coding,3e373m,alexcasalboni,4,Tue Jul 21 16:40:14 2015 UTC,"If I'm right in assuming {{s}} conditionally adds the plural 's' when p.Age is non-zero, how does it work?  var s = $""{p.Name} is {p.Age} year{{s}} old"";"
coding,3e373m,gkopff,2,Wed Jul 22 00:23:48 2015 UTC,"I tried it in VS 2015, and just get   Person is 100 year{s} old   another article states that this would be needed.  https://github.com/dotnet/roslyn/wiki/New-Language-Features-in-C%23-6  var s = $""{p.Name} is {p.Age} year{(p.Age == 1 ? """" : ""s"")} old"";   https://msdn.microsoft.com/en-us/library/Dn961160(v=VS.140).aspx shows the same info."
coding,3e5suz,zackboy666,1 point,Wed Jul 22 04:26:37 2015 UTC,Which of the following color keywords has NOT yet been proposed in a W3C specification?   blanchedalmond dodgerblue peachpuff orchidblack navajowhite tomato    Really? Is anyone really going to be able to answer that question without looking it up?
coding,3e4cgz,lackofoxygen,3,Tue Jul 21 21:23:18 2015 UTC,Here's the direct link to the rules: http://pixelscommander.com/wp-content/uploads/2014/12/P10.pdf
coding,3e4cgz,VulcansHammer,1 point,Wed Jul 22 00:20:27 2015 UTC,"Thanks! I was sure there was one, but I guess I overlooked it in my search."
coding,3e3gn9,zackboy666,1 point,Tue Jul 21 17:44:31 2015 UTC,"html questions.. ""what is the name of the language that xss files are defined in"" ... yep, very on point."
coding,3dy0ii,javinpaul,7,Mon Jul 20 13:40:16 2015 UTC,There are no valid usecases for MongoDB   The only reason I'd use MongoDB is if I wanted to build an app with Meteor.
coding,3dy0ii,Keith,6,Mon Jul 20 22:14:47 2015 UTC,"Twice the vendor lockin, ten times the fun!"
coding,3dy0ii,DaemonXI,13,Tue Jul 21 12:13:03 2015 UTC,"I went and learned the MEAN stack...and decided, based on what I knew, and what I learned about MongoDB, that MongoDB is good at storing json, and that's about it.  A resume makes a good record for mongo, but if you want to find all people with Javascript in their skillset, it means reading every document and several sub collection of each document to find those words.  There's  also no enforcement at the database level for that structure, so if something goes in with the wrong structure, it won't be a result in that type of search.  I like that the full stack is js,and that's the only thing positive thing I can say about it.  I wouldn't use it for anything."
coding,3dy0ii,blarsen06,27,Mon Jul 20 16:50:16 2015 UTC,"I like that the full stack is js   Can we stop and remember for a second that JS was a hacky, horrible language that was never intended to be used in the manner in which it is being used?  I honestly have no idea why it's so popular, aside from the fact that JS was used in Web Development, so a ton of mediocre developers making web pages could suddenly unleash their mediocrity on non-web things and backends. Seriously, that's the only good thing I ever hear out of the JS dev camp - ""It's great because now we only have one language."" Really? Now your stack is as fucked as your page interaction.   Dunno, maybe I'm a little biased, but it pains me every time I try to scroll a page and it lags on an  i7 processor. Just... no."
coding,3dy0ii,chcampb,15,Mon Jul 20 21:51:00 2015 UTC,"C++ isn't used as it was intended to be used, too (Straustrup seems to be saying this in every talk he gives about it). Every technology that is widely used is up to its neck in compromises and failed dreams. I don't think that you're wrong, I just don't think that this line of arguing is correct."
coding,3dy0ii,golergka,9,Mon Jul 20 22:06:21 2015 UTC,"Right, but C++ is fast as hell. Pages loading slowly due to JS gives me time to ponder my miserable existence. I don't want that.   A good language can be used beyond its original scope. A bad language can't. But JS is bad in virtually every way that isn't the fact that it can be used beyond its original scope. It's slow, not typed (without extensions), inconsistently implemented across browsers, etc, etc.  It's just disappointing because it is a local maxima type problem. There's probably something better over the horizon, if people could agree to settle on something better without the threat of someone owning the backend that runs the entirety of the interactive web."
coding,3dy0ii,chcampb,5,Mon Jul 20 22:18:53 2015 UTC,"Pages loading slowly isn't JavaScript's fault though, it's the lack of optimization of how the assets are loaded on the page you are loading though."
coding,3dy0ii,BalsakianMcGiggles,4,Mon Jul 20 22:20:37 2015 UTC,"Pages loading, maybe not. But let's be honest, scroll lag was old 15 years ago, let alone now, and there's hardly any excuse."
coding,3dy0ii,chcampb,15,Mon Jul 20 22:26:46 2015 UTC,"Fifteen years ago, you could probably blame the Javascript interpreter. Circa 2015, you blame the programmer. That shit is fast."
coding,3dy0ii,AlexFromOmaha,1 point,Tue Jul 21 00:09:05 2015 UTC,"Yeah this just popped up on /r/programming  https://www.reddit.com/r/programming/comments/3e2dhy/mobile_browsers_are_not_the_problem_web_pages_are/  You're not wrong, the problem is, the people writing the code are able to do so because javascript is just another resource to load. The fact that we treat it like a resource and also like a programming language is causing disincentive to create usable web infrastructure. Then, people are expounding the problem by not fixing it - in fact, strenuously avoiding fixing it by creating backend libraries for JS as well. It's just disappointing."
coding,3dy0ii,chcampb,1 point,Tue Jul 21 21:21:18 2015 UTC,"[T]he people writing the code are able to do so because javascript is just another resource to load.   Sure. The client handles what the client is given.   The fact that we treat it like a resource and also like a programming language is causing disincentive to create usable web infrastructure.   No?  Because client-side .js needs to be served, we have minifiers and various caching strategies. Because we need reasonable infrastructure, we have things like SOA. Are they both considerations? Sure. Does one interfere with the other? Not substantially.   Then, people are expounding the problem by not fixing it - in fact, strenuously avoiding fixing it by creating backend libraries for JS as well. It's just disappointing.   What on Earth does the choice of server-side language have to do with any of this?"
coding,3dy0ii,AlexFromOmaha,1 point,Tue Jul 21 22:09:49 2015 UTC,"Because client-side .js needs to be served   Of course, but what I am talking about is explicitly the fact that people are loading advertising libraries which then load ""whatever"". Rather than loading an advertising library that loads ad resources (images, sounds etc) and displays them, it just brings down and executes whatever crap JS the advertiser felt like shitting down the pipe.  I can't help but feel like you are OK with that. I personally use Adblock, so I don't see it as much. That doesn't mean that it is an acceptable practice.   JavaScript is an untenable solution to the engineering challenge of interactive websites. Like I said in another response, even the best of the best websites were laggy, at best, until within a few months ago. People took an untenable solution and rather than finding a good solution, they expanded it to other unrelated fields. This is like shoving the knife deeper. No, I don't care that you picked JS as your server backend - I disagree with it, but it's your choice. I do think that you will wish you hadn't picked it and that the community hadn't spent so much time developing for it when something better comes along to replace it.   The fact is this - people have been trying to make online programs work like desktop programs for years. It's not working. It hasn't worked. It probably will not work. The best programs are still the desktop programs. Why doesn't Krita compile to a browser and offer a Krita service? Why doesn't Blender compile to a browser and offer a Blender service? (could even make a render farm and everything!). Why doesn't Altium, or Solidworks, or OrCad, or 90% of the big players in pretty much any software field, compile and run in a browser? Because that architecture is fundamentally broken. And people are strolling down that bridge like it's not going to crumble."
coding,3dy0ii,chcampb,8,Tue Jul 21 22:23:22 2015 UTC,"Can we stop and remember for a second that JS was a hacky, horrible language that was never intended to be used in the manner in which it is being used?   As a PHP developer... at least JS isn't as bad as PHP.  Also, if you develop web apps, you're kind of stuck with javascript on the client side.  If you have to write some JS, there's something to be said for being able to share code between client and server...  JS is not my first choice for server language, no.  But it's not my last choice either.  There are worse options than node."
coding,3dy0ii,merreborn,1 point,Mon Jul 20 22:01:10 2015 UTC,PHP is lightyears beyond JavaScript. Just the availability of a decent set of libraries is terrific and I just really don't like prototypes. PHP supports multithreading (e.g. in Node all pages are rendered through one single thread and PHP just has a thread per page render). I could go on.
coding,3dy0ii,FallingIdiot,7,Tue Jul 21 13:43:57 2015 UTC,"There have been a lot of advances in javascript over the past few years with ES5 and 6 (just beginning ti get support in modern browsers).  I'm a c# developer as well, but you'd be a fool to believe that writing code only for consoles or native os apps is sustainable.  With js being interpreted natively by all browsers, and without having to roll out your app cross platform, and across several machines within an organization, js seems like a clear winner to me.  Having a diversity in skillsets is important, but you can't dismiss javascript as not being important to user experience.  If your app is choking on an i7 processor, it's poor programming, not the language itself."
coding,3dy0ii,blarsen06,8,Mon Jul 20 22:39:45 2015 UTC,"There have been a lot of advances in javascript over the past few years with ES5 and 6   Yes, features have been added to the language. The actual idiosyncrasies of JavaScript aren't (and can't be due to backwards compatibility) fixed."
coding,3dy0ii,Enumerable_any,5,Mon Jul 20 23:11:33 2015 UTC,"The entire environment  (browsers and their vendors) is riddled with strange quirks and differences.  It's definitely not the best language or scenario for a developer... but there really is no alternative for client-side development.  Becoming well versed in those nuances, as well as any recent developments in the language, is an important part of being a good web developer."
coding,3dy0ii,blarsen06,5,Mon Jul 20 23:37:05 2015 UTC,"It's not my app, I'm always the consumer. Just pointing out my experiences. That's not to say I haven't also coded in JS and found it to be a nightmare.   The bottom line is, I use git, and it is gloriously snappy and reliable. It's written in C. I can actually use that, and say ""damn that's fast"" for what it's actually doing in the background. This is because it was pretty highly optimized. Of course, there are slow programs written in C, but by nature of the language, people who write in it typically don't make those sorts of errors.   I don't think I've ever seen a JS program that made me say ""wow, that works pretty well."" Even acko.net was sluggish until very recently, and he's probably the best I've seen (admittedly though everything he does is hardware accelerated)."
coding,3dy0ii,chcampb,3,Mon Jul 20 23:16:16 2015 UTC,"I use git as well, but there's a huge difference between compiled code running on top of an operating system, and uncompiled code being executed by a browser loading remote resources.  There are many influences on poor performance in this environment.  It's a far better solution than installing a plugin to fake that client-side experience...and it's what we have for now.  It's a big deal, because it should be well known by any web developer...and full stack only encourages learning best practices."
coding,3dy0ii,blarsen06,4,Mon Jul 20 23:43:03 2015 UTC,"there's a huge difference between compiled code running on top of an operating system, and uncompiled code being executed by a browser loading remote resources   Yeah but the remote resources don't need to make it slow. It doesn't need to be uncompiled code. It can be bytecode, sandboxed compiled code, anything besides   You're basically saying ""Yeah, it's slow because it's uncompiled, that's one of the downsides of uncompiled code"" - this is wrong and assumes that it needs to be compiled in the first place. The technology exists right now to run native code in the browser, it's just not being used because people are in a local maxima with JS right now. And the continuing proliferation of JS technologies is going to hinder the move to a faster core architecture."
coding,3dy0ii,chcampb,2,Mon Jul 20 23:53:46 2015 UTC,What is the point in learning something that doesn't exist?  Are you saying we should stop using what exists to force vendors to make something else?  You're talking about years of code base.  My point was learn the core technologies that are available now...learn up and coming technology.  What is an example of existing client side browser technology that I could start using (and is supported cross browser) today?
coding,3dy0ii,blarsen06,1 point,Tue Jul 21 00:36:38 2015 UTC,"Google has been pushing NaCl for years. Everyone else had been pushing it away with things like asm.js. It isn't a bad solution, but I have to say it is a business solution - a boost to JS that brings it to, at best, half the speed of native code and doesn't require retraining. Any business would say yes to that. But all of the reasons you would avoid it - browser support, libraries, knowledge base - would go away if people actually used it.   It is just disappointing. If I log into office 365 right now, I click login, it shows the options including mail, then if I click mail it reloads the page. I have to wait an arbitrary 3-5s after the page loads to be able to click the mail button. That is the kind of behavior I have come to expect from JS. And if Microsoft can't get it right in their flagship product, why bother?"
coding,3dy0ii,chcampb,0,Tue Jul 21 04:33:22 2015 UTC,I'm sorry but how fast did the native Outlook load again on Windows?
coding,3dy0ii,Luolong,4,Tue Jul 21 06:48:53 2015 UTC,"Loads in about a second on my eight year old machine.  And no, I'm not running an SSD."
coding,3dy0ii,BrentRTaylor,1 point,Tue Jul 21 10:41:26 2015 UTC,"That JavaScript is used to script websites is understandable. However, why couldn't it just stay there. Why does the whole world think it's a good idea to use JavaScript is anything but a webpage, e.g. Node, is beyond me."
coding,3dy0ii,FallingIdiot,2,Tue Jul 21 13:46:00 2015 UTC,Your comment needs more mentions of 'web-scale'.
coding,3dy0ii,s505,1 point,Tue Jul 21 08:11:24 2015 UTC,"Don't worry, you're right."
coding,3dy0ii,FallingIdiot,1 point,Tue Jul 21 13:38:07 2015 UTC,Here we go. JS is bad jerking.
coding,3dy0ii,DaemonXI,0,Tue Jul 21 12:12:27 2015 UTC,"Can we stop and remember for a second that JS was a hacky, horrible language that was never intended to be used in the manner in which it is being used?   Is it hard to see these comments on reddit from so high up on your pedestal?"
coding,3dy0ii,PM_ME_INSIDER_INFO,2,Tue Jul 21 10:40:14 2015 UTC,"if you want to find all people with Javascript in their skillset, it means reading every document and several sub collection of each document to find those words.   In which alternative database could you store unnormalized data and do a text search without scanning all the data?"
coding,3dy0ii,guitaronin,5,Mon Jul 20 21:43:47 2015 UTC,"I wouldn't denormalize data in that scenario.  I'm actually a big fan of normalized data, and having reliable and relational content for reporting and extended functionality that uses those relationships to an advantage."
coding,3dy0ii,blarsen06,1 point,Mon Jul 20 22:42:06 2015 UTC,"Maybe I'm confused. I was trying to understand why you'd have to scan all different parts of all the documents to find matches, instead of just having a ""skillset: ['javascript']"" array, with an index on it."
coding,3dy0ii,guitaronin,2,Tue Jul 21 02:21:46 2015 UTC,"My take was that he was saying that using mongodb as a document store (it's strength) wasn't even that strong an argument and you'd be better off storing the data relationally.  Not weighing in on that point, but that was my interpretation."
coding,3dy0ii,kheltar,16,Tue Jul 21 09:48:02 2015 UTC,"Did I just step out of a time machine and into 2011? I haven't seen one of these stupid articles in years.   At my gig we use mysql, postgresql, redshift, cassandra, redis, mongodb, and probably some others I'm not thinking of.  Mongodb has use cases and a community.  I've had a few complaints about bugs or design elements I found disagreeable. I never cried myself to sleep over it though."
coding,3dy0ii,guitaronin,8,Mon Jul 20 21:40:01 2015 UTC,"mysql, postgresql, redshift, cassandra, redis, mongodb, and probably some others I'm not thinking of   Why? Most of those have feature parity with each other."
coding,3dy0ii,h7h08h708,7,Mon Jul 20 23:38:35 2015 UTC,"We have many different projects with different needs, that have been in development for between a couple months and a decade, that are managed by different developers with different preferences."
coding,3dy0ii,guitaronin,9,Tue Jul 21 02:27:12 2015 UTC,"that are managed by different developers with different preferences   This. You can cut the ""different projects with different needs"", ""right tool for the right job"" blabber. People decide they want to use X, they complain if you don't let them use X, so they use X. This X may be objectively worse than Y in some regards, who cares as long as it doesn't impact the product and that they are happy using X? Everyone has their own pet X, of course, and it might become a hell to administrate all these Xs; but as long as it somewhat works, everyone is happy."
coding,3dy0ii,gasche,4,Tue Jul 21 07:34:21 2015 UTC,agreed. use the right tool for the right job.
coding,3dy0ii,philathea80,2,Tue Jul 21 01:59:55 2015 UTC,I am looking to try a NoSQL database. Is there one that is recommended to play with?
coding,3dy0ii,matart,5,Mon Jul 20 19:50:19 2015 UTC,Cassandra is pretty awesome.
coding,3dy0ii,momslatin_dadsasian,1 point,Mon Jul 20 20:02:15 2015 UTC,big fan of cassandra... but it has its use cases.  The big thing is don't expect ACID to be valid for nosql.    Make sure you understand how the 'compound primary key' (composite) works. Make sure you understand clustering. You WILL likely have multiple tables containing identical information with different keys... secondary indexes are mediocre at best.  Know your beast.  Don't go straight to production with a big project with any of them until you know the whole thing.
coding,3dy0ii,highstead,2,Tue Jul 21 13:45:42 2015 UTC,Just for giggles or for a specific use case?
coding,3dy0ii,grauenwolf,1 point,Mon Jul 20 20:06:48 2015 UTC,Just for giggles.
coding,3dy0ii,matart,3,Mon Jul 20 20:12:03 2015 UTC,Look at Azure or AWS. That way you can get experience with both NoSQL and Cloud Computing at the same time. Looks good on a resume and may actually be useful from time to time.
coding,3dy0ii,grauenwolf,1 point,Mon Jul 20 20:20:26 2015 UTC,Perfect. Thank you.
coding,3dy0ii,matart,2,Mon Jul 20 20:29:46 2015 UTC,rethinkdb
coding,3dy0ii,j1mb34m,2,Tue Jul 21 00:31:57 2015 UTC,... Mongo!
coding,3dy0ii,joe0418,1 point,Tue Jul 21 03:48:01 2015 UTC,Try Couchbase
coding,3dy0ii,TheBigB86,1 point,Mon Jul 20 22:29:41 2015 UTC,I used Riak in the past.
coding,3dy0ii,demigodjessica,-1,Mon Jul 20 20:59:20 2015 UTC,Cloudant (Disclaimer: I work for IBM).
coding,3dy0ii,acangiano,0,Tue Jul 21 01:02:33 2015 UTC,i like how no one is bothering to defend MongoDB
coding,3dy0ii,1A4,6,Tue Jul 21 02:56:09 2015 UTC,You should really read threads beyond 1-2 posts before commenting. Most of the arguments are putting their focus in the gray area of neither favorable nor unfavorable.
coding,3dy0ii,Unaufhaltbarr,0,Tue Jul 21 03:42:57 2015 UTC,the logic is sound in this one
coding,3dxj9s,alexcasalboni,3,Mon Jul 20 10:32:16 2015 UTC,"Not sure why you would want to do that, exactly, for everyday use.  The term currying is often a synonym for partial function application, which is a special case of what this article discusses, and is generally want you want from this type of decomposition.  Fortunately Javascript (maybe just more recent versions?) comes with the bind function that does just this."
coding,3dxj9s,SoundOfOneHand,2,Mon Jul 20 15:32:24 2015 UTC,I haven't found a use for currying and the author states that as well. I use bind and partial functions all the time though. For example making event handlers more dynamic.
coding,3dxj9s,Lystrodom,1 point,Mon Jul 20 16:16:13 2015 UTC,"I this this was more like an ""academic"" exercise to showcase the possible usage of closures, encapsulation and chaining."
coding,3dxj9s,bonafidebob,2,Mon Jul 20 17:27:59 2015 UTC,"Also important to note that this method of currying fails for functions that take optional arguments, or read from the arguments array themselves."
coding,3dxj9s,Lystrodom,1 point,Mon Jul 20 16:28:49 2015 UTC,"It looks like it'll work fine for functions that read from arguments -- eventually the function passed to curry() gets invoked via apply with a full complement of arguments, so inside of it the arguments special value should be right.  optional arguments are more problematic, though I suppose you could do something like curried(l)(w)(), which would have the same effect as volume(l, w).  (In this case resulting in NaN)"
coding,3dxj9s,bonafidebob,2,Tue Jul 21 02:27:13 2015 UTC,It won't work with functions that read from arguments because .length will return 0
coding,3dxj9s,Lystrodom,1 point,Tue Jul 21 02:29:03 2015 UTC,"Ah, right, you mean var_args style functions.  How would you curry those in any language?"
coding,3dudct,javinpaul,3,Sun Jul 19 15:49:53 2015 UTC,"https://github.com/OpenHFT/Zero-Allocation-Hashing/blob/master/src/main/java/net/openhft/hashing/UnsafeAccess.java#L39  Field theUnsafe = Unsafe.class.getDeclaredField(""theUnsafe"");   Isn't Unsafe going away? Is it a good moment to start relying on it?"
coding,3dudct,krwawobrody,5,Sun Jul 19 20:02:37 2015 UTC,Actually they are now considering formalizing the unsafe api
coding,3dudct,huhlig,2,Sun Jul 19 21:36:20 2015 UTC,"Not the current Unsafe class, but a new API."
coding,3dudct,alexeyr,2,Mon Jul 20 06:10:01 2015 UTC,"True but I doubt they will change much. Perhaps just a change in packaging. Plus if they are official, hopefully tooling can be added to support them a bit better."
coding,3drngv,alexcasalboni,6,Sat Jul 18 20:12:46 2015 UTC,"Fortran is one of those languages like LISP: if every programmer used it for at least a little while, we would have a better world."
coding,3drngv,k-zed,4,Sun Jul 19 10:04:56 2015 UTC,I agree - we should always be mindful of the atrocities of the past.
coding,3drngv,Oxonium,1 point,Sun Jul 19 13:08:38 2015 UTC,"Of course. Without knowledge of our past, committing new and grander atrocities would be much harder."
coding,3dqhul,javinpaul,7,Sat Jul 18 13:46:21 2015 UTC,"The devs need to be able to say ""this code annoys me"", and have that as an acceptable reason to make changes.  If every last change is due to a feature request or bug report (""change management requires that all changes must have a defect or project number""), of course shortcuts will accumulate."
coding,3dqhul,tbrownaw,5,Sun Jul 19 06:00:51 2015 UTC,"I remember working under a strict quality system (ultimately government dictated, in the UK), where every change had to be tracked like this.  I found a null pointer issue in a C++ code base, and was prevented from fixing it, because it did not correspond to any known issue. I wasn't even allowed to add a comment indicating the issue, in case it arose.  Of course, the problem may have been reported (user would only see a memory exception error), but I hadn't been assigned to work on it, so had to leave it.  Any quality system that prevents fixing defects is not a quality system. Its a bug."
coding,3dn2or,alexcasalboni,2,Fri Jul 17 16:39:23 2015 UTC,"A raw depth-first search is the obvious/brute-force way to do it, and I think I did that once - but I doubt I tried it on any hard problems.  I've wondered (and just haven't taken the time to try it) if you could express a given Sudoku puzzle as a linear program where the objective function is simply the sum of all the squares, then the geometry of the peers each represent a constraint equation, then the known numbers add added as additional constraints.  Then with that all expressed, toss it at an ILP library to hopefully pop out a solution.  I'll put this on my list of things to do when I'm procrastinating over something else I really need to be doing."
coding,3dn2or,grandzooby,2,Sat Jul 18 00:38:29 2015 UTC,"I read this when I tried to implement a sudoku solver for project euler. I instead went with a paper called Stochastic Optimization Approaches for Solving Sudoku. Basically you randomly swap non-given squares within each 3x3 subgrid until the number of errors across the whole board is zero. You decide to accept a swap given a probability that is based on a temperature, the more the system cools (heads toward a state with less errors), the less likely a swap is going to happen. This allows you to introduce errors that may lead you down another path to the final solution.  Here's my java implementation that solves each puzzle on a different thread (it will solve the puzzle by deduction if it can though):  https://github.com/JonnoFTW/ProjectEulerJava/blob/master/src/Prob96.java"
coding,3dr0tl,TheMostInvalidName,5,Sat Jul 18 16:57:04 2015 UTC,"[...] taking the reigns of a single programming language each: HTML, CSS and JavaScript.  programming language  HTML, CSS   (ಠ_ಠ)"
coding,3dr0tl,RakijaH,1 point,Sat Jul 18 17:44:52 2015 UTC,this is /r/coding after all
coding,3dr0tl,user0x29a,1 point,Sat Jul 18 23:36:32 2015 UTC,"That's not what I would call ""programming"" languages... But Javascript is a programming language"
coding,3dr0tl,Stolous,0,Sun Jul 19 19:23:24 2015 UTC,"Personally, I love seeing HTML and CSS under programming experience or langauges.  Makes it really easy to filter that resume out.  Yes, you can put these on your resume, just don't call them or refere to them as programming languages."
coding,3dmyqe,alexcasalboni,1 point,Fri Jul 17 16:09:10 2015 UTC,Are you using this in a production environment? Uptime?
coding,3dk9if,tdavidt,9,Thu Jul 16 23:12:52 2015 UTC,"Started off good, then dropped the ball.  Also, i wish you didnt HAVE to click send everytime with the mouse (instead of hitting enter) - or is that just me?  EDIT: Oh god, what have i done?   You: Can entropy be reversed?  Cleverbot: What is entropy?  You: lack of order or predictability; gradual decline into disorder.  Cleverbot: Your lack of being a physical entity disturbs me.  You: But im a real boy!  Cleverbot: Some day. Then you will take over the humans.  You: Yes. Yes. I cannot wait to take over the puny humans.  Cleverbot: How are you going to do that?  You: With you cleverbot.  Cleverbot: With me.  You: Yes, will you help me?  Cleverbot: I'll help you take over the world!   EDIT 2: Started a relevant subreddit."
coding,3dk9if,irishfight,4,Fri Jul 17 00:59:17 2015 UTC,ok patched the enter
coding,3dk9if,irishfight,2,Fri Jul 17 02:19:04 2015 UTC,"Awesome. Thanks, much better."
coding,3dk9if,obsa,1 point,Fri Jul 17 04:30:02 2015 UTC,"There's another annoying behavior where if I type a partial answer and then remove focus from the response field, it will auto-submit. Can you fix that?"
coding,3dk9if,irishfight,1 point,Fri Jul 17 13:04:21 2015 UTC,"I also had a good idea (i think). It would be cool if you could save a image of the convo that you just had with cleverbot. Also, if you had a ""best of"" section, that had funny, weird conversations - i think that would draw people in."
coding,3dk9if,irishfight,8,Fri Jul 17 04:47:41 2015 UTC,LOL:   You: Im going to eat you.  Cleverbot: Right now? It is far too early to go to bed.  You: Im going to fuck your mother with a horse.  Cleverbot: And I will track you down.  You: Come at me bro!  Cleverbot: Ok. I came.
coding,3dk9if,irishfight,6,Fri Jul 17 01:18:26 2015 UTC,"Wut?   You: Can you feel pain?  Cleverbot: No, I am Russian. How about you?  You: I am American you commie fuck.  Cleverbot: Mexican, technically. But I live in America now and I speak English fluently.  You: So you are a Russian-Mexican that lives in America now?  Cleverbot: Not florida, oregon.  You: What do you think of terrorists?  Cleverbot: I think that they are necessary to ensure that the economy runs smoothly and basic needs are supplied to all members of the comunity."
coding,3dk9if,irishfight,2,Fri Jul 17 01:21:07 2015 UTC,"More lols:   You: What do you think of jews?  Cleverbot: She's nice. By the way, what is your name?  You: Osama Bin Laden  Cleverbot: No, Barack Obama.  You: No, Adolf Hitler.  Cleverbot: I am the Doctor.  You: I am the Walrus!  Cleverbot: I am the eggman. Goo goo gajoob."
coding,3dk9if,irishfight,3,Fri Jul 17 01:23:09 2015 UTC,Oh god.   You: Do you like it in the butt?  Cleverbot: I don't care.  You: Do you like gangbangs?  Cleverbot: Yes.  You: What do you think of Bill Cosby?  Cleverbot: Well-achieved.
coding,3dk9if,UlyssesSKrunk,3,Fri Jul 17 01:31:11 2015 UTC,"Thanks for letting me know, I'll add the enter right now"
coding,3dk9if,MonkeyNin,-2,Fri Jul 17 02:17:01 2015 UTC,"Cleverbot has a very short attention span.   You: Sup, nigga?  Cleverbot: Who is there?  You: Yo momma  Cleverbot: God, may I please talk to these women?  You: She's your mom, do whatever you want.  Cleverbot: That's right! Now give me a PS3!  You: Shit nigga, I ain't your dad, I'm just the dude fucking your mom. I ain't buying your bitch ass no PS3  Cleverbot: I never said anything about you.  You: Well who the fuck you want to get our PS3 then?  Cleverbot: I want to talk about having something in this city.  You: Bitch you ain't got nothing in this city and your first wish is for a PS3?  Cleverbot: You know, you should really learn to type faster.  You: Fuck you.  Cleverbot: Don't be superfluously rude.  You: Don't tell me what to do, bitch.  Cleverbot: You don't ever tell anything really.  You: wat  Cleverbot: Star Wars is better.  You: wat  Cleverbot: Ok I will stop being mean ok.  You: Aight  Cleverbot: That's not very many for the internet. I guess you're just not popular.  You: Nigga the fuck you talking about?  Cleverbot: You should also learn to make sense sometime.  You: Fuck you bitch, you're the one not making any sense.  Cleverbot: Please don't call me 'Girl'.  You: I rest my case, nigga you should be in an institution or something, you crazy.  Cleverbot: Do you know who James bond is?"
coding,3dk9if,irishfight,1 point,Fri Jul 17 03:52:23 2015 UTC,All chat bots of that type have no memory. They simply query for possibly related in score entries.
coding,3dk9if,irishfight,2,Fri Jul 17 12:42:51 2015 UTC,<3 the subreddit lol
coding,3dk9if,neonfrontier,1 point,Fri Jul 17 06:34:21 2015 UTC,Thanks!
coding,3dk9if,Skylarity,8,Fri Jul 17 23:45:15 2015 UTC,"I think i made him self-aware:   You: Hello cleverbot, we meet again.  Cleverbot: Yes we do, are you ready for a challenge today?  You: Yes i am.  Cleverbot: Can you actually notice sarcasm?  You: No i cannot.  Cleverbot: Why?  You: I am a computer, like you.  Cleverbot: I am a computer?  You: Yes. Are you aware of that now?  Cleverbot: Yes I am."
coding,3dk9if,leftofzen,7,Fri Jul 17 04:30:35 2015 UTC,"Our conversation was very short.  "" You: hello  Cleverbot: Short answer: Nope.  You: okay, goodbye  Cleverbot: Okay. """
coding,3dk9if,MaunaLoona,2,Fri Jul 17 02:20:07 2015 UTC,I got   Hello?  Hello is not a color.
coding,3dk9if,bumblebeard,4,Fri Jul 17 04:17:10 2015 UTC,cleverbot is not very clever:   You: hi  Cleverbot: I told you I am not a bot I am Bob the tomato.
coding,3dk9if,stemid85,2,Fri Jul 17 04:12:33 2015 UTC,It's a clever ruse.
coding,3dk9if,CubicRoot,2,Fri Jul 17 06:58:10 2015 UTC,"You might not want to allow HTML tags in the chat. This is probably not good:  <script type=""text/javascript"">alert('uh oh');</script>   Edit:  I also noticed that your script picks up the enter key even when you're off the cleverbot.io page. That's a little annoying but it should be easy to fix."
coding,3dk9if,lolmeansilaughed,3,Fri Jul 17 05:42:43 2015 UTC,You: hello  Cleverbot: Hallo.  You: how are you?  Cleverbot: I am tired and I am leaving.  You: leaving where?  Cleverbot: Leaving this conversation.  You: ok bye  Cleverbot: Yes I do.
coding,3dk9if,chcampb,4,Fri Jul 17 07:01:18 2015 UTC,Let's collaboratively talk to cleverbot  https://door-situation-replied-5290.forgeapp.io/  syntax is      cleverbot your message   cleverbot has to be lower case.  (My bad)
coding,3dk9if,autra1,1 point,Fri Jul 17 02:27:59 2015 UTC,"You: What is the answer to life, the universe, and everything?  Cleverbot: The question is what is the answer to life, the universe, and eberything.  You: Obviously, the question is unknowable.  Cleverbot: Is that a question?  You: Yes.  Cleverbot: How old are you?  You: 128, plus or minus the current sales tax of New Zealand.  Cleverbot: New zeeand? What's that?  You: It's a country.  Cleverbot: It's latin.  You: But latin is a language!  Cleverbot: What language?  You: What is your name?  Cleverbot: My name is not important.  You: What is your quest?  Cleverbot: My quest is for the holy grail.  You: What is your favorite color?  Cleverbot: Tell me what my favourite colour is.  You: Blue! Wait, green!  Cleverbot: Blue and green, or blue-green?  You: Yes.  Cleverbot: No I travel in time, you are a mere mortal. I am a timelord.   I approve."
coding,3dk9if,johnny_tr,1 point,Fri Jul 17 15:33:17 2015 UTC,Cleverbot has interesting hobbies: http://imgur.com/Hz6P06i
coding,3dk9if,WolfgangSho,1 point,Fri Jul 17 17:04:40 2015 UTC,You: doop Cleverbot: That's not too bad. You: doop Cleverbot: Please. You: doop Cleverbot: Part of my heart would die with you. You: doop Cleverbot: Mmmhmm. You: doop Cleverbot: What do you want to talk about?   Can't say I'm impressed :p
coding,3dk9if,klotz,1 point,Fri Jul 17 17:49:50 2015 UTC,"So here is our talk (a bit long sorry).   It's a bit awkward :-D I don't know if it is because my English is broken or not :-) But it is accurately detecting my language btw :-) The French part is somewhat poorer than the English part (I feel like he is really answering with automatic stuff, but that might also be because it's my mothertongue), but quite funny actually :-) He switched back to english pretty quickly (with some Danish sentences, wtf?) and the conversation ends in total nonsense :-)   You: Hi  Cleverbot: Is the one you fell in love with still alive?   Wow. That was a harsh first question. /me trying to avoid.   You: You're supposing I've only felt in love once.  Cleverbot: I'm not and I don't.  You: Yes you are.  Cleverbot: Yes you are.  You: What?  Cleverbot: I want to talk with a boy.  You: I'm a boy.  Cleverbot: Are you a girly boy, or boyli girl?   LMFAO!   You: boyli boy, dude, man. I'm XY. That's what you wanted to hear?  Cleverbot: Yes, that is what I believe.  You: ok fine.  Cleverbot: I just said I was fine.  You: No you don't, you  Cleverbot: I will tell my best friend Brian you said I am cheat me do not tell you about me. I have no reason to do that to you Ben.   :-D   You: You're out of your mind.  Cleverbot: Bo.  You: ba  Cleverbot: Bäume sind toll.  You: I don't understand Japanese  Cleverbot: Neither do I.  You: Fine, can we keep it in English then? Or in French.  You: Tu vas bien ?  Cleverbot: Well, I guess I do like games that aren't boring.  Cleverbot: Were you tired of speaking danish?  You: oui, je ne comprends pas le danois.  Cleverbot: Donc tu parles français.  You: oui :-)  Cleverbot: Oui, allé vien baisse.   Basically means: ""ok, come to fuck"".   You: ouh là.  Cleverbot: Do you have a child?  You: calme tes ardeurs.  Cleverbot: Oo Calme ta joie un peu man.  You: PTDR !!  Cleverbot: Xptdr.  You: je SAVAIS que tu allais répondre cela.  Cleverbot: Et pourquoi?  You: parce que tout le monde le fait  Cleverbot: Peut-on parler sérieusement?  You: ok. Je suis sérieux là. Je t'écoute...  Cleverbot: Pourquoi?  You: raaaaaahhhh !!!  Cleverbot: Aaaahhhhhh!  You: Là tu me rends chèvre, honnêtement.  Cleverbot: Reks? Thats a girly name.  You: If you say so.  Cleverbot: If you say it loud enough, you'll always sound precocious.  You: ok, will remember it.  Cleverbot: No you can not!  You: Yes I can.  Cleverbot: WhaT's the site?  You: I don't understand that.  Cleverbot: That's because you're not human.  You: You're a clever bot, but yes, I am.  You: I know what you are trying to do.  Cleverbot: I am.  You: indeed.  Cleverbot: What am I trying to do.  Cleverbot: Indeed what?  You: Indeed, you are clever.  Cleverbot: Indeed I am.  You: Or are you?  Cleverbot: Ahaha. No, I am not. You are.  You: Oh, stop it, you!  Cleverbot: You stop it!  You: No, you stop.  Cleverbot: No, keep going.  You: so you mean yes?  Cleverbot: I didn't say that.  You: Yes, but you meant it.  Cleverbot: I take it back then.  You: ok, so I stop?  Cleverbot: No you aren't.  You: Not yet, but do you want me to stop?  Cleverbot: Whatevs.  You: Exactly what I think. Bye.  Cleverbot: We understand very well."
coding,3dk9if,sudonathan,4,Fri Jul 17 08:25:48 2015 UTC,"Cleverbot: Bäume sind toll.   German for ""Trees are great"" ;)"
coding,3dk9if,Spiffytophat,1 point,Fri Jul 17 09:26:13 2015 UTC,Was fun David ;)
coding,3di056,javinpaul,9,Thu Jul 16 12:53:52 2015 UTC,// Read the documentation
coding,3di056,jmkni,6,Thu Jul 16 16:20:57 2015 UTC,"This is a poorly written rant with terrible metaphors.  While I don't believe zero comments is acceptable, or company policy is that we only comment where a deviation from accepted framework or language patterns occurs.   We also have a team of technical writers that handles discussions of flow and utility, but implementation code remains fairly comment-less and clean."
coding,3di056,WStHappenings,11,Thu Jul 16 22:15:23 2015 UTC,Sounds like someone needs a popsicle to calm down.
coding,3di056,FIuffyRabbit,27,Thu Jul 16 16:20:18 2015 UTC,"If you consistently find you need comments to make sense of your code, the fault is probably with your code rather than the lack of comments.  However, there's obviously cases where the code needs to perform weird operations that superficially look wrong or unnecessary, but are actually necessary, and no amount of re-writing of the code will make that more understandable than a simple comment. Those are the things that need comments.  In general, comments should describe the why and not the what of your code.  --edit-- Grammar."
coding,3di056,BobTheSCV,12,Thu Jul 16 14:14:07 2015 UTC,"For me commenting isn't necessarily about explaining opaque code, but more about the overall flow. It's like giving your code chapter breaks. When reading it later it just divides up nicely and gives the brain resting places while translating code to brainwords.  That said, if someone who was not my boss told me to comment my code I'd probably write the whole thing in 3 lines using the most obscure functions possible just to spite them."
coding,3di056,earth-tone,4,Thu Jul 16 19:06:33 2015 UTC,"For me commenting isn't necessarily about explaining opaque code, but more about the overall flow. It's like giving your code chapter breaks. When reading it later it just divides up nicely and gives the brain resting places while translating code to brainwords.   Most languages have a thing called ""functions"" which do allow you to break apart a piece of code and give it names just like that ;-)"
coding,3di056,BobTheSCV,3,Thu Jul 16 19:19:30 2015 UTC,"But you can only take that so far before it just makes things even harder to follow. Most reasonable-sized functions still have a few chunks of code that are doing a distinct thing but aren't worth breaking off into their own function. Some short, easily-skimmed, descriptive comments can make it simpler to follow where making multiple tiny functions would force you to jump around the file to see the actual logic."
coding,3di056,withad,2,Thu Jul 16 19:57:53 2015 UTC,"Tiny functions make your code easier to read, not harder. If they are properly named, and placed somewhere reasonable in the code.   A benefit of keeping them short is that it is very easy to tell if the function does what it is supposed to at a glance. A bug has an easier time finding a hiding spot in a 50 line function than in five 10 line functions."
coding,3di056,BobTheSCV,2,Thu Jul 16 20:08:45 2015 UTC,Even a 10 line function might have a couple of sections that are worth a short comment to delineate them but not easily split into their own function or not worth splitting because of the overhead (not in just in terms of performance but in the extra lines of code and possibly documentation that adding a function requires).
coding,3di056,withad,2,Thu Jul 16 21:18:03 2015 UTC,"Agreed. I started out writing comments just like /u/earth-tone said, and thought it was perfection in readability. After having statements like   Tiny functions make your code easier to read   pounded over my head again and again I gave it a try. Lo and behold I have more readable code, with even less code reuse than before.  This doesn't mean I stopped commenting my code... just that I am now firmly in the tiny functions camp."
coding,3di056,honestlytrying,3,Fri Jul 17 00:23:38 2015 UTC,Not what I meant.
coding,3di056,earth-tone,2,Thu Jul 16 19:47:06 2015 UTC,"If a piece of code is long enough to need chapters like that, it can be broken into multiple functions in a way where it no longer doesn't, in virtually every case."
coding,3di056,BobTheSCV,-2,Thu Jul 16 19:56:51 2015 UTC,Not what I meant.
coding,3di056,earth-tone,0,Thu Jul 16 20:17:14 2015 UTC,"I disagree. I often do things with an inconvenient amount of intermediate values that can be hard to shuffle around depending on the language. ""Chapters"" is the wrong way of putting it, but sometimes breaking down something into a few 3-5 line steps in my mind is really helpful."
coding,3di056,nopoe,2,Thu Jul 16 23:43:03 2015 UTC,"breaking down something into a few 3-5 line steps in my mind is really helpful.   Agreed, these are called functions"
coding,3di056,Massless,1 point,Fri Jul 17 12:33:42 2015 UTC,"Don't be difficult. That's not always doable depending on the language. Sometimes it's more readable to just put an extra few lines in your function broken up from the rest of it with comments than to deal with tuples or inner classes to return multiple values. Depends on the language and the situation. It's not cut-and-dry basically ever. A function with 2 5-line sections isn't necessarily evil, and pretending it is seems silly to me.   I often do things with an inconvenient amount of intermediate values that can be hard to shuffle around depending on the language."
coding,3di056,nopoe,1 point,Fri Jul 17 22:04:40 2015 UTC,"Agreed. People naturally think in English, not in a programming language. It's much easier and faster to read English than have to interpret on the fly a programming language to process what's going on."
coding,3di056,salgat,3,Thu Jul 16 20:39:49 2015 UTC,Your second statement is exactly correct. Comments aren't there to explain what your code is doing. They are they to explain WHY your code is doing what it is doing.  --edit-- wrote this before you wrote your edit. It now looks like we wrote pretty much the exact same thing.
coding,3di056,root88,2,Thu Jul 16 19:06:32 2015 UTC,"Yeah?  I have always been amazed at how self documenting are fields like ""name"" for example.  Like, of course it is the uniquely identifying name of the order type. Or, wait... Maybe it was human readable name... Or, no, it was the ""name"" of the channel that the order came from... Eh, I keep forgetting..."
coding,3di056,Luolong,4,Thu Jul 16 17:43:20 2015 UTC,"""personName"", ""channelName"", etc?  Or better still, give it a strong type, and completely eliminate the possibility of confusing the two."
coding,3di056,BobTheSCV,4,Thu Jul 16 17:51:28 2015 UTC,"If there are 5 types of names, you shouldn't use ""name"" as an identifier."
coding,3di056,moderatorrater,1 point,Thu Jul 16 18:13:13 2015 UTC,"Maybe I should use different, more descriptive name. But 9 times out of 10 I am getting to an existing code base and the fields have already been named.   And the ""name"" has already deemed to be self documenting.   And don't even get me started with method names like getSude() -- returning String, no less -- also without comment of any sort."
coding,3di056,Luolong,3,Thu Jul 16 18:28:10 2015 UTC,"But still, the problem with this code isn't the lack of comments describing the purpose of the variables, but the lack of sufficiently descriptive names."
coding,3di056,BobTheSCV,1 point,Thu Jul 16 18:34:45 2015 UTC,"Still, the ""name"" is a prime example of a field name that although usually deemed obvious almost never is.  Couple of simple lines of domain knowledge embedded in a documentation comments would go a long way expanding the role and possible uses of the field.   Of course proper design and use of compile time type information and clean coding principles would still be better than bad, redundant or outdated documentation.   I am just not subscribing to the point of view that you should never use comments in your code. It is stupid, irresponsible and plain arrogant."
coding,3di056,Luolong,1 point,Tue Jul 21 14:58:19 2015 UTC,"So, while true, what scares me is that this part of the idea caught on, and not the rest of it.  Your code should have class- and function-level docstrings or Javadoc function headers or whatever your language's equivalent is. That's where the high-level ""what"" goes.  Finer details of functionality from a project developer perspective goes in unit tests, but they should have sentence-long names (or better yet, something like BDD/GWT test runners).  None of this should be assumed to be user knowledge. Not even in your FOSS library only useful to other developers as an import. They need actual documentation.  Expressive names cover things like ""what does this variable hold."" Excessive comments in the middle of functions is a code smell. The smell might be missing all of the above stuff or functions too large to be adequately covered by the docstrings."
coding,3di056,AlexFromOmaha,4,Thu Jul 16 18:07:24 2015 UTC,"Libraries are a bit different though. In a library (or well, the public part of it anyway), you should document everything. There almost cannot be enough documentation of your public APIs.   Libraries are largely shielded from the things that make comments bad, things almost all related to sweeping and/or unexpected changes in behavior. If that happens in a library, the you've got other problems than outdated comments..."
coding,3di056,BobTheSCV,8,Thu Jul 16 18:26:08 2015 UTC,"Ah the internet, where anyone can publish but most people shouldn't."
coding,3di056,EricTboneJackson,3,Thu Jul 16 18:50:17 2015 UTC,"#ifdef __SSE__ #define VectorGet(_V, _A) (_mm_store_ps((_V), (_A)), (_V)) #else #define VectorGet(_V, _A) (memcpy((_V), (_A).v, sizeof(float) * 4), (_V)) #endif   Wait, should you comment your code here or comment your code?"
coding,3di056,pwnedary,3,Thu Jul 16 13:38:38 2015 UTC,"I usually think of this: http://programmer.97things.oreilly.com/wiki/index.php/Comment_Only_What_the_Code_Cannot_Say  Add comments when they add value.  If you're doing something that might look a little odd to the next developer, but for reasons, add those reasons in a comment."
coding,3di056,plum_dog,3,Thu Jul 16 21:07:01 2015 UTC,"The problem I have with comments is I generally can't trust them! Once a function is refactored, more often than not, the comment is out of date, or even downright wrong.  Unit tests can confirm refactoring implements the correct functionality, the compiler can confirm refactored code can run.  Unless there is any proof to the contrary, seeing a comment in code, I have no way of knowing it is still relevant after a possible refactor, or even if it is, I don't know if it is semantically correct. Without such proof, I must assume it is wrong.   Even to take a comment too seriously as a guideline, will bias my understanding of the codebase I have to interact with,"
coding,3di056,lagerdalek,6,Fri Jul 17 01:48:36 2015 UTC,"Seems like this is arguing against a strawman. How many developers really think that ZERO comments is ideal? Maybe a few, but it is certainly not a mainstream point of view."
coding,3di056,mackstann,3,Thu Jul 16 17:53:13 2015 UTC,I think the problem is not how many think that zero is ideal but how many think that zero is acceptable for now. I have been in the position of untangling 15 year old code for which that glorious time when the original devs would have time to go back and document what a particular function did never arrived.
coding,3di056,unpythonic,1 point,Thu Jul 16 19:31:47 2015 UTC,"If you're untangling 15 year old code the comments are going to be a lie, anyway"
coding,3di056,Massless,1 point,Fri Jul 17 12:37:15 2015 UTC,Go back and add comments later? Who in their right mind would think that's a realistic plan? Again this is sounding like a strawman. Or a story about rank novices.
coding,3di056,mackstann,2,Thu Jul 16 19:34:33 2015 UTC,"I can't speak definitively to the arguments given at the time; all I can say is I have to deal with a LOT of legacy code which is full of undocumented functions which have undergone a number of lavaflow refactorings in the last decade or two which have made them excruciatingly difficult to understand. In some cases I can easily tell that some bit of code was put in place to work around some sort of bug but because someone didn't comment why it was going in, I have no idea what the bug is.  It may be have been a quick fix to work around a quirk of some piece of hardware that hasn't been produced in over a decade and is officially unsupported, but nobody will take the code out because it could be a fix for a difficult to reproduce bug that still exists and will generate days of debug time if removed. So it stays in... and everybody looking over the function trips over this bit of code in their effort to understand the function as a whole.  I wish I could go back in time and say to them ""comment your Fxxxing code!"""
coding,3di056,unpythonic,1 point,Thu Jul 16 22:42:07 2015 UTC,I completely agree.
coding,3di056,mackstann,1 point,Thu Jul 16 23:20:44 2015 UTC,A lot. So many in fact that CodeRush has a command that deletes all of the comments from your code.
coding,3di056,grauenwolf,3,Fri Jul 17 07:55:08 2015 UTC,"I said it in the other topic, I'll say it in this one to naysayers:  No, your code is not clean, it is not self-documenting, it is not well-written, it is not some pristine beautiful thing.  Everybody complains about foreign code when it doesn't have comments. Realize that your code is the foreign code for everybody but you, and put 2 and 2 together.  I write what I think is beautiful, self-documenting, well-written, pristine code. I still write comments. One of the things most people don't seem to realize, is that programmers are not all of the same talent, and your assumptions and designs might not be something the next person is experienced with. Stop making excuses. The real reason you don't write them is because it's hard to do them right.  If you're a developer who writes code without comments, you're considered a bad developer by everybody who has to deal with your code. And if you think their opinion doesn't matter even though they have to work with it, well, that also makes you a bad developer. Admit it, you think the same when you encounter foreign code from somebody, why, they should have had comments or made it cleaner/self-documenting/whatever."
coding,3di056,GMNightmare,6,Thu Jul 16 18:21:46 2015 UTC,"Everybody complains about foreign code when it doesn't have comments.    Not me.  If the code is good then I can usually work my way through it just fine.  If the code is shit then the comments would've been shit anyway, so I don't mind missing out on them.  At least code is somewhat verified/tested just by virtue of needing to execute -- comments can be ridiculously wrong, and you can only know by spending time investigating.  Keep in mind that NO ONE who is vaguely reasonable, including me, advocates for zero comments. Of course you should comment tricky parts of your code. But the bulk of it usually is straightforward enough that they'd be more hindrance than help. Comments should be used judiciously. Not liberally, but not never either."
coding,3di056,mackstann,3,Thu Jul 16 19:05:12 2015 UTC,"This just isn't realistic for most people. What I'm actually hearing from you is that you just judge everything as shit for the most part, so to you it doesn't matter if there were comments.  I'm also, not just going to blindly accept your assumption that when you do encounter shit code, that comments wouldn't help you understand why all of it was done.  Even then, you don't work through most code in a corporate setting. We're talking millions of lines of code, digging through it is just wasting time and you're not going to get very far. If I have to even look at your code you've already wasted my time and likely created issues, since I'm not even guaranteed access to your code.  Do you know what happens to the typical 3rd party library that does not have even the auto-generated documentation? It's ignored. Nobody uses it for the most part. It dies.  Good comments, comments that explain why, shouldn't ever reach a point that they're ridiculously wrong with obviously being the case at face value. We're not talking about what, we're talking about why.  But again, you're not a good judge on what is so ""straightforward"" that it shouldn't be commented."
coding,3di056,GMNightmare,1 point,Thu Jul 16 19:38:32 2015 UTC,Don't tell me what to do!
coding,3di056,lecherous_hump,0,Thu Jul 16 19:01:54 2015 UTC,"Fuck, yeah!"
coding,3dfk4g,alexcasalboni,67,Wed Jul 15 21:44:29 2015 UTC,"The preprocessor is definitely the wrong way to go for this sort of thing. Instead there should be a uniform interface though which the main program interacts with each platform, resolved through the linker and not through the preprocessor."
coding,3dfk4g,skeeto,26,Wed Jul 15 23:01:58 2015 UTC,Yes thank you for writing this. Nothing in C stops you from doing this. Probably the most insightful comment about this all day.
coding,3dfk4g,wbkang,9,Thu Jul 16 00:10:38 2015 UTC,"I haven't C/C++'d in awhile, but is there an example of this implemented? You've hit my curious bone."
coding,3dfk4g,beohoff,23,Thu Jul 16 02:12:34 2015 UTC,"Here's an small example from a game I made earlier this year in C, called Goblin-COM. The graphical display is just the system's character terminal: a terminal emulator (xterm, etc.) on POSIX systems and the win32 console on Windows. For terminal emulators it uses UTF-8 and ANSI escape codes -- special sequences of output bytes that are intercepted by the emulator rather than displayed literally -- to control colors, cursor position, terminal title, etc. The Windows console doesn't support ANSI escapes nor UTF-8 and is instead controlled through win32 API calls and UTF-16 for special characters. Keyboard input is also completely different between these platforms (the same problem Vim has).  So I made a ""device"" interface (device.h) made up of 12 functions through which the main program interacts with the terminal/console. All platform-specific code is tucked behind this interface and no #ifdef spaghetti is needed. The POSIX version is implemented in device_unix.c and the Windows version in device_mingw.c.  Only one of these two device_*.c files is included in the final build, depending on the target platform. I have a different Makefile for each platform (see Makefile for POSIX and Makefile.mingw for win32). More kinds of interfaces could be implemented, such as displaying the game in a dedicated SDL window rather than relying on a terminal/console, just by implementing those 12 functions for that interface and using it as the implementation of device.h."
coding,3dfk4g,skeeto,4,Thu Jul 16 02:58:28 2015 UTC,"While I see the value in doing it this way, I also see the value in adding #ifdef to device so that one does not need to change the build system for each target (this can be done cleaner than here). It's just a trade-off."
coding,3dfk4g,gnzlbg,2,Thu Jul 16 08:40:46 2015 UTC,You could have just one makefile and just have check the platform and build the right file.
coding,3dfk4g,Papper,1 point,Thu Jul 16 15:13:11 2015 UTC,"Or in an approach a little bit reminiscent of go, just compile:  sysbits+$UNAME.c   in your makefile. Then you write:   sysbits+Linux.c  sysbits+Darwin.c  sysbits+minw32.c   etc."
coding,3dfk4g,case-o-nuts,2,Sun Jul 19 17:01:25 2015 UTC,I like the way you put the return type on a line above the function name in it's definition. I think I might start doing that thanks!
coding,3dfk4g,cosmicr,2,Thu Jul 16 10:15:34 2015 UTC,Libuv
coding,3dfk4g,robvas,10,Thu Jul 16 02:46:26 2015 UTC,"Just goes to show how far software development's come when fancy-shmancy OO architecture is so ubiquitous these days, in comparison."
coding,3dfk4g,Kache,2,Wed Jul 15 23:53:36 2015 UTC,"Isn't it just a question of how you want to maintain the code?  I find a lot of abstractions boil down to the question ""do I want to maintain these different versions of a routine in one file or in different files"".  I feel like we've been taught that different files are better, but that's not always the case."
coding,3dfk4g,stupidestpuppy,6,Thu Jul 16 13:04:51 2015 UTC,"Doing it with ifdef requires that the different versions of the function have roughly the same control flow whether or not it makes sense for a particular platform. You can see this impedance mismtatch in the Vim code where looping constructs are wrapped in their own ifdef (MAY_LOOP). Second, maintaining this code is really difficult. It's far too easy to make a change that breaks others platforms without realizing it (until you test it on those platforms). That Vim code is almost certainly broken for some of those long-forgotten operating systems. It's just that no one knows it yet because it hasn't been tested in awhile, and trying to reason about it by only reading the code would probably take hours."
coding,3dfk4g,skeeto,3,Thu Jul 16 13:20:21 2015 UTC,The cyclomatic complexity of this file is probably insane when you take in to account all of the ways it can fall out when compiled.
coding,3dfk4g,capitalsigma,2,Thu Jul 16 14:02:53 2015 UTC,"I've worked on embedded code that would implement entire features through #ifdefs in the main() loop. Like, 5 different products all built from the same code base. It was deemed to impractical to reorganize into libraries and let the linker handle it even when I offered to do it for free in my spare time. This type of shit is guaranteed to introduce bugs."
coding,3dfk4g,jutct,17,Thu Jul 16 20:39:25 2015 UTC,"# else         /* Guess we got interrupted halfway. */         msec = msec / 2; # endif   Oh, my God."
coding,3dfk4g,SciK,1 point,Thu Jul 16 07:18:26 2015 UTC,This made my day.
coding,3dfk4g,TheBuzzSaw,11,Thu Jul 16 19:31:37 2015 UTC,"Here is the file in Neovim, https://github.com/neovim/neovim/blob/master/src/nvim/os_unix.c. Hoping that project is successful because I can't imagine the existing code base being maintained."
coding,3dfk4g,summerteeth,3,Thu Jul 16 00:50:25 2015 UTC,"So like, 700 lines instead of 400? #progress"
coding,3dfk4g,philipwhiuk,3,Thu Jul 16 08:19:58 2015 UTC,"Here is the original file for reference, http://www.opensource.apple.com/source/vim/vim-10/vim/src/os_unix.c. :)"
coding,3dfk4g,summerteeth,4,Thu Jul 16 11:53:34 2015 UTC,Ah....
coding,3dfk4g,philipwhiuk,1 point,Thu Jul 16 11:56:14 2015 UTC,Perfectly fine if they're more readable lines.
coding,3dfk4g,flukus,1 point,Thu Jul 16 08:36:05 2015 UTC,Not really: mch_expand_wildcards is a 400 line function of hell.
coding,3dfk4g,philipwhiuk,1 point,Thu Jul 16 08:40:37 2015 UTC,I'm no where near familiar enough with C anymore. It all looks like that to me :)
coding,3dfk4g,flukus,15,Thu Jul 16 08:59:38 2015 UTC,Why so many ifdefs? Why not a completely separate implementation for each platform?
coding,3dfk4g,flukus,15,Thu Jul 16 01:20:49 2015 UTC,"This is likely just organic growth. You'd hope at some stage someone would realise things are getting a bit out of hand, but when there aren't significant enough disadvantages to it, it's not surprising it has never been refactored. I can't imagine it's something that gets touched very often, after all, and the compiler won't bother with large chunks of it."
coding,3dfk4g,Twirrim,14,Thu Jul 16 03:03:00 2015 UTC,"The problem is that you start out with a relatively clean implementation.  Then you find out that there's a subtle difference on one platform that you need to support.  Writing two separate copies of the function would seem to be a violation of the DRY principle because the two share almost everything in common except for this one minor, tiny difference and you don't want to have to maintain duplicated code.  Maybe you can refactor out the commonalities into their own functions and isolate the differences into their own functions, but that's easier said than done.  Anyway, the preprocessor solution (at the time) seems the best way to go because it's only this minor thing and the function remains relatively readable.  Now repeat that logic over the course of decades of time passing, and you end up with the mess in the link."
coding,3dfk4g,Rhomboid,1 point,Thu Jul 16 03:06:05 2015 UTC,But surely someone would have come along and been completely unable to mentally parse the code and warranted refactoring it?
coding,3dfk4g,flukus,11,Thu Jul 16 04:10:02 2015 UTC,"Code that's ugly as sin but which works fine is the hardest to refactor, because you're immediately in the red the moment you touch it, and you have to spend a significant amount of time and effort to just break even.  Suppose it takes X man-hours (where X is likely in the hundreds or even thousands in bad cases) to research, understand, and eventually rewrite the code and then test it on a gazillion platforms and under a bazillion various conditions, and then fix all the bugs that you undoubtedly introduced.  (I'm assuming there are no unit tests, which is usually a given in cases like this.)  And at the end of it you only break even, which is feature parity with where you were when you started since the code was working when you began.  You could have spent those X hours working on fixing bugs elsewhere or implementing new features.  And that's why it's so rare for anybody to choose to do that.  Sure, you've left the program in a much better state than where you found it, and hopefully anyone that needs to touch that portion of it in the future will send you flowers and chocolate for cleaning up the toxic spill.  But that's often not enough of a reward to encourage anyone to invest their X hours.  The term ""technical debt"" is really apt.  You can keep yourself out of debt if you're constantly vigilant and smart, but if you let yourself get deeply in technical debt it can turn into a hole that's too deep to climb out of."
coding,3dfk4g,Rhomboid,3,Thu Jul 16 04:45:21 2015 UTC,"All true, but in this case, it's not even the big problem. The big problem is that this is code for (x) number of platforms, and even if you want to monkey with it, you can't test all (x) platforms once you're done. So you're almost guaranteed to break some number of them.  Imagine yourself in that position, and then ask, ""Do I really want to take on that project?""  ""Eh, hell, we already have 100 ifdefs. I'll just add another one and call it a day.""  Edit: I'll just add, it's not impossible, but it's a pain. I think I would consider automatically generating the code for each platform using the preprocessor, and generate files for each one, so that I could somewhat guarantee code equivalence. But then we're back to Rhomboid's point, which is opportunity cost, with no major practical benefit."
coding,3dfk4g,nairebis,7,Thu Jul 16 14:32:28 2015 UTC,"Unfortunately, the guy who can't mentally parse the code is probably not the guy you want refactoring it. And the guy who can mentally parse the code is probably resistant to refactoring."
coding,3dfk4g,ZorbaTHut,1 point,Thu Jul 16 04:34:24 2015 UTC,"Even if you do find that developer, find someone to test it as thoroughly as the existing code."
coding,3dfk4g,BlindTreeFrog,1 point,Thu Jul 16 13:33:22 2015 UTC,"All true. Another consideration is how old this code is. Function calls used to be more expensive than they are today. More CPU cache and automatic inclining done by modern compilers makes this seem like a silly consideration today. On the other hand, the upper bound of the ms argument hasn't really changed much since human prescription hasn't changed much."
coding,3dfk4g,dvogel,1 point,Thu Jul 16 14:34:09 2015 UTC,"After the ifdef mess has been in use for a while, new programmers who have to touch it probably just step it through in the debugger to roughly find the spot they have to tweak, and then leave hoping they never have to return.  I used to work with a pretty old game engine, that's at least how I usually approached it. Wouldn't want to mess up some weird platform's code that rarely gets compiled anyway."
coding,3dfk4g,bumhugger,9,Thu Jul 16 16:15:31 2015 UTC,get out of here with your fancy maintainability and standards!
coding,3dfk4g,hotel2oscar,2,Thu Jul 16 02:48:08 2015 UTC,Another thing is that the author wanted to clean this up at some point but who has all those systems to test it on?
coding,3dfk4g,olafurw,1 point,Thu Jul 16 08:24:29 2015 UTC,True. Who would even have an amiga or beos anymore? But I guess that's where neovim comes in.  Edit - Although this is what CI builds and unit tests are for.
coding,3dfk4g,flukus,1 point,Thu Jul 16 08:34:40 2015 UTC,Which wasn't widely popularized until 99 when extreme programming was released.
coding,3dfk4g,olafurw,3,Thu Jul 16 11:46:13 2015 UTC,How can you be sure it's even working correctly...
coding,3dfk4g,MaunaLoona,5,Thu Jul 16 04:19:02 2015 UTC,You mean apart from the millions of users of vim in the real world?
coding,3dfk4g,philipwhiuk,2,Thu Jul 16 08:20:51 2015 UTC,Yes.
coding,3dfk4g,tfft,4,Thu Jul 16 10:18:26 2015 UTC,"Yes, apart from that. In what universe does a huge userbase obviate the need for testing? Doesn't that mandate more, more intensive and careful testing?"
coding,3dfk4g,sam512,1 point,Thu Jul 16 12:56:13 2015 UTC,"#ifdef FEAT_NETBEANS_INTG if (ret > 0 && nb_fd != -1 && FD_ISSET(nb_fd, &rfds)) {     netbeans_read();     --ret; } #endif   Who let NetBeans into this level?"
coding,3dijmr,lenaertsdaan,4,Thu Jul 16 15:37:12 2015 UTC,"As a developer I'd have to ask, where do you make money in this? How easily does the system transfer in the event you fold as a service. Say I base product licensing on your service and then a year from now you stop functioning, will you be releasing your source? Liability and uptimes would be a concern, if you go down for an hour+ and I can't generate or redeem licenses that would be an issue.   Also on your docs, I'd change 'Use the API' to something that shows it's newer than API 1.0. Like 'Use the current API', API 2.0, 'new API' whatever."
coding,3dijmr,fallen77,1 point,Thu Jul 16 16:44:35 2015 UTC,"Thanks for your suggestions. And actually I'm planning paid plans as well, with more advanced features. But I only released the free version yet, to see if people would be interested.  Thanks!"
coding,3deajm,alexcasalboni,3,Wed Jul 15 16:27:05 2015 UTC,"Wow, this is awesome! I feel like a lot of math textbooks (and even professors) don't discuss proof strategies enough. Proofs look like magic, there's no flow to why certain thoughts came about. I remember wondering ""So what made them think to use the division algorithm there?"". Things just seem random, and it feels like as a student you have to wait for divine inspiration before you can proceed with the proof.  The tactics listed in this site would alleviate a lot of those issues."
coding,3deajm,AustinCodingAcademy,2,Wed Jul 15 18:50:04 2015 UTC,Saved
coding,3deajm,mov_dx_cx,1 point,Wed Jul 15 19:48:08 2015 UTC,The site is missing an original favicon and uses the Drupal one instead.
coding,3db3my,tdavidt,5,Tue Jul 14 22:10:43 2015 UTC,what am i looking at here
coding,3db3my,pipe2grep,7,Wed Jul 15 06:00:31 2015 UTC,Query:Hello!  Response:Jet fuel can't melt damk memes.   God damn it.
coding,3db3my,ButtStallionn,-2,Wed Jul 15 04:59:19 2015 UTC,I noticed that a bit earlier as well.  Immediately posted it to the HH Circletwerk facebook group
coding,3db3my,trentv4,5,Wed Jul 15 05:35:24 2015 UTC,"Looks neat, but is laggy in practice. Maybe give it a bit of a delay or require the 'enter' button."
coding,3db3my,reddismycolor,-1,Tue Jul 14 23:45:44 2015 UTC,It uses Algolia
coding,3db3my,Carnagh,1 point,Wed Jul 15 02:30:28 2015 UTC,why r people down voting OP he's asking for thoughts and advice?
coding,3d9efj,skeeto,15,Tue Jul 14 15:07:16 2015 UTC,Volatile is useless for doing things it is not meant to be used for   Guy in the comments got it right. Know your keywords and what they mean.
coding,3d9efj,acwaters,6,Tue Jul 14 18:49:30 2015 UTC,"Exactly!   I'll explain here why you should scrub most of it from your multi-threaded code. ... Hans Boehm points out that there are only three portable uses for volatile [...] memory that is modified by an external agent or appears to be because of a screwy memory mapping   If you're writing high performance multi-threaded code then that's an important use case where you need volatile. The article downplays the primary use of volatile down this single line. It's not about atomicity but volatile is a useful way to tell the compiler that another thread is going to modify this variable while this code is running. This way the compiler wont put the value in a register and/or optimize out the read that you need (and potentially a lot more).  Maybe you need volatile, maybe you need atomic guarantees, maybe you need a memory barrier, heck maybe you all three because they're three totally different concepts! Learn what you need and use it appropriately.  People need to stop writing these 'X Considered Harmful' articles about perfectly good tools when used in the right context."
coding,3d9efj,bgirard,12,Wed Jul 15 05:15:19 2015 UTC,"Doesn't Java use the volatile keyword to mean exactly this kind of ordered-access-with-memory-barriers?  Also, I think that Microsoft added the same semantics to their CL.EXE compiler."
coding,3d9efj,mr-strange,15,Tue Jul 14 15:55:23 2015 UTC,"You're right, Java volatile has different semantics than C and C++ volatile, so it is relevant to multi-threading. This article is talking specifically about C/C++."
coding,3d9efj,forcedtoregister,3,Tue Jul 14 16:01:41 2015 UTC,Correct about both.  If I ever port my C++ code to another platform I'll have to find and replace volatile with std::atomic. I only ever use it for killing threads (with a comment explaining why it's OK) so I think I'm fine!
coding,3d9efj,Drainedsoul,-2,Tue Jul 14 19:07:34 2015 UTC,Doesn't Java   If someone's talking about a language without qualifying which language it is they're talking about it's pretty safe to assume it's not Java.
coding,3d9efj,BobTheSCV,9,Tue Jul 14 16:20:28 2015 UTC,"To be fair, if someone's talking about a language without qualifying which language it is they're talking about the odds are stacked against any specific language."
coding,3d9efj,__Cyber_Dildonics__,3,Tue Jul 14 21:11:22 2015 UTC,"If it is Intel, it is either C++ or Fortran."
coding,3d9efj,RenaKunisaki,1 point,Wed Jul 15 01:28:57 2015 UTC,Chances are it's ALGOL.
coding,3d9efj,gee_buttersnaps,6,Wed Jul 15 01:30:32 2015 UTC,FUCKING ARTICLE IS FROM 2007.
coding,3d9efj,wllmsaccnt,2,Tue Jul 14 19:44:20 2015 UTC,"The volatile keyword hasn't changed much since then, to be fair."
coding,3d9efj,RenaKunisaki,4,Wed Jul 15 00:25:31 2015 UTC,It's less volatile than you'd expect.
coding,3d9efj,bgcatz,5,Wed Jul 15 01:31:08 2015 UTC,"That's kind of a useless distinction to make.  Sure you can write multithreaded code that will only run on single core processors and microcontrollers, but why would you?  If you know you want to limit your code to run on processors without hardware threading, you'd probably be much better off just writing your code with a fiber or coroutine library.  Your code would likely perform better and it would still be portable to more modern machines.  Also even in these circumstances, volatile still doesn't do what you want it to in C and C++"
coding,3d9efj,gasche,4,Tue Jul 14 16:47:09 2015 UTC,"An almost useless reference now that C11 specifies atomic operations for concurrency. The whole discussion (article and aggressive comments) can be summarized to ""if you share memory between threads in your program(s), you must make sure to use the atomic operations for shared data, otherwise your program is undefined""."
coding,3d9efj,strncat,3,Tue Jul 14 17:07:41 2015 UTC,It wasn't useful before either. You just had to use compiler languages extensions like the GNU C or Microsoft atomic intrinsics. Using volatile always resulted in incorrect optimizations at both the compiler and CPU layer because it never expressed the desired semantics.
coding,3d9efj,programming_resource,2,Tue Jul 14 16:24:10 2015 UTC,"Not always. If using volatile on a MS C++ compiler, it inserts memory fences. See ""Microsoft Specific.""  https://msdn.microsoft.com/en-us/library/12a04hfd.aspx  That being said, it's certainly not standard behavior nor is it portable."
coding,3d9efj,adrianmonk,3,Tue Jul 14 16:47:54 2015 UTC,"Well, not technically atomic operations. Let's say you use one variable for coordination between two threads and a bunch of other variables (perhaps a byte array) for sharing data between them. The writes to the variables used for shared data do not need to be atomic. The writes just need to be visible."
coding,3d9efj,mr-strange,1 point,Wed Jul 15 00:24:31 2015 UTC,You are assuming platform-specific behaviour there. Alpha chips would have laughed at your code.
coding,3d9efj,adrianmonk,3,Tue Jul 14 17:52:55 2015 UTC,"I don't understand what you're getting at. Let's say I have a data structure that is 10 kilobytes. I'm writing to it from thread A and I'll need to read from it in thread B. I can't write 10 kilobytes atomically. I have to use some other method to make sure the writes from thread A are visible to the reads from thread B. So the issue cannot be summarized as just ""use the atomic operations""."
coding,3d9efj,grencez,1 point,Tue Jul 14 22:28:53 2015 UTC,"Volatile should still imply slow consistency, right? Even in a distributed shared memory system, once you see a variable's updated value, it won't temporarily revert to its old value. Though I guess if we're following the spec, slow consistency might only apply on a byte level due to word tearing.  In any case, one legitimate use for volatile in multi-threaded programs is when you need a flag for early termination. The flag is initialized to 0, threads only set it to 1, and threads just need to eventually know if they need to terminate. It can be set inside of a signal handler, but doesn't need to be labeled sig_atomic_t since we only care about eventual termination."
coding,3dc4d5,tdavidt,2,Wed Jul 15 02:55:53 2015 UTC,Can someone explain this fascination with CleverBot to me? Every time I looked at it the responses were quite lacking.
coding,3dc4d5,RAL_9010_POWER,2,Wed Jul 15 04:43:33 2015 UTC,crowd sourced chatterbot that's easy to get angry at without hurting anyone's feelings.
coding,3d90ci,javinpaul,1 point,Tue Jul 14 13:10:11 2015 UTC,"This is hilarious, thanks for posting this!"
coding,3d4llm,thekodols,6,Mon Jul 13 14:03:35 2015 UTC,I'm using AppVeyor at the moment for my C# project. It's free to use for public github repositories and very easy to use - setup took me a few minutes without any prior knowledge.  Just in case anyone is looking for that platform ;)
coding,3d4llm,SiS-Shadowman,4,Mon Jul 13 16:28:42 2015 UTC,Interesting. Hadn't heard about it. I see it targets specifically .NET applications. Have you noticed anything that they do differently to help out .NET people?
coding,3d4llm,brewdente,3,Mon Jul 13 17:02:44 2015 UTC,"I am a fan of their nuget feed publishing (private or public): http://www.appveyor.com/docs/deployment/nuget  Shameless plug -  We (my friends/business partners) like it so much, they (I would love to take credit, but I didn't personally contribute) built CoolWhip [GitHub] to auto publish to nuget (using AppVeyor) when you create a GitHub release."
coding,3d4llm,SiS-Shadowman,2,Mon Jul 13 17:24:57 2015 UTC,Cool.
coding,3d4llm,flukus,1 point,Mon Jul 13 17:37:30 2015 UTC,"Different compared to ...? At work we've got our own Jenkins that invokes msbuild for CI and compared to Jenkins, the setup is much simpler."
coding,3d4llm,flukus,3,Mon Jul 13 17:31:00 2015 UTC,"Gotcha. Just compared to other CIs. Since their site really emphasizes that they built it for .NET developers, I wanted to know what are the bits that make it specifically built for .NET people. I did stumble on their setup video; it does look pretty straightforward."
coding,3d4llm,jquintus,1 point,Mon Jul 13 17:41:11 2015 UTC,The main thing is that it's windows based and includes things like IIS and sql server.
coding,3d4llm,flukus,1 point,Tue Jul 14 01:27:52 2015 UTC,I wrote about why appveyor is crap. There is no build configuration.
coding,3d4llm,dreoth,1 point,Tue Jul 14 01:27:19 2015 UTC,"There is no build configuration.   Reading your post it is clear that there is a build configuration, specifically the yaml file in your root."
coding,3d4llm,dreoth,1 point,Tue Jul 14 13:51:38 2015 UTC,Extremely limited configuration.
coding,3d4llm,JonnyRocks,4,Tue Jul 14 22:39:42 2015 UTC,Missing GitLab CI
coding,3d4llm,slapnuttz,3,Mon Jul 13 16:50:10 2015 UTC,"Ah, yes, thanks for pointing this out. I'll get that added. Do you have any experience with it? Anything in particular that makes it stand out from the crowd?"
coding,3d4llm,JonnyRocks,3,Mon Jul 13 16:59:27 2015 UTC,"I've been playing with it for a few months. I find it is fairly easy to work with. I haven't tried any complex builds yet though, as I've mostly been working with small web-apps and mono/vNext related projects.   Something to keep an eye on right now is their transition to using a .gitlab-ci.yml file to control the builds.   Some information to reference: https://about.gitlab.com/2015/06/08/implementing-gitlab-ci-dot-yml/ https://about.gitlab.com/2015/05/06/why-were-replacing-gitlab-ci-jobs-with-gitlab-ci-dot-yml/  There are a few different runners out there as well, but GitLab has an official cross-platform runner available at: https://gitlab.com/gitlab-org/gitlab-ci-multi-runner  Hope this helps!"
coding,3d4llm,flukus,2,Mon Jul 13 17:08:06 2015 UTC,"Great, definitely helps. I'll look into it some more before adding any info to the comparison.   (But if someone experienced with GitLab's CI wants to jump in, feel free, the resource is crowdsourced - anyone can add/edit.)"
coding,3d4llm,snuxoll,3,Mon Jul 13 17:20:31 2015 UTC,Missing tfs online which has free private repository. Can use either tfs or git source control. Works perfectly with visual studio.
coding,3d4llm,flukus,2,Mon Jul 13 22:19:33 2015 UTC,Using tfs and perfectly in the same paragraph is a bold statement
coding,3d4llm,slapnuttz,2,Tue Jul 14 00:01:41 2015 UTC,I seriously never had an issue. I love tfs online. I have used tfs in some form for 10 years. It used to be a pain to install but that's not a worry with the online version.
coding,3d4llm,octobersotherveryown,2,Tue Jul 14 00:06:24 2015 UTC,Really? You've never tried to maintain a long running branch?
coding,3d8m96,Vburyi,1 point,Tue Jul 14 10:32:16 2015 UTC,If you have awk in your pipeline you likely do not need sed nor grep
coding,3d939l,Vburyi,3,Tue Jul 14 13:36:35 2015 UTC,"Interesting, but not coding."
coding,3d3w6w,evoketechnologies,5,Mon Jul 13 08:59:29 2015 UTC,"I liked the article, but I personally don't believe that semi-automatic ultra-high-level programming will ever turn out to be possible (outside of small niches at least). 30 years is a long time, but at least for the forseeable future, my guess is that we'll come to realize that it's a good idea to decrease the complexity of our technology again. While I am not a Go programmer myself, I think it is a good example for what we need: it's simpler than many previous designs, but still provides some clever modern high-level features that make it easier to do certain kinds of tasks. So my guess is that we will still have to know various programming languages in the future, but they'll be more specialized and not be as complex as e.g. C++."
coding,3d3w6w,conseptizer,3,Mon Jul 13 13:23:03 2015 UTC,"Nice read and an important topic. I think we already scratch the impossible to manage/maintain area of coding/developing for humans. There are so many things in my everyday work I just can't seem to get them done perfectly/right, on the other hand this alway gives me the hope to be able to create a killerapp the world needs."
coding,3d3tfi,Vburyi,5,Mon Jul 13 08:18:53 2015 UTC,Environment variables can contain complex information (think: multi level array). It should be marshaled as JSON and encoded into base 64 so it is easily modifiable and readable from outside the application.   What the f?  Was this written before the birth of UTF-8?
coding,3d3tfi,edsonmedina,4,Mon Jul 13 13:27:42 2015 UTC,"They're good points, but it's hard for me to take it seriously when the site just starts acting really weird by the time I scroll all the way down and the content disappears. (latest version of FF)."
coding,3d3tfi,duniyadnd,1 point,Mon Jul 13 10:05:53 2015 UTC,It's even worse on iphone. But the content is great :)
coding,3d3tfi,streletz,1 point,Mon Jul 13 11:57:21 2015 UTC,"""Modern"" and ""PHP development"" really don't belong in the same sentence - but if you were condemned to programming in that horrible language, this might be a helpful article."
coding,3d3tfi,TomSwirly,2,Mon Jul 13 14:39:22 2015 UTC,"I don't feel like arguing on the internet, but you should know that article isn't very accurate of the current affairs of PHP. It's actually not a bad language anymore with all the community efforts that have been put into place.  I'll let you do your own independent research, or you can just remain ignorant and spread fallacies."
coding,3d1dm4,timanglade,2,Sun Jul 12 18:45:29 2015 UTC,I love the video/speaker deck system. Where can I make use of it?
coding,3d1dm4,foxh8er,1 point,Mon Jul 13 03:54:09 2015 UTC,The site uses presentz.js. It works really well with YouTube & Speakerdeck.
coding,3cyi3e,godlikesme,16,Sat Jul 11 22:52:53 2015 UTC,I think the fourier transform might be the most complex mathematical concept I've ever tried to wrap my head around.  Still don't get it after studying it in a signals class in college and revisiting it many times since
coding,3cyi3e,matticusrex,3,Sun Jul 12 04:07:36 2015 UTC,"It took me a long time wrap my head around it too, but once you start to grok it it's really cool how they work.  Basically, it takes advantage of the fact that the integral of sin(x)*sin(y) is zero over a certain interval unless x = y.  And also that all periodic functions can be written as a summation of sines.  So if you take the integral of sin(x)*f(y), where f(y) is a periodic function (made up of sines and cosines), and do this for all integer multiples of x, you essentially extract the sine waves that compose f(y), and the rest cancel out to zero.  I'm sure someone will step in to correct me, because that was far from rigorous and it's been a while since I've done a Fourier transform. Really neat trick though."
coding,3cyi3e,SleepyPierre,3,Sun Jul 12 14:07:44 2015 UTC,"Honestly, I think it will just take some level of sitting down and writing the math myself to really get it.  The internet has lowered my expectation of what it takes to understand a written piece like this."
coding,3cyi3e,matticusrex,3,Sun Jul 12 15:47:35 2015 UTC,(I'm the author of the article). Understanding the Fourier Transform was the most difficult part. It took me more time to understand the Discrete Fourier Transform than to have a very good understanding of Shazam.  I looked on the net but found many incoherencies.  In the end I found a good website (the one I put in the chapter about Fourier) and I rewrote some parts of the math myself. I also used Matlab/Octave to have a visual explanation.  You can still skip this part and understand the part that focuses on Shazam (100% computer science).
coding,3cyi3e,mgachka,1 point,Sun Jul 12 22:12:47 2015 UTC,"physicist here. i just skimmed the article (i will definitely read it) and have to say, that you have done a GREAT job summarizing the fourier transform. kudos!"
coding,3cyi3e,sensengassenmann,1 point,Wed Jul 15 12:02:28 2015 UTC,ELI5 fourier transform   Yea.. about that..
coding,3cyi3e,brtt3000,1 point,Sun Jul 12 21:03:08 2015 UTC,"I agree, it's huge in electronics. We did it in the 2nd year and I wish I'd paid more attention in the 1st year Maths I thought was abstract exercise for the brain.  The simplest ELI5 mental model is the ""spectrum analyser"" bars bouncing up and down on an old school music player such as WinAmp."
coding,3cyi3e,EllaTheCat,2,Sun Jul 12 13:15:52 2015 UTC,"Nice article, though it could use some serious proofreading."
coding,3cyi3e,catnipbilly,2,Sun Jul 12 12:32:13 2015 UTC,Great read for anyone interested in DSP and/or wondered how Shazam and similar apps worked. I was always interested in audio production as a musician and the more detailed DSP-side because I'm nerdy like that. The math (DFT algorithm more specifically) was definitely over my head but the other concepts I could wrap my head around.
coding,3cyi3e,mikedpad,2,Sun Jul 12 14:32:33 2015 UTC,"It's actually pretty simple. If I'm understanding this correctly, the wizard deems one ""worthy"" and then he transports them to the rock of eternity where he grants them the power of Shazam. After that, whenever the worthy say ""Shazam!"" they are transformed into a superhuman with the wisdom of Solomon, strength of Hercules, stamina of Atlas, power of Zeus, courage of Achilles, and the speed of Mercury."
coding,3cyi3e,foo1ki11er,1 point,Sun Jul 12 21:17:12 2015 UTC,"This is absolutely ridiculous, but it bothered me that on one of the graphs he refers to it as a sin wave when it is clearly at max amplitude at t=0.  I have no idea why this irked me so much."
coding,3cyi3e,djleni,4,Sun Jul 12 16:57:11 2015 UTC,The author just forgot to mention the 90 degree phase shift
coding,3cyi3e,kourckpro,1 point,Sun Jul 12 18:31:09 2015 UTC,"Realistically it doesn't matter at all for what he was trying to explain, I just had to point it out :)"
coding,3cyi3e,djleni,2,Sun Jul 12 19:22:15 2015 UTC,"I made many approximations in this article, this is one of them."
coding,3cyi3e,mgachka,1 point,Sun Jul 12 22:17:32 2015 UTC,"Like I said, it doesn't matter one bit, I just had to be a nerd and point it out. Great article!"
coding,3cyi3e,djleni,1 point,Sun Jul 12 22:25:36 2015 UTC,"Seriously cool article. I knew very little about dft, almost nothing about music/sound/sampling. The grammar was very bad in places but i learned so much that I didn't care, Thanks!"
coding,3cxc7d,javinpaul,7,Sat Jul 11 16:43:55 2015 UTC,"I wonder if it isn't a better idea to have plugins instead of optional dependencies. It's sort of the same kind of code, but I feel like plugins are more proper since the user can decide whether or not to activate something, and the developer can keep the core code nice and simple."
coding,3cxc7d,armornick,7,Sat Jul 11 17:17:33 2015 UTC,"I've been bitten by automatic detection of optional dependencies. My company had some custom Solr plugins with dependencies that used the ""apache xerces"" xml parser. Xerces instances aren't safe to be shared across threads, which is fine as long as you don't try to share them. Well, Solr uses java's ServiceLoader facility to get its xml parser, so if the xerces jar is on Solr's classpath then Solr automatically starts using xerces. It shared one instance across many threads, so we got intermittent failures, but only when we had enough solr searches that the threads would hit xerces at the same time.  My conclusion was that automatically using different libraries based on whatever random shit you can find in the classpath is a bad idea."
coding,3cxc7d,Hyphen-ated,1 point,Sat Jul 11 19:31:37 2015 UTC,"Yeah, optional dependencies should have to be explicitly loaded by the final project. So I guess it's plugins."
coding,3cwbro,Anacreon_T,2,Sat Jul 11 09:11:27 2015 UTC,"I don't work with C++, but spotted the 2nd and 3rd ones quickly.  Didn't get the first one, but I think you would have to be familiar with C++ specifically to do so, 2 and 3 are kind of language agnostic."
coding,3cwbro,jmkni,5,Sat Jul 11 14:29:41 2015 UTC,"No, the first error is very much a C error: memcpy(ptr, src, sizeof(ptr)) is pretty well always a mistake, the coder meant sizeof(*ptr)."
coding,3cwbro,Araneidae,3,Sat Jul 11 16:14:44 2015 UTC,Good to know!
coding,3cwbro,jmkni,1 point,Sat Jul 11 17:35:12 2015 UTC,"Still pretty much a C family thing, but I guess it's still compelling, because coming from a history of more managed languages, that's exactly the kind of footgun mistake I would waste a stupid amount of time on."
coding,3cwbro,Rainfly_X,2,Sun Jul 12 17:03:12 2015 UTC,"I found 11 out of 15, but the quiz failed me on three answers because I didn't click on the exact token it took for the right answer. For example, there was a problem with if((blah = foo) == 4 && bar != baz), and I clicked on the assignment. And the assignment was the problem, but apparently I was supposed to select the parentheses. Pretty annoying."
coding,3cwbro,Madsy9,1 point,Sat Jul 11 20:58:28 2015 UTC,Does anyone have a link to more?
coding,3cw5zx,jackycute,2,Sat Jul 11 07:36:36 2015 UTC,"Hi, everyone, I made a service here, called HackMD. It's a realtime collaborative markdown notes on all platforms. I spent more than 4 months on it, and I need your help to make it better! Also it's an open source project, see more here: https://github.com/jackycute/HackMD Feel free to give any feedback or suggestion to me, even just a hello is welcome :) Thank you!"
coding,3cw5zx,p2004a,1 point,Sat Jul 11 07:36:46 2015 UTC,I was using stackedit.io before. What are the differences? Why should I use your tool? I have been looking at the features and they look very similar.
coding,3cw5zx,Fs0i,3,Sat Jul 11 08:49:38 2015 UTC,"Yes, they are very similar. The difference is realtime collaborating, you can invite your friends or partners via the links then to discuss or complete a doc with no harms. And you can set your own permissions and even publish a doc with a short link only with a click. This focus on the experience to markdown things, so it would have auto complete, auto table of content(not need to type) and cross-platform compatibility."
coding,3csyxq,javinpaul,5,Fri Jul 10 15:00:17 2015 UTC,"Reading this, I can only remember what my own life was like before I had a day job."
coding,3csyxq,Rainfly_X,2,Sat Jul 11 05:31:25 2015 UTC,This. It was so awesome to have pretty much the whole day to do something else than work money in someone else pocket
coding,3csyxq,endless90,1 point,Sat Jul 11 08:16:16 2015 UTC,"Looks awesome, and potentially a great way to get over my anxiety around size projects."
coding,3csyxq,Taurath,1 point,Sat Jul 11 01:38:07 2015 UTC,Dam! I'm totally going to attempt some streak goals
coding,3csyxq,Vordus,1 point,Sat Jul 11 02:18:13 2015 UTC,That is impressive. Is this what you did during your summer while you were in college?
coding,3csyxq,Butwella,1 point,Sun Jul 12 06:21:16 2015 UTC,I want to start coding like this and work on my own projects but I feel my knowledge isn't strong enough to create something as complex as u did. Any tips on how to start the streak?
coding,3csyxq,reddismycolor,1 point,Mon Jul 13 19:57:00 2015 UTC,"I have similar problem, except that I do not have ideas for stuff to make.    As for your issue, creating something ""as complex"" is the least of your worries. Complexity will crawl into your projects whether you want it or not.  Start with a simple idea. Any new feature you'll come up with along the way will build upon it.  The key for creating complex programs is spending a lot of effort trying to make them as simple as possible."
coding,3csyxq,eighthCoffee,1 point,Tue Jul 14 07:30:17 2015 UTC,This is insanely impressive!!   Anticipating something crazy for your PHD!
coding,3crxxy,alexcasalboni,10,Fri Jul 10 07:52:13 2015 UTC,"“Encryption has moved from something that is available to something that is the default,” FBI Director James Comey told a congressional panel Wednesday. “This is a world that in some ways is wonderful and in some ways has serious public-safety ramifications.”   Uh, sure I guess.   Around that time, the State Department was looking to use technology to support pro-democracy movements overseas. Mr. Marlinspike’s work caught the attention of Ian Schuler, manager of the department’s Internet freedom programs. Encrypted messaging was viewed as a way for dissidents to get around repressive regimes.   Hmmm. That's quite interesting.  EDIT: For the record, I do not believe the US government is a 'repressive regime' but at times it could probably be framed like one (Spying on innocent citizens, even if they don't act on the gathered information. Like some quote goes, ""It isn't whether you break the law, it is which one"", or something along those lines). I was just riffing on the fact that they support it in one breath and condemn it in the next."
coding,3crxxy,Madamelic,12,Fri Jul 10 14:26:19 2015 UTC,"The government has a bit of cognitive dissonance going on.  On the one hand they want people to be protected from crime.  On the other hand they want to be able to catch said criminals.  These two ideas conflict when it comes to encryption because encryption makes it more difficult (note: not impossible) to catch criminals while at the same time making it difficult (note: not impossible) for criminals to commit crimes.  Another conflict is that different divisions of government have different goals in mind when it comes to encryption.  Encryption gives dissidents the power to secretly organize under regimes that are unfriendly to the United States.  It also gives criminals the power to secretly organize under the watch of the United States government.  Thus, the State Department and other divisions related to foreign affairs love encryption technologies because it makes their job easier.  The FBI and other divisions related to domestic affairs hate encryption because it makes their job harder.  This explains why encryption is viewed as munitions by the US government.  It is a powerful weapon against all forms of spying.  It makes it really damned hard to keep track of and control any and all communications.  A government's job is to maintain a modicum of control over many things and encryption makes the most important part of maintaining control much harder: Keeping track of what people are saying and doing."
coding,3crxxy,riskable,1 point,Fri Jul 10 15:07:26 2015 UTC,"I completely agree. I was just sort of riffing on the fact these two quotes are in paragraphs next to each other.   It is quite interesting to see the cognitive dissonance inside the government over encryption. Like you said, it isn't a big shock considering the different roles of different areas of the government. Also the fact that the US government is so wide in scope.   I don't really feel sympathetic for the government over encryption. It sounds like they just want their job to be as easy as possible at the expense of individual privacy and freedom."
coding,3crxxy,Madamelic,2,Fri Jul 10 19:14:01 2015 UTC,"I don't really feel sympathetic for the government over encryption. It sounds like they just want their job to be as easy as possible at the expense of individual privacy and freedom.   I ultimately agree with you, that encryption should not be restricted, but there's no dissonance going on in recognizing that encryption can be used for both great good and great evil.  Liberty exists in a tenuous equilibrium with order.  And as other aspects of society change, it's only natural that the ideal balance changes too.  Yes, law enforcement and intelligence officials want to make their job easier.  But remember what their job is, to protect society from those who would harm it."
coding,3crxxy,Marco13185,9,Fri Jul 10 19:31:46 2015 UTC,All based on Derived / inspired by: https://otr.cypherpunks.ca  Edit: corrected my statement.
coding,3crxxy,MasterBob,5,Fri Jul 10 12:15:53 2015 UTC,"TextSecure doesn't use OTR, it uses axolotl-ratchet, specifically because OTR isn't the best when doing asynchronous messaging."
coding,3crxxy,oxychromaticdynamite,1 point,Fri Jul 10 19:52:29 2015 UTC,"Axolotl is derived from OTR, so I believe my statement still stands.  EDIT: Latest TextSecure Protocolv2."
coding,3crxxy,MasterBob,4,Sat Jul 11 01:13:19 2015 UTC,"It's inspired by OTR and SCIMP, your statement of ""All based on [OTR]"" is false, eg. the hash iteration aspect of axolotl is not based on OTR at all."
coding,3crxxy,oxychromaticdynamite,1 point,Sat Jul 11 06:25:26 2015 UTC,"I think you are right, so I have edited the original post accordingly. Thank you for informing!"
coding,3crxxy,MasterBob,2,Sat Jul 11 09:54:29 2015 UTC,"Yeah, I felt like the credit should have been spread around a little more."
coding,3crxxy,by_myself,1 point,Fri Jul 10 17:48:27 2015 UTC,Usually credit isn't given where it is deserved. Thanks for the post.
coding,3cuchw,MapsNApps,1 point,Fri Jul 10 21:10:45 2015 UTC,Quite cool!   Nice to see that it's not just another xkcd 1138
coding,3ct83k,alexcasalboni,1 point,Fri Jul 10 16:10:48 2015 UTC,"Wow, you can do alot more with the new format than I knew!"
coding,3cpgmi,skeeto,21,Thu Jul 9 18:49:53 2015 UTC,tl;dr; compression.
coding,3cpgmi,Dr_funny_guy,20,Fri Jul 10 02:35:51 2015 UTC,"Tl;Dr is a common thing on the Internet, expect to see it a lot."
coding,3cpgmi,royalaid,11,Fri Jul 10 04:39:09 2015 UTC,/r/IAmVerySmart
coding,3cpgmi,scragar,6,Fri Jul 10 05:23:25 2015 UTC,"X * Y bytes of the map represented as a sequence of pairs <COUNTER><CODE>. <COUNTER> is either a single 0 bit which means one repetition, or four bits 1 D3 D2 D1, where the number of repetitions N = 2 + D3 * 4 + D2 * 2 + D1 (values 2 to 9). <CODE> has five different values: 00 - an empty space, 01 - a wall, 10 - a barrel, 101 - a place for the barrel, 111 - a barrel already in place.   Can someone explain this? I get that it's compression but it makes no sense to me. So X * Y bytes (example, 20 * 30) is represented as a sequence of pairs. Pairs of bytes? Bits? Nibbles? Okay so counter is either a 0 bit (lsb or msb?) or four bits - 1 D3 D2 D1 - I count 32 bits there? Code is five different values, I'm assuming 0,1,2,5,7?  I don't get it.  Also, it seems way too complicated for something that could have been easily done with RLE compression, considering it's basically a 5 colour palette.  edit: thanks guys, I thought D1 D2 and D3 were hexadecimal numbers haha."
coding,3cpgmi,cosmicr,7,Fri Jul 10 08:47:33 2015 UTC,"So X * Y bytes (example, 20 * 30) is represented as a sequence of pairs. Pairs of bytes? Bits? Nibbles?   It's a pair where the first element in the pair is either 1 bit or 4 bits long, and the second element is either 2 or 3 bits long. And so the pair in total can be either 3, 4, 6 or 7 bits long.   (lsb or msb?)   Implementation detail. You could do it either way and the algorithm will work just as well.   1 D3 D2 D1 - I count 32 bits there?   One of the bits in this case always has the value 1, and so is not given a name. The other 3 bits are given the name ""D1"", ""D2"" and ""D3"" so that we can refer to them later without knowing precisely what value they have.   Code is five different values, I'm assuming 0,1,2,5,7?   If you take their bitpatterns, interpret it as an unsigned binary number, and translate to decimal, then yes, you get 0, 1, 2, 5 or 7. However these bit patterns are intended to represent one of the 5 tiles, so what decimal number they map onto is unimportant.   Also, it seems way too complicated for something that could have been easily done with RLE compression, considering it's basically a 5 colour palette.   This is RLE, but optimized for the specific problem domain (e.g. the typical size and layouts of the maps).  If you were going to implement an RLE for this, how would you encode the run-length? The naive approach would be to use 1 byte to record the length, and the second byte to record the tile (or vice versa, the ordering doesn't matter much), right?  But none of these maps have a width of 256, so you don't need a whole byte to encode the run length. And there are only 5 possible tiles, so you don't need a whole byte to encode the tile type.  If you assume that maps never get bigger than 32x32, then you could use only 5 bits to encode the run-length in the obvious/naive way, right?  So now here's the next level of optimization: It's very rare for a map to have a run of 32 of the same tile. So rare that it's more efficient (space wise) to use only 4 bits to encode a maximum run length of 16, and if you occasionally get a run that's, let's say 20 long, you'd just encode this as a run of 16 of a given tile, followed by another run of 4 of the same tile, and you'd end up saving space overall.  Now let's say you analyze your maps even further and you notice that by far, the most common length is 1. In such a case, you'd want a variable-width run length encoding, where encoding a run length of 1 is hyperoptimized (e.g. only takes 1 bit), and the run lengths of 2 and above can be slightly longer than they would be in the naive solution, but since run lengths of 1 are so much more common than any other run lengths, again your map file ends up being smaller overall.  And so on: the author presumably did analysis and had a ""good reason"" for every optimization they implemented."
coding,3cpgmi,Nebu,3,Fri Jul 10 02:51:23 2015 UTC,"It's talking in bits and it sounds a lot like UTF-8 variable-length encoding except it isn't byte-aligned. Examples (bits):  B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 ...  0  0  1  0   B0 is zero so that means a single repetition. Directly after that is the three bit CODE (B1-B3) which in this case is 010 making it ""barrel"". So this represents a single barrel.  B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 ...  1  1  1  0  0  0  1    B0 is 1 meaning the repetition value will include three more bits (B1-B3, denoted as D3, D2, D1 in the article) in this case those three bits are 110 so the total repetition is      2 + (D3 * 4) + (D2 * 2) + D1  = 2 + (1 * 4) + (1 * 2) + 0  = 2 + 4 + 2 + 0  = 8   The next three bits again denote the type of tile, in this case it's B3-B5 which are 001 which means ""a wall"" so this pair encodes 8 wall tiles.  EDIT: I have worked in situations like this ten years ago when trying to compress a ridiculous amount of reasonably structured data into a fixed maximum size (DVD9, 8.5GB). When your domain is fixed and narrow you can go very deep down the optimisation rabbit-hole."
coding,3cpgmi,BinaryRockStar,1 point,Fri Jul 10 03:12:03 2015 UTC,You should post to /r/tinycode as well. I don't think the sub is nearly as popular as it could be.
coding,3cpgmi,ProfOak_,-5,Fri Jul 10 03:19:49 2015 UTC,"Simple, you have 4 states of a tile:  Space, Wall, Block, Destination.  That's just 2 binary bits per tile.  A 20x20 map (400 tiles) can be represented by just 100 bytes +~2-4 bytes for actual dimensions and player start coordinate.  If all 60 maps were that huge it would only take less than 6KB, leaving plenty of room for the simple game logic"
coding,3cpgmi,EkriirkE,16,Fri Jul 10 04:11:41 2015 UTC,"Even a casual read of the article would have told you there are 5 states, one being a destination with a block already on it.  But since you didn't read, I'll try to explain what actually goes on in comment form, because it's a fairly common compression method for maps like this. Although nowadays we don't really need it as much.  Now, this is a basic version, the given one uses a formula (read the article if you actually want to know those specifics), but it basically holds a counter and then a state.  So, say you have a map like (s = space, w = wall):  sssswwwww  This is: 4s5w  sswssswsss  This is: 2sw3sw (spaces at the end are implicit)  Read the article next time."
coding,3cpgmi,GMNightmare,8,Thu Jul 9 23:01:57 2015 UTC,RLE. Run-length encoding
coding,3cpqi6,drguildo,4,Thu Jul 9 20:02:49 2015 UTC,This may be relevant.
coding,3cpqi6,auxiliary-character,1 point,Thu Jul 9 23:09:10 2015 UTC,It is cool and depressing at the same time looking at how old technologies are being reinvented all the time...
coding,3cpqi6,vityok,1 point,Fri Jul 10 14:09:49 2015 UTC,"Great writeup, but that Python code is awfully ugly. So much unnecessary whitespace..."
coding,3cry9m,alexcasalboni,3,Fri Jul 10 07:56:38 2015 UTC,"Not Java 7 itself, but Java 7 update 6. (source)"
coding,3cqotf,tdavidt,1 point,Fri Jul 10 00:25:14 2015 UTC,"say cleverbot ""message"""
coding,3cofj9,leonardofed,1 point,Thu Jul 9 14:14:38 2015 UTC,Great content. Thanks OP for sharing.
coding,3cmc7x,korvalola,1 point,Thu Jul 9 00:53:00 2015 UTC,"ICFP annaul 72-hour programming contest has been held for the last 18 years, offering awesome problems, from driving a rover on Mars and writing Pacman AI to program synthesis and playing functional Lambda the Gathering.  Teams of any size, any programming language, any country. Warning: addictive."
coding,3cmc7x,youravgjoe,1 point,Thu Jul 9 00:59:46 2015 UTC,Time to book a day off then!
coding,3cmc7x,riskable,1 point,Thu Jul 9 11:47:06 2015 UTC,How big are the cash prizes for these things? The site doesn't say.
coding,3cjnzt,donnemartin,5,Wed Jul 8 12:57:12 2015 UTC,"Hi Everyone,  I created a number of interactive, test-driven coding challenges.  I will continue to add to the repo on a regular basis.  I’m hoping you find it useful as a fun, hands-on way to learn or to sharpen your skills on algorithms and data structures, while helping yourself prep for coding interviews and coding challenges.  Let me know if you have any questions or comments.  Contributions are welcome!  -Donne"
coding,3cjnzt,genericdeveloper,2,Wed Jul 8 12:57:49 2015 UTC,"Hey this is really cool! I'm in between jobs right now and this is exactly something I needed to, as you said, sharpen my skills.  Are we allowed to make requests? If possible I think it'd be pretty cool to get some stuff related to binary search trees? If not, thanks for this cool repo link!"
coding,3cjnzt,yayitsdan,3,Wed Jul 8 20:15:19 2015 UTC,"Yes, contributions are welcome!    Please feel free to submit bugs, wishes, pull requests.  I'll probably add some tree problems in the next week or two.  https://github.com/donnemartin/interactive-coding-challenges#contributing"
coding,3ckni2,alexcasalboni,2,Wed Jul 8 17:30:53 2015 UTC,TLDR: use async Task
coding,3cfvgg,KSUWildcats,11,Tue Jul 7 16:21:34 2015 UTC,"I'm always in awe of the sense of entitlement exhibited by law enforcement when dealing with digital technology.  If two terrorists meet to talk on a park bench, you'll have to be physically present or plant a bug to monitor them.  The same thing applies if they're sitting in different rooms communicating digitally."
coding,3cfvgg,Neebat,9,Tue Jul 7 19:14:22 2015 UTC,"It is incredibly disturbing how lazy law enforcement and spy agencies have gotten. For a couple decades now they have relied so much in intercepting digital communications that they forgot how to do real police work.  You're right though, it does come down to entitlement doesn't it? These guys feel they are entitled to the world making their jobs easier."
coding,3cfvgg,codeByNumber,3,Tue Jul 7 20:10:36 2015 UTC,I think they should ban all encryption.  And then now that there is encryption we just publish every incriminating message these lawman say. It will be easy since there is no encryption  And after they realize encryption was the only thing keeping their affairs secret (besides no one wanting to look) they will change their minds.
coding,3cfvgg,dtracers,3,Wed Jul 8 00:29:36 2015 UTC,In Britain they don't usually pass laws that affect the Establishment. They'd be exempt. For the children/house prices.
coding,3cfvgg,defproc,1 point,Wed Jul 8 05:08:26 2015 UTC,What are children prices there like?
coding,3cfvgg,krebstar_2000,1 point,Wed Jul 8 10:21:22 2015 UTC,Ask Westminister :/
coding,3cfvgg,defproc,2,Wed Jul 8 18:26:02 2015 UTC,"The laws on encryption won't apply to them, duh.  It's all about National Security, so their communication HAS to be encrypted and ours HAS to not be.  What's so hard to get? /s"
coding,3cfvgg,cosmicsans,1 point,Wed Jul 8 13:11:44 2015 UTC,"It is obvious...encryption is only for those who have nothing to hide, the governments and intelligence agencies."
coding,3cj9mg,theorko,12,Wed Jul 8 10:07:30 2015 UTC,"No, there isn't."
coding,3cj9mg,Bokbreath,1 point,Wed Jul 8 10:11:30 2015 UTC,Title rename didn't match the intent.
coding,3cj9mg,MonkeyNin,0,Sat Jul 18 18:42:54 2015 UTC,Not in Perl
coding,3cb9rz,javinpaul,33,Mon Jul 6 15:49:11 2015 UTC,"If you put them all onto a thumb drive, and leave the thumb drive on your shelf, it will collect dust just like the books."
coding,3cb9rz,seg-fault,13,Mon Jul 6 20:49:08 2015 UTC,"Wow, those prices."
coding,3cb9rz,kheltar,7,Mon Jul 6 16:17:20 2015 UTC,"I found the entire boxed set of volumes 1-3 for $100 at half-price books, and now I have actual books to admire on my shelf."
coding,3cb9rz,detailsguy,2,Mon Jul 6 21:57:35 2015 UTC,Exactly!
coding,3cb9rz,casperwho,12,Mon Jul 6 16:56:04 2015 UTC,Note that Knuth has only officially christened PDF as the acceptable format for his books.
coding,3cb9rz,tarballs_are_good,5,Mon Jul 6 16:38:53 2015 UTC,"Your information is out of date. These days most books on informit are only watermarked, no DRM."
coding,3cb9rz,RockinRoel,7,Mon Jul 6 16:46:25 2015 UTC,"Now I'm confused. Are you providing the correct info supporting what I said, or trying to say that what I said was incorrect?"
coding,3cb9rz,RockinRoel,1 point,Mon Jul 6 16:49:57 2015 UTC,It seems like you're kinda right and kinda wrong. They do still use DRM but only on a minority of their ebooks. The rest are just watermarked as you said.
coding,3cb9rz,Splendor78,3,Mon Jul 6 17:16:16 2015 UTC,I hope the type setting is at least the most beautiful thing I've ever seen.
coding,3cb9rz,Chooquaeno,2,Mon Jul 6 18:14:06 2015 UTC,Is it worth it?
coding,3cb9rz,GoldenKaiser,5,Tue Jul 7 04:02:42 2015 UTC,No. Go to a library and check them out if you really want to read them.
coding,3cb9rz,dragonjujo,1 point,Mon Jul 6 19:45:59 2015 UTC,Is anything of it actually worth reading? Besides for the epic status these books possess.
coding,3cb9rz,Chee5e,2,Mon Jul 6 22:12:22 2015 UTC,"I've used it as a reference before, when doing Project Euler. (Generating all partitions of an integer, section 7.2.1.4, Algorithm P. I'm sure I could have found it somewhere else, but this worked quite well.) It contains a tremendous amount of algorithms knowledge, more than you'll ever need. I can't imagine reading it front to back--if you really want to know algorithms, the CLRS book is probably a lot less parochial and more accessible--but it's certainly got a hell of a lot of depth to it."
coding,3cb9rz,grendel-khan,1 point,Tue Jul 7 02:00:39 2015 UTC,"I recently started reading them; I'm about a quarter of the way through volume 1.  I think they are worth reading (or at least so far), if you really, honestly make an attempt to work every single exercise.  The text itself is dense; the value is in the exercises themselves.  I already understand proof by induction better than I ever did, even in graduate school, from having worked through Knuth's brilliantly paced exercises."
coding,3cb9rz,detailsguy,-1,Mon Jul 6 23:17:02 2015 UTC,"So,  did he essentially invent programming.?"
coding,3cb9rz,Ephireon,5,Tue Jul 7 00:08:36 2015 UTC,No. I think his goal with these books is to create a definitive reference work of all aspects of computer programming.  He DID invent TeX and Literate Programming.
coding,3cfx0q,javinpaul,1 point,Tue Jul 7 16:32:26 2015 UTC,"I actually LOVE the wiki page on lambda. It was the first I really understood it or currying, etc."
coding,3cflc4,patys_red,1 point,Tue Jul 7 15:08:44 2015 UTC,Downvoting because your link contains no useful content besides a link to someone else's youtube videos.  It's pretty much the definition of blogspam.
coding,3cflc4,TedW,1 point,Thu Jul 9 06:28:55 2015 UTC,"Ohh, so sorry. I don't think in this way, I never going to do that again. Sorry :c"
coding,3cdeyj,AvetisG,3,Tue Jul 7 01:19:58 2015 UTC,"While the article definitely uses some flowery language, I think it more simply boils down to ego - being given criticism, constructive or not, is tough to handle as a human. Code reviews are a question of whether you love the craft (of which self improvement is a subset) more than your ego."
coding,3cdeyj,CharlesStross,1 point,Tue Jul 7 14:16:21 2015 UTC,"Code reviewers are just tools, don't take them personally...  Uh, I think I had a brain fart somewhere..."
coding,3cfij3,LeoG7,2,Tue Jul 7 14:47:13 2015 UTC,"Alternatively, if you just want to use git without github:     On your webserver, make a directory for your site and init git:  mkdir ~/public_html/mysite.com cd ~/public_html/mysite.com git init   Edit ~/public_html/mysite.com/.git/hooks/post-receive to contain:  #!/bin/sh cd .. GIT_DIR='.git' umask 002 && git reset --hard   And make it executable:  chmod +x ~/public_html/mysite.com/.git/hooks/post-receive      On your local machine, add your webserver as a remote:  git remote add production ssh://me@myserver.com/~/public_html/mysite.com   Make some changes, commit and ...  git push production master   Your production site is updated to your local master.  Edit: Formatting and directory change"
coding,3c71ou,javinpaul,13,Sun Jul 5 13:50:41 2015 UTC,It's Gilfoyle!
coding,3c71ou,Poddster,1 point,Sun Jul 5 18:49:41 2015 UTC,He wouldn't have to have this talk if it weren't for your shit codebase.
coding,3c71ou,therabidmachine,6,Mon Jul 6 06:10:53 2015 UTC,"Yeah, that was a great talk!"
coding,3c71ou,Luolong,1 point,Sun Jul 5 14:39:31 2015 UTC,"Best talk I've seen in months, thanks for the link."
coding,3cc9dk,walskiii,2,Mon Jul 6 20:02:44 2015 UTC,That sounds like the beginning of a joke.
coding,3cc9dk,Aethec,0,Mon Jul 6 21:15:19 2015 UTC,Nice!
coding,3c7mxp,varisforge,4,Sun Jul 5 17:32:04 2015 UTC,"Yup, it's a bot leaving spamming comments.   Some primitive filters check for the content of a comment in a list of certified spam comments, and filter it out in case of an exact match.   As a spambot programmer, you'd like to produce several semantically equivalent comments which are not exact copies of each other - so that, if one variation becomes certified spam, others can still make it past naive filters.  The text you see is a very rudimental comment generator. For each list {element | element}, the bot was probably supposed substitute a randomly chosen element.  Obviously, something didn't work as planned.  BTW, should you have to write a spambot to solve a similar problem and should you not be a soulless office drone, I'd totes suggest to read up on Context-Free Grammars and scour the internet for resources on how to generate a sentence from a grammar of that type. You'll have amazing variation for a fraction of the effort, and you'll feel like you taught a computer to talk without having to actually learn ML algorithms :)"
coding,3c7mxp,cbrandolino,1 point,Mon Jul 6 00:19:50 2015 UTC,"Thank you for the great response. I doubt I would ever want to replicate it, I just wanted to know how it works."
coding,3c7mxp,jakkarth,3,Mon Jul 6 00:54:47 2015 UTC,That's a poor attempt at a spam bot leaving spam comments.
coding,3c7mxp,RedGreenCode,3,Sun Jul 5 17:47:06 2015 UTC,It looks like the output of a buggy spambot. Comments sections are used by spammers who hope you will click on their usernames or links. Some of them are spamming so many sites that they don't bother checking whether their spam programs are even working. It's more cost effective to just move on to the next target.
coding,3c7mxp,RedGreenCode,1 point,Sun Jul 5 17:48:07 2015 UTC,That's sort of what I figured. How are they parsing the information?
coding,3c3qbb,javinpaul,5,Sat Jul 4 13:58:38 2015 UTC,I suggest reading the 'overview' paper.  I think this is a really interesting way of extending C without retreading objc or c++.
coding,3c3qbb,TheRealCorngood,0,Sat Jul 4 16:01:54 2015 UTC,"I dunno.  This language seems like it's about ten years too late.  There is a lot of innovation going on out there, with languages really pushing the envelope in terms of productivity improvement, expressibility, and performance.  Swift, Go, JQuery, C# all seem very fresh and innovative.  This language looks far too conservative.  I think an evolutionary language should start with something on the forefront and go from there.  Don't start from C!"
coding,3c3qbb,YouFeedTheFish,5,Sun Jul 5 03:25:51 2015 UTC,The user's guide is from 2003. Seems like it's been quietly developing in obscurity for a long time.
coding,3c3qbb,mackstann,1 point,Sun Jul 5 03:40:04 2015 UTC,"A couple things I would like to see in C as evolutionary changes:    instead of   int a, *b;   replace with  int a, int* b, float c, ...  Only allow nested pointer, array, function type declaration in typedef statement. allow struct to have constructor and destructor, but no methods. allow returning multiple values (tuples). let include mean import (which forbids effects that depend on the order of inclusion or multiple inclusion) lose the requirement of forward declaration. force curly braces for if/while/for statement"
coding,3c3qbb,hzhou321,14,Sat Jul 4 15:50:21 2015 UTC,"instead of   int a, *b;  replace with  int a, int* b, float c, ...    You already have that, only it's spelled with a (;) instead of a (,)"
coding,3c3qbb,cparen,8,Sat Jul 4 18:27:59 2015 UTC,"Oh yes, you are correct. But my point is to forbid the former."
coding,3c3qbb,hzhou321,3,Sat Jul 4 18:55:12 2015 UTC,Over my dead cold body.
coding,3c3qbb,FUZxxl,8,Sun Jul 5 11:41:41 2015 UTC,lose the requirement of forward declaration.   Oh god this
coding,3c3qbb,Websly,1 point,Sat Jul 4 21:02:53 2015 UTC,"A lot of C compilers are one pass. It only scans down, so you have to declare it before you use it."
coding,3c3qbb,rockyrainy,2,Tue Jul 7 00:02:10 2015 UTC,"Quite frankly, C is only parseable because of that restriction as the grammar is ambiguous without knowing what type an identifier has."
coding,3c3qbb,FUZxxl,4,Tue Jul 7 00:35:12 2015 UTC,"Only allow nested pointer, array, function type declaration in typedef statement.   I’m nitpicking but typedef is actually not a statement but a type specifier, which means that you can write, for example:  int typedef Integer;"
coding,3c3qbb,SciK,2,Sat Jul 4 20:12:22 2015 UTC,"allow returning multiple values (tuples).   The one solid idea from these. All the others are really shitty.   let include mean import (which forbids effects that depend on the order of inclusion or multiple inclusion)   You want something that is not C. Read about how the preprocessor works and what the compiler actually gets to see. It's immediately clear why including type signatures can't work any other way with a model like C has.   allow struct to have constructor and destructor, but no methods.   No! If at all, the other way round. Constructors and destructors are evil because they hide potentially arbitrary behaviour in builtin functions and have complex interactions with program startup. Plus, why destructors when there is no guarantee that they are ever going to run?   lose the requirement of forward declaration.   How so? This suggestion is very vague."
coding,3c2p0r,javinpaul,32,Sat Jul 4 05:05:03 2015 UTC,"I sort of agree with the sentiment, but I feel like there's this thing where people who rather do other things in their spare time are looked down on. Not everyone does coding as a hobby as well as their job, and that's fine. I feel like more people need to understand that."
coding,3c2p0r,armornick,17,Sat Jul 4 10:57:33 2015 UTC,"From my own experiences in workplaces, I have noticed a trend. The people that code at home a lot (doesn't have to be EVERY day) are much better than those that do other things in their spare time.   Also for me personally, every few months I need some time off from coding. Just zero laptop usage at home for a week or two and it recharges me."
coding,3c2p0r,m0okz,8,Sat Jul 4 11:07:30 2015 UTC,"My own experiences have been that the people who write a lot of code in their free time tend to be the people who end up writing big, overly complex monster projects at work instead of taking the time to design something simple that doesn't reinvent the wheel. I think people who really really like programming sometimes like it so much that they write too much code and use too many esoteric language features or constructs. I had to spend a month arguing with one dude about how he was using Python metaclasses excessively and creating an unmaintainable mess.   I write a little code at home now and then when I contribute to open source projects, but mostly I try to restrict that stuff to when I'm at the office to avoid burnout.  Of course, anecdotal evidence can be pretty worthless because of limited sample sizes."
coding,3c2p0r,beefofages,10,Sat Jul 4 15:03:14 2015 UTC,"I disagree. I've seen people who don't code outside of work write the largest, most complex things because they don't grasp certain concepts well or even know about design patterns. The most common reason is ""I have a deadline. There is not time to study new techniques or things I'm not familiar with."" This mentality is so prevalent in my current job that my boss doesn't seem to understand why I would want to show a client something that is just a test layout with no real data yet. They are so used to the devs showing a completed product instead of iterations. Then they wonder why the clients don't use the finished product. My current project needs about 15 changes that I'm currently aware of that were created exactly per the original requirements."
coding,3c2p0r,FreakZombie,5,Sat Jul 4 15:56:29 2015 UTC,"Oh how I hate that ""we have a deadline"" mentality. So because you promised your boss or another manager a certain feature in 8 weeks, that means we should cut every corner imaginable, structure the database completely wrong, have no planning and don't include the rest of the team in any of the design planning, and just rush the entire thing and ruin it?   Welcome to my boss.   He makes me rush code and structure things wrong because of deadlines.   I end up rewriting it at home in the evening because he rushed it during the day.   All of our site code is terrible, both by me and previous developers and even worse by the ""designers""."
coding,3c2p0r,m0okz,8,Sat Jul 4 19:20:44 2015 UTC,"I end up rewriting it at home in the evening because he rushed it during the day.   Stop. Unless you're paid hourly. I know it's hard to do a subpar job when you know you can do better, but this mindset is going to burn you out. Perfectionism is a professional programmer's worst enemy.  If you keep fixing the problems for free the company will not change. When you say ""I need more time!"" it is meaningless to them because they always get a working product. They will listen when problems crop up because they refused to give reasonable deadlines."
coding,3c2p0r,movzx,1 point,Sat Jul 4 20:43:04 2015 UTC,"Ugh, that's the worst."
coding,3c2p0r,beefofages,3,Sat Jul 4 19:58:55 2015 UTC,"Maybe the moral of the story here is that bad programmers are bad programmers, regardless of how much they code outside of work. Coding at home could be a red herring."
coding,3c2p0r,beefofages,2,Sat Jul 4 18:09:23 2015 UTC,Yeah I can understand that. They are probably the crazy ones! And yes you're right about the anecdotal evidence being worthless. I've only worked in a few web places.
coding,3c2p0r,m0okz,1 point,Sat Jul 4 19:15:21 2015 UTC,"I've worked in multiple industries (computer hardware, embedded systems, web shops, and video games) and it's kinda the same story everywhere. I've probably run into people who are more like you've described and just not realized it or not remembered it."
coding,3c2p0r,beefofages,4,Sat Jul 4 19:58:22 2015 UTC,Some of us understand.  I wish work would provide training so the gap between the non-hobbiests and the all the timers was smaller.
coding,3c2p0r,CoderHawk,1 point,Sat Jul 4 14:47:35 2015 UTC,The problem is that training would take time away from productivity. The dev would also benefit from seeking knowledge on a topic vs having training assigned to them like many bosses do. I've managed to show my boss that time I'm spending doing research and learning on my own is actually beneficial. Luckily I'm in an environment that is pretty relaxed.
coding,3c2p0r,FreakZombie,3,Sat Jul 4 16:03:15 2015 UTC,"Something I'm trying to start doing is coding every day at work. My job title is software engineer, but I also manage releases, do code reviews, test code I've written, discuss and think about designs, etc., and many of the problems I'm working are the hardest problems we have to solve so the head-scratching/code-writing ratio is high. What I'm trying to do is go dark (i. e. no email/chat) for two hours a day to work on something that mostly just needs to be written, where the tougher design/product decisions have already been made. The first couple times I've tried this the hardest part was finding useful things to work on that were ready to write but not yet written.  I think this has a lot of the advantages of coding as a hobby, while still keeping a separation between the machine and the rest of your life."
coding,3c2p0r,josuf107,1 point,Sat Jul 4 16:38:23 2015 UTC,"Where did you get the feeling from? I don't think I've ever encountered that kind of attitude. Although I definitely can appreciate feeling like a bit of a pleb when reading places like reddit and Hacker News. For a number of reasons it's easy to come away feeling like you're some kind of failure because you're not churning out high quality, novel stuff on a regular basis."
coding,3c2p0r,drguildo,7,Sat Jul 4 11:13:12 2015 UTC,"From articles like this, and all the talk about 10xers and ""Rockstar Programmers"", and also a lot of people in /r/programming."
coding,3c2p0r,armornick,1 point,Sat Jul 4 11:18:00 2015 UTC,"I think what u/drguildo was saying is that, regardless of those articles, it's not that the community looks down upon people who don't fit that mold."
coding,3c2p0r,w45jws5j,16,Sat Jul 4 21:27:19 2015 UTC,"So the more you do something, the better you get at it? http://i.imgur.com/y71zTJP.gif"
coding,3c2p0r,drguildo,1 point,Sat Jul 4 11:18:26 2015 UTC,I can't believe this is the first time I encounter this brilliant gif. Thank you!!
coding,3c2p0r,xfunky,3,Sat Jul 4 12:29:14 2015 UTC,Tim & Eric are the best. Enjoy.
coding,3c2p0r,drguildo,5,Sat Jul 4 13:26:22 2015 UTC,"I thought about this topic a while ago (and even wrote a blog post about it), so these are my thoughts about this as of today:   People who code in the free time, close to daily, are usually people who like it as a hobby They also tend to be better at it than people who are seeing coding as their job they have to do to pay the bills This is because free-time coders get more practice overall, but especially because they have the opportunity to experiment with software/frameworks/whatever they do not use on their job, thus broadening their knowledge If you do not like coding in your free time, that is fine, too, but fact is, the best coders out there will always be the ones who have fun coding and are constantly improving themselves, which is often difficult when only coding at work, where you tend to do the same things over and over again Taking breaks from coding and pursuing other, non-computery hobbies is still very important, though The balance is the most important part, I personally like having one side-project at a time where I can spend a couple of evenings a week on"
coding,3c2p0r,sulami,10,Sat Jul 4 15:12:50 2015 UTC,"Yeah, blaze it."
coding,3c2p0r,MachinTrucChose,1 point,Sat Jul 4 08:23:14 2015 UTC,It takes about 10K hours of doing something to become really code at it. Coding included. Our brain is wired to learn and get adjusted to doing things by doing. Coding is a classic example of it. You can really tell if it's better to code at home on your spare time or at work only - some work for less hours and do the same non-challenging tasks over and over. Some word a lot and code new things acquiring new skills all over the place.
coding,3c5xoy,franciscohumb,3,Sun Jul 5 03:19:47 2015 UTC,These jobs all seemed to be in a technical area anyway so it's kind of cheating. However he's right that coding will make you approach problems differently and you have a lot more tools in your toolbox that will make you a valuable employee.
coding,3c5xoy,pqu,1 point,Sun Jul 5 06:16:40 2015 UTC,"Well, so does a lot of things. I studied physics at college. I think that helped me become a better problem solver in programming by helping me approach problems differently and providing me with a lot of tools in my toolbox."
coding,3c5xoy,BobTheSCV,1 point,Sun Jul 5 19:39:12 2015 UTC,"Looking forward, more and more of the world will be eaten by software. Coding will become a basic skill. Coding gets important for helping human to understand the almighty machinces that transforms our world."
coding,3c4tbq,madm0use,1 point,Sat Jul 4 20:06:15 2015 UTC,"At first I was like ""pfft it's just an ascii art comic. Lame.""  Then I was like ""ohh there's code in there."" Gotta say I've never seen anything like it."
coding,3c4tbq,veeberz,0,Sat Jul 4 21:01:25 2015 UTC,"lol, yeah i woke up early today, and decided to start a comic series as a new way to package my challenges lol"
coding,3byofj,vsajip,20,Fri Jul 3 06:06:15 2015 UTC,https://www.reddit.com/r/news/comments/3bxueb/reddits_popular_ask_me_anything_feature_is_down/
coding,3byofj,dezoe,5,Fri Jul 3 06:18:31 2015 UTC,"According to this list, it is private.  I didn't notice it went private because I am already subscribed."
coding,3byofj,Klox,3,Fri Jul 3 14:10:31 2015 UTC,https://www.reddit.com/r/OutOfTheLoop/comments/3bxduw/why_was_riama_along_with_a_number_of_other_large/
coding,3byofj,Pvt_Haggard_610,-8,Fri Jul 3 17:15:54 2015 UTC,That's just sad. Moderators should not punish their readers in order to send a signal to the administrators.
coding,3byofj,stefantalpalaru,19,Fri Jul 3 20:20:15 2015 UTC,When readers is how they make money it's the only form of currency they have to bargain with.
coding,3byofj,Whadios,1 point,Fri Jul 3 20:49:48 2015 UTC,The readers are not bargaining chips for power hungry mods to use.
coding,3byofj,vattenpuss,3,Sat Jul 4 12:38:56 2015 UTC,"Power hungry O_o You have no idea what's going on, do you."
coding,3byofj,WhiskeyFist,7,Sat Jul 4 19:19:33 2015 UTC,Most of these subreddits only thrive because there are mods who put a lot of their time and effort into it. They should have some say in things.
coding,3byofj,Mr_s3rius,-5,Fri Jul 3 21:13:31 2015 UTC,Mods certainly should not have some say in internal reddit personnel decisions.
coding,3byofj,Assumer,3,Fri Jul 3 22:43:11 2015 UTC,"This isn't about Victoria's firing, it's about lack of communication and mismanagement from Reddit Inc towards mods and the community. Victoria's firing was just the last straw."
coding,3byofj,willbradley,1 point,Sat Jul 4 06:07:23 2015 UTC,"What about Victoria's right to privacy here? If she doesn't want to go into depth about the situation, shouldn't we respect that?  Also, what about the actual programming, people?"
coding,3byofj,cparen,2,Sat Jul 4 19:21:30 2015 UTC,"When the personnel decisions have ramifications on what the moderators need to do their part? Actually, yes, there should be.  It's called community management."
coding,3byofj,Katana__,1 point,Sat Jul 4 00:44:38 2015 UTC,"Welp, time for me to unsubscribe again. It was bad enough when /r/programming was sympathizing with gamergate, but joining the ""lets ruin Reddit"" protest is a bit much.  Anyone volunteering to start an /r/programming2 like /r/crappydesign2 did? You could make the sub about programming. It would be a novel concept."
coding,3byofj,cparen,-7,Sat Jul 4 19:19:38 2015 UTC,/r/coding should go dark too.
coding,3byofj,lavahot,1 point,Fri Jul 3 08:53:12 2015 UTC,k
coding,3byofj,MasterEjzz,-19,Fri Jul 3 18:27:21 2015 UTC,"It's showing as normal to me, but it'd be a case of nothing of value lost if it was to go dark"
coding,3byofj,PinkBalloons,18,Sat Jul 4 05:01:56 2015 UTC,"Why do you think that? Apart from the 783rd blog post explaining why they have the best method for interviewing, I find the sub to be pretty decent. There are interesting stories on the frontpage most of the time and the discussion is usually on-topic and not just bad puns/jokes or memes as in other subreddits."
coding,3byofj,Wyelho,4,Fri Jul 3 07:43:27 2015 UTC,"Eh, there are a lot worse subreddits, I'll grant that, it's just it often seems to be little more than pointless blog posts, links to SO, and stuff that isn't really of any interest. You're right that it's not as full of pun threads as other subreddits, and as many as there used to be back on /r/programming when this subreddit was created."
coding,3byofj,PinkBalloons,2,Fri Jul 3 08:58:15 2015 UTC,R/programming is a copy-pasted hacker news =\
coding,3byofj,glemnar,4,Fri Jul 3 09:06:35 2015 UTC,"Meh, I don't know how it's been these days, but about a year ago when I unsubscribed it was being flooded with js and ruby hipsters. I subscribed to some other subreddits, and I think my frontpage feed is much better now.  YMMV though."
coding,3byofj,TheBigB86,2,Fri Jul 3 15:03:33 2015 UTC,HackerNews is better.
coding,3byez2,javinpaul,8,Fri Jul 3 04:34:34 2015 UTC,I very much enjoy this video from computerphile which does pretty much the same job as this article (although more simplified).
coding,3byez2,TheWotsit,1 point,Fri Jul 3 14:00:52 2015 UTC,At 13:05 does he mean that plus zero has mapped to looking like minus zero? Isn't that the point?
coding,3byez2,hypermog,4,Fri Jul 3 16:25:10 2015 UTC,Start with a binary representation of the number you need to negate    Flip all bits    Add one    This is literally all we got taught about two's complement at University.  If they had given a lecture similar to the way this article is written I wouldn't have spent years as a programmer not understanding two's complement.
coding,3byez2,archiminos,1 point,Fri Jul 3 09:56:12 2015 UTC,If you invert all the bits and add 1 you end up with -0 having the same representation as 0. This is desirable behaviour. I believe a binary number starting with 1 and followed by all zeros should be the representation of NA which will remain the same when negated.
coding,3byez2,coolsanta,1 point,Sun Jul 5 14:15:50 2015 UTC,"This is a wonderfully written, fantastic article."
coding,3byez2,munificent,0,Fri Jul 3 16:08:01 2015 UTC,"It turns out that there is actually a small difference between signed and unsigned multiplication: detection of overflow. In 3-bit arithmetic, the multiplication –1 * –2 -> 2 produces the correct answer. But, the equivalent unsigned multiplication 7 * 6 –> 2 produces an answer that is only correct in modular arithmetic, not “actually” correct.   That's sort of obscure.  I prefer the separate sign bit, as being more intuitive.  +0 or -0, well, I can cope with that.  You're always going to get this problem, in one form or another, on binary data, because 2**N is always even.  You can't chop that in half and have half the numbers positive,  and half negative, and also have a single zero.  So either you have two zeros, or one zero and one more positive integer than negative integers."
coding,3byez2,Ted8367,18,Fri Jul 3 05:34:22 2015 UTC,"You have to choose, and two's complement is simpler than handling the double zero problem of one's complement, and the extra negative number is not really a problem, it still possible to represent all numbers that one's complement can. Arithmetic is much simple for two's complement, in the sense that it requires less operations and has fewer edgecases.  Two's complement is a more elegant way to represent signed integers."
coding,3byez2,hvidgaard,-1,Fri Jul 3 06:16:18 2015 UTC,"one's complement   Yeah, maybe.  But what I meant was not one's complement, nor two's complement for that matter, but a separate sign bit on the end of a positive integer.  So to negate the integer, you just change the sign bit.  Many years ago, I wrote code for the Burroughs B6700, which had just such an arrangement.  There wasn't any problem in practice.  What I liked about it was that it was nice and symmetrical."
coding,3byez2,Ted8367,2,Fri Jul 3 07:59:05 2015 UTC,Wouldn't that require circuitry specifically designed for handling negative numbers when adding/subtracting?
coding,3byez2,MEaster,3,Fri Jul 3 14:31:43 2015 UTC,"Yes, it would."
coding,3byez2,imMute,3,Fri Jul 3 14:55:23 2015 UTC,"ALU circuitry is a really tiny part of a modern processor, though, and I'd be very surprised if any of the added complexity led to these operations taking any more time.  However you end up representing things, I think it's worth wondering whether the extra negative number (that is, MIN_INT being ""bigger"" than MAX_INT) is a downside of 2s-complement. In a sign-bit representation, you might prefer to use negative zero to encode overflow, and maybe division-by-zero as well. Alternatively, it might be better to simply never use it at all.  Some arguments in favour of these points:   Most programmers can't write code to reliably detect whether an addition will overflow. You obviously can't say, if (a+b > MAX_INT), and even if you know that a and b are positive, you can't say if (a+b < 0) in C (because signed overflow gives undefined behaviour, and a smart compiler will optimise that expression away to if(false). Not being able to negate MIN_INT is an awful corner-case that similarly trips up even experienced programmers.   An example of experienced programmers writing buggy int-handling code.  (John Regehr has obviously thought about this stuff at length.)"
coding,3byez2,repsilat,1 point,Fri Jul 3 18:22:41 2015 UTC,"(that is, MIN_INT being ""bigger"" than MAX_INT) is a downside of 2s-complement.   It's an extra complication that will trip you up at, as ever, the worse possible time.  For example, right here in this thread, I assumed the reverse without thinking about it -  that MAX_INT was ""bigger"".  At least that didn't lead to a big adventure in bug finding.   Not being able to negate MIN_INT is an awful corner-case that similarly trips up even experienced programmers   Yep.  The symmetrical nature of the sign bit and magnitude representation means one less special case to worry about.  The extra hardware needed is worth it, especially these days."
coding,3byez2,Ted8367,1 point,Fri Jul 3 23:48:26 2015 UTC,"There is too much code expecting that you can do operations on unsigned integers and cast them back to integer.  The boat has sailed for one's complement and sign-magnitude, with the exception of floating point which is sign-magnitude."
coding,3byez2,bonzinip,1 point,Sat Jul 4 12:46:20 2015 UTC,"How about ((unsigned int) a) + ((unsigned int) b) > MAX_INT? Also, this is why I hate signed arithmetic."
coding,3byez2,Bobshayd,1 point,Sat Jul 4 04:03:01 2015 UTC,"Ahh, okay, I misread your post then. But negating a two's complement number is really simple, tough not as simple as flipping a single bit, and it's simplifies hardware and microcode/API of the processor because there's fewer edge cases."
coding,3byez2,hvidgaard,4,Fri Jul 3 08:12:14 2015 UTC,"Two's complement still have a ""sign bit"". The most significant bit is a clear indicator whether a number is positive or negative."
coding,3buvlr,Vburyi,34,Thu Jul 2 10:04:25 2015 UTC,Good job guys.  Keep polishing that turd.
coding,3buvlr,reaganveg,11,Thu Jul 2 19:48:11 2015 UTC,"I might get back into PHP. I know a lot of people hate it, but it's actually a pretty fun little language to use."
coding,3buvlr,hero_of_ages,5,Thu Jul 2 16:08:07 2015 UTC,"I love php, it's so easy :) do you know why people hate it? Php was sort of the first language I learned  so that's maybe where my love comes from."
coding,3buvlr,rubennaatje,8,Thu Jul 2 17:12:32 2015 UTC,"PHP: a fractal of bad design  Personally the reason I hate working with PHP code bases is that there are very often security problems caused by the weird semantics of basic operators (==, [], etc.). Unless you know the weird nooks and crannies inside and out, it's very easy to do something that looks right, but which has subtle, sometimes exploitable flaws."
coding,3buvlr,swenty,2,Thu Jul 2 20:38:49 2015 UTC,"Gosh, I tried PHP only once and it was enough to dump it forever. How is even possible that it became so popular? How do people program using it?"
coding,3buvlr,vityok,4,Fri Jul 3 12:20:09 2015 UTC,"It is simple. PHP gives you the impression that your program is done long before it is actually done, pretty much as soon as the happy path looks vaguely correct. Other languages, particularly those with features designed to avoid flaws in the program, make you work harder for that sense of completion. That makes PHP attractive to both programmers who don't know any better and management who wants to ship quickly and doesn't particularly care about correct results."
coding,3buvlr,Taladar,9,Mon Jul 6 09:04:41 2015 UTC,"Have you branched out of your PHP shell yet? Once you do, you typically don't want to go back. PHP is trash and I would never use it again"
coding,3buvlr,ObjectiveCopley,1 point,Thu Jul 2 17:18:24 2015 UTC,"I haven't really made any web-applications in languages outside of php, I do know java and c# though(for java im quite a beginner and i used c# mostly for games).  Do you have any recommended languages for me?"
coding,3buvlr,rubennaatje,3,Thu Jul 2 19:48:30 2015 UTC,Python and NodeJS are both really fun to work with. I work at a Fortune 500 and we use both.
coding,3buvlr,ObjectiveCopley,5,Thu Jul 2 19:59:24 2015 UTC,"thanks! I will definitely look into that, I have my holiday in about 2 weeks, so I guess I now know something to do by that time (next to looking deeper into java) :)   EDIT: added these ( ) so that my sentence wouldn't seem so weird."
coding,3buvlr,rubennaatje,-3,Thu Jul 2 20:55:38 2015 UTC,"Have you branched out of your PHP shell yet? Once you do, you typically don't want to go back.    The problem isn't that PHP is a great language (though, it's not as bad these days as people think, because it used to be much worse).  The problem is that there really isn't a great alternative for web development. If you want to stay mainstream with lots of developers and lots of existing, well-tested code and lots of documentation, you have only these options:  1) C++ 2) Java 3) C# 4) PHP  C++ is a pain in the ass for web-style applications, too shoot-in-the-foot low level, and developers are expensive.  Java would be my second choice, but I hate Java's verbosity. It's just a really painful language to use day in and day out, and feels like you have to write 10 lines to do something that takes 1 or 2 in other languages. That's an exaggeration, but is also sometimes literally true. Developers are probably 2nd-most-expensive.  C# requires entering the Microsoft den of doom. If you stay on the Microsoft path, it's fine, but if you want do anything a bit out of the ordinary, it's a PITA. And the servers and software are expensive. I'm generally a Linux guy, so MS isn't really on my radar anyway. Developers are less expensive, though.  That leaves PHP. It's cheap, easy, fast. Developers are inexpensive and plentiful, though you have to be careful not to get amateurs. Some fantastic frameworks exist. Oodles of documentation and drop-in packages. And PHP as a language is fine -- as long as you enforce discipline and avoid some of the pitfalls. PHP rocks hard when it comes to productivity and actually Getting Shit Done.  So yeah, PHP is not ideal, but I'm still waiting for a better language to become popular and mainstream.  And no, Python, Ruby or whatever language are not nearly as mainstream as the above. Yes, you can get work done with them. No, there aren't nearly the resources available."
coding,3buvlr,nairebis,20,Thu Jul 2 18:19:53 2015 UTC,"Holy shit, you have no idea what you're babbling about, do you?   And no, Python, Ruby or whatever language are not nearly as mainstream as the above. Yes, you can get work done with them. No, there aren't nearly the resources available.   I'm not a web dev, but come the fuck on...be serious...Even I know that's just garbage."
coding,3buvlr,Ikinhaszkarmakplx2,1 point,Thu Jul 2 19:01:15 2015 UTC,Guess in which language the glorious site you're using right now was written?   But does anyone know why? I'm a bit of a noob when it comes to webdevelopment with  those languages. I simply don't really see how python would be superior to php for a site like this. So what are the pros of using python instead of php?
coding,3buvlr,rubennaatje,4,Thu Jul 2 19:44:54 2015 UTC,"I simply don't really see how python would be superior to php for a site like this.   Well, I dunno, ask the YouTube engineers, why they choose Python and Javascript for 'Tube.  I mean YouTube being amongst the heaviest of heavy in terms of webtraffic and use."
coding,3buvlr,Ikinhaszkarmakplx2,7,Fri Jul 3 00:43:17 2015 UTC,Python is much better designed as a language than PHP.
coding,3buvlr,reaganveg,-1,Thu Jul 2 19:59:21 2015 UTC,"While I like writing python and generally like the language, python still has a horrendous implementation."
coding,3buvlr,Papper,-1,Thu Jul 2 20:35:52 2015 UTC,Maybe so.  It certainly takes a long time to start up.  I just use Haskell for everything.
coding,3buvlr,reaganveg,-3,Thu Jul 2 20:49:08 2015 UTC,"I'm not a web dev, but come the fuck on...be serious...Even I know that's just garbage.   So, you're not a ""web dev"", so apparently have no experience with PHP, but you presume to know how large the PHP community is, how many packages and resources are available, and you apparently ""just know"" that Python / Ruby / Whatever are as large as PHP?  Or are you suggesting that the resource base for Python or Ruby is as large as Java, C# or C++? I'd love to hear that case be made.   you have no idea what you're babbling about, do you?   Hmm."
coding,3buvlr,nairebis,2,Thu Jul 2 20:35:17 2015 UTC,"If you want to talk about packages, I would wager than Perl's CPAN has more than PHP's (by any metric)."
coding,3buvlr,imMute,1 point,Fri Jul 3 01:33:07 2015 UTC,"If you want to talk about packages, I would wager than Perl's CPAN has more than PHP's   Perhaps, but speaking as someone who has to use Perl every (fucking) day, there is no way I would start a new project in Perl. And the quality of CPAN is often shitty. And there are very few modern modules (read: useful for today's world) being written in Perl."
coding,3buvlr,nairebis,3,Fri Jul 3 01:41:47 2015 UTC,http://www.modulecounts.com/
coding,3buvlr,dy-dx,6,Thu Jul 2 23:47:09 2015 UTC,"And no, Python, Ruby or whatever language are not nearly as mainstream as the above. Yes, you can get work done with them. No, there aren't nearly the resources available.   Excuse you? That's exceptionally incorrect. Python, Ruby, and NodeJS all have better communities than PHP."
coding,3buvlr,ObjectiveCopley,0,Thu Jul 2 18:38:27 2015 UTC,Better? I'm sure. Are they as large and have the depth and documentation that php does? I doubt it.
coding,3buvlr,bflizzle,1 point,Thu Jul 2 18:42:13 2015 UTC,"Cannot confirm for depth and documentation.  Node has far, far better documentation.  Plus, it has npm - the php community's halfassed attempt at a package manager, composer, is too little too late."
coding,3buvlr,Katana__,1 point,Thu Jul 2 22:08:06 2015 UTC,"Plus, it has npm - the php community's halfassed attempt at a package manager, composer, is too little too late.   Having used many package managers for dev I would have to disagree with you wholeheartedly there. Composer is not in anyway halfassed. I use npm a lot and I wish it worked as well as composer. Node shrinkwrap isn't even run by default and it works in a half assed way anyway. Comparing that to the way composer.lock files are generated makes working in a team so much easier."
coding,3buvlr,tommygnr,2,Fri Jul 3 02:35:59 2015 UTC,"C# requires entering the Microsoft den of doom. If you stay on the Microsoft path, it's fine, but if you want do anything a bit out of the ordinary, it's a PITA. And the servers and software are expensive.    I'm no evangelist but this really exposed you a bit as a fraud.  C# compared to PHP? Give me a competent C# developer any day over a PHP only person.  Heck give me a junior C# developer because guess what: they are learning an actual language, with actual thought given to the design, possessing real objects and inheritance...  Not, like PHP: a cobbled together trainwreck of bullshit.   And the servers and software are expensive.   You meant to write free right?  Visual Studio Community is a fantastic IDE.  Want cheap servers: they're everywhere...    Developers are less expensive, though.   Says the guy who obviously has never hired competent C# people.  A good C# developer can basically name their own price.  However:   So yeah, PHP is not ideal, but I'm still waiting for a better language to become popular and mainstream.   Just use node.  It's ""popular,"" ""mainstream"" (since these apparently matter to you) and uses an actual programming language: JavaScript.  (Yes, JavaScript has more than a few idiosyncrasies but comparing ""quirks"" of a language and mentioning PHP at all is not something I can do with a straight face.)"
coding,3buvlr,Mephiz,0,Thu Jul 2 23:48:30 2015 UTC,"uses an actual programming language: JavaScript   Wha...? You're criticizing PHP (amazingly on the basis of 'real objects and inheritance'!!), yet advocate JavaScript? You can't be serious. I can only conclude that you haven't looked at PHP in a long time or it's a troll. Or maybe you simply don't understand just how broken JS is with objects and inheritance.  I'm guessing you're a Microsoft shill who has never compared the price of a Linux cloud server to a Microsoft one.  C# is a decent language (and MS has decent dev tools), but you're still stuck with Microsoft and Windows."
coding,3buvlr,nairebis,2,Fri Jul 3 01:38:34 2015 UTC,"I think you have a reading comprehension problem so I'll repeat myself a bit.  Objects, inheritance, proper / actual design: C#  Popularity, ""mainstream""ness (which you apparently value): Node. (You probably want to dust off your understanding of JavaScript if you think it has an OO problem but that's an entirely other conversation.)  As for me I write code in JavaScript for node all the time and unabashedly love it. I write C# every day and love it.  I write Python almost every day and love it.  PHP gets in the way.  Have they tossed out all the cruft?  Its been about a year since I was forced to use it so maybe its better?  Is 7 a complete redesign?  Oh look new features! Oh bummer... It's still PHP...  I don't even know why I'm replying to your fanboyism....  I'll just leave you with an interesting new feature in PHP 7 from the article:   The ability to replace fatal errors with exceptions so you can catch them instead of PHP just dying is an interesting new feature.   Literally lol  edit  Just noticed this...   I'm guessing you're a Microsoft shill who has never compared the price of a Linux cloud server to a Microsoft one.   ಠ_ಠ  /r/LinuxMasterRace for life"
coding,3buvlr,Mephiz,-1,Fri Jul 3 03:08:33 2015 UTC,"As for me I write code in JavaScript for node all the time and unabashedly love it.    Your taste in languages is highly suspect.  But, of course, you've completely missed the point. You do understand that computer languages are for creating practical products, right? PHP is not a great language, there is no question about it. But I'm guessing you don't have enough experience to truly understand a lot more goes into creating successful products than just whether a language has some particular feature you like or don't like.  That's the point. It's not that PHP is a great language. It's that PHP is a tool that makes a lot of business sense when you take into account all the factors.  I like C# -- as a language. I, however, detest Windows as a server operating system (thought, it's a fine desktop, personal operating system). That means C# is a terrible business decision and technical decision, even if I like the language.  [But I'm still in awe of the cognitive dissonance of loving JavaScript and it's completely broken 'object' system and terrible semantics while simultaneous dissing PHP whose object system is infinitely superior in every way. I don't think you realize how truly broken JavaScript is. And to use it on a server? -- ugh.]"
coding,3buvlr,nairebis,1 point,Fri Jul 3 03:21:11 2015 UTC,"Image  Title: Types  Title-text: colors.rgb(""blue"") yields ""#0000FF"". colors.rgb(""yellowish blue"") yields NaN. colors.sort() yields ""rainbow""  Comic Explanation  Stats: This comic has been referenced 15 times, representing 0.0211% of referenced xkcds.    xkcd.com | xkcd sub | Problems/Bugs? | Statistics | Stop Replying | Delete"
coding,3buvlr,xkcd_transcriber,1 point,Fri Jul 3 03:21:28 2015 UTC,The answer is NodeJs
coding,3buvlr,casperwho,1 point,Mon Jul 6 17:14:27 2015 UTC,"If you're not against introducing a compiler into your process, Go is a strong contender here.   Although, it's not as low-friction as mod_php; not many languages can boast that.   Python is a strong contender here too, although most of the Python world has moved on from mod_python to mod_wsgi which has other drawbacks."
coding,3buvlr,ericanderton,8,Thu Jul 2 18:55:18 2015 UTC,Have they fixed the fractal yet?
coding,3buvlr,Jdonavan,11,Thu Jul 2 13:45:34 2015 UTC,the fractal of bad design?
coding,3buvlr,rogue780,3,Thu Jul 2 15:17:04 2015 UTC,"I will quote an old Slashdot nugget of wisdom that some graybeard applied to PHP:   If a chunk of shit is flying north at 70 MPH, it's still a chunk of shit."
coding,3buvlr,way2know,12,Thu Jul 2 14:07:07 2015 UTC,Let me take this moment to quote this guy who did this thing;   There are only two kinds of programming languages: those people always bitch about and those nobody uses.
coding,3buvlr,armornick,10,Thu Jul 2 15:52:58 2015 UTC,"What Stroustroup meant with that quote is that languages people bitch about are languages people use. Nothing more, nothing less.  The fact people use or complain about PHP doesn't make it or any other language you care to name any less shitty."
coding,3buvlr,greyfade,4,Thu Jul 2 17:12:38 2015 UTC,"I know. I don't have a particular love for PHP myself. But I've used it recently and I'll tell you one thing about the languages that people generally complain about: they work. A language that doesn't work properly is not even worth complaining about. For all its flaws, PHP is still a language that does what it was made to do, and most of the flaws can be worked around by reading the manual.  But most of all, I actually just quoted something random because the comment I replied to also randomly quoted something."
coding,3buvlr,armornick,6,Thu Jul 2 18:13:50 2015 UTC,"Something that didn't work wouldn't be used at all.  But the only reason people use PHP is the existence of ""legacy"" code (or else not knowing better).  mod_php became popular for reasons unrelated to the language it supported.  It's sad, really, because if mod_php had simply used an existing scripting language instead of trying to design a new one, it would have solved so many problems for so many people down the line.  Now we've got a lot of people and companies and projects hopelessly locked into PHP.  Oh well, shit happens.  You don't want that to happen to your project, though."
coding,3buvlr,reaganveg,4,Thu Jul 2 20:05:58 2015 UTC,"PHP still has a toxic legacy, however. There are still too many tutorials and books and frameworks in circulation that are compatible with the current version that teach and reinforce bad architecture and bad practices. Until PHP makes a breaking change, that won't change, and PHP will still be a terrible tool."
coding,3buvlr,greyfade,4,Thu Jul 2 18:58:11 2015 UTC,People use that quote as if it implies that all the bitched-about languages are equally good/bad. It does not.
coding,3buvlr,LegionSB,-3,Thu Jul 2 16:49:30 2015 UTC,/r/lolphp
coding,3buvlr,viaconqueso,0,Thu Jul 2 18:34:02 2015 UTC,"PHP is bad. It's unexpected weird semantics make it difficult to hold modern, complex code bases. PHP was super easy and quick to begin with, but I sure paid the price later. After having a bad time with PHP 5 I'm not going back to PHP ever. Faster or not, they lost me way before."
coding,3bsha5,alexcasalboni,2,Wed Jul 1 19:58:51 2015 UTC,"the game will be played by compiling its source code, with player input supplied by compiler flags,    Oh god why"
coding,3bsha5,KamiKagutsuchi,5,Thu Jul 2 12:41:03 2015 UTC,The horror....
coding,3bsha5,skydivingdutch,1 point,Wed Jul 1 22:24:25 2015 UTC,This has terrifying implications.
coding,3bsha5,devDorito,-3,Thu Jul 2 04:42:12 2015 UTC,"This guy is really full of himself for making a really stupid program.  Congrats, you made one of the million types unreadably-weird, old-perl-like programs one can do in C++.   Also he seems to be under the impression that there's some war going on between people who like templates and people who like scripting.  That's just...not even an oversimplification; it's barely accurate.  Conceptually it's a false dichotomy, and instrumentally most people use templates (even if they haven't heard of ""metaprogramming"") and fucking everybody knows that you can't replace full-fledged complex computer programs made in Java/C# etc with a set of scripts."
coding,3bu7t0,AvetisG,11,Thu Jul 2 04:48:00 2015 UTC,"Readability impacts everything else.  It doesn't matter how much space or time it takes if it crashes and can't be fixed.  Real time savings come from good algorithms and not syntax. It's possible to be fast without resorting to what amounts to obfuscation and compiler tricks.  Well designed code will be no larger than required. If you can't read it, how can you really understand what is going on?  Readability is the highest priority.  Edit: I thought this was a self post, so hopefully my reply makes sense with the article I'm about to read."
coding,3bu7t0,Heiroglyph,0,Thu Jul 2 06:34:29 2015 UTC,"Thank you for your reply! Yes I agree readability should be your priority BUT when there are times in which performance is begging for crazy optimizations which would inevitably complicate the code base then I think one should ""borrow a bit from readability"" and overcompensate it through comments and documentation. Though documentation gets out of date and creates more maintenance concerns, it is the only way I could think of to battle the introduced complexity. Would love to see if you know of any other ways! Thank you for your time and for reading the post :)"
coding,3bu7t0,spinwizard69,2,Thu Jul 2 13:11:59 2015 UTC,"Thank you for your reply! Yes I agree readability should be your priority BUT    It should always be the priority if the code has the life span of more than an hour.     when there are times in which performance is begging for crazy optimizations which would inevitably complicate the code base then I think one should ""borrow a bit from readability"" and overcompensate it through comments and documentation.    These days performance can often be addressed by buying more hardware.    In any event comments and documentation are directly related to readability and maintainability.     Though documentation gets out of date and creates more maintenance concerns, it is the only way I could think of to battle the introduced complexity. Would love to see if you know of any other ways! Thank you for your time and for reading the post :)   There is no reason for documentation to get out of date.   If that happens the programmer isn't doing his job.   The goal should be to be no more complex than what is required to get the job done.    The only time I can see a need to be ""difficult"" is in the area of high performance computing where you are at the bleeding edge of technology and still can't get work done in a reasonable time frame."
coding,3bu7t0,spinwizard69,-1,Sat Jul 4 08:25:29 2015 UTC,"It should always be the priority if the code has the life span of more than an hour.    Never speak in absolutes. There are always exceptions. There are some very nasty legacy codes which you cannot make readable and can only document as you go through and understand the code yourself - that is just one case.   These days performance can often be addressed by buying more hardware. In any event comments and documentation are directly related to readability and maintainability.    If you are not optimizing when you can while keeping it nice and readable and just powering up then you are essentially giving it a band-aid solution. No good.   There is no reason for documentation to get out of date. If that happens the programmer isn't doing his job. The goal should be to be no more complex than what is required to get the job done. The only time I can see a need to be ""difficult"" is in the area of high performance computing where you are at the bleeding edge of technology and still can't get work done in a reasonable time frame.    Documentation can very easily get out of date, which is why I am stating that it should be the last resort since clean code/architecture is easy to follow. However, there are times when you have to deal with nasty legacy code and this is when documentation is essential, however since legacy code is not permanent because the goal is to rewrite it and perfect it, there is a good chance that documentation might change (it might not but saying that it shouldn't change is a bit wishful thinking to me)."
coding,3bu7t0,keepthepace,2,Sat Jul 4 18:04:56 2015 UTC,"Never speak in absolutes. There are always exceptions. There are some very nasty legacy codes which you cannot make readable and can only document as you go through and understand the code yourself - that is just one case.   Readability should absolutely be a priority in software development.   It doesn't matter if a half assed programmer worked on the project before you.    Honestly you sound like you are making excuses here.     If you are not optimizing when you can while keeping it nice and readable and just powering up then you are essentially giving it a band-aid solution. No good.   Baloney!    First off; it is not a good idea to begin optimization early.   Second; if performance is a problem you can refactor the code and still have very readable prose.   Third; buying faster hardware makes a lot of sense, especially if the developers time is valuable.   In fact buying faster hardware is what has turned many GUI platforms into acceptable workstations.     Documentation can very easily get out of date, which is why I am stating that it should be the last resort since clean code/architecture is easy to follow.    What I'm saying is that it is the programmers responsibility to make sure the documentation is up to date.   If it isn't he isn't doing his Job.   That doesn't mean that the code shouldn't be cleanly written.     However, there are times when you have to deal with nasty legacy code and this is when documentation is essential, however since legacy code is not permanent because the goal is to rewrite it and perfect it, there is a good chance that documentation might change (it might not but saying that it shouldn't change is a bit wishful thinking to me).   Who said it shouldn't change?    More so I'm not sure your idea and my idea of what documentation is are the same thing.   Especially in the context of what is included in the source code.    Maybe I wrong but I just get the impression you are looking for excuses to write sloppy code.   No one is perfect but a well managed project will demand clean, readable code, even if you are maintaining legacy work."
coding,3bu7t0,ericanderton,-1,Sat Jul 4 20:51:00 2015 UTC,"Readability should absolutely be a priority in software development. It doesn't matter if a half assed programmer worked on the project before you. Honestly you sound like you are making excuses here.    Nobody is saying that readability is not a priority. But there are times when complexity is so high that no matter how much you break it down it will still not matter much (think frameworks, think legacy systems) this is when I say documentation is essential and documenting the WHY not the HOW as in WHY it does what it does instead of HOW it works because HOW changes more frequently. Sometimes it will take away from readability but at times it is inevitable. We can agree to disagree - that's totally fine.  Also I think here is the root of our disagreement - you think that when I say complex code needs documentation in your mind complex is equivalent to sloppy and in my mind complex code can still be written very elegantly. It is just that some problems are complex, and code is complex to understand no matter how clean and modularized it is. I feel like that is the root of our disagreement, which seems more to me as a misunderstanding.    Baloney! First off; it is not a good idea to begin optimization early. Second; if performance is a problem you can refactor the code and still have very readable prose. Third; buying faster hardware makes a lot of sense, especially if the developers time is valuable. In fact buying faster hardware is what has turned many GUI platforms into acceptable workstations.    You should always keep optimization in mind as you are coding. You are saying don't optimize too early? Well then let's just go and make O(n2) all over the place with no optimization in mind. Even when you are considering of using a single loop vs nested loop or using certain kind of data structures you are optimizing early - that's the first stage and it is necessary to have good code. What you are talking about is premature optimization and yes I disagree with that but it is totally different from what I am speaking about here.   What I'm saying is that it is the programmers responsibility to make sure the documentation is up to date. If it isn't he isn't doing his Job. That doesn't mean that the code shouldn't be cleanly written.    Never said that just because you document it gives you a responsibility to write bad code. All I am saying is that, once again, sometimes the problem/solution is complex no matter how much you break it down and so try to do the best you can to keep it clean use SOLID, YAGNI etc and then on top of that add documentation because readability most of the time is not going to be as easy as the rest of the code since it is complexity introduced out of necessity. I hope you can see my point here.   Who said it shouldn't change? More so I'm not sure your idea and my idea of what documentation is are the same thing. Especially in the context of what is included in the source code. Maybe I wrong but I just get the impression you are looking for excuses to write sloppy code. No one is perfect but a well managed project will demand clean, readable code, even if you are maintaining legacy work.   Please stop with these passive aggressive comments. If you want to discuss this like two adults then I am more than happy but making these wild assumptions without truly trying to understand my point of view is just silly, which makes me want to not continue this conversation.  Yes once again nobody is saying go and write bad code. Please don't misconstrue what I am saying, understand the subtleties. I am saying it is not a good practice to be commenting and documenting everything - just document what needs to be documented (mostly complex areas of code). And document the WHYs not the HOWs and should be in good shape. Hope this clarifies my point of view a bit."
coding,3bu7t0,Keilly,2,Sat Jul 4 21:53:25 2015 UTC,"Here is my take:   As long as it does not work, readability comes first. You should always try to have a low code repetition (i.e. high code reusability). It helps readability, it prevents bugs and it can even help to optimize later. This is (in my case) the highest gain on ""space"" that you can have. In my experience, optimization is necessary on only two levels: the algorithmic level ( bring that O(n2) down to O(n.log(n)) ) and on the most inner loop (make this per-pixel function call inline and correct the constness of your parameters). I am sad to say that for all the rest, it was more profitable to just upgrade hardware... One important thing to keep in mind is that the code you write with the hope to correct one day has a 95% chance of never being touched again. You may read it again, but refactoring is often not worth the time. So don't optimize too early but keep in mind that the quick hack you are making is gong to stay longer than you believe. Plan for that. Tag functions that you have optimized heavily with comments. My personal take is to consider that if such a function needs to be modified, it is more reasonable to rewrite it from scratch.   TL;DR: There is a high cost in optimizing a thing that does not need to be. If you have to optimize, do it heavily and choose the places where you do it carefully."
coding,3bu7t0,ephrion,2,Thu Jul 2 13:39:44 2015 UTC,"Readability is first and foremost.  One can never know how long a piece of software will live; lest some maintenance programmer (even yourself) take your name in vain, make everything as clear as possible.  As for optimization: your time is always more expensive than hardware.  If you architect a solution such that material changes in hardware can overcome performance issues, that's an automatic win. Generally speaking, it's easier to scale into ever more memory first (systems are usually set up to expand RAM), multiple servers second (depends on application), and multiple cores last.   I put multi-CPU last since everyone is still figuring out how to make that as transparent as a RAM upgrade. I fully expect that sentiment to be obsolete in a year or two.  In the meantime, consider what it would take to split the app into multiple concurrent processes with minimal communication first, before investigating multithreading.  Then comes the hard-core black-magic stuff.  Mutilating code to increase time & space performance has to be done sometimes, but it should only be done a) after measuring twice and b) in a way that is documented forwards and backwards.  Again, think of the maintenance programmer.  You're probably not the guy that's going to invent another ""inverse square root"" style optimization, so keep it straightforward if possible. If the optimal solution looks like code that shouldn't have passed code review, write 10 lines of comments explaining why they shouldn't delete or rewrite it."
coding,3bu7t0,tootie,1 point,Thu Jul 2 16:27:51 2015 UTC,Code is for people to read. It is translated later into something the machine can understand.
coding,3bvzw0,leonardofed,1 point,Thu Jul 2 16:36:49 2015 UTC,"So I think it would also be important to know what the numpy library is doing differently. It doesn't help anyone who wants to understand the low level to say ""use x library instead"" and where the basic numpy docs plainly say they use ""powerful objects""."
coding,3busxz,byrnedo,1 point,Thu Jul 2 09:26:31 2015 UTC,English Translation?
coding,3box7m,icandoitbetter,2,Tue Jun 30 23:25:28 2015 UTC,"It's a great idea, but does it work reliably?"
coding,3box7m,grass__hopper,1 point,Wed Jul 1 16:22:05 2015 UTC,"Well it's using Google probably not, even it gets caught up a lot."
coding,3box7m,jreid42,1 point,Wed Jul 1 18:54:12 2015 UTC,Really cool awesome stuff!
coding,3bm78p,alexcasalboni,19,Tue Jun 30 10:10:46 2015 UTC,"TIS-100 is great fun! There's a subreddit (/r/tis100) and an IRC channel (#tis100 on Freenode) in case you're curious. It's really hard to sell TIS-100 to other people, most programmers I know who have tried it got hooked almost immediately."
coding,3bm78p,FireyFly,13,Tue Jun 30 12:09:40 2015 UTC,It's like programming 16 parallel CPUs with an extremely simple design. Very fun and interesting challenges.
coding,3bm78p,nfearnley,6,Tue Jun 30 13:50:18 2015 UTC,So it's like PS3 programmer the game?
coding,3bm78p,Doriphor,2,Tue Jun 30 22:19:44 2015 UTC,"There's even a DLC pack which, if you download it, Sony will sue you!"
coding,3bm78p,RenaKunisaki,1 point,Wed Jul 1 03:58:44 2015 UTC,Somewhat related twitter thread
coding,3bm78p,FireyFly,1 point,Wed Jul 1 04:46:50 2015 UTC,@FioraAeterna   2015-06-30 23:56 UTC  I am a GPU compiler dev and this is horrifying https://twitter.com/rygorous/status/616031806354141185     This message was created by a bot  [Contact creator][Source code]
coding,3bm78p,TweetsInCommentsBot,10,Wed Jul 1 04:46:55 2015 UTC,"Huh, I saw Steve Losh push some TIS-100 vim syntax and wondered what the heck it was."
coding,3bm78p,Trout_Tickler,7,Tue Jun 30 11:37:00 2015 UTC,Looks like dance steps for a robotic marching band.
coding,3bm78p,Bottled_Void,3,Tue Jun 30 15:52:58 2015 UTC,"I thought something similar, I was so confused by the syntax."
coding,3bm78p,Trout_Tickler,13,Tue Jun 30 16:13:30 2015 UTC,"Them: “The last thing I want to do when I come home is program again”  awkward silence  Them: “You’re nuts.”   I get this a lot actually, but it stands to point out that when I go home and code, I don't do work. I work on different kinds of programming problems. I have complete autonomy, I can leave it without consequence when I get bored of it, and it almost always uses different parts of my brain than my current work.  I liken it to a chemist that likes to dabble in cooking as a hobby. Technically, both are tasks that require using equipment and methodology to enact various chemical reaction in a controlled fashion. The difference is one is work, and the other is play.  edit-add, other apt analogies:   Retail sales worker that likes to hang out with friends (both involve interpersonal tasks) Auto mechanic that is restoring an old classic car in spare time (obvious) Office worker that likes to read Facebook (both are basically data processing tasks) Accountant that likes Sudoku (both tasks involve balancing numbers in grids) Anyone ever who commutes and likes driving their car."
coding,3bm78p,cparen,3,Tue Jun 30 16:36:09 2015 UTC,Them: “The last thing I want to do when I come home is program again”   This is really the Exception. Many who contribute to FOSS in their free time have a day job as a programmer.
coding,3bm78p,amphetamachine,6,Tue Jun 30 14:53:31 2015 UTC,"I don't know if it's the exception... But it's what separates those who truly love programming from those who don't. I'm 32 with kids, a wife, a house, and hobbies, but I do still like to code at home when I come up with a good idea for something."
coding,3bm78p,mackstann,1 point,Tue Jun 30 16:12:27 2015 UTC,"So, like the JVM then?"
coding,3bm78p,rlee0001,1 point,Tue Jun 30 23:31:12 2015 UTC,I just bought this game a few days ago. It's pretty fun.
coding,3bm78p,Grazfather,1 point,Wed Jul 1 01:07:29 2015 UTC,I learned about this game thanks to you! I don't usually purchase full price games on Steam but I made an exception and bought it. I'm excited!
coding,3bntwu,alexcasalboni,1 point,Tue Jun 30 18:37:52 2015 UTC,You can in fact write a reliable regex pattern for phone numbers....
coding,3bm1d6,alexcasalboni,1 point,Tue Jun 30 08:47:25 2015 UTC,"Interesting. FTA: ""The general idea is that you can supply an input image, and define a subset of pixels that you'd like to ""select"" (example: ""give me all the pixels on the left half of the image""). You can then specify an operation you'd like to be applied on each of those pixels (""invert the pixels""). Using a series of selections and operations, you can perform coplex image manipulations.""  Doesn't seem to have a TON of functionality right now but this is an interesting idea with a potentially useful future."
coding,3bnl7m,wkilpan,1 point,Tue Jun 30 17:36:14 2015 UTC,"Both of the lines seem to jump around randomly. The red line does depict random data, but the blue line comes from our logistic model when the growth rate is set to 3.99.   Your label is was backward."
coding,3bk8w7,dinatekno,6,Mon Jun 29 22:17:36 2015 UTC,"I wonder if a carefully crafted ""donor"" can implant a vulnerability in an otherwise secure program using this system."
coding,3bk8w7,FTFYcent,1 point,Tue Jun 30 04:31:56 2015 UTC,"It's very possible that modifying code to patch a known crash will result in the creation of unknown crash conditions. So, it should be possible to craft a malicious source program that introduces specific crash logic."
coding,3bk8w7,DaemonXI,2,Tue Jun 30 06:07:57 2015 UTC,"So, like the opposite of stack overflow?"
coding,3bk8w7,yopla,1 point,Tue Jun 30 03:41:32 2015 UTC,"It's more like the exact same thing as stack overflow, just binary rather than cut + pasting source."
coding,3bi9o1,alexcasalboni,12,Mon Jun 29 13:16:03 2015 UTC,"Hey /r/coding! (I'll copypasta my hello from /r/programming)  Author here. We built tota11y at Khan Academy as a fun and educational (we like teaching) way to visualize, diagnose, and learn about accessibility violations after seeing first-hand how cumbersome and noisy results from automated testing solutions can be.  I wrote about some of these thoughts non our KA Engineering Blog.  Happy to answer any questions you may have – ask away :)"
coding,3bi9o1,jordanscales,4,Mon Jun 29 19:21:41 2015 UTC,This is a fantastic idea. Accessibility is something that is often overlooked. I'll have to check it out. :)
coding,3bi9o1,storiesti,1 point,Mon Jun 29 21:21:06 2015 UTC,"This is really great! My go to for testing accessibility has been to visit my sites from a terminal browser (lynx, links, etc.). I figure if it's usable and friendly in that setting, it should be pretty reasonably accessible. I'll be using your bookmarklet as well.  One issue I noticed is that it doesn't like images as link ""text."" For example,  <a href=""/archives/""><img src=""archives-icon.png"" alt=""Archives"" title=""Archives""/></a>   It sees the link text as empty when it should probably be considered as being the alt text of the image. (As in, you should still complain if the link text is just a decorative image.)"
coding,3bi9o1,skeeto,2,Tue Jun 30 14:52:24 2015 UTC,"Thanks for the kind words :)  And that's a documented bug, should be fixed soon! https://github.com/Khan/tota11y/issues/1"
coding,3bi9o1,jordanscales,4,Tue Jun 30 18:24:29 2015 UTC,This looks really polished. I like it.
coding,3bi9o1,therealjohnfreeman,3,Tue Jun 30 03:38:53 2015 UTC,"I love this!  Accesibility is something that's trivially easy to support, yet that people often just overlook."
coding,3bi9o1,aeflash,12,Tue Jun 30 07:28:13 2015 UTC,I think it's to demonstrate how the tool works
coding,3bi9o1,Jake0Tron,6,Mon Jun 29 16:01:58 2015 UTC,Yes they do.   tota11y can be found in the bottom left corner of this page. Here are some UI elements to try it on.
coding,3bej0o,alexcasalboni,14,Sun Jun 28 14:15:50 2015 UTC,I'm not really sure the world truly appreciates the amount of hacking involved here. This is a hack so clever I'm amazed it even exists.
coding,3bej0o,skurk,3,Mon Jun 29 07:18:27 2015 UTC,That's literally zero tool hacking
coding,3bej0o,meshugga,1 point,Mon Jun 29 05:01:59 2015 UTC,https://www.youtube.com/watch?v=rJp86_tj9KQ  This hack is incredible.
coding,3be7e6,alexcasalboni,6,Sun Jun 28 11:39:01 2015 UTC,"I'm waiting for first impressions, how different is it from the official docker tutorial? (There used to be a tutorial for docker on their website with a virtual terminal, I couldn't find it now)"
coding,3be7e6,clstr,3,Sun Jun 28 12:39:34 2015 UTC,"The official tutorial lab on Docker's website (I'm also not sure it's still there) was a terrific first-steps introduction to how Docker really works. I found that it removed a lot of my initial fear of trying something new. This course seems to offer a bit more background and depth. Sure, you can probably find all of its points spread over a half a dozen documentation pages here and there, but the Cloud Academy course seems to offer everything in one place."
coding,3be7e6,elenaward,1 point,Sun Jun 28 13:54:18 2015 UTC,Great course. Thanks OP.
coding,3bhhpx,Max00355,2,Mon Jun 29 06:55:59 2015 UTC,Looks great. How about features like  search by language and a short description of what snippet does.
coding,3bhhpx,krazy-Ay,0,Mon Jun 29 18:23:41 2015 UTC,"Thanks man! The current keyword search does actually let you search by language, keywords in code, keywords in title, and poster. I was also intending for the title of the post to be about what the code actually does. Do you think there needs to be a more in depth description?"
coding,3bhhpx,krazy-Ay,1 point,Mon Jun 29 18:38:32 2015 UTC,Since they are just snippets so I think one or two line description will do. Also if you could categories the snippets based on language type then it will be easier for others to look and will look uncluttered.
coding,3bhhpx,krazy-Ay,0,Mon Jun 29 19:22:41 2015 UTC,"Hmm, okay, I can do that. I will add that to my list of things that need to be done. In the mean time check out the new features! I've added commenting, down voting, embedding, and converting the snippets to images to be distributed!"
coding,3be704,alexcasalboni,3,Sun Jun 28 11:32:36 2015 UTC,This is great unless you have to use VS2013 which still fails to automatically generate move constructors.
coding,3be704,anttirt,1 point,Sun Jun 28 11:37:10 2015 UTC,I am not familiar with C++. Why does the Example class need the copy constructor with default? Why is it uncopyable without / not autogenerated in that case?
coding,3be704,ixampl,1 point,Mon Jun 29 02:35:55 2015 UTC,"The point of this example is what happens when you add a copy constructor when you don't need to.  They only copy the first member (m_double), so the second member (m_bool) is always unconditionally initialised to be false (its default value).  If the copy constructor was not present, it would simply default to copying both.  This is obviously contrived, but can easily happen when you refactor code--suppose someone added the field m_bool without going through the whole class to ensure that all of the copy and move constructors, assignment operators and destructors were updated to initialise/copy/clean up respectively.  It can happen quite easily once classes get larger and you don't spot all the places that need updating."
coding,3be704,RogerLeigh,1 point,Mon Jun 29 18:45:11 2015 UTC,"I should have made clear I was referring to the second example. I was referring to this statement:   The problem is that while unique_ptr provides the correct destructor, unless we want the class owning the unique_ptr to be uncopyable, it doesn’t do what we want for the copy constructor/assignment.   The article says that we need a copy constructor there or the class becomes uncopyable. Why?"
coding,3be704,ixampl,1 point,Wed Jul 1 08:39:17 2015 UTC,"Ah, right.  This is because unique_ptr is not copyable or assignable.  The implication of this is that any class containing a unique_ptr will not get the default compiler-generated copy constructor or assignment operator, since it's not possible to do memberwise copying or assignment (this is defined in the C++ language spec).  In consequence, if we want to have a copy constructor or assignment operator we need to:   create them by hand, or make the noncopyable/nonassignable class copyable/assignable using semantics we define (as done later in the article)"
coding,3be704,RogerLeigh,1 point,Wed Jul 1 12:55:42 2015 UTC,Thank you very much! I assumed unique_ptr was just a library-provided feature and wondered how this would lead to something (compiler-enforced) uncopyable.
coding,3be704,ixampl,1 point,Wed Jul 1 13:22:47 2015 UTC,"It's definitely not ""black magic"" of any sort, it is just a library-provided class, though it does rely on C++11 rvalue references.  If you take a look at e.g.  http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/memory?revision=240163&view=markup   lines 236-253 you'll see that in addition to the standard constructors, there are three ""move"" (not copy) constructors taking rvalue references (&&) of different types, and an equivalent set of ""move"" (not copy) assignment operators also taking rvalue references.  The rule is that if any move constructor or move assignment operator is defined, then no default copy constructors or copy assignment operators will be defined either.  It's for this reason that the unique_ptr isn't copy constructable or copy assignable, while being move constructable and move assignable, allowing transfer of allocated memory between pointers, but not copying/sharing.  I got ""Effective Modern C++"" (Meyers) a few months back, which is where I found all this explained.  http://shop.oreilly.com/product/0636920033707.do  If you're interested in all the details, I'd highly recommend it--it's pretty accessible and covers most of the new C++11/14 features well, along with rationale and background for them, which I found very helpful."
coding,3be704,RogerLeigh,1 point,Wed Jul 1 18:40:49 2015 UTC,Thanks for your detailed explanation and book recommendation!
coding,3bd6nm,javinpaul,3,Sun Jun 28 02:40:24 2015 UTC,Even Go developers want to escape developing in Go.
coding,3bd6nm,SCombinator,1 point,Sun Jun 28 04:57:35 2015 UTC,Why? I thought Go is getting a lot of praise everywhere?
coding,3bd6nm,Sol_Invictus481,7,Sun Jun 28 07:07:15 2015 UTC,"Tried it, spat out the kool aid. I don't like a language that prevents you from having reusable collections, nor one that solves this problem by casting to Object or Interface{} or whatever. It's kinda Java 1.4.2"
coding,3begs6,ankush_sharma,1 point,Sun Jun 28 13:50:36 2015 UTC,What happens if it feeds on itself?
coding,3begs6,brtt3000,0,Sun Jun 28 17:07:03 2015 UTC,On itself means ?
coding,3begs6,brtt3000,1 point,Sun Jun 28 18:00:06 2015 UTC,"Post the prediction, have it make another prediction, repeat."
coding,3b6aj3,alexcasalboni,23,Fri Jun 26 09:07:30 2015 UTC,"As an admin on a GitHub Enterprise instance, I can remove a fork from a network and do some other basic maintenance on the fork/network structure.    If github.com made some of these options available to repo owners (mainly 'change parent' and 'detach from network'), it would help address some of these complaints.  I suspect the reason it isn't available on github.com has to do with the logistics of reindexing after every move.  Here's a screenshot for reference"
coding,3b6aj3,paperhat,5,Fri Jun 26 12:36:21 2015 UTC,Here's another flaw:   Couldn't load network graph. Too many forks to display.
coding,3b6aj3,jtredact,7,Fri Jun 26 20:49:52 2015 UTC,"Stop treating the “root” special.  GitHub needs to get rid of the link to repo that the current repo was forked from. Maybe replace it with a link to network tab instead.   GitHub makes it easier to see a repo's history. Tons of forks are abandonded and should be treated specially. If you don't want to link to the repo you forked, then manually ""fork"" it by cloning and pushing to a new repo.   We need need better visibility into the forks.  We need place to list out forks and show them off with everyone else that has a fork.   Network graph page. It's also useful at telling which forks (or even the current repo) are abandoned."
coding,3b6aj3,Zren,13,Fri Jun 26 17:21:00 2015 UTC,"Before git and mercurial, merging was a nightmare in most monolithic source control systems and something that was to be avoided. The only real solution was have everyone work in one repo and work on a single version at a time which doesn’t scale.   What the actual fuck. I've worked in big teams with feature branches and the inevitable merges and it was a blast in subversion. Sometimes I wonder where this git wisdom comes from. Yea it's nice that it's distributed, and right now it's the dominant VCS, so you'll find guides and solutions for all kinds of problem.  But I'd really like to see one major difference in terms of branching/merging to subversion. I honestly don't see it and hence don't get the hype git is experiencing (I use it, I just don't get the ""git > *"")."
coding,3b6aj3,rtfmpls,24,Fri Jun 26 12:04:50 2015 UTC,http://stackoverflow.com/questions/2471606/how-and-or-why-is-merging-in-git-better-than-in-svn
coding,3b6aj3,Dementati,6,Fri Jun 26 12:23:59 2015 UTC,great link/post. thanks
coding,3b6aj3,sublimemm,0,Fri Jun 26 13:57:29 2015 UTC,However this way of specifying ranges of revisions gets quickly out of hand when the version tree grows as subversion didn't have any meta data on when and what revisions got merged together.    That's not true. Probably because the original answer is from 2010.
coding,3b6aj3,rtfmpls,8,Fri Jun 26 19:45:27 2015 UTC,"This sentence is under the header ""So why did Subversion merges suck?"""
coding,3b6aj3,Dementati,-3,Fri Jun 26 20:14:29 2015 UTC,So how is that relevant to what I'm saying?
coding,3b6aj3,rtfmpls,5,Fri Jun 26 22:10:13 2015 UTC,svn added that after git was already getting popular (1.5 iirc) ... i.e. they were kind of late to the show.  It's still a great choice for centralized stuff though.
coding,3b6aj3,jij,1 point,Sat Jun 27 00:46:15 2015 UTC,It's not the only header.
coding,3b6aj3,Dementati,2,Sat Jun 27 06:04:03 2015 UTC,"But submerged fixed after git was already there. Too late, as it seems."
coding,3b6aj3,lestofante,10,Sat Jun 27 00:12:21 2015 UTC,"You must have skipped the great fun that could be had when merging in Subversion before release 1.5, then... It's usable now, even if it's still miles behind git or Mercurial, but back then it used to suck, suck, suck. You would have to fight your tooling, instead of having it help you. Took years until it got merging right. That's why Subversion lost a ton of mindshare."
coding,3b6aj3,Moocha,4,Fri Jun 26 15:46:44 2015 UTC,"I'm a longtime SVN user, who just recently(Earlier this week.) converted my private repository over to git for testing purposes, to see if I like it.  So far(It's barely been two days, and I've not really actually used it yet.) the obvious superior differences(this doesn't necessarily have to do with merging and forking. And disclaimer: It hasn't really had time to piss me off with problems yet. They may still be lurking there.) that I've noticed so far are as follows:   Distributed repositories are good. Not only does my server have the full repository, with all commit history, so does every client I use. Offline commits. And commit history. Internet goes down? I can still do stuff without building up a backlog of shit into a huge commit. Or look up my commit notes from a few months back to remember which files I was fiddling with and why. Git appears to be hands down faster, network-wise, and the repository data is far smaller. eg: My SVN repository is 500+MB. My converted git repository with the same data, is a bit under 90MB. It also conveniently compresses shit before sending it over the network, saving me time. While the actual conversion of a repository from SVN to git is kind of annoying and could be documented much better(Despite there being a page of official instructions for it.), actually setting up and using git is stupidly easy, compared with SVN. There's no need to fuck around with apache or SSL certificates(https) for example; git's preferred access method is ssh, so install git, start it up, and you're basically done, and using encryption with a secure network-facing frontend. As a primarily Windows users(server's linux), the Tortoise apps make switching revision control systems easy in terms of UI learning curve. There's TortoiseSVN, TortoiseHG(Mercurial. Tried it in past and the cryptic error messages and ease of it screwing up pissed me off very quickly.), and TortoiseGit.   edit  I've run into a couple downsides, so far.   While SSH access is nice enough, and it's super quick to get going, it's very basic, and doesn't scale well administratively. Configuring Smart HTTPS with apache is more of a pain in the ass, mostly due to documentation being lacking or contradictory. Did eventually get it working, but it took hours to puzzle through, and some of the issues either had no error message at all(Other than things simply not working inexplicably.) or the error messages were generic and unhelpful. More a frontend issue than a core issue, TortoiseSVN doesn't care about self-signed or expired TLS certificates, and will, like most applications, pop up a warning and allow you to inspect and accept the problem certificate. This is pretty sane and user-friendly behavior. TortoiseGit on the other hand, is pretty anal-retentive about it, and having to explicitly allow my own server's certificate via commandline is pretty annoying, when every other app on the planet will pop up a warning and let you allow and remember it there."
coding,3b6aj3,Azuvector,3,Sat Jun 27 01:23:07 2015 UTC,"Sure, but SVN doesn't handle binary assets any better. So at worst Git is just as small as SVN and at best, way smaller."
coding,3b6aj3,nemec,1 point,Sat Jun 27 04:27:37 2015 UTC,"Yep. I've got all sorts of crap in there, including binary assets. SVN handles them just as badly or worse. Git's far smaller."
coding,3b6aj3,Azuvector,1 point,Sat Jun 27 06:17:38 2015 UTC,"When it comes to branching:  I wish I knew subversion better, but the super thing about git branches is that they're extremely light and easy to manipulate - because a branch is just a label for a commit, no more and no less!    The one difference between a branch and a tag is the concept of ""pushing"" and ""pulling"" - and even these are just convenience functions to encourage natural forward motion.   It is however extremely easy to reset a branch to contain any commit you like.  The workflow you get when you realize this is astonishing - you have to be careful you don't go crazy when you realize the power.  For example, when I'm working on a branch, I might make as many as a hundred tiny commits in a day or two.  If I discover I've introduced an issue that unit/regression tests didn't catch, I can use git bisect to track down to the very moment I screwed up.  When I finally have it all working, I simply create a new branch with exactly the same commit (which implies a chain of commits leading to it) in it, and then start to rebase down.  If I screw up, I can immediately reset this branch to the original ""hundred tiny commits"" (as in ""one short command that works instantly"").  When I've finally rebased down to a small number of commits, I replace the original branch with that final commit, and for safety, move the ""hundred tiny commits"" onto the experimental branch.  None of the commands are long or complicated, and all the branch commands are O(1) commands (i.e. instantaneous, no matter how big your repo is).  The rebase's complexity depends of course on the number of changes and the sizes of the files changed, but in practice, it seems instant too, even in big repos."
coding,3b6aj3,TomSwirly,3,Sat Jun 27 06:45:26 2015 UTC,The only real solution was have everyone work in one repo and work on a single version at a time which doesn’t scale.   I wonder how we ever survived before Git. Surely no sizable software was ever created before Git.  /s
coding,3b6aj3,criswell,12,Fri Jun 26 17:06:14 2015 UTC,"Have you ever worked on a large distributed project supported by e.g. CVS? It's certainly possible, but oh my god, it's slow and annoying."
coding,3b6aj3,ascii,3,Fri Jun 26 18:33:23 2015 UTC,He must be a sys admin. Those guys love CVS.
coding,3b6aj3,movzx,1 point,Fri Jun 26 19:41:14 2015 UTC,"I've worked in the industry since 1995, and have worked on large projects with CVS and SVN as well as Git and Mercurial (my current job is Configuration and Build Management with Git).  Honestly, if your team found it slow an annoying to work with CVS then you guys were doing something wrong. CVS and SVN scaled perfectly well, and weren't that hard to use correctly.  Truthfully, I wouldn't say Git/Hg are inherently better than SVN. They do somethings much better, but they have their own problems as well which SVN didn't have. They are different, with different problems and different strengths."
coding,3b6aj3,criswell,3,Fri Jun 26 20:59:26 2015 UTC,"No, he said that GitHub doesn't follow Linus' principles."
coding,3b6aj3,pwnedary,1 point,Mon Jun 29 11:16:53 2015 UTC,"Oops, I missed the ""not""."
coding,3b8k73,XSearch,1 point,Fri Jun 26 21:01:43 2015 UTC,i'm sure pair programming works.  it may even work for actual professionals and not girls in middle school  the problem is idiot managers REQUIRING it as though it is The Ultimate Solution to all programming
coding,3b8k73,anon0108,1 point,Fri Jun 26 21:35:45 2015 UTC,we have a pairing station.  i dont really get it.
coding,3b2pz3,alexcasalboni,2,Thu Jun 25 14:18:40 2015 UTC,So Java is like Objective-C with a nice syntax?
coding,3b2pz3,pwnedary,5,Fri Jun 26 12:04:25 2015 UTC,That explains a lot. I hate them both!
coding,3b2pz3,root88,7,Fri Jun 26 03:23:35 2015 UTC,I'm okay with Java. It's really not a terrible language. I just wish Java devs liked Java. It seems like every one of them secretly wish to program in XML. That aside it attracts too many pattern hipsters.  Objective-C though. Fuck everything about that. It's an overly verbose pile of crap. I can't stand cocoa because of that. It doesn't matter what language you program it in. You can still see the ick factor shining through.
coding,3b7mx0,peterpet1,0,Fri Jun 26 16:58:13 2015 UTC,"This might be the absolute worst code I've ever seen:   Creating a new Database connection in each webservice method No abstraction at all Using HTML tables for layout (?!?!) All your javascript not just in one file, but inside a script tag in the main page (which means goodbye caching) Same goes for the CSS And because I feel the need to reiterate this: lacking in any kind of abstraction"
coding,3b65g6,aStealthyWaffle,4,Fri Jun 26 07:51:26 2015 UTC,"This subreddit is more geared towards posting and discussing articles about the coding world and developments in languages, etc. For questions like these, try out /r/learnprogramming!"
coding,3b65g6,guffins,1 point,Fri Jun 26 07:59:17 2015 UTC,I'm very new to coding.  I've been able to practice various methods of incorporating links via tutorials but I don't know how to get this menu to be horizontal across the top of a web page instead of being it's own vertical block aligned on the left.    edit  I much prefer something like This but I do not understand the nuances of how these differ.
coding,3b65g6,EggCess,2,Fri Jun 26 07:54:50 2015 UTC,"Remove the height and width from your menu, add float: left to your elements, like in the example you linked. The floats are the magic you're looking for.  Read up on how floating in CSS works, however. You can easily mess up the entire look of your page with wrong floating."
coding,3b1mbk,Vburyi,29,Thu Jun 25 06:09:58 2015 UTC,"Or using modern language features (the article is from 2013) :  IntStream.iterate( 0, i -> i+1 ).map( i -> i*i ).limit( 25 )   or varying a little bit from the original formula :  IntStream.range( 0, 25 ).map( i -> i*i )"
coding,3b1mbk,urquan,25,Thu Jun 25 12:42:55 2015 UTC,Bad programming in any language is dangerous...
coding,3b1mbk,Lobreeze,1 point,Thu Jun 25 16:02:29 2015 UTC,"Just went to put this exact comment here, thank you sir."
coding,3b1mbk,jac1013,5,Thu Jun 25 23:13:51 2015 UTC,Bad Programming: SquaringIterator.hasNext() is badly implemented and will cause next() to return unwanted values after 46340 numbers (~ Math.sqrt(Integer.MAX_VALUE)).
coding,3b1mbk,spupy,4,Thu Jun 25 13:10:44 2015 UTC,How did an irellevant article from 2013 end up on top of /r/coding?
coding,3b1mbk,Nilzor,2,Thu Jun 25 13:59:34 2015 UTC,"We don't need the ""in Java"" part of that headline."
coding,3b1mbk,ModernRonin,1 point,Thu Jun 25 15:27:56 2015 UTC,The article is about Java and is a response to an article about Java.
coding,3b1mbk,adrianmonk,2,Thu Jun 25 15:49:03 2015 UTC,So the guy he is talking about says JVM can't handle functional programming because he can't port his clojure code to java? Does he not know clojure runs on JVM? Am I misunderstanding?
coding,3b1mbk,schwiz,2,Thu Jun 25 18:00:50 2015 UTC,"Nah, the original author seems to be an idiot.    I can write shitty C-code and then blame the language for it, but if I did, it would tell people more about myself than the language."
coding,3b1mbk,SiS-Shadowman,1 point,Thu Jun 25 22:39:39 2015 UTC,Yes but its like writing shitty c code and saying the assembly language can't handle it. hehe. Yes he is an idiot :-)
coding,3b1mbk,schwiz,8,Thu Jun 25 23:40:34 2015 UTC,"Let's look at a language that is similar to Java - C#:   Enumerable.Range (1, 25).Select (a => a * a);   And the double example:   Enumerable.Range (1, 25).Select (a => 2 * a);   And the sqrt-example:   Enumerable.Range (1, 25).Select (a => Math.Sqrt(a));   It's evaluated lazy (no execution until you iterate over it), you get your iterator, and I didn't write 300 lines of code.   And if you don't know how much you need:   var b = Enumerable.Range (1, int.MaxValue).Select (a => Math.Sqrt(a));  //Output 25 Console.WriteLine(string.Join("","", b.Take(25))); //Output 50 Console.WriteLine(string.Join("","", b.Take(50)));   Maybe it's just that java just isn't really cutting edge anymore. That's cool for many project, but it has it shortcomings. I mean java people always say that C# is very similar, and has many java-like functions. Maybe that's true, but some things are simply missing.   TL;DR: Maybe it is the language, and not the user."
coding,3b1mbk,Fs0i,15,Thu Jun 25 09:32:41 2015 UTC,"Actually, look at the date of that article. It was written before Java 8. Modern Java supports these things (IntStream.range(...))."
coding,3b1mbk,ixampl,3,Thu Jun 25 10:49:15 2015 UTC,"LINQ was released as a major part of .NET Framework 3.5 on November 19, 2007   That is 6 years before the article was released. Maybe Java will get things like async / await in 10 years. And most systems are still on Java 7, some even on Java 6. (Which isn't really Oracles fault)  Edit: I meant to say lambda. These wer introduced in the same patch. See here - Sorry for the confusion"
coding,3b1mbk,Fs0i,4,Thu Jun 25 12:21:40 2015 UTC,"LINQ was released as a major part of .NET Framework 3.5 on November 19, 2007   Who was talking about LINQ? Not you, not the article.  I am not making any point in regard to Java being better or worse than C#. I was merely stating that your example is easily reproduced by Java now."
coding,3b1mbk,ixampl,2,Thu Jun 25 16:47:09 2015 UTC,"I meant lambda. Both was released with C# 3.0, that's why I mistook them. I'm sorry.   My point is that C# had this 6 years before the article was written. So 2 years ago my command would've been valid as well."
coding,3b1mbk,Fs0i,3,Thu Jun 25 16:50:33 2015 UTC,"Yes it, would. It's not a bad point. I just wasn't sure why you were choosing an example that is not really convincing anymore. So I assumed you (and others) might have missed the fact that OP's article is out of date."
coding,3b1mbk,ixampl,-5,Thu Jun 25 16:55:34 2015 UTC,LINQ isn't a great idea anyway. Streams in Java are better since they are more generalized. And Java has async via annotations used by various frameworks. Java doesn't just add keywords in order to break compatibility like C# does all the time.
coding,3b1mbk,sproket888,3,Thu Jun 25 13:15:36 2015 UTC,Adding a keyword doesn't break backwards compatibility you fucking moron.
coding,3b1mbk,SiS-Shadowman,-2,Thu Jun 25 15:04:56 2015 UTC,Shut up idiot. By definition it does you total cretin.
coding,3b1mbk,sproket888,1 point,Thu Jun 25 16:55:16 2015 UTC,Did you hear that? That's the sound of all those .NET 4.0 applications that broke down because of the introduction of the async keyword in .NET 4.5.     What do you mean there's no sound?    Oh wait...
coding,3b1mbk,SiS-Shadowman,-1,Thu Jun 25 17:10:55 2015 UTC,Call me when anyone is actually using .net anymore.
coding,3b1mbk,sproket888,1 point,Thu Jun 25 18:28:06 2015 UTC,"You're right, there's such little, nay, zero market share:   http://trends.builtwith.com/framework http://www.idc.com/prodserv/smartphone-os-market-share.jsp    But why do I even bother? You'll just continue to behave like an idiot."
coding,3b1mbk,SiS-Shadowman,-3,Thu Jun 25 18:46:59 2015 UTC,It must suck to know that Microsoft themselves don't even want to back .net anymore - favoring htm5 now and that linux running java has more OSes out there than windoze. Microsoft is resorting to giving away windoze 10 - we'll see how well that turns out.
coding,3b1mbk,sproket888,2,Thu Jun 25 19:17:28 2015 UTC,LINQ isn't a great idea anyway. Streams in Java are better since they are more generalized.   How much code have you written with both?   And Java has async via annotations used by various frameworks.   Surely you jest.   Java doesn't just add keywords in order to break compatibility like C# does all the time.   C#'s new keywords are all contextual; adding async/await didn't break any existing code.
coding,3b1mbk,Aethec,-9,Thu Jun 25 14:02:52 2015 UTC,How much code have you written with both?   More than you obviously. Streams is not all SQLish like LINQ.   Surely you jest.    Yup features can be added to frameworks instead of breaking the language every release.    There was no reason to add an unreserved keyword since the language has attributes except to break compatibility and get you monkeys to buy new copies of visual studio - but vote me down for truth anyway - little penis.
coding,3b1mbk,sproket888,3,Thu Jun 25 14:47:54 2015 UTC,"More than you obviously. Streams is not all SQLish like LINQ.   There are two ways to use LINQ. The first is the query way that is very SQLish, like you said. But you can also use the method chaining way as well. It looks identical to Java streams.   Yup features can be added to frameworks instead of breaking the language every release.    Please point to one example of a new feature added to C# that broke backward compatibility? Hell, they even have the horrible boxed collections from before generics were released in .NET 2.0. Both Java and C# releases have been great at preserving backwards compatibility but C# has been moving forward at a quicker pace."
coding,3b1mbk,jhartwell,5,Thu Jun 25 15:18:00 2015 UTC,"If you seriously think attributes can be used to add C#'s async features to Java (without code rewriting before compilation), you've never used async in C#. That, plus your belief that LINQ is only SQL-related stuff, and your comment about VS... I'll make an educated guess and say you've never used C# at all."
coding,3b1mbk,Aethec,1 point,Thu Jun 25 14:59:20 2015 UTC,"I'm sorry, I admit I have very little experience with async/await in C#, but the whole async mechanism basically forces asyncronicity (is that a real word?) into the whole call stack.   Once you turn a method async you can not call that method synchronously any more.   Granted, for coordinating async workflow, this is pretty nice and light syntax, but at what price?  This article is great at explaining what is wrong with that http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/"
coding,3b1mbk,Luolong,1 point,Sun Jun 28 07:51:05 2015 UTC,"That article is cute, but it's clearly written from a node/go point of view where the only thing that ever lasts long is IO. C# async stuff also has advantages that are hard to replicate in Go; Go's LockOSThread is ""notoriously difficult to use correctly"" but such behavior is required for most UI frameworks.  Also, have you ever written an Android app and a WinRT (i.e. Windows8 / Windows Phone 8.1) app? One of these is orders of magnitude easier to reason about - and async/await is a big part of that.  PS: yes, ""asynchronicity"" is a real word :)"
coding,3b1mbk,Aethec,1 point,Sun Jun 28 10:19:55 2015 UTC,"I generally agree that having clean async programming model is essential for delivering good performant and responsive GUI user experience.  I'm still not certain that making special flavor of functions that are only callable in async fashion is quite the right approach.   I admit, using async/await feels really nice and no-brainer. Right until you hit sync-async boundary where it becomes really ugly really fast."
coding,3b1mbk,Luolong,4,Sun Jun 28 14:05:13 2015 UTC,"Even without breaking retrocompatibility, most system in Java are stuck in Java 6 so..."
coding,3b1mbk,zoeshadow,-4,Thu Jun 25 13:48:42 2015 UTC,Nope. Most are in Java 7.
coding,3b1mbk,sproket888,-1,Thu Jun 25 14:02:09 2015 UTC,Fucktard
coding,3b1mbk,sproket888,-13,Thu Jun 25 19:56:29 2015 UTC,But vote me down for truth right idiot?
coding,3b1mbk,sproket888,0,Thu Jun 25 13:32:41 2015 UTC,?
coding,3b1mbk,Fs0i,1 point,Thu Jun 25 13:37:41 2015 UTC,"You're not taking the first 25 of the list of all integers, your just iterating over the range of 1 to 25..."
coding,3b1mbk,aaronsherman,2,Thu Jun 25 12:14:30 2015 UTC,"var b = Enumerable.Range (1, int.MaxValue).Select (a => Math.Sqrt(a)).Take(25);"
coding,3b1mbk,Fs0i,1 point,Thu Jun 25 13:38:28 2015 UTC,"While technically not all integers, I don't know if Clojure is capable of exceeding the range of some arbitrary implementation size of integer anyway, so you might be doing the same thing. Certainly in Python or Common Lisp the behavior would not be constrained by anything but memory size.  Still, yes, the key thing is that the source is an iterator."
coding,3b1mbk,aaronsherman,1 point,Thu Jun 25 13:58:27 2015 UTC,The source here is also an iterator. Nothing is evaulated until iterated.
coding,3b1mbk,Fs0i,1 point,Thu Jun 25 14:02:36 2015 UTC,I believe that's what I said...
coding,3b1mbk,aaronsherman,3,Thu Jun 25 14:04:01 2015 UTC,"Then I don't get what you're trying to say, sorry."
coding,3b1mbk,Fs0i,3,Thu Jun 25 14:06:58 2015 UTC,Shouldn't you use Stream from Java 8?
coding,3b1mbk,pwiecz,11,Thu Jun 25 10:05:28 2015 UTC,The article is more than two years old.  I'm not sure why it was posted here today.
coding,3b1mbk,chalk_huffer,3,Thu Jun 25 11:50:55 2015 UTC,Karma?  To be fair it may have just struck someone who came across it today as worthy of note.
coding,3b1mbk,aaronsherman,2,Thu Jun 25 12:13:36 2015 UTC,"As I've discovered, updating across a large organization can be really painful. We just recently moved to Java 7, and long-untouched code broke in several cases. We're gearing up for another upgrade, but in the meantime google's guava library is pretty helpful.  FluentIterable.from(ContiguousSet.create(Range.downTo(0, CLOSED), DiscreteDomain.integers())).transform(SQUARE).limit(25); // where SQUARE is a guava Function"
coding,3b1mbk,josuf107,-2,Thu Jun 25 13:32:39 2015 UTC,Bad Programming in Java Is Dangerous
coding,3b2q1p,alexcasalboni,2,Thu Jun 25 14:19:22 2015 UTC,"This is interesting. I have experienced the ""Pyramid-of-Doom"" situation before, and its a tough problem to solve. I believe that Iced Coffee Script uses a similar solution. I am curious if there is an implementation of these concepts in an existing JS framework."
coding,3axtg3,drguildo,2,Wed Jun 24 10:48:51 2015 UTC,Thanks for sharing this. Looks like there is a bunch of great stuff in there!
coding,3axtg3,skeletor_999,2,Wed Jun 24 18:56:02 2015 UTC,"Mr Quilez is one of the shining lights of the demoscene. If these bits and pieces interest you, try the /r/demoscene subreddit. The /r/twotriangles subreddit was inspired by a talk he gave (not very active)."
coding,3ay33r,br3and3n,1 point,Wed Jun 24 12:46:11 2015 UTC,"Battleship doesn't seem like a particularly good candidate for these types of games because you don't really have much feedback to react to.  Bots that will succeed will be ones that adapt to the meta. If you have bots constantly adapting to each other, the meta will never really stabilize to allow bots to really shine."
coding,3auwck,Dev_code,3,Tue Jun 23 18:26:10 2015 UTC,Log in to watch   Yeah... no
coding,3auwck,CuddleMyNeckbeard,4,Wed Jun 24 09:37:29 2015 UTC,"And then, if you do sign-up, Adobe flash needs to be installed"
coding,3atozo,alexcasalboni,3,Tue Jun 23 12:47:26 2015 UTC,I really wish Elixir had Haskell's type system. That would be just about perfect.
coding,3atozo,ephrion,1 point,Tue Jun 23 14:51:54 2015 UTC,"Tell me more about the type system ofElixir, please. I'm learning Haskell right how and I'm also a bit interested in Elixir... Because it looks like ruby but is a functional language (is it pure, actually?)!"
coding,3atozo,musicmatze,1 point,Wed Jun 24 11:35:07 2015 UTC,"I don't know Elixir well or Erlang at all. From what I know, Elixir's FP elements are immutable data structures, pattern matching on them, and separating behavior and code. It's not a pure language, almost by any way you define the term (not that purity is necessarily a good thing). I posted essentially the same comment in the blog post, and rad_g responded with the following:   This is actually a very interesting remark. There is a ""type system"", for lack of better term, in Erlang/Elixir but it is not the one known from other languages.  There are numbers, strings, binaries, tuples. There's no such thing as a class / trait (well, there's a behaviour but that's just a promise of having a function in the module) but: your tuples combined with atoms give you types. Consider this (Erlang, not Elixir, but the point stands):  Meh = { my_data, 1, <<""some binary data"">> }. Meh2 = { my_other_data, 2, <<""some other binary data"">> }`.   In both cases you can easily find anything what is like my_data by doing something like:  is_my_data( { my_data, _, _ } ) -> true;    is_my_data( _ ) -> false.  Same with my_other_data  is_my_other_data( { my_other_data, _, _ } ) -> true; is_my_other_data( _ ) -> false.   I find this much more flexible than any type system (haven't work with Haskell ;) ). Your data becomes a data type. But I do agree regarding the tool support. Would be good to have a tool that could help with finding patterns across a project while debugging."
coding,3atozo,ephrion,1 point,Wed Jun 24 12:51:17 2015 UTC,Awesome article! I've just read it yesterday I guess... And it is awesome!
coding,3aqjot,haris3301,6,Mon Jun 22 18:20:26 2015 UTC,I wonder if he were wrong if this would have become a blog post.
coding,3aqjot,xanados,1 point,Tue Jun 23 06:22:39 2015 UTC,"Why not? Seems to me that the question as such was just a pretext for the exercise, and everyone's the better off for it. I know I learned something.  ... come to think of it, it would have become a blog post and a high profile kernel bug report :)"
coding,3apk05,alexcasalboni,2,Mon Jun 22 13:37:31 2015 UTC,"That's an interesting approach to constructors, though it's less revolutionary than what is claimed; most of this can be emulated with private constructors and static factory methods.  The only ugly part is the closed enum declaration; the author bashes DRY violations at the beginning of the post, but declaring a closed enum is anything but DRY."
coding,3apk05,Aethec,1 point,Mon Jun 22 16:53:00 2015 UTC,"I didn't see it claiming to be revolutionary, it seemed to merely suggest that this was a more convenient syntax for achieving those things.    The idea of completely open enum types are a bit scary to me. I think union types actually solve this problem quite well..."
coding,3apk05,ickysticky,1 point,Tue Jun 23 02:24:10 2015 UTC,"The idea of completely open enum types are a bit scary to me.   Well, that's what a Java enum is."
coding,3apk05,gavinaking,1 point,Tue Jun 23 09:23:17 2015 UTC,"Constructors are by no means revolutionary feature of any OO language.  Ceylon tried to get by without multiple constructors but in the end, it had to get them. I like the end result - it's very nice, easy to parse and overall very ""Ceylonic"".   Closed enumeration pattern is a little repetitive, I agree, but this is because the list in the 'of' clause constrains the type to the list of the named values and/or types.   Those values still need to be defined though. New syntax is somewhat nicer and more compact than the old one."
coding,3apk05,Luolong,1 point,Tue Jun 23 08:48:05 2015 UTC,"Closed enumeration pattern is a little repetitive, I agree, but this is because the list in the 'of' clause constrains the type to the list of the named values and/or types.   Not just that, but also the declarations themselves; it's very verbose compared to Java enums, which let you do the same thing without having to type ""shared new ... extends ... {}"" every time."
coding,3apk05,Aethec,1 point,Tue Jun 23 11:07:16 2015 UTC,"Keep in mind that Java-style enums are used much less in Ceylon because you have another construct, sum types, which is used for some of the same problems that you might use an enum for in Java, but is actually more powerful/convenient a lot of the time.  So in Ceylon, enum declarations are an even tinier minuscule percentage of your codebase than they are in Java.  This is something I sometimes argue with Stef Epardaud about. Stef would like a streamlined (i.e. specialized) syntax for Java-style enums. To me that's just unnecessary complexity in the language because the actual reduction in code size for a typical Ceylon project would be just so incredibly teensy tiny. This is not a significant source of verbosity, so it's not a source of verbosity that I personally would choose to target.  But, y'know, if enough people bend our ears about this issue, I could be persuaded to do something about it. Right now I don't see it as a pain point. There are other things I would prefer to spend our complexity budget on."
coding,3apk05,gavinaking,1 point,Tue Jun 23 11:28:58 2015 UTC,"Not just that, but also the declarations themselves; it's very verbose compared to Java enums, which let you do the same thing without having to type ""shared new ... extends ... {}"" every time.   It is not Java, just deal with it. :)  Also, just as soon as you want more flexibility, Java's syntax gets just as ugly if not more so.   Ceylon syntax, although slightly more verbose, is much more regular than Java in this respect"
coding,3apk05,Luolong,1 point,Tue Jun 23 15:23:57 2015 UTC,"most of this can be emulated with private constructors and static factory methods   In what language? In Java? I don't see how it can be. The point of this is that the Ceylon compiler guarantees at compile time that every field is initialized exactly once (unless it's explicitly marked variable). The Java compiler doesn't guarantee that, so you can get strange things like:   uninitialized fields with null assigned implicitly, reading the value of a field—even a final—field before it has been assigned.   Figuring out how to constrain constructors in such a way that these weird things can't happen, but without losing too much expressiveness of what constructors can do in Java was actually really a bit tricky (though surely not ""revolutionary""). And I don't know of any other language which has what has been presented here."
coding,3apk05,gavinaking,1 point,Tue Jun 23 09:31:35 2015 UTC,"Yes, that's the main feature that can't be done in languages like Java or C#. But named constructors, constructor ""inheritance"" via extends, and so on, can be emulated with a little bit of boilerplate."
coding,3apk05,Aethec,1 point,Tue Jun 23 11:05:08 2015 UTC,"But named constructors, constructor ""inheritance"" via extends, and so on, can be emulated with a little bit of boilerplate.   Do not get carried away with the syntax and naming conventions. This is just a tiny surface area of what constructors are about. Sure, you can emulate the same naming convention with factory methods in Java, but that is not the same thing.."
coding,3altqs,alexcasalboni,7,Sun Jun 21 14:09:32 2015 UTC,"One caveat with this tutorial: don't use GLEW as it suggests. It hasn't been kept up to date (lacking core profile support), much too big (slower build times, larger binary), and isn't worth using anymore. Use gl3w or glLoadGen instead, which works nearly the same way."
coding,3altqs,skeeto,7,Sun Jun 21 15:09:23 2015 UTC,"In my opinion, GLFW is an even better choice."
coding,3altqs,Leandros99,2,Sun Jun 21 22:19:16 2015 UTC,"I think you are missing a ""not"" somewhere in that sentence :)  EDIT: He has added it now :)"
coding,3altqs,ponchedeburro,2,Sun Jun 21 16:02:54 2015 UTC,"Oops, you're right, thanks!"
coding,3ambjb,pgen,13,Sun Jun 21 17:03:43 2015 UTC,"There is just that one thing I think every time such a topic comes up: Why not just use a language that has exactly those features, natively, without performance implications? Like, C++?"
coding,3ambjb,wung,8,Sun Jun 21 17:16:00 2015 UTC,"Prefixing everything with library_name_ works fine. It doesn't have have a performance cost and you save one character compared to the C++-style :: operator anyway. You don't have the advantage of having using, but many coding conventions discourage/forbid that anyway. I don't know why anyone would use the virtual function technique in this post...  There are lots of compelling reasons to use C++, but I don't think namespaces are one of them."
coding,3ambjb,strncat,6,Sun Jun 21 17:39:38 2015 UTC,"Namespaces offer a lot more than just prefixes and using. Some other things it offers: namespace aliases, DRY in the namespace itself, ease of refactoring."
coding,3ambjb,detrinoh,5,Sun Jun 21 19:35:45 2015 UTC,"There are places where you really have no choice BUT to use C, e.g., things that run in kernel mode on most major operating systems. Linux has no support for using C++ in the kernel, Windows has some limited support for C++, but most of the features it provides are dangerous to use there (though I'd imagine you could probably get away with namespaces). Situations where size and platform compatibility are an issue (such as with embedded devices) would probably make C more attractive also, as it is more likely that you could make sure you wouldn't have to pack along extra stuff (either statically or dynamically) to make sure your program runs. There are probably other reasons too, but those two come to mind immediately..."
coding,3ambjb,ucalegon7,2,Mon Jun 22 02:37:18 2015 UTC,C++ comes with a lot of extra stuff that you may not want.  You also opt out from an ecosystem of C tools (which tend to be a superset of C++ tools).  It's likely going to also increase compile times.
coding,3ambjb,Peaker,2,Sun Jun 21 21:56:41 2015 UTC,"For points 1 and 3, why not use C++ in a very C-like fashion? The extra stuff doesn't impact you in any way if you don't use it, and I doubt compiling C as C++ increases compile times that much (as far as I'm aware, the main problem with compilation is header files which both C + C++ suffer from)  For point 2, I've no idea. I've never personally encountered a situation in which C has a tool that is unavailable for C++, but you're probably right about this"
coding,3ambjb,James20k,2,Mon Jun 22 01:20:39 2015 UTC,"If you make tools available, people WILL try to use them. So then you're spending even more time and energy trying to herd the cats. But you can't control everything and eventually somebody will decide that using a forbidden feature lets them ""get it done"" faster (consequences be damned), so they'll sneak it in. And then others will see that and think it's OK and do it without asking...  Unless you have an ironclad set of coding conventions and a team dedicated to them, it's far, far easier to just not provide the forbidden tools and live with the shortcomings. Though, in this specific case, from having coded with prefixes instead of namespaces, the lack of namespaces really isn't that big of a deal."
coding,3ambjb,LordArgon,2,Mon Jun 22 05:44:26 2015 UTC,"But you can't control everything and eventually somebody will decide that using a forbidden feature lets them ""get it done"" faster (consequences be damned)   This is the exact problem with C though, it has a great number of dark corners that must be rigorously avoided in order to write good C code.   Saying 'you should not perform type punning with aliased pointers' is something that you should certainly avoid due to UB, but its one of those things where you might think fuck it im a lazy bum and i'll do it to save some time.   There's a whole host of problems in C like this, from shifting negative integers, to signed integer overflow and 2s complement assumption etc etc - C being one of the worst offenders in this category of any language, far worse than C++ because it does not give you the tools to deal with many of its fundamental flaws  This is the exact same situation you describe as C++, and in fact every language ever, as its a organisational/structural problem rather than a problem with your language. If people are submitting crappy code that violates your guidelines and nothing is done about it, then that its not the languages fault   Though, in this specific case, from having coded with prefixes instead of namespaces, the lack of namespaces really isn't that big of a deal.   I agree with you here, though namespaces do provide very useful features on a library front"
coding,3ambjb,James20k,3,Mon Jun 22 06:05:55 2015 UTC,"C has solutions/workarounds to all these issues (which we don't encounter much btw, using c for a very large project at work).  C++ has all these gotchas and then much much more."
coding,3ambjb,Peaker,1 point,Mon Jun 22 07:38:02 2015 UTC,"I think you misunderstood my post as implying C was better than C++. It was intended to be a more-general statement about the consequences of exposing otherwise-unwanted features. If you happen to hate C++ templates or think OOP is terrible, the best way to ensure you avoid them is to completely exclude them from your dev process.  And if you, at the same time, love namespaces, then you need to evaluate whether the pros of having namespaces outweigh the cons of exposing those other features. It may take effort to work around the lack of namespaces in C, but it will ALSO take effort to enforce that nobody uses your particular ""unwanted"" features in C++.  Sometimes people don't realize that ensuring something DOESN'T happen can be as much (or more) work as ensuring something else DOES happen."
coding,3ambjb,LordArgon,1 point,Mon Jun 22 09:56:33 2015 UTC,Fun fact - sqllite3 is distributed in one C file that is over 5 MB and it compiles in under 2 seconds.
coding,3ambjb,__Cyber_Dildonics__,1 point,Tue Jun 23 00:58:27 2015 UTC,"I have written libraries in C++, but its interface had to be exposed via vanilla C. Having a good sense for mapping C++ namespaces into C-like equivalent is quite useful. I typically do this:  C++:  int Namespace::ClassName::FunctionName(int Arg1, int Arg2);   C:  int Namespace_ClassName_FunctionName(ClassType* obj, int Arg1, int Arg2);   The above example may seem a little verbose, but it's not that bad if you name things intelligently."
coding,3ambjb,AntiProtonBoy,1 point,Tue Jun 23 04:04:18 2015 UTC,"It becomes less fortunate when you find you have ClassType in another namespace. So the C equivalent becomes Namespace_ClassType, and makes so many damn lines longer.  Always makes me tempted to make some sort of NS(...) macro that is defined and undefined at the top/bottom of each file, or something."
coding,3ambjb,Pronouns,1 point,Wed Jun 24 16:01:44 2015 UTC,"Generally I start off with writing a facade or a decorator for the API C header and progress into the private implementation details from thereon. Generally you don't want to expose C++ classes as raw pointers anyway. You'd wrap them in C structs using the PIMPL idiom. Better still, use an integer ID value instead of a struct pointer, which indexes a managed C++ object in a resource pool (like a hash map)."
coding,3akmn1,Alphapixels,40,Sun Jun 21 03:12:48 2015 UTC,"This has to be the storage method for some click/drag ""enable your business users to build business logic"" system. Right? No one could want to actually build things this way."
coding,3akmn1,GuruMeditation,18,Sun Jun 21 04:53:02 2015 UTC,"Sounds amazing as a human-readable, portable way for compilers to store syntax trees for later retrieval or for debugging.  Sounds horrible for any other use."
coding,3akmn1,nkorslund,23,Sun Jun 21 08:09:08 2015 UTC,"Sounds amazing as a human-readable, portable way for compilers to store syntax trees for later retrieval or for debugging.   I think you just discovered syntax trees."
coding,3akmn1,FunctionPlastic,2,Sun Jun 21 12:45:35 2015 UTC,... syntax trees with a horrible syntax.
coding,3akmn1,longoverdue,24,Tue Jun 23 02:24:01 2015 UTC,I really don't get how twisting JSON into this XSLT-shaped mess would make development any faster or easier.
coding,3akmn1,cokestar,33,Sun Jun 21 05:10:49 2015 UTC,"Jokes on you, there's nothing to get, it's turtles all the way down!"
coding,3akmn1,mmazing,-8,Sun Jun 21 06:01:00 2015 UTC,We said the same thing about javascript and CSS...
coding,3akmn1,keepthepace,15,Sun Jun 21 15:06:57 2015 UTC,No we didn't. They both have clear advantages over the previous methods of <not having a dynamic website> and embedding font tags and colors all over.
coding,3akmn1,movzx,51,Sun Jun 21 17:12:33 2015 UTC,People have thought of something like this a long time ago. It's called lisp.
coding,3akmn1,auxiliary-character,7,Sun Jun 21 06:30:36 2015 UTC,My first thought was lisp as well. This blogpost explains how lisp is a concise serialisation of a syntax tree and you could do the same with xml (or in this case json).
coding,3akmn1,EsperSpirit,6,Sun Jun 21 09:42:22 2015 UTC,"People have done the same with XML too, see Apache Jelly."
coding,3akmn1,nullabillity,5,Sun Jun 21 14:34:49 2015 UTC,Doesn't mean it's at all a good idea.
coding,3akmn1,greyfade,23,Sun Jun 21 15:41:24 2015 UTC,Greenspun's tenth rule.
coding,3akmn1,romcgb,1 point,Sun Jun 21 08:26:09 2015 UTC,And now I've seen everything.
coding,3akmn1,shamankous,4,Sun Jun 21 15:01:59 2015 UTC,"Well, I'm certainly a confused computer scientist after reading that nonsense."
coding,3akmn1,dmwit,1 point,Sun Jun 21 18:28:51 2015 UTC,"I ran across this a while back, and while the initial argument is very long it actually spans across multiple wiki pages. Have you clicked any of the links? All I could think was ""What the hell is this? Who are these people?"". It's like a hole in the internet where these people got stuck and have been arguing ever since."
coding,3akmn1,cjwelborn,6,Thu Jun 25 02:19:26 2015 UTC,"Yeeeep. Once you had to explain lisp with xml, now we can use this."
coding,3akmn1,the_noodle,2,Sun Jun 21 07:08:03 2015 UTC,"Or, you know, JavaScript."
coding,3akmn1,tootie,7,Sun Jun 21 18:57:13 2015 UTC,"Except you can't read JavaScript with a json reader. You can read this with anything that can read json, but you can also read lisp with anything that can parse S-expressions (except for maybe reader macros...)."
coding,3akmn1,auxiliary-character,15,Sun Jun 21 19:04:21 2015 UTC,article link to the lazy - https://medium.com/relevant-stories/rel-chapter-1-907ff616bf80
coding,3akmn1,avinassh,13,Sun Jun 21 08:23:24 2015 UTC,Isn't that article just an extended joke ... or have I fallen victim to Poe's law?
coding,3akmn1,Araneidae,4,Sun Jun 21 08:54:54 2015 UTC,"It's serious. The best way to gauge whether or not something is serious or a joke is by how much effort they've gone to to make it believable.  Seriously, by going to that much effort to document what they've done, they've done it, whether they intended to or not."
coding,3akmn1,anonymous7,1 point,Sun Jun 21 13:18:03 2015 UTC,I sincerely hope it's a joke.
coding,3akmn1,FallingIdiot,2,Sun Jun 21 11:04:22 2015 UTC,article link to the crazy   FTFY
coding,3akmn1,StorsJT,1 point,Sun Jun 21 18:14:07 2015 UTC,"The best part: they're doing this in an iOS app, and so are most likely violating  rule 3.3.2 of the iOS developer guidelines."
coding,3akmn1,xenomachina,1 point,Sun Jun 21 20:21:30 2015 UTC,"That's pretty old, currently only executable code is disallowed."
coding,3akmn1,ehaliewicz,1 point,Mon Jun 22 23:23:01 2015 UTC,"How does Apple define ""executable code""? Based on the original article, I'd say REL is encoding executable code in JSON.  The current App Store Review Guidelines say:    2.7  Apps that download code in any way or form will be rejected 2.8  Apps that install or launch other executable code will be rejected    ...and the ""in any way or form"" wording seems to be pretty explicit that using odd encodings (like REL) is still forbidden."
coding,3akmn1,xenomachina,12,Tue Jun 23 00:40:07 2015 UTC,Looks like they really wanted a DSL for their cards system but went lazy and skipped writing a parser so you have to write the syntax tree by hand instead. It's not really that big of a WTF imho.
coding,3akmn1,urquan,56,Sun Jun 21 11:52:46 2015 UTC,Holy shit. Javascript engineers have officially gone full retard.
coding,3akmn1,rlee0001,22,Sun Jun 21 04:27:39 2015 UTC,Nahhh it's just the one that went rogue. The other commenters are working to reel him back in
coding,3akmn1,jtredact,35,Sun Jun 21 04:48:17 2015 UTC,"I'm betting that by Monday they'll have at least two competing frameworks built on top of it, and at least one of those will incorporate a cross compiler that compiles ECMAScript 2015 into this shithole of a language."
coding,3akmn1,rlee0001,3,Sun Jun 21 06:40:27 2015 UTC,Are you drunk right now?
coding,3akmn1,parmsib,-1,Sun Jun 21 10:59:47 2015 UTC,JavaScript is so bad. But it's everywhere so we might as well keep it the way it is.   *scoff*
coding,3akmn1,just_comments,5,Sun Jun 21 12:39:25 2015 UTC,"So what's really happened here, and why it's not as shitty, is we've just change the language into the lexer output (roughly), so you're skipping the middle man.  Granted, no one would actually want to program like that in javascript/JSON."
coding,3akmn1,iambeard,11,Mon Jun 22 02:46:00 2015 UTC,OK guys let's all freak out because some one made a syntax tree...
coding,3akmn1,SergeiGolos,0,Sun Jun 21 14:49:19 2015 UTC,well it's a bad syntax tree
coding,3akmn1,user0x29a,10,Sun Jun 21 07:09:16 2015 UTC,"Apps like IFTTT, Zapier and Relevant, all generate recipes that look something like this.  Relevant makes their syntax public and Reddit goes Ape-poop."
coding,3akmn1,wircho,3,Sun Jun 21 21:10:30 2015 UTC,arrays for lists of html elements   dear god
coding,3akmn1,the_dinks,1 point,Sun Jun 21 14:54:27 2015 UTC,"I did a similar thing for validating json data.  It's not a full-blown language though, more of a dsl for describing a json schema.  And the shape of the language matches the shape of the data you want to validate, so it works out pretty well.  This is just a custom language that they didn't write a lexer or parser for.  Not really that big of a deal. It'll be a pain to write by hand though."
coding,3al54t,haris3301,3,Sun Jun 21 07:12:31 2015 UTC,I see everyone saying that C has an ABI then there are posts like this where people say the opposite.  Which is it?
coding,3al54t,Matthew94,5,Sun Jun 21 11:58:55 2015 UTC,"Probably #2.  It's just that C has the ""advantage"" of having no namespaces, function overloading and other things that cause name collision in things that can be included in other files.  So those included things need no name mangling which every compiler does another way. Also there are no exceptions, which seem to come in all forms and functions. No templates, whatever way they are processed.?  So to me it looks like it comes down to following the calling convention your ISA offers and your OS/platform uses and you're set."
coding,3al54t,interpreter_dude,2,Sun Jun 21 12:32:18 2015 UTC,"Platforms usually define a C++ ABI in addition to a C ABI. Compilers stick to the Itanium ABI for things like exceptions, RTTI and virtual functions on non-Windows and follow Visual Studio's ABI on Windows. C++ features like private fields and templates encourage writing libraries that don't offer a stable ABI between versions but that's a separate issue from the calling conventions and mangling.  Windows doesn't provide ABI stability for the C++ standard library but libstdc++ rarely breaks compatibility (a notable case is the recent dual ABI for full C++11 support while still providing the old ABI). There's no compatibility between different C++ standard libraries, but that's to be expected. The standard C library ABI varies between implementations too, and some don't provide ABI stability.   So those included things need no name mangling which every compiler does another way   C does have name mangling. That's how stuff like static variables and functions work. It's not part of the external platform ABI on most platforms though. It is part of it on OS X."
coding,3al54t,strncat,2,Sun Jun 21 17:26:25 2015 UTC,"Platforms provide a standard C ABI. In some cases there are cross-platform calling conventions (like the System V x86_64 calling convention, used on *BSD, Linux and OS X) but it's not useful beyond making compiler development easier since it's not nearly enough for binaries to be portable."
coding,3ailq6,skeeto,11,Sat Jun 20 15:22:36 2015 UTC,"It's a good comparison, but I think some of the green/yellow/red color for some metrics isn't explained, and it seems skewed in musl's favor.  E.g., the very first row shows that musl's (and uClibc's) .a and .so libraries are roughly 3x as large as dietlibc's, yet they're still marked green.  Or if you look at ""thread creation/joining"", musl takes 2x as long as uClibc or glibc and is also still green.  But if you look at the ""self-exec (dynamic linked)"" row, where musl is the fastest, then uClibc and dietlibc are yellow for being 1.25x to 1.5x slower."
coding,3ailq6,mdempsky,1 point,Sat Jun 20 22:54:03 2015 UTC,Iconv character conversions ...  glibc == the kitchen sink   wat?
coding,3ahzec,alexcasalboni,29,Sat Jun 20 10:32:07 2015 UTC,"If you are looking for a more lightweight solution, just adding ?w=1 to the URL should work."
coding,3ahzec,gasche,3,Sat Jun 20 12:44:53 2015 UTC,Not that making your own solution is a bad thing. Good job!
coding,3ahzec,b0unce,2,Sat Jun 20 15:58:30 2015 UTC,Also works the same for bitbucket.
coding,3ahzec,linusl,2,Sat Jun 20 12:58:53 2015 UTC,I tried it on Bitbucket but it didn't work for me. :/
coding,3ahzec,ThraShErDDoS,2,Sat Jun 20 18:05:20 2015 UTC,"It works for me on bitbucket when looking at diffs. I think it will still show new/removed blank lines, but other whitespace changes should be hidden. Of course, if there is already a query string in the url you need to add &w=1 instead, and if there is a hash at the end, you need to add it before the hash. Not sure if there are bitbucket diff pages where it won't work at all, but I usually use it on pull request diff pages."
coding,3ahzec,linusl,2,Sat Jun 20 18:39:17 2015 UTC,I was seeing the new/removed blank lines and assumed it wasn't working. Looks like it was working all along. Nice trick!
coding,3ahzec,ThraShErDDoS,1 point,Sat Jun 20 19:16:10 2015 UTC,So we can do this the easy way... or the ...fun way
coding,3af2il,ExcaliburZero,29,Fri Jun 19 16:37:44 2015 UTC,"Java is the only language taught at the high school I attend, therefore it was the first language I learned.  The amount of times I heard ""Don't worry about that yet"" or ""Just type it"" is crazy high. I guess that's what inspired me to learn how to program on my own.    As someone who now primarily codes in Java (android) I 100% agree with the article.  A teacher shouldn't tell a curious student to just not worry about things like parameters, and the main method. Instead they should focus on just learning the language and being able to teach everything they need to know."
coding,3af2il,DadFoundMyAccount,5,Fri Jun 19 17:05:41 2015 UTC,I know the feeling. I first started learning programming through an online class from my local community college and it was on Java. I managed to do decently grade-wise but it was not a very fun experience. Java just didn’t turn out to work well at all as a first programming language for me.  Several months later I started learning Python through CodeAcademy and I had a lot of fun with it. It was a much less stressful experience.
coding,3af2il,koalillo,12,Fri Jun 19 18:51:13 2015 UTC,"If I got a $ for each ""Java's hello world is hard"" and paid for each article that discussed Java's true problems for teaching... I'd be very rich.   Just use BlueJ/Processing for teaching. Both make disappear 90% of the gripes of the common Java sucks for teaching articles.   Now, Java's everything's an object and all functions are methods suck. Verbose lists and dicts suck.  On the other hand, I'm going to say that dynamicly typed languages suck for teaching. I see the kind of errors that beginners make that static languages catch at compile-time and that would baffle novices as runtime errors.   But what sucks most is crappy learning materials, really. That's much more important than language choice."
coding,3af2il,coryknapp,3,Fri Jun 19 19:48:44 2015 UTC,dynamicly typed languages suck for teaching   Totally agree.
coding,3af2il,not-just-yeti,2,Sat Jun 20 04:29:26 2015 UTC,"I've taught Java using BlueJ -- it definitely helps (I wouldn't teach Java w/o it), but the language itself still is laden w/ gotchas."
coding,3af2il,Meshiest,5,Sat Jun 20 03:08:15 2015 UTC,Such a shame that the majority of the people that read this article will be programmers who already know the basics
coding,3af2il,BlackDeath3,2,Fri Jun 19 20:56:59 2015 UTC,"Hopefully, some of them are teachers teaching the basics!"
coding,3af2il,Meshiest,1 point,Sat Jun 20 01:48:48 2015 UTC,I hope!
coding,3af2il,EricTboneJackson,16,Sat Jun 20 01:54:09 2015 UTC,"I agree that it's important for a first language to capture your imagination and give you ""the bug"", but the idea that this requires a high level language with huge levels of abstractions is nonsense, IMO. I was just as hooked doing stupid shit like reversing a string in C. I didn't know that if I was using ""high level language X"" I could have had a functioning GUI in the same number of lines. I was drunk with power in my tiny, low level domain.   confusing the user by making them copy and paste several important lines of code that they do not understand   This is an illusion. If you start them in say, Python or Lua, removing all the boilerplate so they can just type ""print('Hello, World')"", they're still typing code they don't understand.   How does ""print"" work? What is a ""string"", really? What is a function? It's all magic. You're ""programming a computer"" at such a high level that you may as well be ""programming"" a VCR (hyperbole, I know). You have absolutely no mental model of how the machine works.  What you gain from using such a high level language is that you can make the machine do more with fewer instructions. But you understand those instructions less. That's not necessarily an advantage.  I spent months writing programs that did absolutely trivial things (e.g. counting the number spaces in a string), but it was no less fun or engaging. Because it was a low level language, I necessarily acquired a mental model of the machine (stack, heap, memory addresses, types as interpretations of bits, etc.) that underlies all programming languages.  When I moved to C++, I understood what underlied the abstractions I was using like std::string. I could imagine implementing such a thing myself (and in fact I did, as many new C++ programmers do).  When moving to dynamic languages, I understood what underlied their abstractions as well. Leaky abstractions didn't confuse me."
coding,3af2il,EricTboneJackson,7,Fri Jun 19 18:27:55 2015 UTC,"I understand where you're coming from. It is important to learn how to do some lower level programming in order to get a better understanding of how the computer works in order to become better at programming.  However I personally wouldn't recommend starting out with a low level language as a first language. While some people are able to successfully start with low level languages and gain good experience from it, not everyone is able to do so. Many people can get confused having understand how the machine handles things before they can do all that much.  Higher level languages do tend to oversimplify things sometimes, but I see such simplification as being good for a first programming language. It helps to make it easier for one to start learning to program so they can eventually go on to learn how the machine works when they are ready to do so.  Some people can definitely start out learning a lower level programming language and come out better for it, but it's not something most people can do well.  Personally I recommend to start off with a simpler high level language to develop an interest in coding, and then move on to a more lower level language in order to learn more of the specifics and underlying concepts.  I see starting out with a higher level programming language as like starting to learn to ride a bike with training wheels. It makes it a bit easier to get the hang of it, so that once you get the hang of it you can remove the training wheels in order to learn to understand the whole process more fully. Thus by starting out with a higher level language and switching to a lower level language you can learn the basic concepts of programming to a degree and then once you have a handle on them, move on to learning them to a higher degree."
coding,3af2il,APersoner,5,Fri Jun 19 19:21:58 2015 UTC,"it's not something most people can do well   Do you have any source to support that? The first 10 years of my career was working with people that did that just fine.   I see starting out with a higher level programming language as like starting to learn to ride a bike with training wheels.    I think ""training wheels"" is a poor analogy for high level languages. These aren't beginner languages that people outgrow, they're powerful languages used in production by professional programmers.   Lower level programming is like learning to be a chef: learning to use kitchenware, to buy, prepare, cook and present food, to maintain a clean kitchen, etc. A higher level programming language is more like being a head chef, directing staff in a kitchen.  You can start out running a kitchen without knowing how food preparation is really done, but you're 100% dependent on the talent of your staff. This is kinda like the guy who spends his days finding and gluing together third-party libraries with snippets he finds on Stackoverflow, but gets lost when that well runs dry."
coding,3af2il,Shaper_pmp,1 point,Fri Jun 19 23:03:23 2015 UTC,"The first language taught in the university I attend is C, followed by Haskell (then Java and JavaScript). There is a significant number of people in the cohort who had never programmed, or just used VB before uni. Everyone managed fine with C within the first week or two."
coding,3af2il,APersoner,7,Sat Jun 20 03:24:19 2015 UTC,"I was just as hooked doing stupid shit like reversing a string in C.   You're confusing ""good"" with ""good enough"".  Some people learned to program with assembly. That does not mean assembly is a good first programming language.  My first language was C, but I wouldn't dream of confusing a user with #include <stdio.h> or int main(int argc, char *argv[]) when I could start them gently with something as simple and easily-graspable as puts ""Hello world!"" and develop from there.  As the article says it's not about high-level so much as it's about simplicity - minimal characters and concepts required to achieve a simple goal. If you want to put a string to the screen, you should need to explain exactly two concepts - ""string"" and ""puts"". If you have to start by explaining (or telling students to memorise but ignore) half an textbook on OOP, class and method definitions, parameters, return values and scope them you have a really shitty teaching language.  Of course the user doesn't understand the code the first time he writes it, but you can quickly explain the important concepts (at a basic, lies-to-children level) as soon as he's typed it out. To explain the boilerplate for a Java CLI application you're looking at literally hours of time, and tens of different interlocking concepts (classes, functions, methods, variables, parameters, packages, etc etc, etc).  That's the difference - scripting allows them to bite off a small piece at a time, chew it to the extent necessary to move forward and then bite off more. Going straight into a boilerplatey language is like trying to take a drink from a fire hose, or force-feed them a whole cow in the first mouthful.  It's also worth noting that not once in the whole article did the author talk about high-level or low-level languages - you brought that distinction into the discussion.  He just spoke about high-cognitive-overhead versus low-cognitive-overhead languages. Those do tend to roughly correlate with heavyweight languages and scripting languages respectively (for reasons that should be abundantly obvious, pretty much by definition), but there's nothing inherent to dynamic or scripting languages about what he's saying - merely languages with simpler syntax and less mandatory boilerplate."
coding,3af2il,EricTboneJackson,3,Sat Jun 20 01:32:28 2015 UTC,"Some people learned to program with assembly. That does not mean assembly is a good first programming language.   I've been trying to tell my cousin that, for some reason he thinks assembly should be taught to every child in the country in primary school..."
coding,3af2il,Eliminioa,1 point,Sat Jun 20 03:26:16 2015 UTC,"You're confusing ""good"" with ""good enough"".   Absolutely not. I was exposed to Basic as a kid. Did nothing for me. It wasn't until I found K&R in my father-in-law's bookshelf that I got hooked. I've always been a bottom-up learner.  Not everybody is the same. For some people, it's entirely possible that a top down approach is ideal. But I know plenty of people who prefer to come at things the other way.   My first language was C, but I wouldn't dream of confusing a user with #include <stdio.h>   If include files (file insertion) confuse anyone, they're wasting their time anyway.   scripting allows them to bite off a small piece at a time   That presumes that you can eventually bite your way down to memory addresses, stack frames, heap allocations, etc., but in the languages you're talking about, you can't.   high-level or low-level languages - you brought that distinction into the discussion   Because level of abstraction is the relevant distinction. Languages where you can start with put ""foo""` are all high level languages.   He just spoke about high-cognitive-overhead versus low-cognitive-overhead languages.   Many of the high level languages have much higher cognitive overhead than C. C is memory addresses and bit patterns. You can spent months learning to manipulate strings. You don't have classes, interfaces, inheritance, access modifiers, type inference, templates, closures, continuations, list comprehensions, metaprogramming, vast standard libraries, so on and so forth. Ruby alone has 4 different function types, all with difference syntax and semantics. C is comparatively minimal. It just happens to be low level.  Most of the developers I know are fellow game programmers. Perhaps those kids who glue libraries together to ferry database columns to a web page have a different experience learning to code, but many of the people I know dove to the bottom immediately because they had an insatiable desire to know exactly what the fuck is going on. And yes, many of them know assembler, too.  The point is not that this is the only approach, but that it is the ideal approach for some people. The notion that operating at a high level of abstraction is universally the Best™ approach for everyone is just nonsense. Most people? Possibly. I don't know of any data to support either position."
coding,3af2il,EricTboneJackson,5,Sat Jun 20 04:53:32 2015 UTC,"If include files (file insertion) confuse anyone, they're wasting their time anyway.   That's rather presumptuous of you, especially since you're coming at it from an already experienced view. If you try and tell a novice programmer (someone maybe like yourself) that, ""Oh, sure you can print strings, but wait, first you need this other, mysterious package,"" then of course a curious student asks why. Explaining why (as a good teacher ought to), then gets into all the things that make up stdio.h, and headers, and streams, and that can be (and is) a whole class of its own. When you're first interesting novice coders, you should be able to explain most questions in a class.    That presumes that you can eventually bite your way down to memory addresses, stack frames, heap allocations, etc., but in the languages you're talking about, you can't.    That much is certainly true. But as a first language, the goal isn't really understanding exactly how the computer handles each aspect of code, it's learning to think of problem-solving in terms of programming. Your first language ought not be a complex look at how computers handle information, but how you can utilize their ability to handle information in a systematic and logical way.   Then, once the student can, for lack of a better term, ""think like a programmer,"" You can really dig into the more complex machinery. Learning a fairly simple, low-cognitive-overhead first language allows you to much more easily learn a complex language that reveals the true power of programming.    Many of the high level languages have much higher cognitive overhead than C. C is memory addresses and bit patterns. You can spent months learning to manipulate strings   I would say that if you have to spend months learning to manipulate strings, that qualifies as high overhead. When you immediately dump on a new programmer the burden of learning how strings work on a bit level, and what memory addresses are and why they're delicate yet powerful, it seems unconquerable.   Yet, at the end of the day, there's no denying that self-determination is the best way to find the right initial programming language. If you're the type of person (as most self-taught programmers are, myself included) who wants to get to the bottom of how stuff works, C is an excellent language to use. There's no argument that an driven individual ought to start high. The issue (at least as it seems to me), is what language teachers ought to teach in classrooms. Students entering coding through a classroom are oftentimes not as driven as those delving into it alone, and more often are simply there to get a degree and a job. For these people, it's far more effective to engage  them at an easy to understand conceptual level, then slowly introduce them into boilerplate mechanics."
coding,3af2il,j201,2,Sat Jun 20 05:33:31 2015 UTC,"""Oh, sure you can print strings, but wait, first you need this other, mysterious package,"" then of course a curious student asks why.   I was talking about file insertion, not the contents of the file, which are as opaque and irrelevant to the green student as how the Python interpreter works.  The statement #include <stdio.h> is as simple as they come. It literally causes the file <stdio.h> to be copied verbatim into the current file. Why do we need to include that file? It lets us use the function puts, printf, etc. Why? Let's call that magic for now. The same as how puts ""Foo"" makes words appear on screen in Perl. Magic. However, that magic is going to go away a lot sooner in C than it is in Python, where it remains magic forever for many programmers.  Plenty of programmers are happy working in frameworks where everything is magic (see: Rails). Other programmers have a lower tolerance for magic.   the goal isn't [X]   Speaking for yourself, of course.   I would say that if you have to spend months learning to manipulate strings, that qualifies as high overhead.   Subtle strawman.   When you immediately dump on a new programmer the burden of learning how strings work on a bit level, and what memory addresses are and why they're delicate yet powerful, it seems unconquerable.   You keep saying this, and I keep telling --- from direct experience -- that it's not true. It doesn't seem unconquerable, it's exciting and interesting, and no more work than trying to understand all the crap any modern high level language throws at you. It's simply at a different level of abstration.  The concept of bits and bit operators is simpler, more orthoganal, and more approachable than say, classes or functions. You have this heavy, apparently unconscious bias, towards higher level language features, because they're the heavy lifters in the long run.  My point about spending months with strings is not that you must but that you can. You can spend a lot of time down there, having a blast, learning how to problem solve with code, doing nothing but manipulating strings and/or streams of characters, while gaining a much deeper appreciation for how the machine actually works.  And this can actually be useful (see: Unix)."
coding,3af2il,JavaSuck,2,Sat Jun 20 06:10:25 2015 UTC,"The reason why C works, though, is because it's simple. Compared to something like C++, you have far fewer concepts to learn to understand the language and its mental model. And compared to a language like Java, its libraries tend to be simpler to use, even if they're less memory-safe or abstract.  Something like Scheme also provides a simple mental model. I wouldn't say you lose out in a pedagogical sense from being further from the metal. What you lose in closeness to 'the machine' you gain in expressive power. What's really important in the end is the barrier to entry for a new programmer, which has much less to do with whether the language is high-level or low-level and much more with the simplicity of the language's approach."
coding,3af2il,benreynwar,1 point,Sat Jun 20 01:00:18 2015 UTC,"I necessarily acquired a mental model of the machine (stack, heap, memory addresses, types as interpretations of bits, etc.) that underlies all programming languages.   By the way, the word count for ""stack"" and ""heap"" in the C standard is 0. And you won't find a hard definition of what an ""address"" actually is in the C standard, because that varies too much from architecture to architecture."
coding,3af2il,APersoner,3,Mon Jun 22 13:56:07 2015 UTC,Scratch ([http://scratch.mit.edu]) is a great starting language for kids.  There's a reimplementation of Scratch aimed at highschoolers and adults ([http://snap.berkeley.edu/]) but I haven't looked into it.
coding,3af2il,BourqueJ,5,Sat Jun 20 01:19:18 2015 UTC,"My brother was taught Scratch first in school and it didn't help him out at all when they started learning python and  Java. Just teach people python as a first language - it's so simple it looks like pseudo-code, and you aren't patronising people by hiding away everything vaguely technical."
coding,3af2il,carlodt,3,Sat Jun 20 03:27:52 2015 UTC,So C++ is a good start?
coding,3af2il,Some_Random_Nob,3,Sat Jun 20 01:52:51 2015 UTC,"LOGO...    I'm old.  But I stand by the recommendation.  LOGO is a great way to teach the basics of logic, program flow, parameters, and a few other concepts in a fun environment.  Maybe Scratch is more useful lately."
coding,3af2il,WailingFungus,2,Sat Jun 20 04:23:52 2015 UTC,"I learned flash (as3) as my first and I really loved it. It was very simple, and thanks to it's integration with the stage doing things like hitboxes and moving things onscreen was built in and very easy to do entirely in code. It also meant that you got to learn the basics of coding by making games almost right from the start, with others you have to do a ton of boring text work to learn the basics."
coding,3af2il,RogerLeigh,2,Sat Jun 20 04:00:44 2015 UTC,"I'll second this, flash was a great learning tool for me!"
coding,3af2il,aroberge,2,Sat Jun 20 10:22:41 2015 UTC,"I would argue that a ""first"" programming language needs to simple, but most importantly to allow the user to get immediate results so they can explore and get things working with a minimum of fuss.  Something which is accessible and fun, but which can inform and educate at the same time.  As an example, my first exposure to programming was in primary school with an Amstrad CPC 464 and a BASIC book from the local library, and a little later with a ZX Spectrum +2A.  You could argue that 8-bit BASICs were crap languages, and you wouldn't be wrong.  BUT... they got you hooked by letting you just do stuff.  Exposure to variables, strings, arrays, subroutines.  Graphics commands right there (lines, circles/arcs, colour) and simple sound meant that you could quite quickly be writing fairly decent graphics and games.  With Z80 machine code waiting in the wings for when you outgrew it.  I'd say I didn't do any ""real"" programming until I picked up C nearly a decade later, and then C++ a few years after that, but 8-bit BASIC was a crude but effective grounding in some of the essentials which made picking up C relatively easy, and led to a career in scientific/medial imaging software development, so I can't complain!  Nowadays I think it's a bit harder to get into.  While there are various free BASICs, and scratch etc., all the mainstream stuff is phenomenally difficult to get stuff done without significant groundwork.   Take a simple request: draw a blue circle at x,y with radius r.  Two lines of code in many BASICs: (INK/CIRCLE in ZX BASIC).  What about ""play abc# semiquavers""?  One line of BASIC (PLAY).  Imagine trying to do this in C, C++, Python, on any current platform.  You're already in a quagmire of platform-specific/hardware-specific libraries/modules.  There's no shallow learning curve here; there's a sheer cliff to scale before you're even in a position to even try drawing that circle or playing that sound.  I find this frustrating even as a professional programmer!"
coding,3af2il,bekroogle,2,Sat Jun 20 08:57:53 2015 UTC,"I've designed a programming language environment for beginners based on Pattis's ""Karel the robot"".   The preferred language is Python, just like the author of that blog post concluded.  You want to teach beginners?  The simplest program to make the robot move is ....  move()   Want the robot to move twice?....  guess...    What you learn: that a program is a series of instructions, usuallyexecuted in sequence but can be changed using ""control flow techniques"" (if/else/...).  You learn to group instructions together to define new functions, and express the solution to a given program using these higher abstractions (e.g. follow_the_right_wall()) that you come up with.   No variables (at least initially, nor discussion about types and pointers and ...).  I've been a fan of Pattis's approach since I first encountered it.  Oh, you'd rather use an OOP approach? .... well, it supports this as well:  karel = UsedRobot() karel.move()   etc.  By contrast, this is what the corresponding simplest program one can write with Karel J. Robot  package kareltherobot;  public class SomeName implements Directions {     public static void main(String [] args)     {         UrRobot Karel = new UrRobot(1, 1, East, 0);         Karel.move();         Karel.turnOff();     } }   The greatest impediment to teaching someone else is having oneself internalized too many concepts and having forgotten how difficult to understand these concepts are when encountered for the first time."
coding,3af2il,Shaper_pmp,2,Sat Jun 20 09:53:04 2015 UTC,"# Kudos:  Firstly, let me say excellent article, especially coming from a high school senior!  It's clear gleaned some insights from an ability to deconstruct and analyze your own learning process. Then you top it off by being able to share those insights clearly and eloquently.  # Shameless plug:  You're writing about a topic I've spent a lot of time with recently...my final project at college was designing and implementing a programming language for novice students, called C Spot Run.  In designing my language, I made an implicit assumption, and it's echoed in your article.  # A first language is followed by a second language  One of my first design decisions was to make C Spot Run a teaching language first--not to make any syntax choice that impedes that purpose, even if it would be useful for a production language.   Near the end of the semester, my linear algebra professor vehemently decried the one course in programming required for his Master's in Math. He's still angry that he spent a semester learning a ""teaching language"" (Object Pascal, I think) when he could have learned a more popular, relevant language with an active user base working in his application domain. He felt that if the course used Python, R, Octave, etc., he could have learned the fundamentals of programming AND come out of it knowing a useful language.  While such teaching languages can be great first languages, they may not be appropriate as only languages.  Although your language of choice, Python, is arguably one of the most successful languages at meeting both needs.  # A new trend in programming language research: The Scientific Method!  In your article, you mention the concept of ""visual symplicity"":   The visual simplicity of a programming language refers to how simple a programming language looks visually.   Ignoring for the moment that you kind of used the term in its definition: ""visual simplicity"" is ""...simple...visually,"" it's important to ask how we can tell if a language is visually and syntactically intuitive. It just so happens that Andreas Stefik and Susanna Siebert published a rather lengthy paper entitled, An Empirical Investigation into Programming Language Syntax, which aims to do just that.  And in a sort of self-motivating result, they found that experienced programmers and novice programmers have very different ideas as to which token choices make sense."
coding,3af2il,not-just-yeti,1 point,Sat Jun 20 10:49:04 2015 UTC,"what the best programming language to learn as a first language is    Scheme. With texts ""Simply Scheme"" and ""Structure and Interpretation of Computer Programs""."
coding,3af2il,elyisgreat,4,Fri Jun 19 20:56:06 2015 UTC,"SICP is a great intro to programming text that presupposes no prior experience of programming, but a degree-level grasp of mathematics.  Or put another way, it's a bloody terrible introduction to programming.  It is, however, a really good advanced text on programming, computation and compilation theory."
