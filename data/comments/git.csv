git,3e72hl,durdn,2,Wed Jul 22 13:31:46 2015 UTC,XPost Subreddit Link: /r/programming   Original post: https://www.reddit.com/r/programming/comments/3e725c/git_power_routines_video_course/
git,3e6ma3,webmanio,4,Wed Jul 22 10:33:20 2015 UTC,"Git doesn't deal with authentication directly, it uses whatever your underlying transport requires. It sounds like you're probably using ssh, so look into key-based and agent-based authentication methods for ssh rather than focusing on git."
git,3e6ma3,jakkarth,3,Wed Jul 22 11:33:48 2015 UTC,"You might want to look at ssh-agent forwarding.  Re: developer.github.com/guides/using-ssh-agent-forwarding.  (Oh, and in the future, it's usually best to ask for help with your actual problem—presumably something about replicating a repo across multiple hosts—instead of just asking about the latest hiccup.)"
git,3e6ma3,pi3832v2,2,Wed Jul 22 10:45:44 2015 UTC,I'd recommend key-based authentication if you want to clone without a password   https://help.github.com/articles/generating-ssh-keys/
git,3dy4p8,peterlcole,5,Mon Jul 20 14:14:52 2015 UTC,"Use a single repo.  Lots of people recommend splitting up projects into mutliple repos early, this is generally a very bad idea.  As a project matures and gets exceptionally stable, you can look to break stuff out where it makes sense, but don't start there!   Why?    Logical Commits.  Lots of edits you make will be paired, meaning you change something on the server, then you have to change the client to match.  With a single repo, this goes in one commit with a log that makes sense and has the entire relevant change enclosed in it.  In multiple repos you now have two independent (and impossible to relate later) changes and if they fall out of sync, trouble. Refactoring.  You don't yet know where the edges of your projects should be, stuff will migrate across borders a lot -- early on this is expected.  With multiple repos this is a cut and paste nightmare and you lose history all over the place, with a single repo, it is just mv A/bar.thing B/bar.thing Simplicity.  There is a reason both Google and Facebook use monorepos... they are simple and efficient. Scaling.  People will say ""but a single repo doesn't scale"" -- and this is true at some (very large scale: thousands of developers, millions of files), but for you -- it is not an issue.  YAGNI.  Your Not Going to Need It.  You can split up the project later if you decide you need to -- but you won't."
git,3dy4p8,robertmeta,1 point,Mon Jul 20 19:59:24 2015 UTC,"are they tightly coupled? if not keep it separate.  why? because suppose in the future, you have another TEAM A developing the ""server"" and a TEAM B doing the client.  plan for the future...can you foresee the server being a ""global"" server for multiple clients?   either way, my vote is to keep it separate"
git,3dxhej,kamranahmed_se,10,Mon Jul 20 10:05:24 2015 UTC,"Sometimes, you might get SSL certificate error when cloning, pulling or pushing. The simplest way to make it go away is turn off the SSL verification.   This is the kind of thing that is not OK to put in a random tips page aimed at people who don't necessarily know what they're doing."
git,3dxhej,oconnor663,0,Mon Jul 20 11:43:56 2015 UTC,I wanted to propose the quickest solution. However agreed that there are security implications that I should have mentioned. Thank you. Will update the post!
git,3dxhej,jakkarth,6,Mon Jul 20 13:13:09 2015 UTC,"I'm not ok with suggesting people turn of SSL certificate validation. I'm not ok with suggesting people allow git to store their credentials in plain text. I don't consider a detached head to be a problem to be fixed; if I've checked out a commit instead of a branch, that's exactly the state I expect to find myself in, and I've done so on purpose. It's not an error."
git,3dxhej,a_dog_and_his_gun,2,Mon Jul 20 12:01:26 2015 UTC,"and you could just do ""git checkout -"" to go back to the previously checkedout branch i guess?"
git,3dxhej,jakkarth,0,Tue Jul 21 19:13:47 2015 UTC,"Regarding SSL, I wanted to propose the quickest solution. However agreed that there are security implications that I should have mentioned. Thank you. Will update the post!  Regarding the credentials, I have specified the security concerns and proposed the comparatively secure aand better ways.  Detatched head IS a problem, if you (being a newbie) do not know about it. And checking out the commit is not the only way to get into this state. You may get into it without choice e.g. when rebasing the commits etc."
git,3dve0o,zubie_wanders,6,Sun Jul 19 21:05:30 2015 UTC,"Yes, you can. But don't expect git to store them efficiently. The repository may blow up to a large size very quickly, depending on the size of the spreadsheets. Unless your spreadsheets contain lots of advanced excel-only features (VB macros, embedded graphs, etc etc), I'd recommend exporting them to CSV files. At the very least, the plain-text will compress a lot better, even if the diffs are still only marginally useful.   If the spreadsheets DO contain specialized excel-only features, just slice those out of the data spreadsheets and put them into a single Excelt spreadsheet file. You can commit THAT, and import it as a separate...page/workbook, whatever Excel calls it."
git,3dve0o,therealfakemoot,4,Sun Jul 19 21:20:02 2015 UTC,"It will store them efficiently if you run git gc occasionally: committed a 512MiB file with random bytes, changed a few bytes with a hex-editor, committed again. repeated this procedure two times.  $ du -hs .     2.1G    .  # 512 (filesystem) + 512 (first full store in git)  # + 512 (first change) + 512 (second change) = ~2GiB $ git gc $ du -hs .     1.1G    .  # 512 (file in filesystem) + 512 (first full store in git) = ~1GiB $ du -hs .git     513M    .git  # first full store in git only, the changed bytes are stored as delta"
git,3dve0o,jringstad,3,Sun Jul 19 22:54:01 2015 UTC,"Neat. Not a statistically significant dataset, but very neat nonetheless. git is awesome."
git,3dve0o,therealfakemoot,2,Sun Jul 19 22:57:40 2015 UTC,"The problem with binary files is that git has a harder time determining a compact set of changes that were made to the file. For instance excel files are zip files, which means changing a single field could change a significant number of bits in the stored file due to compression."
git,3dve0o,Guvante,1 point,Sun Jul 19 23:44:55 2015 UTC,"Yeah, if the files are compressed, there is only so much you can do about it. But considering the typical size of excel documents and the typical size of harddrives, I'm sure you could do thousands of commits before you'd even do a double-take at the size of the repository. You don't have to commit after every change you make either, if you know you're going to make more.  And if it does become too big, you can just squash together some old commits, and use --depth=1 when cloning the repository.  So all in all, I think it's pretty much a non-issue, if you do want to solve it that way."
git,3dve0o,jringstad,1 point,Sun Jul 19 23:48:51 2015 UTC,Cool--though I had read that the xlsx files are really XML and there was some git tool that would basically convert to text before commit and then deconvert after.
git,3dve0o,atlgeek007,5,Mon Jul 20 17:59:05 2015 UTC,"I'd suggest using Dropbox, sky drive, or google drive for this instead of git, to be honest."
git,3dve0o,takuhi,2,Sun Jul 19 21:24:02 2015 UTC,"Yep, Git is for version control not file backup or synchronisation. With Google Drive you could use Google Sheets as well, makes realtime collaboration a bit easier."
git,3dve0o,pi3832v2,1 point,Sun Jul 19 21:53:32 2015 UTC,"Plus, if they're Google Sheets they won't count against the storage quota on Google Drive.  And as a bonus, you can use them on most major platforms via a web browser, and on a lot of devices via free apps."
git,3dve0o,ldpreload,2,Sun Jul 19 23:11:16 2015 UTC,"You can. One word of caution is that git is sort of bad at files that are larger than the size of memory. Mapping a single file of source code is generally not a problem, but if you've got 3 GB data files, things are likely to go poorly. For your use case, this is probably not a problem.  Git has a mechanism (see the discussion of ""smudge"" and ""clean"" filters at the bottom of this page) for doing rewrites on files between the copy on disk and the copy in the git repository. I think the intention is keyword expansion, people with preferences about indentation style, etc. But there are a few solutions that use this to track large files, such as GitHub's git-lfs. It's possible there's something similar for unzipping xlsx files in the git repo, and re-zipping them when you check out the files from the repo. Hopefully that helps you Google, or understand what you're looking at."
git,3dve0o,ptman,1 point,Sun Jul 19 23:42:11 2015 UTC,"git totally can do binary file diffs. IIRC git actually does binary diffs of all files, both text and binary. But git stores all versions not just last x days or y versions. Many binary files are read in by programs and converted to in-memory stuctures and then written out in their entirety. Small logical changes may result in large changes in the file contents, especially if compression is involved. This is much less common in text files."
git,3dt5wd,Srz2,6,Sun Jul 19 05:18:36 2015 UTC,"I also got good at Markdown (which I only realized now (literally) that's the formatting for reddit too) which goes hand in hand if you use github for the README files.   You'll probably be wanting this at some point: pandoc.org.  Use option ""-f markdown_github""."
git,3dt5wd,pi3832v2,1 point,Sun Jul 19 09:21:08 2015 UTC,"Looks cool, I might use it eventually but it seems like overkill. Haha. Maybe once I become a big time programmer and I could use its functionality fully, I'd considering it. Thanks though!"
git,3dt5wd,pi3832v2,1 point,Sun Jul 19 15:44:34 2015 UTC,"…but it seems like overkill.   Trust me: at some point someone will request copies of your documents in some asinine format (e.g., Word files) and pandoc will become your best friend."
git,3dt5wd,palmin,2,Sun Jul 19 22:53:30 2015 UTC,"I would zip up the project ""just in case"".   This is exactly how I got through the 90's before somebody introduced me to CVS."
git,3dt5wd,flarkis,1 point,Sun Jul 19 13:05:13 2015 UTC,"I was really worried this was going to be another one of those ""I don't grok git but have to use, can someone explain how I can get by without learning anything"" posts that pop up here all the time.  Glad to hear about your success with it. My company uses -shuders- perforce for everything. If you haven't heard of it then you are quite lucky. I just do all of my local development in git and dump changes back into it whenever things get stable enough."
git,3dt5wd,tacho_,3,Sun Jul 19 09:02:57 2015 UTC,"If you haven't seen it already, using the git-p4 bridge makes Perforce much more bearable."
git,3dt5wd,rethnor,1 point,Sun Jul 19 13:07:42 2015 UTC,I try to make it a point not to complain on the internet (which I know some people think it's its purpose).  I guess i'll consider myself lucky that I dont know perforce.
git,3dt5wd,__baxx__,1 point,Sun Jul 19 15:46:21 2015 UTC,What's wrong with perforce? We're switching from accurev and I saw mentioned a number of times due to its performance.
git,3dr88a,galaktos,2,Sat Jul 18 18:03:20 2015 UTC,"It's possible you can do a second clone, using your first local repository as a --reference (see man git-clone). Not sure, and you'd certainly want to git fsck the result. But that could save you a lot of bandwidth for a large repository."
git,3dr88a,Rainfly_X,1 point,Sun Jul 19 18:47:08 2015 UTC,"That’s a good idea, thanks!"
git,3dr88a,jakkarth,1 point,Sun Jul 19 19:14:02 2015 UTC,"If your pack files are corrupt, then running git fsck is not guaranteed to give you sane output. It depends on at least some of the data not being corrupt. Thus, if there is pack file corruption, it's unsafe to trust anything in the .git directory for the purposes of trying to recover, with the possible exception of using a known good set of hashes on a remote to do some kind of sane deltas.  The problem is that the local git repository is considered self-authoritative. The remote is just another repository, not the ""right"" repository vs our ""wrong"" repository. Git will let you merge changes from another repository into yours because that's a controlled operation, but what you're talking about would be blindly destroying local data in favor of remote data, and I don't think git has a way to do that.  I'm not an expert though, so I'd love to be corrected."
git,3dr88a,jakkarth,1 point,Sat Jul 18 18:09:34 2015 UTC,"I’m not sure if the pack file was corrupt. Perhaps it wasn’t. All the error messages from Git seemed to indicate missing objects, not corrupted ones – so I thought it should be possible to fetch those particular objects from a remote repository. (The head commit was still there, so unless the remote can produce SHA-1 collisions, there’s no reason not to trust the received objects.)"
git,3dq5vk,dotsau,3,Sat Jul 18 10:51:18 2015 UTC,Unfortunately you have to get the entire repo or nothing.  This part of git makes me sad every day I think about it.  (The first person to say use more repos and submodules gets whacked).
git,3dq5vk,djryan,2,Sat Jul 18 11:03:14 2015 UTC,"Here is a Stack Overflow post that seems to be useful: http://stackoverflow.com/questions/4479960/git-checkout-to-a-specific-folder  If that's not sophisticated enough for you, you may need to learn more about the low level commands like git read-tree, git cat-file, and git checkout-index.  But... the real problem here is that you're asking your version control system to manage a deployment, which is not what it was originally designed to do. That's why there's no quick and intuitive command for this. You're supposed to do a normal checkout, and then run some kind of build or deployment script (that itself should be in the repo) to move and/or process the files to where they need to be."
git,3dq5vk,DanLynch,1 point,Sat Jul 18 13:42:55 2015 UTC,"Github's subversion checkout capability can target a single subdirectory. Nice, but not really git anymore."
git,3dornq,1playerpiano,3,Sat Jul 18 00:41:12 2015 UTC,"If you step back a bit, and look at the overall picture, a good mental-picture of git is that a git repository is a set of snapshots of the code-base over time. Roughly speaking, each 'commit' is a snapshot. All the rest of the nitty-gritty merely reduces the amount of storage needed for all of those snapshots, and allows you to select one of the snapshots at will."
git,3dornq,shortbaldman,2,Sat Jul 18 01:23:11 2015 UTC,"Can you give a quick example of how you might work on a project, independent of git, so that we can tailor a simple set of git commands to your situation and help explain it better?"
git,3dornq,jakkarth,1 point,Sat Jul 18 00:43:16 2015 UTC,"Yeah!  To start, I mostly work with web design/dev right now (that's my job, to redesign websites with mobile in mind). I keep everything I work on in a Dropbox folder just so it's backed up online and on my devices... I use Sublime Text 2 if I'm working ""in the office"" and I ssh in if I'm working remotely. If I SSH in I use vim to edit source code.  I keep all of these projects stored in independent directories, all of which are stored under a directory named ""web_projects"".   So, what I will end up having is something like this: web_projects/project_name/index.php. In the project_name directory, I have all of the other files and directories. Directories for CSS, JS, PHP, and other scripts and files I might need to make the website work.   I edit the source code, and if I need to test / debug something, I do it on my server (because of how my job is set up, I'm not allowed access to my employer's servers until the project has been finalized and approved by my supervisors, so I have to do all of my tests on my server).  I send my employers links to specific versions of the projects, and based on their feedback I make changes as necessary."
git,3dornq,DanLynch,2,Sat Jul 18 01:43:22 2015 UTC,"I send my employers links to specific versions of the projects, and based on their feedback I make changes as necessary.   OK, let's dig deeper into this part. How do you keep track of all the different versions that you have shown to the client? If he told you to go back to the version from two days ago, after disliking the changes in today's and yesterday's versions, what would you need to do in order to get back there?   I edit the source code, and if I need to test / debug something ...   What do you do if the edit you tried didn't work (and actually made things worse) and you want to go back to exactly how it was before you edited it?"
git,3dornq,DanLynch,1 point,Sat Jul 18 01:51:28 2015 UTC,"Generally the changes are minimal enough I can find them in the code easily. I've never encountered a situation where I couldn't find the changes made. Since I'm the only one working on the projects right now, it's easy for me to keep track of what happens. I comment things that are temporary, I make sure to mark and comment things that are necessary...   It's a system that works now, but its eventually going to be a terribly ineffective way to work, especially if I start working with other people, or working on larger and larger projects..."
git,3dornq,pi3832v2,2,Sat Jul 18 02:13:49 2015 UTC,"All right, so you have the context you need to understand what Git is all about.  Git is a tool that lets you ""save your game"" as often as you want while working on a software project, so that you can easily return to and/or compare multiple previous versions of the project, without resorting to terrible anti-patterns such as commenting in/out code, and without the unreliability of having to remember anything yourself.  These ""save points"" form a branching hierarchy, which means you can return to an older version, and then continue from there with a fresh new idea in a different direction, without losing any of your previous ideas, and without having to even remember which ideas were forked off of what base. You can jump around effortlessly between various divergent threads of thinking, giving them names and metadata to help you make sense of it all, and you can cherry-pick ideas from divergent threads and bring them together.  The simplest way to use Git is to maintain a simple linear history of your code after each change: version 1, version 2, version 3, ... version 400. But that's just scratching the surface of what Git can do for you."
git,3dornq,DanLynch,1 point,Sat Jul 18 02:36:21 2015 UTC,"These ""save points"" form a branching hierarchy, which means you can return to an older version, and then continue from there with a fresh new idea in a different direction, without losing any of your previous ideas, and without having to even remember which ideas were forked off of what base. You can jump around effortlessly between various divergent threads of thinking, giving them names and metadata to help you make sense of it all, and you can cherry-pick ideas from divergent threads and bring them together.   Do you have any advice on naming schemes for branches, to be able to keep track of what you were doing?    Also, what do you mean by ""metadata""? Tags?  Or just commit comments?  (Hopefully this is relevant to the OP, and not a thread-hijacking.)"
git,3dornq,HomeBrewCrew,1 point,Sat Jul 18 12:03:02 2015 UTC,"Do you have any advice on naming schemes for branches, to be able to keep track of what you were doing?   In the traditional, default way of using Git, you would have a master branch that contains your main line of development, and you would make feature branches off it to do experimental things, with each feature branch being named after the feature it is intended to contain.  A more sophisticated Git branching and branch-naming strategy is called Git Flow.   Also, what do you mean by ""metadata""? Tags? Or just commit comments?   I was referring to commit messages, author and committer names, and commit timestamps."
git,3dornq,HomeBrewCrew,1 point,Sat Jul 18 16:04:05 2015 UTC,"Not sure if you have tried the Git documentation, but I found reading at least the first 4 chapter of this documentation to be extremley helpful"
git,3dornq,DanLynch,1 point,Sat Jul 18 00:45:20 2015 UTC,"I have read the first few chapters (either two or three) but that was a long time ago and a friend recommended that I try an interactive tutorial (actually, it was codeschool. I got about halfway through that tutorial before I had to stop because I didn't understand what I was doing."
git,3dornq,oconnor663,1 point,Sat Jul 18 01:44:55 2015 UTC,I find it helpful when trying to learn new concepts to draw things out. Read something then force yourself to stop and explain/articulate it out loud and draw high level diagrams for reference later on in the tutorial.
git,3dornq,kannonboy,1 point,Sat Jul 18 02:12:07 2015 UTC,I'll try that out. Thanks!
git,3dornq,geekbot,1 point,Sat Jul 18 02:15:43 2015 UTC,"I understand that it's a version control system, and I know what that means... if two people are working on the same project, and one person saves before the other, the first person's changes aren't overwritten when the other person saves... that's the version control part...   I think part of your problem is that this is not a very good definition of what a version control system is. As a hint: Git is designed to work very well as a single-user version control system.  A version control system lets you manage more than one version of a project. You can use Git instead of creating random files and folders with names like ""firstattempt"", ""working"", ""working2"", ""temp"", ""broken"", ""final"", ""finalwithcomments"", ""finalafterreview"", ""finalassubmitted"", ""finalfinalafterfeedback"". Git handles all of that crap in a smooth and powerful way."
git,3dornq,stubborn_d0nkey,1 point,Sat Jul 18 01:01:57 2015 UTC,"See, I understand that, I just didn't do a very good job at explaining it... and I understand that it's for these reasons that Git is an extremely useful and powerful tool for developers of any kind... I just can't seem to grasp how to use it. I was just talking with a friend, and I explained it this way:   If you tell someone who hasn't taken calculus that it involves taking derivatives of functions, they'll understand the words, but they might not understand what the words mean. I understand what Git is, I just don't understand how to use it."
git,3dhj4i,da-x,1 point,Thu Jul 16 09:13:26 2015 UTC,This is different from git stash how?
git,3dhj4i,cpbills,2,Thu Jul 16 15:16:29 2015 UTC,"Key differences:   git stash saves only the dirty git state narrowly (modified files, and added files in the index), whereas git-bottle tries to save everything that is different from HEAD, and it differentiates between modified, modified and not added, not added, unmerged paths, and the complete rebase/merge states. git stash saves to stash objects that you need to keep track separately. If I stashed something 2 weeks ago I might not remember it, whereas git bottle saves as tentative commits to the current branch, and the saved state can be pushed and shared among repositories. This can be useful for remote builds, where you have another repository in a remote server just for building."
git,3dhj4i,nerdponx,1 point,Thu Jul 16 16:02:17 2015 UTC,Isn't this what branching is for?
git,3dhj4i,cpbills,1 point,Fri Jul 17 01:24:24 2015 UTC,"Yes, the whole point with git-bottle is to leverage branching in order to save/load the state, unlike git stash in which it is a side option."
git,3dhj4i,Peaker,0,Fri Jul 17 05:03:28 2015 UTC,"That seems goofy.  If there are any changes I need to 'tentatively' commit and share with other contributors, I will commit them."
git,3dhz8x,understanding-git,1 point,Thu Jul 16 12:44:53 2015 UTC,"In the linked wiki page, I show an emulated workflow and end with a question I'm wondering about. My reason for posting this link here is I was hoping someone could answer that question :) Also posted at https://news.ycombinator.com/item?id=9896840"
git,3dhz8x,payco,1 point,Thu Jul 16 12:46:27 2015 UTC,"Are you okay including changes that happened directly on master? If so, I think git log --no-merges master should work. That lists all commits that are a parent of master, filtering out any commits that have more than one parent (i.e., merges).  Adding the --patch or (-p) to that command will show the diffs for each commit as well.  If you want to show only the commits on feature branches that have since been merged into master... I think that might take multiple steps."
git,3dhlv0,248625,3,Thu Jul 16 09:53:05 2015 UTC,"Perhaps your local branch doesn’t have the remote branch set up? There should be something like this in your .git/config:  [branch ""master""]     remote = origin     merge = refs/heads/master   Without this, Git won’t know which remote branch to compare your local branch to. (AFAIK it won’t just guess that branches of the same name belong together.)"
git,3dhlv0,galaktos,2,Thu Jul 16 10:20:02 2015 UTC,"You were right, my config file just had:  [branch ""master""]   I wonder how it could have gotten into this state though?   Thanks very much :))"
git,3dhlv0,pi3832v2,1 point,Thu Jul 16 10:39:54 2015 UTC,"I'm not sure if this is relevant, but I expected the following command to show HEAD pointing at the latest commit, not two behind.  $ git log --oneline --decorate origin/master 7a42df1 (origin/master) *message* dca532b *message* f83f49e (HEAD, master) *message* ...    HEAD won't point to the latest commit until you merge FETCH_HEAD, a.k.a., the second part of a pull.  But git status should now show that the local branch is behind.  E.g.,:  $ git status On branch sideways Your branch is behind 'origin/sideways' by 20 commits, and can be fast-forwarded.  (use ""git pull"" to update your local branch)  nothing to commit, working directory clean   Does status still show your local branch as up-to-date, post fetch?"
git,3dazpd,JAWJAWBINX,1 point,Tue Jul 14 21:42:12 2015 UTC,http://stackoverflow.com/questions/11265463/reset-git-proxy-to-default-configuration
git,3dazpd,kramer314,1 point,Tue Jul 14 21:44:43 2015 UTC,"Thanks, that fixed it. I already found some of those and they hadn't worked."
git,3dak8f,Kummo666,2,Tue Jul 14 19:54:46 2015 UTC,"The entire purpose of the squash workflow is to destroy the history that was squashed; you can't have both. By adopting the squash mentality, you have chosen to discard the history. If you choose to keep the history, you will repudiate the squash approach."
git,3dak8f,DanLynch,1 point,Tue Jul 14 20:42:20 2015 UTC,"You can have both. I use squashes to kill typos all the time, because that history isn't important."
git,3dak8f,cpbills,2,Wed Jul 15 00:50:08 2015 UTC,"It sounds, to me, like you're slightly misunderstanding ""squash your commits together so we get a clean, reversible git history"".  To me that means make sure you squash all of your 'typo fix' commits into one sensible commit, per thing you were fixing.  If it took you 5 commits to get a bug fixed, squash it into 1 commit (or as few logical commits as necessary) that applies cleanly. So if that commit is applied; the bug is fixed, or a file is changed, and nothing breaks. If you remove that commit, the bug is back, but nothing else breaks, either.  Does that make sense?"
git,3d70ts,rvndps,6,Tue Jul 14 00:45:26 2015 UTC,"Just to clarify, you see delay between hitting the ""merge PR"" button and the merge actually taking place within git? If that's the case, maybe doing the final merge locally would bypass the delay.  Once the relevant people have signed off on a PR, the designated merger could do a git merge --no-ff <feature-branch> (or the equivalent in a GUI), make sure the commit message matches your team's convention for PR merge commits, then git push origin to update bitbucket's git server.  If bitbucket behaves the same way as GitHub, the PR system should pick up on the fact that the feature branch has been merged and automatically accept/close the PR. Maybe the delay would manifest itself there (which is certainly less than ideal) but at least your main development branch will be updated in a timely fashion so people can pull it."
git,3d70ts,payco,1 point,Tue Jul 14 02:25:02 2015 UTC,"I have never tried to merge a PR in local. Do you have any detailed tutorial on it? Quick Question: If someone does merged their PR to master, after my last fetch and merge in my local. Will it cause conflict or divergence problem when I try to push my PR merge to repo?"
git,3d70ts,payco,2,Tue Jul 14 03:58:59 2015 UTC,"Sure; I'll look for an existing one, but I'll write some steps up otherwise. Do you use any GUI tools to work with your local git repo? If you use a lot of Atlasssian stuff, you may have SourceTree installed, for instance.  As to your quick question: yes, if an order like the following happens:   You pull from origin, start your merge operation locally Teammate pushes a merge commit to origin You finish the merge and attempt to push   then the push operation will complain at you. You can do a git pull --no-rebase, which will create a new merge commit that joins origin's version of master to your version of master. You can then push to the server again. This does have the unfortunate side effect of having an extra merge commit that makes the branch history look a little less pretty, but I seem to be the only person on my (small) team that cares about that :)  There are a couple different ways to reduce the chance of this conflict, though. I'll make sure to include the more technical ones in the tutorial. The easiest one is to just make sure the feature branch can merge into master without conflicts, and that you write the commit message very quickly (perhaps keep the template string somewhere close at hand to copy/paste), so that you can keep the window between pulling from origin and pushing back to it as small as possible.  One other way is to reduce the number of people who are designated to run this whole operation. Instead of making each feature developer do it, have the team lead (or some other single person per team) do the actual pull-merge-push operation. That at least keeps the number of simultaneous pushes low.  Personally, my team is small, so I avoid conflicts by shifting my work hours and doing my merges while they're asleep :D"
git,3d70ts,jakkarth,1 point,Tue Jul 14 15:59:05 2015 UTC,Thanks for the detailed explanation. I figured out how to do a local PR merge after few mins spending on googling. Even bitbucket supports local PR merge. I am not sure whether this approach will work on a team of 50+ devs. I will have it as a trump card to push emergency fixes.
git,3d70ts,flynnguy,5,Tue Jul 14 16:34:53 2015 UTC,"Assuming your merges aren't gigabytes worth of changes, this is not a git problem. I regularly see projects on github with dozens of open pull requests and have never heard of it being an issue, though I've never heard of it being an issue with bitbucket either. It's certainly worth a try.  You can also run your own web interface via tools like gitlab. Maybe also consider gerrit and gitolite.  Of course, all these fancy interfaces are entirely optional. You can use git without them. Just add a remote to a local repo and run git pull and you'll be merging PRs in no time.  I'm happy to answer further questions about the above or anything else git related :)"
git,3d70ts,jakkarth,2,Tue Jul 14 00:53:59 2015 UTC,"Yes, merge changes are mostly few lines. Will check the tools that you have suggested. I am not sure whether my sys admin will go for a self hosted git repo. We opted for bitbucket because we use other Atlassian product like jira and hipchat. Thanks for the quick reply."
git,3d5hfm,noobcser,2,Mon Jul 13 18:01:15 2015 UTC,"Follow up question - if I am using BitBucket to host my stuff, how does Gitflow come into play? Is it somehow automatically bundled by Atlassian? Or Gitflow is simply something I install locally and I can use their wrapper commands on CLI?   Disclosure: I currently work for Atlassian.  This is where Gitflow can get confusing. Gitflow is both a convention for using Git and a set of scripts to support that convention.  As a convention, Gitflow suggests how to name and use branches. In the overall Atlassian suite, here are some of the things that help support the Gitflow convention:   In JIRA, you can create a branch from an issue. JIRA uses knowledge of the convention to select the branch source and uses the convention to populate the branch name (so you don't have to cut and paste issue numbers). In Bamboo, you can use branch names to filter which branches get built and deployed. You might build and deploy all ""release"" branches but maybe you only build ""feature"" branches. In Bitbucket and Stash, you can use branch permissions to control who can push to certain branches. The convention doesn't really indicate how to deal with the release/production implications of merging but branch permissions can help.   In short, there isn't just one thing you use or install to ""do Gitflow"". Instead, the products just fit with Gitflow (and alternatives).  As scripts that support the Gitflow convention: https://github.com/nvie/gitflow  If you are only using Bitbucket (and not JIRA), the scripts are mostly useful to keep the naming convention but they pair well with branch permissions."
git,3d5hfm,squian,2,Mon Jul 13 22:50:17 2015 UTC,"changes made on the release branch need to be merged back into develop, so that future releases also contain these bug fixes. - this mean for a period of time (between release creation and merge to master), there are fixes / code changes that go into release but does NOT go to develop? Wouldn't it be a better approach to always do your work off develop branch and cherry pick your commit into release as necessary?   I guess you really could do it either way, but producing the fix on a release branch might make more sense for two reasons:   Sometimes when you commit a fix to one branch, you can cleanly apply it to a different branch, but sometimes you can't. Practically speaking, you probably won't find that out until after you've created it. Some fixes are urgent. Release are out in the field in active use, used by paying customers or by the company web site or whatever else. If something is seriously wrong, such as a security issue, it might be important to get the fix out there as soon as possible.   So imagine you've released version 1.3 and 1.4 of your software and there are many customers using both. You are in the process of developing version 1.5 when a security issue is discovered. If you develop the fix against the branch corresponding to the unreleased version, the fix might not cleanly apply to the release-1.3 or release-1.4 branches. Now you have an unnecessary delay. (Chances are, if a fix created on a 1.5 branch does not cleanly apply to a 1.4 branch, then the opposite will be true: the fix created on a 1.4 branch will not cleanly apply to the 1.5 branch. However, at least you can deal with that problem at your leisure, after the fix has been released and the customers are taken care of.)  Furthermore, most likely version 1.3 or 1.4 is where the security bug was found. If you want to reproduce/understand the bug, it makes sense to start with a configuration as close as possible to the one in which the bug was discovered. If you don't, it's possible you might misunderstand the bug, fail to be able to reproduce it, or not produce the right fix.  Not all bug fixes are urgent, of course, but if you want to be consistent, it makes sense to choose the workflow that works better for urgent fixes."
git,3d5hfm,adrianmonk,1 point,Tue Jul 14 06:25:18 2015 UTC,"at least you can deal with that problem at your leisure, after the fix has been released and the customers are taken care of   Great point, thanks!"
git,3d5hfm,jakkarth,2,Tue Jul 14 12:34:59 2015 UTC,"Yes, that's exactly what it means. Some people choose to rebase instead of merge because it tends to keep the history cleaner. Which one you choose is up to you, but you should try to stick with one or the other generally speaking. If you're working on a team that has established a default for this, use their default. Yes and no. Sometimes it's easier to keep track of a particular release branch by not having merges into it from other branches all the time. If it's just a small bug fix that only applies to this particular release, you can merge it back into development all at once. Again, not a strict requirement, you could cherry pick back and forth either way. The problem is that the development branch has a lot of other work going on in it that isn't relevant to this particular release, and cherry-picking loses the context the commit was created in whereas a merge does not. That's specifically what feature branches are designed to make possible. By using feature branches, you don't clutter up development with half-finished features that aren't going to end up in the release. By keeping half-finished features in separate branches, it's always safe to make a release branch from development. Because cherry-picking throws away context. You're getting rid of the parent commit references when you cherry pick, so you can't see the history it was developed under. Also, because it doesn't include any of the parent commits, they can often be very difficult to apply individually; this is especially true the further the release and development branches have diverged."
git,3d5hfm,jakkarth,1 point,Mon Jul 13 18:20:11 2015 UTC,Thanks for the response ... sorry for the ignorance but what's exactly meant by:   cherry-picking throws away context
git,3d5hfm,throwawaylifespan,1 point,Mon Jul 13 18:43:49 2015 UTC,"In this case it means the history of everything before the commit in question. If it was commit 3 of a 5-patch bugfix, and it depends on the two before it to apply cleanly, you're going to get errors/conflicts during the cherry pick operation. After you've resolved them, when you look at the history of the branch you picked it into, you won't see the other 4 patches from the bugfix, there won't be any indication that it was part of a set. It won't even have the same parent commit that it did before. Sometimes that information is helpful, but a cherry-pick discards it."
git,3d5hfm,humansky,1 point,Mon Jul 13 19:05:17 2015 UTC,Well explained sir.
git,3d6uf4,ChevronCat,2,Mon Jul 13 23:53:56 2015 UTC,"I'm confused.  Do you want to change where the files are hosted, or change the DNS configuration with the domain-name registrar to point to a new host?"
git,3d6uf4,pi3832v2,1 point,Tue Jul 14 01:15:36 2015 UTC,"The latter? Currently, everything is hosted and published through github, but I'm trying to either: set up a custom domain name through github or transfer everything to her domain name. The end result is just having her domain name show up with this new design and content I've created. I have no idea how to configure DNS or what a registrar is. :/"
git,3d6uf4,xiongchiamiov,1 point,Tue Jul 14 01:36:27 2015 UTC,"When you register a domain, you tell that company (your registrar) who should be hosting the DNS for that domain, so they can tell everyone else where to look. Often these are the same company, but not always.  Your DNS host controls where people go when they visit your domain. If you want her domain to go to Github, you'll need to change those DNS entries to point there. These controls will be in the control panel of the DNS host."
git,3d6uf4,jaxzin,1 point,Tue Jul 14 01:46:47 2015 UTC,Thanks so much for clarifying! This makes sense and helps me understand the github pages documentation much better.
git,3d3fbd,insanehong,3,Mon Jul 13 05:18:59 2015 UTC,"See also gitignore.io, which can be added to your shell."
git,3d3fbd,ccharles,1 point,Mon Jul 13 05:41:49 2015 UTC,gitingore.io is cool! But  gitignore.io CLI used curl so no supported offline and no supported custom gitignore template packages.  gig support offline and custom gitignore template packages.
git,3d3fbd,dAnjou,3,Mon Jul 13 06:50:37 2015 UTC,How often does someone create a new project that they need a CLI tool to create their .gitignore?
git,3ct6za,lclemente,3,Fri Jul 10 16:02:12 2015 UTC,"Alternative that's been around for a while and doesn't need Go, just bash."
git,3ct6za,spwhitton,3,Sat Jul 11 07:21:36 2015 UTC,"Thanks, I was not aware of that project.  One advantage of my implementation is that it supports thin pack files, meaning that only the compressed deltas will be pushed / fetched."
git,3ct6za,untitleddocument37,1 point,Sat Jul 11 07:38:06 2015 UTC,git + ssh => luks/encfs/etc == better?
git,3cpg5l,letthisnightexplode,2,Thu Jul 9 18:46:08 2015 UTC,"Back in the day when we all used cvs there was support for magically updating strings.  So if you had $Id:$ it would get expanded on commit/checkout, for example.  In git however that isn't supported.  Linus said:   ""The whole notion of keyword substitution is just totally idiotic. It's trivial to do ""outside"" of the actual content tracking, if you want to have it when doing release trees as tar-balls etc.""   So the short version is no, this is not supported.  If you use make you can write rules in your Makefile to format IDs, etc, via calls git, but that's your best option."
git,3cpg5l,chocolate_bread,2,Thu Jul 9 19:45:07 2015 UTC,I know git generates a string of data to identify which revision we're working with…   Does it?  I thought it only kept track of what commit you're working with.
git,3cpg5l,pi3832v2,2,Thu Jul 9 19:54:57 2015 UTC,That string got generated is s hex-encoded sha1 hash of the content of the commit. For obvious reasons it can't be known ahead of time and inserted into the commit
git,3cpg5l,jimktrains,1 point,Fri Jul 10 03:10:31 2015 UTC,"Git doesn't alter the code that gets committed. You need to edit the code before you commit it if that's what you want. If you just want to tag certain commits with version numbers, that what git tags are for."
git,3cpg5l,artard,1 point,Thu Jul 9 23:38:06 2015 UTC,"Why not have your build / CI system do it for you?  When we detect the build is running on CI, the build number is automatically appended to the version string and, if successfully published, tagged in git."
git,3crmtg,ilikeredkidneybeans,5,Fri Jul 10 05:34:51 2015 UTC,Git does not have anything to do with installing security patches for Magento.
git,3crmtg,DanLynch,1 point,Fri Jul 10 05:39:29 2015 UTC,here is the link which says to apply patch using command line http://devdocs.magento.com/guides/m1x/other/ht_install-patches.html#apply. I asked this question in r/magento one person told me to use git. i searched online but didnt get anything useful.
git,3crmtg,DanLynch,2,Fri Jul 10 05:46:10 2015 UTC,"You misunderstood the suggestion that was made in /r/magento. The other user suggested you might want to use Git Bash instead of Cygwin, because many people these days already have Git Bash installed on their Windows machines. If this is not the case for you, the suggestion has no value, and you might as well follow the original suggestion of installing Cygwin.  The topic has nothing to do with Git."
git,3coyly,Roseysdaddy,1 point,Thu Jul 9 16:38:10 2015 UTC,"I haven't looked at your link, but the error is pretty clear. There's a permission error on that file, either ownership or mode, such that git (as the current user) can't modify it.  When you tried it with sudo, it used root's ssh keys instead of the unprivileged user's, thus the publickey error.  Git reset --hard has nothing to do with remotes or pulling, so it's not surprising it didn't affect anything."
git,3coyly,jakkarth,1 point,Thu Jul 9 16:47:37 2015 UTC,"ok.  so i changed the permissions on the .sickrage folder and files to 777 but I still get the same error.  Does that mean I need to change git's permissions?  And if so, how would I do that?"
git,3coyly,jakkarth,1 point,Thu Jul 9 17:13:09 2015 UTC,".sickrage is not the problem. You need to look at .git/FETCH_HEAD, as the error states. My guess is that you need to change the ownership of everything in your working directory to be that of the user you're trying to do this stuff as."
git,3coyly,Jack126Guy,1 point,Thu Jul 9 17:18:47 2015 UTC,"Any idea where .git/FETCH_HEAD is located, or what I would look at once I'm there?"
git,3coyly,urvll,1 point,Thu Jul 9 17:29:14 2015 UTC,"This is located under the .sickrage folder, that is, .sickrage/.git/FETCH_HEAD."
git,3coyly,jredmond,1 point,Thu Jul 9 17:41:22 2015 UTC,Everything from .sickrage on up is set to 777. What else would I need to do?
git,3coyly,pi3832v2,1 point,Thu Jul 9 17:57:52 2015 UTC,Just remove and clone this thing again. You don't need to pull anything just after cloning.
git,3ceuao,Recallz,1 point,Tue Jul 7 10:43:07 2015 UTC,In my git (version 2.1.4) most of the mentioned files (e.g. .git/index) are not text but some unreadable binary format.
git,3ceuao,fuxoft,1 point,Tue Jul 7 11:01:19 2015 UTC,The index file should be in readable text. You should be able to find the hash of (I think) the name of your file in it.  You're right that it doesn't look at all like what the author showed.  I'm using 1.9.5 on Windows.  Index  Object  The author must have used some commands in git that allow you to check the content of the files from the database. I cant remember what they are.  edit:    git ls-files --stage   Preview    File type Hash stage number filename    100644 f2e4113.... 0 letter.txt
git,3ceuao,Kraigius,2,Tue Jul 7 20:13:02 2015 UTC,"Well, I'm using 1.9.1 (gee, what am I doing?!) and .git/index always contains lots of binary content. The paths are human readable as well as what looks like permissions.  Btw. your ""I don't know"" is the index or stage number which is only non-zero if you have multiple versions of a file due to a merge conflict (source)."
git,3ceuao,mus1Kk,1 point,Wed Jul 8 09:45:05 2015 UTC,"644 looks like permission. My wild guess is that 100 is for a ""file"" and there most be other encoding for the different types (symbolic links, folders, etc.).  edit:    100644 blob  040000 tree   Pro Git first edition p.228"
git,3cg6es,fezzik02,2,Tue Jul 7 17:36:47 2015 UTC,If .NET is your style: https://bitbucket.org/atlassianlabs/bitbucket.reviewerassigner
git,3cc94r,musicomet,5,Mon Jul 6 20:01:14 2015 UTC,git reflog and then reset the branch to it :)  https://stackoverflow.com/questions/134882/undoing-a-git-rebase
git,3cc94r,Kraigius,3,Mon Jul 6 20:11:41 2015 UTC,How can I determine where the rebase started?
git,3cc94r,Kraigius,4,Mon Jul 6 20:17:14 2015 UTC,"Pretty straight forward. The reflog is an historic of your git commands/actions. Each line consist of an hash that you can checkout, HEAD@{n} which refer to the n position of the prior value (the hash and the HEAD@{n} point at the same thing, just different way to reference the same thing) and a description. Read from bottom to top    dh84kz3 HEAD@{20}: commit : <message> //if you did a commit at this point //Creating a new commit   ad2g4kz3 HEAD@{21}: rebase -i (finish): returning to refs/heads/<branch name> //Finishing the rebase here   gch84kz3 HEAD@{22}: rebase -i (fixup): <the new Comment> //unit action of the rebase: one fixup here   op84kz3 HEAD@{23}: rebase -i (start): checkout refs/remotes/<remote name>/<branch name> //I started an interactive rebase for the current branch   sa5paz5 HEAD@{24}: checkout: moving from <branch name> to <branch name> // I just checkout a new branch here   In this example, you would want to choose sa5paz5 as it is before the start of the rebase.  edit: It occurred to me that I might have wrote a bad example for what a rebase looks like in the reflog. However, I'm sure you can understand that you need to reset to the ref right before the word ""rebase"" :)"
git,3cc94r,beez_beez_beez,3,Mon Jul 6 22:53:13 2015 UTC,"ahh  okay, I see. Thank you!"
git,3cc94r,a_falsity,2,Mon Jul 6 22:59:55 2015 UTC,I can't count how many times got reflog has saved me. I'm surprised how few people know/use it.
git,3cail5,NOT_EVER_sarcastic,4,Mon Jul 6 11:34:43 2015 UTC,It sounds like you are using some kind of server-side security that imposes a rule that the pusher and committer must be the same person. This is nothing to do with Git. What server program are you using? Gerrit?
git,3cail5,DanLynch,1 point,Mon Jul 6 11:52:23 2015 UTC,"You're right, this is coming from the server, which I think is Gerrit. How do I get information about the server?"
git,3cail5,jakkarth,3,Mon Jul 6 12:10:46 2015 UTC,Ask your server administrator?
git,3cail5,jakkarth,2,Mon Jul 6 12:13:52 2015 UTC,"Also, this answer may be useful if you just want to alter the commit in question to have your author information instead of what was already there. Moral implications of this are left as an exercise for the reader."
git,3cail5,jakkarth,1 point,Mon Jul 6 12:15:35 2015 UTC,"I was following those instructions, but during the interactive rebase I started getting troublesome conflicts which had nothing to do with the author.  Surely git can query the server version and display it?"
git,3cail5,jakkarth,2,Mon Jul 6 12:21:54 2015 UTC,"Without knowing what errors you're referring to I'm not sure how to advise you. That procedure is the easiest way I know of to alter the author of a historic commit, and should not result in any conflicts at all since you aren't changing the content of the commit.  Git could possibly tell you which version of the git transfer protocol the remote end of the connection is running, but getting information about other software besides git running on the remote host would be a potential security flaw and is not supported."
git,3cail5,jakkarth,0,Mon Jul 6 12:26:51 2015 UTC,"what errors you're referring to I'm not sure how to advise you.    I don't think you want to see my specific merge conflicts. Merging my branch with the master didn't produce any conflicts (because I used strategy=ours), but when I tried to change the author of the earlier commit, merge conflicts appeared during the interactive rebase.  I think what I need to do is go back and retry the merge with master, but exclude the commit with the mismatching author. Does that sound like a sensible strategy?"
git,3c6p4l,knolspeak,1 point,Sun Jul 5 10:26:59 2015 UTC,"It may be worth considering changing the instructions to manually pull ""AVH git-flow."" It's actively maintained and has tons of fixes compared to the ""official"" release.  https://github.com/petervanderdoes/gitflow"
git,3c0joy,musicomet,2,Fri Jul 3 17:42:05 2015 UTC,Here's what I did:  git checkout feature-branch git pull --rebase origin develop-branch   Then I get one conflict after another on the same file!  Why is that?   Why wouldn't there be conflicts? How far back is their most recent common ancestor commit?
git,3c0joy,pi3832v2,2,Fri Jul 3 18:47:00 2015 UTC,"Have a check at ""git rerere"", I've never used it but its purpose seems to solve your exact problem."
git,3c0joy,sfrigon,1 point,Fri Jul 3 19:53:14 2015 UTC,"git rerere is applicable to the same exact conflict. The conflicts I'm getting are unique, however, I'm getting a conflict on every single commit I made to the feature-branch.  I've edited the question."
git,3c0joy,rsaxvc,1 point,Mon Jul 6 16:29:15 2015 UTC,Did you do something silly like change line endings?
git,3c0joy,HowIsntBabbyFormed,1 point,Fri Jul 3 23:18:55 2015 UTC,Why not just:  git checkout feature-branch git rebase develop-branch
git,3c0joy,lucaslos,1 point,Fri Jul 3 23:57:51 2015 UTC,I always avoid use rebase at all. =/
git,3c1bay,Guthe,5,Fri Jul 3 21:15:45 2015 UTC,"Could it be that you are just not scrolling down? Try using the git shortlog command also, to see if more commits appear."
git,3c1bay,chrisb8,5,Fri Jul 3 21:29:45 2015 UTC,Hit the spacebar?
git,3c1bay,pi3832v2,3,Fri Jul 3 22:17:47 2015 UTC,try: git log --oneline do you see more?
git,3c1bay,scottchiefbaker,3,Sat Jul 4 02:44:10 2015 UTC,"By default, git log and several other git commands use the less pager. You can move around with the arrow keys, or with the space bar to move a page at the time. You can quit by pressing q, and scroll to the end by pressing Shift-G.  If you want to confirm whether it's the pager, try running git --no-pager log instead, which should dump everything all at once and be overwhelming."
git,3c1bay,ldpreload,1 point,Sat Jul 4 04:06:46 2015 UTC,I think this is common when uploading to Github for me personally a bunch of my commit's over 100+ have not been documented on github but they have been stored on my git. It's really weird but I think it has to do with your git's global settings. Try editing those and see what happens. Are you using your own private git server or using a repo from github?
git,3c1bay,BigBoss424,1 point,Sat Jul 4 03:38:53 2015 UTC,"Huh, that's odd. Are you pushing after you commit, and do you get an error message when you push? Are you pushing the branches you think you're pushing?  Maybe take a look at git branch -a, to see all your local branches as well as what your local repo thinks all the remote branches look like. You can then run git log on any of those names."
git,3bxsj7,ccharles,6,Fri Jul 3 01:10:10 2015 UTC,Later this year the git-for-windows project is scheduled to replace msysgit as the official Git release for Windows. Preview releases are now available.  Those of you on Windows who want a release that's newer than the 1.9.5preview that's officially available should check out git-for-windows.
git,3bym4m,destraht,12,Fri Jul 3 05:42:26 2015 UTC,"cgit or gitweb. I think git itself embeds gitweb, so you can start a local webserver with a simple git web xxxx command.   Should it also present the same exploitability than phpmyadmin? (tired of probes in my web server logs- no guys, I do not run it)"
git,3bym4m,koalillo,7,Fri Jul 3 06:57:05 2015 UTC,"Oh, it's git instaweb:  http://git-scm.com/docs/git-instaweb"
git,3bym4m,koalillo,2,Fri Jul 3 06:59:15 2015 UTC,https://github.com/FredrikNoren/ungit is pretty nice imo
git,3bym4m,odiouslol,2,Fri Jul 3 16:50:20 2015 UTC,"Does it have to be browser based? Does it have to be clunky?  Atlassian's SourceTree is IMO the best graphical git client on the market right now. It's not quick and dirty, it's fully featured. But it's not heavyweight, either."
git,3bym4m,ratbastid,1 point,Fri Jul 3 13:02:27 2015 UTC,Does it have to be clunky?   I don't want to get my hopes up too much.  I'm on Linux but it looks pretty good.
git,3bym4m,Jack126Guy,1 point,Fri Jul 3 15:15:01 2015 UTC,"It's not browser-based, but try gitk."
git,3bym4m,srenatus,5,Fri Jul 3 06:39:46 2015 UTC,And tig (screenshots)
git,3bym4m,pi3832v2,1 point,Fri Jul 3 07:23:02 2015 UTC,From Git – GUI clients:   Git comes with built-in GUI tools for committing (git-gui) and browsing (gitk) but there are several third-party tools for users looking for platform-specific experience. (more…)
git,3bym4m,beosman,1 point,Fri Jul 3 10:43:39 2015 UTC,You can also try Gogs.
git,3bym4m,ahandle,1 point,Fri Jul 3 11:09:18 2015 UTC,"Try GitBucket:   The default administrator account is root and password is root.  You can start GitBucket by 'java -jar gitbucket.war' without servlet container. In this case, GitBucket URL is http://[hostname]:8080/. You can specify following options:   --port=[NUMBER]  --prefix=[CONTEXTPATH]  --host=[HOSTNAME]  --gitbucket.home=[DATA_DIR]   To upgrade GitBucket, only replace gitbucket.war. All GitBucket data is stored in HOME/.gitbucket. So if you want to back up GitBucket data, copy this directory to the other disk.   Copy or clone the repo into ~/.gitbucket and away you go."
git,3bym4m,btgeekboy,1 point,Fri Jul 3 15:19:52 2015 UTC,"If you don't feel like configuring anything, you might consider creating a private repo on BitBucket and pushing everything to there. Boom, instant web UI."
git,3bym4m,unkz,1 point,Fri Jul 3 16:07:11 2015 UTC,I do that with my open source base but the special sauce is local only and is encrypted and mailed away for backup.
git,3bxor5,musicomet,1 point,Fri Jul 3 00:35:09 2015 UTC,My changes don't show up on the develop branch.   What exactly do you mean by this?
git,3bxor5,jakkarth,1 point,Fri Jul 3 00:53:14 2015 UTC,I want the changes I made to the feature branch to show on the develop branch after rebasing.
git,3bxor5,jakkarth,1 point,Fri Jul 3 01:12:57 2015 UTC,"If you are on the feature branch, and you run git pull --rebase origin develop is going to get the changes made to the develop branch on github and apply them to the feature branch on your local machine, leaving the develop branch in the local machine completely untouched. develop in that command line is not a destination, it specifies which branch on the remote to use.  If you want to modify the develop branch in your local repository, you need to be on that branch before you run the pull command."
git,3bxor5,Jack126Guy,1 point,Fri Jul 3 03:16:30 2015 UTC,"EDIT: Ignore this entire answer, because my knowledge of git pull escaped me.  The command git pull --rebase rebases the changes from Github onto your local develop-branch the changes from your local develop-branch (if any) onto the changes from Github. It doesn't do anything with feature-branch.  To rebase your features:  git checkout feature-branch git rebase develop-branch   Forgive me if I misunderstood the situation."
git,3bwda8,hunkeelin,4,Thu Jul 2 18:18:18 2015 UTC,"You have to give us the commands you ran... you cannot commit changes you didn't stage.  That's fairly fundamental to how git works.  You might have hit a CRLF conversion issue though if you have ""extra"" lines in your commits."
git,3bwda8,untitleddocument37,2,Thu Jul 2 18:25:10 2015 UTC,"""Git – the simple guide"" is available in deutsch, español, français, indonesian, italiano, nederlands, polski, português, русский, türkçe, 日本語, 中文, 한국어 and Vietnamese.  Check it out at: rogerdudler.github.io/git-guide."
git,3bwda8,pi3832v2,1 point,Thu Jul 2 19:14:00 2015 UTC,"If you're attempting to say 'How do I look at my repository's history?', then you can use git log to view your commits, and git diff <commit_hash> to view the changes."
git,3bwda8,cpbills,1 point,Thu Jul 2 19:04:59 2015 UTC,"git diff   I typically use GitExtensions or some similar gui when I want to view changes.  But what I would do if I were you:  git branch workingbranch git checkout workingbranch   ...because you can then switch back to the master branch if you find the need. You should develop the habit and practice that no commit ever happens in master. You merge into master. Master represents a known good state. (I.e., what is deployed.)"
git,3bwda8,forlasanto,1 point,Thu Jul 2 23:04:36 2015 UTC,Thanks that's what i am looking for.
git,3bsurg,alexwagner73,5,Wed Jul 1 21:35:45 2015 UTC,"In general, git won't really care if you are moving the SAME binary around. However I'd warn you that git handles binaries poorly in  that it generates hashes of the repo, branches, etc as a core function. If you have a huge amount of data, it will not require a lot of CPU and memory. I've worked with some 20GB+ size repos and they would bring fairly beefy systems to their knees when it came time to recalculate the hash of a particularly troublesome branch. There are some extensions to get around it, like git-fat   Git would not be the right tool for personal storage. It's great for code development, but if you're looking to keep your family photos safe, I'd suggest amazon."
git,3bsurg,techie1980,3,Thu Jul 2 04:49:24 2015 UTC,You might want to look into using git-annex
git,3bsurg,aeontech,2,Thu Jul 2 16:48:09 2015 UTC,"Git detects when files are moved, so it will not add another object for identical file contents. So, if the files are not edited often, then you should not have a problem."
git,3bsurg,Jack126Guy,0,Wed Jul 1 22:02:05 2015 UTC,Make sure to use git mv though.
git,3bsurg,NathanJang,6,Wed Jul 1 22:16:36 2015 UTC,No. That doesn't matter at all. You can just equivalently re-add the file at some other path.
git,3bsurg,avar,1 point,Wed Jul 1 22:25:49 2015 UTC,Hmm. It shows up as removed and new file for me. Maybe I'm wrong. Or maybe it happens when I move a file and change it at the same time. :P
git,3bsurg,NathanJang,9,Wed Jul 1 23:08:51 2015 UTC,"Git has a heuristic for determining which operations were renames. The heuristic is used for ""git status"" and ""git log"", but the actual rename operation is not stored with the commit. Running ""git mv a/file b/file"" is just a convenient shorthand for ""cp a/file b/file && git add b/file && git rm a/file"""
git,3bsurg,starkinth,2,Wed Jul 1 23:26:12 2015 UTC,TIL. Thanks for that :)
git,3bsurg,NathanJang,1 point,Thu Jul 2 02:19:41 2015 UTC,where git-rm is again a shorthand. another way to put the commands in use is mv a/file b/file && git add -A a/file b/file.
git,3bsurg,Nevik42,2,Thu Jul 2 07:04:21 2015 UTC,"Yep, that's another good way to do it"
git,3bsurg,starkinth,1 point,Thu Jul 2 20:53:19 2015 UTC,"The status shows that.  When you actually commit, Git figures it out.  See my example."
git,3bsurg,pi3832v2,2,Wed Jul 1 23:16:48 2015 UTC,"The reason why git doesn't duplicate object when you move them by the way (I noticed no one mentioned the why in this thread) is that git stores the file name/path in a different location than the contents of the file itself. So when you move a file, it updates the path in the commit, but it still refers to the same binary blob as the previous commit."
git,3bsurg,unhingedninja,1 point,Thu Jul 2 02:36:36 2015 UTC,"To be pedantic ... the tree objects get updated as part of a move, commits always change solely because tree objects change (and they change because tree/blob objects change)"
git,3bsurg,untitleddocument37,2,Thu Jul 2 10:25:33 2015 UTC,"One downside to keep in mind is that you'll always have two copies, one in the .git directory and one in the working copy. Consider something like git-annex, which was specifically built to handle binary files."
git,3bsurg,toupeira,1 point,Thu Jul 2 02:46:13 2015 UTC,That's only true for non-bare repos
git,3bsurg,starkinth,2,Thu Jul 2 20:56:26 2015 UTC,"As others said,it will work. Still, don't put binary files in git!"
git,3bsurg,musicmatze,1 point,Thu Jul 2 10:11:53 2015 UTC,"Yep. You can test this pretty easily too, just make a commit, move some files, make another commit, repeat a dozen times and check the size of the .git folder."
git,3bsurg,jakkarth,1 point,Wed Jul 1 22:04:42 2015 UTC,"AFAIK, files are identified and stored based on a checksum-like hash.  You can move them, you can rename them, as long as their contents don't change, Git won't duplicate them.    $ mkdir hash-test $ cd hash-test/ $ git init Initialized empty Git repository in ~/hash-test/.git/  $ mv ~/Desktop/Screen\ Shot\ 2015-07-01\ at\ 5.58.01\ PM.png ./ $ git hash-object Screen\ Shot\ 2015-07-01\ at\ 5.58.01\ PM.png  50716c11b6b40d115ced9711fd8dd57cf0c59403  $ mv Screen\ Shot\ 2015-07-01\ at\ 5.58.01\ PM.png screen-shot.png  $ git hash-object screen-shot.png  50716c11b6b40d115ced9711fd8dd57cf0c59403  $ mkdir sub-directory $ mv screen-shot.png sub-directory/ $ git hash-object sub-directory/screen-shot.png  50716c11b6b40d115ced9711fd8dd57cf0c59403  $ git add . $ git commit -m ""foo"" [master (root-commit) 674087b] foo  1 file changed, 0 insertions(+), 0 deletions(-)  create mode 100644 sub-directory/screen-shot.png  $ mv sub-directory/screen-shot.png ./ $ git status On branch master Changes not staged for commit:      deleted:    sub-directory/screen-shot.png  Untracked files:      screen-shot.png  no changes added to commit (use ""git add"" and/or ""git commit -a"")  $ git add . $ git commit -m ""bar"" [master 329fe14] bar  1 file changed, 0 insertions(+), 0 deletions(-)  rename sub-directory/screen-shot.png => screen-shot.png (100%)  $ du -hs .git/ 400K    .git/  $ ls -lh total 704 -rw-r--r--    351K Jul  1 17:58 screen-shot.png drwxr-xr-x     68B Jul  1 18:09 sub-directory     Git automatically figured out that the file had been moved/renamed, and didn't duplicate it."
git,3bsurg,pi3832v2,1 point,Wed Jul 1 22:55:55 2015 UTC,"Git doesn't care what types of files they are, and Git doesn't care about moving files, only the data. If you move, copy or rename a file Git doesn't care."
git,3bsurg,felipec,1 point,Thu Jul 2 03:05:48 2015 UTC,"You could give more information about the binary files. Is the repo going to be only binary files? How many? How big? In general git will do just fine with some small rarely edited binary files, like icons, and images for web development projects. But look into something else, like git-annex or syncthing, if you're not going to be keeping any source code in the same repository."
git,3bpsa6,Bbentley1986,5,Wed Jul 1 04:17:27 2015 UTC,"I presented at Dreamforce last year on versioning and deploying Salesforce metadata using Git: https://www.youtube.com/watch?v=pA-7jqklxSU  Atlassian's internal Salesforce dev team also maintain a sort of cookbook for continuous development here: https://developer.atlassian.com/display/SFDC/Atlassian+Cookbook+for+Collaborative+Salesforce+Development  Full disclosure: I work at Atlassian and the materials I linked to above use our tools. You don't have to use our stuff though, the general ideas will mostly work for other git hosting & CI/CD tools as well.  Hope this helps!"
git,3bpsa6,kannonboy,1 point,Wed Jul 1 19:45:16 2015 UTC,Awesome. Thank you for sharing!
git,3bpsa6,l4than-d3vers,2,Thu Jul 2 21:58:21 2015 UTC,"What is a ""SalesForce environment""?  I actually use salesforce.com in the company I work for but I still have no idea what you mean."
git,3bpsa6,kaaskop42,1 point,Wed Jul 1 16:04:35 2015 UTC,As in our organizations entire dev/uat/prod configuration.   config files deployments versions add-ins etc.
git,3bpsa6,DanLynch,1 point,Thu Jul 2 22:02:00 2015 UTC,"I think you should be looking at configuration management tools such as Chef, Puppet, Ansible or Salt."
git,3bpsa6,bigrodey77,2,Wed Jul 8 07:41:04 2015 UTC,"The purpose of Git is to help you track changes to structured plain text files over time and across alternatives. If that's what you want to do, you will find that Git is very powerful. If what you want to do differs from that, you will find Git less useful to the extent of the difference."
git,3blymp,rorriMnmaD,20,Tue Jun 30 08:07:08 2015 UTC,"Really, it's fine.  A linear history is usually better for later review.  It's simpler, more bisectable, and that's why historically the lack of good branching hasn't been a big limitation in older version control systems.  Branching matters when you're working on multiple features at the same time.  The Big Huge Need for branching arises when you have multiple programmers, but it can be useful to a single person if you have a development/maintenance split, or you like jumping around to avoid boredom.  (I tend to accumulate bandoned branches for things I started doing and gave up on because they grew in scope too much.)  A related thing that leads to branching on single-developer projects is multiple customer support.  If you customize something for customer A, maybe you first think it's something stupid you don't want to merge into mainline.  But maybe later you think of a nice way to turn it into a generally useful and supportable feature.  But the point is that you branch when you have to.  When the alternative is worse.  With a single developer, even if you branch temporarily, you can often linearize history by rebasing.  The thing that forces branching is that you don't want to rebase after release.  Everyone who pulls from you has to rebase too, and it quickly becomes a mess fighting over whose changes go into the history first.  There's a level of publication at which you stop doing that and have branches."
git,3blymp,cypherpunks,5,Tue Jun 30 08:47:58 2015 UTC,"I incorporated branching in a minesweeper game I had to program.  I had an initial state of the game: a grid, some buttons. Click on a button, a mine appear (or not). This was my master branch.  I had a set of functionality I had to add, here are a few:   Program the Win/Lost logic Being able to start a new game without closing the software Programming the cascading effect when you click on an empty location to reveal all adjacency areas. Implementing custom game settings Implementing the right click (flag) etc.   Okay, well I wanted to work on the right click first because it sounds easy.   From Master  git checkout -b RightClick   I started working on it, did a few commit, then I got bored. I want to work on the custom game settings!   git checkout master  git checkout -b customSetting   All my branches are independent from each others, I can easily work like that. Let's say I had the custom settings done to a point where it's not 100% over, but I'm satisfied with it and it work. I'll then merge it back to master.   git checkout master  git merge customSetting   Since I'm working solo, I don't truly care if I force push some changes on my repo, so at that point I'll go back to my RightClick branch and rebase master to get a linear history. Although, since I was working alone, the history was pretty linear, now it's straight out flat. :P  TL;DR: You can use branch to work on independent features on the fly, whenever you like. You start working with feature A, then got bore? You can easily switch to feature B or C."
git,3blymp,Kraigius,1 point,Tue Jun 30 14:12:08 2015 UTC,Thanks for writing out an actual example!  It helps to see how others process problems
git,3blymp,mus1Kk,1 point,Wed Jul 1 04:49:03 2015 UTC,"Keep in mind that this depends on your project. If it is small, chances are that many parts are related to each other, making merging the branches together a nightmare. Even if you can divide them up into modules, refactoring can cause issues."
git,3blymp,pi3832v2,4,Wed Jul 1 09:08:39 2015 UTC,"Currently, everytime I start on a new feature, or logical set of features, I git checkout -b new_branch_name, work on them (sometimes I abort at this stage and reset to head)…   Personally, I occasionally keep a failed branch around for awhile as a sort of reference, or from which to do a cherry-pick, because there are bits and pieces of it that I want to use in other, ultimately successful, branches.  In the end, the advantages of branching are more cognitive than procedural, and therefore may not be readily apparent in the final history.  Branching should give you the mental freedom to ""code with wild abandon""; it should allow you to find the right way to do something by first doing it the wrong way; it should let you mine your wonky ideas for the nuggets of genius hidden in them; etcetcetc.  My advice is: stop resetting to HEAD for awhile.  Leave your failures lying about.  If there aren't a lot of them, ask yourself why you aren't being more innovative, why you aren't learning new things, and why you think your time is best spent simply churning out the same old code.  Or not.  Caveat emptor."
git,3blymp,robertmeta,3,Tue Jun 30 10:45:00 2015 UTC,"One long list of commits is perfectly fine, it is actually something bigger projects strive for and would love to have.  A lot of the reason to rebase and squash is to have that clean history.   Branching is nice (even solo) when you are doing some long task and need to be able to make progress on both master and the branch."
git,3blymp,camponez,6,Tue Jun 30 08:44:01 2015 UTC,I like to use gitflow. Every feature and fix has a merge commit. This is useful if I want to remove it in just one revert.
git,3blymp,noratat,1 point,Tue Jun 30 12:35:56 2015 UTC,"I like to use gitflow   wow, gitflow is really awesome!  I wish I knew about this sooner"
git,3blymp,Synes_Godt_Om,1 point,Wed Jul 1 07:38:56 2015 UTC,"For small personal projects it's fine, but teams should have automated infrastructure in place that makes it redundant (eg if master is automatically tested, what's the point in having a develop branch? Releases should be separate / tagged anyways.)  In general for single person projects, I wouldn't expect much branching. Trying to work on too many things at once will cause problems regardless of whether you use branches or are working alone."
git,3bjis4,goomyman,1 point,Mon Jun 29 19:07:06 2015 UTC,Skip history changes? Can you explain what the end result you want would be as you did with your first example?
git,3bjis4,jakkarth,1 point,Mon Jun 29 19:11:17 2015 UTC,"I just want the list of changes starting from the old head.    I am now wondering if ORIG_HEAD will work. -- Edit,  it does not.   I only want to see changes 6 7 8 9 in my rebase because those are the ones I can squash / merge etc."
git,3bjis4,jakkarth,1 point,Mon Jun 29 20:24:05 2015 UTC,I'm still not sure I entirely understand what it is you're looking for. The merge commit will have two (or more) parent commit hashes if you want to see each side of things before the merge occurred. Git rebase -i will allow you to to reorder and then squash commits as you like.
git,3bjis4,kaaskop42,1 point,Mon Jun 29 20:30:07 2015 UTC,git rebase 6 9 --onto A
git,3bjis4,rvndps,1 point,Mon Jun 29 20:44:52 2015 UTC,"Thanks for the help everyone.  I guess my question made no sense because the build was totally busted due to a forced rebase.  In this case,  I just had to merge the changes until I got to where I wanted to be.  Someone commited the sin of rebasing pushed files,  so no matter what I did it would compile."
git,3bif46,SofaSurfer14,6,Mon Jun 29 14:08:24 2015 UTC,Add your large file name to your .gitignore file
git,3bif46,withremote,2,Mon Jun 29 14:18:26 2015 UTC,"stackoverflow.com/questions/4035779/gitignore-by-file-size  Spoiler: there is no direct way, but you can use other utilities to add files to .gitignore based on file size."
git,3bif46,pi3832v2,1 point,Mon Jun 29 14:21:39 2015 UTC,"If you're looking to remove large files that are already in your repo, you'll probably need the BFG Repo Cleaner: https://rtyley.github.io/bfg-repo-cleaner/"
git,3b6nuf,HS8290HS,6,Fri Jun 26 12:07:46 2015 UTC,Clicked expecting the equivalent of a cherry-pick. Completely misleading title.
git,3b6nuf,jakkarth,4,Fri Jun 26 12:14:59 2015 UTC,"Well, not entirely true since he even notes at the bottom that this will push all commits up to and including the commit specified."
git,3b6nuf,logickal,-1,Fri Jun 26 12:13:35 2015 UTC,I guess instead of single i should use specific commits Sorry BAD in English :(
git,3b1ldb,srenatus,1 point,Thu Jun 25 05:58:38 2015 UTC,"Does anyone know of similar projects? Metrics dashboards generally seem to focus operations, none of them feature per-revision data..."
git,3b23ml,blackrat47,3,Thu Jun 25 10:14:32 2015 UTC,"If you're using a *nix OS, there's incrontab, which is like crontab, except that it's triggered by filesystem changes, instead of a time schedule.  Set up that to monitor for the file changing, then call rsync or summat to copy it into the Git repository, and stage it.  E.g.: manpages.ubuntu.com/manpages/trusty/man5/incrontab.5.html."
git,3b23ml,pi3832v2,1 point,Thu Jun 25 16:15:09 2015 UTC,"It sounds like it would need to be a pre-commit hook.   One possible solution that probably won't work here would be to make a symlink on the other file location. So wherever the non git repo location is, turn that into a symlink to the git repo's copy. This works when the other file is changed but if it is deleted and rewritten (which I would guess to be the case here) then this won't work. This is the solution I use for things like dotfiles (since I don't want a git repo in my home directory).   A hard link would have the same issue that the symlink would have - deleting and recreating a file means that hard link doesn't exist anymore."
git,3b23ml,az4z3l,1 point,Thu Jun 25 14:29:21 2015 UTC,"Yeah, that's what I found with hardlinks :/ I tried the pre-commit but it just didn't do anything, I'm not really sure why. Do you need to do anything more complicated than just sticking an executable file with a reasonable shebang in the ./.git/hooks folder and calling it pre-commit?"
git,3b23ml,ahref,1 point,Thu Jun 25 15:16:42 2015 UTC,Could you make the generator put the file in the repository?
git,3b23ml,ahref,1 point,Thu Jun 25 15:12:13 2015 UTC,"I could do, but then it would also put the bib files of all of my other projects in there as well, which isn't what I want."
git,3azlet,btcspry,1 point,Wed Jun 24 19:48:35 2015 UTC,"I'm a bot, bleep, bloop. Someone has linked to this thread from another place on reddit:   [/r/github] Trying to Push, Giving Key Error [x-post: git]   If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads. (Info / Contact)"
git,3azlet,TotesMessenger,1 point,Wed Jun 24 20:03:29 2015 UTC,"What is origin, do you have an ssh key for it, and is your public key on that host? If origin is some.host.com:foo/bar.git, what happens when you type ssh some.host.com? Can you connect?  Long story short; your problem is ssh keys not being configured or set up properly."
git,3azlet,cpbills,1 point,Wed Jun 24 20:04:41 2015 UTC,"But what would have unconfigured them, and how do I reconfigure them?  They were working fine.  I'm rather new to git, so please forgive me."
git,3azlet,thescientist13,1 point,Wed Jun 24 20:39:16 2015 UTC,"If you ever regenerated your public key, it would invalidate all clients you've used it with.  Also, do you have access to the same account for both repos?  You can also just to look in your Github account and make sure the public key there matches the one on your local machine."
git,3azlet,thescientist13,1 point,Wed Jun 24 20:48:29 2015 UTC,"I haven't regenerated the public key.  I own both repos under the same account.  I have pushed to both of them before, but now only one of them is working.  How do I look in my GitHub account?  Where is that option located?"
git,3azlet,thescientist13,3,Wed Jun 24 20:54:43 2015 UTC,Here are their docs.  Step 4 covers uploading a key https://help.github.com/articles/generating-ssh-keys/
git,3axgdl,lgiordani,2,Wed Jun 24 07:39:00 2015 UTC,What's the advantage over this than using regular branching methods?
git,3axgdl,Triptcip,2,Wed Jun 24 10:15:58 2015 UTC,"I think the advantages are the same of gitflow itself. You get a clean set of commands to work with features, which is something that helps me to keep order in my work. I also like the publish shortcuts to share features with others. Obviously it is just a matter of personal preference (I think)."
git,3anwro,__baxx__,3,Mon Jun 22 01:39:16 2015 UTC,"The closest ""tutorial"" that I can come up with is the git-game, which is basically a intra-repository treasure hunt that tests one's Git prowess. However, be forewarned that it is by and large a ""teach yourself"" game that tries to cover more obscure commands and hang-ups within the Git program.   If you're really adventurous, try out the second edition--it's esoteric, to say the least!"
git,3anwro,SpyCat811,1 point,Mon Jun 22 02:09:14 2015 UTC,"In a very similar fashion, there is also GitHug."
git,3anwro,b0xors,3,Tue Jun 23 01:12:55 2015 UTC,"Not command line based, but this is a good one: http://pcottle.github.io/learnGitBranching/"
git,3anwro,__sprinkles,2,Mon Jun 22 14:41:38 2015 UTC,"There's try.github.io by GitHub. It's an online course which focuses on GitHub, but it's interactive and it's a tutorial for Git."
git,3anwro,memoryspaceglitch,2,Mon Jun 22 07:17:32 2015 UTC,"cheers - i was after something a little more involved than that, but without all the theory that comes with Pro Git or something like that.   Maybe there's nothing out there, maybe it wouldn't really translate to a vimtutor esque tutorial anyway!   cheers :)"
git,3anwro,memoryspaceglitch,1 point,Mon Jun 22 11:30:43 2015 UTC,"I really think it could be done, and it'd be awesome if someone made one. Code School's git path begins with the Try Git-course and continues with Git Real (1 & 2) and a Mastering GitHub course. Since Code School charge for their courses I haven't really tried these out but if nothing else it's some kind of proof that the concept is doable :)"
git,3anwro,rickumali,2,Mon Jun 22 17:34:31 2015 UTC,"yeah I don't really want to pay for one.   VimTutor as a format is great. The site Think like a Git is cool for a boiled down theoretical look into Git (even though there are quite a few i'll do this later notes in it...) , but I'm surprised how there isn't something comparable for using Git past making ones first Repo or whatever.   I'll learn by doing - I'm aware that I can just make a repo and try things out (obviously!). But having a straight up guide for it would be pretty neat.   hey ho, maybe someone will write one up, who knows :)"
git,3anwro,a_dog_and_his_gun,1 point,Mon Jun 22 17:40:15 2015 UTC,"""Learn Git in a Month of Lunches"" is a book about Git in tutorial format."
git,3aishx,Godspiral,2,Sat Jun 20 16:28:19 2015 UTC,"related question, is there a way to use a single file from another git repository in a project?  Basically, consider a programming language like C, where stdlib is a file included by other library files.  A whole set of libraries rely on stdlib, and then hierarchically, other libraries rely on those intermediate libraries loading stdlib themselves.  The only thing you need to not screw up all of these libraries being in the same folder is to not name new files stdlib.c"
git,3aishx,unkz,3,Sat Jun 20 16:32:16 2015 UTC,"No, not really.  Maybe check out the other repo as a submodule and symlink it?"
git,3aishx,coffeesleeve,1 point,Sat Jun 20 16:39:18 2015 UTC,git submodule
git,3aishx,coffeesleeve,1 point,Sun Jun 21 01:06:03 2015 UTC,"from what I've read, git subtree would be a more robust and simpler alternative"
git,3aishx,clermbclermb,1 point,Sun Jun 21 01:38:37 2015 UTC,I think you're right. Thanks
git,3aishx,clermbclermb,1 point,Sun Jun 21 01:52:02 2015 UTC,Does your software/platform support versioning?  Something like library2  v0.0.2 requires library1 version 0.0.5; and application1 requires library2 0.0.2.  You may want to look at semantic versioning since you think the library should stand on their own.  Also should look at possibly using some sort of package management for the individual versions of the libraries.  This isn't the 'how to use git to solve the problem'  answer but it may be a bit of overkill to use git here.
git,3aishx,unkz,1 point,Sun Jun 21 01:57:24 2015 UTC,"library 1 will try very hard to not break code that depends on it.  Improvements in library 1 are likely desired by its dependents.  The apps is a database, library2 is a GUI framework, and library1 is a type system (math).  Improvements in the type system, make the GUI framework more powerful, and the GUI framework can make the app prettier.   This isn't the 'how to use git to solve the problem' answer but it may be a bit of overkill to use git here   I'm leaning towards a manual approach to 3 independent git projects.  git basically becomes the publishing platform.  Is there a name for manually copying the same file into 2 or more repos?"
git,3aishx,unkz,1 point,Sun Jun 21 02:17:46 2015 UTC,"Is there a name for manually copying the same file into 2 or more repos?   'mistake'.  It becomes a nightmare to maintain the code like that over time; hence why people look at submodules or subtrees.  You could also approach this as a build-system problem as well, where your build script takes care of grabbing the repo for library1, building it, then grabbing the repo for library2, building it (with the results of the first build); then building the application."
git,3ako9y,q5sys,18,Sun Jun 21 03:30:27 2015 UTC,"Total clickbait title (the talk itself).  ""commits closest in time to a check-in""- Time should be of nearly zero importance. History is much more useful in tracking functional evolution, not temporal iteration. He indicates that when tracking down a bug (in a branch) you might be interested in what's going on on other branches around the same time. That sounds completely ludicrous to me. You might as well ask when bugs were being investigated in a completely separate project but at the same time.   Automatically push? Insane. I'm constantly rebasing, squashing, moving stuff around, and (temporarily) completely breaking the entire system while I'm off  overhauling a codebase to add a new feature.  Git may be hard to use but I haven't come across anything better, and the complaints levied in (part of) this talk seem to show a slight misunderstanding of the git design. Most things the speaker wanted git to do better were things I couldn't understand why you'd want to being with. For example, ""given a commit, what branch was it a part of?"" Why would you need that? A branch is just a handy pointer to a commit. There's no need to keep the pointer around; the commit is the thing you're interested in. If you're looking to branch names to understand something about the commit, you've failed to provide proper commit messages. Then again, focusing on temporal history instead of functional history may show how this guy is completely misusing the system.  Slicing? How would your VCS know about inter-dependencies between files located in different subdirectories (his ""slices"")? Again, this is insane. If the subdirectories can actually be used independently, then there's no reason they should be in the same repository.  ""Why can't I just get the current state of the code? Why do I need to get the entire history?"" Well there's shallow clones, but... without all the history, all clones aren't equal. Now you've got some central location which actually has everything. You're back to SVN. It's exactly that garbage model which git improved on.  I'm open minded to better tools but this talk is garbage."
git,3ako9y,artard,3,Sun Jun 21 04:07:50 2015 UTC,"Git is good as it is. Its simplicity is the perfection. Half of things he wants git to do should not be Git's concern. The quotes he gives about how hard git is are bad argument. Some things are supposed to be hard to learn just because they are doing things properly, and are different from what people used to. Vi is a good example of that for text editing. Vi is forever, and so is git.  It seems like he has been using svn for too long to want slices.  Edit: so I looked more into Fossil. And I repeat my sentiment - it looks like something that would be easier to learn after using svn. Built in wiki and ticket tracking (and web interface) sure do look nice. But I would not call Fossil simple, exactly because it has all those things built in. Git is simpler because it only does a very few things at its core. Furthermore, because git is simple, it is easy to extend its functionality. And I would argue, that is what helped to create a huge git ecosystem with numerous tools (github, bitbucket, git-annex etc)."
git,3ako9y,bearrus,5,Sun Jun 21 05:30:54 2015 UTC,"It seems like he has been using svn for too long to want slices.   I imagine the version control system he uses is Fossil, considering that he wrote Fossil."
git,3ako9y,adrianmonk,2,Sun Jun 21 07:02:51 2015 UTC,"Git is the worst (D)VCS, except for all the others."
git,3ako9y,Resquid,1 point,Sun Jun 21 22:53:18 2015 UTC,"The quotes he starts the lecture with are weak.  I taught myself Git by reading the man pages and that's probably the difference between him and me.  I can read manpages.  comments   slide 14.  Sorting by time is pointless.  I only look at timestamps to figure out the context of a commit as in ""that was in July when we were doing ...."" slide 16, I don't need to ""keep track"" of remote head/etc... that's what the git tool does for me. slide 18, use --no-ff, bisect your feature branch not mainline if that's what you want.   It really seems like he's finding non-important ways to dis git and he misses really important ones (binary files for instance).    Solving the ""what are the children of a commit"" ... uh you can find out what branch it's on fairly easily.  I wrote a macro called ""ghas"" which tells me all of the branches that own a commit.    Basically, he doesn't know how to use Git and is trying to dis it and will likely be selling his wares in a future blog post..."
git,3ako9y,untitleddocument37,1 point,Mon Jun 22 16:37:37 2015 UTC,"that's probably the difference between him and me. I can read manpages.  Basically, he doesn't know how to use Git and is trying to dis it and will likely be selling his wares in a future blog post...   Richard Hipp is the creator of SQlite.  I'm pretty sure he knows how to read man pages.  He's not some shady character who is trying to scam people for a quick buck."
git,3ako9y,untitleddocument37,1 point,Mon Jun 22 20:09:06 2015 UTC,"I dunno, I read the fossil website and many of his comments about git are just off base."
git,3ako9y,Resquid,1 point,Mon Jun 22 23:58:17 2015 UTC,"hahaha, what a troll of a talk title."
git,3afubp,ThePiGuy2,10,Fri Jun 19 20:11:02 2015 UTC,"Nope.  It is easier to squash multiple commits than the try to split up overly big ones.  Your local git is your sandbox, use that power and then cleanup before you share with others.    http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html   A commit is your smallest working unit, so if you have what should be 5 commits jammed into 1 -- you are going to have a bad time."
git,3afubp,robertmeta,3,Fri Jun 19 22:33:12 2015 UTC,"Woah, I've always wondered about rebase but never had a reason to use it on my personal projects. Thanks for the useful read!"
git,3afubp,boarhog,1 point,Fri Jun 19 23:10:37 2015 UTC,"Yep -- it is incredibly easy right?  Once people learn how to do it, they realize it isn't some overhead inducing process.  It is so easy, and it makes your commits so much better."
git,3afubp,robertmeta,2,Fri Jun 19 23:25:02 2015 UTC,I recently learned to do this and it made things so much cleaner.
git,3afubp,rogue780,1 point,Sat Jun 20 03:50:14 2015 UTC,"Makes sense, thanks!"
git,3afubp,robertmeta,1 point,Fri Jun 19 23:42:16 2015 UTC,"NP.  You might also want to check out this chapter about rewriting history: https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History  It is one of things that is not unique, but a major reoccurring feature of git.  Allowing you to edit your own little version of the world right up until the point you share it with others."
git,3afubp,rowe92,5,Fri Jun 19 23:46:15 2015 UTC,"It's like cooking. Make as much mess as you like in the kitchen (local commits), but when it's time to serve up, make it presentable (squash commits together and write nice commit messages before pushing)."
git,3afubp,wlu56,3,Sat Jun 20 09:21:13 2015 UTC,when you spend more time typing out commit messages than actual code?
git,3afubp,ndboost,1 point,Sat Jun 20 07:07:33 2015 UTC,Best answer :D
git,3afubp,mackstann,1 point,Sat Jun 20 12:43:46 2015 UTC,"lets say im working on a crud style web application.  First, i create branches off of development for specific features.. features are ... functionality added to the application... books, usermanagement, dashboard, authors...   lets say feature.books is a good branch. I'll then commit for each  of the CRUD operations.. when i create the entire read portion including views, backend code, frontend code etc.. i'll commit.  and so on..   once an entire feature including tests are done, i'll merge them back into development.  i tend to follow this guide.. http://nvie.com/posts/a-successful-git-branching-model/  when it comes to patching or repairing broken code, i'll commit when the patches are made and confirmed working and all tests are updated.."
git,3afubp,robertmeta,-5,Fri Jun 19 21:53:11 2015 UTC,"Yes. Too many may actually be worse than too few. As in so many other things in life, balance is key."
git,3afubp,mackstann,4,Fri Jun 19 20:22:38 2015 UTC,"Do not listen to such nonsense.  It comes to separability.  It is very easy to squash commits together, it is exponentially harder to separate them later.  You should commit whenever you think it makes sense -- this can be 50+ times a day, this can be half completed work.  This isn't shared with this world, this is on your git, local to your machine.  If you did something and you are like ""I want to save that"", then do so by committing.   Before you release your commits into the wild, you can squash them (yes, that is a git term, squashing) into fewer commits that make more sense.  Often in the course of working -- the majority of my commits have the comment ""WIP"" (Work In Progress) and then at the end of the day, I break those 10 to 30 commits into logical features, clean up the history, and then push it out to the team.  They never see my messy string of ""WIP"" messages."
git,3afubp,robertmeta,0,Fri Jun 19 22:25:52 2015 UTC,"Taken to the logical, extreme, you'd commit every single character change. There is obviously a point where you have too many commits to sanely manage."
git,3afubp,mackstann,3,Fri Jun 19 22:36:12 2015 UTC,"We fundamentally disagree, that is fine.  I find anyone who says in regards to git ""Yes. Too many may actually be worse than too few."" to be so far off the norm to be an untrustworthy source.  Giving that advice to someone new to git I find deplorable.   You are going to be in FAR worse trouble doing too few commits than too many."
git,3afubp,robertmeta,0,Fri Jun 19 22:41:36 2015 UTC,"I don't generally find myself getting into trouble with git due to commits being too large, and that's after about 5 years of daily use at work, including being in charge of merging/releases for much of that time, on several different projects with different people, etc.  I don't disagree with your recommendation to make tons of tiny commits and squash them -- it's a perfectly fine practice -- although I do find it to be generally unnecessary and unhelpful busywork, personally."
git,3afubp,mackstann,1 point,Fri Jun 19 22:51:28 2015 UTC,"It is real simple.  If you make a big fat commit -- walk me through how to break that into a series of smaller, clean logical commits.  Now look at the inverse, if you make too many small commits -- walk me through how to build them into a single big fat commit.  One of these operations is trivial, the other is a nightmare.  Because the fundamental working unit is a commit.  Combining small commits is EASY.  Breaking up large commits is HARD."
git,3afubp,robertmeta,2,Fri Jun 19 23:02:19 2015 UTC,"I understand that point.  I just don't find it to pose a real, practical problem. If I change a bit of code and then later change it back, or whatever, in a different commit -- so be it. I don't feel the need to have a finely manicured commit history. Sometimes I amend stuff here and there, but beyond the last commit, I usually don't bother obsessing over past commits. I don't worry about pushing beautiful commits."
git,3afubp,mackstann,1 point,Fri Jun 19 23:10:14 2015 UTC,"Again, we disagree.    I just don't find it to pose a real, practical problem.   I do -- to the point that after talking to someone repeatedly about poor commit maintenance we had to let him go.   I don't worry about pushing beautiful commits.   That is fine, all I ask is that you don't pollute newcomers with such IMHO poor habits.  What kills me about people who do a poor job managing commits is they don't even end up saving any appreciable time and they hurt the entire team in the process.  Squashing is insanely easy -- it takes hardly more time than just writing the commit mesage: http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html"
git,3afubp,robertmeta,1 point,Fri Jun 19 23:20:03 2015 UTC,"I suspect you have worked on small projects, with small teams with very little code review process or rollbacks.   Correct.  edit: I find it amusing that you deleted the one sentence that really explained our schism here."
git,3afubp,mackstann,1 point,Fri Jun 19 23:22:55 2015 UTC,"While I was correct, what I said came across as borderline insulting so I removed it.  I am not here to be rude, but I also can't sit by and see such, IMHO, disastrous advice being given out to a newcomer."
git,3afubp,bekroogle,1 point,Fri Jun 19 23:26:46 2015 UTC,"I'm literally brand new to git (like learned how to use it yesterday).  What are good and bad times to do commits, and when is too many?"
git,3afubp,remy_porter,2,Fri Jun 19 20:26:47 2015 UTC,"It's a little hard for me to describe. I'd try looking through the commit logs of some projects on github to get a feel for how other people do it.  Generally I commit at steps along the way where I got a new change working. The change may be just one part of a larger feature. I try to avoid committing when I'm in the middle of a change and it doesn't work, although occasionally I do this just because I need to stop working on it for a while. Usually such commits should clearly note this, using the term WIP (work in progress) in the commit message.  Of course, life is not neat and perfect and there are plenty of exceptions.  Sometimes a commit is just changing a single letter or word, because that's all that's needed to address a certain issue.  Sometimes a commit includes lots of changes that could have been broken into smaller commits, but you just got carried away and didn't commit along the way. These can sometimes be broken up using git add -p, which lets you selectively commit only certain parts of your changes at a  time."
git,3afubp,robertmeta,1 point,Fri Jun 19 20:36:52 2015 UTC,"Perfect, thanks! Great explanation!"
git,3afubp,remy_porter,2,Fri Jun 19 20:39:42 2015 UTC,"Disclaimer: I'm no expert!  When I realize I can't fit a meaningful commit message on one line, I realize I've done too much without committing (and it usually means I've done several different things). This is when I go with the git add -p mentioned by /u/mackstann.  I've found that one of the great benefits I've gotten out of using Git is that it encourages me to do ""atomic commits"" and work on one thing at a time--instead of digressing all over my source code."
git,3afubp,robertmeta,1 point,Sat Jun 20 11:17:19 2015 UTC,"When you have done something, to completion- commit it. Never commit work in progress. Do lots of small things that can add up to big things."
git,3afubp,remy_porter,3,Fri Jun 19 21:49:30 2015 UTC,"Work in progress is fine, you can always squash those last 3 commits into one.  I feel people are conflating SHARING commits and MAKING commits."
git,3afubp,robertmeta,-1,Fri Jun 19 22:43:15 2015 UTC,"I think if your work in progress is complex enough that you need to squash commits, you're biting off too much in a single go. It's not a git problem, but it's a code smell.  I generally don't squash commits, but I'll be careful about what I stage per commit to keep the history neat-ish."
git,3afubp,remy_porter,3,Fri Jun 19 22:54:34 2015 UTC,"It isn't a code smell -- it is a personality type -- it is a way of working entirely independent of code complexity.    Some people like writing little commit messages about work done often, I am not one of them, but I work with someone fanatical about it.  She commits every time she finishes an operation she deems worthy of a commit message.  Then she squashes them and combines those messages into one very sane well written commit.  This means she spreads the overhead of notes about things throughout her entire workflow.    I am not as disciplined as her, so I commit a lot of ""WIP"" messages cause I don't want to bothered during the day -- then have kinda a mini retrospective at the end of the day and share the work with others..."
git,3afubp,robertmeta,1 point,Fri Jun 19 23:06:20 2015 UTC,"I guess I just don't understand the point of squashing. If I didn't think it was worthy of a commit, I wouldn't have committed it. If I think something is complex enough that it's going to take multiple commits, I'll do it in a branch, and then merge it in later.  If I start something, only to discover later that it's too complicated for a single commit- I'll move all the changes into a branch. Maybe this is too many years using non-distributed SCMs, but I never want to tamper with history after the fact. History is history, it's in the past. Don't change it."
git,3afubp,thistimeframe,2,Fri Jun 19 23:24:04 2015 UTC,"Took me years to get used to mucking around with history -- but it is unreasonably effective so I gave up on my borderline religious defense of frozen history.    Doing it with branches, and branches and branches, and branches on branches on branches as you discover new feature needs or new lines of work is reasonable(ish) and merges do work.  But IMHO, it is far more complicated, adds little value and mucks up the history. (rebase versus merge: https://pbs.twimg.com/media/CB7Xq3ZUkAALJyv.jpg).  Rebasing and squashing takes seconds and just works (tm): http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html"
git,3acbbq,ChannelJuanNews,2,Thu Jun 18 23:06:34 2015 UTC,EDIT2: removed spoilers because jruel006 fixed the bug
git,3acbbq,imsometueventhisUN,2,Thu Jun 18 23:28:08 2015 UTC,Sorry! There was a problem with the last commit pushed. It works now. git pull to update and try the same command again!
git,3acbbq,imsometueventhisUN,1 point,Thu Jun 18 23:42:27 2015 UTC,"Typo in the README.md for Level 7 - ""specificied"" should be ""specified"""
git,3acbbq,imsometueventhisUN,1 point,Thu Jun 18 23:57:53 2015 UTC,"Also in Level 9 git log --pretty=oneline --reverse | tail -n1 can just be git log --pretty=oneline | head -n1, or even git show --format=oneline"
git,3acbbq,imsometueventhisUN,1 point,Fri Jun 19 00:08:39 2015 UTC,Heh - just saw your commit and pulled before checking this page again - thanks!
git,3acbbq,imsometueventhisUN,1 point,Thu Jun 18 23:38:21 2015 UTC,"Just finished - great game, thank you for making it! Now I want to learn how to automate that git bisect process...there must be a way to write a script to do it for you..."
git,3acbbq,Evan-Purkhiser,3,Thu Jun 18 23:43:01 2015 UTC,This is how I did it  git bisect run sh -c '! grep racecar twinkle.txt'
git,3acbbq,benjica,1 point,Fri Jun 19 00:13:01 2015 UTC,"You can use the run sub command of git bisect to execute a script to automate the search. Say, for instance, you have a grunt file that kicks off your unit tests that you manually execute with grunt test. You can use git bisect run grunt test that will perform the bisect and run the unit test on each step of the search using an exit code to mark good and bad."
git,3acbbq,coffeesleeve,1 point,Fri Jun 19 09:10:59 2015 UTC,Stuck on Level 5 using git version 1.8.4. or am I missing something?
git,3adbu4,weasleyiskingg,2,Fri Jun 19 04:45:27 2015 UTC,"When you commit code in Git, it sets the commit author using whatever email address you've configured. If you previously configured the email for your old account, GitHub will associate those commits with the old account, even if you push them to the new repository. To update your email, run git config --global user.email <new_email>"
git,3adbu4,itsananderson,1 point,Fri Jun 19 08:36:21 2015 UTC,"I did this and the email that shows up is only the one from my new account. However, when I click on the readme file, the previous account comes up as well."
git,3adbu4,itsananderson,2,Sat Jun 20 00:44:31 2015 UTC,You probably have old commits on the README file from your old email. Is it a public GitHub repository? Easier to look at the actual repository than to guess blindly at what's going on.
git,3adbu4,itsananderson,1 point,Sat Jun 20 03:08:36 2015 UTC,"https://github.com/dinocodes/treehouse  If you click on the README file, then the other user comes out"
git,3a9ct8,charlottedinkle,3,Thu Jun 18 06:59:17 2015 UTC,This is probably not what you actually want to do. What are you trying to achieve?
git,3a9ct8,DanLynch,1 point,Thu Jun 18 11:12:20 2015 UTC,Pretty much wanted to start a project from scratch without having to remake my git repos etc. I managed it anyways.
git,3a9ct8,DanLynch,1 point,Thu Jun 18 18:21:30 2015 UTC,Pretty much wanted to start a project from scratch without having to remake my git repos etc.   This is not a commendable goal. The correct thing to do when you start a project from scratch is indeed to remake your git repos etc.
git,3a9ct8,untitleddocument37,1 point,Thu Jun 18 18:54:53 2015 UTC,Yeah it seems like it would have been a good idea. Its just a test the now so its not so bad. :s
git,3a9ct8,pi3832v2,1 point,Thu Jun 18 19:09:25 2015 UTC,But starting a new repo is literally just doing   mkdir foo  cd foo git init .
git,3a68ex,solteranis,15,Wed Jun 17 15:33:30 2015 UTC,"You do not have to use a cloud-based provider with git. You do not have to have network access to use git. You do not have to capitalize git :)  A lot of people will use a central repository in their workflow simply because it's an easy central place to back up and base your production deploys and builds on, but it's not required.  The simplest situation is a single repository on your local computer. Take it with you on an airplane with no internet access and everything's still fine.  Second simplest is a two-developer setup. Each developer has a repository on their local machine, with a remote added referencing the other. This makes collaboration easy because pushing and pulling just references your coworker's repository.  Every repository is equal in git's eyes. There is no single authoritative source of information like you'd have in SVN for example. The repository on your local machine is no more or less important than the one on your coworker's machine.  It is not recommended that you have two different developers using a single repository (eg storing the git files on a network drive and everyone accesses that single repository). Each developer should have their own repository, and use remotes to share code between them. Whether that's a peer-based architecture or a centralized one is a matter of taste. In a centralized model, whether that central server is on premises or in the cloud is again a matter of taste. Git is flexible enough to support a great variety of workflows and architectures.  Does that somewhat answer your question?"
git,3a68ex,jakkarth,1 point,Wed Jun 17 15:45:25 2015 UTC,"First, thanks for the response, I appreciate it.  It makes it a bit clearer for sure, but I guess I just need to walk through this a bit to make sure I understand.  So for example, I'm working on a C# project using Visual Studios, I can install GIT to a local linux server which is backed up nightly. Do I then upload the base of the project to the GIT server, and then make a repo on my laptop? If so I assume then I'd essentially have a copy of the code from the server that I can work with, and when I'm ready commit that code back to the repository? I also assume GIT would keep each version (the original, and each pushed commit) so I could revert if needed?  I hope I'm getting closer to having my head wrapped around this"
git,3a68ex,jakkarth,12,Wed Jun 17 15:54:43 2015 UTC,"So you'll have a local repo on your computer, and a second repo on the linux server for redundancy and backup. That's a great setup! The integration between git and your IDE of choice will vary a bit from version to version etc. I'm going to list the commands that you would use from the command line, and you can adapt that to whatever interface you choose (or maybe someone else here can help with the specifics, I don't use Visual Studio).  The first thing to do is to create one of the repositories. It doesn't matter which one comes first. Lets do the server. The command here is pretty simple:  cd /path/to/myrepo git init --bare   This will change the directory to wherever you want to store your repository, and then create a blank repository for you. You'll notice a few files and directories when it's done. The --bare tells git that you're not going to be doing any work directly in this location. The largest effect this has is that the repo on the server doesn't have a working directory, meaning that the source files for your project won't be visible here, even though git is storing all the information about them.  Now we have an empty repository on the server. Lets switch to your local machine. Maybe you've already got some files set up for your project, like foo.cs. The steps are almost identical to what we did on the server:  cd c:\myprojects\projectFoo\ git init   Note that I'm omitting the --bare here because we intend to do work. I'm going to assume that c:\myprojects\projectFoo\foo.cs exists and has some basic code already in there. Right now, git isn't tracking any of the changes you're making to that file. We can verify this by seeing what git thinks of the current state of the working directory:      git status  This might show something like: On branch master  Untracked files:   (use ""git add <file>..."" to include in what will be committed)      foo.cs  nothing added to commit but untracked files present (use ""git add"" to track)   You can see there that git knows foo.cs exists, but it isn't keeping track of the information inside it; it is untracked. We want git to remember the current contents of the file. Git takes snapshots of the contents of the repository, called commits. For now, think of a commit as a set of changes you've made to your project. It doesn't have to be to a single file or directory. Perhaps, since the last time you took a snapshot, you've added a search function that involved changes to several different files. The commit is a set of logically grouped changes, ie ""this commit implements the search function,"" rather than ""this commit adds 12 lines to interface.cs."" I'm trying to keep theory to a minimum here, only introducing the concepts you need for a basic understanding, but commits are really important.  Ok, so far we don't have any commits. But we do have some content inside of foo.cs that we want to keep track of. You can think of this as a change from <nothing> to the state of foo.cs having its initial contents. We want to commemorate this state of the repository by making a commit out of it. I'm going to gloss over a bunch of details now. Git, rather than just taking a snapshot of your working directory to create the commit, has an in-between place called the stage. Sometimes it's also called the index. It's a place your code goes between when you're working on it and when you create the commit. It's not a stage like you'd have in a play, it's a stage as in a staging ground, where you get things prepared. We need to add the changes you made to foo.cs (ie its initial contents) to the stage and then tell git to create a commit out of what's on the stage:  git add foo.cs git commit -m ""Initial Commit""   Now git will keep track of the contents of foo.cs, so if you want to look at previous versions of it you can. the -m flag here is used to specify a commit message, a little string attached to the snapshot that explains the logical set of changes. Going back to the search function example, you might run git commit -m ""Added the search function. See #141 in the issue tracker."".   Now you implement another function in foo.cs, and when you've finished the new feature you want to create another snapshot:  git add foo.cs git commit -m ""Added new feature""   Now you've got two commits. You can read through the history of the repository by running git log, and any commit that you've made can be checked out into the working directory.  So how do we get the data to the server? Well, we can't just copy foo.cs up there. Git will only move entire logical changes, ie commits, at a time so that your repository is always in a known good state. So, we're not transferring foo.cs so much as we're transferring those two commits we made. Subtle but important distinction. There are two steps involved for this. First, we tell our local repository that the one on the server exists and how to access it. Second, we push all of the commits we made to the repository on the server.  git remote add origin user@server.com:/path/to/myrepo git push origin   The first command will create a new remote. That's basically just a shorthand way of referring to a repository other than this one that we might like to pull or push commits with.  In this case we named it origin, but it's not special, you can use any name you like.  Then we ran push. This takes any commits in the local repository and pushed (copies) them to the remote server's repository.  I tried to keep things pretty basic. Hopefully I haven't overwhelmed you with my giant wall of text. Other important topics that I didn't cover but you'll need to be familiar with at a basic level: pull, clone, branch, merge.  I'd be happy to clarify any of the above, and continue our example into the basics of pull clone branch and merge if you like. Good luck!"
git,3a68ex,bigrodey77,1 point,Wed Jun 17 17:06:11 2015 UTC,"Wow, thanks so much for the post. You really broke that down perfectly. I think that is more than enough to get myself moving on this.   Once again, thanks"
git,3a68ex,bigrodey77,2,Thu Jun 18 17:03:48 2015 UTC,"You'll want to create a bare repo on the Linux server whose purpose is to be the centralized repo from where the other devs will clone. The main difference between a traditional repo and a bare repo is that you cannot directly commit to a bare repo.  git init --bare   Then go to your laptop and clone the repo from the Linux server. You'll have to know the ""address"" of the repo as it could be in the form of a network share or http address. Depends on your network configuration.  Once you have the repo cloned to your laptop, you can just start working with the repo. Adding files, changing projects, etc. and once ready, push your repo to the Linux server.  Slightly off topic but storing the centralized repo on a Linux server but working with the code on a Windows machine can make line endings a giant PITA. That problem has plagued me on numerous projects as I can just never seem to get the correct settings to make it go away. YMMV but just remember that you might run in to this problem as well."
git,3a68ex,bigrodey77,0,Wed Jun 17 16:12:59 2015 UTC,"So, should I then install GIT on a linux server, store the repo on a windows share? Or would I still run into a similar issue?"
git,3a68ex,bigrodey77,1 point,Wed Jun 17 16:32:16 2015 UTC,Let's ask this question. What is the benefit of installing Git on the Linux server but actually storing the repo on a Windows share?   Git has to be installed on the server where the repo will be stored.
git,3a68ex,Fs0i,1 point,Wed Jun 17 17:08:43 2015 UTC,"lol, good point"
git,3a68ex,forlasanto,2,Thu Jun 18 16:59:01 2015 UTC,"Git repositories are fully self contained regardless if they are stored on your local computer or the cloud. A Git repository has everything it needs to function as a standalone repository.  Connecting your Git repo to the cloud is almost always done with GitHub as that has become the de facto cloud based Git hosting provider. GitHub also sells an enterprise version of their product that is to be hosted within your company network.  You'll need to determine a location for the centralized repo where every member can access. This copy of the repo is main version where all members will initially clone from and changes are merged. The team will never directly work on the centralized repo as they should clone the repo to their local dev machine and do all development work on their local dev machine. Once they are ready to share their changes, their changes are ""pushed"" to the centralized version of the repo where then other developers can ""pull"" them."
git,3a68ex,noratat,3,Wed Jun 17 15:52:03 2015 UTC,"so can the centralized repo be stored on a local git server, and then clone that my computer. Then when I'm happy with changes I've made can I push those changes back to the main version on the server?"
git,3a68ex,untitleddocument37,3,Wed Jun 17 16:03:18 2015 UTC,"Yup, pretty much."
git,3a30q7,lol_dominion,10,Tue Jun 16 20:51:34 2015 UTC,If you're hoping for a response this other guy posted something a year ago saying he thought it was a good idea and nobody responded http://www.reddit.com/r/git/comments/23lu68/always_prune_remotetracking_branches_when
git,3a30q7,jokerdeuce,6,Tue Jun 16 21:17:33 2015 UTC,Can someone explain what --prune does?
git,3a30q7,Waldheri,7,Wed Jun 17 05:18:15 2015 UTC,"Removes stale tracking branches (that is, branches that were once tracking remote branches that have since been deleted from the remote repo)."
git,3a30q7,mipadi,6,Wed Jun 17 05:38:18 2015 UTC,"Well, it's OK unless you have a reason not to do it :).  But I'd expect the most typical reason not to is that you're tracking multiple people's version of the same project and the branches regularly get deleted when merged, and you still care about somebody else's particular ephemeral branch."
git,3a4b9u,ThePiGuy2,10,Wed Jun 17 03:06:01 2015 UTC,"“Adding” files “stages” them to be “committed.”  The reason for the extra step is so that you can combine changes to multiple files into one commit, but at the same time not be required to include all changed files in that commit.  Some Git commands also work differently on staged files as opposed to changed/new unstaged files, e.g., git diff."
git,3a4b9u,pi3832v2,5,Wed Jun 17 04:24:35 2015 UTC,After that one time you don't have to use add anymore.   This is completely wrong. git add should be the most used command (especially with git add -p) to craft feature specific commits. git commit -a is the wrong way to do it.
git,3a4b9u,Femaref,3,Wed Jun 17 03:19:46 2015 UTC,"Thanks, all I needed!"
git,3a38v2,ThePiGuy2,6,Tue Jun 16 21:48:30 2015 UTC,"git commit -a will first add all changes to tracked files to the stage and then create a commit out of them. Information on individual subcommands can be found by appending --help. For example, git commit --help will open the documentation for commit. git commit -h will provide a shorter description of the available options."
git,3a38v2,jakkarth,5,Tue Jun 16 21:58:56 2015 UTC,also git help commit and man git-commit
git,3a38v2,l4than-d3vers,4,Tue Jun 16 22:22:33 2015 UTC,"man git-commit     -a, --all        Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected."
git,3a38v2,untitleddocument37,1 point,Wed Jun 17 11:34:13 2015 UTC,"Perfect, thank you!"
git,3a38v2,untitleddocument37,1 point,Wed Jun 17 15:48:18 2015 UTC,most [all?] git commands also have --help e.g.  git commit --help   which shows the same page.
git,3a38v2,pi3832v2,1 point,Wed Jun 17 15:52:47 2015 UTC,"Gotcha, thanks"
git,3a2nh0,ajr901,2,Tue Jun 16 19:19:21 2015 UTC,Why not skip bitbucket and just push to your vps? You can have a post-receive hook that will freshen your working directory.
git,3a2nh0,jakkarth,1 point,Tue Jun 16 19:25:14 2015 UTC,"Ok, that's what I thought would be a good option. But now I'm having a hard time with this. I tried pushing to the VPS via git and got a bunch of errors.   Should I remove the VPS's git repo and clone it from bitbucket and then push to it? Or is there a right way to do it?"
git,3a2nh0,jakkarth,1 point,Tue Jun 16 19:52:58 2015 UTC,got a bunch of errors.   Can you be more specific?
git,3a2nh0,jakkarth,1 point,Tue Jun 16 19:54:09 2015 UTC,"Actually, I figured it out. Tower (Mac App) was giving errors saying that it couldn't push to the repo (even though they were identical). So what I did was git clone [bitbucket repo address] and then added my vps's address and username + password to Tower and then I merged head with the VPS remote and then I pushed and it worked perfectly.   Only thing that sucks is I have to push to both remotes separately. Tower doesn't provide a way to push to both at the same time.  Thanks!"
git,3a2nh0,GlowInTheDarkDonkey,1 point,Tue Jun 16 20:00:45 2015 UTC,"Not sure I totally followed that, but glad you got it working at least. If you have more questions let me know."
git,39vaed,jakubgarfield,3,Mon Jun 15 02:24:27 2015 UTC,This is excellent. I had no idea it existed. I manually created fixup commits on more than one occasion.
git,39vaed,Kraigius,3,Mon Jun 15 03:10:56 2015 UTC,Shameless plug. I've created a script that lets you pick the fixup target by tabcomplete from a list based on git blame/log   https://github.com/keis/git-fixup
git,39vaed,keis,1 point,Mon Jun 15 06:43:14 2015 UTC,"Tab completion appears to be zsh only, is that correct?"
git,39vaed,babilen5,2,Mon Jun 15 10:24:02 2015 UTC,"yes. I'm afraid so. I've been meaning to sort out some bash support as that's always the first comment I get but it's hard to find the motivation as I so rarely use bash (well, at least the interactive mode)  pull requests are welcome ;)"
git,39vaed,keis,1 point,Mon Jun 15 11:45:54 2015 UTC,"It looks like an interesting project and I'd encourage you to pursue it further, but bash-completion would be quite nice for me and, I guess, a lot of other people."
git,39vaed,babilen5,1 point,Mon Jun 15 12:42:10 2015 UTC,Pretty awesome stuff! I do think that being able to search the most recent commit by some string makes it exponentially more useful.
git,39vaed,unixlover,1 point,Mon Jun 15 13:32:35 2015 UTC,git-cola has a really nice way to generate fixup commits for those that prefer a UI for commiting.
git,39jn80,rorriMnmaD,20,Fri Jun 12 04:48:37 2015 UTC,"Atomic changes.  That is to say, the smallest patch that is indivisible but leaves the project buildable both before and after it.  That doesn't necessarily mean ""frequently"".  I use git add -i a lot, and spend a lot of time doing the above when I reach a nice mini-milestone (which might be once at the end of the day).  Then I sort out which bits of the current changes in my working tree can be isolated into single-subject commits.  Then I tend to use git rebase -i to order those commits to tell the story of the development as best I can.  Advantages:  - git bisect is incredibly useful when the patches are atomic  - Code reviews easier, as each patch will have a focus and every line of the diff should contribute to its purpose  - git rebase conflicts are much easier to resolve for the same reason.  Also remember that writing a commit message is as much an art as writing commentary.  Just as  x = 4;  // Store 4 in x   is an appalling comment.  So would  Change timing constant  -TIMING_CONSTANT = 6; +TIMING_CONSTANT = 10;   be an appalling commit message.  Anything that's obvious from the diff, doesn't need repeating in the message.  Err on the side of too many commits rather than not enough. git rebase -i makes it very easy to combine commits that you later realise didn't need to be so fine grained.  It's like entropy flowing in one direction only: mixing ingredients is easy; unmixing them is hard."
git,39jn80,kingofthejaffacakes,3,Fri Jun 12 09:40:10 2015 UTC,"I've switched to git add -p most of the time.  It can do pretty much the same thing, but most of the time flows a lot smoother for me."
git,39jn80,jk3us,1 point,Fri Jun 12 18:39:30 2015 UTC,"I like this.  I'm going to try copying your workflow next week and see how it feels.  Previously I have always used git add -A... I never really thought about it, just kind of automatically used it, probably because it was the way whatever git-tutorial I read first was.  git add -i seems so much nicer, especially in those cases where I make a lot of different edits that have really no relationship to eachother.  How ofter do you check out a new branch?   Since I'm working solo, very rarely does it seem worth it to branch rather than just working on Master.  I usually only use it in cases that I'm unsure whether I'm making the right coding decision (branching makes it easy to just scrap a failed idea)."
git,39jn80,Manitcor,1 point,Fri Jun 12 10:33:34 2015 UTC,This is my way of doing it than about once every six months to a year I might go through and roll-up large groups of related commits when the atomic-ness of the change matters much less than the milestone of a set of features working for archival and tracking.
git,39jn80,robertmeta,11,Fri Jun 12 20:32:23 2015 UTC,"Every minor change(s).  It is easy to clump them up later, orders of magnitude harder to separate.  If I am exploring, generally I commit them locally with a placeholder message like ""WIP"" which signals to me I need to clean those up before shipping them out.  Team setting is irrelevant, the size of your LOCAL commits is independent from the size of commits you push.  Lots of little commits, squash and cleanup, then push."
git,39jn80,rwong48,5,Fri Jun 12 05:04:23 2015 UTC,"Every time you get somewhere. Just write a message for yourself. You can always squash/rearrange/reword them later. For the super obvious ones, I add ""WIP' or ""squash me into <other commit message>"" to the title to remind myself to do that later."
git,39jn80,kinygos,7,Fri Jun 12 05:23:26 2015 UTC,"When I create a commit, I only include changes to the codebase that belong together, meaning they make up a single functional change to the system.  Sometimes a commit might be a single change to a single file, or it could be changes to several files.  The key for me is to think about changes to the system.  I even go to the extent of including partial changes (git add -p) to a given file in a commit if necessary.  There are a few scenarios in a development workflow when the contents of a commit become relevant, but the most common for me are:   in the future, looking back at code history cherry picking a change from one branch to another reverting a change   In each of these scenarios, by keeping commits to single functional changes makes my life easier.  Typically, when I'm looking back at code history, I'm interested in why certain code has been written.  So, using git blame to get the commit reference, I can get the whole commit that includes the code I'm interested in.  This lets me see what change to the system left the code as it is.  Cherry-picking a change from one branch to another is easier if you don't have to break the commit up to.  This is also the case when you want to revert a change.  One other useful part of a commit is the commit message.  Use an imperative statement that describes the change, as if you were ordering someone to make the change."
git,39jn80,untitleddocument37,3,Fri Jun 12 08:30:32 2015 UTC,"To sum up advice   On a feature branch, early and often, rebase and squash before merging when done.   Committing on a branch avoids littering on longer lived branches.  Early and often gives you points you can bisect at when things get broken.  Squashing allows you to remove useless partial solutions."
git,39jn80,cruyff8,3,Fri Jun 12 18:01:30 2015 UTC,"I make separate commits on every logical part. For example, if I fix a bug that maps an object to the proper URL and another bug in the same file that generates its QR code properly, these will be two separate commits. A client such as SourceTree makes this a joy to deal with."
git,39jn80,pi3832v2,7,Fri Jun 12 18:28:20 2015 UTC,"But as far as workflow goes, I'm not sure when is appropriate to commit.  Sometimes it's quite obvious: Implemented a new feature, or hit an obvious landmark.   That's not the obvious time to commit.  That's the obvious time to merge."
git,39jn80,pydry,2,Fri Jun 12 05:26:29 2015 UTC,"Every minor working change. Frequently this will mean committing code that isn't hooked up yet and won't yet run, but also doesn't break anything.   But what about the one-off stuff like ""changed css background to light green""?    Hell ya.   Would you commit that in a team setting? Even if you don't even know that you necessarily want to stick with green (for example)?   Definitely. Committing red straight away afterwards isn't a huge issue."
git,39jn80,remy_porter,2,Fri Jun 12 08:20:14 2015 UTC,"Commit in meaningful increments. Things like line count, files, etc? That's bullshit. If the current round of changes is meaningful, commit that set of changes."
git,39jn80,cdunn2001,2,Fri Jun 12 14:03:31 2015 UTC,"There are 2 different issues:   How should commits look in the public repository? How should you work locally?   For #1, you could rebase immediately before pushing. You can do this:  git rebase -i origin/master # Change each 'pick' to 'squash' (to reduce) or 'edit' (to expand). # Repeatedly:   git add -p   git commit -m 'new message'   git add -p   git commit -m 'another'   ... git rebase --continue # And repeat.   For #2, in order to avoid losing code, you should commit often. And in order to avoid wasting time, you should branch for every new idea, but rebase those temporary branches before pushing.  Personally, I do both. I use a combo git add -p and git commit --fixup."
git,39jn80,DanLynch,1 point,Sat Jun 13 18:13:00 2015 UTC,"I try to break down my progress into the smallest possible steps, and commit each one separately, even if it sometimes means I feel like I'm using Git more than I'm using my IDE or programming language.  Of course this doesn't always go according to plan, but I think that's the right attitude to have."
git,39kuyv,Trexounay,1 point,Fri Jun 12 12:58:39 2015 UTC,http://stackoverflow.com/a/4828031 ? It also looks like it can be caused by editors/IDEs like visual studio or eclipse having some of the files open while git is trying to work with them.
git,397qkj,napsterpepper,10,Tue Jun 9 21:27:49 2015 UTC,"https://github.com/eirikurn/git-dropbox  http://stackoverflow.com/questions/1960799/using-git-and-dropbox-together-effectively  But I would drop dropbox altogether and use git (with github, gitlab, bitbucket, etc) itself."
git,397qkj,Phrohdoh,1 point,Tue Jun 9 21:54:36 2015 UTC,"If you get rid of dropbox like /u/Phrohdoh suggests (seconded), then I would suggest using two or three remotes simultaneously (git remote add). Just in case one site goes down or shuts down unexpectedly, since you won't have the dropbox backup."
git,39605i,permabed,5,Tue Jun 9 14:35:33 2015 UTC,"The rebase is only rewriting the history of the feature branch. Depending on what you want to do by sharing the feature branch, this may be acceptable; when others pull the feature branch, it'll warn them that history is being rewritten, and it won't be a problem unless they've added commits on top of the work you've done.  If they're going to be adding commits to your feature branch, then rewriting the history may be an inconvenience for them because their patches may no longer apply. Instead, you can use merge instead of rebase, which doesn't alter the history but still keeps your feature branch up to date with the changes made in origin/develop. Merging means that future commits made by other developers may have to be adjusted, but commits made in the past should still apply cleanly, making it easier to collaborate without breaking things."
git,39605i,jakkarth,1 point,Tue Jun 9 14:50:43 2015 UTC,"Thanks! So, i'll carve in stone that whenever i share commits, history rewrite is forbidden even if it's a feature branch"
git,39605i,lhxtx,2,Wed Jun 10 07:10:02 2015 UTC,Just don't rewrite history on branches on origin. Rebasing should be on your local repo.
git,391i2a,jbcrail,7,Mon Jun 8 15:51:53 2015 UTC,"Hmm, another day, another misleading git blog. Some poor choice of words in this article, for instance:  ""git reset rewinds your repository's history all the way back to the specified SHA""  This doesn't make a great deal of sense. git reset moves the current branch pointer to the specified commit, it doesn't ""rewind"" your ""repository's history"".  ""The commits are gone""  The commits are most certainly not gone; if you have a remote version of the branch you can still access them that way, or failing that, look them up in the reflog. If they have no branch pointing to them they will be garbage collected by default after two weeks.  Misleading, poorly thought out posts like this are the reason people struggle with git - they don't explain what is happening to the repository correctly. I urge everyone to read a site like http://think-like-a-git.net/ and learn what the commands actually DO, then you will never need to consult this ""cheat sheet"" in a panic when something goes wrong."
git,391i2a,rowe92,4,Tue Jun 9 08:34:03 2015 UTC,"This is Git's safest, most basic ""undo"" scenario, because it doesn't alter history—so you can now git push the new ""inverse"" commit to undo your mistaken commit.   This is not entirely true - both the original commit and the revert will appear in your branch's history, and if you need to recover the original commit later, you must revert the revert.  edit: My comment was based on a variant reading of ""alter history"" - the author is saying that it adds new commits, it does not modify (or lose) existing commits. However, revert is still a dangerous operation if you don't understand what it's doing.  For example, let's say that you merged a branch and then realized that you didn't want it in that branch yet. If you revert the merge commit, the only way to get it back into that branch is to revert the revert. If you try to just merge the branch in again, Git reports that everything is up to date (even though it most definitely isn't) because the commits are in the branch history."
git,391i2a,Matosawitko,1 point,Mon Jun 8 20:36:45 2015 UTC,"git reset rewinds your repository's history all the way back to the specified SHA.   No..it just move the branch pointer.   The commits are gone, but the contents are still on disk.   This doesn't make sense. The commits are still in your repository database. However, they are detached from your commit history, like if you removed a pointer from a linked list or an edge from a graph that prevents to reach them.   Scenario: You made some commits, then realized you were checked out on master. You wish you could make those commits on a feature branch instead.  Undo with: git branch feature, git reset --hard origin/master, and git checkout feature   Completely useless if you pushed those commits to your remote. You will have to hard reset at a specific commit in your history."
git,391fvb,DayvanCowboy,1 point,Mon Jun 8 15:37:05 2015 UTC,"What sorts of files? What you are describing seems perfectly normal. A pull merges your local branch with what was obtained from the remote (technically the remote-tracking branch). If you want to keep your local branch the way it was before, fetch instead of pulling. You can merge later if you want."
git,391fvb,Jack126Guy,1 point,Mon Jun 8 23:38:46 2015 UTC,"SQL files. This was a FF merge. Also, even if I tried to stash and drop the files or do a hard reset, the files were still present as unstaged files. Also, the same files seemed to bother several other developers"
git,391fvb,jredmond,1 point,Tue Jun 9 02:33:16 2015 UTC,"SQL files as in ""here's the schema"", or SQL files as in ""here's a backup of our DB""?"
git,391fvb,untitleddocument37,1 point,Tue Jun 9 18:06:51 2015 UTC,SQL files as in here's the schema or sprocs and the like...
git,38ybuf,sorcix,15,Sun Jun 7 21:53:10 2015 UTC,"Does it make sense to keep the old commits?  Probably.  Even if you have absolutely no way of getting hold of the old software, and can therefore not directly use the old code, you can almost certainly still learn something from it.  Version control is not only about being able to reconstruct a copy of the code at any point in time, but also to act as a record of what changed and why."
git,38ybuf,cfmdobbie,8,Sun Jun 7 22:05:44 2015 UTC,"It's amazing how many people forget the ""why"" part of their commit messages."
git,38ybuf,djmattyg007,1 point,Mon Jun 8 10:23:24 2015 UTC,You're right. Thanks
git,38ybuf,metaobject,9,Mon Jun 8 07:07:59 2015 UTC,"Maybe it's just me (or perhaps I don't fully understand the situation), but I can't imagine a scenario where you'd gain anything by having less log information regarding your project.  Perhaps add a README file to note what versions/dates are affected or no longer contain accurate paths, etc."
git,38ybuf,assassinii,3,Sun Jun 7 22:09:08 2015 UTC,"You should leave them be. I'd argue that removing those old commits would do more harm than it would do good to the legibility of the history.  In the future if you're making large changes to the codebase at once, you should consider using feature branches to organize the commits."
git,38ybuf,hereatendill,3,Mon Jun 8 00:43:18 2015 UTC,"What do you lose by keeping those commits? A couple of KB or MB in most cases? Unless your computer was made in the 60s that's not a problem. What do you gain? A detailed log of everything that's happened.  Have you considered using some kind of dependency management to install your static site generator? If you installed it via bundler, composer, etc then you'd be able to install an older version easily.   In case I no longer have access to the older versions of the static site generator   If you're concerned about that, you could vendor the source of the static site generator inside your repository. i.e. stick a copy of the source in your repo, and when you build your site build the static site generator first."
git,38ybuf,a-p,2,Mon Jun 8 00:54:03 2015 UTC,Yes.  Why the question?
git,38y6hh,knight_who_says_knee,2,Sun Jun 7 21:11:12 2015 UTC,"Can anyone explain how to get my local project to match what's on github?   If this is your goal, you could just delete the directory and clone it back down (or just clone it into a fresh directory). Now, this would mean losing any local changes, which may not be what you want.  It asked you to merge because there were conflicting changes in your local repo and in GitHub. If you want them, you'll need to try reverting again- and that can mean a variety of things."
git,38y6hh,remy_porter,1 point,Sun Jun 7 21:24:14 2015 UTC,"If I merged, shouldn't my project match what's on github? For instance, I'm missing the gen directory which is making my project unrunnable although it is on github.  I guess I'll just clone it to a new project, although I'm sure that will likely screw up something else"
git,38y6hh,remy_porter,2,Sun Jun 7 21:43:06 2015 UTC,"If I merged, shouldn't my project match what's on github?   Nooo. Quite the opposite- if you merged, any changes you had committed locally will be there plus whatever was on GitHub. So, for example, if you deleted the gen directory locally, committed that, and then pulled from GitHub- it's still deleted for you."
git,38y6hh,Jew_Fucker_69,2,Sun Jun 7 22:20:18 2015 UTC,"Everything you have committed can be recovered (even if you deleted it later).   What you had not committed can not be recovered.   Assuming you had the files commited:   A git repository is made up of ""revisions"". Every commit creates a ""revision"". You have to find the revision in which you commited the files that you want to recover.   First clean everything up until ""git status"" returns ""nothing to commit, working directory clean"". An easy way to do this is to just make a new folder and clone the repository again in that folder.   Then type ""git log"" to see a list of revisions, or ""git log -p"" to see a list of revisions including the changes made. When you have found the revision in which your files are, type ""git checkout [revision_code]"". Now your files should exist again. Copy them somewhere else, then type ""git checkout HEAD"". Then copy the files into the git again and add them and commit them."
git,38y6hh,monstermudder78,2,Sun Jun 7 21:45:47 2015 UTC,Reset my local repository to be just like remote repository HEAD
git,38pjxt,nastydance,9,Fri Jun 5 19:28:48 2015 UTC,You can tell Git to clone into a directory with a different name:  git clone https://example.com/template.git path/to/new/project   The directory must be empty (or not yet exist).
git,38pjxt,Jack126Guy,4,Fri Jun 5 20:16:34 2015 UTC,Oh nice! Thank you!
git,38pjxt,sz4rlej,5,Fri Jun 5 21:17:28 2015 UTC,"Also, you can clone your repo to directory you're currently in (making it the root dir of your project):  git clone https://example.com/template.git ."
git,38pjxt,DanLynch,2,Fri Jun 5 21:52:58 2015 UTC,"Oh man, this one is fantastic. I finally figured out that it doesn't work if you do $ git init first but actually it SAVES a step that clients won't have to remember. Thanks man!"
git,38pfjm,dzikakulka,2,Fri Jun 5 19:01:30 2015 UTC,"Did you ever commit your changes to your new branch? If not, I can try and explain what happened.  Git keeps track of commits. Each commit stores a snapshot of your repository. Additionally, each commit contains a pointer to the commit that came before it (called its parent). So, you get a graph like this:  A <- B <- C <- D   A is the first commit. B came later and its parent is the commit A. C's parent is B and D's parent is C. More than one commit could have the same parent. Below, E's parent is also B.  A <- B <- C <- D       \        - E <- F   A branch is just a pointer to some commit. Here, the branch foo points to commit B and the branch bar points to commit D.  A <- B <- C <- D       \         \        foo       bar   Additionally, branches can change over time. Whenever you make a commit while you are on a particular branch, you'll update the branch pointer to your new commit. The special pointer HEAD always points at the current branch. Here a repository starts with one commit and the master branch points at it:  A  \   master <- HEAD   Make commit B on the master branch:  A <- B       \        master <- HEAD   And commit C on the master branch:  A <- B <- C            \             master <- HEAD   If you create a new branch with git branch, you make a new pointer and point it at whatever commit HEAD points at. Say we did git branch foo. Now we have two branches pointing at commit C.              foo            / A <- B <- C            \             master <- HEAD   If you do git checkout foo, all that does is move the HEAD pointer to point at foo. If foo had different contents, it would also change the files in your repository to reflect that commit. In this case, both foo and master point to the same commit, so your files are untouched:              foo <- HEAD            / A <- B <- C            \             master   Since a branch is just a pointer to a commit, you can see now that a branch doesn't care what changes you've made to the files in your repository unless you commit them. Going back to the master branch with git checkout master doesn't change any of the files on your filesystem. HEAD still points to the same place it has this whole time, commit C:              foo            / A <- B <- C            \             master <- HEAD   git reset --hard origin/master means to make your current branch (in this case master) point to the same commit as origin/master and make your filesystem look just like that commit. It throws away any changes you have made. Since you never committed those changes anywhere, they are gone for good.  What you should have done was commited your changes while you were on branch foo. If you had done so, it would look like this:                   foo <- HEAD                 / A <- B <- C <- D            \             master   Now master and foo point to two different commits."
git,38pfjm,peterlundgren,1 point,Sat Jun 6 03:56:11 2015 UTC,"Wow, thanks for such an elaborated answer :)  I had impression that creating new branch would act as commit but that's pretty db if you think about it. Thanks for explaining that to me."
git,38pfjm,Chousuke,1 point,Sat Jun 6 08:49:16 2015 UTC,"/u/peterlundgren already answered in many words, so let me give you a good tip to avoid mistakes like this: there's never a bad time to commit your code.  You can amend, undo, combine, split and reorder local commits all you want. You can even recover references to them if you screw up with rebase and ""delete"" the wrong commit. No git command save for an explicit GC will ever delete committed data."
git,38k44s,jakubgarfield,37,Thu Jun 4 19:14:13 2015 UTC,"Except that this leaves all the information about why the change took place in the pull request on GitHub; so if you're doing git blame, GitHub is down, or you migrate away from GitHub you just see ""update this"". You don't have the information anymore.  If it's in your commit messages, it lasts as long as the repository does."
git,38k44s,dr4g0nnn,19,Thu Jun 4 20:15:28 2015 UTC,"GitHub is a cool service, and I'm glad that it is doing a lot to popularize Git, but some of the non-Git-like stuff it encourages people to do is alarming."
git,38k44s,DanLynch,15,Thu Jun 4 21:43:59 2015 UTC,"Yeah. As an example, relying on Github comments to document things just seems like a terrible idea."
git,38k44s,GundamWang,2,Thu Jun 4 22:25:10 2015 UTC,"contrairiwise, the user interface it provides is being addopted at an alarming rate and many people find it much more simple to work with  i sympathise that it is terrible we are bing locked into this closed-source platform, but i think the spirit of the tool is good. we need more better user interfaces for a lot of the software processes our community has built  probably we should seek to build something that makes github unnecessary, because the tools themselves are already simple enough to use"
git,38k44s,wjdp,2,Fri Jun 5 17:00:28 2015 UTC,Half way there http://gitlab.com?
git,38k44s,rowe92,11,Fri Jun 5 17:46:31 2015 UTC,"Load of horseshit.  If you want to do experimental changes with lots of reference commits that's fine, but rebase -i was invented so you could clean that shit up afterwards.  There's no reason to have a commit message like ""unfuck the last commit"". Fixup into the previous commit, it takes 2 seconds to do."
git,38k44s,Kraigius,14,Fri Jun 5 11:30:05 2015 UTC,"No, no, no.. furiously shake head with both hands  If you are working alone, then I totally understand if you make a lot of commits with meaningless messages.   In fact, you are encouraged to commit often. I would encourage everyone to commit often, as long as every commit is not changing a bunch of different unrelated things, and as long as the build succeed. I see red if someone commit and forgot to include a file and the build fail :p  If you are working alone, commit messages can be as meaningless as you want, who cares if it's bad practice. You can always ammend them later on, no one is there to complain to you about a force push. If you don't write meaningful commit message you will only hate yourself after months/years passed and you come back to your project. Though, I assume my future employer might look at my previous repositories and I would hate if they see one of my commit message being ""fuck this"", doesn't ring professionalism.  The commit example with Atom is..really awful. I mean, it's a good example of things that shouldn't be done. Just like what /u/dr4g0nnn , /u/DanLynch , and /u/GundamWang said, pull request is a feature of github, that information is not stored in the repo. A commit message should always explain the commit, what it changed and why. A pull request should explain why you want this to be merged, the benefits, what it fix, etc.   if Git had a new object that was below the Commit object — maybe a ExperimentalCommit that would get folded into a single Commit once it went through code review.   Depending on the context, I mostly disagree with folding lots of commits into a single one (Squashed commits) since you might lose some precious context, what you are looking for is called branches.  Branch off, do your feature. Too much meaningless commits? Squash what you want. Merge when done. Delete branch."
git,38k44s,yawaramin,5,Thu Jun 4 23:33:41 2015 UTC,Even nicer: merge --no-ff and do log --first-parent in master to see the mainline commit history with pull requests that were merged over time: and do show -m SHA to see merge commits with full diffs of what was merged in. This is exactly what Holman was wishing for.
git,38k44s,Drainedsoul,4,Fri Jun 5 02:49:23 2015 UTC,"If you are working alone, then I totally understand if you make a lot of commits with meaningless messages.   I don't.  Rather than being the worst enemy of other people working on the code base, you instead become the worst enemy of future you working on the code base.  I think that's even worse.  I mean if you don't have regard for other people you may be a piece of shit but I can at least understand where you're coming from: You're not them, so it's not your problem.  If you don't have regard for yourself, well..."
git,38k44s,jerriman,7,Fri Jun 5 17:04:38 2015 UTC,"that special system already exists ""local branches"" and git rebase -i. During programming I only create oneline-comment commits. And before merging I squash everything together with a great commit messages. Best thing about git!"
git,38k44s,frigge,6,Fri Jun 5 06:10:27 2015 UTC,"Sometimes I’ll even deliberately push a commit and immediately  revert it because I want a record of one possible experiment was. [...] That way, each developer could commit their scratchpad  experimentations to mainline    I wonder, if the author knows what branches are o.O"
git,38k44s,cmputrnx,7,Fri Jun 5 11:28:18 2015 UTC,"Writing nice, long, detailed commit messages and then running git log at the end of the week is also a great way to generate your weekly status report."
git,38k44s,joehillen,8,Fri Jun 5 08:54:15 2015 UTC,"You, sir, are an idiot."
git,38k44s,ficiek,6,Thu Jun 4 21:49:25 2015 UTC,My first thought was that I would never want to work or cooperate on an open source project with this guy.
git,38k44s,MachinShin2006,2,Fri Jun 5 07:30:32 2015 UTC,"It is horrible, this idea.    -- Samir Nagha.. Nagha.... Not gonna working here."
git,38kcxu,Kendama_Llama,3,Thu Jun 4 20:01:30 2015 UTC,"Git is not about servers. For example, Git is not about deploying built artifacts to a server.  Git is about version control for source code, which can be optionally stored or backed up on a server. Most of the time, however, each developer will be using Git locally on his personal workstation. The fact that you've provided a lot of information about your servers, but no information about your developers' workstations, makes me worry that you're not really thinking about Git the right way.  SVN requires a server because it is inherently a client-server program. Git is not inherently a client-server program (though it does have some optional networking capabilities), so it doesn't require a server."
git,38kcxu,DanLynch,1 point,Thu Jun 4 21:42:00 2015 UTC,"Use the local server as your central server where everybody pushes to, and at the remote server you setup a cron job to mirror the git repository."
git,38kcxu,fdafasdfadfaf,1 point,Thu Jun 4 21:02:29 2015 UTC,"I like this idea, how do I go about mirroring the git repository?"
git,38kcxu,fdafasdfadfaf,1 point,Thu Jun 4 23:35:24 2015 UTC,Look at git push --mirror
git,38ekzu,unigee,6,Wed Jun 3 18:23:07 2015 UTC,"I create a new project that I decide to use git. When would I start using git?, if I start using it right from the start, it seems I would be performing many many commits. From what I can tell, it's more suited for when you have a working project, then you create your initial git repo, then use git as it should be used.   I don't really follow your logic here. You can commit as frequently or infrequently as you like, so there's not really any benefit to delaying using git. In fact, I would say one of the biggest benefits of git is that it's super easy to start using it. Just git init and you're good to go.   So what do we do now? Do I start up my IDE, first thing I do is pull the repo?, spend couple days coding, then commit and push my update? What about the other person, do they always pull the repo before starting with anything, then commit and push the bug fixes?  So do we now always follow the pattern Pull, code, commit, push?   That's definitely one way to use git. If you always want to work on the most up-to-date codebase, then yes, you will need to pull (and push) regularly.  A more typical workflow is to use separate branches. When you start working on a new feature, create a branch (git checkout -b myfeature) and do your work in that branch. When you are finished working on your feature, or have it in a stable state, you can merge it into the master branch, at which point other developers will pull the changes."
git,38ekzu,root45,6,Wed Jun 3 19:39:06 2015 UTC,https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow
git,38ekzu,krokodil_hodil,1 point,Thu Jun 4 04:04:01 2015 UTC,This tutorial is great. It really helped me understand how to use git in terms of workflow. I highly recommend it.
git,38ekzu,thetalentedmrpeanut,5,Thu Jun 4 04:21:58 2015 UTC,"You should commit several times per day, not once per several days. During the early formative/organizing stages of a project you will probably be committing several times per hour."
git,38ekzu,DanLynch,4,Wed Jun 3 21:25:06 2015 UTC,"Absolutely!  I've always read that if you can't summarize what you've done in one short sentence in the commit message, you've probably done too much.  There is absolutely no harm in commiting as often as possible. In fact, most of the things you can do with git work better, the more you've split up your work."
git,38ekzu,frigge,2,Wed Jun 3 22:15:31 2015 UTC,"if I start using it right from the start, it seems I would be performing many many commits.   There's no harm in that. Commit early and often. IF you feel the need later, you can rebase to squash multiple commits into one. (But for the love of all that is holy, do this before you push to your remote, as this changes your commit hashes.)  Overall, your workflow is correct. As /u/root45 noted, you will usually want to work in an isolated branch so that you can stash changes, isolate risk, context-switch, etc. without endangering your main code branch. (master)"
git,38ekzu,Matosawitko,1 point,Wed Jun 3 20:22:06 2015 UTC,"There are a number of workflows you can use with git, and which one kind of depends on what you're doing, whether you're in a team (and how that team collaborates), and what kind of tooling / infrastructure / automation you have.  As others have pointed out, making lots of commits is a non-issue (unless you have a lot of large binaries checked in that change with every commit, which is unlikely unless you're a game developer).  Generally you commit as often as you feel like, but in general if you can keep your commits restricted to covering one particular thing or change you'll thank yourself later. If you want to break up a set of changes after the fact, you can commit piecemeal using git commit -p.  In general, it's better to keep integrated with what other people are working on as frequently as possible without leaving the codebase in a wreck. This applies to software development in general, and not just git.  Integrate too infrequently, and you risk your team mates and you making conflicting or redundant changes - this tends to happen even if you're talking with each other frequently or pulling in their changes without pushing your own changes.  Integrate too frequently without good automation or CI infrastructure, and the code will be in a broken state too often to make real progress or figure out if it was you that broke it or someone else.  There should be a primary branch or version of the code that's kept in a more or less ""good"" state. In git, this is usually master, though if you're using git-flow it's develop (git-flow treats master like a floating release tag instead of a true branch).  Now, for workflow:  Always pull to make sure you're up-to-date before starting new work.  It sounds like you have at least one other team member. If you're both working on independent things, use separate branches. Always branch from the primary branch (usually master) if at all possible, don't start new work off a branch before it's been completed and merged.  When you're done, merge that back to master. Generally branches should be relatively short-lived because of the integration point I made earlier.  If you're working on something simultaneously (e.g. pair programming), you should both use the same branch, though you should still start from the known good state (i.e. master). You should pull to ensure everything's up-to-date before pushing in this case, especially if you have automated tests you can run. Git itself will actually block pushes if there are changes your local git repo hasn't seen yet, so you aren't likely to break anything if you forget, you'll just get an error message."
git,38ekzu,noratat,1 point,Thu Jun 4 03:06:57 2015 UTC,A lot of it is up to you ... don't worry too much prematurely just get something going and overtime you'll understand where and why things could be done differently
git,38ekzu,GFandango,1 point,Thu Jun 4 11:03:16 2015 UTC,"Remember that in Git branching is cheap, so the way that works best for me is kind of the best of both worlds:   Make sure your master branch is pulled so it's up to date Make a new branch for the particular feature you're adding or bug you're fixing Commit often in this new branch, until it's ready Go into the master branch and pull it again just in case anyone's made any other changes Rebase your branch off of the new master, so it's as if you made your changes after all that other stuff went live; check it still works Merge your new branch into master.  You can do this as a ""squashed"" commit which means that it's added as if you did the whole thing as one big commit on the master branch, instead of lots of little commits in the other branch.   I work on most projects solo so the method I use isn't quite this, but it's pretty similar, and I'd most likely make those changes if I was working with lots of other people."
git,38hcy1,casebash,8,Thu Jun 4 05:34:45 2015 UTC,Not open source and :   Requires Mac OS X 10.8 or later  Some features require creating a free account   Thanks but no thanks.
git,38hcy1,urquan,4,Thu Jun 4 11:57:25 2015 UTC,"Their first demo is about amending some random commits on master…  The interface seems nice. But besides that, i think it encourages evil behavior."
git,38hcy1,Aldarone,5,Thu Jun 4 07:02:34 2015 UTC,Related: Ungit on Github & quick demo.
git,38hcy1,vimishor,2,Thu Jun 4 09:53:01 2015 UTC,Not open source and OSX only... pretty lame.
git,38hcy1,brennanfee,2,Thu Jun 4 15:25:48 2015 UTC,"OS X only and closed source, grr"
git,38dl6x,palmin,8,Wed Jun 3 15:01:11 2015 UTC,"There's also git format-patch, git apply and git am to facilitate email exchange of patches / commits.  https://ariejan.net/2009/10/26/how-to-create-and-apply-a-patch-with-git/"
git,38dl6x,cpbills,5,Wed Jun 3 15:38:02 2015 UTC,For some reason I had the misconception that a patch could only contain a single commit. This sounds like exactly what I needed.  Thanks.
git,38dl6x,fdafasdfadfaf,3,Wed Jun 3 16:20:51 2015 UTC,That's how the kernel and git itself handle their workflow. One patch per email. As an example: http://thread.gmane.org/gmane.comp.version-control.git/270685
git,38dl6x,noratat,3,Wed Jun 3 17:41:48 2015 UTC,I have been living inside i GitHub PR bubble. :-)
git,38dl6x,keis,1 point,Wed Jun 3 18:43:09 2015 UTC,"Atlassian Stash and GitLab both have pull-request functionality that's similar to GitHub's, and FishEye can be used for just the code review / commenting part."
git,38eav7,Nexeo,8,Wed Jun 3 17:27:09 2015 UTC,"Says my screen is too small, that's one of the most amateurish things I've seen in a long while."
git,38eav7,kaaskop42,6,Wed Jun 3 21:28:50 2015 UTC,broken website
git,38eav7,Zokkar,8,Wed Jun 3 21:20:51 2015 UTC,"Sounds interesting, but that site is broken for me in chrome and safari. The ""Begin Tour"" button doesn't do anything in the former and is missing completely in the latter."
git,38eav7,kannonboy,2,Wed Jun 3 18:48:13 2015 UTC,Same for me.
git,38eav7,sfprogrammer,1 point,Wed Jun 3 19:19:49 2015 UTC,"http://gitprime.com/pricing $15 / Month / Active Contributor   Wow, that bites..."
git,38eav7,berenm,1 point,Fri Jun 5 09:15:37 2015 UTC,"I'm sorry guys, I linked to an out-dated tour/demo website that isn't available anymore. You can check out www.gitprime.com for the up-to-date site and intro!"
git,387cf0,Kwbmm,3,Tue Jun 2 11:10:37 2015 UTC,"Also, does it matter if the files I don't want to track anymore are currently tracked by git?   Git only checks .gitignore when it encounters a new, untracked file.  If you want to ignore a tracked file, you must first run ""`git rm --cache"" on it.  Git only uses the last applicable exclusion rule it finds.  I'm guessing that means that with a back-asswards approach to exclusion, the directory rules need to come before the file rules.  But that's just a guess."
git,387cf0,pi3832v2,2,Tue Jun 2 11:32:59 2015 UTC,"So I rather run that command, or manually delete each file I don't want to track.. Well, that's good to know for the future..   Git only uses the last applicable exclusion rule it finds. I'm guessing that means that with a back-asswards approach to exclusion, the directory rules need to come before the file rules. But that's just a guess.   I took that .gitignoresetup from here: http://stackoverflow.com/questions/987142/make-gitignore-ignore-everything-except-a-few-files  So it should work.."
git,387cf0,pi3832v2,3,Tue Jun 2 12:42:47 2015 UTC,"So I rather run that command, or manually delete each file I don't want to track.. Well, that's good to know for the future..   That command is for manually deleting each one.  I probably should've written it as, ""`git rm --cache [file-to-stop-tracking]""."
git,387cf0,pi3832v2,2,Tue Jun 2 13:30:57 2015 UTC,"I took that .gitignoresetup from here: http://stackoverflow.com/questions/987142/make-gitignore-ignore-everything-except-a-few-files  So it should work..   Maybe you stopped reading too soon? The comments on that question eventually lead to this answer: stackoverflow.com/questions/9162919/whitelisting-and-subdirectories-in-git/9227991#9227991.  I think you should at least try putting the subdirectory rule before the file rules, and see what happens."
git,387cf0,Kraigius,7,Tue Jun 2 13:39:02 2015 UTC,OP also forgot the wildcard on all of them. Only with .gitignore it is unnecessary.  # Ignore everything * # Whitelist subdirectories !*/  # Whitelist the following extensions !*.c !*.php !*.html !*.pdf !*.js !*.php !*.h !.gitignore
git,387cf0,pi3832v2,2,Tue Jun 2 16:13:08 2015 UTC,"Finally, how is the regexp support on git?    I know you've already got things working the way you want, but I just noticed something in the documentation for .gitignore, and I thought I'd mention it.  Apparently, Git doesn't do any regex for matching files, instead it “treats the pattern as a shell glob”.  (Re: gitignore(5) Manual Page.)"
git,387cf0,kwhali,0,Thu Jun 4 12:34:23 2015 UTC,Thank you! I figured regexp support was really poor when I tried to use $ to match the termination of the expression..  That a pity..
git,387cf0,Kraigius,1 point,Fri Jun 5 06:56:52 2015 UTC,Thank you all! I managed to get it working with your suggestions!
git,37wuo5,bulbishNYC,10,Sun May 31 01:48:37 2015 UTC,"A merge is a new commit. This happens, for example, if two people working on the project create commits at the same time, then pull (or merge) changes.  For example, if two people add commits without pulling or merging changes, they both have commits that don't exist in each others' repositories. Assume they both started with a repo ending in a commit we'll call ""A"". Person 1 adds a commit to their own called ""B"", and Person 2 adds a commit called ""C"". Their repos now look like this:  Person 1: A -> B Person 2: A -> C   Imagine Person 1 pushes their changes and then Person 2 pulls those changes. Git now needs to perform a merge, so (assuming there are no conflicts) Git creates a merge commit that we will call ""M"". Now the repo will look something like this:      -> B   /     \ A         -> M   \     /     -> C   ""M"" would be that merge commit that you are seeing. If no merge needs to happen, then no merge commit will be generated."
git,37wuo5,indenturedsmile,5,Sun May 31 02:08:02 2015 UTC,"If no merge needs to happen, then no merge commit will be generated.   It's also worth noting that there is an option to disallow ""fast-forward"" merges and always require an explicit merge commit.    git config branch.master.mergeoptions  ""--no-ff""    I believe that github has this enabled whenever you do a merge through their UI. It will always result in a merge commit, so long as you use the web interface to perform the merge.    If you do the merge locally and then push up to github, fast-forward merges will work as expected."
git,37wuo5,unhingedninja,1 point,Sun May 31 05:42:52 2015 UTC,"Ah, I didn't realize that GitHub enabled that by default. I'm of the opinion that --no-ff is not necessary, but that's good information to have."
git,37wuo5,indenturedsmile,2,Sun May 31 05:46:18 2015 UTC,"So now the resulting branch has 4 commits, right? A > B > C > M ?"
git,37wuo5,indenturedsmile,2,Sun May 31 02:31:12 2015 UTC,"Yes, that's correct."
git,37wuo5,m1ss1ontomars2k4,3,Sun May 31 02:58:33 2015 UTC,thanks!
git,37wuo5,rgarrett88,9,Sun May 31 03:18:23 2015 UTC,"It's not 100% accurate as you wrote it: there is no strict ordering between B and C. They both come after A and before M, but they have no relation to each other."
git,37wuo5,chimyx,0,Sun May 31 06:15:44 2015 UTC,It could be 100% accurate based on the time of the commits. You're being pedantic.
git,37wuo5,m1ss1ontomars2k4,3,Sun May 31 15:15:13 2015 UTC,"No, he's right. Time of commit isn't a reliable information. If the system clock of one of the devs is wrong, it'll be wrong. Also, if you use rebase to rearrange you tree, time of commits will be unchanged while their order may be. A merge commit is a commit with two parent commits. These parent commits don't have any precedence towards each other."
git,37wuo5,chimyx,2,Sun May 31 19:20:42 2015 UTC,"These parent commits don't have any precedence towards each other.   I believe they can (for example, if one parent is a merge commit, one of whose parents is the other parent of the new merge commit), but that's not what's happening here."
git,37wuo5,m1ss1ontomars2k4,1 point,Sun May 31 19:52:59 2015 UTC,Why would you merge a merge commit with one of its parents?
git,37wuo5,m1ss1ontomars2k4,1 point,Sun May 31 19:59:33 2015 UTC,"I'm pretty sure the Android auto-merger at least occasionally does this in an automated fashion.  EDIT: Also will happen frequently if you use --no-ff, I guess."
git,37wuo5,rgarrett88,2,Sun May 31 20:04:52 2015 UTC,"It could be 100% accurate, if we were talking purely about commit times, which we are not, since that would be meaningless and would imply orderings such as B > C where they do not exist.  If you look at the parent and child commits of B and C, they will not include the other, since that wouldn't make sense. The parent of B is A, and the child of B is M. The parent of C is A, and the child of C is M. That's it. There's no directy relation between B and C at all.  You can feel free to discuss which one came first temporally in a separate discussion."
git,37wuo5,m1ss1ontomars2k4,0,Sun May 31 19:52:47 2015 UTC,"It not really clear that he thinks B is the parent of C. If you were to type git log how would the commits be displayed? M C B A.  You're correct, it just seems like an unimportant and pedantic clarification to introduce to someone learning git."
git,37wuo5,indenturedsmile,1 point,Sun May 31 23:04:41 2015 UTC,"It not really clear that he thinks B is the parent of C.   So, let's make sure he doesn't.   If you were to type git log how would the commits be displayed? M C B A.   It might be displayed M B C A also.   it just seems like an unimportant and pedantic clarification to introduce to someone learning git.   Glossing over ""the little things"" when learning a topic leads to confusion later on. For instance, does OP think that time on the commit has anything to do with the ordering? Maybe, maybe not. Maybe if he thinks it does, sometime in the future he'll be trying some advanced rebase or similar command, only to have it go terribly wrong because he's always thought that the time DID have something to do with the ordering. Or maybe he'll have difficulty understanding Gerrit, where both the time stamps are used for different purposes."
git,37wuo5,unhingedninja,2,Mon Jun 1 08:32:17 2015 UTC,"Definitely check out the Pro Git book, specifically the chapters on exactly what a commit is and what a branch is."
git,37wuo5,frigge,1 point,Sun May 31 03:46:47 2015 UTC,"Another question I have. Say, we have branch B1 and branch B2.  B1 is A->B->C->D B2 is A->F->G->H       we merge B1 into B2 and end up with something like this: A->B->F->C->D->G->H->M  Now, after I merge B1 into B2 then change my mind and realize it was a bad idea, and I still want B2 without any of the B1 commits. How do I create a new branch that is the same as B2 per-merge? If I go to current B2 and create a branch from commit H this will include all commits prior to H( A->B->F->C->D->G->H)? But I do not want commits B,C,D. How do I get the original branch back that is not contaminated with B1 commits?"
git,37uvcj,bentolor,1 point,Sat May 30 16:22:07 2015 UTC,"Just stumbled over this proof-of-concept implementation, which already looks beautiful and seems to be really usable to average users.   The (unminified) source code is a little bit hidden in the development branch on the original client repo"
git,37rf9y,nivwusquorum,4,Fri May 29 20:03:56 2015 UTC,A tldr on how to use it? ;-)
git,37rf9y,maredsous10,3,Sat May 30 01:53:47 2015 UTC,More Details and Usage https://github.com/cjb/GitTorrent      Looks like its written in javascript.
git,37luf5,matasbeard,3,Thu May 28 15:51:49 2015 UTC,You need to merge or cherry-pick that commit back onto master.
git,37luf5,xiongchiamiov,1 point,Thu May 28 16:23:58 2015 UTC,I didn't know about cherry-picking and it worked. Thank you.
git,37luf5,adrianmonk,3,Thu May 28 19:45:42 2015 UTC,"Sounds like you merely committed to the wrong branch. When you run ""git push"", it normally only sends what's on one branch (in your case, probably ""master""), so your changes aren't visible on github.  You should probably be able to recover by doing this:  git checkout master git log other-branch # find the hexadecimal id of commit you accidentally made git cherry-pick abcd1234 git push   If you made other changes in that same commit, things get more complicated.  You also ought to consider whether you want that commit to still exist on the other branch. If not (and if you have not pushed the branch anywhere else, which it sounds like you haven't), you could fix that with ""git rebase -i"", which is a little daunting if you haven't used it before, but it should work. If you don't mind having that change on the other branch, you can just leave it there."
git,37luf5,Campers,3,Thu May 28 18:22:13 2015 UTC,"TIL about cherry picking! And yeah, I did commit to the wrong branch. This worked like a charm. Thank you! :)"
git,37luf5,Livesinthefuture,1 point,Thu May 28 19:43:53 2015 UTC,Are you sure you are not looking at different branches in github and in your local repository?
git,37luf5,cenderis,1 point,Thu May 28 16:12:26 2015 UTC,"I presume so because on github, it shows only one branch existing for that repo, that branch being the master."
git,37fyrj,mortymer,7,Wed May 27 10:18:52 2015 UTC,"Use the same repo, different branches.  I don't understand why you need two repos."
git,37fyrj,e40,3,Wed May 27 13:52:49 2015 UTC,"Clone the your first repo and have a second one that can evolve independently.  Keep the first repo as a remote in the second. If you make any changes to the template, merge or cherry pick the changes into the second from first."
git,37ehue,R9GsPvy4qgHgwStudP7E,1 point,Wed May 27 01:11:43 2015 UTC,"Can you link us to the pull request in question? You resolved the conflicts with the branch you're trying to merge your current branch into, but it still can't merge? Did you push the result?"
git,37ehue,wormnut,1 point,Wed May 27 02:07:21 2015 UTC,"fixed, see edit"
git,37age4,PortableDinosaur,2,Tue May 26 04:26:09 2015 UTC,"if two people are working on two projects (a web app vs a mobile app) and we both push/commit one of our commits will override the other.   I'm not sure I follow here. Submodules model dependencies, and it's best to think of them as 3rd-party dependencies. Whenever I go into a submodule, I presume I work at another company, and don't know anything about the code depending on me, and I've just received a feature request. I think about how to add it without disrupting the rest of the repo, then do so without breaking any of my tests. Then I push it out, because if it's not pushed out, my other code can't see it. It hasn't been published to the world yet. Once it's pushed, then I can go out to my dependent repo again, put on my other hat/job, make a feature branch, fetch in the changes, merge up to where I feel comfortable, fix my code against those changes (if necessary, committing the fixes if so), then merge back to master and push.  It's a pain, because it is a pain. Whenever a 3rd party updates their dependency, you need to update your code against it. The great thing about submodules vs. dot releases is the granularity. You can update exactly to where you want, and leave it there. If you stop updating your code, you can leave it pointed to whatever commit it's on, forever, and the dependency/submodule will stay right where it is along with it. The reality is more harsh: if a hotfix for some dangerous vulnerability comes in a thousand commits later, you have to either merge 1000 commits and fix against them, or replicate the fix on a branch off of the submodule's commit you were on, and probably leave that newly-grown branch dangling there locally from then on. Versioning is hard."
git,37age4,gfixler,1 point,Tue May 26 09:07:42 2015 UTC,"Yeah and I think that since all of our programs are so interdependent on each other, the problem is when we try to do work on different submodules and we can't keep the repo clean and organized in any fashion. The API was all user built, and not by me, so all the code I'm working on is not my own. My job for now is just to clean the repo so that we can have different production and development versions of all our stuff."
git,37age4,gfixler,1 point,Tue May 26 17:09:21 2015 UTC,Maybe I need to more deeply understand the problem.
git,37age4,paleowannabe,1 point,Tue May 26 17:09:47 2015 UTC,"Don't we all :)  It sounds like the biggest problem is a lack of communication - super common, and always awful.  Fowler's book may help with the disentanglement efforts."
git,37age4,shampine,1 point,Tue May 26 18:09:22 2015 UTC,"Submodules can track specific branches now, as far as I remember. Perhaps you should have in the Submodules repos a superproject? PM me, and we can try to work this situation out"
git,376z83,infinitysgame,11,Mon May 25 11:38:16 2015 UTC,"I use Git (mostly just to act as backup software) when I write academic papers.  I've been using markdown formatting in plain text files for composition and revision, and Git works well with that.  (I feed those into pandoc to make PDFs when I need something I can print.)  And since GitHub will render markdown files, I can also use Git to push things up to there and then I have a link to share my progress with my academic advisor or whatever.  I think Git could be an excellent way to collaborate on a paper, but I haven't yet found anyone who wants to collaborate with me and is also comfortable with Git."
git,376z83,pi3832v2,1 point,Mon May 25 15:18:16 2015 UTC,Checkout zim wiki if you haven't already. It's a GUI for markdown notes. There a plugin to do auto commits in git too. I also have a daily cron job to commit them.
git,376z83,r0ck0,2,Tue May 26 01:11:17 2015 UTC,Zim is awesome
git,376z83,okmkz,1 point,Tue May 26 03:30:32 2015 UTC,Did you look at asciidoc instead of markdown? I always find markdown (and restructuredtext) too restrictive for anything more than a quick readme file. How do you handle tables?
git,376z83,its_never_lupus,1 point,Tue May 26 16:51:25 2015 UTC,"I never looked at alternatives.  I'd been using markdown for notes/summaries because I was already familiar with it (from /r/reddit) and GitHub supports it.  So when I started turning those things into parts of papers, it was convenient to just keep using markdown.  You can do basic tables in GitHub-flavored markdown.  For anything beyond that, I use HTML.  You're right that markdown is rather limited.  But it's also very simple, and it's been sufficient for my needs so far."
git,376z83,pi3832v2,-1,Tue May 26 18:07:47 2015 UTC,That's not unusual/unconventional. Everybody does that.
git,376z83,dAnjou,7,Tue May 26 18:56:21 2015 UTC,"Well, I use git to keep track of my multiple Kerbal Space Program installs. I've never had another repo where git checkout takes half a minute (on an SSD)."
git,376z83,MadTux,1 point,Mon May 25 12:59:58 2015 UTC,I use it for The Long Dark.
git,376z83,artard,1 point,Mon May 25 13:38:59 2015 UTC,And I for Terraria.
git,376z83,Nevik42,5,Tue May 26 06:41:22 2015 UTC,"Not my project, but some guy uses git to distribute the french civil code, criminal law and criminal procedure on github. It's quite handy to see the law through a revision control system with a commit for every change, I wish governments would to it by themselves."
git,376z83,RodolpheB,3,Tue May 26 10:21:03 2015 UTC,As a bug tracker
git,376z83,MadTux,3,Mon May 25 12:05:52 2015 UTC,A friend I know started using it for writing song lyrics!
git,376z83,LifeBeginsAt10kRPM,0,Mon May 25 14:32:23 2015 UTC,Is that really so unconventional? I track all my Lilypond music writing with git.
git,376z83,Nevik42,1 point,Mon May 25 15:39:12 2015 UTC,I think it's safe to say anything  that isn't a code repository would be unconventional for git..
git,376z83,MadTux,1 point,Tue May 26 00:20:23 2015 UTC,"Actually, no. Git is explicitly a content tracker -- it specializes in any form of text-based content (and this specialization is purely technical, because the compression in use works best on text files)."
git,376z83,LifeBeginsAt10kRPM,1 point,Tue May 26 06:42:31 2015 UTC,"Also, Lilypond is code (or do markup languages not count as code?)."
git,376z83,dAnjou,1 point,Tue May 26 06:46:34 2015 UTC,Good to know!! I've never heard or have seen it used outside of the programming world..
git,376z83,chocolate_bread,1 point,Tue May 26 10:44:58 2015 UTC,"I think in this question ""git"" just stands for any VCS. Wikipedia uses version control for articles and StackExchange uses it for questions and answers. So, yeah ..."
git,376z83,oonniioonn,3,Tue May 26 19:02:02 2015 UTC,"Hosting and updating dns records, albeit via a third-party."
git,376z83,chocolate_bread,1 point,Mon May 25 19:31:53 2015 UTC,"dns records   Using tinydns format and not supporting basic records like SRV is, if you ask me, pretty terrible. Shame because I thought the idea was interesting."
git,376z83,Nirenjan,1 point,Tue May 26 23:47:49 2015 UTC,"When I started I figured I'd support both TinyDNS (which I was using myself), and bind zonefiles (as the standard).  But nobody has asked for the latter yet.    Maybe people have just ruled me out because it was missing, but if a paying client wants it then it will happen.  Even if it is via some horrid hack behind the scenes (such as via a trivial bind -> tinydns conversion).  Edit: SRV support is now documented."
git,376z83,wilhelmtell,2,Wed May 27 07:09:09 2015 UTC,"Interestingly enough, I wrote a script that saves a journal as a Git branch - each entry is a commit pointing to the previous entry. This was really an attempt at (ab)using the Git plumbing commands to do my bidding.  You can find the source code here - https://github.com/nirenjan/overlord"
git,376z83,Nevik42,2,Mon May 25 18:49:40 2015 UTC,"I wrote a distributed micro blogging platform a while back:  https://github.com/wilhelmtell/dis  It's fairly small and is based on Git. The posts are essentially Git commits, and the feed is a custom-formatted Git log.  Also, but not mine, slides:  https://github.com/gelisam/git-slides  This is a slides tool for presentations and demos, based on Vim and Git."
git,376z83,gfixler,2,Tue May 26 00:39:38 2015 UTC,"I recently implemented a proof-of-concept of using Git as a database for tracking timestamped data.  If you're thinking in RDBMS terms, the top folder level in the repo was the tables, the path of each file was the row, the filename the column and the file content the field value.  Since it was only a proof of concept, it was implemented on top of porcelain commands, putting all the data into files on the filesystem, and creating regular commits (albeit with specifically set timestamps), etc.  A next step would have been to go deeper and use plumbing commands.  We abandoned the idea in favor of a regular RDBMS because it gave us no real edge, and using a non-bare repository wasted huge amounts of disk space (due to the large number of folders, which each take 4KB on the ext4-filesystem on which we tested this).  With plumbing commands, we could probably have run this directly on a bare repo (index and conflict resolution were never used), which was a lot more compact than the working copy.  Nevertheless, it was fun to implement, and I got more familiar with some of the not-so-everyday Git commands :)"
git,376z83,Zalozba,2,Tue May 26 06:48:49 2015 UTC,I'll just share my response to the last version of this post.
git,376z83,QuantumRiff,1 point,Tue May 26 10:50:07 2015 UTC,I use it for all my promotion emails. Each new promotion is a new branch. If I ever need the same promotion  I just checkout the relevant branch.
git,36w8q5,balkierode,3,Fri May 22 17:13:41 2015 UTC,I love the stats page; basically a list of stupid people.
git,36uy7h,kajjiNai,4,Fri May 22 09:34:49 2015 UTC,Did you revert a merge recently?
git,36uy7h,hitex,0,Fri May 22 10:40:25 2015 UTC,Yes. I did. Does it matter?
git,36uy7h,hitex,5,Fri May 22 11:30:12 2015 UTC,"Yes, it matters. There is a quirk in git with reverting merges. If you want to merge back to master, you need to revert that revert on master and then merge your branch.  You can read more about why this happens in section ""Reverting the Revert"" at https://git-scm.com/blog/2010/03/02/undoing-merges.html"
git,36uy7h,oconnor663,0,Fri May 22 11:47:57 2015 UTC,Good catch! Learned something today.
git,36uy7h,untitleddocument37,0,Fri May 22 12:48:49 2015 UTC,"Either the file is untracked or you commit it against master.  Do a ""git log $filename"" and see if it has history on master."
git,36oviy,ChristianGeek,4,Wed May 20 23:27:36 2015 UTC,"We have a very similar environment, with one repo per sub-project. We have our own in-house wrapper script that clones all the sub-projects and handles dependencies among the sub-projects. I don't know the details of it, but I do know it uses the repo tool (from Android) for handling the multiple repos."
git,36oviy,Nirenjan,1 point,Thu May 21 01:03:00 2015 UTC,The repo tool looks interesting...thanks.
git,36oviy,dohmer_simpson,2,Thu May 21 01:23:07 2015 UTC,"If you're interested in tying different projects together look at ""mr"", which is a multi-repository tool.  It allows you to checkout, update, etc, multiple repositories together:   http://myrepos.branchable.com/   For bonus points it works with git, subversion, mercurial, & etc."
git,36oviy,DanLynch,3,Thu May 21 07:55:50 2015 UTC,"If you're familiar with the Subversion ""standard directory structure"", then it may help to think of Git as making that structure not just standard, but mandatory. It does this by making branches and tags into core concepts, not directories with a naming convention. So, that also means each repository can really only have one ""set"" of trunk/branches/tags, and should therefore really only contain one ""project"".  There are a lot of ways to get around this and do fancy stuff, but really, the way Git is designed to be used, is to have one repository for each independent project. And, in this context, the most important indicator of ""independence"" is a desire (and the logical capacity) for separate branching, tagging, and/or releasing.  For your code, it sounds like you really could go either way: have all your code form a single project with a unified branching and release cycle, or split it into four projects, each with their own branching and release cycle.  Of course, splitting your code into four projects would come with some overhead costs: you would need to carefully track versions and dependencies across all four (e.g. version X of project A depends on version Y of project B). As an extreme case, consider that the Android Open Source Project includes code from hundreds of separate Git repositories in each release, so they actually created a special software tool to oversee their Git repositories and manage, version, and track all those interdependencies!  One thing you should not consider is having your four different projects in the same repo, but in different branches. That's really not what branches are in Git: they are not like directories (that idea is specific to Subversion). You can physically do this using the tool, but it's really just plain wrong™."
git,36oviy,unkz,1 point,Thu May 21 01:14:08 2015 UTC,"Thanks, you've convinced me to go with multiple repos and I'm looking int the Android project now."
git,36oviy,unkz,2,Thu May 21 01:25:03 2015 UTC,"I would think 4 repositories, with the shared one in a submodule.  That's basically the textbook case."
git,36oviy,hevakmai,1 point,Thu May 21 03:45:36 2015 UTC,"A submodule isn't going to work, because the shared code is being developed alongside the other modules. From my reading, submodules work best with static code, or a snapshot of dynamic code."
git,36oviy,LifeBeginsAt10kRPM,3,Thu May 21 17:54:40 2015 UTC,"That's fine, you can commit/push/pull inside your submodule directory just like any other repo as long as you check out a branch in your submodule.  Then you merge changes in with  git submodule update --remote --merge  The manual actually goes into detail on this particular, common use case:  https://git-scm.com/book/en/v2/Git-Tools-Submodules   It’s quite likely that if you’re using submodules, you’re doing so because you really want to work on the code in the submodule at the same time as you’re working on the code in the main project (or across several submodules). Otherwise you would probably instead be using a simpler dependency management system (such as Maven or Rubygems).  So now let’s go through an example of making changes to the submodule at the same time as the main project and committing and publishing those changes at the same time.   ..."
git,36oviy,bearrus,1 point,Thu May 21 18:18:35 2015 UTC,"Yeah, I find submodules make it easy to iterate on both repos together, you just have to be aware that operations on each repo happen generally independently.  There isn't a steep learning curve either since submodules act exactly like a git repo when you cd into them."
git,36oviy,Qazzian,2,Fri May 22 04:05:02 2015 UTC,Multiple repos and submodules where needed?
git,36oviy,aeontech,3,Thu May 21 01:37:07 2015 UTC,"I would advise against submodules. At least unless you understand exactly what the consequences are and what submodules are designed to do, and what they are not. I am a bit lazy to look for links, but there is a lot of information available.  In my experience it was not worth the pain of changed workflow. It is better to use completely separate repos, and glue them together either with your own scripts, or by reusing existing solutions. I think not using submodules also helps with decoupling, because you have to write your project without dependencies present in project subdirectories."
git,36pvdx,Jack126Guy,8,Thu May 21 04:14:15 2015 UTC,Are you sure you switched to the new branch before committing? The git branch command does not checkout the new branch.  Try git checkout to the new branch and see if the files are there.
git,36pvdx,pi3832v2,1 point,Thu May 21 04:21:08 2015 UTC,You got it. Thanks for the help!
git,36o5j6,nobrandheroes,5,Wed May 20 20:27:02 2015 UTC,You're probably versioning files that shouldn't be versioned if you're worrying about space considerations.  What's your use-case to be having such large files in your repository?
git,36o5j6,pushad,1 point,Wed May 20 20:55:17 2015 UTC,It's just text-based scripts mostly. The repository is just going to be on a hard with very little space.
git,36o5j6,jakkarth,2,Thu May 21 00:09:36 2015 UTC,That's essentially correct.
git,36o5j6,DanLynch,1 point,Wed May 20 20:31:51 2015 UTC,Thanks.
git,36o5j6,DanLynch,2,Wed May 20 20:45:08 2015 UTC,"If you are using Git to track changes to large binary files, you will not benefit from the techniques that Git uses to avoid data storage waste. Git is designed to efficiently store small text files only; if you choose to store and track changes to large non-text files, all sorts of awful space-wasting will inevitably occur.  A good rule of thumb is that if a file cannot be opened (and safely and meaningfully edited) using the text editor that comes with your operating system (e.g. Notepad for Windows), then storing it in Git will probably result in pain."
git,36o5j6,DanLynch,1 point,Wed May 20 21:36:48 2015 UTC,"Not tracking anything but text and a few images(web application), but there just isn't much space nor an opportunity to increase it in the near future, so I'm just trying to plan for the eventual filesize."
git,36o5j6,AMDmi3,1 point,Thu May 21 00:11:08 2015 UTC,"OK, but how little space are we really talking about here? Assuming he types at the equivalent of 100 words per minute, 24 hours a day (LOL) a typist can only produce about 250 megabytes of text per year.  If you keep your images under source control, they will also take up as much space as they take up. Every time you add a new image, it will take up that much more space. Every time you change one of the existing images, additional space will be used up to keep both the old and the new version, forever. If you change the same 1-megabyte image every day, after one year you will have 365 megabytes of storage dedicated to that image and its history.  Git doesn't really add much overhead to the material being kept in source control. The extra space consumption simply comes from the need to keep every old version of every file. The number of branches doesn't matter, only the number of different versions for each file that need to be kept."
git,36mbv2,Smokey_Circles,3,Wed May 20 13:01:52 2015 UTC,Try running  git check-ignore -v path/to/gradle-wrapper.jar   This should show you the file and line causing the file to be ignored. My guess is that your gradle-wrapper.jar file is in a subdirectory that is being entirely ignored.
git,36mbv2,ccharles,2,Wed May 20 14:35:53 2015 UTC,I had no idea about this function :O   Thank you!
git,36mbv2,jakkarth,3,Wed May 20 14:41:45 2015 UTC,"I'm no expert, but it looks like you ignore it on line 30 and then include it again on line 31. Try swapping the order of those two lines?"
git,36mbv2,pi3832v2,2,Wed May 20 13:05:09 2015 UTC,"Yep, the order of the lines is probably the issue.  From the gitignore(5) Manual Page:   Each line in a gitignore file specifies a pattern. When deciding whether to ignore a path, git normally checks gitignore patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):   Patterns read from the command line for those commands that support them.  Patterns read from a .gitignore file in the same directory as the path, or in any parent directory, with patterns in the higher level files (up to the toplevel of the work tree) being overridden by those in lower level files down to the directory containing the file.  Patterns read from $GIT_DIR/info/exclude.  Patterns read from the file specified by the configuration variable core.excludesfile."
git,36mbv2,Nevik42,1 point,Wed May 20 14:13:59 2015 UTC,"Turns out it was this and something I am not sure about  I moved the line back to being under all jar files. No dice.   Then I noticed the in line # comment. I deleted that and boom suddenly I have an untracked file... I doubt git registers # as a comment unless it's the first character in the line, but it maybe it freaks it out a little bit if it finds it in line  Nonetheless I wouldn't have looked at the line without the suggestion, thanks guys :)"
git,36knbb,Somedude2024,3,Wed May 20 02:08:50 2015 UTC,Did you push?
git,36knbb,jakkarth,1 point,Wed May 20 02:17:17 2015 UTC,When I push I get everything is in order. It doesn't work.   -sh-4.1$ git push origin master Everything up-to-date
git,36knbb,jakkarth,5,Wed May 20 02:22:35 2015 UTC,"That matches up with the results of your ls-remote output. You'll note that all of the remote hashes are identical to the local ones.  So you go to /dev, and you look at the files there, and none of the changes you made committed and pushed are showing up, right? That's because your push only updates the contents of /dev/.git/, not the working tree in /dev. You'd need to go to /dev and tell git to check out the latest version of your branch to see the changes. You can see this by going to /dev and running git status."
git,36knbb,Bkil,1 point,Wed May 20 04:24:49 2015 UTC,"This makes sense. Also, after some further reading, I realized that the /dev is a bare git repository.   So we have /dev.git and /dev.code.   When I do a clone from /dev.git it shows all my latest code, but it doesn't show up in the dev.code.  As I am fairly new to git, I am sure there's a way for me to update the dev.code folder with the latest files.   Also, for whatever reason I can't do git status under the /dev.git directory."
git,36knbb,Smokey_Circles,1 point,Wed May 20 14:34:37 2015 UTC,What repository is that command run in? In /dev or /home?
git,36dm11,durdn,2,Mon May 18 15:29:49 2015 UTC,"I like the workflows this creates better than the equivalents from git submodule, particularly the way that other users of the repo never need to interact with the subtree unless they're pulling or pushing. Shame it's not better supported. (AFAIK, subtrees are more-or-less officially deprecated in favour of submodules, despite not really being fully equivalent.)"
git,36dm11,tobascodagama,2,Tue May 19 01:44:20 2015 UTC,"Eh, wasn't submodule in git before subtree was conceived? Regardless, part of the issue is that subtree is in contrib/, rather than a core part of the git system. It's an appropriate place for it to be, of course, because it was initiated as an external project and it's not mature enough to be a core part of the git system, but in contrib/ it doesn't really get the attention it needs to mature, partly because it isn't of great interest to the active devs, and the dev who started it way back when doesn't seem to be around any more.  I'm planning on doing some work on it soon, though, after my exams are finished, so about six weeks time. It'd need to start with a design discussion, though, to solidify the use cases and desired behaviour of subtree, in order to work out its future and such, because while there's a lot of unchampioned patches to work on, blindly championing them would lead to a messy, confusing, inconsistent subtree command."
git,36hwcv,cpbills,10,Tue May 19 14:42:01 2015 UTC,What is Google?
git,36hwcv,jakkarth,4,Tue May 19 17:02:24 2015 UTC,Git is a distributed version control system designed to make managing software development easier. You should use it to help keep track of changes you make to your software and to collaborate with other developers. You get it from http://git-scm.com.
git,36hwcv,sciguyCO,2,Tue May 19 14:44:32 2015 UTC,I came across a blog post that for me helped to cement some of the underlying concepts / design choices / philosophy of git that might help:  The Git Parable  It's a story in which you (as the developer protagonist) encounter problems and implement solutions a bit at a time until you end up with something equivalent to git.  Each step helps to give context to git's implementations rather than just going through a typical workflow where commands are just listed.
git,36hwcv,gammadistribution,-2,Tue May 19 15:54:19 2015 UTC,How do I use it on Linux? And what are its most used functions?
git,36cosg,GarethX,1 point,Mon May 18 09:30:37 2015 UTC,"I guess I'm missing some context, because I have no idea what this tool is for."
git,36cosg,DanLynch,1 point,Mon May 18 10:30:05 2015 UTC,Seems to be about this:  http://mercurial.selenic.com/wiki/Infocalypse
git,36avnu,Apophis775,5,Sun May 17 21:43:38 2015 UTC,"Can't be done, unless you manually ignore modified the files each time you ""add"". Best solution would be to create files like ""admin.txt.default"", add those to source control, and then put admin.txt in the gitignore."
git,36avnu,nemec,5,Sun May 17 22:41:32 2015 UTC,*.default is probably the most obvious choice here. It's a pretty common pattern
git,36avnu,okmkz,2,Mon May 18 02:11:00 2015 UTC,"you will have to both ignore the files and remove them from the repo. if you need development variants of those files separate from production, you could make separate folders for them and then only ignore the prod folder add add logic to your code to read from relevant folder depending if it's development or production environment."
git,36avnu,mick88,2,Sun May 17 22:04:07 2015 UTC,"You post is a little confusing, but I think I have the gist of it.  I suspect the files in version control should be in version control, with all that entails.  I mean, let's assume you managed to organise it such that the files existed in the repo but changes couldn't be checked back in - how will you ever edit them in the future?  If these files need to be treated differently because of how they are interpreted by the game, that sounds like a problem better solved in the game, not in git.  How about keeping the base/default versions of these files in a different directory and copy them to the place the game expects them to be in on first run?  Or if these files are expected to be edited by the end-user, maybe have ""motd.txt.default"" etc files, and require the person setting it up to duplicate and edit the files as required.  Then you can safely .gitignore the edited files, still keeping the default versions of the files under version control."
git,36avnu,cfmdobbie,2,Sun May 17 22:05:59 2015 UTC,"You are looking for git update-index --assume-unchanged, which lets you edit files and have git act as though you haven't.  You might be interested in this snippet from my ~/.gitconfig:  [alias]   # Assume-unchanged:   assume = update-index --assume-unchanged   unassume = update-index --no-assume-unchanged   assumed = ""!git ls-files -v | grep ^h | cut -c 3-""  # list assumed files   unassumeall = ""!git assumed | xargs git update-index --no-assume-unchanged""   assumeall = ""!git status -s | awk {'print $2'} | xargs git assume""   (In case it isn't clear, first you git assume ... some files; then you can edit them and git will act as though they still contain the defaults that you've previously committed to the repository.  You can use git assumed to list the files you've marked this way, and unassume to unmark them.)"
git,36avnu,lunarsunrise,1 point,Sun May 17 22:37:05 2015 UTC,"I've been using this, but now, i change checkout different braches with git for windows"
git,36avnu,nevinera,1 point,Mon May 18 00:06:25 2015 UTC,"gitignore tells git to ignore the files - they are no longer in the repo, just on your file system. It's not called gitignorechanges.  I can't tell exactly from your description whether you're implementing push-to-deploy, or have a central repo and your deploy process is to ssh to the server and do a pull from there.  Either way, you should probably have the default config file in the repo, and use an environment variable to optionally supply a different location at which to find a config file that overrides those defaults. If you have more than one config file, just use more than one environment variable. At its core, a version-control system is not for implementing behaviors, it's for managing versions of a file tree - if you want more than ""these files exist, with those contents"", you probably ought to use something external to the tool.  If you're on windows, I don't know what the equivalent to an environment variable is there, but I'm sure there's something."
git,36avnu,isarl,1 point,Mon May 18 00:26:00 2015 UTC,"As others have said, you can't use a .gitignore to ignore changes to tracked files. You can do it with git update-index --assume-unchanged but, take it from somebody with experience, using this flag is just begging for head-scratching bugs when changes you made to a file never got committed because you forgot to --no-assume-unchanged.  The best way I've seen to do this involves three files:   base config file (e.g. ""base.conf""); config file with private variables (e.g. ""user.conf""); sample config file (e.g. ""user.conf.sample"").   user.conf is untracked, it's not in your repository except as an entry in the .gitignore file. Instead, you write base.conf to look for user.conf, and if it doesn't exist, base.conf instead loads sensible defaults from user.conf.sample. (Perhaps instead of pointing to the production db it points to localhost so that it's easy for a developer to set it up for test in their dev environment.)  You can also write base.conf to fail if it doesn't find user.conf. Depends on how you want to design it."
git,362rsu,nobrandheroes,21,Fri May 15 16:43:39 2015 UTC,"Git exists specifically because having multiple people work inside a single checkout of a repository is a terrible idea. There is an argument to be made for having your dev server be used as a central repo just like you're using bitbucket for now, but that's not the same thing. Each developer should have a local repository on their own machine where they do their hacking, and then you can push to the dev server to test it/collaborate if necessary."
git,362rsu,jakkarth,5,Fri May 15 16:51:29 2015 UTC,"I agree, the other developer has been lagging on this months, and the Directory who doesn't code just says ""**** it"" and put VC on the server, which is the opposite direction of where we should be going.  Ironically, he's going to be using PHPStorm so he's going to need a local copy anyways."
git,362rsu,m0okz,10,Fri May 15 17:54:51 2015 UTC,You need to have a serious talk with your boss and explain how Git works.
git,362rsu,slappingpenguins,-9,Fri May 15 22:29:53 2015 UTC,and to stop using PHP
git,362rsu,m0okz,3,Sat May 16 13:39:10 2015 UTC,In favour of what exactly?
git,362rsu,slappingpenguins,0,Sat May 16 17:48:25 2015 UTC,"ASP MVC or Java, or Nodejs, Django(python), Sinatra (ruby) if they are settled on scripting languages."
git,362rsu,m0okz,3,Sun May 17 13:34:29 2015 UTC,You bash PHP and come back with ASP? Get out of here.
git,362rsu,slappingpenguins,-1,Sun May 17 14:38:02 2015 UTC,Enjoy http://www.asp.net/mvc/mvc5
git,362rsu,m0okz,2,Sun May 17 14:52:42 2015 UTC,How does it run in any of the billions of linux machines?
git,362rsu,slappingpenguins,-1,Sun May 17 18:27:28 2015 UTC,"Mono Framework: https://en.wikipedia.org/wiki/Mono_%28software%29  AWS also offers Windows instances, and Azure is about same price as AWS too. Microsoft also recently announced a new incarnation of ASP.net that is open-source and meant to also run on Linux and OS X. http://www.asp.net/vnext"
git,362rsu,tuncOfGrayLake,18,Mon May 18 01:49:22 2015 UTC,"I always enjoy doing this thing where I come across with my hands up in the air. Here's what I mean.  I'll tell my 'boss', hey here's what you want to do and I'm ready to do it. If you don't agree with what I want to say I will do as you like, no problems. I think it's a better idea to do it the other way, because of fact.  Don't patronize, don't confuse with bullshit terms, be clear and make sure he understands everyone's life will be easier the right way by talking his language. You have to feel him out and find out why his persistent on the issue. People are not persistent on things without a compelling reason even if that reason may sound insignificant to you.  You will look responsible because you care about the issue. You will look like a team-player because you're ready to listen to your 'team commander'. You will look like someone to trust and listen to if things go wrong with their way.  This ain't a git problem yo, this is a communication issue."
git,362rsu,Manitcor,16,Fri May 15 18:54:00 2015 UTC,Please for all that is good and holy get a real CI process. From dev to prod? That's a damn tightrope act every day.
git,362rsu,chishiki,2,Fri May 15 18:17:44 2015 UTC,"You have no idea. I set up Jenkins for us sometime ago, and QA machines are in the queue."
git,362rsu,pi3832v2,6,Fri May 15 20:00:11 2015 UTC,The company I work for just laid off the QA department. LOL. Not sure they thought that one through.
git,362rsu,pi3832v2,5,Fri May 15 21:55:29 2015 UTC,"To make it easier for the other developer, he wants [Git] on the dev server…  Anyone ever do this? A small team of devs writing directly to and committing from the dev server?   It seems like maybe someone (or everyone) is confused about Git repositories, and how you sync branches between them.    What do you mean by ""writing directly to… the dev server""?  Will they log into a shell on the remote server, change directories into the tree of the Git repository and do all their work in there?  And what does ""committing from the dev server"" mean? Committing what? To where?"
git,362rsu,scottchiefbaker,2,Fri May 15 17:23:38 2015 UTC,"Basically Yes? I'll update the question, but I think you get the idea."
git,362rsu,slappingpenguins,9,Fri May 15 17:43:27 2015 UTC,"Oh dear lord.  A “remote” repository doesn't necessarily need to be on a separate host.  It can merely be in some other directory on the same machine.  E.g.:  $ mkdir foobar $ cd foobar $ git init Initialized empty Git repository in foobar/.git/  $ cd .. $ git clone foobar barfoo Cloning into 'barfoo'... warning: You appear to have cloned an empty repository. done.  $ cd barfoo $ cat .git/config  [core] … … … [remote ""origin""]     url = {{full path}}/foobar     fetch = +refs/heads/*:refs/remotes/origin/* [branch ""master""]     remote = origin $    So, depending on how big the repository is, that might be one approach. Everyone gets their own clone, they push into a master clone that then pushes to where-ever."
git,362rsu,acphilly,2,Fri May 15 18:55:16 2015 UTC,"You are right. However, the boss wants me to take our codebase on the live server and drop it into a git repository in the exact spot. No multiple repositories for each user.   So I will have clone the existing repo, copy the files to it, commit, then move the repo back in place so we can go back to serving the files.  If that makes sense."
git,362rsu,slappingpenguins,3,Fri May 15 20:05:25 2015 UTC,"We do something similar to this. We have a primary dev server that all our devs work directly on (using Vim and git). Each dev has their own git repo of the code on the dev server, but pushes and pulls go to another server (just running SSH and git).   This keeps the code on two different places for redundancy and allows all our devs to work on the actual dev server. Really pretty simple."
git,362rsu,scottchiefbaker,2,Fri May 15 18:43:42 2015 UTC,Why have devs working directly on dev server instead of their local computers?
git,362rsu,slappingpenguins,1 point,Sat May 16 15:14:00 2015 UTC,"Depending on the strength of your team this might be a decent approach. If you don't have time to get a Vagrant box to your liking and or setup instructions for your devs local environments and if your devs are not that experienced with unix and config then having the on a single machine means you have only one environment to tune and troubleshoot.  I've never done this and would rather take the time to setup a process to have devs working locally, but I could imagine in the right circumstances it would make sense."
git,362rsu,scottchiefbaker,1 point,Sat May 16 20:28:07 2015 UTC,"That is the only situation that I can imagine. In which case, I have bigger complaints with the team. If my dev is not good enough to run his code on his computer, how can I trust them to not make intermediate mistakes like introducing bottlenecks in solution, or maintaining clean logs, or troubleshooting environment issues"
git,362rsu,slappingpenguins,1 point,Sun May 17 13:59:05 2015 UTC,"What's the point of a dev server, if you're not going to do work on it?"
git,362rsu,scottchiefbaker,1 point,Sun May 17 03:05:26 2015 UTC,"Dev server is where you'd integrate the product of each of your dev's work, together. And where you can show your progress to your business partners.   For example: Jim works on the registration flow, Alice works on the News feed, and Greg works on the Profile piece. Each does their work on their computers, so they aren't constrained by others. And then when they checkin progress, you combine their changes and put the result on Dev to test how well the features work together."
git,362rsu,alxndrhi,1 point,Sun May 17 13:44:31 2015 UTC,"If that's your model then git will do that too just fine. Each dev can have a git repo on their local machine that pushes to a central repository, and the dev server can ""pull"" them all together."
git,362rsu,remy_porter,1 point,Mon May 18 00:43:03 2015 UTC,"Exactly :)  You don't need a decentralized repo, SVN/TFS/CVS can accomplish that too"
git,362rsu,shampine,1 point,Mon May 18 01:47:37 2015 UTC,Where does the running code come from? Do your git server push it back to the development machine?
git,362rsu,jimschubert,1 point,Fri May 15 20:11:23 2015 UTC,The remote git server servers the code to the dev machine via git pull
git,362rsu,remy_porter,3,Fri May 15 20:18:54 2015 UTC,"You are right with your feeling that this is wired... Your Boss has maybe a little misconception about the hole naming thing. The question is what is his intention in the end.   I highly recommend reading about git workflow examples like on the Git Website: http://git-scm.com/book/es/v2/Distributed-Git-Distributed-Workflows to get you some arguments on hand to work WITH your Boss into the right direction. (this is just one possible source, there are tons of workflow and best practices examples online)  As already mentioned by others, Git enables different Team Members to work on one source by having everyone hacking on his own copy of the hole thing end merge it together into one Codebase - one ""Git Server"" - if you want so. Server means not Development Server ... more like code base server. You can use git to deploy to the Development (or even the live) server. You can have something like a git server (your own bitbucket) in parallel on the dev server. but you should not use the git repo on the dev server as your servers file directory."
git,362rsu,adrianmonk,1 point,Fri May 15 18:55:12 2015 UTC,"Any tips, because this seems like it is going to be a mess.   It's the same as any other deployment scenario. When you want to deploy to DEV, you push from a repo into the DEV repo. You'd do the same thing going to TEST and PROD, too, but with more workflow (assuming you're using GIT to deploy).  DEV is just a deployment target."
git,362rsu,remy_porter,1 point,Fri May 15 16:52:28 2015 UTC,"That is the goal, but the boss wants to go in the opposite direction.  The dev server will be where the repository lives, instead of locally. Deployment mechanism won't change(We have a Jenkins server I set up that we don't use), just making our commits from Dev -> BitBucket."
git,362rsu,lunarsunrise,3,Fri May 15 17:57:16 2015 UTC,"Your understanding of Git is broken. The repo's can live anywhere and have multiple remotes. Whether it is a bare repo or has a working copy is different. Why doesn't your coworker just install Git and push to Bitbucket?  Bitbucket is a bare repo. Your local copy is not. You don't need a second bare repo on a staging server, then you would have two remotes. You should use your staging working copy like it is a bare repo. Your other developer should have a working local copy as well."
git,362rsu,mahamoti,2,Fri May 15 19:08:42 2015 UTC,"I'm probably not clear.   There is to be only the remote(BitBucket) and the local(on the dev server). No locals on the developer machines(that's not going to stop me). All code is written directly to and committed from the development server, pushed to BitBucket.  The simplest solution would be for the other dev to pull the files in the existing repo, update them from the development server, and just work locally. The boss, for whatever reason, will not tell him to do such, and he's not going to do something unless he is ordered."
git,362rsu,repster,1 point,Fri May 15 20:09:32 2015 UTC,"The only way for you to have a 'local on the DEV server' would be for all developers to code directly on the Dev server.  I agree that it sounds like your whole team has misunderstanding of how git works.  If your boss wants a mirror on your DEV server, set it up to mirror bitbucket and do a pull whenever one of you commits to bitbucket. Otherwise, someone needs to read up on git and educate your boss on why his request won't work (or makes no sense) and come to some agreement on your workflow. It's possible your manager is thinking that git is exactly like subversion or TFS, which it's not."
git,362b97,thinsoldier,14,Fri May 15 14:31:10 2015 UTC,I've been trying for years to convince my co-workers to use version control with no luck   You need to work somewhere else :)
git,362b97,Eli-T,2,Fri May 15 16:08:47 2015 UTC,"You have to wipe the server and set up the services and install the website files again. Git makes it easy to clone a repository to get the files back in place, but it's not easier than unzipping a copy of the website files would be. I'm not sure what benefit you believe exists?"
git,362b97,jakkarth,1 point,Fri May 15 14:35:40 2015 UTC,very small company. projects are on shared hosting who aren't in the habit of wiping their servers. They just rename our site folder to example.com_HACKED and send us an e-mail with a list of files they think might have had some bad code inserted into them.  Other projects are self hosted. We don't have a full time dedicated server administrator so our own servers aren't likely to get wiped clean either.   As bad as this sounds we've luckily only experienced a hack about 5 times in 15 years.  I can't change the way my superiors do things. All I can do is improve my preparation/response to having one of my projects hacked and version control has been very useful for that.   But then version control is just plain useful in general. But I can't get anyone else to understand that.
git,362b97,oconnor663,1 point,Fri May 15 16:35:14 2015 UTC,"If you're talking about version control vs no version control at all, it doesn't matter whether you pick git or svn or whatever. Anything will be an improvement.  Hacking has almost nothing to do with it. What happens when someone makes a mistake? When something breaks, how do you find out what change broke it? Unless no two people ever work on the same code at your company?"
git,362b97,oconnor663,1 point,Sat May 16 14:27:08 2015 UTC,No 2 people work on the same code.  git and svn have saved me from myself a few times.  But I can't seem to convince anyone that those few times were with the extra steps of adding git to their workflow.
git,362b97,Manitcor,1 point,Sat May 16 14:52:29 2015 UTC,"Show them git bisect :)  Also, you can always write a cronjob that just commits whatever they've written to another git repo of your own, if you want to save them from themselves."
git,362b97,johnny5canuck,2,Sat May 16 15:24:19 2015 UTC,Git is an effective historical record for any change you have ever made to your code so it makes recovering the code from just about any point and time incredibly trivial. Keep in mind you still need a backup strategy for data and assets and for production systems its best to have fully imaged backups regularly so you can just re-image as building from source will still be a lot of work.  Really git is mostly useful for multiple people working in a code base at a same time or to keep a history of your work for tracking and debugging purposes. That said I hope your company is using some kind of source control. If not you are just asking for disaster and pain and likely have it on a semi-regular basis.
git,362b97,atlgeek007,2,Fri May 15 14:53:47 2015 UTC,"I use git for version control of files that I have edited during the development process.  I have automated scripts to perform daily/weekly offsite backups of my web sites (files and databases).  To me, these are two different things."
git,362b97,joepeg,3,Fri May 15 14:58:38 2015 UTC,"From an operations perspective -- if the site gets compromised, the instance gets wiped.  No questions asked.  It should be relatively simple to spin up a new instance at whatever provider you're using and redeploy.    You ARE using Puppet/Chef/Salt/Ansible to automate your infrastructure right?  RIGHT?"
git,362b97,robvert,1 point,Fri May 15 15:28:22 2015 UTC,"lol, nope/nope/nop/nope/and nope."
git,362b97,atlgeek007,1 point,Fri May 15 15:35:14 2015 UTC,"Dude, op can't even convince them of the value in source control. This place must be a hot mess."
git,362b97,robvert,2,Sat May 16 10:18:41 2015 UTC,Server gets hacked.  = git reset HEAD --hard  Everything now back to how it was before hack. Note: as long as the db and/or untracked files weren't compromised.
git,362b97,niczar,1 point,Fri May 15 14:55:49 2015 UTC,"I would assume if your .git directory was on the server, then there's every chance you can't trust it anymore."
git,360xpl,nekomech,2,Fri May 15 04:10:27 2015 UTC,"From the client run   git log remote/branch   after fetching the remote.  The error is because a bare repo doesn't really have a 'HEAD' (no currently checkout branch, because no working directory). From my small read on the subject, git log will read from the 'HEAD', but you should be fine if you specify a branch.   git log master"
git,360xpl,Kraigius,1 point,Fri May 15 04:52:17 2015 UTC,"in a bare [shared] repo ""git log"" should work.  If it doesn't it means someone moved the HEAD pointer to something that no longer exists."
git,35yage,badg35,3,Thu May 14 15:02:10 2015 UTC,I'm struggling to understand what you're trying to do. Is there any way you explain it in more detail? What is a request? What do the four-digit numbers represent? Does your project have any source code other than these numbered database scripts?
git,35yage,DanLynch,1 point,Thu May 14 16:13:41 2015 UTC,"This organization generates a lot of data that is of interest to individuals within and without the organization.  They use a request-tracking system as a system of record, where each request for data/report/etc. is assigned a unique ID (the 4-digit number).  The request could be a report (e.g. SSRS, RPT) or an extract (e.g. database scripts; CSVs).  There may be other use-cases, but I haven't had exposure to them.  Based on a number of factors (availability, experience, skill), request is then assigned to an analyst and developer.  In addition to the usual artifacts, I'm hoping to move them towards using AsciiDoc as a documentation standard.  This would be created by the analyst, then augmented by the developer.  These files (.adoc) would be store in each request's folder.  This document acts as the basis for a Gollum wiki entry (or will if I can get the approval).  My goal is to have the entire repository of requests act as a single wiki, in addition to the valuable aspects of version control."
git,35yage,Nevik42,2,Thu May 14 17:17:07 2015 UTC,"Your approach seems to make a lot of sense for your use case. I don't see any big issues. Regarding your ""negatives"":   forgetting about stashes   There's really not much help for human error. If your developers (or other people who interact with the repo) can't manage them, discourage use of stashing and/or have them train more.   starting development on the wrong branch   Not a problem. You can easily float uncommitted changes or rebase committed changes to another branch. ""Floating"" means that when you have uncommitted changes and switch branches, those changes are taken along and not left on the previously checked-out branch (Git will complain and abort if taking along these changes would interfere with the target branch; in this case, use stashing and popping, or rebasing, to transfer the changes with conflict resolution.)   inability to easily copy code between branches   Not a problem. You should probably look into rebasing and cherry-picking. Given your presented folder structure and assuming that only one person is ever working on a subfolder, rebasing/cherry-picking changes to another branch will not even cause merge conflicts.    Regarding (some of) your question:   would there be any benefit to using submodules (i.e. one for each request)?   Probably not. You'd certainly incur a much higher effort for managing all the repos and the superrepo.   is there a better way to structure this (e.g. each request has a separate repo)? what are the issues with this?    Again assuming that only one person is working on a 'request' (folder) at a given time, this structure (subfolder per request) makes a lot of sense because you will basically never have merge conflicts.  Putting each request in its own repo gives you more management work (as mentioned above). The creation of the repo and adding it to the superrepo (if submodules are used) can be automated, but you'd have to create and deploy (and maintain) such scripts. And to inspect the complete history, you'd have to go look at each repo's individual history.  (It should be pointed out that this is not an issue in the opposite direction, you can always view the history of a subfolder in a given repo.)   how would i migrate to this structure (keeping the history)?   With git filter-branch. There are lots of guides on the internet for this (search for ""extract/split out subfolder from repo with history"" or similar)."
git,35yage,untitleddocument37,4,Thu May 14 16:26:18 2015 UTC,git isn't really the best tool to revision binary files.  This is going to blow up really fast.  What you really need is a file server with daily backups.
git,35yage,cpbills,2,Thu May 14 17:44:22 2015 UTC,"At this point, the files are text.    If they choose to use a tool like Crystal Reports, I'd probably use RptToXml library in combination with a .gitattribute file to index the major properties."
git,35q13k,0xdeadf001,2,Tue May 12 15:53:57 2015 UTC,"push to experimental/whatever and have a post-receive hook on the server that checks the ref name, and if it matches experimental/* it initiates the build/test process."
git,35q13k,jakkarth,1 point,Tue May 12 16:01:26 2015 UTC,"Yup, the error is having your developer commit/push to master for things that are experiments.  The entire point of git (aside from being an SCM) is to make branching stupid simple.    If your developers are all gang-banging the master branch you're ""doing it wrong (tm)"""
git,35q13k,untitleddocument37,-7,Tue May 12 16:13:34 2015 UTC,"Did you even read what I wrote??  No one is ""gang-banging the master branch"".  If you can't even read, then you can't offer any help."
git,35q13k,Kraigius,2,Tue May 12 20:24:35 2015 UTC,"I think he's referring to    if a developer works directly in their ""master"" branch on their workstation   .   If you can't even read, then you can't offer any help.   There is no need of that altitude here, if you can't comment something valuable, do not comment either.  You should check how Travis Ci work, I think it's a post-receive hook as /u/jakkarth suggested that you do. Let them push their branch to an ""experimental"" remote and with a post-receive hook it will notify your system to fetch it and build it. It works in my head, no idea if that's how it should be done, but you should try it."
git,35eliw,L000,7,Sat May 9 16:20:48 2015 UTC,https://roots.io/bedrock/
git,35eliw,bankslain,3,Sat May 9 18:47:03 2015 UTC,Woah thanks! Time for me to study up!
git,35eliw,ndboost,2,Mon May 11 17:39:34 2015 UTC,/endthread
git,35eliw,__notmythrowaway__,5,Mon May 11 22:08:54 2015 UTC,"I'm not familiar with WordPress, is it common to have sites use 2GB (non database)?"
git,35eliw,shadowfactsdev,6,Sat May 9 16:28:33 2015 UTC,No
git,35eliw,vimishor,2,Sat May 9 19:40:30 2015 UTC,"Didn't touch WP in a while, but from what I remember somewhere in ""wp-content"" directory are stored many things (themes, plugins, etc) and one of those things are uploads ; so the size of the website pretty much it depends on how much data you upload.      And to answer your question, I've rarely seen WP sites under 10GB, but I worked only on a few news related WP installations."
git,35eliw,shampine,2,Sun May 10 08:25:38 2015 UTC,"But you don't version the uploads for a few reasons. Repo size being the biggest, the second being that it would obnoxious to push every time someone uploaded an image.   Most WP repos I work with are 20-100MB and have 400-1000 commits."
git,35eliw,vimishor,2,Sun May 10 17:59:41 2015 UTC,The question was:   is it common to have sites use 2GB (non database)?   Not if the uploads are versioned or not.
git,35eliw,shampine,1 point,Sun May 10 20:17:16 2015 UTC,"Ya I see that now, thought he was asking that in line of the Git repo size, which would be nuts. Most we house are probably 10-15GB each with the uploads."
git,35eliw,shampine,1 point,Mon May 11 18:06:01 2015 UTC,"So git is definitly not the correct tool for a full site backup. Is it ideal in conjunction with something, say like Dropbox, for the databases, or do you think it's best to work with another framework entirely?"
git,35eliw,pi3832v2,2,Mon May 11 17:35:44 2015 UTC,"We have server level backups that happen weekly. We have daily scripts that dump out the database and move it to another server for archiving/storage. We also use those same scripts to rsync our uploads directories to a backup server. We truncate backups at 7 days, and rysnc keeps the uploads in exact sync.  You could also host your uploads on S3, super cheap and then utitilize their versioning."
git,35eliw,shampine,3,Mon May 11 18:10:31 2015 UTC,"I assume you're referring to this GitHub .gitignore template: github.com/github/gitignore/blob/master/WordPress.gitignore.  This guy has a more aggressive approach—ignore everything by default, whitelist things you specifically want to track: gist.github.com/salcode/gitignore.  What will make a repository explode in size are binary files, especially those that can't be compressed.  If you pare down what's being tracked to only include text files, I expect you shouldn't ever have to worry about the total size of the repository."
git,35eliw,shampine,5,Sat May 9 17:54:48 2015 UTC,We version the whole codebase. We don't version the uploads folder though. But we want plugins and WP to be matching between production/staging/dev.  Feel free to take a look at our Git Submodule boilerplate and ask any questions:  https://github.com/GunnJerkens/wp-boilerplate  You can also look at my personal one that is a more traditional setup and I can answer any questions you might have:   https://github.com/shampine/wordplate
git,35eliw,shampine,1 point,Sun May 10 02:09:00 2015 UTC,Thanks! I'm going to check these out as soon as I'm in front of a computer. Since you've got your codebase covered. How do you supplement it with backups for uploads and databases? Or are you using something different entirely for that?
git,359hls,Godd2,8,Fri May 8 05:51:25 2015 UTC,"TL;DR If anyone tells you that a commit contains the difference between the last commit and that one, they are wrong, and you can prove it.  I've heard this falsehood more than once even from well-seasoned git enthusiasts.   The post feels a bit pedantic and condescending, but I guess it's like porn for ""git enthusiasts"" (whatever the hell those are)."
git,359hls,thr3ddy,-2,Fri May 8 18:55:48 2015 UTC,"I take your claim of pedantry as a compliment, but I don't think I was being condescending."
git,359hls,causa-sui,2,Fri May 8 19:10:23 2015 UTC,"If your post wasn't, that comment was."
git,359hls,mick88,1 point,Fri May 15 23:21:51 2015 UTC,How?  I wasn't patronizing at all.
git,359hls,mick88,8,Sat May 16 01:58:37 2015 UTC,"For all intents and purposes, they are transactions. Unless you are working under the hood of git, you can treat commits as diffs (changes). Yes it will snapshot whole file if you only changed one line, this may be a problem if you're working with large files, but the commits will be compressed periodically (whether the compression accounts for duplicated files, I don't know).  And no, git does not store unchanged files again, it makes a new reference to existing instance of the file objects, only changed files actually get added again."
git,359hls,Kraigius,2,Fri May 8 09:45:27 2015 UTC,"And no, git does not store unchanged files again, it makes a new reference to existing instance of the file objects   I know.  As it says in my post:   To be more precise, it contains a reference to a list of compressed files.  Each of those compressed files are what you ""git add""ed in the last iteration including the files that you did not change.   I was only trying to say here that each commit stores it's own reference to a list of files.  Do you recommend that I phrase that differently?   Unless you are working under the hood of git, you can treat commits as diffs (changes).   I would contend that it's up for debate.  For me, understanding some of the porcelain commands was a lot easier after I understood this difference.  It also makes merges seem a lot more sane.  But not everyone's like me, and not everyone needs to know the exact, ""byte for byte"" model of whats going on.   (whether the compression accounts for duplicated files, I don't know)   To my understanding, it does.  When Git makes a packfile, it does it's best (within a reasonable amount of time) to compress duplication, even across files."
git,359hls,elperroborrachotoo,1 point,Fri May 8 10:04:53 2015 UTC,"I understood from the article that git takes a full snapshot each time:   Each of those compressed files are what you ""git add""ed in the last iteration including the files that you did not change.   I agree that you can look at at commits however you want, technically they are snapshots. But for me it's easier to treat them as diffs, because to me it makes more sense for actions like reverting, cherry-picking dropping commits, and anything really.  I guess I just don't agree with the article title, because it says that ""git commits are not transactions"" while they are treated as such and only technically they are not."
git,359hls,fdafasdfadfaf,1 point,Fri May 8 10:23:29 2015 UTC,"But for me it's easier to treat them as diffs, because to me it makes more sense for actions like reverting, cherry-picking dropping commits, and anything really.   It's true that Git will reconstruct diffs in the intermediate to do cherry-pick and rebase, but it's a temporary calculation, done on the fly.  They aren't saved anywhere in the object store."
git,359hls,fdafasdfadfaf,1 point,Fri May 8 17:01:23 2015 UTC,"(whether the compression accounts for duplicated files, I don't know).   Sort of. According to Pro Git, the content of the git blob (the actual change to your file) is compressed with zlib. It doesn't account for duplicated files. However, once the garbage collect fire up, git objects are packed into binary files called packfile. Packfiles contain the deltas across versions of similarly named and sized files, which saves even more space.  If I would be more specific on the blog I would say that he is technically correct that commit objects are not a list of the differences (delta) between the different versions, but packfiles are and do exist.  That a branch is not a transactional database, but a pointer (reference) to a commit.  Git commit doesn't contains the compressed snapshot of your entire working directory tracked files. Commits point to a tree object, it have an author, it have a commiter, it have a parent commit, and a message. Blob objects contain the compressed the data and they are pointed by tree objects."
git,359hls,0xdeadf001,3,Fri May 8 21:04:33 2015 UTC,"Technically, you are right"".   ""Difference between commits"" comes in as a convenient model that makes the explanations of some git operations (such as cherry-picking or rebasing commits) much more transparent:  Commit 64329df5 contains the bug fix for case 879423 you pushed to ""dev"" yesterday, we now cherry-pick these changes onto the ""suffer-you-fools"" branch   ... would be technically wrong, but in a very convenient way.   For me - and apparently, for some others - this model is when git ""clicked"", when all the operations I was doing by cheat sheet started to make sense."
git,359plt,depressiveRobot,1 point,Fri May 8 07:44:04 2015 UTC,"I have a 'simple' prompt to remind me, it shows the branch name, ? for untracked files, + for stash(es), > to indicate I'm ahead of the remote, < to indicate I'm behind the remote, ! to indicate divergence."
git,359plt,cpbills,1 point,Fri May 8 21:04:50 2015 UTC,See right-prompt used by sorin theme from prezto
git,357zrh,UnknownProcess,4,Thu May 7 21:33:04 2015 UTC,"I reckon you probably need an absolute, not relative, path there:  git clone pi@192.168.1.2:/home/usbdrv/repo.git"
git,357zrh,cfmdobbie,1 point,Thu May 7 22:20:37 2015 UTC,"I did that. I also tried different locations for the 'repo.git' but still without success... I will check the permissions, maybe the Git is not a problem."
git,357ri6,techaddict0099,5,Thu May 7 20:29:37 2015 UTC,"There are lots of tools for this.  The phrase to search is ""mac diff merge tool"".  I'm using one called DiffMerge by SourceGear. It's pretty good. Utilitarian, smart but not pretty.  BTW, on the Windows side, I've generally found Tortoise to be a fairly awful git client. Go download SourceTree by Atlassian, it's far better. It doesn't sacrifice git power for Finder integration the way Tortoise does."
git,357ri6,ratbastid,0,Thu May 7 20:49:24 2015 UTC,Ah thanks checking it out. I am new to git. Our repo just got ported from SVN to GIT so I am used to tortoise.  Is there any single tool to handle everything related to git?  Can we use github's git management tool for repo hosted on our own gitorious served?
git,357ri6,ratbastid,2,Thu May 7 21:47:51 2015 UTC,Tortoise SVN was okay. Tortoise git is fairly poor. Google for SourceTree. It's an all-in-one git client.  Github and Gitorious are totally unrelated things.
git,357ri6,bigrodey77,2,Thu May 7 22:16:39 2015 UTC,"Beyond Compare has versions for Linux, Mac and Windows and is the best diff tool available IMO. You can edit the file while doing the diff and save changes."
git,357ri6,arc-guardian,1 point,Fri May 8 15:44:30 2015 UTC,Beyond Compare is definitely the way to go! Love using it
git,357ri6,arc-guardian,1 point,Sat May 9 09:20:07 2015 UTC,http://www.scootersoftware.com/support.php?zz=kb_vcs_osx#git   This is the thing you guys are talking about right?
git,352csy,eddydio,1 point,Wed May 6 15:00:27 2015 UTC,Can you explain what a staging area is?
git,352csy,wherethebuffaloroam,1 point,Thu May 7 01:04:56 2015 UTC,"A website on a subdomain that I can edit without disturbing the public facing domain: staging.example.com is the staging area for example.com.  I have worked on sites that are set up like this, I just wanted to set it up for my own site and have version control with git."
git,352csy,isarl,1 point,Thu May 7 14:22:19 2015 UTC,"It sounds like you want multiple detached working trees. Use a git hook so that when you push to the bare repository, the latest stable head gets checked out to your stable (non-staging) work tree. Don't do this to the staging work tree because you might obliterate changes which haven't been checked in yet; you'll have to manually update the staging tree with, e.g., git fetch origin && git merge origin/master."
git,352csy,isarl,1 point,Thu May 7 17:33:17 2015 UTC,I have no idea what you just said. I really need the baby steps of how to make this happen and most guides read just like your response so I'm at a loss.
git,352csy,isarl,1 point,Thu May 7 18:49:28 2015 UTC,Sorry about that. I'll link you to some documentation when I'm not on my phone.
git,352m85,nicoschuele,-1,Wed May 6 16:12:33 2015 UTC,"I've setup aliases in my bash profile for a few of my commonly used actions. For example ""acp"" is just an alias for ""git add . && git commit && git push"" I used git config to launch my text editor for my commit message and after I close the editor tab it goes on with its merry way."
git,352m85,thebronado,0,Wed May 6 16:57:34 2015 UTC,"Heh, this is cool! I've also used aliases or .sh scripts but as I'm working on different machines, I figured it would be easier to regroup everything in a gem I could get from anywhere with gem install :-)"
git,34yqhk,kannonboy,1 point,Tue May 5 17:50:48 2015 UTC,[deleted]
git,34yqhk,Audiblade,1 point,Wed May 6 01:10:07 2015 UTC,To me signed commits are only useful for blaming people.  If you want write-access control to your git repo put it behind an SSH server and use public key authentication.
git,34yqhk,untitleddocument37,2,Wed May 6 11:31:18 2015 UTC,Signed commits additionally ensure that my commit was not altered by someone afterwards or so someone doesn't make the commit author me when it wasn't.
git,34yqhk,jimktrains,1 point,Wed May 6 15:07:32 2015 UTC,That's relatively easy to detect because your trees will become out of sync.
git,34yqhk,untitleddocument37,1 point,Wed May 6 15:12:09 2015 UTC,"Not if  a commit is made in my name without my knowledge.  Also, if I am an infrequent commuter to the project, I may not notice the tree change for a while (and there is a window where noone else would see a difference)."
git,34yqhk,jimktrains,1 point,Wed May 6 15:37:58 2015 UTC,"Furthermore, it doesn't give you any deniability if you are asked to prove you didn't retroactively alter your local repository to protect yourself."
git,34wo5a,esconyc,3,Tue May 5 04:20:40 2015 UTC,"When you say ""uploaded"", do you mean ""I have a remote git server and a local git repo, and the files I don't want are on both""?  If so, unstaging is not enough.  There are three different states your files can be: unstaged, staged, and committed.  Briefly (but really you should read a git tutorial) staged means ""will be committed next time you trigger a commit"".  What you've described sounds like your changes are committed, and pushed to the remote.  If that's the case, you need to actually commit a deletion of these files, even push it up.  If you need to keep these files locally, you can use git rm --cached yourfile (or git rm --cached -r dir if it's a directory).  That will create a staged removal of the files, but leave the files locally.  (Run git status pretty much constantly in order to know what's going on).  Then you can commit that removal.  Also, until you understand git, please don't use a client.  I personally recommend people only use the command line for the first few months.  I've never used tower, so I don't know if it provides the full git functionality."
git,34wo5a,trebor89,1 point,Tue May 5 04:33:28 2015 UTC,"You probably mean ""untrack"" not ""unstage"".  And even then, ""untrack"" is not the best explanation of what you're doing.  As /u/tebor89 explained, what you need to do is tell Git you deleted the files. Git only checks .gitignore when it comes across a new (to it) file/directory. The --cached in git rm --cached tells Git to not delete the copy of the file that's currently in the working directory.  After you've done the deletion, run git status.  If it reports what you just deleted as ""new untracked files"", your .gitignore is not working.  Another thing to remember—deleting a file is just another sort of change to a file. So, all the previously committed versions of the file still exist in the repo's history."
git,34tcv7,k4f123,3,Mon May 4 12:01:14 2015 UTC,"If you just want the files why not use git archive?  Also, ""deploying"" from a tip of a branch is a bad idea.  You should be deploying from tags only because otherwise how the fuck do you QA anything?"
git,34tcv7,untitleddocument37,1 point,Mon May 4 12:10:11 2015 UTC,"That makes sense, and I fully intend on using tags.  The way I was going to use them was to do it from within Gitlab. Gitlab allows you to fire specific hooks based on tags passed with the push command. So if the push was going to have the 'staging' tag on it, I was going to refresh the staging server, etc.  Re: git archive -- I would be totally open to using that. I am not familiar with it however. Going to google that right now and see if I can find a way to integrate it.  Thanks for your feedback. If you have any tips on git archive I should keep in mind, please let me know."
git,34tcv7,untitleddocument37,1 point,Mon May 4 12:12:32 2015 UTC,"git archive produces a tarball (and you can specify prefix'es) of a given commit.  So you could ""off-line"" store it via   git archive SOME_TAG | xz -c > foo.tar.xz   You could also deploy it as    git archive SOME_TAG --prefix=/var/www | tar -x   It also means that your deploy doesn't have any .git files in it.  Just the tracked files."
git,34tcv7,untitleddocument37,1 point,Mon May 4 12:18:42 2015 UTC,"Unfortunately, this would not remove deleted files. This was an option I considered and was discussed here: http://gitolite.com/deploy.html  As you can see the archive methods do have some shortfalls which make them less than ideal."
git,34tcv7,trebor89,2,Mon May 4 12:48:23 2015 UTC,"You would have to clean the directory in eithercase... ""git checkout"" doesn't touch untracked files ..."
git,34tcv7,untitleddocument37,1 point,Mon May 4 12:54:59 2015 UTC,"I'm partial to deploying to a dev environment from master or a release branch, then tagging for stage."
git,34tcv7,trebor89,1 point,Mon May 4 15:26:36 2015 UTC,Except then you have to tag from your dev environment because it's branch and your branch may deviate...
git,34kcc9,somelinuxuser,3,Fri May 1 22:15:03 2015 UTC,"It looks like you've forgotten to push your changes to your public remote. The people to whom you are sending the pull request need to be able to pull them from somewhere, right?"
git,34kcc9,DanLynch,2,Fri May 1 22:40:08 2015 UTC,"My description was misleading. I want to generate my pull request for origin without having commit access there. My repository is readable for the person who maintains origin.  Edit: My mistake was using origin for the second option. I should have provided the URL of my own repository, obviously. Thanks for your help!"
git,34kcc9,cpbills,2,Fri May 1 23:23:40 2015 UTC,"When you say URL, you mean the URL, or do you mean the remote you've created locally to push to your repo?  If not, check out git remote --help, and save yourself a lot of typing."
git,34c3ul,ssaasen,6,Wed Apr 29 23:29:19 2015 UTC,"Generally speaking if you find yourself using --force on a semi regular basis you're doing things wrong.  When you go to rebase a public feature branch it should only be done before a merge and even then you can just branch the feature branch and rebase that.  using ""--force"" means you fucked up a public branch and you have to overwrite existing work because of it.  It's like saying ""my driving is fine because the jaws of life can get me out of any collision..."""
git,34c3ul,untitleddocument37,2,Thu Apr 30 11:34:16 2015 UTC,"Different people have different, perfectly valid workflows. I often use push --force (or --force-with-lease from now on) in these situations:   longer-lived feature branches when I want to pull in changes from the master branch before merging the feature branch, so the CI can verify it still works with recent changes and I can merge it directly through the interface on GitHub/Gitlab/etc.   Of course I only do this on feature branches where I know I'm the only person working on it."
git,34c3ul,toupeira,4,Thu Apr 30 23:36:00 2015 UTC,"Interesting, I didn't know about --force-with-lease. That's clever!  tl;dr It's cmpxchg for git --force."
git,34c3ul,skeeto,1 point,Thu Apr 30 12:58:33 2015 UTC,Sounds like --force-with-lease should be the default result of --force!
git,34dnwh,LameTokyoTourist,2,Thu Apr 30 08:37:21 2015 UTC,What is your git config --get push.default?
git,34dnwh,bwalk,1 point,Thu Apr 30 10:06:35 2015 UTC,"It's not set. I used to have it set to ""simple"" before git 2.0 came out. They changed the default value to simple in 2.0, so now I leave it empty.  The way I understand the ""simple"" mode is that it should push my branch to the remote that it is tracking, to the branch of the same name. So basically it should push to the same place that ""git pull"" without arguments pulls from.  What's really driving me crazy here is the asymmetry between ""git pull"" and ""git push"", and I can't figure out why it's happening."
git,34dnwh,bwalk,2,Thu Apr 30 10:53:00 2015 UTC,"Hmm. I understand your frustration. I would expect the same thing you do. Unfortunately, my git foo isn't strong enough to even ask more specific questions.  Is this for all repositories or just this one specific?"
git,34dnwh,pi3832v2,2,Thu Apr 30 11:46:12 2015 UTC,Using a push.default of simple? Try:   git config push.default upstream
git,34dnwh,pi3832v2,1 point,Thu Apr 30 11:08:10 2015 UTC,"Already tried that, it didn't help. Tried it again now just to be sure, same thing."
git,34dnwh,trebor89,1 point,Thu Apr 30 11:12:36 2015 UTC,Odd.  Maybe try setting upstream again?  git push -u <remote> <branch>
git,345ks5,until0,12,Tue Apr 28 14:06:24 2015 UTC,"It seems that git will accept any prefix as long as it uniquely identifies an option. For example, git commit --am works, but git commit --a doesn't."
git,345ks5,kalgynirae,3,Tue Apr 28 14:20:21 2015 UTC,Isn't that considered bad practice? Why does it have the hinting built in?  $ git comit   git: 'comit' is not a git command. See 'git --help'. Did you mean this?  commit
git,345ks5,oonniioonn,7,Tue Apr 28 14:46:45 2015 UTC,'comit' isn't a subset of 'commit'.   It's not bad practice -- many commandline interfaces do this.
git,345ks5,oonniioonn,5,Tue Apr 28 18:25:43 2015 UTC,"I can't see how it wouldn't be bad practice though. Due to this logic, git is now restricted in its potential for future options or shorthand.  If git accepts ""am"" as an alias for ""amend"", then if git releases an option, let's call it ""amode"" for intents and purposes, then there is a level of ambiguity and a previously working command now fails. Additionally, if the command was simply called something that would be partial to the fullname, such as if they made ""allow"" since ""allow-empty"" exists they also break this functionality.  There is no practical gain, just implied restrictions. I don't get why this was done this way. Could we not just use aliases if we were unhappy with the option name choices?   I just think this is quite off, especially from a programming mindset. I'm noticing getopt's default behavior does this, so I guess it is recommended practice, but I just can't get behind it personally. I'm not sure why this feature exists unless it was due to legacy reasons."
git,345ks5,oonniioonn,4,Tue Apr 28 18:57:12 2015 UTC,"It's there to allow us to type less.  It's bad practice to use the shortened versions of commands in things like scripts, sure, but not when actually typing."
git,345ks5,l4than-d3vers,2,Tue Apr 28 18:59:31 2015 UTC,"If we wanted to type less, shouldn't we just use aliases? Verbosity is always the better choice.   I  can see the merit, but overall, I think it's small and the potential issues outweigh the benefit."
git,345ks5,oonniioonn,3,Tue Apr 28 19:00:44 2015 UTC,"Aliases don't work for command arguments I don't think.  I honestly don't really see any issues with this behaviour, so long as you take care not to use short versions of commands/arguments in scripts or documentation."
git,345ks5,m1ss1ontomars2k4,2,Tue Apr 28 19:04:06 2015 UTC,"Aliases don't work for command arguments I don't think.   yes, but you can configure git ""aliases"". For example:  $ git config --global alias.l ""log --graph --decorate --oneline"" $ git l"
git,345ks5,l4than-d3vers,1 point,Tue Apr 28 21:59:05 2015 UTC,"Well, I meant alias your command with the arguments to something that works for you.  I think my issue is not that it's necessarily harmful, but that its redundant and redundancy should always be avoided in programming. I see no reason in the first place, but it may have been a legacy feature for when windows were smaller and terminals were limited to around 80 characters.   Also, as a side note, commit is a subset of git and is an argument to the git command, so shouldn't that follow the same ambiguity argument deciphering that applies to the rest of the arguments?"
git,345ks5,l4than-d3vers,3,Tue Apr 28 19:10:10 2015 UTC,"the string 'comit' isn't a substring of 'commit', like 'com' or 'commi' are. It only does simple prefix matching, probably specifically to avoid running the wrong command."
git,345ks5,fdafasdfadfaf,1 point,Tue Apr 28 19:19:49 2015 UTC,Well even git commi doesn't work. It seems to only work for the arguments to the command passed to git.
git,345ks5,berenm,3,Tue Apr 28 19:24:33 2015 UTC,"Due to this logic, git is now restricted in its potential for future options or shorthand.   No, it isn't. Just tell people to stop using their no-longer-unique shortcuts."
git,345ks5,canton7,1 point,Tue Apr 28 22:00:51 2015 UTC,"If git accepts ""am"" as an alias for ""amend""   It doesn't. In fact, git am is a whole other thing. man git-am"
git,345ks5,mus1Kk,2,Tue Apr 28 21:56:59 2015 UTC,"git commit --am is an alias for git commit --amend  That's what I am referring too, the context is in the previous comments."
git,345ks5,xiongchiamiov,1 point,Tue Apr 28 22:43:40 2015 UTC,"ehm, sorry :)"
git,343jld,LamborghiniVeneno,14,Tue Apr 28 00:47:35 2015 UTC,It’s easy to get an overall diff from a sequence of small commits. It’s impossible to extract step-by-step patches from a single large commit.
git,343jld,a-p,12,Tue Apr 28 06:33:19 2015 UTC,"Definitely several smaller commits. Then I can see individual pieces, and alternately the whole thing."
git,343jld,scottchiefbaker,13,Tue Apr 28 01:47:14 2015 UTC,"With multiple commits you always have the choice of viewing it as one big diff if you want to, so that's the winner. With a single commit you have no choice."
git,343jld,mackstann,6,Tue Apr 28 01:00:17 2015 UTC,"A pull request may map 1:1 to a particular bug or feature. If it takes 40 commits to get there, so be it."
git,343jld,ahandle,1 point,Tue Apr 28 03:33:35 2015 UTC,Is there an easy way to merge multiple commit into a single one such that I can still access the individual commits later on?
git,343jld,PeterSR,7,Tue Apr 28 05:40:13 2015 UTC,"No. The point of a commit is that it's a pretty much a logical bunch of changes. Git has no way of saving information that can split it into multiple commits.  This is why you would use multiple commits on a feature branch and then merge them back into the base branch (with --no-ff, so that a merge commit is created). The stretch from the branch-off point to the merge commit is your ""single big commit,"" and you can always inspect the individual commits as well."
git,343jld,Nevik42,3,Tue Apr 28 06:45:46 2015 UTC,Perfect answer! Thank you!
git,343jld,PeterSR,2,Tue Apr 28 06:54:55 2015 UTC,If you use something like Gerrit you only upload patchsets instead of commits and only the final commit will be merged into the repo so that your history is clean but using the Change-Id field in your commit message you could always look up the review and see the history of the work done on said commit.  https://review.openstack.org/#/c/164446/
git,343jld,zxiiro,0,Tue Apr 28 10:47:11 2015 UTC,"I prefer a single commit for a single pull request for a single new feature/bug fix/issue/etc.   Multiple smaller commits are harder to read because now I'm iterating through all of them trying to figure out how they piece together. And if I realize your commit breaks something farther down the line I can just revert that one commit instead of tracking down multiple commits.  That said - if you have changes that are logically separate, then they should be separate commits submitted via separate pull requests. Each commit should be branched off of the current development branch so that I can pick and choose which ones ultimately go in independently.  Edit - apparently my opinion is wrong. Sorry for trying to keep clutter out of my repo."
git,343jld,az4z3l,1 point,Tue Apr 28 01:03:02 2015 UTC,"I get what you're saying, but I think your issue is with the merge, not the change set. Since you can look at a series of commits in a pull request as a single diff, it doesn't really matter.   What would be great is if a github pull request could be merged as a squash commit. This allows easy reverting, since the entire change set gets merged as a single commit, while allowing the developer to make a series of smaller commits, and have more granular control over how they create their patch.   I've been complaining about lack of squash commits on github for a couple years."
git,343jld,spizzike,3,Tue Apr 28 13:49:42 2015 UTC,"Ya apparently everyone here is obsessing over the best way to do it on GitHub rather than with git. GitHub is not the only way to do git, guys. I don't do my work via GitHub so I don't have much of a workflow for it but in things other than GitHub, how it looks in the PR is generally how its going to look in the repo. My company has an internal git hosting service and that is how it fits in with us as well as open source projects like LibreOffice, Linux, and gasp git!  So here's my problem with multiple commits:  Let's say that we operated a web application. When ""multiple smaller commits"" are encouraged in a PR, I get commit logs like this (oldest to newest):   Add database service Create API endpoint that returns ID's Create service to return ID's with API call Fix bug in API endpoint Add controller to call service WIP: Build template to display ID's to user. Add jQuery in order to manipulate DOM better Finish displaying ID to user   Obviously this is a collection of worst cases thrown together into one, but this is the type of thing that happens when multiple small commits are treated as the ideal. This is why I encourage single commits for a PR. This whole thing could have been squashed into a single commit ""Display ID to user on whatever page"". All of the commits are directly related to that task and it is a single logical addition to the application.   When single commits are treated as the ideal (though not necessarily a requirement), it makes the repo significantly cleaner and people squash their commits together to represent complete feature changes. Will there still be situations in which multiple commits are necessary/preferred? Absolutely. But that shouldn't be considered the ""best"" way to do things. You should strive towards making things concise."
git,343jld,az4z3l,1 point,Tue Apr 28 14:29:15 2015 UTC,"The whole ""pull request"" vocabulary has been hijacked by github, and the fact that a PR on that platform is just an issue with a change set attached, means that you can have an abstract description of what all the commits encompass.   Without the github ui, a pr is really a patch, and I agree with you that that should be a single unit of work (commit). If additional context is needed, one can always provide access to the branch itself in the fork."
git,343jld,spizzike,1 point,Tue Apr 28 14:35:13 2015 UTC,"I agree with your comment, but I don't agree with your example (although, I do give you credit for at least providing one. I can't image a good example is easy to come up with).  My take on the example is the issue you describes is what I would consider a small change - a single self-contained feature. Individual commits like this cause self-contained features to be spread across multiple commits - which I feel is wrong (grouping them all into 1 makes a lot more sense).  On the other side of the spectrum, if the task was something large like implementing a new message queue system I'd rather see it broken down in parts.   Add MQ packages Added MQ Dashboard Implemented new MQ in X Implemented new MQ in Y ...   Besides actually adding the MQ packages, each of those commits are a self-contained. You could delete any on of those and the overall PR would still work.  So I guess my opinion is. Commits should encompass self-contained features (adding jQuery is not a feature - unless it's explicitly required for multiple other features. Even then, it should be included in something bigger like ""updated JS assets""). Ideally, unless a commit is a dependency for future commits, you should be able to remove it without much impact. In turn, a PR should simply be the container for X amount of features."
git,343jld,slccsoccer28,1 point,Tue Apr 28 15:53:35 2015 UTC,"You are absolutely right. However, in this case, I would prefer those commits to have been added separately to the repo. Why wait for X and Y to have it implemented when you have the dashboard finished?  I guess I can see this workflow when your product has a release schedule. My team does continuous deployment though, so there is no reason to wait for X and Y when we can get the dashboard out to customers now.    In turn, a PR should simply be the container for X amount of features.   I do take issue with this, however. During a PR, I want it to be for a single feature. I should be able to accept or reject the whole request (after necessary amends), rather than making individual decisions and taking part of it. Further, grouping a bunch of features together in one line of commits introduces a lot of risk that commits 3 and 4 do in fact rely on commits 1 and 2, even though it might not be obvious."
git,343jld,az4z3l,1 point,Tue Apr 28 16:03:54 2015 UTC,"I didn't think about that. Steps 2 and 3+ can really be separate PR.  I think it comes down to perspective.  Where I work (agency), we have a core platform and thousands of projects based on it. We do features/releases on core so we can associate a project with a specific release. Most of our projects are relatively short lived (couple of months) so makes sense to freeze the core they're related to.  In our case, the MQ functionality would come as one release (I admit a MQ might be a little too large of a function for my example). Then on subsequent projects, the entire feature is stable and available.  After hearing what you have to say, I can see where the opposite approach would also be extremely valuable. I guess that's why it's called software engineering, not Ikea furniture assembly."
git,343jld,slccsoccer28,1 point,Tue Apr 28 17:17:22 2015 UTC,Multiple smaller commits are harder to read because now I'm iterating through all of them trying to figure out how they piece together.    Why not review the diff?
git,343jld,bpp198,0,Tue Apr 28 06:19:20 2015 UTC,Sure during the pull request phase. But how about down the line when I'm tracking down when a bug was introduced? Now I have four or five additional commits to look at independently to figure out which one did what.
git,343jld,az4z3l,4,Tue Apr 28 06:23:36 2015 UTC,Isn't that easier though? Each commit is a logical addition/deletion with a commit message.
git,343jld,bpp198,1 point,Tue Apr 28 06:33:32 2015 UTC,Look at the merge commit?
git,343jld,Rubykuby,0,Tue Apr 28 06:55:14 2015 UTC,git bisect
git,343jld,Femaref,1 point,Tue Apr 28 13:26:40 2015 UTC,"Exactly. And on any non-trivial non-web-based repository, bisect takes a very long time per commit. Squashing commits down to a minimal amount of logical changes will help that a lot."
git,343jld,az4z3l,1 point,Tue Apr 28 14:13:38 2015 UTC,"Don't you have to go through a lot of code if the commit is large? Are you really saving time due to it, or are you just moving your spend time to finding the bug instead of letting software do the work for you?"
git,343jld,Femaref,1 point,Tue Apr 28 14:19:37 2015 UTC,"I really have no idea what you're saying here. I think you are operating under the assumption that git bisect will always magically find a bug completely on its own? That's not true in almost any case I have encountered. Git bisect is great in that it can manage the source code side but most of the hardest bugs I have had to deal with (and the ones that justified spending time on bisect) weren't things that I could write a script to encounter. That makes git bisect important for me to say ""present"" or ""not present"" and it will automatically roll to the next commit.   Build time for my application is ~7 minutes. Between each commit change there will be a build. That means if you end up with ""40 commits in your change"" like someone else suggested, that is an hour or so?  If I can narrow a bug down to a single commit, I am smart enough to find where the bug is occurring based on other context.  But you're right, if you send in a single commit that is hundreds (or thousands even) of lines changed, then yes, it should be multiple commits. But don't treat multiple commits as somehow superior to single commits. If your 20 commits are just segments of a single feature addition, then there is no reason for you to spell out every single step in the history. And if your 20 commits are 5 adding this feature and 10 adding another and 5 fixing bugs, they shouldn't be grouped together into one PR."
git,343jld,az4z3l,0,Tue Apr 28 14:52:13 2015 UTC,One. Large. Commit. ... sigh
git,33tjww,ElectroYak,14,Sat Apr 25 14:18:27 2015 UTC,I use this guy:  http://git-scm.com/downloads
git,33tjww,johnny5canuck,6,Sat Apr 25 14:27:36 2015 UTC,"For the command line, Cmder + Clink will make the CMD prompt a bit nicer. And if you were a big shell user on the Mac, try GOW for a bunch of the shell tools you were used to (Gnu on Windows).  For a GUI, look into SourceTree, it seems to be the best GUI I've tried, only downside I'd say is that at times it can be a bit slow. But I also think Atlassian (the creator of SourceTree) is aware of the issue and seem to be trying to resolve it.  For merging/diffing, look into P4Merge, from Perforce. You don't need the entire Perforce version control system, just the merge/diff tool, and it is a free download.  Setup your git config mergetool reference to P4Merge so it is the default, it does a pretty great job of handling all your merge conflicts.  edit: add links"
git,33tjww,Mael5trom,5,Sat Apr 25 17:18:38 2015 UTC,I'm really liking SourceTree. It's wonderful for Git rookies like myself.
git,33tjww,InternetArtisan,1 point,Sat Apr 25 17:36:10 2015 UTC,"Even being pretty advanced with git CLI, the diff formatting is worth the install."
git,33tjww,bluecamel17,2,Sun Apr 26 01:58:13 2015 UTC,+1 for Cmder
git,33tjww,Nevik42,1 point,Sat Apr 25 20:52:31 2015 UTC,"What does P4Merge offer over KDiff? Do you also mean set up 2 different mergetools, how does that work?  Not trying to sound negative, genuinely curious!"
git,33tjww,IntricateRuin,1 point,Sat Apr 25 23:00:41 2015 UTC,"Mostly P4Merge is just has a nicer UI compared to KDiff (my opinion, of course). From a feature standpoint, I believe they are pretty equivalent.  And no, sorry, I didn't mean to imply that anyone should use two mergetools, I just meant to setup the gitconfig to reference P4Merge so it becomes the default mergetool."
git,33tjww,Mael5trom,1 point,Sat Apr 25 23:12:11 2015 UTC,"Perfect! Thanks for clarifying. Think I'll give P4Merge a go :)  Edit: Switched over a few days ago and it's beautiful! Thanks for the suggestion, definitely converted!"
git,33tjww,IntricateRuin,1 point,Sun Apr 26 07:29:49 2015 UTC,why Cmder + Clink? does clink adds additional features to cmder?   I'm totally noob. Could you explain more for me please?  Thanks.
git,33tjww,erdemece,1 point,Mon Apr 27 09:27:21 2015 UTC,"Cmder makes the command line a lot prettier, plus it installs Clink which installs a number of utilities that make CMD more like a Linux prompt. Check out the links, there are descriptions of each of the tools and what they do."
git,33tjww,Mael5trom,1 point,Tue Apr 28 01:39:37 2015 UTC,"You shouldn't need to install both as Cmder itself includes Clink.  If you're asking why Clink itself useful; it offers a bunch of features that emulate those found on traditional unix shells such as tab completion, keyboard shortcuts (ctrl + v for paste is huge), history search and many more. See here for more."
git,33tjww,IntricateRuin,1 point,Tue Apr 28 09:28:09 2015 UTC,Doesn't Cmder already have Clink?
git,33tjww,grizzly_teddy,1 point,Mon Apr 27 21:52:43 2015 UTC,"I think it might, I had Clink installed before Cmder, so wasn't sure whether it came with Cmder or was just there because I already was running it."
git,33tjww,Mael5trom,3,Tue Apr 28 01:36:33 2015 UTC,You could just run zsh on windows via mingw - https://msys2.github.io - pacman -Ss zsh
git,33tjww,TingPing,2,Sun Apr 26 02:44:13 2015 UTC,"Command-line works fine for Git on Windows.  The things you'll miss are the more sophisticated tab-completion and easier copy/paste of systems with Unix-like shells.  So, you'll find it a little clunkier to use, but all the functionality is there."
git,33tjww,cfmdobbie,2,Sat Apr 25 14:56:31 2015 UTC,"If you use third party prompts like Cmder or Console2, you can get things like tab completion back on windows. I've been using these guys on my Windows 8.1 box for almost 2 years."
git,33tjww,Bbentley1986,1 point,Sat Apr 25 16:43:02 2015 UTC,Yeah thats what I've realised. I think I'm just going to have to put up with the clunk!   Thanks
git,33tjww,frumious,4,Sat Apr 25 15:06:38 2015 UTC,You can install Cygwin for a sort-of Unix experience on MicroSoft Windows.
git,33tjww,djryan,6,Sat Apr 25 15:08:50 2015 UTC,You're committed to Windows then you should be using PowerShell.  There's a module called PoshGit that gives a very nice overlay on top of PS1 with tab completion and status in the command line.
git,33tjww,nVitius,1 point,Sat Apr 25 16:01:13 2015 UTC,"+1 for PoshGit. This blog post gives a pretty decent guide for setting it up. It also show you how to set up your ssh-agent properly, which is important."
git,33tjww,foosel,2,Mon Apr 27 20:31:29 2015 UTC,"ConEmu paired with Git Bash is what I use, can't complain."
git,33tjww,grizzly_teddy,1 point,Sat Apr 25 22:59:13 2015 UTC,See Cmder
git,33tjww,IntricateRuin,1 point,Mon Apr 27 21:53:18 2015 UTC,Have you thought about cmder? It's effectively a skinned ConEmu with a few extra convenience features.
git,33tjww,toupeira,1 point,Tue Apr 28 09:33:36 2015 UTC,"Babun is brilliant, it's basically a wrapper around Cygwin and comes with a nice terminal and oh-my-zsh by default."
git,33tjww,Mael5trom,1 point,Sat Apr 25 18:12:46 2015 UTC,"Thanks - that looks pretty nice. I'm going to give it a look. I'm pretty happy with Cmder+Clink+Gow, but it's still based on top of the Window's CMD prompt."
git,33tjww,toupeira,1 point,Sun Apr 26 03:31:19 2015 UTC,"Those look interesting too! The nice thing about Babun though is that it also has a package manager for Cygwin (called pact), so other tools like tmux are just a command away and work (mostly) the same as on Linux / OS X. I rarely use Windows so it's great that I can just reuse my dotfiles."
git,33tjww,Mael5trom,1 point,Sun Apr 26 04:23:35 2015 UTC,"Hmmm...looks like Babun can't run Node by default. You need to launch it manually through something like Cmder. And then npm wasn't working, you have to setup an alias to tell npm to run via the Windows cmd process rather than under Cygwin.  So heads up, there is a bit of a pain if you want to develop Node apps using Babun."
git,33tjww,toupeira,1 point,Sun Apr 26 07:17:28 2015 UTC,"Hmm I didn't have those problems, Node's and NPM's bin directories should be present in Windows' $PATH which Babun adds to its own, so commands like node, npm and grunt just work for me.  Note that I was using the .msi installer from https://nodejs.org/download/"
git,33tjww,Mael5trom,1 point,Sun Apr 26 13:07:57 2015 UTC,"That is how I had node installed as well. It's a known issue with node and Cygwin - https://github.com/joyent/node/issues/6459. And the reason npm wasn't working was because the differences between Windows and Linux line feeds, https://oligofren.wordpress.com/2014/02/12/using-the-node-package-manager-npm-with-cygwin/.  Both ""existed"" and were found on the path, they just didn't work without some workarounds. I sorta documented my steps here: https://github.com/babun/babun/issues/113"
git,33tjww,toupeira,1 point,Sun Apr 26 21:58:01 2015 UTC,What version are you using? I'm on 0.12.2 here (Windows 7 32-bit) and didn't encounter any of these issues.
git,33tjww,Mael5trom,1 point,Mon Apr 27 07:20:28 2015 UTC,"Still on .10.x, that could very well be the difference."
git,33tjww,0xJRS,1 point,Tue Apr 28 01:35:51 2015 UTC,I'm actually in the middle of transitioning from cli git to SourceTree and really liking it to be honest. Give that a try.  Edit: Not sure if it has a windows version but another dev where I work uses SmartGit. Haven't tried it myself but its his favorite git gui.
git,33tjww,afraca,1 point,Sat Apr 25 20:04:59 2015 UTC,"Just to be complete, I suspect suggestions by others are all great, but here's another one:   For my side-job I work with the Github for Windows client. They provide you with a ""Git shell"" which is an enriched Powershell window, works fine for the small things I did. (mostly on Mac now, so not sure how powerful it is)"
git,33tjww,ElevenSquared,2,Sun Apr 26 13:17:06 2015 UTC,"Github for windows users poshgit for the git shell by default. You don't need to use github for windows, but it does make getting poshgit installed very easy."
git,33tjww,Manitcor,0,Sun Apr 26 20:43:15 2015 UTC,Aside for the suggestions already here (all of which are good). Also check out tortoisegit. It provides direct explorer shell integration.   Personally I tend to use different tools at different times too. SourceTree for example is great for picking apart history. While Tortoise makes it so I don't have to think about commands at the end of a long day.
git,33sfb4,For_America_,1 point,Sat Apr 25 04:18:11 2015 UTC,I'd reckon it might be the same user as the one you are setting permission to App_Data folder - IIS_IUSRS.
git,33mfy6,sfall,28,Thu Apr 23 18:37:29 2015 UTC,"""Branches are cheap.""  Using a branch should give you the mental freedom to code with wild abandon. When you're not sure, or when you're struck by inspiration, you should simply branch and ""Go for it!""  Coding is a creative process, and all creative activities benefit from experimentation, exploration, and the willingness to fail. Branches make all of that much easier and/or less painful."
git,33mfy6,pi3832v2,7,Thu Apr 23 21:10:11 2015 UTC,"This is an incredibly succinct description of why I think branches are awesome. The freedom to go on ""r&d safari"" with a feature and still be able to checkout back to reality is significant"
git,33mfy6,eoincampbell,4,Thu Apr 23 23:31:45 2015 UTC,"It also helps out with Uncle Bob Martin's (""Clean Code,"" ""Clean Coder,"" etc.) ideas of being a mature and responsible coder. In one of his talks he speaks as a manager, saying (paraphrasing): ""Don't ever tell me that you can't build the code the moment I ask you to, because you're in the middle of tearing it apart, and it could be a few hours before you get it back to a working state."" Git makes that old problem a non-issue. Just save, stash, checkout master, and build. You're never more than seconds from completely tested, working, ready-to-build-and-deploy code, because that's the state of the latest thing on master, if you're using git optimally."
git,33mfy6,gfixler,2,Fri Apr 24 16:35:50 2015 UTC,"Coding is a creative process, and all creative activities benefit from experimentation, exploration, and the willingness to fail. Branches make all of that much easier and/or less painful.   This is more why you need tests than branches."
git,33mfy6,pydry,1 point,Fri Apr 24 14:12:31 2015 UTC,"No, that's too large scale. What pi3832v2 is talking about is getting a bit of code to a happy state, and then being able to quickly branch out and just try something out without worrying about what happens next (will you need to roll back or merge?). Branching is so cheap and easy to do."
git,33mfy6,rowe92,2,Fri Apr 24 17:12:56 2015 UTC,"I usually try something and if it doesn't work I don't commit it. I try and keep my code in a perpetually happy state.  Is this not normal?  I know branching is cheap and easy, but not branching is cheap and easy too. Creating a branch and later abandoning it sounds expensive, though, even if it does mitigate the need to roll back."
git,33mfy6,pydry,2,Fri Apr 24 17:24:15 2015 UTC,"I usually try something and if it doesn't work I don't commit it.    Ok, but what if it doesn't quite work, but it might still be the best solution.  So you could stash it, try a different approach, then decide between the two.  But stashing has risks and is hard to review later."
git,33mfy6,BezierPatch,1 point,Sun Apr 26 16:43:20 2015 UTC,"I'd rather commit something that works but isn't quite the best solution.  Once it works, I incrementally refactor it into a better solution. After each increment I make sure the test(s) still pass and then I commit. Then I incrementally refactor again.  It's usually near-impossible to see what the 'best' solution is in the beginning, anyhow."
git,33mfy6,pydry,1 point,Sun Apr 26 17:16:42 2015 UTC,"The problem is especially in the prototyping/high level hardware design I do there are vastly different ways of doing things and re-factoring between them isn't easy. it wouldn't be incremental, it would be faster to revert to the commit before you started.  You genuinely have to experiment first to see if it will behave like you want."
git,33mfy6,BezierPatch,1 point,Sun Apr 26 17:24:11 2015 UTC,"Creating a branch and later abandoning it isn't expensive, if we're talking about code changes. Branches are not an entire copy of the repository, they are a reference to a commit. They're tiny little tags! The git versioning model is very lean in this regard; if you've come from SVN where entire trees are copied you'll be surprised how git works. Expense doesn't even come into it. If you're storing exceedingly large files in your repo there's usually a reason not to; and I can bet that solo developers aren't working on the kind of software that needs large file storage.  I don't know about you, but often I need to get to a series of logical points (especially when refactoring code) that I can't just do in one massive change - you should commit more frequently than that!  By branching you can easily rock back to your happy state and you've still got a record of the experimental changes should you suddenly decide there's something of worth in them. By resetting your single branch if you don't like what you've done, you'll have to hunt them down again in the reflog and they will eventually be garbage collected.  I'm sure at some point you'll run into an issue where you'd have wished you'd branched."
git,33mfy6,rowe92,1 point,Fri Apr 24 17:42:35 2015 UTC,"Creating a branch and later abandoning it isn't expensive   It is in the sense that you have just wasted the work that you did until the point where you abandoned it. I am well aware that it is not computationally expensive.   I don't know about you, but often I need to get to a series of logical points (especially when refactoring code) that I can't just do in one massive change - you should commit more frequently than that!   I commit very frequently. I just make sure that all the tests pass when I commit, and I try and make each commit tiny, incremental and non-breaking irrespective of whether I am adding features or refactoring existing code. This is my default working pattern.  Where this isn't possible, I branch, but where it isn't possible usually means a pile of technical debt or insufficient availability of tests. That means instead of my normal perpetual 'happy state', I am, like you, only experiencing this happy state intermittently."
git,33mfy6,pydry,2,Fri Apr 24 18:09:24 2015 UTC,"You've haven't wasted the work. You can merge the branch or cherry pick the commits you want to keep. Hell, you can just diff them if you want to read the code for some insight? The branch is still there if you want to use it, even if you've switched your HEAD elsewhere...  Or if you mean that the work you've done in that branch hasn't furthered your understanding - well no more than if you hadn't tried it in the first place. I'm not sure I follow you."
git,33mfy6,rowe92,1 point,Fri Apr 24 18:32:05 2015 UTC,"You've haven't wasted the work. You can merge the branch or cherry pick the commits you want to keep.   Ok, so you've thrown away the work that you didn't cherry pick?  Either way if you are branching with the intention of disposing of some of your work, it implies that you're doing something a bit wrong.   Or if you mean that the work you've done in that branch hasn't furthered your understanding   I mean any of this 'zombie' code that doesn't make it into the main branch and you never intend to let it make it into the main branch.  If it's not useful to the project, why is it committed at all? What purpose does committing it on any branch serve?  I use branches (a lot) to allow different people to easily work on or use different versions of the software simultaneously, but always with the intention of eventually merging everything back on to one main branch. Some branches get merged every 20 minutes, others might take six months, but they should all get merged eventually.  On my own projects, though, this need doesn't usually arise. Or at least, it won't unless the project becomes very popular."
git,33mfy6,pydry,2,Sat Apr 25 04:21:35 2015 UTC,"Jesus dude.  The purpose of commiting is that you get yourself to a point in the code where you're happy. If you're doing experimental work, this might be because you've written a function that you're cool with but you still need to see how it will work with the rest of the code. It's just logical markers because nobody sane is going to build up 4 hours of work in to one specific commit having hacked the crap out of their code. I can't understand you  I start branching some work because I want to try something out. I do a few changes and it looks good. I commit. It costs nothing and it gives me a logical platform to continue my investigation.  I have no idea what you are talking about in the first part. I make a branch and I do what I want with it. You do realise that commits don't go away, right? They're sitting there in a branch and I can do what I like with them. If I leave the branch and go back to master to try something else there is literally no cost for doing so; and I have the benefit of having a record of my code should I need to use it for many reasons already explained.  I'm sorry, but if you're literally working on one branch at all times you are using git wrong and gimping yourself. Do you actually reset master every time you want to go back? The moment you realise you might actually need something from commits you made but abandoned you load up the reflog? This makes no sense  You know full well that you reach logical cornerstones in the work that you do and that commiting that work is a sensible thing to do. I can understand if your toy projects involve changing a few lines of CSS or a program that counts to 100, but I'm willing to think that they're bigger than that, and give you the benefit of the doubt."
git,33mfy6,rowe92,14,Sat Apr 25 08:26:13 2015 UTC,Feature branches are helpful even when you're solo.
git,33mfy6,jakkarth,3,Thu Apr 23 18:39:23 2015 UTC,How are they useful. I honestly don't know.
git,33mfy6,jakkarth,15,Thu Apr 23 18:40:31 2015 UTC,"They allow you to separate different features so you can develop them in parallel. If you need to do a bug fix while you're in the middle of creating a feature, you can just switch back to your main branch to make the fix, then rebase the feature on top of your work."
git,33mfy6,michaelKlumpy,3,Thu Apr 23 18:44:19 2015 UTC,re-base or         git checkout feature         git merge master (that's how I've done it so far)
git,33mfy6,tinyOnion,3,Thu Apr 23 20:41:05 2015 UTC,You can branch your branch and try the rebase too. If it doesn't work out well you don't lose anything.
git,33mfy6,bigrodey77,1 point,Fri Apr 24 11:13:45 2015 UTC,That creates a new merge commit in the feature. Rebase does not.   git checkout master git pull origin master git checkout feature git rebase master
git,33mfy6,Kraigius,3,Fri May 8 15:54:24 2015 UTC,"Exactly. For my last work I forced myself to use feature branch, I never really used branch since I'm mostly working solo and I was a bit harsh on the git history.  For a bit of a context, I'm working on a minesweeper game. Got a master branch, which will only hold release versions (0.1 and 1.0 tbh). Dev branch will contain new features, only those properly functional will be merged to the dev branch.  Made the following branch:    ""config""  - feature that add a config file for multiple settings. ""winLost"" - feature that implement the Win and Lost conditions for the game   and a bunch of others.  I started to work on config, got bored, went to winLost after a few hours.  Everything is in their own little sandbox. Once winLost was done, not necessarily complete, but that the game could recognize a win and a lost and inform the player, I was done with the branch.  Went to dev, merged winLost, deleted winLost, went back to config and rebased dev to it.  Everything is fluid."
git,33mfy6,grumbel,3,Thu Apr 23 22:03:25 2015 UTC,"They can be used to group commits together, if you merge them with --no-ff they show up in the history like this:  * Merged feature/about-window |\ | * Added close button | * Added scrollbars | * Added window |/ *"
git,33mfy6,LifeBeginsAt10kRPM,2,Fri Apr 24 12:12:07 2015 UTC,"If you need a last minute change to production code you can commit to master then to the production branch, having 20 commits after you're last master commit isn't helpful for this.."
git,33mfy6,NeoMarlin,11,Fri Apr 24 03:05:44 2015 UTC,If you have the tendency do something like cp index.html index2.html to test another approach in index2.html then a feature branch would be more appropriate :)
git,33mfy6,scottchiefbaker,7,Thu Apr 23 20:57:53 2015 UTC,"Don't think about branches in a solo vs team context, think about them as an organization tool. ""These 5 commits make up feature KittenChallenge"", is easier to see in a branch than 5 random commits."
git,33mfy6,gfixler,4,Thu Apr 23 22:46:02 2015 UTC,"I use branches in most of my solo repos. I have some in which I don't, like one I use to track bookmarks. However, here's a page of git logs from my /r/dailyprogrammer repo; these read from the bottom up:  * 169d365 (HEAD, origin/master, origin/HEAD, master, 211_intermediate) Try different take on 211 Easy game function *   65871b8 Merge branch '211_easy' |\   | * 70f359e Add solution for 211 Easy The Name Game |/   | * ff6d9ca (origin/210_hard) Add default Bot creator function bot | * 813af9d Remove Cmd data type | * 48b1713 Replace parseCommands function with step function | * b67ec88 Add parseCommands function | * 678589a Begin Main.hs with Facing, Cmd, Bot data types |/   *   5755dea Merge branch '210_intermediate' |\   | * e747bad Fix challenge.ppm line breaks | * e0e2834 Change unwords to unlines to fix toPixmap wrapping | * f1e9e45 Add solution to challenge input as challenge.ppm | * 1c8f59a Finish solution with final line in main function | * 5be3fcc Add hgrad3 function | * fbba91d Shorten that pesky fromIntegral in intSteps | * ae88930 Add intSteps function | * 730caa8 Improve toPixmap | * 645209f Add main, toPixmap, spacedInts to new Main.hs file * | c1e0ea1 Add dist to .gitignore * | fe5fff4 Add .gitignore file * |   4956d5d Merge branch '209_easy' |\ \   | |/   |/|    | * 8f577bd Remove readUserTime and formatUserTime functions | * 14110ae Use parseTime and formatFlair in main | * ec48ab6 Add formatFlair function | * 9e1a34f Add parseTime function | * 2c29857 Properly print output from main function | * 76c09f7 Add formatUserTime function | * 9fa4080 User readLn and replicateM in main | * 0485938 Add readUserTime function | * da08842 Remove utpairs temp data | * a5d868e Add simple main function to read lines into list | * 4715441 Simplify names in getFlairs function | * b59134c Make imports explicit | * 3fdbd1a Add type for getFlairs | * afacf42 Add getFlairs function to calculate times |/   | * 941bc05 (origin/209_intermediate, 209_intermediate) Add showExBox function | * 84d1549 Refactor ExBox, related functions to use (l,t,r,b) | * fd8e78d Add expandPack function   Branches let me skip back and forth between different challenges, and see their progress in separate lines of development. You can see near the top ff6d9ca (origin/210_hard) - I haven't finished that one, so it's not merged back in, and it's easy to see what I've been doing on it in isolation, not scattered throughout all the other challenges I've been playing around with.  This also means that the master branch is made only of completed challenges, so when I switch to master, the project folder contains only the challenges that I consider done. I can also do git branch and see the branches I'm currently working on, because those heads still exist. I can do git branch -a to see the origin list, too, which shows me even the ongoing ones for which I don't have a local head (I work on these in different places on different machines. IOW I'm using the branch system to automatically keep track of which ones I haven't completed, on top of the organizational and isolationary aspects mentioned earlier.  I also get to be less explicit in my subject lines this way. What does the subject line for 3fdbd1a Add type for getFlairs relate to? I can follow the commits up that branch and see 4956d5d Merge branch '209_easy', and I know that was part of that effort. Whenever I'm not on a branch, I need to qualify my subjects more, so I know what I'm referring to. Take these commits from another repo - I was using branches, but was at that point between them, back on master:  * 7602cf7 Remove unneeded tanParts list in anim.py * 1f4bf1f Refactor name in core.py test helper function * c9d4f03 Improve docstring/comments in core.resolveJSONData   See how I'm naming the files in the subjects? There's no branch to explain where my efforts are localized, so I'm adding more information to the subject. I could just rely on something like --name-only when viewing log output, but I prefer this one-line readout in my day-to-day work, and my commits are always granular enough to speak of in this way in my subject lines within the 50-character soft limit. I find it much easier to read commits as one-line 'bullet points.'  Another use: I may decide I don't want a feature I've added. In the first log output at the top there's a merge commit - 5755dea Merge branch '210_intermediate' - with ~10 commits in it. I can get rid of all of that in one shot with git revert -m1 5755d. Git will revert all of the changes made by that merge, in this case wiping out the 210_intermediate branch as though it never existed.  Finally, branches break up the history, and give your eyes and your brain a rest. You can see logical units of work at the feature level, and reason about them there, instead of wading through hundreds of commits of overlapping and intersecting efforts, like this:  | * b26f9bf Add skin.getSkinInfs | * 030746a Add skin.tryForSkin | * d1061a4 Extract and separate things a bit in skin.py tests | * 6381b10 Return just the name (no path) from func.getParent | * 685e4e2 Fix shape.py poly conversion test | * cd4ab33 Remove shape.shapeToTransform | * 520b86c Move shape.shapeToTransform near other conversions | * 8d0b0dd Remove implemented mesh->verts names from todofunc | * f295ff2 Add shape.meshToVerts | * 321505e Fix test class name for shape.isMesh | * fe19596 Add shape.isShape | * 04d6773 Add shape.tryForShape | * 547f93b Remove redundant shape.getMeshFromMeshShape | * f63279d Add shape.shapeToTransform | * 0f5837c Refactor shape.py selmask functions to filters | * 0e56131 Add shape.getOnlyShape | * 808a246 Add shape.isMesh | * ac45aa8 Remove skin.getVertPosition | * 7506512 Remove redundant skin.meshToSkin | * 55ba003 Refactor skin.getSkins -> skin.getSkins | * cc4f20b Add skin.getSkins | * ce009b1 Add shape.getOnlyShapeOrDie | * 5293fbf Return [] from shape.getShapes when no shapes | * f8a398a Move shape.py selmask functions up in file | * bc5df18 Move shape.py poly conversion functions up in file | * a4ff44f Fix weight-averaging test floating values | * e94d75a Remove shape.getVertsConnectedToVerts | * 2c1077c Add shape.vertNeighbors | * dd0e504 Add name.buildComponentName | * 29c762e Rename shape.py poly selection mask functions   You have no idea what the relationship is between any of these commits. Is this one long feature I'm working on, or ongoing improvements, or is it 4 features that I keep skipping back and forth on? From a commit standpoint, this is gibberish. You have to go in and understand each commit, and retain it all in your head to begin to rebuild lines of development. It's not helping anyone.  I also love being able to play at will on a branch, safe in the knowledge that if I end up not liking any of it in 3 days, I can just delete the branch, and I don't have to extricate it from the rest of what's going on in master. Every feature I work on - whether with a team or on my own - gets its own branch, and I very regularly switch around between 4 or 5 in a single project. This lets me keep it all separate and easy to follow, reason about, and quickly get back up to speed on when I get back to work on Monday mornings, after my brain dumps all of it over the weekend."
git,33mfy6,gfixler,1 point,Thu Apr 23 21:58:48 2015 UTC,Wow great!
git,33mfy6,ferglovesyou,1 point,Fri Apr 24 14:53:38 2015 UTC,i have another question you maybe able to help me with. I started by writing a chrome app now I am getting requests to put it in another medium mobile app or webpage. What is the best way of utilizing git to utilize common code for core functionality?
git,33mfy6,cmputrnx,1 point,Sat Apr 25 21:40:48 2015 UTC,"I'd probably use submodules, because to me they most accurately reflect what's going on with dependencies. They can be a bit contentious, though, and IMO this is mostly down to lack of info. Submodules kind of sit quietly in the background, whereas I think a few reminders at opportune moments would help out a lot, even for me, someone who uses maybe a hundred submodules across 2 dozens repos, and completely groks the idea.  A submodule is just another repo, which your repo knows only 3 things about: 1) its URL, 2) the project-local path where your repo keeps its copy it, and 3) which commit it should be on. The 3rd one is the only one that changes over time; each commit in the containing repo records which commit the submodule should be on, and thus what should be in the local folder in the project where it keeps its copy of it. You must add changes to the submodule and commit them, just as when you change a file or folder in your project, but all you can record in your repo is which commit the submodule should be on, so you have no fine-grained control from the containing repo, which is good; all change inside that repo are the concern of that repo. As a dependent, you can - and should only be able - to pick a commit for the submodule to be on in each of your commits, and that's all git allows for.  This is a key point. A key element in grokking submodules is thinking of them as 3rd party dependencies. Whenever I go into a submodule, I change hats. I think of myself as a developer who knows nothing about the containing project. I allow that the person running the outer repo (me, when I'm not in the submodule) has opened an issue and asked for some feature from this dependency I maintain, i.e. the core library, but when I then implement it, I do so as a library maintainer, in a way that stays true to the core, works nicely for anyone who might want to use this repo as a submodule (including me in other repos), and without any hacks, circular dependencies, or grossly breaking changes. It's good to think of the submodule repo as it's own, public thing, used by many, listening to the needs of any projects that use my efforts, but never focusing solely on fixing something for one dependent at the expense of others. If you always work that way, you'll maintain a clean core.  When the maintainer of my dependency/submodule (me, when I'm in there) has updated the changes, and made sure to push them to my server (I don't consider that they exist if I can't get to them while working from another PC somewhere else - and this is one of those failures of information where I think git should tell you things), then I go up to the outer repo, check that git status tells me that the submodule has new commits (because the commit it's on in its folder is not what the current commit in the outer repo says it should be on, another subtle place where people could use more information, as working against this now without first committing the new submodule's commit in the other repo means you're not keeping those changes in sync, historically, just as working against uncommitted changes in a file as you make new commits on other files is laying down bad history), add it and commit it with a message like ""Pull foo for new bar and baz features,"" along with any changes I needed to make in the outer repo to sync up with those changes.  Often I'll do all of this on a feature branch, and allow the submodule change to be its own commit, often a breaking change in the outer repo, which I then fix in subsequent commits. I'm okay with the state of the outer project not being flawless in a feature branch, as long as everything is solid again before I merge it back in. Of course, then I can push the changes in the outer repo onward.  One nice thing about this is that I don't have to go update every other repo using this dependency, because they all still say their versions of this repo - their submodules thereof - all still say it should be on an older commit, so they're still in sync with the commit in the submodule they should be synced with. I love that I can leave one tool sitting on an old version of a submodule for as long as I like, while other tools can pull in the latest and sync up, and then stop doing so whenever they stabilize.  There's only one place I know of where this falls down, and that's with hotfixes to the submodule. If you're 300 commits behind on a submodule in a particular repo, because that project isn't really changing much anymore, and a hotfix to the submodule goes live, suddenly you need to jump 300 commits forward in the submodule to get that fix, almost certainly breaking a bunch of things in the containing repo. The only way around this that I know of is to drop a legacy branch name in your local copy of the submodule in that particular tool, and on that old commit, then duplicate the fix on top of that, and then point to that new commit sticking off the old commit you were on. You can try to send that fix upstream, if you're not the maintainer, and if anyone cares, otherwise you're now maintaining that tiny branch yourself, and a new world of micromanagement can open up.  If we wrote solid code without things like Heartbleed, we wouldn't have to worry as much about this, because the only changes would be new ideas (which your old code doesn't care about), not security concerns (which your old code might very well care about). Because of this issue, it makes a lot of sense to have release points, where you say ""This is version 2.0.0,"" with a list of what changed, and then you can copy hotfixes back to the last n versions (usually with a policy, like ""we maintain fixes for 3 past versions,"" possibly encoded into a long-term release strategy). This is a way of reducing the number of old commits that need such fixes. Dependent codebases stabilize around a small number of waypoints in this manner, so you can make logical jumps forward to some other dot release, and fix against an overall changelist there, instead of walking haphazardly forward through time to random commits that seem like decent waypoints after reading all the log messages along the way. If security isn't an issue (it isn't for me; I write art tools for a local team of artists, no internet involved), things get a lot simpler."
git,33mfy6,mortonfox,0,Sun Apr 26 05:26:47 2015 UTC,"Hey, any chance your repo is on github or somewhere public? That way people can look through the commit history and see the benefit of branches."
git,33mfy6,rowe92,2,Fri Apr 24 07:49:13 2015 UTC,"While working by myself I don't typically go crazy with branches a la git flow, but I will certainly have a branch for each stage of development I have planned, each with its own tags."
