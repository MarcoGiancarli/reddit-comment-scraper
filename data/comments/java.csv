java,3e2j6c,javosize,3,Tue Jul 21 13:37:43 2015 UTC,"Had to read a bit to be clear, but this is adding an HTTP/2 client. Servers are already trickling in with Undertow and Jetty adding support. The benefits for the web are big and obvious, but I'm curious to see what kind of clever optimizations we can start squeezing into REST services. Server-push could really streamline HATEOAS."
java,3e2j6c,tootie,1 point,Tue Jul 21 14:20:20 2015 UTC,"Since it's adding an HTTP/2 client, will that mean built-in ALPN support is coming with it?  That would be nice.  Undertow for example requires ALPN, and enabling that now requires -Xbootclasspath trickery, which is inconvenient when it comes to code portability."
java,3e2j6c,mhixson,1 point,Wed Jul 22 02:31:18 2015 UTC,Where is asString() defined?  I assume it's a static import on HttpRequest?
java,3e2j6c,JustinKSU,2,Tue Jul 21 19:49:19 2015 UTC,Thank God. No more HttpURLConnection.
java,3dzq2d,habitue,40,Mon Jul 20 21:04:25 2015 UTC,See here: http://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-for-2014/
java,3dzq2d,xela321,6,Mon Jul 20 21:52:38 2015 UTC,"Oh man, this is beautiful, thanks for this!"
java,3dzq2d,HaMMeReD,2,Mon Jul 20 22:03:37 2015 UTC,"The only major difference worth noting is that Gradle is becoming a very popular build tool, probably will surpass maven soon."
java,3dzq2d,hugith,3,Tue Jul 21 04:02:15 2015 UTC,What about Java 8?
java,3dzq2d,HaMMeReD,5,Tue Jul 21 05:48:56 2015 UTC,"We've adopted and standardized on it at my company for all environments. Never adopted a new major Java release this soon.  It feels like Java 8 is generally being adopted considerably faster than older releases (you can google ""java 8 adoption"" for a little more concrete data than my feelings)."
java,3dzq2d,Truthier,3,Tue Jul 21 10:08:59 2015 UTC,My main concern with Java 8 is android support. I've already fragmented my client/server code to account for googles fragmentation of the ecosystem.
java,3dzq2d,xela321,-4,Tue Jul 21 15:16:51 2015 UTC,Agreed. Also It's lagging (doesn't reflect the newer stuff as much as what's most popular mainstream) usually mainstream isn't best and it's slow to catch up to the best tech   Most people don't necessarily use the best tools
java,3dzq2d,worldsayshi,1 point,Tue Jul 21 05:37:46 2015 UTC,You're welcome
java,3dzq2d,robi2106,1 point,Wed Jul 22 01:02:52 2015 UTC,"As for tomcat, at least where I work it's being replaced by jetty as quickly as we can manage. Much nicer to work with."
java,3dzq2d,tootie,1 point,Tue Jul 21 09:26:21 2015 UTC,very comprehensive report.  thanks!
java,3dzq2d,rjungemann,12,Tue Jul 21 19:46:34 2015 UTC,"Spring is still popular, so is Guava. Spring Boot lets you bootstrap any kind of web project in a few clicks. Guice pretty much faded away. A lot of the excitement recently is in the core language. If you're a few years out of date, hava a look at java.nio, java.util.concurrent, streams, lambdas (streams + lambdas = list comprehensions). Scala and Clojure have been gaining fans, but aren't really mainstream."
java,3dzq2d,HaMMeReD,6,Tue Jul 21 00:15:05 2015 UTC,"Oddly enough, we used Dagger (https://github.com/square/dagger) for a few projects when I worked at Google. Seems to be popular with Android projects in particular. Unlike Guice, it can report build-time errors."
java,3dzq2d,ZakTaccardi,2,Tue Jul 21 02:29:50 2015 UTC,I saw that they even use Dagger with google maps on android.
java,3dzq2d,slobarnuts,1 point,Tue Jul 21 04:00:43 2015 UTC,Dagger is awesome!
java,3dzq2d,sazzer,2,Tue Jul 21 04:15:32 2015 UTC,"Spring Boot   Seconded. There's something about being able to create open source turnkey webapps that will see this get a lot more traction. I've built a couple already, and they are incredibly reliable."
java,3dzq2d,virtyx,8,Tue Jul 21 00:20:52 2015 UTC,"Spring Boot is great for prototyping apps and getting a quick turnaround, but it scares me for production-quality code. There's too much magic that goes on with it, and too much that it just does because it finds classes on the classpath. You can accidentally pull in a dependency as a transitive of something else, and all of a sudden you're running an in-memory database!"
java,3dzq2d,rs-485,1 point,Tue Jul 21 09:48:23 2015 UTC,"Agreed. As an outsider coming from Python and trying to break into Spring, I gave up on Spring Boot and am just using standard Spring.  Not to be cynical but I think the whole notion of Spring Boot shows a certain lapse of judgement on the Spring team, who seem to have otherwise produced some very good libraries. I don't think the problem of ""Our configuration is too complicated"" should be answered with ""Let's make an entirely separate project with completely opaque config!""  I hate when I see examples in Spring Boot because tons of the essential Spring configuration is hidden. It feels so impossible for me to fully understand what's happening in Spring a lot of the time, compared to Django where I can just launch manage.py shell_plus and say  >>> settings.MIDDLEWARE [exhaustive list of AOP-style middleware here] >>> settings.DATABASES [all database connections] >>> settings.INSTALLED_APPS [list of all Python modules, 3rd party and in-house, that Django looks at for extra database schema, template tags, etc.]   Perhaps this is easier in Django since Python has a REPL but right now for example I'm having trouble getting Spring Security to prevent access to any URLs on my app and my debugging algorithm goes something like this:   Google it If Googling didn't work, stare at my source files in bewilderment for anything that looks even one character off of the examples Get frustrated that in fact my code does look exactly like the example Find a Github sample project, clone it, watch it run, then look at the source code to see what it's doing Get frustrated when I find out it's a Spring Boot project and in fact I learn nothing from the exercise Find another example that uses Spring XML and get frustrated since I'm trying to learn with annotations and don't understand Spring XML or how it mixes with annotations Give up for the day"
java,3dzq2d,virtyx,1 point,Wed Jul 22 01:42:46 2015 UTC,"Spring Boot does have a lot of introspective features to help you cope with that. For instance, you can get reports on automatically included beans, so if you encounter a situation like that, you can figure out why it's happening and prevent it. Here's a nice webinar on that."
java,3dzq2d,vittusormi,1 point,Tue Jul 21 21:20:17 2015 UTC,Is there a nice slideshow or doc page that I can read to give me the gist of it in less than an hour?
java,3dzq2d,worldsayshi,8,Wed Jul 22 01:46:44 2015 UTC,Serious JVM languages seemingly popped out of nowhere during the past year while I wasn't paying attention and are now hot topic. Look up Clojure and Scala.
java,3dzq2d,stormcrowsx,5,Mon Jul 20 22:24:05 2015 UTC,"The scala hype seems mostly overblown? Java 8 has maybe taken a bit of the momentum out of scala. I really like scala but I haven't seen any hype recently, mostly critical texts."
java,3dzq2d,worldsayshi,1 point,Tue Jul 21 09:31:39 2015 UTC,"From what I've seen usage of Scala has steadily increased, the hype has certainly died off though.  There's more Scala in use everyday and some projects that a lot of big companies rely on like Apache Spark are written using it."
java,3dzq2d,cryptos6,1 point,Tue Jul 21 13:52:29 2015 UTC,"Oh, spark was written with scala. Interesting! Makes me even more inclined to learn spark."
java,3dzq2d,xris-l,1 point,Tue Jul 21 13:59:09 2015 UTC,"Maybe the hype is over, but that is not necessarily a bad  sign. Scala is over ten years old (and about 6 years in the industry), so there are  no more a lot of blog posts from people who have just discovered the joy of Scala. Scala is now used to do real stuff.   Java 8 is not really a rival for scala since Scala is so much more powerful and cleaner in the design."
java,3dzq2d,MordecaiMalignatus,6,Tue Jul 21 18:33:45 2015 UTC,"Also, Kotlin from IntelliJ"
java,3dzq2d,xris-l,5,Tue Jul 21 03:34:05 2015 UTC,"*Jetbrains, to be pedantic. IntelliJ is 'just' the tool. Jetbrains are the people."
java,3dzq2d,tanuma,2,Tue Jul 21 09:25:59 2015 UTC,"I'm sorry, you are right of course.   I knew, something was off, when I wrote that ☺"
java,3dzq2d,andreicristianpetcu,2,Tue Jul 21 16:28:51 2015 UTC,"Streams and some of the newer Java 8 concurrency features, such as CompletableFuture."
java,3dzq2d,grunlog,2,Tue Jul 21 00:22:23 2015 UTC,"Spring & Hibernate are still strong, Guava is more for early adopters (unfortunately), nobody uses J2EE anymore (but unexperienced recruiters call Spring + Hibernate J2EE which is wrong), people use JHipster for scafolding projects, JSP and JSF are dead (Rest backend in Java + JavaScript frontend are popular now, take a look at JHipster again)"
java,3dzq2d,andreicristianpetcu,4,Tue Jul 21 05:21:50 2015 UTC,"JEE (they dropped the 2 a long time ago) 7 isn't too dissimilar from the way mainstream libraries work (similar annotations,  usages,  etc.). I wouldn't write it off. Also, I hear Oracle will be making a big show of JEE 8 at JavaOne this year."
java,3dzq2d,purplepharaoh,0,Tue Jul 21 06:35:29 2015 UTC,"JEE need s a big fat container, everybody is moving away from this, people are using Tomcat and Jetty. At least this is the way I see things. Is there anything like Spring Boot in JEE world?"
java,3dzq2d,NimChimspky,2,Tue Jul 21 08:54:16 2015 UTC,"Newer JEE containers are neither big nor fat.  Yes they are somewhat bigger than just a servlet container, it's only marginally so.  The idea that Spring=thin and JEE=bloated is outdated."
java,3dzq2d,Luolong,-3,Tue Jul 21 12:05:32 2015 UTC,JEE is defintiely still blaoted. My current job I have to use it for the first time.  The default bean lifecycle with spring is   @Component (or controller/service)  public MyClass   And you get a stateless singleton bean that can be Autowired.  Whats the equivalent in ee ... a confusing mess thats what.
java,3dzq2d,purplepharaoh,3,Tue Jul 21 12:29:27 2015 UTC,In JEE (CDI to be precise) you don't need even that much. Having a class is enough to be able to @Inject it in any situation.
java,3dzq2d,xportebois,2,Tue Jul 21 19:40:38 2015 UTC,"The @Singleton or @ApplicationScoped annotations along with @Inject take care of all of this.  No muss, no fuss."
java,3dzq2d,bdavisx,2,Wed Jul 22 00:39:55 2015 UTC,"What web rendering framework would you recommend, instead of JSF2?"
java,3dzq2d,xportebois,0,Tue Jul 21 11:50:38 2015 UTC,"Spring is using Thymeleaf for their documentation. If you're doing SPAs with AngularJS or EmberJS or the like, then you are generally building in an HTML templating environment."
java,3dzq2d,Zeffas,3,Tue Jul 21 12:02:34 2015 UTC,"I'm currently on a project with Spring MVC and Thymeleaf. This is a pain in the ass. It's just templating, whereas JSF2 is a true web framework. I mean, JSF has its flaws, right, but its provides a lot of incredibly good stuff I didn't find anywhere (conversation scope, real and robust pojo2form mapping, easy ajax rerendering, ...)."
java,3dzq2d,cryptos6,2,Tue Jul 21 19:32:21 2015 UTC,"I really dislike Spring stance on view technology support - Spring Boot does not support JSP's and are pushing Thymeleaf which haven't gain traction and I would argue that it never will.  First of all its not that much better than jsp (e.g. its so far from Razor@ASP.NET). Secondly its very ugly when combined with frameworks like Angular - HTML elements are now polluted with both server-side and client-side stuff - total mess.  So, many developers who don't buy this ""no templates, html + REST only"" hype are left ignoring solutions like Spring Boot."
java,3dzq2d,rs-485,1 point,Tue Jul 21 14:34:07 2015 UTC,I like razor too. The engine that comes closest to it in the java world is http://rythmengine.org. Very nice!
java,3dzq2d,pooper_scooper123,1 point,Tue Jul 21 18:37:27 2015 UTC,Spring Boot supports JSPs. Why are you thinking it doesn't? See http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html.
java,3dzq2d,andreicristianpetcu,0,Tue Jul 21 21:23:16 2015 UTC,What about Play Framework?
java,3dzq2d,xportebois,0,Tue Jul 21 14:27:22 2015 UTC,"Rest + whatever on the client side (AngularJS, ReactJS). Not Java, not compiled and not duplicating the whole DOM like JSF does it. If I have to pick between JSF and JSP, I pick JSP since I can build my own CSS+JS on top."
java,3dzq2d,andreicristianpetcu,2,Tue Jul 21 14:48:51 2015 UTC,"Never had the opportunity to try Angular or React. Do they provide advanced stuff like conversation scope, auto mapping for form fields (and a true mapping, not the crap Spring MVC does)?"
java,3dzq2d,OceanOfSpiceAndSmoke,-1,Tue Jul 21 19:29:16 2015 UTC,The most Sci-Fi forms you can imagine...... AngularJS has them.
java,3dzq2d,andreicristianpetcu,3,Tue Jul 21 20:25:52 2015 UTC,Guava is more for early adopters   Why do you say this? It is among the top five libraries used with java on github:   JUnit (imported by 64% of top Java projects) SLF4J (imported by 22% of top Java projects) Log4j (imported by 16.76% of top Java projects) Google Guava (imported by 15.6% of top Java projects) apache-commons (imported by 12.63% of of top Java projects)   http://www.javaworld.com/article/2924315/open-source-tools/javas-top-20-the-most-used-java-libraries-on-github.html
java,3dzq2d,OceanOfSpiceAndSmoke,2,Tue Jul 21 08:48:55 2015 UTC,"15% is a small percentage but I was expecting less. It is a good library, I dislike the fact that people are not using it more."
java,3dzq2d,robi2106,1 point,Tue Jul 21 08:52:22 2015 UTC,"I agree that more should use it. However, I disagree that 15% is a small percentage."
java,3dzq2d,avoidhugeships,0,Tue Jul 21 11:17:39 2015 UTC,"speaking of top 5 (ok fine it isn't in the top 5, but it is for static analysis), is there a source for findBugs that isn't sourceforge? or is that still the host for the project? SF seems to be having problems today. http://www.img42.com/s17FE"
java,3dzq2d,fundieInAChainWax,1 point,Tue Jul 21 19:55:00 2015 UTC,"Ecosystem is still pretty fractured but you can probably see that in the responses.  Java EE (CDI, JSF, EJB) are very popular although the Spring fans will try to convince you otherwise.  Spring MVC is still a popular framework as is Hibernate."
java,3dzq2d,frugalmail,2,Tue Jul 21 17:58:20 2015 UTC,"Jeff Atwood's Law - any application that can be written in JavaScript will eventually be written in JavaScript.  Also, keep up with updates from Thoughtworks Technology Radar."
java,3e2ovt,supersanista,2,Tue Jul 21 14:26:01 2015 UTC,Ant is a real pain but Maven does not have all the features I use in it :-(
java,3e2ovt,markee174,2,Tue Jul 21 20:07:24 2015 UTC,Good thing you can run Ant tasks in Maven using the antrun plugin then!  https://maven.apache.org/plugins/maven-antrun-plugin/
java,3e2ovt,BinaryRockStar,0,Wed Jul 22 01:05:42 2015 UTC,Even better you can run both of them inside gradle without catching the diabetus (XML)
java,3e2ovt,-INFEntropy,2,Wed Jul 22 01:41:14 2015 UTC,"I haven't used Gradle professionally but I do actually like the XML in Maven. Makes builds more declarative than imperative, which is how I seem them. You're defining the structure of your build instead of giving it a list of commands."
java,3dyh56,lukaseder,7,Mon Jul 20 15:49:13 2015 UTC,"So this is pretty fascinating stuff and it looks really cool but I expect a lot of pain from this change as developers and release engineers get familiar with the system. Also how does this impact the use of Maven, Gradle or other dependency resolving build systems?"
java,3dyh56,Liqmadique,8,Mon Jul 20 16:55:04 2015 UTC,... or OSGi
java,3dyh56,duhace,2,Mon Jul 20 16:57:04 2015 UTC,"It's supposed to be compatible with OSGi, or at least I have heard that"
java,3dyh56,obfuscation_,4,Mon Jul 20 20:31:26 2015 UTC,"I agree it could cause a lot of pain, so hopefully the reasons to upgrade are compelling enough, lest we end up with a Python-esque major version divide."
java,3dyh56,jonhanson,5,Mon Jul 20 20:30:23 2015 UTC,"In the case of Maven, I don't see how it could make things much worse..."
java,3dyh56,thomascgalvin,3,Mon Jul 20 18:55:00 2015 UTC,"If I'm reading correctly, Java 8 code will for the most part ""just work"" as Java 9 code. Modularization has to be explicitly turned on, or else everything will appear in the default, nameless module."
java,3dyh56,vittusormi,3,Tue Jul 21 00:19:10 2015 UTC,"According to this picture about planned modularization in Java 9, it looks like a lot of people have a lot of unlearning and relearning to do when surfing API docs. https://bugs.openjdk.java.net/secure/attachment/21573/jdk-tr.png"
java,3dyh56,adila01,1 point,Mon Jul 20 19:14:24 2015 UTC,It is unfortunate that we cannot have multiple versions of a module.
java,3dyh56,eliasv,4,Tue Jul 21 00:00:17 2015 UTC,"Accross an entire application or project you can! But each module can only depend on one version (which makes sense, you could never have multiple on the same classpath). You can depend on more than one through transitive dependencies, so long as those dependencies are not explicitly exported.  Basically it will behave pretty much like osgi in this one regard, afaiu."
java,3dyh56,sanity,1 point,Tue Jul 21 07:12:07 2015 UTC,"I'd like to understand how this relates to Maven/Gradle/Ivy etc, and also whether it replaces dependency injection frameworks like Guice."
java,3dzds2,kepasanolose,1 point,Mon Jul 20 19:38:21 2015 UTC,"Amusing, but it makes kind of sense: https://jira.mongodb.org/browse/JAVA-836"
java,3dzds2,PdoesnotequalNP,2,Mon Jul 20 20:51:41 2015 UTC,But it could bottleneck on the system's entropy pool which isn't Web Scale.
java,3dzds2,esquilax,1 point,Mon Jul 20 21:47:16 2015 UTC,"I am not sure whether you are joking, but just in case: Math.random() is not cryptographically secure and does not decrease the system entropy in any way."
java,3dzds2,PdoesnotequalNP,2,Mon Jul 20 22:27:34 2015 UTC,"Yes, I was joking."
java,3dztz9,talslain,1 point,Mon Jul 20 21:32:42 2015 UTC,"Nice channel, I recommend uploading at 1080p and using a noise gate."
java,3dztz9,Jire,1 point,Tue Jul 21 00:58:54 2015 UTC,"Thank you, the actual footage of coding is 1080p, it's just the camera I use maxes at 720 and okay I'll try with a noise gate, thank you for the feedback  Matt"
java,3dztz9,lulzmachine,1 point,Tue Jul 21 07:05:48 2015 UTC,"If your camera only gets 720, then you can't ""upcode"" it to 1080. The data isn't there"
java,3ds445,dddent,3,Sat Jul 18 22:43:49 2015 UTC,I am very new to Java so most of this is over my head but one thing I wish was easier on Java was making a small stub exe that does things like you get with .NET where if the runtime isn't installed it gives you an informative message and directs you to the download and if the runtime is installed it just hands over to the JRE.   I assume this kind of thing exists but I have never seen it working in the main 3 IDEs. Am I missing something?
java,3ds445,kozukumi,5,Sun Jul 19 17:25:10 2015 UTC,"See javapackager. I haven't used the command line tool directly, only via sbt-native-packager, but it does exactly what you describe.  javapackager(relatively new to java 8) is the correct way to create java executables for distribution. The contents of this article are old and should be ignored."
java,3ds445,Milyardo,2,Sun Jul 19 20:07:51 2015 UTC,"I am the author of that article, if you have any comments/questions/suggestions, please post here."
java,3ds445,dleskov,1 point,Mon Jul 20 08:25:44 2015 UTC,"Another alternative is to create a batch/shell script, which opens the desired jar file. You can then place your own icon/image over the designated batch file."
java,3ds445,RosscoGiordano,1 point,Sun Jul 19 18:10:35 2015 UTC,I found that article a very useful read. Thanks!
java,3ds445,msharp_oh,1 point,Sun Jul 19 13:47:24 2015 UTC,"it's a very old article, and FYI excelsior JET running a charity, where you can donate and get standard license of their AOT compiler for as low as $10 per platform."
java,3ds445,wikes82,2,Sun Jul 19 15:32:50 2015 UTC,"Yeah, it is pretty old, but I try to keep it up to date, purging dead links and adding new tools once every few months."
java,3dr9g9,leventov,5,Sat Jul 18 18:13:11 2015 UTC,"The google code repository (yes, I know it's closing) says of xxHash:   xxHash is an extremely fast non-cryptographic Hash algorithm, working at speeds close to RAM limits   Can someone ELI5 why it's considered ""non-cryptographic""?"
java,3dr9g9,Orac007,10,Sun Jul 19 01:11:17 2015 UTC,"https://en.wikipedia.org/wiki/Cryptographic_hash_function states that one of the required properties of cryptographic hash functions - impossibility to find a byte sequence s for the given hash value h, so that f(s) = h.  xxHash, same as Murmur, City and other functions, use only reversable operations, so finding the 8-byte sequence, hashed to the specific value, is as easy as applying the reverse ops to this hash value"
java,3dr9g9,Twirrim,3,Sun Jul 19 01:43:59 2015 UTC,So it's purpose would be for stuff like in memory hashtables?
java,3dr9g9,xris-l,4,Sun Jul 19 04:27:25 2015 UTC,"And probably bloom filters.   Also, at this speed, the functions wouldn't be very useful for password hashing, as you want very slow hashing functions for that."
java,3dr9g9,leftofzen,-13,Sun Jul 19 05:24:39 2015 UTC,"Well...no, the speed of a has function has nothing to do with it's use as a password hasher. You'd just use a fast (crypto) hash function and add a sleep(x) or similar."
java,3dr9g9,klotz,18,Sun Jul 19 07:58:00 2015 UTC,"No, an intrinsically slow function makes it harder to compute hashes in a dictionary attack.  Just putting in a sleep function doesn't do that because you can just compile your own own version that does the exact same thing, only without the sleep."
java,3dr9g9,leftofzen,8,Sun Jul 19 08:09:23 2015 UTC,"That's a fair point, thanks."
java,3dr9g9,kitatwbobcat,2,Sun Jul 19 08:40:01 2015 UTC,"Well, any hash function applications listed here: https://en.wikipedia.org/wiki/Hash_function#Uses, except cryptographic hash function applications.  In addition, I would mention:   other probabilistic algorithms/data structures, in addition to Bloom Filter: HyperLogLog, Quotient Filter, MinHash Sharding/partitioning keys in distributed systems"
java,3dm1dt,javosize,2,Fri Jul 17 10:45:32 2015 UTC,http://java-0day.com/
java,3dk0au,voileipa,14,Thu Jul 16 22:01:05 2015 UTC,"I'm disappointed that the project contains legitimate unit tests. Eat your own dog food, JUnitQuest!  (plus i'm curious to see the kinds of tests it generates)"
java,3dk0au,Poobslag,6,Fri Jul 17 00:13:03 2015 UTC,"Sounds like people are aiming to 'tick the unit-test box' rather than actually ""test""..."
java,3dk0au,SlobberGoat,3,Fri Jul 17 05:45:52 2015 UTC,"I worked somewhere where this was the policy, must have 80% coverage. That was it, no real thought to it."
java,3dk0au,NimChimspky,2,Fri Jul 17 10:45:49 2015 UTC,"Where I am currently someone has written a hack which will automagically test getters/setters on pojos, and their null constructors should they exist, in order to game the test coverage score.."
java,3dk0au,fact_hunt,4,Fri Jul 17 08:24:11 2015 UTC,"This is ace, it essentially automates what i did as a junior dev, write tests that do nothing!"
java,3dk0au,Thrand-,2,Fri Jul 17 08:55:46 2015 UTC,"Interesting. I had played with KLEE once and this brought back good memories. So I spent about an hour in playing with this.  However, this tool doesn't seem to be trying to improve coverage. I don't know if it is because it is still not fully developed, but I created a simple parser and the tool failed to generate tests with good coverage.  Example input:  public boolean parse(final String str) {     return parseBrackets(str); }  private boolean parseBrackets(String str) {     if (str.length() > 2) {         return str.charAt(0) == '(' && str.charAt(str.length() - 1) == ')';     } else {         return false;     } }   Generated test:  @Test  public void parseTest0() throws Exception {         Class var4 = Byte.TYPE;     int var5 = 1;byte[] var3 = (byte[]) java.lang.reflect.Array.newInstance(var4, var5);     int var6 = 0;     int var7 = 0;     java.lang.String var2 = new java.lang.String(var3, var6, var7);          test.Parser var8 = new test.Parser();     var8.parse(var2); }   It seems to be just invoking methods with matching parameter types and not trying to create parameters that exercise all branches of the code.  (cross-posted comment)."
java,3dk0au,hrjet,2,Fri Jul 17 05:24:09 2015 UTC,"I think you've missed the point, its an ironic utility, making the point that just getting test coverage up is not useful - even tho it is the policy at many companies."
java,3dk0au,NimChimspky,1 point,Fri Jul 17 10:47:16 2015 UTC,"Yeah, I was intentionally trying to mis-use it to do something useful :)  Readme mentions concolic testing which is why I got interested in mis-using it. Anyway, a good outcome was that I found this while researching."
java,3dk0au,hrjet,2,Fri Jul 17 12:35:37 2015 UTC,I think automated unit test are generally overrated.  They take a lot of resources to create and maintain without providing that much value.  It's basically testing for the scenarios I know about.  That is not the kind of error I usually make.  I am much more likely to misunderstand a requirement or miss a scenario.  They do have some value if you have a lot of resources but I find system testing through the GUI to be much more effective for time spent.  I will go hide in my bunker now to dodge the incoming down votes.
java,3dk0au,avoidhugeships,2,Fri Jul 17 21:27:52 2015 UTC,I could not agree more! Honestly a good code review standard is as effective as wasting a ton of time writing unit tests.  Integration tests are where the real benefits are.
java,3dmh3e,eugenparaschiv,3,Fri Jul 17 13:47:14 2015 UTC,"Please, stop spamming your weekly reviews here. The karma they receive should already be an indication that they are not well liked and according to the reddit rules about spamming posts that historically get downvoted (as your weekly reviews are) are considered spam.  Also, as a mod I have to tell you that each and every of your ""weekly reviews"" gets reported by some reddit users as spam."
java,3dirch,nixfkt,-1,Thu Jul 16 16:33:20 2015 UTC,"So....   We are not sure it works but due to the glacial pace of language development, we think it will be ready in time.   Gotcha."
java,3dirch,redldr1,13,Thu Jul 16 20:46:02 2015 UTC,"It absolutely works.   I've got it running on a couple hundred different apps with heap sizes ranging from less than a gig up to 96GB and it works like a champ.   The people who use the default garbage collector are the people who don't tune a garbage collector, and G1 is by far the best behaving without any additional tuning.   There's a very very very small niche where cms might be better, for some batch applications the parallel collector might be better, but for most other things G1 is the best thing you can use."
java,3dirch,ryebrye,1 point,Fri Jul 17 00:51:10 2015 UTC,Where is cms better? From my reading about g1 it sounds like it is superior to cms in every way. The places where g1 stumbles it sounds like you should use the parallel collectors.
java,3dirch,cogman10,3,Fri Jul 17 01:42:13 2015 UTC,"If you can spend forever tuning it, cms can have similar pause times to G1 with less CPU usage."
java,3dirch,ryebrye,3,Fri Jul 17 02:43:55 2015 UTC,"What about the fragmentation problem? While g1 spends more time in minor gcs doesn't it tends to spend less time doing major gcs? Primarily because it does old gen collection during minor gcs and compaction.  Cms, on the other hand only does compaction during major gcs which tends to force major gcs more frequently. Right?"
java,3dhf9d,eugenparaschiv,44,Thu Jul 16 08:15:47 2015 UTC,"I can see the ""what"" from the way you have named your method  I can see the ""how"" by looking at your implementation.  I cannot see ""why"" you throw an exception in the value of the second parameter is -2, unless you tell me!"
java,3dhf9d,lju1977,12,Thu Jul 16 10:14:19 2015 UTC,"That is inherently bad design, never use magic numbers."
java,3dhf9d,monadicgames,13,Thu Jul 16 11:56:27 2015 UTC,"I think he meant when you pass the constant, VALUE_NEGATIVE_TWO  No but seriously, the exception should tell you why it was thrown, via the stack trace and message."
java,3dhf9d,HaMMeReD,3,Thu Jul 16 16:43:13 2015 UTC,"Yeah, but wouldn't you call the constant FILE_NOT_FOUND. but even that would be still bad design. Best would be creating a specific exception for each possible error. Bulky, lots of code but at least it's specific and easy to track and maintainable without handling constants."
java,3dhf9d,monadicgames,1 point,Thu Jul 16 16:45:35 2015 UTC,So instead of benefiting from the abstraction someone created I have to (a) hope that the tests demonstrate every possible scenario which can leave to an exception in an understandable fashion or (b) provoke every possible exception?
java,3dhf9d,nicolaiparlog,3,Thu Jul 16 21:00:15 2015 UTC,"That is inherently bad design, never use magic numbers    Of course you would use a const, but the unaswered question remains"
java,3dhf9d,lju1977,1 point,Thu Jul 16 12:10:38 2015 UTC,Amateur coder here. Could you elaborate on the magic numbers thing? Do you mean to say just arbitrary numbers?
java,3dhf9d,theBCexperience,1 point,Sun Jul 19 18:27:41 2015 UTC,"It's pretty straight forward, whenever you write a number inside your code it's a magic number, let's assume you have a program that displays blog entries per page and this routine displays the entries based on the page number:  int startIndex = pageNumber*20; for (int i = startIndex; i < startIndex+20; i++) {     displayEntry(i); }   This code basically displays 20 entries per page, now what happens when you want to change to 10 entries? you will have to find all occurrences of that 20 and replace it. In this case it's easy, but this can get messy very fast. a more reliable version would be:  int entriesPerPage = 20; int startIndex = pageNumber*entriesPerPage; for (int i = startIndex; i < startIndex+entriesPerPage i++) {     displayEntry(i); }   or just a CONST, whatever floats your boat, but everything is better than magic numbers.  you can keep all bugs and logical errors in the code above ;p"
java,3dhf9d,monadicgames,1 point,Sun Jul 19 19:23:53 2015 UTC,"I understand why the latter is a better way of doing it, but I feel like I'm missing something because idk what's so magic about the one above."
java,3dhf9d,theBCexperience,1 point,Sun Jul 19 20:31:25 2015 UTC,"It's an expression. Magic is stuff you can't explain, a random value somewhere within the code isn't necessarily explainable at first thus magic."
java,3dhf9d,monadicgames,0,Sun Jul 19 20:36:48 2015 UTC,It wouldn't be magic with a comment.
java,3dhf9d,pricks,3,Thu Jul 16 23:35:51 2015 UTC,"Umm then how about you just use a variable and String? No need for a damn comment. The string could be more generic and the variable name more specific, whatever floats your boat. The variable might be overkill but a comment defiantly is.   Exception errorWithNetwork = new ExceptionType(""This is an explanation of the network error""); throw errorWithNetwork;"
java,3dhf9d,n0mel7,5,Thu Jul 16 11:19:45 2015 UTC,"I cannot see ""why"" you throw an exception in the value of the second parameter is -2, unless you tell me!   Usually this hints of the bad design regarding this second parameter and its magic value. Probably the author of code was lazy to use a couple of boolean flags instead of single integer variable or something like this.  So if you feel your code needs to be explained - it is time to stop and think thoroughly, if there are some flaws in the code design."
java,3dhf9d,RodionGork,3,Thu Jul 16 10:21:43 2015 UTC,"Usually this hints of the bad design regarding this second parameter and its magic value   or, the integration/hardware/rpc/customer data/etc has a bug in it and we have to deal with it in our calling code... we'll never know, because there isn't a comment :)"
java,3dhf9d,lju1977,2,Thu Jul 16 12:19:26 2015 UTC,"I agree, I surely did not mean such cases... Though probably in such cases it is better to have thorough documentation of their crappy API rather than vague comments in the code :D"
java,3dhf9d,RodionGork,2,Thu Jul 16 12:25:57 2015 UTC,That's a perfect thing for javadoc comments.  Documenting the API is a good thing to do with the exception of trivial methods like straightforward getters and setters.
java,3dhf9d,tau-lepton,9,Thu Jul 16 14:22:55 2015 UTC,"If you write behavior driven tests, you can perfectly explain why you're throwing that exception.  I'm not saying comments are bad, but I do not agree with the author, telling us that it's trolling if you tell him to read the tests, reading tests are a necessity if you're developing."
java,3dhf9d,g00glen00b,14,Thu Jul 16 10:41:33 2015 UTC,"Reading tests is a necessity, I agree.  But which tests? The ones directly covering the lines I want to change? All tests for the class I want to change? All tests for all classes which interact with the one I want to change? All tests for all classes I come along while I try to understand the subsystem I am working on?  As I read way more code than I will eventually change, I would have to read massive amounts of tests to understand a subsystem. I prefer to get a high level explanation from the comments (i.e. the Javadoc class/interface comments) and only read the tests which are immediately relevant for what I am working on."
java,3dhf9d,nicolaiparlog,4,Thu Jul 16 10:50:26 2015 UTC,"If you don't know why something is there, changing it and then seeing which tests fail should enlighten you, assuming it was test-driven."
java,3dhf9d,benjiman,2,Thu Jul 16 18:08:38 2015 UTC,A lot of what I work with involves working around vendors breaking spec in data we get from upstream.   Sometimes the why exists outside your codebase and I can't tell you how many hours of my life have been wasted because my predecessors would comment the how but not the why.
java,3dhf9d,commandar,4,Thu Jul 16 18:40:03 2015 UTC,"An Anticorruption Layer is often a good way to document the problems with third party data in code, and avoid them polluting your actual important domain model at the same time."
java,3dhf9d,benjiman,1 point,Thu Jul 16 20:34:48 2015 UTC,Oh that I only have one up vote.  It is a beautiful pattern when dealing with ugly data.
java,3dhf9d,tau-lepton,1 point,Thu Jul 16 22:16:03 2015 UTC,"Absolutely an option. The why still needs to be documented somewhere though.   Basically what I'm saying is that it's easy for me to tell what you're changing and how, but unless I know the reason behind why it's being done, it's a giant nightmare for me to maintain it. Abstracting out the handling of bad data doesn't solve that specific problem if the abstraction isn't documented."
java,3dhf9d,commandar,-2,Fri Jul 17 18:26:14 2015 UTC,"It depends on what you're going to change, but you will probably have to read quite some tests yes. However, I think that unit tests can often better explain what a specific piece of code does than any documentation.  Like I said, I'm not against comments, but only to give a high level explanation where a high level explanation is necessary (for example to document your API's, documenting simple CRUD operations or accessors/mutators does not make sense to me).   However, if you're going to change some code, is a high level explanation enough? I don't think so, you will probably end up reading the tests anyway (at least I do). I just don't think that a comment can cover all details, while unit tests should cover everything (or at least the amount of code that is covered)."
java,3dhf9d,g00glen00b,1 point,Thu Jul 16 11:55:54 2015 UTC,I love
java,3dhf9d,PDFormat_SFW,1 point,Fri Jul 17 01:33:53 2015 UTC,"I cannot see ""why"" you throw an exception in the value of the second parameter is -2, unless you tell me!   Yeah, that info should be in the exception message, not buried somewhere in a quick-to-go-out-of-date comment in the code."
java,3dhf9d,RedPill115,53,Fri Jul 17 19:13:40 2015 UTC,For some reason many of the people who care so much about commenting the code do not care that much about updating comments when the code changes.
java,3dhf9d,RodionGork,5,Thu Jul 16 10:19:12 2015 UTC,"True. But to be fair, people who expressively dismiss comments probably care even less. In general it is hard to maintain comments if the team disagrees on their importance and use."
java,3dhf9d,nicolaiparlog,5,Thu Jul 16 10:52:38 2015 UTC,"if the team disagrees on their importance and use   Very true. However even if the team agrees on their important that is not enough. You know that terrible feeling when you look at the some other's comment and could not understand what it is about - and could not find right now whom to ask about it. And well - should you insert TODO for this comment or even create an issue in bug-tracker? or leave as is, or remove altogether?  Though of course the same applies to poor code :)"
java,3dhf9d,RodionGork,2,Thu Jul 16 11:06:23 2015 UTC,"For that reason, comments can't be trusted."
java,3dhf9d,rfinger1337,5,Thu Jul 16 16:50:02 2015 UTC,"Comments should be code reviewed. It's precisely the same principle as having a function named 'addOne' that gets changed over time to do subtraction. If you're lazy and unprofessional, you end up with something misleading."
java,3dhf9d,Cifize,0,Thu Jul 16 21:54:11 2015 UTC,Not it!
java,3dhf9d,sudonathan,4,Thu Jul 16 17:57:18 2015 UTC,"I will take code where the developers just don't use variables all named ""ufw"", ""q"", ""q1"", ""ql"", ""qi"", etc vs. over even full Javadoc (at the expense of other factors), any day.  The point of documentation is to communicate the intent of the author. IMHO, code can be ""self-documenting"" if you pay enough attention to splitting up the functionality into human-parseable segments and realizing that using ""n"" instead of ""customerIndex"" makes no fucking difference in the eyes of the runtime, but every difference in the world to the poor bastard who has to maintain your gibberish in the future. Especially if its future-you (fuck that guy)."
java,3dhf9d,Various_Pickles,1 point,Fri Jul 17 00:53:27 2015 UTC,"I will take code where the developers just don't use variables all named ""ufw"", ""q"", ""q1"", ""ql"", ""qi"", etc vs. over even full Javadoc (at the expense of other factors), any day.   I would pick the same but this is a false dichotomy. Why can't we do our best to write clean code and then add comments where necessary? I mean, at least a couple of lines of API-doc which explain the central abstraction of the class can't be too hard, can it?"
java,3dhf9d,nicolaiparlog,10,Sat Jul 18 18:32:57 2015 UTC,"When commenting your code, make sure to change the code a few weeks later but leave the comment unchanged.  People following you will love you:  # Expire things that are two weeks old twoweeks=$(date -d '13 weeks ago')"
java,3dhf9d,inushi,3,Thu Jul 16 11:37:38 2015 UTC,"more importantly, the almost reasonable variable of twoweeks didn't get refactored.   The comment should be deleted and the variable updated to reflect the new reality.    (Oh, and I recognize the sarcasm and enjoyed it as it was intended) - edit"
java,3dhf9d,rfinger1337,4,Thu Jul 16 17:30:47 2015 UTC,"The danger with code comments is they can be wrong.  So while it's nice to suggest one comment the code, it's important to realize that every comment adds another line that requires maintenance.  So the goal should be to remove useless cruft.  This doesn't mean comments are useless.  Doc style comments in front of every method are well accepted, even when people talk about not commenting.  Usually what's in contention is inline comments.  Personally, I find the most reasonable thing to do is limit comments to explaining why.  What is defined by the code, but why is usually the intent.  More importantly, this is a signal to me that most likely the block of code belongs in a well defined method at the very least.  The comment can be carried over there as a docblock, which has the benefit of being a bit more formal.  For some reason, I find people are better at keeping docblocks correct (though this is purely anecdotal).  In the end though, if the code is complicated enough, I find inline comments rarely useful.  The reason is that if someone had a hard time writing easy-to-understand code, their comments will be equally difficult to understand.  Couple that with the fact that comments can be wrong, I literally cannot rely on them, which means they generally just get in the way.  So yeah, comment your code, but like all good things, keep it to a minimum.  Stick to why, and consider refactoring out the piece needing comments to something that make sense.  Usually comments are a good sign that you should extract something out.  tl;dr: Skipping my comment to read the tl;dr is basically admitting that you don't find comments important. =)"
java,3dhf9d,jasonlotito,6,Thu Jul 16 21:40:10 2015 UTC,"I used to work with a really great programmer 15 years ago, but he never commented anything. So I used to tease him about that. He was a very quiet and humble guy, and never said anything in response. Then, one day, he out of the blue explained that his problem was that he'd work with a part of the code for say, two weeks. At the end he'd feel that he understood that part and was tempted to write a comment explaining it. But what if he were wrong? Then he'd just be misleading people, including his future self. (As experienced developers know, wrong comments are really toxic.) So in the end he never wrote any comments.  I was impressed with his humility and always felt it was part of why he was so good. I never teased him again after that. His was a special case, though. In general I agree with the author. At least have a comment explaining what each class is for. Don't force me to reverse engineer it out of the code."
java,3dhf9d,larsga,1 point,Thu Jul 16 20:00:38 2015 UTC,But how would he be wrong about his own code? He presumably knows what it does.
java,3dhf9d,argv_minus_one,3,Thu Jul 16 23:49:04 2015 UTC,"It was a big code base and very complex, so, no, there was always the possibility that he was not 100% sure what it did. Plus, there was the humility. I think part of what made him so good was always being alert to the possibility that he was wrong."
java,3dhf9d,larsga,3,Fri Jul 17 06:21:58 2015 UTC,"We all know comments tend to get out of sync with the code. We also know that expressive code can be as descriptive as comments. Tests describe how the code should be used. I still occasionally use comments, but it isn't like the old days where half the code file was comments."
java,3dhf9d,freebit,1 point,Fri Jul 17 16:24:48 2015 UTC,"We all know comments tend to get out of sync with the code.   This is no law of nature, quite the contrary, it is a consequence of negligence. I am convinced that intelligently placed and formulated comments, an agreed-upon documentation-schema, pair programming and code reviews can eliminate this problem.   We also know that expressive code can be as descriptive as comments.   My argument in the post is that this is an illusion. I listed a number of things that code is inherently unsuited to express. And I hinted at the fact that some things just take to long if they are only documented in code. Both is ok and no argument against clean code. Just pick the right tool for the job.  PS: Note that I include API-docs in comments, i.e. for me ""no comments"" also means ""no API-docs""."
java,3dhf9d,nicolaiparlog,2,Sat Jul 18 18:29:36 2015 UTC,I don't think anyone's arguing against API docs here.
java,3dhf9d,ladna,1 point,Sun Jul 19 03:15:28 2015 UTC,According to different sources API docs (like Javadoc) are just a special kind of comment. That was also my understanding.  So I ranted against not having any non-instructions in a code base because that is what I am currently facing.
java,3dhf9d,nicolaiparlog,2,Sun Jul 19 07:57:16 2015 UTC,"Oh now I am reading your ""Note from the future"" at the top of the post.  Yeah I think most devs don't conflate API docs with comments, so it's likely that's the main miscommunication here.  In fairness (like you point out), a lot of documentation tools (javadoc, doxygen) use special, language-specific comment block formats for API documentation, so maybe it's easy to conflate the two.  But those tools work that way because that workflow actually is convenient, compared with combing through the source code to find a big comment block explaining the architecture in a now-unrelated source file.  Agree: no API docs would irritate me.  Disagree: comments are the norm.  I think comments should only exist if something insane is happening, like you over-allocate an array to emulate an overflow access in a previous version of a game or something."
java,3dhf9d,ladna,13,Sun Jul 19 16:58:43 2015 UTC,"No, your code is not clean, it is not self-documenting, it is not well-written, it is not some pristine beautiful thing.  Everybody complains about foreign code when it doesn't have comments. Realize that your code is the foreign code for everybody but you, and put 2 and 2 together.  I write what I think is beautiful, self-documenting, well-written, pristine code. I still write comments. One of the things most people don't seem to realize, is that programmers are not all of the same talent, and your assumptions and designs might not be something the next person is experienced with. Stop making excuses. The real reason you don't write them is because it's hard to do them right.  If you're a developer who writes code without comments, you're considered a bad developer by everybody who has to deal with your code. And if you think their opinion doesn't matter even though they have to work with it, well, that also makes you a bad developer."
java,3dhf9d,GMNightmare,2,Thu Jul 16 16:11:10 2015 UTC,"I pretty much consider all code bad that is more than an hour old, including my own. To be safe."
java,3dhf9d,skel625,2,Fri Jul 17 01:32:57 2015 UTC,"My favorite part of your comment is this: ""One of the things most people don't seem to realize, is that programmers are not all of the same talent, and your assumptions and designs might not be something the next person is experienced with"".  Totally agree - junior engineers complain that not everyone is as smart as them, while good senior engineers grow up and work with the people around them."
java,3dhf9d,brick_wall_mirror,2,Fri Jul 17 02:49:12 2015 UTC,"can you give me an example of a comment that adds value to a class that is is beautiful, self-documenting, well-written, pristine code?"
java,3dhf9d,rfinger1337,5,Thu Jul 16 16:51:57 2015 UTC,"I don't know, I've found my comments to be very useful even to myself just a few months down the line... stuff like:  // DON'T TOUCH THIS I don't know why it works but it does"
java,3dhf9d,RobCubed,6,Thu Jul 16 16:57:28 2015 UTC,http://www.urbandictionary.com/define.php?term=here+be+dragons
java,3dhf9d,rfinger1337,5,Thu Jul 16 17:09:50 2015 UTC,"You mean, do I have a generic, isolated, simple example of nonreal world code, were even you would admit a comment is required?  But hey, sure, I'm up to the task. Since we're talking about foreign code that you may/may not be super competent in the methodology about, let's try C#. Something not Java, but fairly similar. So, here it is:  public sealed class UnmanagedHolder : IDisposable {     private readonly UnmanagedResource resource;     public UnmanagedHolder(string resourceId)     {         if(resourceId == null) throw new ArgumentNullException(""resourceId"");         resource = new UnamangedResource(resourceId);     }     ~UnmanagedHolder() { Dispose(); }     public void Dispose()      {          if(resource != null) resource.CleanUp();     } }   For a little info, ""resource"" here is immutable and cannot be changed, and must be declared in the constructor. What is the format of the ""resourceId"", what does it actually refer to? Want something more advanced? Quick, why am I checking for null in the Dispose method, is that a mistake? Can you remove it safely?  With real world code, almost everything can have additional value with comments. Because like everybody tells you, for good reason, the why is not readable from the code."
java,3dhf9d,GMNightmare,1 point,Thu Jul 16 17:38:45 2015 UTC,"What is the format of the ""resourceId"", what does it actually refer to?   A non-null resource identifier of type string... There are no other format restrictions.   Quick, why am I checking for null in the Dispose method, is that a mistake? Can you remove it safely?   I can't imagine any comment that would document the fact that the null check is a mistake... I mean even if the comment straight up said ""skipping null check, resource is never null"" and I saw the null check in code, I would still not feel it could be removed safely. If anything, I'd be even more confused."
java,3dhf9d,dablya,1 point,Fri Jul 17 19:12:55 2015 UTC,"There are no other format restrictions   That you can see in the current code at this level. Amazingly, can't always get those things from looking at the code as is, now can you? Calling code has requirements, too.   I can't imagine any comment that would document the fact that the null check is a mistake...   Is not. As in, a reason that the null check would be required is what is missing. The assumption here is that resource is never null, because it's immutable and must be set in the constructor. But there is a null check there, why?  ... did you bother to read any of the rest of this thread?"
java,3dhf9d,GMNightmare,1 point,Fri Jul 17 21:01:01 2015 UTC,"Amazingly, can't always get those things from looking at the code as is, now can you?   You're missing my point... This code has no restrictions on what the resource id can be. Adding a comment won't change that fact. Writing code that restricts it will.   The assumption here is that resource is never null, because it's immutable and must be set in the constructor.   No... The assumption here is a null check is needed because there is a null check in the code."
java,3dhf9d,dablya,1 point,Fri Jul 17 21:25:18 2015 UTC,"No, you're missing my point. Just because the code restrictions on resourceId aren't on the given piece of code you're looking at, doesn't mean such restrictions aren't on it.  As in, if I was calling an external resource, which I'm passing that string to, that has those restrictions. You can't look at the code, it's external and not available to you. That doesn't mean those restrictions aren't there.  Since you don't have access to the code, and we're under the assumption no comments at all because readable code, guess what? You have NO way to know that restriction exists. Even though, it can.  Writing additional code that restricts it at this level as well is just bad. That's bad design, repeating checks on every layer that the string visits, but I don't think you'd ever do it in the first place. You're just being argumentative for argument sake.   No... The assumption here is a null check is needed because there is a null check in the code.   You made a second assumption, not invalidating the first one. Programmers make mistakes, you assuming code is correct is already a bad assumption especially when you have people having to maintain your code. Looks like you want to avoid the issue altogether.  Quite frankly, that kind of attitude doesn't make a good programmer. Why code exists is just important as it existing in the first place, and since people have to maintain and fix your code down the line (even if it's correct now, doesn't mean when assumptions change that it's still correct) you pretending it must exist is not an argument."
java,3dhf9d,GMNightmare,1 point,Fri Jul 17 21:31:31 2015 UTC,"No, you're missing my point. Just because the code restrictions on resourceId aren't on the given piece of code you're looking at, doesn't mean such restrictions aren't on it.  As in, if I was calling an external resource, which I'm passing that string to, that has those restrictions. You can't look at the code, it's external and not available to you. That doesn't mean those restrictions aren't there.   You're no longer describing comments... You're describing documentation. Specifically you're suggesting that there is a need to document external APIs in client code comments.   If the value of resource id is more restricted than string, it should be it's own type, where the restriction can be coded and read from code.   You made a second assumption, not invalidating the first one. Programmers make mistakes, you assuming code is correct is already a bad assumption especially when you have people having to maintain your code.   And you're assuming if there was a comment it would be correct and that it would be in synch with the code..."
java,3dhf9d,dablya,1 point,Fri Jul 17 21:53:50 2015 UTC,"You're describing documentation   I hate to apparently bring you this news, but comments are documentation. In C# your autogenerated docs are created by documentation comments. It's similar to how javadocs work.   If the value of a resource id is more restricted than string, it should be it's own type   That's complete and utter nonsense that is not adhered to by anybody anywhere. The type would look like what exactly? Nothing would be more readable by making it a type, either. Exactly how would it? Also, check with me how many cmd line programs require or use types for arguments like that. Absolute nonsense.   And you're assuming if there was a comment it would be correct and that it would be in synch with the code...    I'm not assuming shit on this. Yeah, since we're talking about my code, and I know exactly what the issue is, it is correct and is in sync with the code. But since the comment says why, and not what, you can easily verify it yourself. Not that you want to deal with it, of course, which is why you're avoiding the issue outright."
java,3dhf9d,GMNightmare,1 point,Fri Jul 17 22:37:56 2015 UTC,"Javadoc documents the api. It does not document the source code (yes, api is defined in source, but I hope you see the distinction). It serves a different purpose. You shouldn't assume people that will be reading your javadoc will be reading the source code.   That's complete and utter nonsense that is not adhered to by anybody anywhere. The type would look like what exactly?   It would model the id and enforce the restriction. Inspecting the code that enforces the restrictions should be enough to know what the format of the id is.   Also, check with me how many cmd line programs require or use types for arguments like that.   What does that have to do with anything we're talking about? Do you base your code on cmd line programs?   Not that you want to deal with it, of course, which is why you're avoiding the issue outright.   Deal with what exactly?   Quick, why am I checking for null in the Dispose method, is that a mistake? Can you remove it safely?   Without any C# experience, I'm assuming there is some condition under which it could be null, I don't think it's a mistake, and I wouldn't feel it was safe to remove it.  Having read through the other posts, I'd suggest refactoring the null check into a method ""boolean initialized()"". This is the general idea behind self-documenting code.  I'm not saying you should never comment your code, I'm saying this is a bad example of code that should be documented."
java,3dhf9d,dablya,-1,Sat Jul 18 01:32:57 2015 UTC,"Ok, so where would you put the comment? What would the comment tell you?    Would it explain what the generic variable name resource refers to?  If so, can't the variable be refactored to include the same information?  What would you have to explain about if(resource != null) resource.CleanUp();  ?  What would the comment say here that I can't infer from the context?  //this isn't a mistake, don't remove it? /s"
java,3dhf9d,rfinger1337,5,Thu Jul 16 17:54:40 2015 UTC,"If so, can't the variable be refactored to include the same information?   You think, that the formatting of a string should be included in the name of the string? ""resourceIdAsGuidWithoutHyphensOrNameWithUnderscoresInsteadSpaces"".  Oh BOY! That's readable code! So much more readable than making a comment that will show up on your generated docs and actually be legible.   What would the comment say here that I can't infer from the context?   Don't bullshit me, answer the question: Why is it needed? Or is it even? Infer it, as you think you can."
java,3dhf9d,GMNightmare,0,Thu Jul 16 17:58:04 2015 UTC,you haven't added the comments.  let's see them and compare the classes with and without.
java,3dhf9d,rfinger1337,2,Thu Jul 16 18:25:43 2015 UTC,"I see this as admitting you failed, without actually saying it. As in, you could not infer why it was needed. Which is why I have to do it backwards, because if I just gave you the comment at first, why, you'd claim you really could just infer it.  So, for your information, why the null check is included, the comment that would appear above that line would be something like:  // Resource is null for finalizer if constructor throws an exception.  I made it easy for you, by the way. Don't say I didn't give you a chance, I actually put an exception throw clause in the constructor as a really big hint, when the exception might occur down the line.  And, of course, it's a simple small example that is surprisingly more complex than it appears. A real class would be even more complex, having a Dispose(bool) method that Dispose() and the finalizer calls, with a GC.SuppressFinalize(this) in the Dispose() method, and actual logic in the class doing things...  Did I also mention you can't test for it reliably? If you just say, ran a test throwing an exception in the constructor, nothing would happen in Visual Studio. You have to run it on a separate MSTest instance. And then, you won't get any details of the exception in relation to the calling code because it's on the finalizer thread. So where did the bug come from? Who knows. Why is it null? Good luck finding it out.  Even if, you could ""infer"" all of this, which you couldn't in a real world example of actual code, just think how easy it is to gain ALL this knowledge, with just a single, simple handy comment saying why it's there. And how much time you could waste otherwise."
java,3dhf9d,GMNightmare,2,Thu Jul 16 18:42:21 2015 UTC,"// Resource is null for finalizer if constructor throws an exception.  You could have made a unit test with  sut = new UnmanagedHolder(null) and cover that case. That unit test would act as an executable comment: not only would it document that behavior, like the comment, but it also would alert (with a failing test) the user if the behavior is inadvertently changed."
java,3dhf9d,jeenajeena,0,Fri Jul 17 03:40:00 2015 UTC,"You've mistaken the issue. The case to be covered is a NullReferenceException in the Dispose method when it is called by the finalizer.  Catching an exception from the constructor is not enough. It's the dispose exception that is not cover-able. Without the null clause in the dispose function (not the constructor), you'll get a NullReferenceException, but you won't be able to test it from Visual Studio. You'll have to run a separate test instance to be able to hit the case, which means you can't make a test for it as you can't guarantee the environment will throw anything and it happens whenever the finalizer thread wants it to anyways (which is likely not within the test method).  In other words, you can't test this case. So you can't resort to any tests acting as documentation argument."
java,3dhf9d,GMNightmare,2,Fri Jul 17 06:43:47 2015 UTC,"I don't agree. We are not able to test that behaviour because the code is not really well designed. We could improve its design. For example, introducing Dependency Injection.  We could refactor that code injecting the resource into the UnmanagedHolder's constructor rather than injecting the resourceid. Like this   public sealed class UnmanagedHolder : IDisposable {     private readonly IUnmanagedResource _resource;     public UnmanagedHolder(IUnmanagedResource resource)     {         _resource = resource;     }      ~UnmanagedHolder() { Dispose(); }      public void Dispose()     {         _resource.CleanUp();     } }  public class UnmanagedResource : IUnmanagedResource {     private readonly string _resourceId;      public UnmanagedResource(string resourceId)     {         if (resourceId == null) throw new ArgumentNullException(""resourceId"");         _resourceId = resourceId;     } }   This way, you can easily avoid the if statement.  My feeling is: if something is hard (or even impossibible) to test, it's a smell the design can be improved. A comment in this case would be a dirt trick, a workaround.  So, just writing the missing tests, one could eliminate the source of ambiguity and the need for comments. In our case, the tests could have been:      [Test]     public void ResourceIdIsMandatory()     {         try         {             new UnmanagedResource(null);             Assert.Fail();          }         catch (ArgumentNullException e)         {             Assert.Pass();         }        }      [Test]     public void ShouldCleanUpResourceAfterDisposal()     {         var resource = Substitute.For<IUnmanagedResource>();         var sut = new UnmanagedHolder(resource);         resource.DidNotReceive().CleanUp();          sut.Dispose();         resource.Received().CleanUp();     }  }   Please, find the complete code here https://gist.github.com/anonymous/b0b3793179df89ce293d"
java,3dhf9d,jeenajeena,-2,Fri Jul 17 13:29:59 2015 UTC,https://www.reddit.com/r/java/comments/3dhf9d/comment_your_fucking_code/ct6inuk  ^ (edit) Way way better.  So I'll just point there.
java,3dhf9d,rfinger1337,4,Thu Jul 16 19:36:43 2015 UTC,"Wtf is this? You've just proven how bad you are at creating readable code.  Why are you setting constructorException to null? What is that, an object even? You set it to var, I have no idea what class you intend it to be. Is it an exception class? How does it relate. It's obviously not the exception itself, or is it? The variable name doesn't reflect what it is. It doesn't even tell you that the finalizer still runs on an constructor exception, which is an important part!  This is complete garbage. All because you want to try and avoid a single comment. Why? Does it hurt your pride to admit comments have value? Incredible.  Do I need this for every null guard clause?  var inputIsNull = null; if(input == inputIsNull) throw new ArgumentNullException(""input"");  Completely vapid."
java,3dhf9d,GMNightmare,3,Thu Jul 16 19:44:48 2015 UTC,This thread made my day. Thanks GMNightmare for such a great example! (And the engaging presentation!)
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 20:30:36 2015 UTC,I like you.
java,3dhf9d,pricks,-2,Thu Jul 16 23:44:14 2015 UTC,"Ok, I think your kind of a dick so I'm not going to continue discussing this with you. I don't think you've made a compelling argument for that comment in particular."
java,3dhf9d,rfinger1337,2,Thu Jul 16 19:52:55 2015 UTC,"For starters, pretty much anytime I have to implement something in a weird or non-idiomatic way due to a bug or quirk I either can't fix or don't know the root cause of.  If possible, I usually include a reference or link to a bug/issue tracker for the problem."
java,3dhf9d,noratat,6,Fri Jul 17 07:12:35 2015 UTC,"But... my code is artisanal, handcrafted, made with love from SF!"
java,3dhf9d,lukaseder,5,Thu Jul 16 16:38:55 2015 UTC,"God I can't stress this enough. I'm maintaining a codebase right now where anyone who originally wrote the code base is long since gone. They left behind a mess of 700-line methods with virtually no comments (or making their comment a redundant repetition of the method: Oh your method ""sendMsg"" sends a message, does it? Gee thanks, WHERE DOES IT SEND A MESSAGE TO??)  and terrible variable names like ""LJR"" and ""mtg"" that tell me nothing about what's going on. It's a nightmare."
java,3dhf9d,sreya92,5,Thu Jul 16 16:24:28 2015 UTC,Of course the authors can not be expected to care about comments when they don't even care about code. Meaning: it is unlikely that dev's writing such code would write accurate and helpful comments.
java,3dhf9d,nicolaiparlog,4,Thu Jul 16 20:24:33 2015 UTC,"There is a lot of compile time protection against whether return values are null or parameters that can be null thanks to annotation libraries.  The name of the exception should be a good indicator as to when it may be thrown or at least why.  I think the jab at agile is a bit flippant... If my team were to deliver a library or something to be used by someone external to the team, public interfaces and entry points WILL be documented as they are least likely to change.  Core implementation details won't be documented, as although code ""ages"", comments come off worse from said aging. If an interface changes, I get compile errors, if comments no longer reflect reality, I get nothing.  Even worse, the author seems to think that any written comments are going to always be correct at the time of writing. I can't count the amount of times I've been burnt by incorrect comments.   I'd much rather have no clear perception than an incorrect one.  Although I feel biased towards tests as documentation, I do know and understand it requires a very high level of skill to be able to write succinct tests, it's important to realise that tests often demonstrate the what, not the how. In fact tests that do demonstrate the how are going to be as tedious as documentation to keep up to date (although they'd be a better canary for knowing when documentation needs updating!)  I don't think the author would find anyone who doesn't like documentation, or anyone who doesn't aspire to write good documentation, but it is difficult to state whether the effort to write documentation is worth the benefit it may give the few (when it comes to documenting the insides of complex applications.)"
java,3dhf9d,ElFeesho,2,Thu Jul 16 16:28:12 2015 UTC,"Thanks for engaging. Even though I disagree with most points, I appreciate the open discussion.   There is a lot of compile time protection against whether return values are null or parameters that can be null thanks to annotation libraries.   This is true for Java and other mainstream, statically typed languages. There are many others out there. Btw, I only pick null because I hate it with a passion. Other guarantees are equally useful to know and hard to demonstrate with tests (albeit less common).   The name of the exception should be a good indicator as to when it may be thrown or at least why.   True for some, false for others. What about, e.g., IllegalArgumentException? Which of the arguments caused it? What are the conditions?   Even worse, the author seems to think that any written comments are going to always be correct at the time of writing.   No, no, I do not have any such illusions. ;) But I hope that if a team decides on a comment schema they like (strawman example ""describe the cause of any checked exceotion""), that there is a real chance that they get updated as code changes (pair programming and code reviews should increase that chance).   I can't count the amount of times I've been burnt by incorrect comments.   Same happens with names but admittedly less often.   I don't think the author would find anyone who doesn't like documentation, or anyone who doesn't aspire to write good documentation   Look no further."
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 20:46:59 2015 UTC,I wish I didn't look further...   Can you describe what your thought process is when documenting a project?  Is it a case of document all the things or do you have a few situations in which you will avoid commenting all together?  I do genuinely believe that a projects internals being documented can lead to more troubles than gains but I work in a team that exclusively pairs on implementing functionality. I can imagine I'd appreciate some breadcrumbs if that wasn't the case.  When I say document and documentation I am strictly referring to source code comments.
java,3dhf9d,ElFeesho,1 point,Thu Jul 16 22:01:34 2015 UTC,"See http://blog.codefx.org/techniques/documentation/comment-your-fucking-code/#comment-2140389388here for a little background how I got to this point.   Can you describe what your thought process is when documenting a project?  Is it a case of document all the things or do you have a few situations in which you will avoid commenting all together?   I am currently not too sure what exactly I want. The code base I work on is huge and partially old. There are things in there that worked well for years with unchanged requirements (hence nobody touched them). Requiring team members to remember what they did five years ago turned out to be a lossy way of storing their knowledge. I am mainly looking for a remedy against that. I am currently thinking about this more intensely (this discussion helps) and will distill my thoughts into my next post.  While I personally am leaning towards ""document all the things"" (more like ""document all non-private members with meaningful Javadoc"") I see that this is not the way to go. Two things I would really appreciate are:   a Javadoc on every class or interface that explains the central abstraction (often there is more to Customer than just ""it's a customer"") and how it interacts with others it depends on hints like ""I do this crazy thing because the stored procedure I am calling behaves differently in PostGIS version 1.3, 1.5 and 2.x"""
java,3dhf9d,nicolaiparlog,4,Fri Jul 17 07:32:19 2015 UTC,"When I don't comment my code, it's not because of high-and-mighty horse shit like “it's self-documenting”. It's because I have limited time, very limited energy (chronic fatigue is a massive bitch), and a job to do—a job whose requirements do not include comprehensive comments or API documentation. Also, I usually work alone (I'm the only coder in this company), so the only one that's likely to ever see those comments is me.  If my job was different—if I was writing code that other people would be using, and my boss approved of me taking the time to thoroughly document it—then sure, I'd thoroughly document it. I'd document it so well, you'd think I also wrote the excellent API documentation for Java itself! (Seriously, though, the documentation of java.lang and java.util is top-notch. Everyone should strive to write documentation like that.)  But that isn't my job."
java,3dhf9d,argv_minus_one,3,Thu Jul 16 23:47:22 2015 UTC,"Didn't take long for the ""comments are not necessary, beautiful nirvana code shall be enough"" to appear."
java,3dhf9d,camilos,1 point,Fri Jul 17 03:00:05 2015 UTC,"I think it's not a case of either using comments or writing beautiful code, but both. I just think that the discussion here is that some people tend to prioritize the one over the other.  I would probably give more priority to well written code + behavior explaining tests (BDD) than comments as well, but I do comment the methods on my service classes, but that's about it. Models/utilities/DTO's/controllers are usually self-explanatory since all our logic is retained within services. REST API's are documented as well, but we have technical documentation to do so (and contracts like WADL's).  I also think that having comments within methods, or code requiring a lot of extra explanation using comments is often an indicator that something is wrong within the code."
java,3dhf9d,g00glen00b,25,Fri Jul 17 06:12:20 2015 UTC,"No, please don't. Comments are noise. Well-written code should be readable as it stands. Javadoc your APIs, and stop there."
java,3dhf9d,codepoetics,55,Thu Jul 16 08:41:46 2015 UTC,"My rule is, let the code be the 'what' and the comments be the 'why'.  Yes code should be self documenting to a degree: a low level example being to split-out complex expressions into steps with clearly named values.  What you can't express in your source code is contextual information: how this code fits into the wider system.  This could be derived by reading it all, but a few natural language comments really do go a long way to lowering the 'barrier of entry'.  Being actively helpful with your comments is especially important when working in a team, if you expect your lovingly crafted, re-useable components to gain any traction among colleagues.  In this way, comments multiply your code's effectiveness.  Conversely, failing to comment re-useable components increases the chance of a colleague re-writing it's behaviour, weakening the cohesiveness of the project.  That said, one should strive to keep the code obvious enough not to require comments where possible. I don't comment obvious accessor methods.  Auto-generated and blatantly obvious comments like setName being 'sets the name' are indeed worse than no comments at all, and should be severely punished."
java,3dhf9d,Darkmoon_UK,15,Thu Jul 16 09:19:05 2015 UTC,"My rule is, let the code be the 'what' and the comments be the 'why'.   Exactly. Your code should be easy to follow, but it can't tell the user why you're doing a specific thing.  Take, for example, a file watch that checks if a certain configuration is modified, and reloads it if it is. You might have a line that checks if the reloaded configuration is the same as the existing configuration. The code makes sense, but surely the config won't be the same if the file is modified, so why check at all? It turns out, however, that some OS's will write the metadata and the content separately, hence triggering the watch twice for every modification. That deserves to go into a comment, as you can't expect future developers to know that (and you may forget yourself)."
java,3dhf9d,Vile2539,20,Thu Jul 16 11:15:37 2015 UTC,"My rule is, let the code be the 'what' and the comments be the 'why'.   This is the proper approach."
java,3dhf9d,desrtfx,-2,Thu Jul 16 11:02:02 2015 UTC,"My rule is, let the code be the 'what' and the comments be the 'why'.   Exactly.  I even try to put the bug report number over some of the stuff that is inserted later."
java,3dhf9d,RogueLeaderJ,6,Thu Jul 16 13:35:52 2015 UTC,Exactly. I even try to put the bug report number over some of the stuff that is inserted later.   Don't do this. It's horrific after a few years.
java,3dhf9d,philipwhiuk,0,Thu Jul 16 13:42:06 2015 UTC,"Eh, its not that bad.  I only do it when it's something of a hack so I know I will have to come back to it."
java,3dhf9d,RogueLeaderJ,4,Thu Jul 16 13:48:32 2015 UTC,"Put the bug report number in your revision control system commit comment instead of your source code.  You can find it a touch easier, it'll be timestamped, and it'll point you to all parts of the source code that are related to that commit."
java,3dhf9d,stillalone,-1,Thu Jul 16 15:45:22 2015 UTC,What happens when you move from Rally to Jira?
java,3dhf9d,tau-lepton,6,Thu Jul 16 15:53:35 2015 UTC,"Agree. Unless you have something really unusual or exceptional to add as a comment (to explain why a counter-intuitive solution works for example), comments distract from the reabability of code and are rarely maintained properly (thus lie eventually).  Key point about tests : they may document your code (if you are lucky), but they sure as hell do mean an engineer who doesn't understand your solution can more confidently refactor or rewrite it."
java,3dhf9d,van_gaals_left_ear,19,Thu Jul 16 11:57:12 2015 UTC,"I disagree. Even if your code is written well, sometimes you just have to do something strange. If it's not commented, someone is going to come along and change or remove something. Then everything goes down and you have to yell at people who will in turn yell at you for not commenting your code.  It's a good ideal for wanting code to be readable all the time, but it's just not realistic if you're working on a big application with a lot of different people."
java,3dhf9d,armornick,7,Thu Jul 16 08:57:58 2015 UTC,"In these cases, there ought to be a unit test covering the strange behaviour, which will break immediately and noisily if the behaviour is changed. The name of the test, and the code within the test method, ought to give a clear indication of what the exceptional case is, how it is arrived at, and what ought to happen in that case.  Then you yell at people for not running the unit tests before committing."
java,3dhf9d,codepoetics,-2,Thu Jul 16 10:52:38 2015 UTC,"If you have a great deal of untested code, you might use comments to indicate where the landmines are buried. But anyone writing new comments is writing new code that doesn't have tests. And the general tendency over time should be for tests to appear, and for comments to disappear. Ideally it should be a build metric: a graph with a line indicating a count of non-javadoc comments that tends monotonically towards 0. And if people commit code that makes the line move in the wrong direction, you gently take them aside and show them the error of their ways."
java,3dhf9d,codepoetics,6,Thu Jul 16 10:56:00 2015 UTC,"The fact that you've gotten so many up votes scares the fucking shit out of me...  ...and also, unfortunately, confirms what I know from my 25+ years of professional software development experience: most developers simply aren't very good."
java,3dhf9d,fzammetti,1 point,Thu Jul 16 21:21:45 2015 UTC,"I must have been unlucky then: none of the best developers I've known has littered their code with comments. Funnily enough, I've never had any trouble following their code. Comments are a crutch that over time becomes an impediment. They are no substitute for clarity of expression in the code itself.  There may be a generational issue here. I read Code Complete 15 years ago, back when I was first starting to get paid for writing code. It has a lot to say about good commenting style. But that advice comes out of the preceding decade of development experience - your first ten years on the job - when a lot of borderline-unintelligible C and Perl was being written as a matter of course, and comments were where people explained themselves. Not explaining yourself would have been terribly rude to your peers, not to mention (as the wisdom of the day had it) a liability when you yourself came to review the same code 6 months later.  The thing is, we have genuinely moved on since then. We refactor, we write tests, we don't try to cram everything into a blazingly brilliant one-liner, our VMs perform dataflow analysis on executing code and do all the gnarly optimisation tricks for us. And this is good, because it means we're free to care about what actually matters, rather than permanently distracted and befuddled and in need of an extra semantic layer to help us through. The presence of that extra semantic layer is now a smell. It means that someone is writing illegible code who no longer needs to."
java,3dhf9d,codepoetics,8,Fri Jul 17 07:01:15 2015 UTC,"Never had some weird really obscure corner case, that makes virtually no sense ... except in this one particular situation with a million dollar customer.    // don't change this, this is because mr Smith is a douche talk to someone in customer services cust id 198   There are loads of good uses of non javadoc comments.  The business context of code always help, to echo other replies, the why is important in comments.    Just saying all comments are noise, is itself just noise itself."
java,3dhf9d,NimChimspky,-3,Thu Jul 16 10:03:04 2015 UTC,if(customerID == 1938) {      handleCustomerID1938();  }   Zero comments. Self-documenting code that covers him.   And avoid stupid attacks on customers in code. It's always funny until your source code is leaked.
java,3dhf9d,philipwhiuk,5,Thu Jul 16 13:43:48 2015 UTC,"Er well yeah, but I think you are taking my comment rather too literally."
java,3dhf9d,NimChimspky,-4,Thu Jul 16 13:53:29 2015 UTC,Are you moaning I removed the need for a comment or that I made a point about language in code which has come to haunt companies before
java,3dhf9d,philipwhiuk,3,Thu Jul 16 13:55:12 2015 UTC,"I am not moaning about anything, I think you are taking the point of my comment too literally, and not using common sense."
java,3dhf9d,NimChimspky,1 point,Thu Jul 16 14:19:57 2015 UTC,Comment sense
java,3dhf9d,sudonathan,1 point,Thu Jul 16 18:01:28 2015 UTC,Coffee sense
java,3dhf9d,zfolwick,3,Thu Jul 16 20:15:56 2015 UTC,Exactly.  The number of times I've seen implementation comments remain accurate I can count on one hand.  The only possible exception is very clever code or bit manipulation code that may not be clear.
java,3dhf9d,tau-lepton,4,Thu Jul 16 14:19:05 2015 UTC,Read this and tell me you would prefer it without comments.
java,3dhf9d,nicolaiparlog,5,Thu Jul 16 08:59:31 2015 UTC,"If you have to write comments in your methods, you're usually doing something wrong. Any code quality analysis tool would probably complain about the complexity of that method."
java,3dhf9d,g00glen00b,2,Thu Jul 16 10:34:31 2015 UTC,I am curious to find out how you would simplify it.
java,3dhf9d,nicolaiparlog,8,Thu Jul 16 10:56:56 2015 UTC,"Encapsulating the conditionals into their own methods would make the code a lot clearer. :Clean Code Encapsulate Conditionals   That would include both the  parts within the if statement and this type of thing      return any(((WildcardType) supertype).getLowerBounds()).isSupertypeOf(runtimeType);   should also be replaced with a meaningful method name that descibes  the rules, in English, when we have co & contravariant wildcards."
java,3dhf9d,van_gaals_left_ear,1 point,Thu Jul 16 13:18:41 2015 UTC,"Encapsulating the conditionals into their own methods   Do I get this right? A method for 'supertype instanceof WildcardType'? That part is actually the most readable for me. :)  The line you want to replace might benefit from its own method with a better name, yes. But it would surprise me if the comment would not still help with bridging from the condition to the determination of the return value."
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 21:21:43 2015 UTC,"The line you want to replace might benefit from its own method with a better name,    Probably not just one, from the comments it is doing multiple things (see the example further down). Likewise the whole method is extra-ordinarily dense (which I guess is why you chose it :).  It really could do with being broken up, into simpler methods with well chosen names."
java,3dhf9d,van_gaals_left_ear,2,Thu Jul 16 23:12:53 2015 UTC,"Usually I said, but like /u/n0mel7 mentioned, Guava is not the typical code. But anyways, even as the code stands now, with comments, I can still not read what it does.  But really, I can't see why the code doesn't use proper if/else if statements in stead of all those if's. Also, the regular type checks can be separated in another method, call it isRegularSubTypeOf() and then you don't have to put a comment in your code anymore."
java,3dhf9d,g00glen00b,1 point,Thu Jul 16 12:18:12 2015 UTC,"I don't think Guava does wird stuff.  I guess if you use if/return, you don't need if/else if."
java,3dhf9d,nicolaiparlog,9,Thu Jul 16 21:25:15 2015 UTC,those comments are harder to read than the code!
java,3dhf9d,GuyOnTheInterweb,1 point,Thu Jul 16 10:13:59 2015 UTC,"I'd say the comments make obvious that complex rules are involved. If I were to draw an image of what is going on, I am sure I could o it in half the time from only looking at the comments compared to only looking at the code."
java,3dhf9d,nicolaiparlog,2,Thu Jul 16 11:00:20 2015 UTC,"This could also be done in code, e.g.  // if 'supertype' is <? extends Foo>, nothing is a subtype.   if(isCovariant(superType))        return false;"
java,3dhf9d,van_gaals_left_ear,1 point,Thu Jul 16 13:33:03 2015 UTC,I don't see how this relates to the existing code but I am tired and might try again tomorrow.
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 21:27:28 2015 UTC,"This is only a simple example, but the code reflects what the comment says, everything in the Guava example could be written in intention revealing style.   I think the reason it looks complex, is the comments are explaining co  & contra variance. They probably shouldn't (the definitions can be retrieved from StackOverflow if needs be).  They could instead encapsulate the logic / rules in method names. Probably at the expense of some performance (which could be optimised later - as others have said, because of performance concerns Guava is not the best material for this type of thing)."
java,3dhf9d,van_gaals_left_ear,2,Thu Jul 16 23:08:08 2015 UTC,"Yeah those comments are terrible.  I don't need a comment translating the code into English, just like I don't need a comment above a malloc call in C that says ""// allocate the memory"".  Well no shit."
java,3dhf9d,ladna,1 point,Thu Jul 16 16:33:14 2015 UTC,"Just that it is no translation. The information it gives is redundant, yes, but not obvious. So it does help figuring out what the code does. If you could do that just as easy without the comments (which I doubt), great, you're awesome, but the average dev won't and you know it."
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 21:14:23 2015 UTC,"There's a big problem in the software industry where incompetent devs work right alongside competent ones.  It's why we have terrible performance metrics, a ridiculous interview process, and source that ends up being more comments than code.  I get your point from a pragmatic perspective, but I don't think the response should be ""so dumb everything down"", it should be "" if you don't understand code, you can't work with it "".  To me, this is completely reasonable."
java,3dhf9d,ladna,1 point,Fri Jul 17 17:37:34 2015 UTC,"Competence is not a one-dimensional metric. Someone might be a C#-rockstar but maybe he does not know all the details about Spring, which he is currently working on. No what? He's incompetent? He needs to go on a three year Spring bootcamp before he can continue?  Or say you're working on software for insurances. The new gal in the team is awesome in every technical aspect but has little domain knowledge. She can't start working right away because she doesn't know all the details?  Why not assume an ""average level of knowledge"" (whatever that is) and add some (!) comments to point out the more arcane details?   I don't think the response should be ""so dumb everything down""   Providing contextual information means ""dumbing things down""? Does this apply to issue descriptions, version control comments, high-level architecture diagrams, ...?"
java,3dhf9d,nicolaiparlog,2,Sat Jul 18 19:24:38 2015 UTC,"To answer your questions directly, yes, those programmers need additional training.  I don't know about 3 years of Spring bootcamp, but we need to start having professional standards if we're to be taken seriously.  I probably came off too harsh, but I do think that if you don't understand something, you shouldn't work with it.  I'm pretty good with C, not a rockstar, but pretty good, but I don't understand Scala one bit.  It would be wildly irresponsible of me to take a Scala job, despite my experience/ability with C or ""average level of knowledge"".  Take this code for example.  I get single inheritance (who doesn't?), but I don't really understand bounds in that context, and the comment <? super Base> is of no use in checking 'from' being a subtype of 'to' doesn't really help, because I don't understand what Base is.  I'm assuming Guava has an extended type system and these are Guava concepts.  But all that aside, if I were to work on this code base, I would need additional training.  I have two major problems with comments:   Some coders end up writing more comments than code.  If that's happening, you're not coding, you're documenting, and documentation doesn't belong in code, if only because it's hard to find. A lot of comments just translate the code into human language.  Most coders are only doing that to get over their boss' lame ""comment your fucking code"" requirements.  But if you need that, you really shouldn't be coding.   And when I say ""you really shouldn't be coding"", I mean you might introduce a bug that exposes people's private information, or loses tons of money, or creates a security problem for 80% of the world's web servers, or loses precious data that can never be recovered, or destroys hardware, or blah blah blah.  It's hard enough (impossible?) for world-class programmers to get that stuff right; if you need code translated into English, you have no chance of getting it right.  Harsh maybe, but true."
java,3dhf9d,ladna,3,Sun Jul 19 02:03:42 2015 UTC,I would prefer it to be refactored into something where the logic was clearer and the comments were no longer relevant.
java,3dhf9d,codepoetics,1 point,Thu Jul 16 11:02:49 2015 UTC,Be my guest. ;) The method's structure is straight forward and no external knowledge seems to be required.
java,3dhf9d,nicolaiparlog,2,Thu Jul 16 11:20:23 2015 UTC,Guava is hardly typical code. It's used in pretty much every system in Google (and countless other companies) and needs to be ultra efficient and completely correct but mainly it does weird things that you should never need to do in your average web service. This is like comparing NASA code to your college assignment.
java,3dhf9d,n0mel7,1 point,Thu Jul 16 11:27:50 2015 UTC,"Guava is hardly typical code.   You are right, it is not typical. Because it deals with something I actually know something about (in this case Java's type system). I'd say the typical dev knows way more about what Guava does (again, e.g. the type system) than about the domain she is programming for.  So this code should actually be easier to understand."
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 21:10:52 2015 UTC,"Not necessarily because as I said, Gauva does weird stuff (so that you don't have to)."
java,3dhf9d,n0mel7,1 point,Thu Jul 16 21:13:16 2015 UTC,It's not weird at all. At least not if compared to stuff like this which is exactly the kind of code I think would benefit from comments.
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 21:24:02 2015 UTC,"I mean weird in the sense in that it makes heavy use of things like reflection, bit manipulation and low level data structures when there are simpler but less efficient ways to achieve the result, which you shouldn't have in your average Java service. This type of code does benefit from comments but most people aren't (and shouldn't) be writing this type of Java code."
java,3dhf9d,n0mel7,2,Thu Jul 16 21:33:09 2015 UTC,"I know what you mean. But it only seems weird to us because it is a layer below of what we usually do. I get it. I'm not saying it's easy.  I am saying that the same arcane crazy shit is going on in the business logic. Even for insiders (i.e. ""the business people"") it will be ""weird"" and hard to understand. The code may explain what it does very well. But adding a little ""we have to do this because our SLA requires us to"" adds a lot of information."
java,3dhf9d,nicolaiparlog,1 point,Fri Jul 17 07:46:57 2015 UTC,"I would    // if 'supertype' is <? super Foo>, 'this' can be:   // Foo, SubFoo, <? extends Foo>.   // if 'supertype' is <? extends Foo>, nothing is a subtype   Is not useful at all"
java,3dhf9d,tau-lepton,4,Thu Jul 16 14:37:34 2015 UTC,"I agree. There may be some corner case where a comment would be helpful but I believe this is the exception. As you have said, well written code should be understandable."
java,3dhf9d,flagrantaroma,2,Thu Jul 16 10:25:01 2015 UTC,By Javadoc I don't want you copying the function name and turning it into a full sentence. I mean worked examples and edge cases and best practice. Anticipating common usage patterns and explaining them.  This is half-way decent and   dispatchTrackballEvent(MotionEvent ev) Called to process trackball events.   still bugs me because it is a non phrase.
java,3dhf9d,philipwhiuk,2,Thu Jul 16 13:50:11 2015 UTC,"Seriously, get up to speed on clean code.   There are SO many books and articles written.  If you need comments, you are probably not coding clean."
java,3dhf9d,rfinger1337,2,Thu Jul 16 15:50:05 2015 UTC,"A stock exchange order of clearing type code 27 needs to be grouped with all other subsequent orders of type code 27 (if and only if they have a rounding lot below 0.01), before actually unloading them within a time-frame of at most 35 seconds.  Without comments.  Go!"
java,3dhf9d,lukaseder,-3,Thu Jul 16 16:40:10 2015 UTC,"You need a billing account before I write code for you, but if you are up to speed on clean code it will be fine without comments.  Each class does one thing.  It's name describes exactly what it does.  If you need to explain it with a comment, refactor the name until you don't need the comment.  If you have to write a comment (and occasionally you need a  ""why this is done""  - never HOW -) then you should feel shame as you write it."
java,3dhf9d,rfinger1337,4,Thu Jul 16 16:45:05 2015 UTC,"There are about 50 paragraphs to write about why the hell this code 27 is so damn special and whatever idiot VIP requirement and SLA-from-hell requires us to ABSOLUTELY NEVER pass those 35 seconds or we'll get our asses sued.  True story.  (of course, you may opt to use less cursing in actual comments, although that takes a lot of discipline)  This is just to say, I fully agree on the why vs. how argument."
java,3dhf9d,lukaseder,-3,Thu Jul 16 16:52:40 2015 UTC,"I accept that as a reasonable comment, though I still would feel shame as I wrote it."
java,3dhf9d,rfinger1337,4,Thu Jul 16 17:11:17 2015 UTC,Then better don't work on 10 year old PL/SQL legacy code :)
java,3dhf9d,lukaseder,0,Thu Jul 16 17:15:01 2015 UTC,Great job addressing the arguments. lol
java,3dhf9d,nicolaiparlog,-2,Thu Jul 16 20:33:21 2015 UTC,http://www.amazon.com/The-Clean-Coder-Professional-Programmers/dp/0137081073
java,3dhf9d,rfinger1337,2,Thu Jul 16 16:47:06 2015 UTC,"I work in a basically ""no comment"" shop, and I don't think I'd like to move to a place that cared about comments. There are a few situations where I will write comments:   unusual algorithm or syntax (e.g. bit shift operators) a method that I struggled to write cleanly config files (poms, spring xmls, etc)   If I wrote my methods cleanly they should be less than 10, or even 5, lines of code. Is such a short method illegible to you without comments? This may be the reason the writer is so angry with confusing code that's uncommented, that code is not SOLID. Code should be simple and self documenting. If you need comments, chances are it's because you failed to write clean and legible code."
java,3dhf9d,proskillz,1 point,Thu Jul 16 17:20:29 2015 UTC,There is nothing clean about limiting methods to 10 or 5 lines of code.  Methods should perform a specific function not be broken out by arbitrary number of lines.  Sometimes 5 methods in 70 lines is much harder to read than one 40 line method.
java,3dhf9d,avoidhugeships,-3,Thu Jul 16 18:13:23 2015 UTC,"The number of lines is not arbitrary. If you're writing a method that is longer than about 10 lines, it almost certainly is doing more than one task or function and should be broken apart into atomic pieces. One major reason to have small methods is unit testing. Unit testing is much easier when you have atomic methods, as they are obvious cases, not a huge amount of variable output and mocking/stubbing."
java,3dhf9d,proskillz,0,Thu Jul 16 18:35:56 2015 UTC,There are many things that take more than 10 lines and are a single unit of work.  Most of my methods are this short but certainly not all.  Breaking your code into a million arbitrary pieces and making it incomprehensible to make it easier to unit test is not a good practice.
java,3dhf9d,avoidhugeships,-1,Fri Jul 17 12:48:47 2015 UTC,"Do you have a source on easily testable code being a bad practice? Everything I've read on the topic suggests the opposite (Clean Code, Refactoring, TDD books, et al)."
java,3dhf9d,proskillz,0,Fri Jul 17 14:09:44 2015 UTC,"I never said easily testable code is a bad practice.  Making your code longer, more complex and harder to read to make it slightly easier to write a unit test is a bad practice.   There are some good points in those books but sometimes people take a general idea and try to make it a hard and fast rule with poor results."
java,3dhf9d,avoidhugeships,0,Fri Jul 17 21:31:22 2015 UTC,"Making your code longer, more complex and harder to read to make it slightly easier to write a unit test is a bad practice.    Here's the fundamental difference between you're idea of clean code and Bob Martin's; not that he's perfect, but I agree with him in this case. To me, a ""hard to write"" unit test is a code smell showing I need to clean up the underlying code. A ""unit"" should be as small and as possible, and hard to break down further.   There are some good points in those books but sometimes people take a general idea and try to make it a hard and fast rule with poor results.   Complete opposite for me. My code is 100 times better than it used to be when I just did whatever with long methods, little to no testing, and poor design patterns. I'm evangelizing these books and constantly downvoted because of it, but I don't care because they changed my life as a coder."
java,3dhf9d,proskillz,-1,Fri Jul 17 21:48:34 2015 UTC,"I am in favour of SOLID, short methods, clear names, ..., you name it. These things are ""must-do's"" and great when I want to understand the code I am reading.  But very often I don't want to read the code. I want to enjoy the abstraction that some subsystem is promising me. I may have to check some detail (i.e. under what conditions are exceptions thrown) but that's it. I will want to move on to the next detail until I have enough knowledge about what the other things are doing to work on my own.  As stated in the text: If you're so convinced, eat your own dog food and stop reading any official documentation."
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 20:21:52 2015 UTC,"I don't consider official documentation and comments to be related at all. Some people may consider comments to be documentation, but they're only code explanation at best. Writing documentation and examples of your API has nothing to do with commenting the code. That's like saying https://api.jquery.com/ is the same as reading the jQuery source code, since it's commented heavily."
java,3dhf9d,proskillz,0,Thu Jul 16 22:25:47 2015 UTC,"Damn, that misunderstanding crops here and there. For me Javadoc and the like are just a special kind of comment. So when I say ""no comments"" I mean ""literally no non-executable line in any damn file"".  So I guess we agree because my point is not to have people pepper their code with stupid inline comments like ""loop through the list"". I want some documentation saying ""returns all items the customer with the specified ID ordered; throws an Exception if there is no such customer"" or some such."
java,3dhf9d,nicolaiparlog,2,Fri Jul 17 07:21:31 2015 UTC,"We can debate what constitutes good comments versus bad, where the line between too many comments and just enough is,.all that kind of metric stuff is up for debate...  ...but if you call yourself a ""professional"" developer and you don't believe in comments then you're NOT a professional and a fucking idiot on top of it.   I'm not even going to try and mince words. This is the way it is. If you disagree then you're a moron and I hope you never have a job in this industry because you'll do more harm than good."
java,3dhf9d,fzammetti,1 point,Thu Jul 16 21:28:09 2015 UTC,Can I have that wallpaper?
java,3dhf9d,akeryw,1 point,Thu Jul 16 17:32:27 2015 UTC,"Don't know, you might have to ask the artist (like I did)."
java,3dhf9d,nicolaiparlog,1 point,Thu Jul 16 20:50:07 2015 UTC,@nipafx   2015-07-13 19:05 UTC  @igorclark I'm currently writing a rant about comments and would love to use this image of yours.  http://blog.wk.com/wordpress/wp-content/uploads/2011/10/102011comment.jpg  May I?     This message was created by a bot  [Contact creator][Source code]
java,3dhf9d,TweetsInCommentsBot,2,Thu Jul 16 20:50:13 2015 UTC,Don't document and make your code unreadable and complicated. That way you can't be fired. /s
java,3dhf9d,Adamas_Mustache,-3,Thu Jul 16 14:48:39 2015 UTC,"I have Checkstyle and Eslint set up so that every single possible thing required a comment. That means every class, every field, every method, every parameter, every return type, everything.   Now, I'll freely admit that my actual comments aren't always the best - especially when it comes to certain types of method. There's only so much you can actually write in a getter method, after all. But the requirement to always write comments means that when it comes to the elements that actually need it then you're already writing the comment so you're more likely to actually write something useful."
java,3dhf9d,sazzer,5,Thu Jul 16 13:22:25 2015 UTC,"But the requirement to always write comments means that when it comes to the elements that actually need it then you're already writing the comment so you're more likely to actually write something useful.   Is this really true?  In my experience it makes people more likely to blindly comment their code with bullshit like:  //the widget private final Widget widget;   I'm not saying I never comment code but when I do, it's always to say something that the code isn't already saying.  If you're commenting every single line of code, you are just adding a bunch of noise."
java,3dhf9d,CubsThisYear,8,Thu Jul 16 15:21:11 2015 UTC,Why are you documenting getters? Commenting everything is a waste of time. Time that could be spent much better.
java,3dhf9d,Stoompunk,1 point,Thu Jul 16 13:41:59 2015 UTC,"Several reasons. It means that the generated and published Javadoc contains documentations for those methods. That's important enough on it's own, but even more so when you consider that a getter method doesn't have to just return a value as-is - there's no point having a method at all in that case. It could just as easily be a computed value, or delegate through to some other getter, or who knows what. The documentation should tell you things like that. Then there's also the fact that my IDE shows the Javadoc on hovering of a method call, so I can see the reasoning behind the method call, and in the case of a getter see the reasoning behind the field that I'm getting easily without having to jump from where I am to the bean that I'm calling, and then to the field that I'm getting."
java,3dhf9d,sazzer,2,Thu Jul 16 14:01:39 2015 UTC,"It could just as easily be a computed value, or delegate through to some other getter, or who knows what   That's an implementation detail and shouldn't be relevant to your client code. If it's actually expensive to get() then there should be some internal caching in the object or it should be clear from the method name - this is separation of concerns. I shouldn't have to read the JavaDoc to use your code. I don't have time and this leads to errors and inefficient code.   there's no point having a method at all in that case   Yes there is, it's called encapsulation. It allows me to change, for example, that the returned value comes from a completely different object instead of the existing object without breaking existing code.  You sould stop JavaDocing stuff like this, it's a waste of everyone's time."
java,3dhf9d,n0mel7,6,Thu Jul 16 15:37:09 2015 UTC,"No it doesn't.  It means people assume the comment will tell you nothing, so they blank it.  Lots of your comments will be pointless re-wording of the function name and if they aren't your function name is probably wrong."
java,3dhf9d,philipwhiuk,1 point,Thu Jul 16 13:46:21 2015 UTC,"I am guilty of the same behavior and understand your arguments. I start to feel differently know.  But of course, that is not even the point of the post. I would currently be happy with just having some helpful comments."
java,3dhf9d,nicolaiparlog,-6,Thu Jul 16 20:56:48 2015 UTC,Comment Your Fucking Code!   Considered totally outdated and bad practice. Read Robert C. Martin's Clean Code for more information.
java,3dhf9d,errrzarrr,6,Thu Jul 16 17:32:27 2015 UTC,"As you might have guessed by the fact that I reference the book in the first line, I did. I do not automatically have to agree, do I?  And contrary to you I actually address the arguments against my position (e.g. names and tests as documentation)."
java,3djg2x,fernandokokocha,3,Thu Jul 16 19:32:15 2015 UTC,"The Java community is big. Really big. It is likely to have as diverse a set of opinions as the JavaScript community itself.  I love React overall. One way data binding, slim, doesn't try to do everything.  We currently use Backbone but would likely move to something like react in the future."
java,3djg2x,altCognito,1 point,Thu Jul 16 19:59:30 2015 UTC,"We use React in a single-page application with Spring-based backend API. We also use React in a more traditional backoffice-type application for forms, because they always get complex in the end. Both projects are doing well."
java,3djg2x,Infeligo,1 point,Thu Jul 16 20:06:19 2015 UTC,"I still don't get the benefits of react, could you sell me react using layman term?"
java,3djg2x,puntadewa,2,Fri Jul 17 07:47:28 2015 UTC,"React is not a framework, but a library. It means that you don't have to fit your ideas into ""their"" structure, but rather use React whenever and wherever you like.  React doesn't pretend to be a ""golden hammer"". It only does one thing - rendering the view. And does it well.  React scales very well due to its declarativeness. It's very much unlike jQuery, where you have to manually update dependencies. React's components re-render itself when needed.   And last but not least - React is really fast."
java,3djg2x,jupblb,1 point,Fri Jul 17 10:10:23 2015 UTC,"What attracted my team to this library in a company product is that it's ""V in MVC"", which is exactly what we need in a Play Framework based application. Apart from all basic benefits (fast execution, reusable components, easy management of content due to stateful elements) the most important advantage of this library is that it's extremely easy to learn. And it also does have lots of interesting user based projects (like material ui). Knowledge of React might also give more benefits in the future when it'll be possible to write Android apps with this (It's already possible to write iOS projects with React Native). My only worry is that we still don't have 1.0 version - which means that there might be some breaking changes coming."
java,3dflcm,based2,2,Wed Jul 15 21:53:48 2015 UTC,http://www.oracle.com/technetwork/java/javase/2col/8u51-bugfixes-2587594.html
java,3dflcm,lechatsportif,1 point,Wed Jul 15 21:53:59 2015 UTC,I assume this fixed the recent 0 day?
java,3dflcm,thejavaguy,1 point,Thu Jul 16 14:14:34 2015 UTC,Says Zero day was fixed http://krebsonsecurity.com/2015/07/adobe-ms-oracle-push-critical-security-fixes/
java,3dflcm,thejavaguy,1 point,Thu Jul 16 18:00:45 2015 UTC,this bug fix...  Slow cache performance since JRE 7u06 (August 2012 Java 7 Update 6)  http://www.oracle.com/technetwork/java/javase/2col/8u51-bugfixes-2587594.html
java,3dflcm,dr_entropy,1 point,Thu Jul 16 17:59:27 2015 UTC,Looks pretty boring; a desktop release. Mostly certs and jnlp fixes
java,3dhhwq,markee174,1 point,Thu Jul 16 08:55:54 2015 UTC,"Great, name it after a common commandline tool for ultimate confusion."
java,3d9zk9,friendlytuna,3,Tue Jul 14 17:35:26 2015 UTC,"There is a JEP being prepared to have an officially blessed class that subsumes most of the functionality of sun.misc.Unsafe. However, as Peter Lawrey (of vanilla java) put it on the JEP-off heap group:   My feeling is there is too many holes for them to plug in one release. This will mean we might expect a proper ?fix? in Java 10."
java,3d9zk9,llogiq,2,Wed Jul 15 07:07:15 2015 UTC,Didn't they say not to depend on sun.* classes?
java,3d9zk9,kxh,1 point,Wed Jul 15 22:45:19 2015 UTC,"When all you have is a hammer, every problem looks like a thumb  This time, the hammer is Unsafe and it was all that people had..."
java,3d9zk9,lukaseder,0,Sat Jul 18 13:03:45 2015 UTC,As I do .NET more than Java I have not needed unsafe code to make things work in my Java apps. However I have used unsafe functionality in .NET many times. What comparable performing APIs are being offered up in its place? Just JNI?
java,3d9zk9,Manitcor,5,Tue Jul 14 21:41:41 2015 UTC,"JNI will eventually be superseded by Panama, which will bring significant improvement, and in the shorter term the proposed VarHandle should cover some of the other functionality currently provided by Unsafe.  Edit: I'm also interested as to what sort of work you're doing that you find it appropriate to use unsafe functionality frequently..."
java,3dazt9,JimmySquishSquish,1 point,Tue Jul 14 21:42:59 2015 UTC,How about JUnit theories?
java,3d4ys2,saua,1 point,Mon Jul 13 15:48:13 2015 UTC,"Hi /r/java!   I created a very simple tool which hooks into spring's testing framework and allows you to easily mock beans. This is  basically what springockito does, unfortunately it appears to no longer be maintained.  At work we've been using it successfully for multiple of our applications and I figured it was time to spread the word.  Any feedback would be welcome!"
java,3d4ys2,xris-l,1 point,Mon Jul 13 15:48:47 2015 UTC,"Very nice, looks quite good.   I'll try it at work sometime!"
java,3d4vzk,codepoetics,2,Mon Jul 13 15:26:53 2015 UTC,"See also the proxology library, linked from the fine article."
java,3d76ef,Puppetpals1,3,Tue Jul 14 01:29:43 2015 UTC,Aren't Java applets no longer supported by a ton of browsers now?
java,3d76ef,Drepic26,4,Tue Jul 14 02:14:34 2015 UTC,"Stop trying, applets are universally dead."
java,3d76ef,-INFEntropy,2,Tue Jul 14 07:45:36 2015 UTC,Plenty of applets are still in use in corporate environments.
java,3d76ef,wildjokers,1 point,Tue Jul 14 14:07:57 2015 UTC,Then they can feel free to enjoy all the wonderful security implications.
java,3d76ef,-INFEntropy,1 point,Wed Jul 15 04:04:41 2015 UTC,"This should most certainly be in /r/javahelp. Either way, is it your applet throwing the exception? Or is it an error being printed in the console of the browser?"
java,3d76ef,wildjokers,1 point,Tue Jul 14 14:09:28 2015 UTC,"Revise your exception handling, make sure you have the full stack trace of your error somewhere. Check the Java Log Console.  This exception is probably from your code, and not the fact that this is run as an applet."
java,3d76ef,m1000,1 point,Tue Jul 14 14:37:59 2015 UTC,"Even though it's not Java programming related (yet the Exception gives a hint that there is something wrong in the program), it should be in /r/Javahelp.  /r/Java is for discussions about the Java ecosystem and not for any programming related (applets belong in that category) questions. All questions should be directed to /r/Javahelp.  Kindly repost there."
java,3d76ef,JusticeMitchTheJust,0,Wed Jul 15 10:38:01 2015 UTC,Try enabling NPAPI https://java.com/en/download/faq/chrome.xml
java,3d3vwv,axelfontaine,5,Mon Jul 13 08:55:39 2015 UTC,I use ssh for troubleshooting quite often. How should I do that without ssh?
java,3d3vwv,mikaelstaldal,4,Mon Jul 13 15:36:11 2015 UTC,"The idea is that it forces you to automate things to a degree where not much can go wrong, and that when it does go wrong, you just throw away the server and bootstrap a new one.  That's the idea, at least."
java,3d3vwv,the_opinion,2,Tue Jul 14 11:26:31 2015 UTC,"It is good to be able to throw away a broken server and bootstrap a new one to replace it. And it even makes sense to automate that.  But if that happens frequently, you will most likely want to investigate why, and then SSH can be a useful tool.  You can imagine other ways than SSH though, such as making a read only snapshot of the file system of the decommissioned server available to post mortem analysis.  My point is that if you get rid of SSH, you have to provide alternatives to all things it's used for, not just some of them."
java,3d3vwv,mikaelstaldal,1 point,Mon Jul 20 11:32:44 2015 UTC,"I agree. That's why I qualified it with ""that's the idea, at least""."
java,3d3vwv,the_opinion,3,Mon Jul 20 12:08:10 2015 UTC,"Check out Red Hat Atomic.  Designed so that you can manage, deploy immutable infrastructure.   Fully supported (performance, security patches, within 2 hour callback 24-7) via enterprise subscription from Red Hat."
java,3d3vwv,atwong,1 point,Mon Jul 13 17:28:27 2015 UTC,If you can apply security patches that implies whatever you are applying them to is not immutable. :/
java,3d3vwv,ryebrye,2,Mon Jul 13 20:23:55 2015 UTC,Good thing that isn't how atomic works
java,3d3vwv,atwong,1 point,Tue Jul 14 01:36:55 2015 UTC,"immutable = ""unchanging over time or unable to be changed.""  a patch = ""A patch is a piece of software designed to update a computer program or its supporting data, to fix or improve it.""  you can't change something and call it immutable."
java,3d3vwv,ryebrye,1 point,Tue Jul 14 01:48:31 2015 UTC,"As I understand it, the infrastructure your app stack runs on is indeed immutable. It's the host that runs it which gets the security updates etc. As you spin up a new container, it effectively inherits the latest patches from the host."
java,3d3vwv,the_opinion,8,Tue Jul 14 11:31:17 2015 UTC,"This sounds like an excellent way to ensure that no critical security fixes will ever get deployed rapidly, or at all."
java,3d3vwv,capitol_,3,Mon Jul 13 11:15:25 2015 UTC,This requires you to have an efficient deployment pipeline where new versions can be rolled out in minutes.
java,3d3vwv,capitol_,7,Mon Jul 13 11:17:28 2015 UTC,"Yes, and it requires that the deployment pipeline can get access to packages with security patches already applied with a timely fashion.  Since the debian repositories doesn't keep old packages with security holes around I presume that the pipeline will pull them from snapshot.debian.org instead (for example).  That sounds like our project would need someone to manually change the dependency so that it's not pointing to 1.0.1e-2+deb7u16 that has a security hole, but to 1.0.1e-2+deb7u17 instead (for example).  That means that someone on our team must track CVE's listed for the complete software stack, from the kernel up to the java layer.  If I compare that strategy with our current strategy of having our servers on debian stable and installing (only) security updates autocratically I can safely assure you that the average time we would have a security hole in production for some would rise dramatically."
java,3d3vwv,atwong,1 point,Mon Jul 13 11:51:38 2015 UTC,check out RHEL atomic.   Bypasses what you say.
java,3d3vwv,capitol_,2,Mon Jul 13 17:29:29 2015 UTC,"I read through their help page, and it might be me who is dense, but the ""sudo atomic host upgrade"" command to do updates looks very much like ""apt update && apt upgrade"".  Maybe there is architectural difference in handling security updates that i didn't understand."
java,3d3vwv,the_opinion,1 point,Mon Jul 13 19:17:40 2015 UTC,"The difference is you are upgrading the host, not all of your servers."
java,3d3vwv,el_chief,2,Wed Jul 15 08:03:03 2015 UTC,Except for the part where your devops tools connects to the server over SSH right? Agent-based server provisioning is fucking stupid.
java,3d3vwv,the_opinion,2,Mon Jul 13 18:28:21 2015 UTC,"Why is it ""fucking stupid""?"
java,3d3vwv,el_chief,2,Tue Jul 14 11:33:32 2015 UTC,"Forgive my hyperbole as I was quite hungover yesterday.  I prefer agentless server provisioning, as you don't have to install anything before you can install anything, and it doesn't take space, memory, add possible exploit vector."
java,3d3vwv,the_opinion,3,Tue Jul 14 17:58:28 2015 UTC,"Well, you still have to roll out ssh keys. That diminishes the advantage in a lot of use cases."
java,3d3vwv,monumentshorts,1 point,Tue Jul 14 21:04:26 2015 UTC,Or you generate the server as part of your build like Boxfuse does. No agents and no SSH required.
java,3d3vwv,atwong,2,Mon Jul 13 18:34:11 2015 UTC,This is the whole point of docker
java,3d3vwv,RockMeetHardPlaces,2,Mon Jul 13 14:34:59 2015 UTC,you need more than just docker.  You can break in through the OS or through other vectors.
java,3d3vwv,based2,1 point,Mon Jul 13 17:30:03 2015 UTC,"This seems... off ... I might be missing the point, but then again I'm a Java developer and not a systems engineer.  Oh wait.  This is the Java subreddit; I thought i was in /r/sysadmin for a second."
java,3d3lmp,vladmihalcea,5,Mon Jul 13 06:33:00 2015 UTC,"“Up to Java 6, you could use the substring() method to save memory, if you only needed a small chunk of the String. But since Java 7, both Strings share the same underlying char[] and the old optimizations do not work anymore”  This is completely the wrong way around. You've summarised Heinz's article but mixed up the before and after situation."
java,3d3lmp,stevoski111,0,Mon Jul 13 10:55:29 2015 UTC,"true, it was actually a bug on substring() implementation and can cause memory leak if your application is using long Strings and doing substring on them.  BTW, its already fixed by author."
java,3d52ok,rafaelement,4,Mon Jul 13 16:16:42 2015 UTC,"Have a look at SonarQube. You can check out loads of open source projects, and see how their code quality measures up. It shows you where they have violated some rules and also tells you why its a problem.  http://nemo.sonarqube.org/  The above is a link to the main dashboard. Pick a project and have a look around."
java,3d52ok,nocpu,1 point,Mon Jul 13 16:26:03 2015 UTC,wow! Even better than what I was looking for!!! Thank you SO much.
java,3d52ok,mrhhug,2,Mon Jul 13 22:52:10 2015 UTC,"apache commons, https://commons.apache.org/  you will probably use some of these libs in the real world, community reviewed."
java,3d52ok,thecarlhall,1 point,Tue Jul 14 02:06:39 2015 UTC,"When I decided to read more of others' code, I cut my teeth on an early version of Apache Tomcat.  Large projects like that can be daunting, but as @mrhhug said, it's real code that's community reviewed and lives on thousands of installs."
java,3d52ok,sinsan01,1 point,Tue Jul 14 17:23:37 2015 UTC,"You should go through the source code of classes from collection API like ArrayList, Hashmap on something like codegrep."
java,3czyhh,kepasanolose,6,Sun Jul 12 08:49:50 2015 UTC,Whats the advantage of this over https://projectlombok.org/features/Value.html and https://projectlombok.org/features/Builder.html
java,3czyhh,DarkFlare,6,Sun Jul 12 16:47:21 2015 UTC,Lombok's reliance on undocumented compiler APIs have held me back from trying it.
java,3czyhh,diroussel,-8,Sun Jul 12 17:47:21 2015 UTC,"yes, because nothing else you've ever used has ever done that.   that sounds like a reason somebody trying to sound smarter than they are would use. like people who hated on windows ""because it crashes and stuff"" or IE because ""it doesn't work right"" but can't be pressed for any specifics."
java,3czyhh,oldneckbeard,4,Mon Jul 13 02:18:08 2015 UTC,"I love the idea of Lombok, however implementation bothers me.  Your code doesn't really compile, except through some 'black magic,' that involves installing an IDE plugin.  I've used it, and found it too painful.  If you want to create a custom Lombok annotation, you must define separate Eclipse and IntelliJ implementations.  The Syntax is not Java, so that's another thing you must learn."
java,3czyhh,DevIceMan,2,Sun Jul 12 23:54:47 2015 UTC,"I use Lombok with Netbeans and don't use a plugin, didn't realize one was required."
java,3czyhh,dstutz,2,Mon Jul 13 12:51:55 2015 UTC,what do you mean by painful? installing an Eclipse or intellij lombok plugin is honestly not much pain in relation to the advantages it offers
java,3czyhh,epicallanl,3,Mon Jul 13 07:25:32 2015 UTC,Code that use Lombok is technically not Java and it is really dependent on the quality of IDE plugin.
java,3czyhh,puntadewa,2,Mon Jul 13 04:37:38 2015 UTC,"It is very much java, as it parses, compiles an runs as any other java program using standard build tools and without added runtime dependencies. It is way less invasive than AspectJ or other similar Java extensions requiring alternate or additional build steps. The only ""dirty"" thing it does with regards to the Java spec is modifying the AST (the in-memory parsed representation of the code) of the current compilation unit rather than generating new ones which is what the compile-time annotations are supposed to do. Also, IDE plugins work totally fine, except for IntelliJ which does not support @val for some stubborn reason, even though they have excellent support of the similar language construct in Scala. Go figure. We simply agreed no to use that feature - and we save tons on boilerplate elsewhere."
java,3czyhh,deep_fried_eyeballs,3,Mon Jul 13 08:47:58 2015 UTC,"It depends on how you define ""very much java"" or ""standard java"" etc. It's not a standard java because the code no longer complies with the JLS. (for example: if you define private field, accessor method could not appear out of nowhere whatever annotation it may have). It will continue to be non java compliant until AST transformations and their effects would be standardized and described in JLS. On a practical aspect: fraction of tools don't work to full extent with lombok, if you don't use some tools it doesn't mean that other don't use them as well. Lombok community just cannot write adapters or plugins to all variety of java tools."
java,3czyhh,elucash,3,Mon Jul 13 09:09:35 2015 UTC,"See also PhantomPojos, for a Java 8 alternative with no code generation: https://github.com/poetix/phantom-pojos"
java,3czyhh,codepoetics,1 point,Sun Jul 12 17:14:22 2015 UTC,"The more choice - the better! Just a side note, the point is not only make some API possible: debug-ability, performance, serialization(binary/JSON), and other concerns are also important."
java,3czyhh,elucash,5,Sun Jul 12 21:08:47 2015 UTC,This is cool!
java,3czyhh,Jire,4,Sun Jul 12 09:08:14 2015 UTC,Groovy provides this functionality via the @Immutable annotation
java,3czyhh,tonydrago,5,Sun Jul 12 13:36:54 2015 UTC,What is the application for this?
java,3czyhh,gee_buttersnaps,3,Sun Jul 12 17:37:58 2015 UTC,"Not sure I understand your confusion. Are you asking what immutable classes are good for, or what the library does?"
java,3czyhh,nuclearqtip,-2,Sun Jul 12 18:23:24 2015 UTC,"When would you use it.  All I'm seeing is that you can reduce boilerplate. My IDE refactors code to my satisfaction.  If you want to use a language that has these features then use Groovy, Clojure, Scala, etc, they too compile to byte code."
java,3czyhh,gee_buttersnaps,8,Sun Jul 12 18:50:00 2015 UTC,"OK, so fair warning I'm a Scala fanboy so what you're saying I buy 100%.  HOWEVER not everyone can escape from Java. Writing a ""proper"" immutable class is time consuming and cumbersome. Worse, if your company is big on coverage percentages, now you have to write unit tests for some dumb POJO that just stores values. And don't even get me started on rolling your own builder pattern. It's a waste of time in a lot of ways. So having an annotation-driven approach that frees the programmer up to concentrate on business logic rather than fluff is really nice."
java,3czyhh,nuclearqtip,3,Sun Jul 12 19:02:32 2015 UTC,"At my current job, nearly all of our Java classes are immutable, which greatly increases the boilerplate code.  What takes us 50 lines of code in a POJO is about 1-3 in Scala.  That said, having experienced the benefits of immutability, there's no going back.  I'm tempted to replace our Builders with simple Scala classes at work, but am mostly waiting for the right time."
java,3czyhh,DevIceMan,0,Sun Jul 12 23:48:57 2015 UTC,"Try Lombok @Value for immutable classes. No, really : https://projectlombok.org/features/Value.html  Keep Scala for the functional features."
java,3czyhh,deep_fried_eyeballs,3,Mon Jul 13 08:52:56 2015 UTC,"Keep Scala for the functional features.   Java-8 functional features could be better, but there's a LOT you can do functional in Java-8"
java,3czyhh,DevIceMan,3,Mon Jul 13 13:00:57 2015 UTC,"Immutability reduced the likelihood for bugs and errors to propagate into your application.  For example, lets say your API returned a mutable object, and then that object is modified by some external code, and then your code tries to work with that same object, tracing that bug is going to be somewhere between difficult to impossible.  Compiler optimization is another benefit of immutability.  Since the compiler knows an object cannot be mutated, it can more easily cache and reuse values, re-order operations, or run them concurrently.  When dealing with threads, immutability becomes even more important.    If any thread can mutate the object, the state of that object is always uncertain.  An object may be mutated in the middle of a method, so while (for example) 3 might have been the value at the start, by the end it could be 10, or 13, and you'll get really strange bugs, race conditions, etc.  Immutability is unfortunately quite painful to do in Java, which is why you see things like builders, factories, and other similar patterns.  With Java-8 functional programming features, mutability becomes even more problematic."
java,3czyhh,DevIceMan,1 point,Sun Jul 12 23:43:00 2015 UTC,"I don't know why, but I feel like I'm looking at Javascript generated code.."
java,3czyhh,papers_,1 point,Sun Jul 12 23:56:55 2015 UTC,"I'm a bit let down that they clone arrays on get, instead of allowing to statically prove that the returned array is not modified."
java,3czyhh,llogiq,2,Mon Jul 13 00:08:29 2015 UTC,"You can use immutable collection instead of array there, so no array is  copied on get. Also, there are some primitive immutable collection I guess. Statically proving that array will not be modified is very limited and barely reliable in java. Most array returning APIs in java clone internal arrays to maintain consistency."
java,3czyhh,elucash,1 point,Mon Jul 13 01:24:01 2015 UTC,"Style question — what do you prefer: a) instantiating a nested static Builder class directly a la Joshua Bloch or b) a public static class method that returns the nested builder?  So when using the class, do you prefer this (a):  Item item = new Item.Builder().build();   Or this (b):  Item item = Item.builder().build();   And why?"
java,3czyhh,puuut,2,Mon Jul 13 07:21:25 2015 UTC,"Citing Effective Java. 2nd ed. Item 2:   ... Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object...   Guava heavily use factory methods for builders, mainly because of generics (prior to 'diamond' in java 7) and flexibility to have other builder factories: think ImmutableSortedSet.naturalOrder(), reverseOrder() etc.   Also we shouldn't forget that Josh Bloch worked at Google at the time when core of Google Collections/Guava was created and was one of the major authorities regarding API design for Google core libraries, so he would not be against using factory methods for this. (That was merely an anecdotal evidence than a point)  Immutables was primarily designed after Google's immutable collections and uses factory method by default. However you can use constructors for builders or configure other conventions using styles."
java,3czyhh,elucash,1 point,Mon Jul 13 07:46:39 2015 UTC,Thanks!
java,3czyhh,puuut,1 point,Mon Jul 13 08:10:47 2015 UTC,has exposed that Builder is part of Item when the user might not care hides where the builder comes from and you can have multiple builder factories for different use cases   just my 2 cents to add on
java,3czyhh,TheDuke45,1 point,Tue Jul 14 20:46:54 2015 UTC,https://news.ycombinator.com/item?id=9873645
java,3czyhh,based2,-16,Mon Jul 13 20:22:32 2015 UTC,Y U NO SCALA?
java,3d0vjk,moru0011,2,Sun Jul 12 16:13:13 2015 UTC,"This is awesome. There is a really interesting ecosystem growing around reactive streams, and remoting is a really cool and important addition.  The ability to Stream  across services in Java with simple-react (our own reactive streams impl, which provides async jdk 8 streaming) or RxJava , Reactor etc via Kontractor into services that could be running Akka Streams, Quasar Streams or Kontractor Streams offers incredible choice and flexibility.   Link for simple-react : https://github.com/aol/simple-react"
java,3d0vjk,johnmcclean,2,Sun Jul 12 16:58:05 2015 UTC,"cool, was not aware of this .. transparently remoting futures will not work out of the box ofc, however if one translates them to kontraktor Promise's behind the scenes it could work. might try as I find time :)"
java,3d0vjk,johnmcclean,1 point,Sun Jul 12 17:44:35 2015 UTC,"The Reactive Streams publisher available in simple-react at the moment, asynchronously publishes the results rather than the futures themselves.  If remoting Futures (or Kontraktor Promises) was possible then that would open a lot of interesting possibilities."
java,3d0u3v,tlg93,9,Sun Jul 12 16:00:19 2015 UTC,"Oh my lord, the Oracle tutorials are so good. Use those!"
java,3d0u3v,trentv4,5,Sun Jul 12 16:11:29 2015 UTC,"Internet. It's free and has all the information you could want.  As a supplement, however, I'd advise you to buy Effective Java, 2nd Edition, by Joshua Bloch. Written by someone who used to work on Java, it helps you start thinking about how the code is written and functions rather than what it does."
java,3d0u3v,Anon10W1z,3,Sun Jul 12 16:02:11 2015 UTC,"Take a look at the /r/javahelp wiki. You'll find plenty good and free tutorials there.  I'd say that the net and books complement each other. I learned most from the internet, but books are an always available, valuable reference."
java,3d0u3v,desrtfx,2,Mon Jul 13 05:56:30 2015 UTC,"Book should be your first reference followed by internet. You will learn more in less time by using book, internet is other way around."
java,3d0u3v,javinpaul,2,Mon Jul 13 16:09:58 2015 UTC,"As someone with a very short attention span, I say you should use the internet. I'm speaking entirely from my experience here, but:   It's quick to absorb, and comprehensive without looking like a trillion-word document. You learn much quicker-- you see examples in play, and compared to a book or a classroom setting, you can just take it hit after hit for a much longer time, and learn a lot more a lot quicker. This taught me stuff CS classes and books didn't, believe it or not.   https://www.youtube.com/watch?v=Hl-zzrqQoSE&list=PLFE2CE09D83EE3E28  Check this dude's stuff out. He's comprehensive. Each of his videos cover a single topic. Easy to go in and out of the loop from, and easy to cross-check and supplement with outside information. Totally do it!"
java,3d0u3v,ActualHater,3,Mon Jul 13 04:10:17 2015 UTC,"Don't use theNewBoston. He is a discouraged resource in most programming related subs. He uses terrible variable naming, doesn't stick to common conventions, and in general teaches frowned upon practices. All the above is essential to be avoided especially in the beginning.  Derek Banas is the way better alternative."
java,3d0u3v,desrtfx,4,Mon Jul 13 06:00:00 2015 UTC,"Derek Banas   Yup, agree with this one!"
java,3d0u3v,nocpu,3,Mon Jul 13 16:32:21 2015 UTC,Agreed.  He annotates his code really well so a noob like myself can read and understand it.
java,3d0u3v,ohlaph,1 point,Mon Jul 13 17:15:47 2015 UTC,Never thought about that-- I'll check it out!
java,3d0u3v,ActualHater,1 point,Sat Jul 18 23:47:49 2015 UTC,I would suggest reading articles online because there are several benifits -    Less intimidating than a thick book. Much wider choice of authors A certain author might have covered a certain topic better than others. Free
java,3d0u3v,sinsan01,-1,Mon Jul 13 08:40:04 2015 UTC,Why not both? Pick what's best.
java,3czt59,jeandieu,7,Sun Jul 12 07:21:49 2015 UTC,"One module to rule them all. It's nice design to split them in separate module, but unless you actually share your modules between several projects, you only get the pain without any benefits."
java,3czt59,xhak,3,Sun Jul 12 08:03:27 2015 UTC,Put your business logic in the EJB's.  Forget the idea of DAO's.  The EJB's serve the purpose of DAO's via Entity Managers and things of a similar nature.
java,3czt59,harmonicPersistence,1 point,Sun Jul 12 08:12:35 2015 UTC,"I worked in a project so big, that it was divided in several really big ears and the each application was divided in several modules. Each module had a DAO part. In practice these were EJBs using EntityManager to save and retrieve entities."
