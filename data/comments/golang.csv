golang,3e5t77,Jamo008,1 point,Wed Jul 22 04:30:02 2015 UTC,"I'm not sure you always want to cycle. If you have reads that are not a multiple of 256 bits, this will throw away some bytes. Also, your reader isn't very crypto in nature, as you simply hash what is output (so you can predict future outputs by just looking at the output and hash it yourself).  Off the top of my hat, this seems a better design to me: http://play.golang.org/p/PDTLyCDQfM, though it's untested and I'm not that much of a crypto person :)"
golang,3e5t77,TheMerovius,1 point,Wed Jul 22 08:48:26 2015 UTC,"Thanks, yep - should be saving the leftover bytes. It's definitely not very crypto in nature, however, I currently need it to allow the user to generate the same SSH key on demand. What would you suggest as an alternative?"
golang,3e33xn,SerialMiller,6,Tue Jul 21 16:18:06 2015 UTC,"I hate tags. They are effectively a DSL embedded into go, without syntax highlighting, specification or static checking. In theory, they are free-form strings and thus provide flexibility in their usage -- in practice, however, a de-facto language has emerged, where you hand-serialize a map[string]string into it. But they're not namespaced, so if I make a package foo that interprets tags and someone else makes a package foo that interprets tags, you can't have a type that works with both. In their current usage, they also make something that should be a property of a particular serialization-process instead a property of the type. If, for example, I want to never send a password as part of an API response, but I want it in the serialized object in the database, I have to write two types and manually copy stuff around whenever I (de-)serialize it.  Thus, I try to avoid tags alltogether as good as I can. They are not a feature I would choose to promote actively."
golang,3e33xn,TheMerovius,4,Tue Jul 21 16:39:58 2015 UTC,"I see your point, but like all things in life they have their benefits. Tags allow you to develop smaller applications faster. If however, your codebase grows and the use of tags holds you back, I would obviously move away from them.  I am not condemning nor trying to advertise tags in this post, the aim is to show people how to implement it in their own applications. After that it's up to them to decide whether they find tags too much magic, or if it suits their needs."
golang,3e33xn,dchapes,2,Tue Jul 21 17:21:34 2015 UTC,"So if you were implementing something like encoding/json with a better API, how would you easily configure json.Marshal to work with your own type? Would you require even common things (say json:""title"",omitempty) need to implement their own encoding.TextMarshaler? Would you pass some kind of config into marshal? Or is there a better, easy way?"
golang,3e33xn,TheMerovius,3,Tue Jul 21 17:32:06 2015 UTC,"Honestly: I don't have a good solution either. In particular as we are stable now. I would probably start by putting tags in the language as package-namespaced typed identifiers. If that is unacceptable, because the spec would get too complex (which I would understand) the API would need to be different.  Given the language as is, the best (as in most ""correct"") implementation would probably be some kind of visitor-pattern. You pass a closure to json.Marshal, that decides in what way a given field should be marshaled.  But, I didn't really want to hate that much on tags. They are an uglyness, but one I can live with being in the language. But I wouldn't promote them and in my opinion we don't need more packages that make overload them (for example I saw some kind of ORM-like package that uses the 'db' tag-key). Find solutions that work together with the compiler."
golang,3e33xn,quiI,1 point,Tue Jul 21 22:50:17 2015 UTC,"Reservations around tags aside, this is a really straightforward introduction to tags (read in <1 minute). Good job."
golang,3e5wm8,obito02,1 point,Wed Jul 22 05:04:09 2015 UTC,"rconn, err := net.Dial(""tcp"", dst)                 if err != nil {                 log.Println(""errorconnectiongto"",dst,"":"", err)                     //  lconn.Close()                     return                           }  I put part of the code I need is to be able to edit the payload of rconn which is a variablde net.conn and to its ves io.write added this so help entener my problem thank you"
golang,3e2w0a,Chillance,1 point,Tue Jul 21 15:21:15 2015 UTC,"I just want to say that I posted this in text, but it was blocked by reddit filter, and after talking to the admins to this subreddit, they said I should write a blog post instead and link to it. And that is what I'm doing.  I'm really hoping for a sincere discussion so I can make the marketplace for my users.  Thanks!"
golang,3dzprs,MrJamesCole,5,Mon Jul 20 21:02:26 2015 UTC,"Reading through, some initial comments:  1) Show your includes!  In this case it's probably pretty easy to figure out, but when you start using code from an external library but don't show what the library is it makes it quite hard to follow along.  2) Along the same vein, toss a comment in when you're using a variable defined somewhere else.  For instance, I have absolutely no idea what ""hb"" is(except that it's probably an integer) in the first code snippet."
golang,3dzprs,rco8786,1 point,Tue Jul 21 02:21:12 2015 UTC,"Thanks for your feedback. I have added includes and some comments. I thought something like ""hb"" would be OK, as it was defined in the same example code block and just a couple of lines before the first time it was used.   The way I structured the code examples might not have been brilliant, I was trying to remove everything that was not essential in the code block in the blog post. and keeping the full code on Github. The reason was not to try to distract the reader while reading. However, it makes it hard to ""copy/paste"" code while reading, and it's easy to remove to much."
golang,3dzprs,c0p,1 point,Tue Jul 21 05:51:25 2015 UTC,"You have context, so something like ""hb"" seems reasonable and straightforward.  But to someone without context it means nothing.  Code is read more often than it is written so choosing appropriate variable names is crucial to ensure that those reading do not need to spend extra mental cycles mapping short variable names.    I haven't read your code yet, but I'm guessing that something like ""heartbeat"" would've been a better name choice.  It's straightforward and conveys what is being stored in it.  Plus all modern code editors do name completion, so there's no need to use short variables under the guise of saving key strokes :)"
golang,3dzprs,conekt,0,Tue Jul 21 15:42:15 2015 UTC,Agreed. I don't even want to read it.
golang,3dzprs,akarl,1 point,Tue Jul 21 02:27:57 2015 UTC,"FYI, your page layout on an iPad in landscape keeps recalculating the widths of the sidebar and content columns, making it impossible to read that way. In portrait the content column is so narrow as to make even your punch card-friendly code wrap, so the code becomes hard to read. Reader view doesn't even help, as the code comments are low contrast enough that reader view makes them white on white."
golang,3dzprs,michaelbironneau,1 point,Tue Jul 21 11:46:52 2015 UTC,"Thanks for the heads up, I had not updated my theme in a while."
golang,3dzprs,michaelbironneau,1 point,Tue Jul 21 12:35:40 2015 UTC,"Great article, really enjoyed reading it, thanks. One question: at the end, you access the node's pstore to verify that the entry has been committed. Can you do this without knowing about the underlying storage? eg. if I am a user of the system and I want some sort of acknowledgement that the message I Propose() has been committed (at least to the leader's journal), is that possible through the raft API? Or if not, how does one implement retry logic?"
golang,3dzh0s,saloz23,1 point,Mon Jul 20 20:02:04 2015 UTC,Nice work. I'll have to check this out.
golang,3dzh0s,muffinz0,1 point,Mon Jul 20 23:12:05 2015 UTC,"Hey buddy, this is pretty nice. How was working with the docker deamon, is that library your using to interact any good?"
golang,3dzh0s,CzarSkye,1 point,Tue Jul 21 00:09:18 2015 UTC,"Author here. I used this library ( https://godoc.org/github.com/fsouza/go-dockerclient ) to interact with it. It uses the remote API to interact with the docker daemon. You'll have to open that port if you are going to connect to it remotely. Since this port will be open, I added an HTTP authentication layer using nginx which will then proxy pass the request to the daemon."
golang,3dzh0s,MohamedBassem,1 point,Tue Jul 21 23:40:38 2015 UTC,Neat. But why Martini?
golang,3dzh0s,Bromlife,1 point,Tue Jul 21 15:07:51 2015 UTC,I'm a go beginner. I searched for a small web framework and martini was the first thing I found. It's very easy and suitable for my needs since I have only 2 endpoints.
golang,3dzh0s,MohamedBassem,1 point,Tue Jul 21 23:43:42 2015 UTC,"Why did you choose MySQL as the backend instead of, say, redis?"
golang,3dzh0s,c0p,1 point,Tue Jul 21 15:36:36 2015 UTC,"Well, There wasn't any real specific reason for the choice to be honest. I guess redis would have been a better choice since I do have a running redis instance for service discovery."
golang,3dzfof,alexisnotonfire,1 point,Mon Jul 20 19:52:33 2015 UTC,"Interesting, I am pretty ignorant as far as dev communities outside of london. A lot going on over there?"
golang,3dzfof,quiI,1 point,Mon Jul 20 21:42:57 2015 UTC,"Portsmouth/Southampton have a decent tech scheme, there is a fairly large php user group that has meetups once a month in Portsmouth. I work at a decent sized tech firm with a few people keen to join, and I know that there are other companies around here using Go."
golang,3dzfof,oarmstrong,1 point,Mon Jul 20 21:55:58 2015 UTC,"Ooh, I'm right on the Surrey / Hampshire border, count me in for this :)"
golang,3dzfof,warmans,1 point,Mon Jul 20 22:49:11 2015 UTC,You could start a group on meetup.com.  thought being in Southampton its likely to be more losergroup then usergroup. I think bloody daryl hosted a meetup at the office before for something. Probably something not safe for work
golang,3dzfof,jfcalcerrada,1 point,Tue Jul 21 07:31:09 2015 UTC,I live in Southampton and more than happy to join!
golang,3dzwbf,panama_canals,1 point,Mon Jul 20 21:49:41 2015 UTC,"Why? Why can't you create the comment immediately?  I've used this library: https://github.com/streadway/amqp , but only on the ""producer"" side. It's easy to use.  If you don't want to create the comment immediately, you can use a buffered chan."
golang,3dzwbf,pierrrre,1 point,Mon Jul 20 22:21:58 2015 UTC,"I know Go is fast for sure, but this has more to with the whole ""microservices"" architecture thing.  Sometimes an object does not need to be created immediately. Let's say I've got a Rails app; I click a link and it builds a PDF or something like that. This is a long running process, I don't want my users waiting for the PDF to finish, so it's suitable for a non-blocking background job. In my case I want to send a message via RabbmitMQ to this Go service. The services listens for a job and does it. From the Rails app, I hit /pdfs/index or whatever, and see a list of PDFs done, which is pulled from the REST aspect of the Go server. This is a pretty involved example, but totally possible in the real world."
golang,3dzwbf,pierrrre,2,Mon Jul 20 22:45:06 2015 UTC,"OK, that's a good reason.  Read https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/go & https://godoc.org/github.com/streadway/amqp"
golang,3dzwbf,jasonbx,1 point,Mon Jul 20 22:52:15 2015 UTC,"I don't want my users waiting for the PDF to finish,    Why not call the pdf generating part in a goroutine and return the response back immediately to the user? In this case, it will be non blocking for the user. Although, if the load is too large that the system cannot scale, you will need to go for a queuing system."
golang,3dzwbf,roveboat,1 point,Tue Jul 21 05:24:53 2015 UTC,"Although, if the load is too large that the system cannot scale, you will need to go for a queuing system.   His usecase was that the PDF generation is triggered from a Rails app - so this wouldn't work.   Also, even if his API was on Go as well, this would quickly run into the scaling problem you point out - you'd basically be killing your API in case the PDF generation load on the server got too high."
golang,3dzwbf,jasonbx,1 point,Tue Jul 21 08:15:53 2015 UTC,"His usecase was that the PDF generation is triggered from a Rails app - so this wouldn't work.   Assuming there is no load issue, this will work perfectly with golang. Rails app calls a golang API server which can immediately return the response back to the app while creating the PDF in the background."
golang,3dzwbf,google_you,2,Wed Jul 22 04:39:09 2015 UTC,"For asynchronous tasks, you create a task resource clients can check. For example,  POST /comments/submissions HTTP/1.1  ; response HTTP/1.1 202 Accepted Content-Location: http://fuck/comments/submissions/1   Clients can keep checking that resource to see the status:  GET /comments/submissions/1 HTTP/1.1  ; response HTTP/1.1 200 Ok Content-Type: text/html  <link href=""http://fuck/comments/submissions/1"" rel=""self""> <p>Pending review bro.</p>   When asynchronous task is done, you'd redirect clients:  GET /comments/submissions/1 HTTP/1.1  ; response HTTP/1.1 303 See Other Location: http://fuck/comments/1   Clients can now GET, PUT, DELETE  /comments/1....  For implementing this in Go, I would create a process for HTTP stuff. And another process that works on asynchronous task (consuming RabbitMQ messages). If worker is down, HTTP is still up.   It's usually better to create a simple program that does one thing well. Once you have many simple programs, you can have a supervisor program that manages lifetime of those programs."
golang,3dzwbf,qu33ksilver,1 point,Tue Jul 21 02:21:26 2015 UTC,"Oh this is nice, I didn't know about the 202 status code."
golang,3dzwbf,smallfishxy,1 point,Tue Jul 21 05:43:00 2015 UTC,try https://github.com/smallfish/rabbitmq-http ?
golang,3dzwbf,argandas,-1,Wed Jul 22 05:26:18 2015 UTC,"I have never used RabbitMQ, but you should totally take a look at martini for REST APIs  https://github.com/go-martini/martini About having producer-consumer loops inside the app, I suppose is for testing purposes, try with in-built testing package for Go. http://golang.org/pkg/testing/"
golang,3dzwbf,ecmdome,1 point,Mon Jul 20 22:13:34 2015 UTC,Do not use Martini for REST API  Use the standard net/http library or possibly Gorilla MUX to handle your routes and maybe Negroni for middleware.
golang,3dzwbf,Bromlife,2,Mon Jul 20 23:19:46 2015 UTC,"I agree with your statement 50%. Do not use Martini.  But you don't need Gorilla or Negroni either. The best thing I ever did for my web application was writing my own muxer. Sure, I initially started using Gorilla, but I soon realised it didn't fit my needs perfectly. Looking at the Gorrilla Mux source code made me realise that I could easily cut out the middle man & doing so also cut out a lot of overhead. It's can't be overstated just how much overhead these libraries add.  They're great to get you started, and I would use them for simple ""Hackathon"" style hobby projects. But for real apps you're building - do it yourself."
golang,3dzwbf,ecmdome,1 point,Tue Jul 21 15:18:54 2015 UTC,I actually very much agree with you.  I started with standard library and went to Gorilla for the muxer just because I wanted to save some time...  I actually like Negroni... But yeah you can essentially build it pretty simply or something like it...
golang,3dzwbf,Bromlife,1 point,Tue Jul 21 15:56:13 2015 UTC,"When using Negroni (or Alice) I quickly realised that ""middleware"" really only applies in a framework context. Seeing as you're building software from the ground up, with awesome first party libraries, in my opinion it doesn't fit in the same way. Why would you need middleware if you're building the routing engine?"
golang,3dzwbf,ecmdome,1 point,Tue Jul 21 15:58:59 2015 UTC,I don't see how mifdlewares only applies in a framework context.  I mean essentially I'm building a custom framework for my application.  I like the middleware pattern for auth and handling some session data.
golang,3dzwbf,argandas,1 point,Tue Jul 21 16:06:49 2015 UTC,"Any good reason not to use martini? It's.. really easy to use, I'm kind of noob on this. So far only used mastini."
golang,3dzwbf,Mteigers,2,Mon Jul 20 23:25:15 2015 UTC,Martini due to the amount of reflection use and dependency injection leveraged is quite a bit slower than other frameworks. Though when I say quite a bit slower we're still measuring in the nanoseconds range.   We actually run a production REST API in Martini. At the time most of our developers only knew PHP (our company recently switched to Go) and Martini was the most familiar feeling to the team to allow us to deliver a product the fastest. Is it fast for us? Go/Martini has never been a concern for what it actually does. Will we rewrite it and ditch Martini? Probably.
golang,3dzwbf,ecmdome,0,Tue Jul 21 00:58:28 2015 UTC,"Its not idiomatic to how Go was designed.  The creator of Martini even wrote a response to the criticism of it saying he built it before fully understanding Go.  I reccomend starting with standard library only and going to 3rd party when you see a need.  You will most likely use the Gorilla MUX rourter, but I recommend building your own first before jumping to that.  Look at Go as modular rather than one framework to rule them all.  Also ORM is a tricky one in Go.  I use Gorm, which can be really nice but I sometimes wish I just abandoned an ORM and went with the standard library or maybe Gorp.  Go is really fun though so enjoy the learning experience!"
golang,3e1urb,dgryski,6,Tue Jul 21 08:49:03 2015 UTC,"Maybe I missed it in there, but I still don't understand, what is the proposed scope of the CoC? What is the definition of the ""Go community""? Each community seems independent, from Reddit to Slack to golang-nuts to IRC. Does it extend to Twitter and other social media?"
golang,3e1urb,mwholt,4,Tue Jul 21 13:37:00 2015 UTC,"As far as I can tell, it includes all of those places that you mentioned. I think it's a little sad that there's very little discussion on this thread. I think people just got tired of it, especially when they saw that Andrew Gerrand wasn't really looking for feedback about the CoC from Reddit, only confirmation for a decision that had already been taken.   Personally I wish they had extended the Go philosophy of ""less is more"" to this area as well, and it seemed like most of the people on reddit seemed to agree. But Andrew decided that in this case, ""more is more"". What's more, since he solicited feedback here he can now claim that it was endorsed by the community when it wasn't."
golang,3e1urb,nexusbees,5,Wed Jul 22 01:46:03 2015 UTC,"We marginalize people based on preferences of experiences with different technologies. Why is it okay to make fun of Windows or Ruby or Java? Even if we think we’re just being derogatory towards the technology itself, the users very often have made it part of their identity. These jabs divide us more than they bring us together.   My first ever exposure to Go was a video by Rob Pike where he discussed getting gophers to burn C++ books. Personally, I realised it was just a joke and he didn't actually endorse the idea of burning any books, let alone C++ ones. My question is - is this sort of joke no longer kosher? Or is it allowed if we can come up with a reasonable explanation like    it’s not C++ itself at fault, but a complicated development process that got out of hand at Google.   I only hope that these efforts to be more inclusive (which are laudable) don't devolve into witch-hunts over jokes. I think in this specific case, the problem is less about the jokes and more about the people who are outraged over them."
golang,3e1urb,nexusbees,-1,Tue Jul 21 11:45:41 2015 UTC,"Was that kind of joke necessary in order to say how Go helped simplify their system designs? I know inflammatory comments get views and stir up controversy, but does that create the right kind of conversation?"
golang,3e1urb,pollodelamuerte,1 point,Tue Jul 21 12:31:12 2015 UTC,"I think you could argue for either perspective - that it was just a joke or that it was an inflammatory comment designed to stir up controversy. I personally think it was the former. I have no problem if you disagree and hold the latter view. However, if someone who thinks in a similar fashion also starts a witch hunt and demands an apology for that comment, it wouldn't be constructive at all.  In this case, its Rob Pike. No one in the Go community is likely to demand anything from him (not even generics). If a lesser figure had said it or something similar (about Java, Ruby etc.) and made someone feel ""unwelcome"" as a result, the response might be different."
golang,3dtw0w,jlaracil,4,Sun Jul 19 12:31:29 2015 UTC,Amazing.
golang,3dtw0w,ericanderton,3,Sun Jul 19 13:46:19 2015 UTC,Super-cool.
golang,3dtw0w,Spirit_of_Stallman,3,Sun Jul 19 13:54:16 2015 UTC,That's awesome! Fascinating view of the Go universe :)
golang,3dtw0w,fr4nk3n,2,Sun Jul 19 15:42:40 2015 UTC,amazing!
golang,3dtw0w,diegobernardes,1 point,Sun Jul 19 15:58:50 2015 UTC,The moment when I noticed my phones accelerometer manipulates the view: ![no edge](https://41.media.tumblr.com/tumblr_mcqfwjq9xi1qdss9uo1_500.jpg)  Really nice. Is there something similar for npm?
golang,3dtw0w,cryp7ix,1 point,Sun Jul 19 22:35:34 2015 UTC,http://anvaka.github.io/pm/#/
golang,3dwz9k,obito02,2,Mon Jul 20 05:50:43 2015 UTC,"The application does not contain any code that copies the server's response to the client.  If you are trying to build a proxy, then I suggest that you use ReverseProxy."
golang,3dwz9k,avrtno,1 point,Mon Jul 20 09:35:54 2015 UTC,"Yep this, and if you need to handle a more than average load on the reverse proxy, consider tweaking the http.Transport member variable MaxIdleConnsPerHost. I think the default is 2 but you can do something like:  http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 50"
golang,3dwz9k,cenuij,1 point,Mon Jul 20 11:52:56 2015 UTC,"Yep this, and if you need to handle a more than average load on the reverse proxy, consider tweaking the http.Transport member variable MaxIdleConnsPerHost. I think the default is 2 but you can do something like:  http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 50   If it is a proxy, but how I can do so that you receive or read the server response sorry I am new to go you would appreciate your help"
golang,3dt1c1,dgryski,2,Sun Jul 19 04:24:15 2015 UTC,"Nice! Good write-up and documentation.  I am not sure I am sold yet. It seems like in your ""typed"" examples the ""roundtripper"" loses its type, and is an interface{} - am I misreading it?  What I like about Daves approach is that if I require a parameter to be an http.Roundtripper that is checked by the compiler. Using you library I have to check it at runtime, which is an unnecessary risk of error."
golang,3dt1c1,klauspost,1 point,Sun Jul 19 09:59:06 2015 UTC,"That's right, but you can add a few lines of boilerplate to get arguments with your own custom type: https://github.com/soheilhy/args/blob/master/example_custom_test.go"
golang,3dt1c1,soheilhy,1 point,Sun Jul 19 14:09:11 2015 UTC,"Yes, I saw the example. What the example doesn't make clear is that you can have the parameter be a specific type. You should probably change the example to:  func RoundTripper(r http.RoundTripper) ServerOpt { return ServerOpt(roundTripper(r)) }  and   rt := roundTripper.Get(opts).(http.RoundTripper)  Now it will be a http.RoundTripper since it is checked by the call to RoundTripper(), and it will be casted to that in the receiver. rt will not be type interface{}, but a http.RoundTripper."
golang,3dt1c1,klauspost,1 point,Sun Jul 19 19:04:08 2015 UTC,"Sure, thanks. that's a very good point. I updated the examples and the docs."
golang,3dt1c1,soheilhy,1 point,Sun Jul 19 19:34:22 2015 UTC,"The get functions should really return (val, bool) so that you can know if the argument was set.  As it is, they return the default for the value, so, for example, you don't know if someone set Port to 0, or didn't set it at all.  [edited to make the return in the correct order]"
golang,3dt1c1,natefinch,1 point,Mon Jul 20 01:04:50 2015 UTC,"I agree, Nate. It was actually the very first version that I wrote. But, after a while I dropped it because I always set the default value. I am still not sure if it's better to have a IsSet() method or change Get() back to (val interface{}, ok bool). What do you think?"
golang,3dt1c1,soheilhy,1 point,Mon Jul 20 03:11:18 2015 UTC,"Discussing this with a few friends, I decided to revert the API to (v, ok)."
golang,3dt1c1,soheilhy,1 point,Mon Jul 20 04:04:03 2015 UTC,"The flag package has an isset method, so maybe that's the best lead to follow."
golang,3dt1c1,natefinch,1 point,Mon Jul 20 11:33:02 2015 UTC,"When building libraries, we usually care most about the end-user client experience. To compare, here are some variants:  Using the most common pattern, just positional arguments:  // In the client provider.MyServer(42, nil, 1 * time.Second)   Or using a configuration struct (lets you omit args):  // In the provider module type ServerOpts struct {     Port int,     RoundTripped http.RoundTripper,     Timeout time.Duration, }  // In the client provider.MyServer(provider.ServerOpts{Port: 42, Timeout: 1 * time.Second})   Finally, compared to the proposed solution:  // In the provider module type ServerOpt args.V  func Port(p int) ServerOpt                       { return ServerOpt(port(p)) } func RoundTripper(r http.RoundTripper) ServerOpt { return ServerOpt(roundTripper(r)) } func Timeout(d time.Duration) ServerOpt          { return ServerOpt(timeout(d)) }  // In the client provider.MyServer(provider.Port(42), provider.Timeout(1 * time.Second))   Side by side, it doesn't seem like a great improvement. A neat syntactic sugar pattern, but feels unnatural for Go. :)"
golang,3dt1c1,shazow,1 point,Mon Jul 20 09:59:31 2015 UTC,"If we have a few options sure, but when you have a handful of them it'll get very messy, especially when you want to have default values and flags.   I've use that mechanism for a few years, and believe me it's not a pleasant experience neither for me nor for the end-user. Consider this as an example:  https://godoc.org/github.com/kandoo/beehive#HiveConfig https://github.com/kandoo/beehive/blob/master/hive.go#L143  Try to explicitly set the listening port, but reuse the default config. :-)   This is what I'm trying to improve and because of that I have created args."
golang,3dt1c1,soheilhy,1 point,Mon Jul 20 13:53:24 2015 UTC,"I've use that mechanism for a few years, and believe me it's not a pleasant experience neither for me nor for the end-user. Consider this as an example:  https://godoc.org/github.com/kandoo/beehive#HiveConfig https://github.com/kandoo/beehive/blob/master/hive.go#L143  Try to explicitly set the listening port, but reuse the default config. :-)    How about copying the default config and overriding the value?  myCfg := beehive.DefaultCfg myCfg.Addr = "":8080""   You could mutate the beehive.DefaultCfg if you wanted, too. Doing a := assignment, since it's not a reference, will assign-by-value. If it were a reference, you'd need to dereference it first. Such as:  myCfg := *foo.DefaultCfgPtr myCfg.overrideWhatever = 42   If you were writing a package which you didn't want to let people to override the package-level default config, you could provide a getter instead, something like:  func DefaultConfig() Config { ... }"
golang,3dt1c1,shazow,1 point,Mon Jul 20 17:46:56 2015 UTC,That's exactly what I've done: https://github.com/kandoo/beehive/blob/master/app_test.go#L121-L124   And I personally prefer the new approach over this older one. Personal taste maybe. :-)
golang,3dt1c1,soheilhy,1 point,Mon Jul 20 21:32:05 2015 UTC,"While I like your idea of having named optional parameters (and the order not being important), I find the resulting code hard to read, but that may just be a personal thing.  In Python, kwargs is a dict. Why not emulate that in Go by making a type Args map[string]interface{} with getters like Args.String(""param"") that return (possibly nil) pointers: http://play.golang.org/p/ZOUfQxnqgs"
golang,3dt1c1,michaelbironneau,1 point,Mon Jul 20 18:46:39 2015 UTC,"There is nothing wrong with that approach, but I personally prefer a config structure (e.g., https://godoc.org/github.com/kandoo/beehive#HiveConfig) over a map mainly because of hardcoded parameter ""name""s. One needs to make sure names are consistent everywhere.  Anyhow, config structures and maps will both get messy when it comes to default values and command-line flags."
golang,3dt1c1,soheilhy,1 point,Mon Jul 20 21:42:13 2015 UTC,"OK you're right, if you're after compile time guarantees a map won't cut it.   You can still merge default values in two structs that are of the same type though, just create one function that does it generically using runtime reflection and reuse that throughout. You still get the compile time guarantee as your code won't compile if your args aren't of the same type as the arg type defined in the function signature, but you essentially get the equivalent of Python's dict.update() when merging configurations."
golang,3dt1c1,michaelbironneau,1 point,Tue Jul 21 09:59:30 2015 UTC,"That's right. I actually used a similar approach, an instance of the config to store the default values: https://godoc.org/github.com/kandoo/beehive#DefaultCfg  But the problem is if I get a 0 value from one of the fields in the configuration struct, is it set by the user to 0? or is it not?  Still really a matter of taste though. :-)"
golang,3dt1c1,soheilhy,1 point,Tue Jul 21 13:40:00 2015 UTC,"Yep, that's very true :).   FWIW another totally different approach (closer to yours maybe?) is what the grpc-go library uses for ServerOption - each argument is a function that operates on a config struct: https://github.com/grpc/grpc-go/blob/master/server.go#L95."
golang,3dt1c1,michaelbironneau,1 point,Tue Jul 21 15:46:57 2015 UTC,"That's right, they use Dave Cheney's functional options that I referred int the post: http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis"
golang,3dr4kh,jbuberel,17,Sat Jul 18 17:30:38 2015 UTC,When is the best time to do a GC? When nobody is looking. Using camera to track eye movement When subject looks away do a GC.
golang,3dr4kh,FUZxxl,1 point,Sat Jul 18 18:40:30 2015 UTC,Is this staying that Go 1.5's collector is actually slower? Or am I crazy?
golang,3dr4kh,plasticmacaroni,3,Mon Jul 20 20:28:04 2015 UTC,"There is no such thing as free GC, and every GC implementation makes trade-offs between total application throughput (the number of operations that can be processed in a time period) and the frequency vs duration of GC pauses.   In the 1.4 and earlier GC implementations, the amount of CPU overhead consumed by the GC between GC pauses was lower, which meant that more of the CPU/cores could be used by your application. But when it came time for the GC pause, the pause time was much higher (multiple seconds).  With the 1.5 GC the team chose to increase the CPU overhead slightly between pauses in order to minimize the pause durations. So in 1.5, depending on the workload, your total throughput may be a few percent lower, but none of those operations will be interrupted by a 5 second GC pause.  Does that make sense?"
golang,3dr4kh,addos,1 point,Tue Jul 21 00:28:43 2015 UTC,"He talked about this during gophercon. As the slides indicate, they are still trying to find the sweet spot.  ""Tune for even lower latency, higher throughput, more predictability/ Find the sweet spot."""
golang,3dqsjy,jbuberel,3,Sat Jul 18 15:40:10 2015 UTC,I just can't wait for them to improve UI packages. Ah the bliss of building one UI for all platforms.
golang,3dqsjy,Artemis311,3,Sat Jul 18 19:02:51 2015 UTC,"I was under the impression it was just GL bindings that were cross-compatible on all platforms (a feat in itself, don't get me wrong), not that it was some kind of UX library.  And not to be pedantic, but we have one UI for all platforms - it's rendered by web browsers :P"
golang,3dqsjy,perihelion9,1 point,Sat Jul 18 20:26:46 2015 UTC,"Well they have a note on the 1.6 slide about UI libraries.   We do, but maybe we can do better than that!"
golang,3dtj4i,gomaniax,2,Sun Jul 19 08:46:01 2015 UTC,My eyes.
