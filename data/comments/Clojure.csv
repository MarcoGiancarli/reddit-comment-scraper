Clojure,3e209g,meatcompute,6,Tue Jul 21 10:04:08 2015 UTC,Are you using Clojure for something beside web and data analysis?
Clojure,3e209g,zarandysofia,8,Tue Jul 21 11:05:13 2015 UTC,I am writing a text editor http://github.com/fromheten/rad
Clojure,3e209g,Hdhdhebgehd,1 point,Tue Jul 21 16:18:24 2015 UTC,So good!
Clojure,3e209g,zarandysofia,2,Tue Jul 21 16:30:45 2015 UTC,"Thank you :). I hope it can be the editor/ide emacs and vim and IntelliJ never could be for me, and endlessly extendible with clojure & immutable design. It's also the first serious clojure project I'm doing, so I'm learning A LOT. Have high hopes"
Clojure,3e209g,Hdhdhebgehd,4,Tue Jul 21 20:53:03 2015 UTC,"We are using core.async channels in a photo processing job pipeline. Download photo, put file path on a channel -> another thread reads file path off channel, does resizing, etc., saves new file, puts file path on another channel -> another thread drops file in s3, puts s3 url on a channel, another thread puts s3 url in db, puts a ""completed"" flag on a channel -> job manager keeps track of completed photos in a batch job. If there are some Cognitect folks in this thread this will sound familiar to some of them :-)"
Clojure,3e209g,clojure_neckbeard,1 point,Tue Jul 21 13:46:41 2015 UTC,This is something very interesting. I am looking in to ways to handle multiple files with core async.
Clojure,3e209g,zarandysofia,4,Tue Jul 21 16:32:28 2015 UTC,Compilers and virtual machines! Okay that's my hobby stuff I'm getting paid to use Hadoop in Clojure :c
Clojure,3e209g,Arrdem,1 point,Tue Jul 21 17:57:21 2015 UTC,I want your job :)
Clojure,3e209g,phughk,1 point,Wed Jul 22 00:22:28 2015 UTC,Not Spark yet? Spark seems a more natural fit for Clojure....
Clojure,3e209g,mikera,3,Wed Jul 22 09:04:59 2015 UTC,I'm using it for games: https://github.com/orionsbelt-battlegrounds/obb-rules But the interface will probably be web-based.
Clojure,3e209g,donbonifacio,2,Tue Jul 21 11:32:02 2015 UTC,Cool
Clojure,3e209g,zarandysofia,1 point,Tue Jul 21 11:42:29 2015 UTC,I too am making games! It aI too am making games! It a wonder compared to what I used to be doing which was game dev in Scala.
Clojure,3e209g,reutermj,1 point,Wed Jul 22 00:44:30 2015 UTC,Continuous integration / testing / regression server.
Clojure,3e209g,613style,1 point,Tue Jul 21 16:21:57 2015 UTC,Hope I can use that one day.
Clojure,3e209g,zarandysofia,5,Tue Jul 21 16:33:03 2015 UTC,"I'm running through the Om tutorials and finding it very confusing. For example, this function that updates the Class table of a database:  (defn update-class [id params]   (let [db    (d/db conn)         title (:class/title params)         eid   (ffirst                 (d/q '[:find ?class                        :in $ ?id                        :where                         [?class :class/id ?id]]                   db id))]     (d/transact conn [[:db/add eid :class/title title]])   I'm used to working in Rails, where a similar function would be   Class.find(params[:class][:id]).update_attribute(:title, params[:class][:title])   This seems a lot more complicated and I can't wrap my head around it.   What's the difference between '[] and [] ? Is ?class and ?id some special syntax? Stack says that vars in Clojure can begin with ? and it doesn't mean anything, but ?class and ?id aren't declared in the let statement, so what are they? What does the $ in :in $ ?id do?"
Clojure,3e209g,FeloniousMonk119,3,Tue Jul 21 13:11:12 2015 UTC,"The '[] syntax ('quote') means that everything inside that vector is not going to be evaluated and is instead taken at literal value, i.e. both?class and ?id are used as symbols inside the d/q function, which I assume does some template substitution.  You use the same quote syntax when doing (use 'mynamespace) from the REPL, because at that time mynamespace does not refer to anything, it's just a name."
Clojure,3e209g,lshevtsov,2,Tue Jul 21 13:41:11 2015 UTC,"So I'm not really passing a vector to d/q, I'm giving it a string that describes a vector that the database knows how to evaluate.  How does this relate to list syntax, where (foo bar baz) is a function call but '(foo bar baz) is an ordered list?"
Clojure,3e209g,FeloniousMonk119,4,Tue Jul 21 14:29:51 2015 UTC,"Not quite. The '[] is not a string. It's still a vector literal. However normally when Clojure reads a vector literal it attempts to interpret all of the elements. For example if you had:  (def foo 1) (def bar 2)   Then [foo bar 3] would evaluate to the vector [1 2 3]. If, instead, you wanted to keep the symbols in an un-evaluated state, then you would need to use '[foo bar 3].  In this case, you need to give Datomic the quoted vector because the ?class and ?id vars are placeholders that will be used by datalog.  If you did [:find ?class ...] instead, you'd get an error because Clojure would attempt to lookup and evaluate ?class, but ?class isn't defined in the context of the function."
Clojure,3e209g,jballanc,2,Tue Jul 21 14:59:19 2015 UTC,The Om tutorial uses datomic that uses datalogic as its query language (tutorial)
Clojure,3e209g,cairdazar,1 point,Tue Jul 21 13:41:09 2015 UTC,"Most of the ""complicated"" stuff you see here is specific to Datomic, a store of related ""facts"" (datoms) called entities. Many of your questions can be answered by going through the Datomic tutorials.  I've been using datomic in production for more than a year now, so if you have additional questions please feel free to reply."
Clojure,3e209g,clojure_neckbeard,2,Tue Jul 21 13:38:38 2015 UTC,What is the recommended database store to use with datomic?
Clojure,3e209g,spoofedexistence,1 point,Tue Jul 21 15:13:37 2015 UTC,"It depends on your infrastructure and how ""big"" your data is I'd say. If you're on AWS and need scale and performance, go with Dynamo. Datomics data cache cuts down on your reads, which help keep costs down while giving you great performance. Other than that, I would imagine MySQL or Postgres are good for a backend as well, but I'd imagine large volumes of data are going to eventually lead to some read latency issues. Datomic may handle table partitioning, so it never gets too unweildy, but I have no knowledge or experience there."
Clojure,3e209g,clojure_neckbeard,1 point,Tue Jul 21 15:45:14 2015 UTC,Last I heard Cognitect was recommending Cassandra.
Clojure,3e209g,weavejester,1 point,Tue Jul 21 20:19:21 2015 UTC,If you want something that's a little closer to what you are used to with ActiveRecord you might be interested in http://sqlkorma.com/
Clojure,3e209g,lgastako,4,Wed Jul 22 01:00:52 2015 UTC,Where could I find a place that solves logic puzzles using clojure.
Clojure,3e209g,worthless-trash,3,Tue Jul 21 12:06:55 2015 UTC,I pretty much grab some old book with good exercises in another language I try to came with solution in Clojure.
Clojure,3e209g,zarandysofia,2,Tue Jul 21 16:42:51 2015 UTC,codewars.com has clojure support and has plenty of interesting problems to solve.
Clojure,3e209g,clojure_neckbeard,2,Tue Jul 21 13:31:54 2015 UTC,hackerrank.com has Clojure support.
Clojure,3e209g,stardotstarmv,3,Tue Jul 21 17:39:04 2015 UTC,"Can you recommend me an open source project written in Clojure, such that: - I can learn by reading the source code (focus on idiomaticity) - Solves a real life problem - Simple and friendly enough to accept contributions - Bonus: uses some core libraries like core.async"
Clojure,3e209g,bagofthoughts,4,Tue Jul 21 17:50:56 2015 UTC,"Cryogen is a nice project that's not too complex, idiomatic, and does something useful."
Clojure,3e209g,yogthos,1 point,Wed Jul 22 03:54:24 2015 UTC,Thank you. Will check this out too.
Clojure,3e209g,bagofthoughts,3,Wed Jul 22 06:07:34 2015 UTC,"I'm biased in that I know the maintainer, but the clj-rethinkdb project might fit that bill."
Clojure,3e209g,Arrdem,1 point,Tue Jul 21 17:58:45 2015 UTC,Thanks! Will check it out.
Clojure,3e209g,bagofthoughts,4,Wed Jul 22 03:43:16 2015 UTC,How should handle errors?
Clojure,3e209g,kcuf,2,Wed Jul 22 01:59:42 2015 UTC,"struct maps, records, types: when to use what?"
Clojure,3e209g,quantumbyte,1 point,Wed Jul 22 10:05:45 2015 UTC,"Is there a way of saving and reloading the state of a persistent collection? If I'm implementing a web UI with undo & redo functionality, how can I make so the user can completely reload the page and have their full list of previous edits?"
Clojure,3e209g,reidiculous,2,Tue Jul 21 15:44:59 2015 UTC,You just conj each new state into a history vector. The structural sharing won't make it to the serialization and would result in a huge state vector so keep that in mind.
Clojure,3e209g,AndreRauh_,1 point,Tue Jul 21 17:46:49 2015 UTC,Do you know of a example given this?
Clojure,3e209g,zarandysofia,4,Tue Jul 21 18:20:14 2015 UTC,"Here's a basic example. If you represent your app state as an atom containing a map and your history as an atom containing a vector, then you just need to push the new state onto the vector with conj anytime your state changes as shown by this refheap: https://www.refheap.com/106792  For a more complete example, and to see how you could only save a part of the app-state, here's how its done in Goya, a pixel editor written in Om: https://github.com/jackschaedler/goya/blob/master/src/cljs/goya/timemachine.cljs  As long as you build up your history like this in memory with 'changes' to a persistent data structure, you will be leveraging structural sharing and it will be efficient in terms of space, but if you naively serialize all those vectors to a string (to store in local storage for example) and read them back, the new vectors won't share structure so it won't be efficient. If you did want to support that you would need to do some sort of event sourcing where you store the operations that updated the state, serialize those, and then re-build your history yourself when you deserialize them from local storage."
Clojure,3e209g,blazinglambda,2,Tue Jul 21 19:10:40 2015 UTC,"Also keep in mind that if you want a FULL list of edits then you'll have to create a history tree since  I list can't hold an ""undo and then new edit"" which results in a tree like data structure."
Clojure,3e209g,AndreRauh_,1 point,Tue Jul 21 19:24:13 2015 UTC,"You can serialize a collection as a string with something like (pr-str {:hello 1}) and then convert that string back to a collection with (read-string my-str). You should use the read-string from clojure.edn as it is safer:  (require 'clojure.edn) (def my-str (pr-str {:hello 1})) (clojure.edn/read-string my-str) ; {:hello 1}   Beyond that, you can get it to persist by saving and reading the string using the local storage API."
Clojure,3e209g,oakes,1 point,Tue Jul 21 16:48:39 2015 UTC,"Ok, it sounds like I would need to keep track of the edit stack myself. I was hoping there'd be a way to use the internal tree structure of the persistent collection to do this automatically, but that make sense."
Clojure,3e209g,reidiculous,1 point,Tue Jul 21 17:10:20 2015 UTC,"Is this the best way to drop the first n characters from a string?  (apply str (drop n my-string))   When my-string is very large, it seems intuitively like a slow way to do it, but I don't have any idea how these things actually work."
Clojure,3e209g,613style,5,Tue Jul 21 16:25:33 2015 UTC,"You can use subs:  (subs ""Hello"" 1) ; ""ello"""
Clojure,3e209g,oakes,1 point,Tue Jul 21 16:39:50 2015 UTC,"Much better, thanks!"
Clojure,3e209g,613style,3,Tue Jul 21 17:18:12 2015 UTC,"Bonus: If you want to drop a specific character (given the index) from a string:  (let [i 1       s ""Hello""]    (str (subs s 0 i) (subs s (inc i))) ; ""Hllo"""
Clojure,3e209g,zarandysofia,1 point,Tue Jul 21 18:06:57 2015 UTC,"Looking for a way to create permutations/combinations. Specifically i want (a b c) -> ((a)(b)(c)(a a)(a b)(b a)(b b) (a c) (c a) (c b) (b c) (c c) (a b c) (a c b) (b a c) (b c a) ... into infinity. Its all combinations of objects in any orientation with any number of objects in a lazy stream. Any tools to do this or to use as a jumping off point?  P.s. forgive me if i missed some orientations, im on my phone.  Edit: I suppose its just permutation for each element of the power set."
Clojure,3e209g,Cid-highwind,3,Tue Jul 21 23:34:50 2015 UTC,Solved!  (require '[clojure.math.combinatorics :as combo]) (use 'clojure.pprint)  (pprint (map combo/permutations (combo/subsets [1 2 3])))
Clojure,3e11ox,edwastone,4,Tue Jul 21 03:22:18 2015 UTC,"There are some good projects in the numerical library space that you could look at, e.g.:   core.matrix (pretty active, quite a few open issues or chances to contribute) Incanter (very interesting project, could do with some focused work to help get to version 2.0)"
Clojure,3e11ox,mikera,1 point,Tue Jul 21 04:54:48 2015 UTC,Thanks mikera. That's just nice because of my experience with similar python libraries.
Clojure,3e11ox,niwibe,1 point,Tue Jul 21 05:18:07 2015 UTC,We have few libraries in Clojure & ClojureScript at funcool organization (https://github.com/funcool) ;)
Clojure,3e11ox,zarandysofia,1 point,Tue Jul 21 07:54:38 2015 UTC,There is the project called Pepa and this video that show how is the architecture layout. I think is well written.
Clojure,3e11ox,scttnlsn,1 point,Tue Jul 21 18:29:53 2015 UTC,I learned a lot about ClojureScript from reading through the CircleCI frontend: https://github.com/circleci/frontend  Not sure if they take contributions from the public.
Clojure,3e0lt7,redmorph,2,Tue Jul 21 01:10:20 2015 UTC,"You might take advantage of the fact that disjoin works even if you give it a key that isn't present in the collection:  (defn overlaps?   [s x]   (if (seq (set/intersection x s)) true false))  (defn union-or-add-set   [sets s]   (let [found (or (some #(and (overlaps? s %) %) sets) #{})]     (conj (disj sets found)           (set/union found s))))   Edit:  Sorry, we can clean the above up to just:  (defn overlaps?   [s x]   (if (seq (set/intersection x s)) true false))  (defn union-or-add-set   [sets s]   (let [found (some #(and (overlaps? s %) %) sets)]     (conj (disj sets found)           (set/union found s))))   (set/union x nil) -> x (disj x nil) -> x"
Clojure,3e0lt7,macnube,4,Tue Jul 21 03:49:56 2015 UTC,(if (seq (set/intersection x s)) true false))   should be  (seq (set/intersection x s))
Clojure,3e0lt7,satanclau5,1 point,Tue Jul 21 07:36:12 2015 UTC,"Functions ending with ? return boolean values, by convention. The suggested change works just fine in the code above, but be aware that overlaps? now returns either a sequence or nil."
Clojure,3e0lt7,macnube,1 point,Wed Jul 22 04:31:45 2015 UTC,"Indeed. If you actually want to coerce to a boolean, you can do it with the boolean function in core. Basically it's like the !! idiom in other languages, i.e.:  (-> x (set/intersection s) seq boolean)"
Clojure,3e0lt7,ljsc,2,Wed Jul 22 11:19:53 2015 UTC,"If you don't need a set you can also get the result as a (lazy) seq:  (defn foo [sets s]   (->>     (concat sets [::end]) ; add a sentinel value so that we know we've hit the end of the collection     (reductions (fn [[result-set found] candidate-set]                   (cond                     (= candidate-set ::end) (when-not found [s]) ; if we've reached the end add s if it hasn't been found                     found [candidate-set found] ; if s has been found then nothing more to do                     (empty? (filter candidate-set s)) [candidate-set false] ; didn't find s, keep looking                     :else [(into candidate-set s) true])) ; found s, return the union                 nil)     (filter identity) ; discard nils     (map first))) ; discard the temporary data  (foo #{#{1 2 3} #{4 5 6} #{7 8 9}} #{0})   ; => (#{4 6 5} #{7 9 8} #{1 3 2} #{0}) (foo #{#{1 2 3} #{4 5 6} #{7 8 9}} #{0 1}) ; => (#{4 6 5} #{7 9 8} #{0 1 3 2})"
Clojure,3e0lt7,CurtainDog,1 point,Tue Jul 21 13:23:01 2015 UTC,Upvoted for reductions.  I never quite know when to reach for that one from the toolbox.
Clojure,3e0lt7,lgstein,2,Tue Jul 21 13:45:26 2015 UTC,"There is no need for using intersection, which is eager to check whether there is just a single element.  (defn union-or-add-set   [sets s]   (let [found (->> (filter #(any? % s) sets) first)]     ...   You might want to optimize the filter predicat pick the smaller set as collection arg.  (defn overlap?   [s1 s2]   (apply any? (if (> (count s1) (count s2))                  [s1 s2]                   [s2 s1]))"
Clojure,3e0lt7,bY3hXA08,1 point,Tue Jul 21 23:06:42 2015 UTC,i'm a novice so your solution looks alright to me. hopefully a more experienced clojurian will be able to enlighten. fyi there are shorter macros like when-not and not-empty you could use.   here's an alternate solution using loops:  (defn union-or-add-set   [sets s]   (loop [checked   #{}          unchecked (vec sets)]     (let [[head & tail] unchecked]       (cond         (nil? head)                 (conj sets s)         (not-empty          (set/intersection head s)) (into (conj checked (set/union head s))                                            tail)          :else                       (recur (conj checked head) tail)))))   good luck.
Clojure,3e0lt7,mikera,1 point,Tue Jul 21 03:26:53 2015 UTC,"Do you know anything about the type of the ""sets"" parameter? Is it known to be a vector of sets, for example?  If so you could find the numeric index of the set position you want to add to, and do something like:  (defn index-of [pred coll]      (let [c (count coll)]        (loop [i 0]          (when (< i c)            (if (pred (nth coll i)) i (recur (inc i)))))))  (defn union-or-add-set   ""If S overlaps with any set in SETS, add it that set (the first set found) else add S to SETS.""   [sets s]   (let [i (index-of  #(not (empty? (set/intersection % s))) sets)]     (if i       (update sets i set/union s)       (conj sets s))))"
Clojure,3e0lt7,mikera,3,Tue Jul 21 01:58:16 2015 UTC,In my case the SETS container is also a set.  It's my understanding that looking for index of things is rarely idiomatic in clojure.  Do I have that wrong?
Clojure,3dybij,reallylargehead,3,Mon Jul 20 15:07:26 2015 UTC,"If you have side effects, you might want to factor them out, so that you can mock them up. Eg, if you have a coupling to a db, db connection or file system, parametrise it, so that you can supply a mock implementation, which you can test.   Edit: The above isn't very Clojure-specific, and I haven't got much Clojure experience in this regard, but I believe that there are Clojure tools for these kinds of things like bindings and protocols. I do have experience mocking up a Datomic database, but that was as easy as supplying a list of tuples instead of the real db! :-)  Edit2: About all that optional argument-stuff (or rather, more arguments, if you're factoring out stuff), that is exactly what bindings are supposed to avoid, as I understand it."
Clojure,3dybij,grav,1 point,Mon Jul 20 17:27:47 2015 UTC,"We've had a lot success in unit testing by pulling apart components through its channels. If you write your code by passing around and returning channels, you can easily test segments of the code by pushing messages onto input channels and expecting messages out.  Though I can't say I've ever used RabbitMQ, we did build the clj-zmq library. We often would build test harnesses that would allow us to push messages into a service and dynamically route it to back to the harness. Same idea, test the ins and outs.  At a grander scale, you can attempt the end-to-end test. These are difficult to build (and maintain). It's truly an organizational shift to keep these things in alive. Despite this, they are really what give you confidence in what you've built. Especially if you can use your testing framework as a middleman. Use your testing framework as a proxy for messages, apply your assertions, and send the messages to its intended target.  Depending on the service, this can sometimes mean building things like DSLs in order to be able to simulate (via configuration, or whatever it might be) to get tests to exhaust potential simulations. They can be expensive but ultimately they are likely cheaper than their manual counterparts."
Clojure,3dybij,ianbishop,1 point,Tue Jul 21 02:40:02 2015 UTC,"One way you might think about he problem is ""I want to test that this function ultimately sends something to rabbit"". If ""sends something to rabbit"" can be wrapped in a clojure function, then you can mock it to mutate an atom, and then base your test around that atom being mutated."
Clojure,3dwik6,bY3hXA08,3,Mon Jul 20 03:00:17 2015 UTC,"Personally I learned a lot from this new set of videos by cognitect's Timothy Baldridge, whether it be directly related to core.async or other features of the clojure language itself. For some reason it seems to be obscured from public news- I came across it by accident when perusing safari. But I could be very wrong and living under a rock. Nevertheless I hope people who haven't seen it will enjoy.  TL;DR: good new(?) videos on core.async by tim baldridge"
Clojure,3dwik6,misterswing,2,Mon Jul 20 03:10:34 2015 UTC,"If anyone's tempted, the package is 50% off with code CFSCON5 until 25 July."
Clojure,3dwik6,salaperuna,1 point,Mon Jul 20 17:31:57 2015 UTC,Are they free if you create an account?
Clojure,3dwik6,agumonkey,2,Mon Jul 20 05:11:00 2015 UTC,"unfortunately no. you need a safaribooksonline subscription, or get it ala carte for $40 here http://shop.oreilly.com/product/0636920041474.do"
Clojure,3dwik6,fabrizioc2,2,Mon Jul 20 06:43:53 2015 UTC,"Oh we can peek at the first 30 seconds.   In the mean time, T. Baldridge talks on AST https://www.youtube.com/watch?v=KhRQmT22SSg"
Clojure,3dwyup,Schtauffen,2,Mon Jul 20 05:45:39 2015 UTC,"May be it is not related, but in my opinion if you want to build isomorphic web apps you should use right tools. Take a look at catberry.js: https://github.com/catberry/catberry . It also have Flux architecture and build with isomorphity in mind, to compare with React.   You should also know that CLJS land have a few good React wrappers, that very different from Om: for example Reagent, Rum."
Clojure,3dwyup,zarkone,1 point,Mon Jul 20 08:58:04 2015 UTC,"React is a strong point of the whole setup, IMO, so catberry might not be for me but I'll definitely check it out.  Thank you for letting me know about Reagent and Rum, I will check them out as well!"
Clojure,3dwyup,blazinglambda,1 point,Mon Jul 20 13:24:33 2015 UTC,"I would highly recommend using JVM Clojure instead of Node for your backend server if you are developing your frontend in ClojureScript. You will already be using the Clojure development tools to compile ClojureScript and Clojure supports sharing code between cljs and clj out of the box in Clojure 1.7. That will also give you more flexibility on the server side since you will have access to threads and Clojure's library ecosystem.  When you say ""isomorphic Om"" I believe you mean pre-rendering your UI using react on the server. I don't have any experience with this myself, but I think in an ideal world you would be able to do that in a thread inside your JVM process using Java's Nashorn JavaScript engine and not have to rely on external processes.  Good luck and have fun learning Clojure!"
Clojure,3dquov,laforge49,8,Sat Jul 18 16:01:29 2015 UTC,"There are so many things you'll find pointless after programming with Clojure for a while:   JavaBeans with lots of autogenerated getters/setters/equals/toString, even with the help of tools such as Lombok. Data is just data, and Clojure data abstractions are awesome. Pass vectors, sets or maps around and you'll be fine Lots of interfaces and ""classes which encapsulate business logic"" Maven madness. Leiningen is great and I've seen praise to Boot as well. For many of the libraries you might use from Java there are idiomatic wrappers to use which fit Clojure better   One thing which is sometimes confusing to newcomers is that there are no big ""frameworks"" to develop applications (as in ""Rails"" or ""Spring MVC"") but libraries which are more decoupled which people aggregate based on the problem they're trying to solve. Even LuminusWeb.net which looks like a framework is more of curated selection of libraries."
Clojure,3dquov,eccp,1 point,Sat Jul 18 19:56:23 2015 UTC,"I must say, it sure looks a lot easier to publish something with Lean than to publish to the maven Central Repository!"
Clojure,3dquov,ajoberstar,1 point,Sat Jul 18 21:23:28 2015 UTC,That seems like a mismatched comparison. Publishing to Clojars is easier than Maven Central is easier because the requirements of Maven Central are more strict. That doesn't have anything to do with the tools. Publishing to an arbitrary Maven repo with Lein or Maven should be comparable in difficulty.
Clojure,3dquov,613style,5,Sun Jul 19 22:25:04 2015 UTC,"I saw someone say once that calling Java from Clojure is easier than calling Java from Java.  On the other hand, if I'm having trouble maintaining code that I wrote, I have to consider the uncomfortable idea that it's my fault for writing it that way, not the language's."
Clojure,3dquov,zarandysofia,3,Sat Jul 18 18:27:40 2015 UTC,"I've spent years working on simple ideas and end up with something that is big and clumsy. And rewriting does not help.  I've started implementing some of my ideas in Clojure and it seems to have shrunk by orders of magnitude. Which is why I say there may be something here that I like. Only been at this for a week now, so I am not at all sure.  But the language seems to allow some elegance. Which is a far cry from what you can do with Java."
Clojure,3dquov,remko,1 point,Sat Jul 18 18:38:12 2015 UTC,But the language seems to allow some elegance. Which is a far cry from what you can do with Java.   Could you elaborate in this?
Clojure,3dquov,skinney,2,Sat Jul 18 22:09:23 2015 UTC,"Not easy to do as a Closure novice, but I can at least relate the project I just worked on.  I've developed a robust framework in Java for actors using 2-way messaging http://www.agilewiki.org/projects/JActor2/index.html and as both a learning tool and a motivational device I decided to work on converting it to Clojure. After some study (a day, which is a long time seeing how I've only been looking at Closure for a week), I decided to build on Clojure core's agents.  For a first draft, I abandoned robustness and indeed any form of exception handling or performance considerations. The result was a set of code short enough to reasonably pass in an email: https://groups.google.com/forum/?hl=en#!topic/agilewikidevelopers/PCXdMm65mmE  In Java, this code would likely span multiple files and it would be difficult to rework when adding the additional features. The Clojure code is harder to read, but seems to be much easier to refactor--something I will need to do a lot of since there are so many features that are missing.  What I like is that there just is not that much code to read. And I do spend a lot of time reading code when I am working with it. I also did not feel like I was having to force the code to do unnatural acts, as nothing I did seemed to be that out of place for Clojure.  I do miss objects. But I found that dynamic vars were much more suitable to what I was doing than member variables. Mind, Java has all the equivalents. There is nothing (except maybe agents) that Clojure is providing that Java does not provide ample support for. But it just all seems to go together that much more smoothly than the Java code. And I've been programming in Java since they invented applets."
Clojure,3dquov,remko,4,Sat Jul 18 22:45:46 2015 UTC,"Glad you like Clojure. Don't take this rant personal, it's not directed at you, you just caught me at a time I wanted to vent ;-)  I'm not really sure if huge projects can become manageable by writing them in a different language, even concise ones like Clojure. You can get constant factor reductions at best, which I don't think solves the maintainability problem. To manage large projects, you need to structure your code in ways that make it manageable.  Personally, I think Clojure has inherited all the 'bad' boilerplate of Java (the heavy tooling and project setup, e.g. not being able to create a simple project by just hand-writing an .rb and a Gemfile, or a .js and a package.json, but need a script to generate a bunch of files in a bunch of places someone thinks is a good idea Update: It seems you can do this with Lein too; that just leaves the 'heavy' part where lein takes so long to run a simple script), and dropped all the 'good' boilerplate of Java (static types that give you a safety net for working in large projects, enable easy and safe refactoring, ...). Sure, recent languages (like Go, Swift, and even C++) have proven that you can do much better static typing than Java with less code overhead, but getting rid of the types is a bridge too far. The only result for me is that most of the mistakes I make, despite heavy unit testing, could have been avoided in a language that would come with types, which is something I really dislike in critical projects.  So for me, that makes Clojure unsuitable for small projects and large projects, which is unfortunate, because I really like the language. I guess I'm just the proverbial developer who likes to have a beer during lunch :)  Final notes: immutability is awesome, but I use most of that in other languages anyway; may not have been in there by design like in Clojure, but you don't really need language support for that. And I have to admit I have been lucky enough to never have to expose multi-threadedness outside of small modules in a large projects. I can see that if you're in this horrible situation where threads really must trickle through to your whole codebase, Clojure's model sounds appealing. But again, I would hope to be able to get something in a statically typed language if i really wanted to, but I may be wrong."
Clojure,3dquov,nzlemming,4,Sat Jul 18 18:00:37 2015 UTC,"The problem with Java is ""death by specificity"". That is, due to the static types, the tendency to tightly couple and specify things that actually doesn't need to be specified. In Clojure, avoiding tight coupling is a lot easier (though not automatic, you still have to know what you're doing).  Using a tool like component is really good for structuring your app in Clojure, and I really hate that a lot of languages doesn't have this.  I don't really understand your beef with project management. There are four required entries for your standard project.clj: name, version, source path and dependencies. The only difference from package.json files is that you specify a source-path (although, the default is 'src' so you don't actually have to specify it). There isn't any generation of files happening (where do you get this from?) and lein doesn't really do any more magic than Ruby Gems, which downloads dependencies and adjusts the classpath (import path in ruby). It does A LOT less magic than e.g. Rails. Your minimal Clojure project is a folder with a project.clj/build.boot file, and a 'src' folder containing a .clj file. Actually, if you don't need anything more than Java and Clojure's standard library, your minimal project is a single .clj file and the clojure.jar.  Regarding refactoring, in my experience it isn't static types that enable easy refactoring, but static structure. Clojure has static structure, and due to its homoiconic nature, parsing Clojure is very easy. You're mostly doing functional calls in Clojure, and functions (its arities) and namespaces are static. Things like global-rename, export function, generate stubs from protocol and 'safe-delete' should be just as easy to do in Clojure as they are in other languages (I don't use refactoring tools often, in any language, so I don't know how far clj-refactor or Cursive have gotten in this area).  Regarding safety, I've never really had big problems with that. I've worked in Ruby and JS shops, and a ""type"" error has never crept into production. The things that do creep into production are the same things that get you in C++, Java or C#. Interestingly enough, my most stable programs are written in Clojure. Which is probably one of the reasons Netflix and Walmart use Clojure at scale.  Regarding your final notes: immutability, while crucial to Clojure's concurrency model, isn't what makes working with concurrency easy in Clojure. Immutability does prevent a whole host of bugs, and makes your program easier to reason about, even before concurrency is involved. What makes Clojure a great language for concurrency though, are the concurrency primitives (future, stm) and state management references (var, atom, agents and refs)."
Clojure,3dquov,remko,5,Sun Jul 19 07:05:41 2015 UTC,"I don't really understand your beef with project management.   You're right, I was unrightfully annoyed there. You can get by with a minimal project.clj, thanks for setting me straight on that.   Regarding refactoring, in my experience it isn't static types that enable easy refactoring   Interesting. Can you easily change variable, function and module names from within an IDE in Clojure with a single click? Can you easily swap parameters / add a parameter in a function with an IDE and be sure you updated all the usages? (advantage for statically typed languages is that you don't need refactoring support, it just breaks your compilation). I was under the impression that you can't do these things, but I could be wrong.   Regarding safety, I've never really had big problems with that.    Weird, I have problems with this all the time. I do a small change to e.g. a function signature, and it breaks in places that a compiler could have caught.    immutability isn't what makes working with concurrency easy in Clojure What makes Clojure a great language for concurrency though, are the concurrency primitives   Right, that's what I meant. I was actually talking about 2 different positive aspects of Clojure that I saw the value of, but it was confusing of me to put them in the same note."
Clojure,3dquov,skinney,4,Sun Jul 19 10:03:26 2015 UTC,"Hi, I develop Cursive.   Can you easily change variable, function and module names from within an IDE in Clojure with a single click?   Yes, Cursive allows you to do this. It also provides decent refactoring support for Clojure code using keywords, which is very common. For example, you can rename a keyword and it will let you choose which instances of that keyword you want to rename, and it will also rename variables destructured from that keyword.   Can you easily swap parameters / add a parameter in a function with an IDE and be sure you updated all the usages?   Cursive doesn't allow this yet, but that's just because I haven't gotten around to it yet - it will do. There are cases that this will not be able to handle, for example putting a function with a particular signature into a map - you can't reliably find usages of something like that. But these refactorings are surprisingly useful. Idiomatic Clojure code is quite regular.  Cursive still has a long way to go, in particular moving things around is not supported as well as I'd like. That's just a question of it getting enough of my time, though, not any fundamental limitation.   I do a small change to e.g. a function signature, and it breaks in places that a compiler could have caught.    Cursive does mark arity errors in real time in the editor, which is amazingly useful for catching these errors while refactoring. It still misses a couple of cases (loop/recur and local fns) but again, it catches 95%* of cases.  (* Warning: totally made up statistic)"
Clojure,3dquov,nzlemming,1 point,Sun Jul 19 18:44:34 2015 UTC,"Thanks a lot for clearing this up!  My beef with dynamic languages is mostly coming from experience with (many) other dynamic languages than Clojure. Given your comments, maybe I wouldn't be that bothered with large production Clojure codebases. I hope i'll find out one day :-)"
Clojure,3dquov,skinney,2,Mon Jul 20 07:31:54 2015 UTC,"Interesting. Can you easily change variable, function and module names from within an IDE in Clojure with a single click? Can you easily swap parameters / add a parameter in a function with an IDE and be sure you updated all the usages? (advantage for statically typed languages is that you don't need refactoring support, it just breaks your compilation). I was under the impression that you can't do these things, but I could be wrong.   I don't use an IDE so I don't know, but just like with Java, this is static information, so it should be easier to add support for than most other dynamic languages out there. There is a new project for emacs that looks promising (clojure-refactor) and I would assume Cursive has good refactoring.   Weird, I have problems with this all the time. I do a small change to e.g. a function signature, and it breaks in places that a compiler could have caught.   The Clojure compiler should catch arity problems (giving two arguments to a three argument function), use of private symbols and using symbols that don't exist. ClojureScript will give you warnings, but will still compile. These are my most frequent problems in JS, but your milage may vary.  Of course, someone prefers a good type system (which is why core.typed exist) and it can catch bugs which a dynamic language can't catch. But like I said, I've never had problems with type errors in production, and a type system can make it easier to tightly couple things (Go has done this right IMHO, with type inference and duck typed interfaces)."
Clojure,3dquov,rainbowwow,1 point,Sun Jul 19 12:15:00 2015 UTC,"The Clojure compiler should catch arity problems (giving two arguments to a three argument function)   Unfortunately, and somewhat surprisingly, it doesn't - these errors are only caught at runtime. I believe CLJS does since it's essentially an AOT compiler."
Clojure,3dquov,Scriptorius,1 point,Sun Jul 19 18:46:11 2015 UTC,"Hmm. You're right. Use of functions/variables that hasn't been defined (typos) are caught, but not arity errors. I AOT production code however, which is probably why I catch errors like that before they hit production."
Clojure,3dquov,remko,1 point,Sun Jul 19 21:16:13 2015 UTC,lein check
Clojure,3dquov,ianhedoesit,3,Mon Jul 20 16:35:04 2015 UTC,"The benefit with having a single .rb/.js/.c file and just pointing a compiler/interpreter at it is that I know exactly what's going on. Then, as the build process gets complex, I can understand what each added layer of complexity does and what problem it solves.  Like you say, with Lein I'm just thrown into this directory structure. Namespaces, classpaths and import paths, source paths, profiles...these are all thrown at me at once. One the one hand, Lein seems to take care of it all for you and getting a basic workflow set up isn't hard. On the other hand, it feels like there is a ton of black magic going on just under the hood. I can't begin from a simple compiler+file model and then incrementally increase my understanding of the build process. I have to take the whole monolithic build process and take it apart to understand how it works.  My complaints are kind of wishy washy, and honestly for the most part it's not a huge issue. I'm just annoyed that I don't have a thorough understanding yet of such a major part of my workflow."
Clojure,3dquov,yogthos,2,Sat Jul 18 18:16:00 2015 UTC,"Really, I started off the beginning of the week with Intellij and the La Cursive plugin. Everything was fine and simple.  Last night I started reading up on Lein and frankly it looks ever so much nicer than dealing with Maven. There is just so much magic in Maven pom files!"
Clojure,3dquov,joequin,1 point,Sat Jul 18 18:49:01 2015 UTC,"Understood. But I think what Scriptorius is saying is that, although lein hides a lot of magic, the magic is still there, you just don't have to deal with it (yet). Sooner or later (and often at a time where you really don't want to deal with it), the nice interface will start to leak though, and you'll have to learn the magic anyway. Like Scriptorius, I'm also of the type that likes to start simple and add complexity layers in my software/tools because I understand I need them, not having to figure it out at some random point."
Clojure,3dquov,yogthos,2,Sat Jul 18 19:14:19 2015 UTC,"It sounds like a couple people so far are looking for something like Boot instead of Lein. Perhaps you would enjoy it if you aren't fond of how Lein deals with Clojure projects. It allows much more control and you get to add complexity as you need. I'm not very good with it, but as far as I understand, you can even build a project in a REPL step by step."
Clojure,3dquov,yogthos,1 point,Sun Jul 19 22:22:16 2015 UTC,"I remember the Forth language fondly, though it always felt a bit like a kluge. A simple language that was comprehensive enough to include durability.  As for types, yeah. I do not normally leave home without them. And I find it hard to reason about code if I do not know the expected forms of the parameters!"
Clojure,3dquov,joequin,3,Sat Jul 18 18:41:48 2015 UTC,One thing I recommend is using destructuring in function parameters. This way you can quickly tell what the shape of the data that a function expects is.
Clojure,3dquov,yogthos,1 point,Sun Jul 19 13:19:41 2015 UTC,Sounds helpful. I'll keep it in mind. Thanks.
Clojure,3dquov,joequin,1 point,Sun Jul 19 16:31:24 2015 UTC,"There are some things you'll miss. You'll miss major classes with dependency injection. Your alternatives will be passing dependencies with every function call, globals, or the library called component. Component is good, but eventually this problem and a dislike of dynamic typing made me switch to scala.   But that's just my experience and depending on what you're doing, I think clojure is a legitimately good language."
Clojure,3dquov,yogthos,6,Sun Jul 19 03:07:59 2015 UTC,"I've been developing Clojure for about 5 years now and I haven't missed either in the slightest. I think Component works great and passing things explicitly tends to make code more clear in my experience.  As far as Scala goes, I found that the sheer complexity of the language outweighed any potential benefits for me. While you can restrict yourself to a small subset for your own code, it's simply not a practical solution in general. As soon as you start working on larger projects or using libraries you quickly see every part of the language used in creative ways."
Clojure,3dquov,joequin,2,Sun Jul 19 04:25:53 2015 UTC,"I was always surprised at how much stuff they put into what look like low-level things in Scala. Case in point--lazy. Yes, I can see that you need to worry about race conditions with lazy so the atomic call is justified, but every time I turned around it was always something unexpected.  I remember trying to figure out why some code was so slow and tracked it down to partial functions--who would have thought! I think they tried to hard to get the JVM to perform too many unnatural acts, unnatural at least for the JVM.  What I liked about Java is that I have a good understanding of what is slow, why it is slow and how to make it fast. Learned a lot working on high performance message passing between actors, too. (The original implementation of JActor was concerned with speed, the second was more concerned with robustness than with speed.)  So now I am on Clojure. At least it looks like it stays pretty true to the kinds of things the JVM is good at. And I know I am giving up a fair amount of performance just by going with Clojure. But I'm more mellow now about performance and at least it is faster than Python (or faster than Python used to be!)"
Clojure,3dquov,yogthos,4,Sun Jul 19 04:53:38 2015 UTC,"Another thing to note is that the vast majority of the code in the application doesn't run all that often. You'll usually have a few places that have tight loops that may need optimizing.  The JVM provides great profiling tools that let you zero in on the problem areas and at that point you can to use tricks like annotations to make the code more performant, or rewrite things in less idiomatic ways. If all else fails you can always fall back to writing a bit of Java. I haven't run into a situation where the last step has been necessary yet though. :)"
Clojure,3dquov,deong,2,Sun Jul 19 13:15:55 2015 UTC,Sounds like you also read Knuth. :-)
Clojure,3dquov,joequin,1 point,Sun Jul 19 16:31:54 2015 UTC,"I've never found the need to restrict code to a subset of scala's features. Learning about type classes, value classes, implicit conversion and implicit types is ready. After that, the only thing that makes the language complex to use is functional programming in general, and you have to learn that in order to work with clojure as well."
Clojure,3dpjpf,FatSoccerMan,8,Sat Jul 18 05:14:29 2015 UTC,"My to-go server is Immutant2, especially since Sente (local analogue of socket.io) started supporting it in addition to http-kit quite recently.  While previous Immutant1 release was big and monolithic in new Immutant2 you can for example choose only to use org.immutant/web clojar and is as simple to set up as any other Clojure webserver. A nice bonus is the slew of additional libraries Immutant2 can provide (messaging, scheduling, distributed cache, distributed transactions) by virtue of JBoss/WildFly. The only downside I've encountered so far is having to contend with Java logging, since that's what JBoss uses, which is somewhat annoying.  Previously I've used http-kit to good effect, though it seems less maintained than it used to be and doesn't have all the optional goodies Immutant2 has. It has Sente support as well as I mentioned above, though.  I didn't try Aleph so far, but it's manifold abstraction seems quite interesting. Unfortunately no Sente support so far.  If you're interested in preformance you can for example see benchmarks here: https://github.com/ptaoussanis/clojure-web-server-benchmarks  As for ease of use for a beginner - it doesn't really matter which one you choose. Most of the webservers in the benchmark above are run like (some-namespace/run-fn some-handler {:some options}) so whichever you choose it won't be much of a problem to wrap your head around. Just compare fns inside start-server! forms in the benchmark here - it's all pretty same-y.  All in all I'd suggest going with Immmutant2's web component due to the awesome optional components and Sente support or Aleph if you would feel like exploring some of it's advanced async functionality once you have grasp on basics."
Clojure,3dpjpf,jaen-ni-rin,6,Sat Jul 18 10:35:02 2015 UTC,Undertow (used by immutant) also now supports HTTP/2 and is blazing fast. So soon we'll see that in Immutant.  I'm surprised Immutant isn't more popular. It's really the easiest option to get stuff done really quickly.
Clojure,3dpjpf,AndreRauh_,1 point,Sat Jul 18 12:24:46 2015 UTC,"Yeah, curious when they will expose that in Immutant."
Clojure,3dpjpf,jaen-ni-rin,1 point,Sat Jul 18 14:24:11 2015 UTC,"Not sure exactly, but it's on our list: https://issues.jboss.org/browse/IMMUTANT-570"
Clojure,3dpjpf,jcrossley3,3,Sat Jul 18 15:03:34 2015 UTC,If you are new - just go with the simplest option - as far as I know this is Jetty.
Clojure,3dpjpf,1xltP3mgkiF9,1 point,Sat Jul 18 07:31:14 2015 UTC,"I agree with this, you can change it later if necessary."
Clojure,3dpjpf,pupeno,2,Sun Jul 19 10:42:31 2015 UTC,"Aleph - stable, fast, asynchronous server (Netty-based), stream abstractions (Manifold) HTTPKit - straightforward HTTP server Immutant - don't know much, but heavy framework ?   I'd go for Aleph."
Clojure,3dpjpf,cljssscssssssssss,3,Sat Jul 18 07:37:52 2015 UTC,"Immutant used to be heavy, the new version is pretty modular - http://immutant.org/documentation/current/apidoc/guide-installation.html"
Clojure,3dpjpf,jaen-ni-rin,2,Sat Jul 18 10:37:50 2015 UTC,"To add to this: Undertow (which you can get by immutant-web depedency) is extremely lightweigh. 1MB jar and 4MB heap usage.  Yes, if you add caching,transactions and scheduling you'll get much more jars (and much more functionality)."
Clojure,3dpjpf,AndreRauh_,2,Sat Jul 18 17:54:05 2015 UTC,"I'm currently developing an other fully asynchronous web toolkit, called catacumba (https://github.com/funcool/catacumba) that like aleph is built up on netty and has an extensive documentation (https://funcool.github.io/catacumba/latest/)"
Clojure,3dpjpf,niwibe,2,Sat Jul 18 07:40:08 2015 UTC,"I wrote a post on the reason I'm defaulting to HTTP Kit for now.  Long story short is that it's very lightweight and has the most straightforward API for websockts that plays nice with Ring middleware.  I was going to use Jetty, but both Jet and ring-jetty9-adapter require JRE 8. Also, at least for Jet, the websockets break middleware that expects request/response maps.  I don't have too much experience with using immutant, it seems a bit heavier overall. Although, the 2.x version has been modularized. I might revisit it at some point if I find there are issues with HTTP Kit.  In general, I think that for vast majority of applications it really doesn't matter. Ring provides a great abstraction for the HTTP layer and the servers are for the most part interchangeable.  edit/update  After some discussion here and doing a bit of testing with Immutant I've decided that it might just be the best default option. It addresses all of the problems that HTTP Kit solves and seems to be much better maintained."
Clojure,3dpjpf,yogthos,2,Sat Jul 18 15:23:29 2015 UTC,"Be careful with that choice--I benchmarked HTTP-kit and Jet extensively for Spiral, and found that http-kit has serious race conditions that make it fall over when you push it too hard. Simply making too many GET/sec to HTTP-kit will permanently deadlock the handler thread pool."
Clojure,3dpjpf,dsg123456789,1 point,Sat Jul 18 19:16:35 2015 UTC,"Interesting, have you opened an issue for the project regarding this?  It's definitely something I'm a bit conflicted on. Jetty and JBoss are very mature by now. So, while they're heavier than Aleph and HTTP Kit, they're also a lot more robust.  I might explore Immutant some more to see what its websocket story is like. I think the Jet approach is a bit problematic at the moment, and JRE 8 requirement is too restrictive.  I've contacted HTTP Kit author and he did mention that he's looking to patch the existing bugs, but he is looking for a maintainer long term."
Clojure,3dpjpf,yogthos,1 point,Sat Jul 18 19:35:46 2015 UTC,"I have reported it, but the author couldn't repro it. Apparently, I close the issue as I thought I'd fixed it[1], but I had already moved off.  [1] https://github.com/http-kit/http-kit/issues/147"
Clojure,3dpjpf,dsg123456789,1 point,Sun Jul 19 02:43:26 2015 UTC,It sounds like the latest version doesn't lock up at least. I did a bit more testing with Immutant though and it does seem to address all the same problems as HTTP Kit. Since it appears that a lot of people are using it already I'm going to test it out as the default.
Clojure,3dpjpf,yogthos,1 point,Sun Jul 19 04:20:28 2015 UTC,"For what it's worth, I'd consider Aleph nearly as robust as Netty, since there's very little being added on top of it.  As far as http-kit, NIO is complicated enough that I wouldn't be surprised if there are lingering issues."
Clojure,3dpjpf,prospero,1 point,Mon Jul 20 05:04:51 2015 UTC,"For what it's worth, http-kit isn't built on Netty, it uses its own code on top of nio."
Clojure,3dpjpf,prospero,1 point,Sat Jul 18 18:05:01 2015 UTC,It does have netty as a dependency though. Perhaps it's used for some other purpose?
Clojure,3dpjpf,yogthos,1 point,Sat Jul 18 18:58:04 2015 UTC,"It's a dev-dependency, so it might be used for testing, but it can't be used for anything in the main codebase."
Clojure,3dpjpf,prospero,1 point,Mon Jul 20 05:05:31 2015 UTC,"Oh yeah good catch, didn't notice that. In any case, after thinking about this some more and trying out Immutant with websockets I decided that's probably the best option at the moment.  It's based on JBoss that's very mature, and there's a team maintaining it that appears to be very active. Now that it's no longer monolithic the core component is pretty light and comparable to Aleph and Jetty in terms of overhead."
Clojure,3dpjpf,yogthos,1 point,Mon Jul 20 05:40:00 2015 UTC,"You should look at immutant again. Its websocket API is as simple as http-kit's, but it also supports on-success/on-error callbacks for websocket messages. The callbacks make it much easier to implement back pressure.  Immutant also seemed faster under load, but I didn't make any careful benchmarks."
Clojure,3dpjpf,dwwoelfel,2,Sat Jul 18 19:44:21 2015 UTC,"I looked a bit at its websocket API just now and it does seem to work well. It appears that it works accidentally with Compojure routes as well. :)  (def websocket-callbacks   ""WebSocket callback functions""   {:on-open    (fn [channel]     (async/send! channel ""Ready to reverse your messages!""))    :on-close   (fn [channel {:keys [code reason]}]     (println ""close code:"" code ""reason:"" reason))    :on-message (fn [ch m]     (async/send! ch (apply str (reverse m))))})  (defroutes ws-routes   (wrap-routes    (GET ""/ws"")    #(web-middleware/wrap-websocket % websocket-callbacks)))"
Clojure,3dpjpf,yogthos,1 point,Sat Jul 18 20:27:50 2015 UTC,"Author of Ring-jetty9-adapter here. Rj9a will soon get support for http2. The PR is almost finished.  For websocket we will receive a new customizable Creator API for you to control the Upgrade request in a Ring way (maybe).  For me jetty combines lightweight and stability. And rj9a is a thing wrapper above jetty9. There's no additional abstraction, thread models and so on, which means you don't have to lose performance by default."
Clojure,3dpjpf,sunng,1 point,Sun Jul 19 03:17:16 2015 UTC,"I generally do like Jetty as well, the two main issues are JRE 8 and websockets not playing well with Compojure/Ring. If you can get an API that addresses the latter, I'd be glad to include rj9a in Luminus."
Clojure,3dpjpf,yogthos,1 point,Sun Jul 19 04:14:16 2015 UTC,The man himself replied!  Exciting :)
Clojure,3dmr4c,dunnowins,2,Fri Jul 17 15:09:57 2015 UTC,"It's pretty good! Listened while traveling home from the day job, dreaming of doing clj for a living instead"
Clojure,3dmr4c,Hdhdhebgehd,2,Fri Jul 17 16:51:52 2015 UTC,Turns out the gentleman who posted it on /r/techno is the producer of the track. He is learning Clojure and said he finds himself writing lein uberjar frequently and that's how he chose the name.
Clojure,3dmr4c,lgstein,1 point,Fri Jul 17 19:30:46 2015 UTC,"I am already looking forward to his next track, assumedly called deploy.sh"
Clojure,3dn7xf,donbonifacio,1 point,Fri Jul 17 17:18:36 2015 UTC,Code is here: https://github.com/orionsbelt-battlegrounds/obb-rules  Can't believe how fast this is.
Clojure,3dkw2z,dunnowins,4,Fri Jul 17 02:29:33 2015 UTC,Interesting story. I would love to read more about the technical details of CircleCI's live patching infrastructure.
Clojure,3dkw2z,pokle,1 point,Fri Jul 17 10:05:41 2015 UTC,I think they have a port / API in their Apps to launch an NREPL server they can connect to. What else would you need?
Clojure,3dkw2z,lgstein,5,Fri Jul 17 13:58:51 2015 UTC,The devil's in the details. Nrepl on one running process is easy. How do you scale that to a 100? From reading the blog I got the impression that they weren't live coding an nrepl in production - one typo and down comes your entire cluster. Perhaps they tested their changes somewhere else and had a tool to push their changes to a running cluster of nrepls. It sounded like the primary problem they solved was a slow deployment pipeline. I wonder if they could use their fast nrepl tool for all deployments without having to restart anything. Anyway it's all very interesting and I'd love to hear more.
Clojure,3dkw2z,pokle,1 point,Fri Jul 17 14:27:07 2015 UTC,"This is where Clojure's live patching comes in. By connecting directly to our production machines and connecting to the Clojure REPL, we can change code live and in production. We've built tooling over the last few years to automate this across the hundreds of machines we run at a particular time."
Clojure,3dk5uv,djhaskin987,2,Thu Jul 16 22:43:44 2015 UTC,"@djhaskin987:   2015-07-07 06:20:53 UTC  @rkneufeld in response to your question, #clojure's animal should be a chinese dragon, because: pic.twitter.com [Imgur]     [Mistake?] [Suggestion] [FAQ] [Code] [Issues]"
Clojure,3dgbhq,fj2010,6,Thu Jul 16 01:22:26 2015 UTC,"The most basic thing you need is to add the Clojurescript dependency to your project file:  [org.clojure/clojurescript ""0.0-3308""]   However... I also assume you're a sane human being so you'll want to add lein-cljsbuild to have the nice features of building your cljs code. There's two parts to this.  1) You need to reference the plugin  :plugins [[lein-cljsbuild ""1.0.6""]]   2) You need to set up where cljsbuild is going to compile to. Here's a basic setup you can use  :cljsbuild {:builds   {:app    {:source-paths [""src-cljs""] ;; This indicates which folder your source code is contained in. If it is in a different folder, e.g. just src, then you should change it      :compiler     {:optimizations :none ;; This indicates whether any optimization will be done during compilation. You can check out more details in the documentation https://github.com/emezeske/lein-cljsbuild       :output-to ""resources/public/js/app.js"" ;; This indicates where the compiled .js file will be outputted to. Edit as needed       :pretty-print true}}}}   EDIT: Perhaps this link can also help!"
Clojure,3dgbhq,derpcow,2,Thu Jul 16 01:55:06 2015 UTC,"Thanks!  I've added the dependency, plugin and cljsbuild params to my project.clj.  I've also created the directory structure for the source files.  When I do a 'lein cljsbuild once', I get a stacktrace dump. The relevant line seems to be;  Exception in thread ""main"" java.io.FileNotFoundException: Could not locate cljs/util__init.class or cljs/util.clj on classpath: , compiling:(cljs/closure.clj:1:1)   Any ideas? I have done 'lein deps' already."
Clojure,3dgbhq,eccp,4,Thu Jul 16 03:18:12 2015 UTC,Could not locate cljs/util__init.class   It seems it might be this issue eg.: Using a recent version of ClojureScript will bump the requirements for Clojure itself.
Clojure,3dgbhq,eccp,2,Thu Jul 16 05:00:31 2015 UTC,That's it! Thanks a million.
Clojure,3ddfg0,AndreRauh_,2,Wed Jul 15 12:05:30 2015 UTC,Someone's been reading the clojurians slack ;)
Clojure,3ddfg0,emsimot,1 point,Wed Jul 15 15:26:34 2015 UTC,this is an excellent write-up! thanks
Clojure,3dfexn,laforge49,1 point,Wed Jul 15 21:06:29 2015 UTC,"Aside from the overhead created by creating new agents, there is the fact that swap! on atoms is synchronous. E. g. swap! returns the new atoms value and hence has to wait for the result of the successfull cas operation, whereas send immediately returns the agent and the operation is going to happen asynchronously."
Clojure,3dfexn,lgstein,1 point,Wed Jul 15 22:12:46 2015 UTC,"Exactly. It is very hard to write code that runs faster with more threads. So in general, you should not pass something to another thread that you can do yourself. Which is what the JActor2 framework tries to do under the covers.  The timing test I wrote is at one level absurd. You do not want to always do everything in a single thread. But always passing messages seems equally foolish. Passing messages between threads kills your response time, with the hope that you might improve throughput. But I've learned that it is often faster when passing a message to an idle actor to pass the thread along with it rather than just putting the thread back in the threadpool and having a different thread process the message.  The reason why it is faster to go single threaded and ""pass the thread"" is because there is often something already loaded in the cache that the thread can use. That, in addition to avoiding the overhead of having another thread begin processing the message for the targeted actor.  Ah sorry. Just realize you were arguing the reverse point. In practice, messages may not be sent to another actor until the originating actor has nothing else to do. (One case that comes to mind is when transactions are involved.) This delay lets you buffer messages going to the same destination. I do the same when migrating a thread--it is done when the actor originating the request has no pending requests. So you are typically not delaying anything by migrating the thread--it was headed back to the thread pool anyway."
Clojure,3dfexn,foogoof,3,Wed Jul 15 22:24:07 2015 UTC,"Bit of a tangent, but there's a really excellent benchmarking tool called Criterium."
Clojure,3dfhtl,Tikotus,2,Wed Jul 15 21:27:03 2015 UTC,Should be fairly straightforward to write your own based on https://github.com/clojure/clojure/blob/bdc752a7fefff5e63e0847836ae5e6d95f971c37/src/clj/clojure/core.clj#L4801
Clojure,3dfhtl,skiaec04,1 point,Wed Jul 15 21:30:30 2015 UTC,"Thanks. Now I know it can be done quite easily, which is good enough for now :)"
Clojure,3dfhtl,lgstein,2,Thu Jul 16 09:01:43 2015 UTC,So you have multiple maps with the same user_id but you only want the first of them. Are you sure? Because group-by gives you all of them. So that is quite different.
Clojure,3dfhtl,lgstein,1 point,Wed Jul 15 21:41:30 2015 UTC,"So you have multiple maps with the same user_id but you only want the first of them. Are you sure? Because group-by gives you all of them. So that is quite different.   Ok, true, wasn't thinking through. But after group-by I can select the first one of all of the gorups."
Clojure,3dbvvf,ajoberstar,3,Wed Jul 15 01:47:22 2015 UTC,"He makes a really good case in front of an audience who is not in his corner. I felt like he pulled some punches, but certainly not all of them. In particular, the puppeteer analogy seemed really good; other people being able to make your objects dance just because you gave them a reference is really bad for reasoning about how your code will behave."
Clojure,3dbvvf,Rurouni,3,Wed Jul 15 02:28:31 2015 UTC,Agreed. The HttpServletRequest example was also very illustrative. The idea that there are four different APIs on a single class for getting properties is just eye-opening.  I hope he wins some new Clojure fans with that talk.
Clojure,3day9y,kgxsz,1 point,Tue Jul 14 21:31:27 2015 UTC,"It looks fantastic! Great job :)  Hiccup style (https://github.com/r0man/sablono) over dom/blah is more concise and pleasant, consider using it in the slides.  Your code is excellently crafted. I like that you have docstrings, well thought of naming, and right sized namespaces. It is very clear in intent and execution.  Thank you for sharing."
Clojure,3day9y,timothypratley,1 point,Wed Jul 15 02:17:24 2015 UTC,"Extremely slick presentation, great job"
Clojure,3davoe,Rezistik,8,Tue Jul 14 21:12:50 2015 UTC,It doesn't cover user accounts but I wrote a six part blog series awhile back that covers how to write and test a compojure CRUD application. That covers a lot of what you mentioned.   http://www.jarrodctaylor.com/posts/Compojure-Address-Book-Part-1/
Clojure,3davoe,JarrodCTaylor,2,Tue Jul 14 21:26:46 2015 UTC,"This is a dumb question...but I really dislike Hiccup, I didn't choose a lisp to write brackets! I really like quiescient, how do I use that in place of hiccups?"
Clojure,3davoe,JarrodCTaylor,2,Wed Jul 15 01:08:08 2015 UTC,The hiccup library is not comparable with quiescient. From their respective readmes. Hiccup is for representing HTML in Clojure and quiescient is a ClojureScript abstraction over ReactJS. I haven't ever used quiescient so I can't comment on what it uses for HTML generation or if it is available as a stand alone lib.
Clojure,3davoe,emil0r,1 point,Wed Jul 15 01:44:17 2015 UTC,"Quiescient is a wrapper around React, so all I need is a way to send my Clojurescript file down and load it onto a div. So I only need a single HTML template to put an ID down on it.   I find a lot of tutorials on Clojure or Clojurescript...but I can't seem to figure out how to use them both.  I think I gather you should have a src directory and a cljs-src directory I guess?"
Clojure,3davoe,ritperson,1 point,Wed Jul 15 23:36:07 2015 UTC,"If you don't wish to use hiccup you have the choice of enlive and selmer. Enlive takes html, and returns a data structure of that html that you can then operate on. Selmer is more like django templates.  https://github.com/cgrand/enlive https://github.com/yogthos/Selmer"
Clojure,3davoe,prbroadfoot,1 point,Wed Jul 15 08:12:12 2015 UTC,Maybe you'd like Hoplon. It uses s-expressions to represent HTML http://hoplon.io
Clojure,3davoe,JarrodCTaylor,0,Wed Jul 15 22:10:05 2015 UTC,I looked at hoplon and something about it turned me off. Completely irrational...but yeah.
Clojure,3davoe,kgxsz,1 point,Wed Jul 15 22:35:29 2015 UTC,I used your tutorial about a month ago and found it very helpful! Thanks for writing it.
Clojure,3davoe,soundslogical,1 point,Wed Jul 15 03:06:52 2015 UTC,Glad you found it useful.
Clojure,3davoe,DrUngood,11,Wed Jul 15 03:28:08 2015 UTC,"If you have a bit of time on your hands, web development with clojure is a relatively short read that covers a lot of the stack."
Clojure,3davoe,Venthorn,4,Tue Jul 14 21:18:39 2015 UTC,"Seconded, I'm going through it the moment and it does what OP needs. It's good for beginners to Clojure too."
Clojure,3davoe,EAT_DA_POOPOO,2,Tue Jul 14 23:32:24 2015 UTC,"According to the author a second edition is coming soon, I'm not sure whether or not to wait! Apparently one of the major libraries from the first edition (lib-noir) is no longer used."
Clojure,3davoe,Venthorn,2,Wed Jul 15 03:04:17 2015 UTC,"Hey, so I actually had a similar problem to you, though coming from the other direction! The last time I did real web dev was back in the CGI days so I totally didn't get the new way of doing things with reverse-proxying and stuff like that.  There's not much really ""integrated"" framework solutions in Clojure like what I think there is in the node.js world, instead it's sort of bring-together-a-lot-of-pieces to build your stack. I'll try to describe some of the pieces of interest, from generally-lowest-level to higher-level.   HTTP server. You get to pick one, but until your project seriously grows a lot just use the next piece of the stack... Ring. This is a library for passing around HTTP requests and responses and munging them until you get the final result for a web request. It takes the initial HTTP request from the HTTP server (and it comes with one by default -- Jetty), and you eventually get a response to feed back to the server. On top of this everything else is layered. Ring is responsible for handling HTTP concepts like ""sessions"" and ""cookies"" as well. Compojure. This is a minimal library that sits on top of Ring for turning URL paths from requests into function calls. I use Enlive for transforming HTML into what I want the output to be. I don't know anything about React or frontend stuff. For handling user accounts and roles and whatnot, you have a couple choices. There is the low-level choice of Buddy and the higher-level choice of Friend (which should handle a lot of what you want for you). For persisting things, you pick a SQL database that has a JDBC implementation (basically all of them do) and use org.clojure/jdbc to execute your SQL commands against it. You could of course use a non-SQL database too but who does that!   Hope that helps. Not sure if I missed anything for you or not."
Clojure,3d7omc,fj2010,13,Tue Jul 14 03:58:12 2015 UTC,"Performance. The JVM is very good at efficiently and performantly dispatching on arity, which is why you see code like this in Clojure source. The only variant for functions in Clojure is arity (no type variants). To help the JVM Clojure's clojure.lang.IFn interface has support for 20 positions parameters."
Clojure,3d7omc,kipblint,2,Tue Jul 14 04:20:12 2015 UTC,"Thanks for that, makes sense. I can understand it for the Clojure core, but I wonder if it's necessary for something like Enlive."
Clojure,3d7omc,jbiserkov,1 point,Tue Jul 14 07:24:10 2015 UTC,"So this is basically a form of loop unrolling, no?"
Clojure,3d7omc,kipblint,3,Tue Jul 14 12:25:48 2015 UTC,"In this case because the variable argument invocation can be implemented in terms of a reduce yes, but in general no. It is more about the cost of method invocation on the JVM and giving the JIT compiler enough information to inline effectively. Calling a method is fairly slow compared to executing within a method body. So it is more about number of method calls than loop unrolling."
Clojure,3d7omc,peeja,3,Tue Jul 14 12:45:29 2015 UTC,Where do macros fall into this chain of events? Could a function like this be rewritten with a macro to more readably generate all the declarations?
Clojure,3d7omc,weavejester,1 point,Tue Jul 14 15:27:44 2015 UTC,"A macro is evaluated at compile time, so a macro could indeed be used to automatically generate definitions like this. It would be easy to make the definition more concise, but I'm not certain about more readable."
Clojure,3d7omc,peeja,1 point,Wed Jul 15 00:07:19 2015 UTC,What I'm imagining is some kind of loop-unwinding that would let you say what you mean in the definition and turn a knob to tune the number of arities to produce. But maybe it would have to be too specific to be reusable.
Clojure,3d87vt,dkvasnicka,8,Tue Jul 14 07:19:10 2015 UTC,Take a look at https://github.com/Day8/re-frame
Clojure,3d87vt,baris83,1 point,Tue Jul 14 07:53:42 2015 UTC,I'm a huge fan of re-frame. I recommend taking a look at the readme to see if its philosophy aligns with what you want from an FRP library.
Clojure,3d87vt,jmikem825,1 point,Tue Jul 14 13:47:47 2015 UTC,Agreed; re-frame is required reading regardless of if you plan to use it. Many gems of knowledge and style are contained within.
Clojure,3d87vt,timothypratley,4,Wed Jul 15 01:50:28 2015 UTC,I know you didn't ask for this but REALLY: Don't do FRP when you have core.async. Use core.async and you'll have a much powerful tool. Yes you might not have some of the high level functions of FRP but you have all those much more powerful low level functions from core.async. CSP > FRP.
Clojure,3d87vt,MyNameIsFuchs,1 point,Tue Jul 14 12:02:37 2015 UTC,My problem is that I want this for a PoC that I myself don't know what I want it evolve to... So for now I want something straightforward. Right now I'm afraid I'll do the first iteration using Kefir and the Kefir-React mixin (i.e. no Cljs) because that's by far the most straightforward thing I've found...
Clojure,3d87vt,timothypratley,1 point,Tue Jul 14 13:02:24 2015 UTC,"No problem, I value your contribution to the discussion :)"
Clojure,3d74sq,warrentiesvoidme,2,Tue Jul 14 01:17:23 2015 UTC,"It depends on how your application is structured. If you poll the pin status you can probably extract getting the status into a single function and use a mocking library or just https://clojuredocs.org/clojure.core/with-redefs-fn to fake results. This has lots of benefits and is reasonably easy to pick up.  If you structure your code so that you have a small io layer to read the pin status and some inner logic merely receives the new status and does not depend on the pin, you can just test the inner function with fake data and not worry about the pin."
Clojure,3d1bxs,quantumbyte,5,Sun Jul 12 18:32:06 2015 UTC,https://github.com/Prismatic/schema
Clojure,3d1bxs,beppu,2,Sun Jul 12 19:10:56 2015 UTC,"Is there a way to enforce ""coreference""?  I'm doing something like this:  {:pets {:my-dog {:name ""Fiffy""                  :color ""Black""}}  :owners {:my-dog ""John Doe""}}   I need to ensure that both maps for :pets and  :owners have the same keyset.  I am not putting :owner together with :name and :color, because it is at a different abstraction level and I don't want to mix these things."
Clojure,3d1bxs,Byga6,3,Mon Jul 13 09:36:47 2015 UTC,"In the past, I've solved the coreference problem by using, well, I guess you could call it ""higher order Prismatic schemas."" Basically, I feed the data structure through functions that generate schemas (i.e. ""schemers"") that get merged into an overall schema.   For your example, I'd do something like:  (defn owners-schemer   ""Ensures that keys in :pets are also in :owners""   [{m :pets}]   {:owners (zipmap (keys m) (repeat schema.core/Any))})  (defn generate-schema   [data]   (merge {:pets schema.core/Any} (owners-schemer data)))  (let [data {:pets {:my-dog {:name ""Fiffy""                             :color ""Black""}}             :owners {:my-dog ""John Doe""}}]   (schema.core/validate (generate-schema data) data))   I've used this in, for example: https://github.com/dvdt/xvsy/blob/master/src/xvsy/schemers.clj  Not sure if this is a particularly idiomatic way to solve the problem; it's just what I've done in the past.  EDIT: couldn't figure out how to format code properly so I made a gist: https://gist.github.com/dvdt/fb13f898ebe2c844b7b0"
Clojure,3d1bxs,lgstein,1 point,Mon Jul 13 22:26:53 2015 UTC,Do you wish to allow arbitrary keys or do you know that it has to be :my-dog in both of them?
Clojure,3d1bxs,jonaen,2,Mon Jul 13 23:23:59 2015 UTC,"There are a lot of different libraries for this. Search for ""Validation"" on http://www.clojure-toolbox.com/"
Clojure,3d1bxs,jonaen,1 point,Sun Jul 12 19:02:09 2015 UTC,"Oh, nice link! It'll take some time to go through all of these, but I already recognized some ideas I had myself.   Any specific recommendations from that list?"
Clojure,3d1bxs,lgstein,3,Sun Jul 12 19:11:51 2015 UTC,Schema is a popular choice. I've used Bouncer which I personally liked a lot. I'm sure there are other great choices on that list.
Clojure,3d1bxs,lgstein,1 point,Sun Jul 12 19:24:09 2015 UTC,"I am personally dissatisfied with the existing validation libraries and hence am developing a small CLJC library called validat. It is not stable yet, but if you are interested in giving it a try I'd be very happy about your feedback: https://github.com/lgrapenthin/validat - (Documentation in docstrings comments/ https://github.com/lgrapenthin/validat/blob/master/src/validat/core.cljc)"
Clojure,3d0ve9,ritperson,6,Sun Jul 12 16:11:51 2015 UTC,"I've been using Dash + Alfred integration for docs.  It's OS X only, but I get any doc I want within a few keystrokes even if I'm not in my repl. Pretty sweet.  Also, sorry, but I'm never a fan of clickbait titles. I just get an awful emotional reaction to them since I assume someone is trying to  manipulate me."
Clojure,3d0ve9,LessCodeMoreLife,1 point,Sun Jul 12 18:03:08 2015 UTC,"dash   https://kapeli.com/dash   alfred   http://support.alfredapp.com/  ps at least Clojure manipulation is immutable, what you have is yours"
Clojure,3d0ve9,fullouterjoin,1 point,Mon Jul 13 02:09:35 2015 UTC,Velocity is Dash's counterpart for Windows. Just for the sake of completeness.
Clojure,3cya3w,kansasKarmaWhore,4,Sat Jul 11 21:40:14 2015 UTC,Wasn't it machine listening?
Clojure,3cya3w,john_atx,4,Sat Jul 11 22:20:35 2015 UTC,I remember that he was asked in the Cognicast about that. It was something related to digital sound analysis.
Clojure,3cya3w,lgstein,4,Sat Jul 11 22:21:32 2015 UTC,"Harmonikit, maybe?"
Clojure,3cya3w,saint_glo,2,Sun Jul 12 04:30:40 2015 UTC,Of all his talks this is the only one I completely forgot.
Clojure,3cuvdj,funkenblatt,3,Fri Jul 10 23:36:37 2015 UTC,The code can be found here: https://github.com/funkenblatt/figwheel-test/blob/master/cljs/figwheel_test/snake.cljs  I spent a lot more time than I probably should have deriving equations for intersecting curves.
Clojure,3cuvdj,WesOfWaco,2,Fri Jul 10 23:39:16 2015 UTC,(defn draw-shit   Awesome!
Clojure,3cuvdj,doubleagent03,3,Sat Jul 11 02:48:50 2015 UTC,This little game is the most frustrating thing I've done all day.
Clojure,3cuvdj,p1r4nh4,2,Sat Jul 11 14:51:16 2015 UTC,"Please add left/right buttons for control, my left hand sucks!"
Clojure,3cuvdj,p1r4nh4,2,Sat Jul 11 15:13:04 2015 UTC,Should work now.
Clojure,3cuvdj,fastgtr14,3,Sat Jul 11 19:11:02 2015 UTC,Thanks! It seems my right hand sucks just as much! :)
Clojure,3cpj5w,ericwnormand,2,Thu Jul 9 19:10:18 2015 UTC,"This is not consistent. The last approach relies on convention as much as the first:   In the first, the rule that you can only use the presented keys is implicit. In the last, the rule is that you ""use a hashmap with a single key"" which is just as implicit.   Only the variant example strictly enforces a single tag/value combo, and it is highly questionable whether anyone wants to do this. A great deal of Clojures flexibility is derived from being able to rely on convention and I wouldn't want to miss it.   What is the point of having hash maps with only one key?  Why can maps better get passed around and collected into sequence than vectors?"
Clojure,3cpj5w,lgstein,2,Sat Jul 11 22:51:24 2015 UTC,"That's an interesting pattern, but intuitively I'd be tempted to do the opposite: that is, use 2-member vectors like [:tag {actual data}] (e.g. [:image/external {:url ""http://imgur.com/xxx.jpg""}]). It would then allow me to trivially dispatch multimethods on first (while the 1-key map requires the use of match).  What makes the 1-key dict a superior alternative? Is there something super-obvious that I missed?"
Clojure,3cpj5w,WildCatBrown,1 point,Sun Jul 12 13:01:13 2015 UTC,"Awesome post. I've recently written a compiler using vector variants and I agree that unless you have nested trees, you don't wan't to use them.  They add a significant amount of complexity, even when using core.match. And even then, core.match has so many bugs that you don't really want to use it.  The map approach looks promising, and I'm going to try that out in the future, since it employs all the available infrastructure of clojure, destructuring, keyword lookup and it allows you to add more data to a variant, without worrying about the arrity becoming polymorphic."
Clojure,3cpj5w,_lasjdf,2,Fri Jul 10 00:24:32 2015 UTC,"So, I'm new to clojure, but came from Scala where I used pattern matching quite a bit. What makes core.match buggy and less than ideal to be used? Is its performance bad? Does it not always work?"
Clojure,3cpj5w,Sublixt,1 point,Fri Jul 10 13:40:32 2015 UTC,"There are several bugs that simply break the pattern match ([x y & z] :as all) will just bind[x y] to all, for example. There are a few more documented in the JIRA."
Clojure,3cpj5w,_lasjdf,1 point,Sat Jul 11 12:16:38 2015 UTC,"iirc matching is a language feature whereas in clj its ""just a lib"" so i think it gets used less.  that said i remember it being pretty well tested so also wondering what author ran into."
Clojure,3cpj5w,lechatsportif,1 point,Fri Jul 10 16:42:35 2015 UTC,"Deeply in love with this.   Is there is a guide to learn how to calculate complexity of code design, like this post shows?"
Clojure,3cdxc4,meatcompute,7,Tue Jul 7 03:57:11 2015 UTC,"I want to learn Clojure and functional programming in general, but I am afraid that I will learn the syntax and write ""bad"" Clojureimperative-like and not functional (if that is possible). Is there a good resource that teaches both? I am reading Clojure for the Brave and True, so that may help.  It's kind of hard for me to forget the old imperative/oop/mutable data paradigms when writing Clojure, but I am trying!"
Clojure,3cdxc4,Ogesana,6,Tue Jul 7 15:07:09 2015 UTC,"When I started learning Clojure I found that Clojure for the Brave and True was a little too focused on syntax for an introduction to FP. Yogthos' Clojure Distilled does a better job of giving a high level introduction to the FP paradigm imo.   As for writing ""good"" Clojure, it honestly just takes practice before you start to recognize what are the best practices and what strategies are the most suitable for certain problems. Writing small projects and refactoring them to be more idiomatic or cleaner is an excellent way to practice.   Looking through some GitHub libraries can also give you a sense of what is good style. Weavejester writes some really clean code and it's a good place to start. You can also take a look at the core of one of my libraries, Cryogen as an example."
Clojure,3cdxc4,Nymsi,2,Tue Jul 7 16:01:57 2015 UTC,"I learned Clojure with Brave and True, and while I'm still certainly no expert, I think it was an excellent introduction.  Also, I think Clojure the language is so opinionated that it pushes you strongly to develop an FP style. The fact that everything's immutable by default means I found it pretty hard to write imperative style code anyway."
Clojure,3cdxc4,soundslogical,2,Tue Jul 7 16:49:06 2015 UTC,"Clojure from the ground up is a great resource, as is The joy of Clojure. Both of these were extremely helpful when I was starting out.  One thing to keep in mind is that whenever you reach for atom or mutable state in general, ask the question ""do I really need mutablility here?"". Often you'll discover that there is a functional solution if you keep trying different approaches.  One thing about functional programming in general: know thy map, filter and reduce! These can be used in many places you'd use loops in imperative languages. Reduce especially is an incredibly versatile function."
Clojure,3cdxc4,jschm,5,Tue Jul 7 18:18:28 2015 UTC,"As a Vimmer (and more specifically a non-Emacser), is there a sane way to get up and rolling and a guide to Paredit so that it feels more natural and isn't modifier-key-heavy, rather than myself needing a special editor just to handle the fact that all functions are wrapped (unlike those in the ML family)? When I heard about 'parentheses are like hugs for your functions', I laughed, but also decided to give learning Clojure another go. My problem has actually been the tooling to feel fluent and productive. I liked Light Table, but they've not updated in a long time and plugin makers have abandoned their libraries so I get zlib errors when attempting to get useful plugins :/."
Clojure,3cdxc4,NoGodTryScience,5,Tue Jul 7 13:20:55 2015 UTC,"I used paraedit for some time, but then I gave up and started using tpope's vim-sexp-mappings-for-regular-people and I'm happy now, though I'm not sure if it was paraedit that was stubborn to use or if it was me who didn't learn its keybindings enough."
Clojure,3cdxc4,Ravicious,1 point,Tue Jul 7 16:42:46 2015 UTC,My friend/coworker recommended me this. I'll have to give it another go now that I fixed a 'bug' in my .vimrcwhere a plugin had hijacked my <BS>. I have a feeling it caused conflicts with this plugin.
Clojure,3cdxc4,NoGodTryScience,1 point,Tue Jul 7 17:38:48 2015 UTC,"I currently use Vim + vim-fireplace + paredit and find it to be quite natural to work with Clojure code. Not sure what you mean by Paredit being modifier key heavy. In Vim most of what you need from Paredit is linked to <leader>. For example wrapping a form is just <leader>-W, wrapping in square or curly is <leader>-w [ or <leader>-w {, slurp is <leader>->, and so on. The built-in help for Paredit should get you pretty much everything you need.  If you want to dive into the Emacs waters, but don't want to completely leave your modal editing ways behind, try Spacemacs!"
Clojure,3cdxc4,jballanc,1 point,Tue Jul 7 14:45:24 2015 UTC,"Vimmer here too: moved to Emacs with the wonderful Evil packages. Still a Vimmer, just now an Emacs using Vimmer. :)"
Clojure,3cdxc4,cies010,3,Fri Jul 10 12:33:30 2015 UTC,what should i replace my usage of enlive with?
Clojure,3cdxc4,funnyarticle,3,Tue Jul 7 03:58:11 2015 UTC,There are a number of choices you could make. Why do you want to replace enlive?
Clojure,3cdxc4,funnyarticle,2,Tue Jul 7 04:03:31 2015 UTC,"I enjoy it a lot, it just seems somewhat abandoned"
Clojure,3cdxc4,pauldlynch,2,Tue Jul 7 04:29:36 2015 UTC,"Perhaps Enlive is not so much abandoned as mature?  I notice that it hasn't been updated much recently, and so if anyone has any suggestions for a web scraper library is be interested to hear them too."
Clojure,3cdxc4,Escherize,1 point,Tue Jul 7 11:13:32 2015 UTC,"Is not abandoned, is just at the point were the library is considered mature enough to no make any major updated in it. If it works well, you should keep using it."
Clojure,3cdxc4,funnyarticle,1 point,Tue Jul 7 11:23:21 2015 UTC,"If you use enlive for its html templating, there's always hiccup.  I've made a site with a few tiny examples at http://hiccup.space  If you use it for parsing html, I think it's probably still the best library for that."
Clojure,3cdxc4,flaccidicus,1 point,Thu Jul 9 11:45:08 2015 UTC,"these are great examples, yup i've mostly been using it for html templates"
Clojure,3cdxc4,jballanc,2,Thu Jul 9 16:02:18 2015 UTC,I want replace my usage of TypeScript+C# (privately not at work) with ClojureScript+Clojure.   Are there any fullstack environments for me to try out? Preferably with AngularJS since I have a lot of time invested in that framework.
Clojure,3cdxc4,flaccidicus,9,Tue Jul 7 08:25:56 2015 UTC,"I don't know of anyone building ClojureScript on top of Angular. It's not that you can't (ClojureScript can always call down to JS if need be), it's just that it's not a very natural fit. React, on the other hand, is a much better match and has at least three ClojureScript libraries that I know of built on top of it.  As for ""fullstack"" environments, Clojure tends to eschew frameworks but there's absolutely nothing preventing you from using Clojure and ClojureScript together on your own. In fact, almost all of the web projects I've worked on in Clojure are put together this way.  If you want a bit more of a guided path, try Luminus or Hoplon."
Clojure,3cdxc4,jballanc,3,Tue Jul 7 08:35:05 2015 UTC,"I will abandon the idea of using Angular, I didn't know that there was such a good React support in the community.   As I wrote in my other reply, are there any good resources for sharing code (for example validation logic) between a React app and the back end?"
Clojure,3cdxc4,nevaduck,5,Tue Jul 7 19:07:45 2015 UTC,I think Schema is pretty much exactly what you're looking for!
Clojure,3cdxc4,flaccidicus,8,Tue Jul 7 20:00:30 2015 UTC,"For me the whole point of using Clojurescript was to get as far away from Angular as possible. Objects getting mutated everywhere made very annoying bugs appear in my code. Objects would get changed, and break things in some cases and it was really hard to track down what was going on. Maybe someone will write an immutable angular wrapper, like Om or Reagent for React. But I suggest you check out Reagent. The reagent-template gets you started very quickly. The re-frame patterns is also nice.  I think what I am trying to say is if you are going to go for clojurescipt, use the idiomatic patterns that have been setup by the community. Using Angular will not be a pleasant experience."
Clojure,3cdxc4,yogthos,2,Tue Jul 7 11:04:21 2015 UTC,Reagent looks really awesome! Are there any good resources for sharing code (for example validation logic) between a React app and the back end? Given that the back end is written in Clojure.
Clojure,3cdxc4,homonomonohomo,2,Tue Jul 7 19:05:13 2015 UTC,"Bouncer is a nice Clojure/Script validation library, Schema is another popular library for defining models. There are quite a few libraries that cross-compile nowadays."
Clojure,3cdxc4,jballanc,2,Tue Jul 7 19:10:34 2015 UTC,This:  (defn dragon [i] {:pre (>= i 0)}    (if (= i 0) '()        (let [prev (dragon (- i 1))]             (concat prev '(:l) (fold prev)))))   seems to run much faster than this:  (defn dragon [i] {:pre (>= i 0)}     (if (= i 0) '()         (concat (dragon (- i 1)) '(:l) (fold (dragon (- i 1))))))   Is clojure actually evaluating (dragon (- i 1)) twice each time in the second case? Why?  EDIT: fold is:  (defn fold [list] (invert (reverse list))) (defn invert [list] (map #({:r :l :l :r} %) list))   The code is a (naive) implementation of dragon curves.
Clojure,3cdxc4,homonomonohomo,2,Tue Jul 7 16:54:02 2015 UTC,"Your examples don't run. It looks like you're missing an argument to fold. That said, you likely are evaluating (dragon (- i 1)) twice, but if you turn on *warn-on-reflection* I bet you'll see the real problem: you're forcing Java to reflect on the type of i in order to know which version of - to call. Reflection is a performance killer. Add a type hint to your argument and things will speed up considerably."
Clojure,3cdxc4,jballanc,2,Tue Jul 7 17:43:10 2015 UTC,fold is defined somewhere else in the code:  (defn fold [list] (invert (reverse list))) (defn invert [list] (map #({:r :l :l :r} %) list))   I did not know there was a built-in function by the same name.  Thanks for the comment regarding type hints. I didn't know that was available and had such an impact on performance.
Clojure,3cdxc4,jschm,3,Tue Jul 7 18:39:44 2015 UTC,"Yeah, unfortunately fold (and variants like foldl and foldr) are fairly common FP terms. No reason you can't re-use the name. There's always the :refer-clojure :exclude [...] form you can add to your namespace declaration if you're concerned about any confusion."
Clojure,3cdxc4,homonomonohomo,2,Tue Jul 7 20:07:55 2015 UTC,"I have a hypothesis here, but I'm not entirely sure so take this with a grain of salt: since Clojure is not a pure functional language like Haskell, the compiler cannot guarantee that dragon is free of side-effects. Maybe each call to dragon bumps a counter in a database or something. Thus it has to actually evaluate the function twice."
Clojure,3cdxc4,jballanc,1 point,Tue Jul 7 18:26:37 2015 UTC,"Yeah, that was my hypothesis, too. But I would find it surprising if clojure had no way to declare a function pure (or impure)... I am no expert, but it seems to defeat the point of inmutability.  Even C++ compilers offer (non-standard) ways to do this."
Clojure,3cdxc4,homonomonohomo,3,Tue Jul 7 18:43:18 2015 UTC,"Usually the Hotspot JVM can analyze functions for side-effects, and will cache at the call-site if the function is pure. However, the need for reflection kills this, since the JVM doesn't even know what function it's calling (and therefore doesn't have a fixed call-site to cache to)."
Clojure,3cdxc4,jballanc,2,Tue Jul 7 20:05:02 2015 UTC,"I see, that makes sense.  Apart from *warn-on-reflection*, is there any other warning you recommend enabling? something analogous to -Wall?"
Clojure,3cdxc4,Whats_Calculus,1 point,Tue Jul 7 20:15:18 2015 UTC,"That's the major one, but if you're interested in code-checking/static analysis tools, there's also Eastwood and Kibit."
Clojure,3cdxc4,shriek,2,Tue Jul 7 20:53:49 2015 UTC,Is there a way to abstract out nested if-let clauses?   (if-let [...]   (do               )   (if-let [...]     (do                 )     (if-let [...]   I'm trying to write the equivalent of an if...else statement and it's becoming difficult to read.
Clojure,3cdxc4,jballanc,1 point,Mon Jul 13 22:23:53 2015 UTC,"What would be one driving factor of Clojure? Meaning, if I learn Clojure then what kind of exposure would I have with the platforms out there? E.g. If I learn Java then I can develop apps for Android, Swift = iOS, JS= (mostly) Web, C/C++ = Systems. Where does Clojure fit in this? I see that there are few Web frameworks for Clojures on the sidebar and also it's mentioned in the official site that it's a general purpose language but I'm not sure what answer I would give to others if they ask me where Clojure is dominant at. Edit: Thanks guys for all the answers. It really helped clarify the strength of Clojure to me."
Clojure,3cdxc4,jdeisenberg,6,Tue Jul 7 05:15:21 2015 UTC,"I agree with the other answers that Clojure really is an excellent general purpose language and you will find it in many domains. In my own work I've used it for asynchronous message processing, traditional RESTful web apps, background processing, and even command-line tools (thanks to boot!).  One area where I personally think Clojure excels is ETL (extract-transform-load), for two reasons:   A lot of ETL work has traditionally been done in Java, meaning that there is already a plethora of libraries available. Clojure makes working with data structures ridiculously easy! Seriously, if you can convert your documents into Clojure data structures (and what document can't be converted?), then working with those documents will be a cake-walk."
Clojure,3cdxc4,SpaceCadetJones,5,Tue Jul 7 08:40:13 2015 UTC,"Clojure is a Lisp dialect that runs on the JVM, so you have access to all the Java libraries. http://clojure-android.info/ may answer your questions about developing for Android. Speaking only for myself, I'd say that Clojure is what you use instead of Java if you want to take a functional approach to programming rather than an imperative/object oriented approach."
Clojure,3cdxc4,bostonou,3,Tue Jul 7 05:31:39 2015 UTC,You also get the dynamic and interactive programming style of Lisp. I got into Clojure as I was learning Common Lisp and wanted something with a more functional style and could interop with a large ecosystem
Clojure,3cdxc4,pihkal,3,Tue Jul 7 18:14:03 2015 UTC,"One benefit of learning Clojure is that ClojureScript follows very closely. That opens up web development (and even desktop with Atom/Electron), and a lot of exciting work is being done with React Native (check out mike fikes blog). React Native is moving towards iOS and Android development.  So, Clojure+ClojureScript is getting a pretty wide reach."
Clojure,3cdxc4,green_transistor,3,Tue Jul 7 14:29:43 2015 UTC,"Clojure excels at a lot of things, so it's a legit replacement for many languages in various domains.   But one thing is fairly unique to Clojure: it was designed in part for the multi-core future, so it has many parallel/concurrency options that are both easy and safe to use. Your options include threads, futures, promises, core.async channels, and p* functions, while default immutability wipes out whole classes of synchronization errors.  The only languages that come close to matching the sweet spot of ease/safety for concurrent programming are Go (which is not immutable by default, though it's primary async primitive, channels, mitigate that somewhat) and I believe, Erlang (which I don't know well, but I gather is designed for fault-tolerant, distributed computing). There seem to be several concurrent Haskell libs too, but I'm not familiar with them."
Clojure,3cdxc4,Questy,1 point,Tue Jul 7 06:04:51 2015 UTC,"In web development, I feel the best advantage of using Clojure is resuse of code in server-side and client-side. It's also possible to write a web app entirely in Clojure (no CSS or HTML required)."
Clojure,3cdxc4,yogthos,1 point,Tue Jul 7 08:00:13 2015 UTC,"Does anyone know a good Clojure/CLJS example of wrapping an imperative library into more functional code?  I'm working on a THREE.js wrapper, but the resulting code is naturally very declarative. I was wondering how to write it to be more functional, even if I don't map the original library 1:1."
Clojure,3cdxc4,Questy,3,Tue Jul 7 18:05:34 2015 UTC,"You could take a look at my iText wrapper library for generating PDFs, clj-http is another good example of idiomatically wrapping a Java lib in Clojure."
Clojure,3cdxc4,yogthos,1 point,Tue Jul 7 18:54:49 2015 UTC,I'll take a look. Thanks :)
Clojure,3cdxc4,yogthos,1 point,Tue Jul 7 19:42:05 2015 UTC,"How Clojure Repl is different from others mainstream languages, and why is OS important to the community?"
Clojure,3cdxc4,boraj,2,Wed Jul 8 02:51:01 2015 UTC,Clojure REPL is tightly integrated with the editor. You use it as part of the regular workflow as opposed to a standalone tool for trying out individual functions. You can also connect the editor to a REPL running on a server and interact with a live running application that way.
Clojure,3cb5qi,jdeisenberg,3,Mon Jul 6 15:17:19 2015 UTC,"Looking for feedback and suggestions for more topics. Source is at https://github.com/jdeisenberg/etudes-for-clojurescript  The book contains descriptions of short programs you can write to help you practice ClojureScript. From the preface: ""These tudes are not intended to introduce you to individual ClojureScript concepts. That ground is covered quite nicely by ClojureScript Koans, 4Clojure, and ClojureScript Unraveled. ... [The tudes] are much along the lines of the programming katas given in chapter 10 of Living Clojure by Carin Meier. If Koans, 4Clojure, and ClojureScript Unraveled are programs at the level of chemical elements, in this book you are constructing simple molecules."""
Clojure,3cb5qi,Litra,2,Mon Jul 6 15:17:38 2015 UTC,Testing should be covered
Clojure,3cbqa4,venantius,1 point,Mon Jul 6 17:51:28 2015 UTC,There was a talk that you might find interesting.
Clojure,3cbqa4,qbg,0,Tue Jul 7 01:24:11 2015 UTC,"Thanks for posting this, I'll give it a look."
Clojure,3cbqa4,nzlemming,2,Tue Jul 7 01:58:03 2015 UTC,"Definitely see Elena's work. See also dynalint, it's a similar approach.  I've been interested for a while in a catalog of common Clojure errors, with some kind of pattern matching to try to identify what the problem might be. I'm not sure how feasible that is, but I'd love to try. I haven't had time to get to it, though. @noisesmith was thinking about something similar too, but then got a new job and had no time IIRC."
Clojure,3c17cx,prbroadfoot,5,Fri Jul 3 20:44:02 2015 UTC,See also my post for links to slides and sketchnotes http://biserkov.com/blog/2015/07/01/EuroClojure-2015/
Clojure,3c17cx,jbiserkov,1 point,Fri Jul 3 21:59:41 2015 UTC,Some very good talks in there. Thanks!
Clojure,3c17cx,with_gusto,1 point,Sun Jul 5 09:58:56 2015 UTC,Anyone have recommendations from among these?
Clojure,3bvhgw,mac,3,Thu Jul 2 14:12:06 2015 UTC,Why doesn't this blog have a date on the articles? Weird.
Clojure,3bvhgw,grav,2,Thu Jul 2 18:28:54 2015 UTC,It's weird indeed. Comments indicate that the post is approx 5 months old.
Clojure,3bmx8y,yogthos,18,Tue Jun 30 14:44:36 2015 UTC,Better read IMO:  https://github.com/clojure/clojure/blob/master/changes.md
Clojure,3bmx8y,MyNameIsFuchs,5,Tue Jun 30 15:52:46 2015 UTC,Looking through the HN comments: There is still a ton of confusions about transducers. Also a lot of people making statements that are just wrong.  What could we do about this?
Clojure,3bmx8y,MyNameIsFuchs,2,Wed Jul 1 12:11:48 2015 UTC,There is a strangeloop talk by Rich Hickey you could link to...
Clojure,3bmx8y,lgstein,1 point,Thu Jul 2 12:14:45 2015 UTC,"In light of these new reader conditionals that allow portability to clojurescript, what would be the role of cljx now? Is it not needed at all?"
Clojure,3bmx8y,salaperuna,3,Wed Jul 1 06:09:17 2015 UTC,Correct. Reader conditionals replaces cljx.
Clojure,3bmx8y,jonaen,1 point,Wed Jul 1 13:37:20 2015 UTC,What platform is :cljr?
Clojure,3bmx8y,peeja,3,Wed Jul 1 18:28:06 2015 UTC,"Apparently Clojure-CLR.  Any reason it couldn't be :clj-clr? I know it's not as short as :cljr, but it's less confusing."
Clojure,3bmx8y,moosingin3space,1 point,Thu Jul 2 02:31:59 2015 UTC,"Oh, right, that thing. Huh."
Clojure,3bmx8y,peeja,1 point,Thu Jul 2 18:36:24 2015 UTC,https://github.com/clojure/clojure-clr  http://dev.clojure.org/display/design/Reader+Conditionals
Clojure,3bmx8y,woatbarg,1 point,Wed Jul 1 23:04:25 2015 UTC,"How much closer to Java-free Clojurescript are we now that 1.7 has been released (with reader conditionals)? (As in: I remember that was an important missing part before Clojurescript could compile itself, but I do not remember if there was any other big missing parts as well.)"
Clojure,3bmx8y,livrem,7,Tue Jun 30 21:31:22 2015 UTC,"How much closer to Java-free Clojurescript   Just for saying, I would highly prefer Java Clojurescript's compiler than a Nodejs one.  Edit: Clarifying that I am talking about the compiler."
Clojure,3bmx8y,peeja,1 point,Tue Jun 30 23:25:24 2015 UTC,Why is that?
Clojure,3bmx8y,peeja,0,Wed Jul 1 18:25:32 2015 UTC,Why would?
Clojure,3bmx8y,peeja,0,Wed Jul 1 18:30:16 2015 UTC,Would what?
Clojure,3bmx8y,soulcheck,0,Wed Jul 1 20:17:06 2015 UTC,That.
Clojure,3bmx8y,livrem,1 point,Wed Jul 1 20:21:03 2015 UTC,Remind me of the babe.
Clojure,3bmx8y,mkremins,1 point,Wed Jul 1 20:28:05 2015 UTC,Why would you want Java Clojurescript when you have Java Clojure?   Part of the rationale of Clojurescript is having Clojure running on a host other than JVM (in this case various js engines).
Clojure,3bmx8y,TweetsInCommentsBot,7,Wed Jul 1 09:30:17 2015 UTC,"I am talking about Clojurescript compiler, I would highly prefer this implementation in Java than Nodejs"
Clojure,3bm1q0,sunng,1 point,Tue Jun 30 08:52:23 2015 UTC,"Thanks for pointing this out! I followed the merging of that PR for cider-nrepl, and it seems like it should also be able to debug macros. Also clojurescript support, but I'm not sure on what the status on that was earlier to be honest.  See https://github.com/clojure-emacs/cider-nrepl/pull/220"
Clojure,3bm1q0,salaperuna,1 point,Tue Jun 30 11:51:58 2015 UTC,"Before there was no clojurescript support. Now it's supported, but still untested.  So if you try it, do let us know. :-)"
Clojure,3bm1q0,BruceConnor,1 point,Wed Jul 1 23:50:43 2015 UTC,Is this in the 0.9.1 release of Cider?
Clojure,3bm1q0,underplank,3,Tue Jun 30 14:59:47 2015 UTC,It haven't been released yet. Use the MELPA package and set cider-nrepl version to 0.10.0-SNAPSHOT
Clojure,3bm1q0,BruceConnor,1 point,Wed Jul 1 01:43:29 2015 UTC,For anyone reading this. The #bp macro has been changed to #break.
Clojure,3bc7vr,mac,2,Sat Jun 27 20:58:21 2015 UTC,See also instar: https://github.com/boxed/Instar
Clojure,3bbdnn,rogerallen,3,Sat Jun 27 16:29:21 2015 UTC,That's a great idea!
Clojure,3bbdnn,JonyEpsilon,2,Sat Jun 27 20:09:11 2015 UTC,"Thanks!  This is an idea that has been rattling around in my head for quite a while...the Siggraph paper this was based on came out in 1991!  It was fun to code this up and quite satisfying to see some of the surprisingly beautiful images pop out.  It seems just when I'm getting a bit bored with what it creates, it presents me with something amazing.  Things I could never create myself--even if I were trying."
Clojure,3befor,rwobben,4,Sun Jun 28 13:35:46 2015 UTC,"then I goto the src/clojure-noob directory and do lein run and I see the above error.   To be clear, lein run should be run from the root of your project (that is, where your project.clj is).  If that isn't your problem try lein clean."
Clojure,3befor,Drolyt,1 point,Sun Jun 28 16:44:46 2015 UTC,"thanks for the clarification /u/Drolyt! sorry for the confusion, /u/rwobben"
Clojure,3befor,nonrecursive,1 point,Mon Jun 29 01:39:41 2015 UTC,you also have to add :main clojure-noob.core in your project.clj
Clojure,3befor,yogthos,1 point,Sun Jun 28 13:50:38 2015 UTC,Maybe add this key and value in your project.clj ?  :main clojure-noob.core
Clojure,3befor,cark,1 point,Sun Jun 28 13:51:58 2015 UTC,it looks like it's already added :    :main ^:skip-aot clojure-noob.core   Roelof
Clojure,3b85aj,buovjaga,3,Fri Jun 26 19:09:50 2015 UTC,Excited!
Clojure,3b9lrn,wqhhust,2,Sat Jun 27 02:41:54 2015 UTC,"clojure.java.jdbc/with-db-transaction  I haven't tried this, but assumed it was for doing this"
Clojure,3b6830,ReneFroger,1 point,Fri Jun 26 08:30:46 2015 UTC,"Could someone share usage experiences of using lispy?  I'm a long time vim user who migrated to emacs a few years back. I now use evil, the emacs vi layer, to use emacs like I used vim in the days of yore. I have some bindings to smartparens instead of using paredit, and use vim text objects for managing expressions in some cases.  Do you think I could benefit from lispy?"
Clojure,3b0jft,cjbarre,3,Thu Jun 25 00:11:00 2015 UTC,(fn [coll]    (take (-> coll count inc))     (iterate rest coll)))
Clojure,3b0jft,gilesecoyote,2,Thu Jun 25 03:30:47 2015 UTC,"I really like that! I didn't even think about using take, and I don't think I knew about iterate. Nice use of the thread macro too. Any advice on arriving at a solution like this next time?"
Clojure,3b0jft,beppu,1 point,Thu Jun 25 12:30:52 2015 UTC,removed extra paren after inc:  (defn ex-2-1 [coll] (take (-> coll count inc) (iterate rest coll)))   example:  (ex-2-1 '(1 2 3 4))  => ((1 2 3 4) (2 3 4) (3 4) (4) ())
Clojure,3b0jft,MyNameIsFuchs,3,Thu Jun 25 05:08:42 2015 UTC,"You've already been given a better version of what you want to accomplish (and just btw, (reductions conj [] coll) might also work for you).  But given that nobody answered your actual question (Like Rich Hickey said ""Programmers know the benefits of everything and the tradeoffs of nothing""). Here actually the costs:  https://www.innoq.com/blog/st/2010/04/clojure-performance-guarantees/  To see what into does you'll have to read the source. Then you'll see a (reduce conj to from) so your run-time is linear in that case. Just because it happens to end up like a reverse doesn't mean that it didn't do the entire thing inefficiently."
Clojure,3b0jft,bucketh3ad,2,Thu Jun 25 12:15:01 2015 UTC,"If you want to stick with explicit recursion,  it would be more idiomatic to use seq instead of both not-empty and the (into '() (rseq ...)) combo. Also, with only a single condition to check for, you could easily use if instead of cond.  Otherwise, you could use a functional solution using (iterate rest coll) like the one gilescoyote posted (though it has a typo with an extra paren)"
Clojure,3axuyh,donbonifacio,7,Wed Jun 24 11:10:18 2015 UTC,"Were still not sure on how to test service interactions   At MixRadio we have something like 120 services (mostly in Clojure). We use rest-cljer to isolate the REST calls between services for testing.  It works by spinning up a jetty instance to handle the requests, validates that the expected request params etc are passed and returns the specified response. It's a wrapper for another in-house, earlier, java project called rest-driver.  We switch rest-driver in simply by setting the dependency's URI using environment variables and environ. As such we can run our service in an isolated or integrated way depending on the tests that are running.  We also have a lein template for our clojure services available here: https://github.com/mixradio/mr-clojure"
Clojure,3axuyh,lebski88,1 point,Wed Jun 24 22:52:56 2015 UTC,"We are following MixRadio for quite a while. :) Haven't heard of rest-cljer, nice one. Thanks for the hint.  You also have us the ideia of a custom lein template. We are still figuring out how to build the services and will do something like your mr-clojure (Otto's tesla-microservice[1] is another source of inspiration).  [1] https://github.com/otto-de/tesla-microservice"
Clojure,3axuyh,kachayev,3,Thu Jun 25 08:33:07 2015 UTC,"Good start! We've also shared our experience with microservices few months ago, maybe you will find something useful - https://speakerdeck.com/kachayev/microservices-in-clojure"
Clojure,3axuyh,kachayev,2,Wed Jun 24 22:19:12 2015 UTC,"Nice overview, shared it. Have you considered aleph for the async server? HttpKit seams stalled, don't know if it's just my impression."
Clojure,3av8i4,citrined,6,Tue Jun 23 19:49:17 2015 UTC,"I work for Curiosity.com mostly using Clojure (some Python, a smidgeon of Javascript). I'm remote 90-95% in a month traveling by train (3 hours) to Chicago, IL (live in Springfield, IL) for major meetings (read: beer and food).  We recently hired another developer and it wasn't too hard convincing someone to try Clojure. From my perspective, worker supply isn't really an issue unless you are hiring a team starting from 0 in the language. IMO the tooling that an organization builds up around monitoring/testing/deployment needs to exist before you begin bringing in people who haven't worked with Clojure ever."
Clojure,3av8i4,emidln,2,Tue Jun 23 21:55:42 2015 UTC,Just a shout out to you emidln: you were part of the team that hired me for my first clojure job!  Anyway I'm doing clojure freelancing these days in Europe.  Hope Chicago is treating you well buddy!
Clojure,3av8i4,EtherPonzi,1 point,Fri Jun 26 08:57:01 2015 UTC,Glad to have converted you from the land of types and order to EVAL ALL THE THINGS! LMK if you make it back to North America.
Clojure,3av8i4,emidln,2,Tue Jun 30 03:12:42 2015 UTC,"I live in Berlin and have been doing freelance JS & Ruby etc for years. I do clojure for passion every night at home. If I could work with it, I would be so happy. Living in Berlin (EU Citizen), but open to other cities. PM me maybe ;)"
Clojure,3av8i4,lkubjlkhjb,1 point,Wed Jun 24 12:05:17 2015 UTC,"At EuroClojure there were lot of people from Germany. Companies like Codecentric, Stylefruits, Zalando. Maybe you could check with those. Wish there were more from the Netherlands :)"
Clojure,3av8i4,gsserge,2,Tue Jun 30 13:46:30 2015 UTC,We're always hiring awesome functional developers!  Clojure/Scala/Go/Erlang/Wahtever  Also Software Defined Radio experts..  bastille.io
Clojure,3av8i4,netw1z,1 point,Wed Jun 24 16:40:27 2015 UTC,"Me, clojurescript for a startup, freelance and remote"
Clojure,3av8i4,dustingetz,1 point,Wed Jun 24 02:51:03 2015 UTC,"My company is basically a Clojure shop, at least for backend work. We exist."
Clojure,3av8i4,kevinmershon,1 point,Wed Jun 24 03:23:07 2015 UTC,"My company (actually, my team) is based on Clojure. we provide major ebook service to customer in south korea."
Clojure,3av8i4,ja3ck,1 point,Wed Jun 24 05:10:50 2015 UTC,I qualify on both counts. I do remote freelance Clojure and ClojureScript development. Recently I've been doing API work but I've also done mobile and web development.
Clojure,3av8i4,daveliepmann,1 point,Wed Jun 24 07:09:58 2015 UTC,I'd love to :)
Clojure,3av8i4,dkvasnicka,1 point,Wed Jun 24 07:32:33 2015 UTC,Working remote for a startup.
Clojure,3av8i4,emil0r,1 point,Wed Jun 24 08:01:04 2015 UTC,I work as an independent contractor doing mostly remote Clojure and ClojureScript stuff these days.  I've previously done a lot of Ruby and JavaScript.
Clojure,3av8i4,scttnlsn,1 point,Wed Jun 24 20:03:20 2015 UTC,"My Los Angeles based startup is using Clojure for the backend web service. I'm currently the only developer on the project, but we are looking to hire at least one more asap. http://purpledelivery.com  Message me if you're interested, remote or local LA."
Clojure,3av8i4,clelwell,1 point,Fri Jun 26 04:18:54 2015 UTC,"I'm the CTO at Cognician. I live and work 2 hours from the office. We have several remoters on the team, some in the same town as the office and some in other timezones/continents/hemispheres."
Clojure,3av8i4,afhammad,1 point,Fri Jun 26 08:48:16 2015 UTC,We at http://buttercloud.com use Clojure(Script) for in-house products. Most of us work remotely.
Clojure,3auve3,yogthos,1 point,Tue Jun 23 18:19:45 2015 UTC,"I don't know any, but I'd use core.async to achieve similar effects."
Clojure,3ava53,uhef,1 point,Tue Jun 23 20:00:34 2015 UTC,"I just started developing on a proto using Clojure + ClojureScript and wanted to get my Vim toolchain working. For me REPL is one of the big things in Clojure so I wanted to integrate it to my project as well as possible. Like others before me, I had some issues getting REPL integration in Vim to work so I decided to write yet another blog post about it. I hope this will be of help and perhaps save someone some time."
Clojure,3atwy5,jballanc,2,Tue Jun 23 14:01:52 2015 UTC,done! :)
Clojure,3atwy5,yogthos,3,Tue Jun 23 15:28:28 2015 UTC,Can we get a spell check? ;)
Clojure,3atwy5,evilduck,1 point,Wed Jun 24 15:58:21 2015 UTC,"Awesome, thanks!"
Clojure,3at853,bilus,2,Tue Jun 23 09:13:08 2015 UTC,"Nice one, IMO it's both elegant and does the job. Although I don't see why reforms need any binding to Om/Reagent. Shouldn't it be just pure data transformation into hiccup/sablono free of any bindings?"
Clojure,3at853,skratlo,2,Tue Jun 23 11:53:42 2015 UTC,"Good point.  It does generate hiccup but it does so with appropriate handlers for on-change etc. so as to bind inputs to data (om cursors or reagent ratoms). This way when you write  (input ""Name"" ""Type in your name"" user [:name])   and type anything into input, it gets automatically saved to the ratom/cursor.  Now because Om uses different functions (core.om/update! and core.om/transact!) while Reagent uses swap! and reset! I had to address that somehow. I've decided to use protocols.   See https://github.com/bilus/reagent-reforms/blob/master/src/reforms/binding/reagent.cljs for an example."
Clojure,3at853,skratlo,2,Tue Jun 23 12:28:26 2015 UTC,"Ah ok, I missed the data binding part. It makes sense and protocols seems to be the way to go."
Clojure,3aojpf,mac,1 point,Mon Jun 22 05:30:53 2015 UTC,This is exactly what I was looking for. Especially like that it gives a default for deployment.
Clojure,3aojpf,aptmnt_,1 point,Mon Jun 22 09:02:04 2015 UTC,"Wow, this fits my needs perfectly."
Clojure,3aojpf,emsimot,1 point,Mon Jun 22 13:06:04 2015 UTC,This looks very useful indeed.
