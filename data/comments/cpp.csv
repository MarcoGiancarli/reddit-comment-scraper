cpp,3e4yg5,pmedv,3,Wed Jul 22 00:10:00 2015 UTC,"My initial response was that std::function is a little heavy weight for this and that a constructor template would be better, but since this is a bindless lambda, it probably satisfies the small object optimization.   This is pretty neat!"
cpp,3e4yg5,fsecilia,8,Wed Jul 22 01:33:43 2015 UTC,"However, even if std::function can avoid dynamic memory allocation, you'll lose inlining, which is significant. I do not recommend this technique. It is better to use a lambda to default-construct an object, set its fields, and then return that object so it can be copied as const. This is likely to be fully inlined and NRVOed."
cpp,3e4yg5,STL,7,Wed Jul 22 01:39:02 2015 UTC,const auto font = []() {     Font font;     font.weight = Weight::VeryBold;     font.slant  = Slang::Oblique;     font.halign = Anchor::Left;     return font; };   instead of  const Font font = Font([] (Font& font) {     font.weight = Weight::VeryBold;     font.slant  = Slang::Oblique;     font.halign = Anchor::Left; });
cpp,3e4yg5,minno,7,Wed Jul 22 02:54:21 2015 UTC,"Better in every way except for the minor typo which I know I've made plenty of times and I'm sure other people are also likely to make, namely you forget to actually invoke your lambda expression, so font ends up being a lambda expression itself, rather than the result of calling one.  The wall of text error messages that ensues is not fun."
cpp,3e4yg5,sakarri,3,Wed Jul 22 03:21:48 2015 UTC,"Wouldn't you want to immediately call the lambda in the first example, i.e. add a trailing pair of parentheses?"
cpp,3e4yg5,quicknir,3,Wed Jul 22 03:21:15 2015 UTC,"Meh, I'm happy to use GCC extensions."
cpp,3e35uu,omnompikachu,41,Tue Jul 21 16:31:48 2015 UTC,nullptr_t
cpp,3e35uu,meetingcpp,9,Tue Jul 21 16:53:35 2015 UTC,"Or the various levels of ""nullness"" in XML   <x><foo></foo></x> : ""The value is nothing."" <x><foo/></x> : The same. <x><foo xsi:nil=""true""/></x> : ""The value  of the string is asserted to be the empty set."" <x></x>: ""The element containing the value hasn't been provided.  It's value cannot be ascertained from the document."""
cpp,3e35uu,YouFeedTheFish,24,Tue Jul 21 21:56:19 2015 UTC,"A lot of coding principles have a broader applications:   Short, clear code is better than convoluted or hard-to-read code. Usually, the compiler will even make it faster than a ""clever"" formulation. Outside of programming, this is equally true.  A bug that shows up in one place is often due to a problem further up the call stack. Free everything you malloc. Always clean up after yourself or stuff will pile up.   Be aware of parallel overhead. Sometimes it takes more time to communicate and get everyone on the same page than it would take to just do the job yourself.  In a similar vein, if you need to communicate something, do it as early as possible. Waiting is pointless and will only be more costly.   I'm sure I could come up with a dozen more of these. Maybe I should put silly graphics on each one and publish a stupid ""philosophy of programming"" book that people will buy for their IT friends and family. Hmm..."
cpp,3e35uu,Quantumtroll,8,Tue Jul 21 18:25:32 2015 UTC,"Short, clear code is better than convoluted or hard-to-read code.   I always liked the quote from Kernighan regarding the subject:   Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.   And in real world experience I've seen code savants pass off their astronautically architected code to merely exceptional programmers who struggled for months before finally rewriting most of it to ""fix"" it."
cpp,3e35uu,vanhellion,18,Wed Jul 22 02:22:50 2015 UTC,"Indeed, sometimes I even find it to be euphoric."
cpp,3e35uu,logiasin,8,Tue Jul 21 16:39:49 2015 UTC,Unlike phony natural language.
cpp,3e35uu,2Punx2Furious,2,Tue Jul 21 18:23:53 2015 UTC,"Not because of any phony scripting language's blessing, but by the power of the language itself?"
cpp,3e35uu,CandyCorns_,13,Tue Jul 21 19:49:26 2015 UTC,"All of it. I view software development as an exercise in ontology where I am constantly asking myself what is the essence of such and such feature and then defining it in code. E.g. If you are implementing an email server, eventually you have to ask the highly philosophical question, ""what is email-ness?"""
cpp,3e35uu,oracleoftroy,5,Tue Jul 21 21:04:15 2015 UTC,"Yes. All of it. It was, quite literally, invented by philosophers before computers even were. CS is merely applied philosophical tools."
cpp,3e35uu,rafajafar,10,Wed Jul 22 01:50:58 2015 UTC,space and time_t
cpp,3e35uu,Railorsi,7,Tue Jul 21 17:03:25 2015 UTC,This should be the title of a book.
cpp,3e35uu,ericanderton,5,Tue Jul 21 19:28:09 2015 UTC,"time_t   If I ever see a call to get the current time I wonder how long it takes for that function call to execute and if the time it reports back is for the instance of time when the call began, ended or at some point inbetween.  And then I remember it's probably impossible to know for sure just like so many other things in life.  :("
cpp,3e35uu,quzox,2,Tue Jul 21 23:37:22 2015 UTC,wouldn't a debugger help there (step into)?
cpp,3e35uu,rogueyoshi,2,Wed Jul 22 00:36:32 2015 UTC,"If you call it twice, you can put some bounds on it."
cpp,3e35uu,o11c,1 point,Wed Jul 22 01:16:39 2015 UTC,"The real question is how many loop iterations can you get through before the clock even ""ticks""."
cpp,3e35uu,crackez,4,Wed Jul 22 02:43:52 2015 UTC,#include <future>
cpp,3e35uu,Zwergner,1 point,Wed Jul 22 02:23:38 2015 UTC,Too bad it hasn't been implemented yet... ;-(
cpp,3e35uu,crackez,8,Wed Jul 22 02:44:53 2015 UTC,Duff's Device?
cpp,3e35uu,Crazy__Eddie,4,Tue Jul 21 19:35:54 2015 UTC,"10 Print ""Hello World""   20 Goto 10"
cpp,3e35uu,motiv999,3,Tue Jul 21 18:19:00 2015 UTC,Even made it uneven so you get the spiral instead of just a flashing line on the bottom.
cpp,3e35uu,Crazy__Eddie,3,Tue Jul 21 19:34:56 2015 UTC,I found out today that our framework says that integer zero is an empty string but not null.
cpp,3e35uu,david0mp,5,Wed Jul 22 01:58:59 2015 UTC,// wtf did i do to deserve this
cpp,3e35uu,mrcactus28,5,Tue Jul 21 19:17:28 2015 UTC,std::being   As a frequent typo that I make.
cpp,3e35uu,Predelnik,2,Tue Jul 21 23:53:47 2015 UTC,"Plan9 is pretty grand, but that's more design-wise than code-wise."
cpp,3e35uu,bhg_,2,Tue Jul 21 17:54:21 2015 UTC,// why
cpp,3e35uu,NotScrollsApparently,2,Tue Jul 21 20:16:15 2015 UTC,"I'm rather fond of the Python's documentation for types.CodeType:  code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,       constants, names, varnames, filename, name, firstlineno,       lnotab[, freevars[, cellvars]])  Create a code object.  Not for the faint of heart."
cpp,3e35uu,o11c,2,Wed Jul 22 01:19:49 2015 UTC,Equality of values.
cpp,3e35uu,andrewsutton,1 point,Wed Jul 22 01:37:36 2015 UTC,identity of indiscernibles?
cpp,3e35uu,ThisIs_MyName,2,Wed Jul 22 02:25:27 2015 UTC,"Nice try, Herr Leibniz :) Doesn't work for user-defined types."
cpp,3e35uu,andrewsutton,3,Wed Jul 22 03:00:50 2015 UTC,"Not anything specifically.  But there's a ton of stuff around programming that is nothing but philosophy:   Virtually everything going on over in /r/rust.  Ever since the language was started, it's been one long philosophical discussion after another; in a good way.  The language's direction has benefited greatly from it. The D community was like that from 2001-2010 or so.  Lots of debate and philosophy in the context of new language development.  Great stuff.  Especially when people would go head-to-head with Walter Bright or Andrei Alexandrescu.  Doubly so when they would argue with each other.   Edit: now that I think about it:   SQL won't let you compare values to NULL.  So WHERE column_name = NULL will never evaluate to true.  For that matter, common operations like count(column_name) will only consider rows where column_name is not NULL.  So a SQL NULL is not a value, but another state entirely.  This is like saying that ""nothing"" is the total absence of value or state at all, apart from zero. I always kind of liked how C/C++ use 'void' as meaning 'devoid of any type'.  It has a certain finality to it that is apart from any use of NULL or zero."
cpp,3e35uu,ericanderton,3,Tue Jul 21 19:31:10 2015 UTC,"Not in C++ specifically.  The way the fixed point combinator (in various forms and guises) tends to come back is fascinating, though, as is the Curry-Howard correspondence."
cpp,3e35uu,jesyspa,3,Tue Jul 21 19:03:32 2015 UTC,"Type coercion in conditionals is Colbert-esque. You don't need the truth, truthiness will suffice."
cpp,3e35uu,hexasquid,1 point,Tue Jul 21 23:20:13 2015 UTC,Philosophical in that my view of the world has darkened considerably.
cpp,3e35uu,staticassert,3,Tue Jul 21 20:52:53 2015 UTC,"if ( 2 * b || ! 2 * b )     kill(getpid(), SIGKILL);"
cpp,3e35uu,boredcircuits,1 point,Tue Jul 21 23:13:01 2015 UTC,https://books.google.com/books?id=w5VQAAAAMAAJ&q=aristotle+inauthor:Grady+inauthor:Booch&dq=aristotle+inauthor:Grady+inauthor:Booch&hl=en&sa=X&ved=0CC4Q6AEwAmoVChMIu_GD6d3sxgIVJnmmCh1pVQex
cpp,3e35uu,michaelmalak,1 point,Tue Jul 21 17:21:40 2015 UTC,"The nature of numbers becomes ponderous when dealing with decimals and floats.  The limited size of the value in memory contains a mantissa (2 to the power of an exponent) and data bits.  Depending on the protocol, the accuracy of the numbers and the number of values ""in between"" values which can be represented varies.    When dealing with edge cases (like 1/3), there are human decisions programmed into the mathematical functions that render an answer ""close enough."""
cpp,3e35uu,YouFeedTheFish,2,Tue Jul 21 22:01:55 2015 UTC,"Python:  from future import *  I always liked that terminology.    I think people would adopt Python 3 faster if they changed that module to be called ""present."" /s"
cpp,3e35uu,MallocNofree,3,Tue Jul 21 22:00:15 2015 UTC,I think people would adopt Python 3 faster if they followed the Ruby approach and EOL'd Python 2.
cpp,3e35uu,MsEtheldreda,1 point,Wed Jul 22 00:20:34 2015 UTC,"I'd go more along with import this, but that's kind of cheap since the whole point of it is philosophical.  >> import this The Zen of Python, by Tim Peters  Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!"
cpp,3e35uu,d4rch0n,2,Wed Jul 22 01:10:24 2015 UTC,"In one of the major compiler theory books, don't remember if it was the Dragon Book (Aho, Sethi, Ulman) or Alan Holub's ""Compiler Design in C"", in the preface the authors asked that none of the algorithms be used in any form of weapon development."
cpp,3e35uu,ripred3,-4,Tue Jul 21 23:48:56 2015 UTC,no
cpp,3dzv6i,join_the_fun,73,Mon Jul 20 21:41:07 2015 UTC,"My heart stopped for a second there when I read was voted out and thought it meant it had been rejected.   Congrats, this is great!"
cpp,3dzv6i,Elador,42,Mon Jul 20 21:58:08 2015 UTC,"Sorry for the heart attack. That's just how the committee speaks of these things. It's voted ""out"", as in it's voted in. :-)"
cpp,3dzv6i,eric_niebler,20,Mon Jul 20 22:24:26 2015 UTC,This explains so much about c++
cpp,3dzv6i,Herbert_Von_Karajan,3,Tue Jul 21 15:28:16 2015 UTC,Are you in or out?
cpp,3dzv6i,cogman10,14,Tue Jul 21 00:04:53 2015 UTC,Mine too when I read the tweet.
cpp,3dzv6i,GYN-k4H-Q3z-75B,5,Mon Jul 20 22:07:52 2015 UTC,"I was like... ""NOT AGAIN, AT THIS RATE WE'RE NEVER GONNA GET CONCEPTS UNTIL 2027""  phew ;)"
cpp,3dzv6i,superfunc,1 point,Tue Jul 21 09:23:28 2015 UTC,I nearly pooped my pants
cpp,3dzv6i,Houndie,14,Tue Jul 21 15:48:27 2015 UTC,"Okay so there's a lot of people asking what concepts are in this thread, so I thought maybe I'd spend a few minutes writing up what I remember of them.  Disclaimer:  I haven't read the TS, and I'm working off of memory of last year's CPPcon talk.  Note that this talk is really good, and if you have time you should totally watch it!    If I screw something up, please correct me and I'll do my best to fix my post.    Why concepts?  Basically right now when you use a template function (or class), the compiler has to scan the instantiation tree to make sure what you're doing is legal.  Look at the following code for example:  class Foo {    Foo(const Foo & other) = delete; };  template< class T > void f(const T & t) {    T copy(t);  //Error occurs when instantiating this line }  int main() {    Foo foo;    f(foo);  //Error occurs when compiling this line }   Now this is fairly straightforward to see...the problem is that we're trying to copy construct Foo, and Foo has a deleted copy constructor.  However, I'm sure most people with templates have had weird obscure errors that occur with 3 subtypes and 8 levels deep through a third party library that are an absolute pain to parse why your specific template instantiation failed.  Wouldn't it be great to know that as soon as you called the function?  This is where concepts can help.    Defining Concepts  Concepts are a new thing to the language.  There's lots of ways to define them but the basic idea is we define a certain thing that the class can do.  Sort of like an interface class, but for duck typing.  A CopyConstructable concept would tentatively look like this.  template< class T > concept bool CopyConstructable = requires( T t )    { T(t) -> T }   This is saying the following things:   I'm defining a concept named CopyConstructable It takes one template parameter, T. An example of a T is named t (This is simply to avoid using std::declval for clarity purposes.) If I call T's constructor with a t, the result is of type T, basically confirming that this is a legal function.   Tada! You now have a CopyConstructable concept.  Note:  I'm a bit fuzzy on the exact syntax to create a concept so if you really understand this, please proof my concept above.  Thanks!    Using Concepts  The basic way to use a concept is like this:  template< class T >    requires CopyConstructable<T> void f(const T & t){ ... }   Now, when we call f with Foo we get an immediate error, since Foo is not copy constructable.  Nice!    Syntactic Sugar  A few things that are also becoming standard to save on space.  If your concept only takes one template parameter, you can simply type this  template<CopyConstructable T> void f(const T & t){ ... }   And if you don't actually need to know the typename T in your function, you can simply write.  void f(const CopyConstructable & t){ ... }     Extra  Additionally, the TS provides the auto syntax to functions as well.  It's mostly unrelated to using concepts, but you can write this.  void f(const auto & t){ ... }"
cpp,3dzv6i,tpecholt,3,Tue Jul 21 13:33:46 2015 UTC,All these are fine. But when I was reading the TS there were some more controversial points:   concepts introductions bring another meaning for {} blocks somebody proposed to remove the bool in concept bool name = xyz; syntax since there is no other option anyway. I think it's not a bad idea Concepts TS supports both concepts defined as variables and concepts defined as functions. The usage is different e.g. CopyContructible<T> vs CopyContructible<T>() so this can bring a lot of confusion and a need to inspect definition of conceps every time to be able to use it correctly. Someone again proposed to use only variable concepts.   Do you think there will still be time to address these important points?
cpp,3dzv6i,pfultz2,1 point,Tue Jul 21 14:27:15 2015 UTC,"somebody proposed to remove the bool in concept bool name = xyz; syntax since there is no other option anyway. I think it's not a bad idea   I don't like this idea. I would hope that eventually we will get real concepts(with multi-phase checking and concept mapping) not just predicates. I guess we could write auto concept or explicit concept however, it could be confusing when concept by itself means something completely different."
cpp,3dzv6i,pfultz2,2,Tue Jul 21 17:12:37 2015 UTC,"Currently, you can write this to check the requirements:  #define REQUIRES(...) typename std::enable_if<(__VA_ARGS__)>::type  template< class T, REQUIRES(std::is_copy_constructible<T>()) > void f(const T & t){ ... }   Which will produce short informative error message just like the requires clause. You even check requirements in a similar way(see here and this library here which emulates many of the concept checking). So the current way of checking type requirements can use some syntactic sugar to make it a lot clearer. Unfortunately, requires and enable_if are not interchangeable, so you can't write this:  template< class T > requires std::is_copy_constructible<T>() void f(const T & t){ ... }   Nor this:  template< class T > concept bool CopyConstructible = std::is_copy_constructible<T>();   Which will probably be a chapter(or two) in Scott Meyers' Effective Concepts book."
cpp,3dzv6i,samkellett,2,Tue Jul 21 17:28:49 2015 UTC,"a macro-less way i like to use is something like this:  template <bool T> using requires_t = std::enable_if_t<T, std::size_t>;   and can be used like so:  template <typename T,   requires_t<std::is_copy_constructible<T>{}> = 0> void f(const T &t) { ... }"
cpp,3dzv6i,andrewsutton,2,Tue Jul 21 17:50:25 2015 UTC,You can absolutely write both of those. Concepts lite would have been a non-starter without that compatibility.   I'm surprised you didn't know that. Or are you trying to spread misinformation?
cpp,3dzv6i,pfultz2,1 point,Tue Jul 21 20:18:09 2015 UTC,"You can absolutely write both of those.   Really? Then things have changed quickly. A couple of months ago, you told me it was not possible(only booleans allowed with no implicit conversions). However, if that is possible than that is great to hear, and sorry for spreading misinformation."
cpp,3dzv6i,Houndie,1 point,Tue Jul 21 20:24:54 2015 UTC,"As mentioned below, you don't really need a macro since enable_if_t is a thing.  The problem this this strategy is that it's very annoying to write type_traits for member functions and other SFINAE constructs...you need to make a trait for each one (has_function_one, has_function_two, etc).  void_t can help fill in the gaps, however both of these should become much less necessary once we get proper concepts."
cpp,3dzv6i,pfultz2,1 point,Tue Jul 21 18:13:23 2015 UTC,"As mentioned below, you don't really need a macro since enable_if_t is a thing.   You shouldn't use enable_if_t as its harder for the compiler to diagnosis the error(see bug for clang here). However, something like this will still have good diagnostics:  template<class T> using CopyConstructible = typename std::enable_if<(std::is_copy_constructible<T>())>::type; template< class T, typename = CopyConstructible<T> > void f(const T & t){ ... }    The problem this this strategy is that it's very annoying to write type_traits for member functions and other SFINAE constructs...you need to make a trait for each one (has_function_one, has_function_two, etc).   I am not sure what you are referring to. Definition of type traits work the same way as Concepts Lite does.   void_t can help fill in the gaps   void_t is way too verbose for defining concepts or type traits."
cpp,3dzv6i,andrewsutton,1 point,Tue Jul 21 19:29:36 2015 UTC,"Oh.. wait.  You're relying an implicit conversion.  Change the parens to ::value and it's fine.   Still, that's a very subtle point on which to claim incompatibility. Perhaps you'd like to explain why your example doesn't work?"
cpp,3dzv6i,pfultz2,1 point,Tue Jul 21 20:21:01 2015 UTC,"Change the parens to ::value and it's fine.    Except I never write it like that, neither does Eric Niebler in his ranges-v3 library, nor does Concepts Lite write it using ::value.   Still, that's a very subtle point on which to claim incompatibility.   It still is a problem. I would love to be able to do this:  #if HAS_CONCEPTS #define REQUIRES(...) typename=void> requires (__VA_ARGS__) && Bool<true #else #define REQUIRES(...) typename std::enable_if<(__VA_ARGS__)>::type #endif  template< class T, REQUIRES(std::is_copy_constructible<T>()) > void f(const T & t){ ... }   So it uses requires when available and falls back on enable_if when it is not. However, its not interchangeable. I could try to define it like this:  #define REQUIRES(...) typename=void> requires Bool<(__VA_ARGS__)   But I lose error reporting for constraints.   Perhaps you'd like to explain why your example doesn't work?   I'll leave that for Scott Meyers."
cpp,3dzv6i,andrewsutton,3,Tue Jul 21 20:48:20 2015 UTC,"Why wait for Scott? I wrote the thing.  It was a conservative decision, made during a CWG meeting, to disallow implicit conversions during normalization. There was a concern that it could lead to evaluations that didn't agree with the logical structure of a constraint.  It's possible that the decision could possibly be relaxed in the future, but that discussion needs to go through EWG."
cpp,3dzv6i,andrewsutton,2,Tue Jul 21 22:49:25 2015 UTC,"Great summary.   I would write body of CopyConstructible as just this:  T{t};   Constructing an object of type T obviously has T so you don't need the extra -> T bit. That's for when you want the return type to have some extra qualification.  Also, the additional auto bit lets you do a lot of other stuff. Like this:   tuple<auto...> ts = make_tuple(...);   or:   vector<int, auto> = get_vector(...);   and you can use a concept name wherever auto appears:  tuple<Integral...> ints = make_tuple(0, 0u); // Integral is a concept   And also in functions:  Iterator next(Iterator i); // Iterator is a concept   The last bit is new :)"
cpp,3dzv6i,tecknoize,1 point,Wed Jul 22 00:07:19 2015 UTC,The last bit is interesting. Isn't it like structural typing?
cpp,3dzv6i,andrewsutton,1 point,Wed Jul 22 03:39:43 2015 UTC,"No, it's not structural.  It's syntactic sugar for  template<Iterator T> // Iterator is a concept T next(T i);   And the declaration of T imposes constraints."
cpp,3dzv6i,Houndie,1 point,Wed Jul 22 03:46:39 2015 UTC,Thanks for the clarifications!
cpp,3dzv6i,Matthew94,1 point,Wed Jul 22 04:13:43 2015 UTC,Is it kind of like a type class in Haskell?
cpp,3dzv6i,andrewsutton,1 point,Tue Jul 21 22:11:42 2015 UTC,No. Concepts are compile time predicates.
cpp,3dzv6i,excessdenied,7,Tue Jul 21 22:50:05 2015 UTC,"What's the biggest advantages with this? I'm thinking self documenting template code and better error messages, but what more? Could compile times be reduced (since the compiler maybe can make more assumptions)?"
cpp,3dzv6i,spotta,4,Tue Jul 21 05:34:43 2015 UTC,Compile times are supposed to be shorter.  concepts allow short circuiting of errors (things fail faster).
cpp,3dzv6i,excessdenied,4,Tue Jul 21 06:09:50 2015 UTC,Only shorter when there's an error or shorter in general?
cpp,3dzv6i,encyclopedist,7,Tue Jul 21 06:20:17 2015 UTC,"Due to use of SFINAE, even in a well-formed code there is a lot of (soft) failures. Which are now supposed to fail quicker. So, I would expect shorter build times in general.  Also total amount of things for the compiler to parse and instantiate is supposed to shrink due to replacement of many template constructs (like complex SFINAE predicates) with concept checks.  But to see these effects, the libraries shall be rewritten. So we probably have to wait several more years for STL2, before we can enjoy the full power of Concepts."
cpp,3dzv6i,andrewsutton,4,Tue Jul 21 09:40:03 2015 UTC,"It actually depends... if you're aggressively using SFINAE and type traits to constrain your templates in a principled way, then concepts will give you a big speedup. By my measurements last year with GCC, it's a speed up by order an of magnitude.  BUT -- and this is a huge BUT -- you only get that speedup if you are using type traits to emulate concepts everywhere. Most people don't do that.   That performance boost was largely due to the fact that concepts don't require you to instantiate a ton of templates to check for valid syntax. That's all internalized by language now.  On average, there will probably be a slight performance decrease due to the overhead of processing template constraints (and this is relative to size of the constraint). In my experience, I haven't been able to notice any difference.  Except for this one bug I had in the implementation that caused a 2 minute compile of 30 lines of code. Accidentally exponential algorithms are not good."
cpp,3dzv6i,encyclopedist,1 point,Tue Jul 21 22:57:01 2015 UTC,"Thanks for clarification! ""Aggressively using"" - does it mean ""like Range-v3""? Indeed, probably there are not many libraries like that currently."
cpp,3dzv6i,andrewsutton,1 point,Tue Jul 21 23:41:07 2015 UTC,"Yup. I won't claim that all of the background noise goes away (I missed the target for certain kinds of constraints -- hope to improve that moving forward), but a lot of it will."
cpp,3dzv6i,m_0g,19,Wed Jul 22 00:42:40 2015 UTC,"As someone who thinks they know a moderate amount about C++ and tries to keep up with the language's development, I'm mostly just confused by this tweet - what exactly are the ""Concepts TS"" and what's the big deal here? My only guess is this is something to do with a new C++ standard.  Edit: for my fellow confused C++ers, the tweet seems to be referring to a proposed extension to C++ templates, called ""concepts"".  Sounds interesting, though the idea of axioms, described a little lower on the wikipedia page about ""concepts"", also sounds super cool.  For the lazy, my basic understanding is that concepts are basically a way of saying ""classes supplied to this template must support the following operators"".  Axioms are a way of saying that certain properties of concepts will satisfy certain rules (the wiki article has a good example for associativity).  my only gripe is that concepts are hard to talk about while not sounding silly :P"
cpp,3dzv6i,andrewsutton,30,Tue Jul 21 01:01:18 2015 UTC,"A ""TS"" is a ""Technical Specification"". In this case it is an (optional) extension of the ISO C++ Standard (language or library). A TS provides a way for the committee to publish more experimental features in order to gain implementation and user experience before committing to change the C++ Standard.  The ""Concepts TS"" is a set of language features that aims to (dramatically) improve support for generic programming. Writing a tutorial is a bit beyond me right now but this paper is a reasonable introduction to the feature set: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3701.pdf. The introduction needs to brought up to date with the spec.  In short, Eric's tweet is right. This will change how C++ is written.  TLDR: It's a fundamental, not incremental change to the language. I need to write a paper."
cpp,3dzv6i,m_0g,10,Tue Jul 21 01:22:16 2015 UTC,"A ""TS"" is a ""Technical Specification"". In this case it is an (optional) extension of the ISO C++ Standard (language or library). A TS provides a way for the committee to publish more experimental features in order to gain implementation and user experience before committing to change the C++ Standard.   Thank you for the explanation, that definitely helps me a lot to understand how this actually fits in with current C++.   The ""Concepts TS"" is a set of language features that aims to (dramatically) improve support for generic programming. Writing a tutorial is a bit beyond me right now but this paper is a reasonable introduction to the feature set: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3701.pdf[1] . The introduction needs to brought up to date with the spec.   I'll have to take a look at the paper to find out more of the details!  and after all that initial reaction - holy crap, it seems like the person who actually came up with this idea is explaining it to me!!  I'm excited to come up with a project to test these features with, that is, once I can actually compile them :P Any idea when I can expect to see a compiler support concepts?  In any case, thanks for your contribution!"
cpp,3dzv6i,andrewsutton,8,Tue Jul 21 01:38:55 2015 UTC,"I can't claim to have come up with all of it. I just did a lot of the leg work.  Most of the proposed features are implemented in the c++-concepts branch of GCC, so you'd have to go build it from source to play with it. I think it's going to be merged into trunk in the near future, but I don't have the final say on that."
cpp,3dzv6i,m_0g,4,Tue Jul 21 01:46:02 2015 UTC,"cool, I'll have to give that a try when I get a chance.  Only one other question - can you recommend where the best place is to keep up to date on these sort of developments and additions to C++?"
cpp,3dzv6i,bstamour,5,Tue Jul 21 01:58:10 2015 UTC,Check out isocpp.org. Its where i go to get the latest news.
cpp,3dzv6i,encyclopedist,2,Tue Jul 21 02:17:55 2015 UTC,Will the Concepts make it into C++17? Or is there any other timeline for the future?
cpp,3dzv6i,andrewsutton,2,Tue Jul 21 09:43:20 2015 UTC,I suspect that the TS will be proposed to be added to C++17. I think there will be some significant changes to the proposed features before it lands in C++.
cpp,3dzv6i,sellibitze,2,Tue Jul 21 22:58:33 2015 UTC,"The concepts stuff you linked to corresponds to a very old proposal that is off the table. What we will get (first) are ""concepts lite"", a heavily simplified version."
cpp,3dzv6i,alonjit,3,Tue Jul 21 09:43:45 2015 UTC,"Why is it called ""concepts lite""? What would be the ""heavy"" version?"
cpp,3dzv6i,Houndie,5,Tue Jul 21 12:27:59 2015 UTC,"A heavy version includes what are called ""axioms"".  If a concept describes what a type can physically do, an axiom describes how that type should semantically behave. (Some definitions include axioms as a subset of concepts as well...that concepts define abilities and axioms).  An example:  Concepts Lite can declare that for T x and T y (for some class T), x == y is a valid function.  An axiom could say that if x == y then y == x."
cpp,3dzv6i,TiagoRabello,4,Tue Jul 21 13:41:05 2015 UTC,"The ""heavy"" version was the one proposed to C++11 that was deemed too complicated and got rejected by the standard. The current version was elaborated afterwards as an alternative which tries to solve the same problems but simpler and shorter."
cpp,3dzv6i,pfultz2,1 point,Tue Jul 21 13:04:03 2015 UTC,"The C++0x concepts didnt make it in because of strong disagreement on how to implement concepts(not because they were deemed too complicated). A liter version of concepts was proposed(see here), but was rejected because Bjarne Stroustrup has the unfounded opinion that C++0x concepts are inferior(see here). So instead ""Concepts Lite"" is not a simplified version of C++0x, but rather a complete detour."
cpp,3dzv6i,hpsutter,4,Tue Jul 21 17:05:26 2015 UTC,"No, that's mostly backwards.  C++0x concepts were removed because they were found to be too complicated. In particular, even in 2009 there was still no evidence they were even commercially implementable due to compile time overheads (IIRC the prototype often incurred 3-10x compile time on normal code that used STL headers, which isn't close to viable) and run time overheads (C++0x concepts were based on the injection of the indirection of concept maps and assumed that optimizers could be made good enough to optimize them away enough of the time, which is in the ""pound of cure"" spirit of languages like Java but not in the ""ounce of prevention"" spirit of C++). Also, in 2009 it became clear that we-the-committee didn't understand how to use C++0x concepts (there were over 100 concepts for the standard library, and fundamental disagreement on how to create more).  Concepts Lite is in many ways (I'd say ""mostly"") a return to Bjarne et al.'s original concepts proposal before the committee tried to merge that with a fundamentally different competing proposal. Both Bjarne's team and the other proposal's team gave a good-faith effort to follow the committee's direction to try to merge the two, and both should get credit for trying. The result was not viable though. It's possible that if there hadn't been the pressure to merge with the competing proposal with its inherent indirection overheads, C++ could have had useful concepts nearly a decade ago, but at least we're getting there now.  Finally, the ""Lite"" part is mostly not a comparison to C++0x concepts at all. It is mostly about that this version of the feature is about checking the callers only (the 99% case and where 99% of the benefit comes from, because callers always vastly outnumber callees), and does not include separate checking of callee bodies (the 1% case that has 1% of the value and that I personally won't cry if we never get)."
cpp,3dzv6i,pfultz2,1 point,Tue Jul 21 23:33:00 2015 UTC,"C++0x concepts were removed because they were found to be too complicated.   However, if that was the case, why did the committee not consider pursing a simplified version of concepts? Its seems a lot of research and effort was thrown away when concepts lite decided to take a completely different approach.   In particular, even in 2009 there was still no evidence they were even commercially implementable due to compile time overheads   Yes perhaps that was problematic in 2009, but what about 2012? There was viable implementations of C++0x concepts that was not as costly to compile time.   Finally, the ""Lite"" part is mostly not a comparison to C++0x concepts at all. It is mostly about that this version of the feature is about checking the callers only   If that was the case it should build on top of the current mechanism to check concepts. concept bool should be an enhanced type trait. However, concept bool and type traits are not interchangeable(and neither is enable_if and requires). So now the C++ standard library will have duplicate concept predicates(ie std::is_copy_constructible and CopyConstructible). This is just a mess.   and does not include separate checking of callee bodies (the 1% case that has 1% of the value and that I personally won't cry if we never get).   Multi-phase checking doesn't just apply to the just callee bodies. It can be used for improved checking such as template members.   Also, there is the lack of concepts maps, which would help simplify customization points. Currently, ADL is used, however, it is a little confusing for new users(see here). Plus, it may get even more complicated if uniform call syntax is added."
cpp,3dzv6i,pfultz2,0,Wed Jul 22 04:11:07 2015 UTC,"Watch this talk here by Dave Abrahams to get an idea of how the original C++0x Concepts are to work(although its in swift instead of C++). However, Concepts Lite(or Concepts TS) will never be as powerful as C++0x concepts. It would be better described as a detour than a ""lite"" version, since it is a completely different approach. Bjarne believes that C++0x concepts are inferior even though Concepts Lite can't do most of the things Dave Abrahams shows in the video, whereas the C++0x concepts could."
cpp,3dzv6i,andrewsutton,1 point,Tue Jul 21 19:47:23 2015 UTC,"The Concepts TS wasn't designed to provide the wealth of features that C++0x concepts (or Swift) provide. That's clearly stated in every (non-TS) paper describing the feature set.   But concepts was designed with an eye to the future. It opens the door to a number of interesting and useful extensions and shuts the door on none.   If you want to make meaningful arguments, contrast -- in code -- the difference between the examples in Dave's presentation with an equivalent implementation written in C++."
cpp,3dzv6i,gg_h4x,9,Wed Jul 22 01:29:00 2015 UTC,ELI5?
cpp,3dzv6i,bitse,49,Tue Jul 21 00:26:38 2015 UTC,"Imagine you're playing a game of Mad Libs, but when you ask your friends for words, you don't tell them whether to give a noun or an adjective, you just ask for any word. When you go to plug the words into the sentence it doesn't make any sense at all. It just comes out as ""cat and he said run as he jumped into happy"". Bleh.  The Mad Libs creators knew that you needed some sort of structure for the sentences to make sense. That's why there are grammatical restrictions -- you need a noun here, then a verb, then an adverb. You still have the flexibility to choose whatever word you want, as long as it fits within that category. That's how you make meaningful yet funny sentences.  Right now C++ templates is basically Mad Libs without any restrictions at all. You can plug any type you like into the template T but when the compiler goes to actually compile your code, the result may not make any sense at all. And the compiler doesn't have enough information to even tell you what went wrong, because it's just stuck with a nonsensical sentence.  Concepts are restrictions on templates, like grammar is a restriction on Mad Libs. You can still choose many different types for T, but they all have to be in some general category that at least lets the code make sense. And then the compiler can give a much more useful error when something doesn't fit, like ""hey, we were looking for something you can add to another thing, but the type you gave doesn't do that!""."
cpp,3dzv6i,FeastofFiction,10,Tue Jul 21 01:54:24 2015 UTC,"This is by far the best explanation I have seen here.   Imagine you're playing a game of Mad Libs, but when you ask your friends for words, you don't tell them whether to give a noun or an adjective, you just ask for any word. When you go to plug the words into the sentence it doesn't make any sense at all. It just comes out as ""cat and he said run as he jumped into happy"". Bleh.   I consider myself fairly well versed in C++, at least when it comes to actual coding.  However, being self taught I lack knowledge of some of the technical Jargon a formally educated programmer would posses.  Those 3 sentences of your's told me far more than every other comment in this thread combined...  Concepts will be indispensable!"
cpp,3dzv6i,Gangstuh_Nugget,4,Tue Jul 21 03:42:53 2015 UTC,I've always wondered why people default to explaining C++ features in the most complicated possible way. That sort of explaining only makes sense if you already know what they're talking about.
cpp,3dzv6i,mttd,9,Tue Jul 21 11:08:08 2015 UTC,http://en.cppreference.com/w/cpp/concept http://en.cppreference.com/w/cpp/language/constraints https://channel9.msdn.com/Events/CPP/C-PP-Con-2014/Generic-Programming-with-Concepts-Lite-Part-I https://channel9.msdn.com/Events/CPP/C-PP-Con-2014/Generic-Programming-with-Concepts-Lite-Part-II
cpp,3dzv6i,TweetPoster,2,Tue Jul 21 01:08:11 2015 UTC,"@ericniebler:   2015-07-20 20:58:40 UTC  The Concepts TS was voted out today! Concepts are (almost) an ISO standard. Congrats, A. Sutton. This will change everything. @isocpp #cpp     [Mistake?] [Suggestion] [FAQ] [Code] [Issues]"
cpp,3dzv6i,bumhugger,1 point,Mon Jul 20 21:42:06 2015 UTC,"Is this something similar to <T extends MyObject>, in other words when Concepts become ISO standard will it be possible to set upper bounds for templates?"
cpp,3dzv6i,TiagoRabello,5,Tue Jul 21 11:24:21 2015 UTC,"You will but It's really much more generic than that.  Concepts are predicates on types. You can test for whatever you want on the type, not limiting yourself to ""inherits from"" as in extends."
cpp,3dzv6i,Fazer2,1 point,Tue Jul 21 13:16:39 2015 UTC,Any information about modules?
cpp,3dy9tf,CraigularB,18,Mon Jul 20 14:54:47 2015 UTC,"Note that RTM's installer contains a significant change: Visual C++ is not installed by default. You must explicitly select it if you want it. (For clean installations, at least. I'd have to check how RC-to-RTM upgrades work.)"
cpp,3dy9tf,STL,8,Mon Jul 20 16:51:18 2015 UTC,":( why? That seems a little harsh.  edit: wow I just got my hands on the installer and it appears that for most languages it is opt-in, with the common cases being the express install. This is very different to the old setup and actually not bad as long as I can add and remove features at a later date I would say that this is an improvement."
cpp,3dy9tf,newuser1892435h,7,Mon Jul 20 17:06:38 2015 UTC,Yeah I am very happy to see a return to the advanced install options. They [over] simplified things in Visual Studio 2012 and 2013 so it is great to see so many options. All I want/need is the VC++ language and tools not all the web and mobile stuff.
cpp,3dy9tf,kozukumi,4,Mon Jul 20 18:38:04 2015 UTC,"Maybe because most VS users will not use it, and it probably takes up most of the space after installation, meaning the installation will also take much longer if it's included."
cpp,3dy9tf,nikbackm,1 point,Mon Jul 20 17:59:15 2015 UTC,"I strongly doubt msvc takes up the most space during install (but i will check) at least not for the packages that don't have other languages with strong dependencies on it (such as the crt and the redistributions). At this rate why not make all languages and features opt-in at least at a later date, as I know i wont be touching the webdev stuff and python is nice to have but it isn't even that popular in the python community (which is mainly on linux) and that is default installed...   Meanwhile here i am still using the Win32Api because unless I want to add dotnet as a dependency (which i don't as i need maybe three win32 functions)... sigh."
cpp,3dy9tf,newuser1892435h,10,Mon Jul 20 18:18:30 2015 UTC,"VC Dev Mgr here, actually because of the libs (and matching pdbs), VC is very large.   We also require the Win32SDK, which some scenarios do not.   Improving the acquisition experience for our customers is very important.  This adds a step for VC devs but significantly improves things for non-VC devs.   Note that you can already not install web dev stuff."
cpp,3dy9tf,spongo2,1 point,Mon Jul 20 19:11:45 2015 UTC,"Thank you, this was exactly the response I was looking for! Also while I have you here I wanted to say that I really enjoy using your product and that it makes writing code and debugging (almost) effortless.   Good luck with the RTM, and good (bug) hunting!"
cpp,3dy9tf,newuser1892435h,1 point,Mon Jul 20 19:18:37 2015 UTC,I appreciate the reduction in bloat especially seeing as how my SSD needs room to breathe.
cpp,3dy9tf,Gangstuh_Nugget,1 point,Tue Jul 21 11:13:22 2015 UTC,"Yeah, fortunately, I sold all my stock in SSD manufacturers before the product release.   <nota bene to SEC regulators.... THIS IS A JOKE>"
cpp,3dy9tf,spongo2,1 point,Tue Jul 21 17:14:59 2015 UTC,"I've just started the setup on my machine, where 2015 RC is installed. It didn't have VC++ selected, but luckily I always select ""advanced"" options anyway, no matter what I'm installing :-)  One question though, it was also not mentioned on the MSDN blog, should I have uninstalled RC first? Or will RTM overwrite RC? (hopefully). Or will it even be installed side-by-side?"
cpp,3dy9tf,Elador,3,Mon Jul 20 18:12:14 2015 UTC,"The setup team confirmed that upgrading RC to RTM in place is supported. You don't get side-by-side, since RC's lifespan is expiring."
cpp,3dy9tf,STL,2,Mon Jul 20 18:20:40 2015 UTC,"Cool, that's awesome, thanks! All good then. Can't wait till the setup finishes :-)))"
cpp,3dy9tf,Elador,2,Mon Jul 20 18:24:56 2015 UTC,I wonder why icon wasn't changed I was so happy when RC had different icon. Now I will have to suffer a ton of misclicks while using VC2013/2015 simultaneously again.
cpp,3dy9tf,Predelnik,1 point,Mon Jul 20 19:50:21 2015 UTC,And it remains ugly. :( I loved the icon from VS 2010; I wish they didn't replace it with this... awful... thing. :-/
cpp,3dy9tf,SushiAndWoW,2,Mon Jul 20 20:04:50 2015 UTC,"Well I guess this style is from Windows 8, but now it's new age with Windows 10 and all, so new style would probably make sense."
cpp,3dy9tf,Predelnik,3,Mon Jul 20 20:13:38 2015 UTC,"It's a shame btw that that they present all the new cool features always with XAML/C#/.NET. And then, if you want to find out if said cool feature also works with native C++ code, it's really, really hard to find information about it on their blog posts. (like for example the ""history-debugging"", code-lense, or the profiler stuff)  Update: The new Diagnostic Tools window is really awesome! Thank you so much for this!  Now we only need IntelliTrace :-)"
cpp,3dy9tf,Elador,1 point,Mon Jul 20 18:14:58 2015 UTC,"BUG REPORT: It turns out constexpr is borked in the Community edition (this code works fine in the Professional edition):  template<unsigned N> constexpr int count(const char(&str)[N], int i = 0) {     return str[i] ? 1 + count(str, i + 1) : 0; }  int main() {     static_assert(count(""Ben Hanson"") == 10, ""No""); }"
cpp,3dy9tf,BenHanson,4,Mon Jul 20 18:04:58 2015 UTC,"Very unusual, both are supposed to use the same compiler.  Could it perhaps be an installation issue on your part?"
cpp,3dy9tf,sakarri,1 point,Mon Jul 20 18:07:58 2015 UTC,"Uninstalled, rebooted, deleted installer, downloaded installer again, installed, rebooted, still borked:  1>d:\ben\dev\constexpr\main.cpp(64): warning C4425: 'const char (&)[N]' : 'constexpr' was ignored (class literal types are not yet supported) 1>d:\ben\dev\constexpr\main.cpp(70): error C2057: expected constant expression"
cpp,3dy9tf,BenHanson,10,Mon Jul 20 18:40:47 2015 UTC,"I just tried this with Community RTM and it worked. Can you add the following to your code and see what happens?  static_assert(_MSC_FULL_VER == 190023026, ""2015 RTM is 19.00.23026"");   This will verify that you're actually running RTM. If you are, can you prepare a self-contained repro and E-mail it to me? What I need is (1) a source file (that includes only built-in headers) and (2) the exact command line that repros the problem, as run in ""VS2015 x86 Native Tools Command Prompt"". x64 Native would also be OK (tell me which one you're using), but I really need a command-line repro, to avoid any possible IDE influence."
cpp,3dy9tf,STL,2,Mon Jul 20 19:38:44 2015 UTC,"Sorry, operator error. I had to re-target in Project Properties (it was an existing project). I was expecting it to auto upgrade."
cpp,3dy9tf,BenHanson,1 point,Tue Jul 21 07:28:37 2015 UTC,"I did have the RC installed already, so I am uninstalling it all now and will reboot and reinstall from scratch."
cpp,3dy9tf,BenHanson,3,Mon Jul 20 18:27:36 2015 UTC,"I'm on Community, it seems to compile fine for me."
cpp,3dy9tf,adrian17,1 point,Mon Jul 20 18:21:25 2015 UTC,"I thought constexpr was completely broken, but it appears you allow the debugger to step through constexpr functions? If I use static_assert to verify constexpr values, it is working as expected."
cpp,3dy9tf,BenHanson,-5,Mon Jul 20 15:53:09 2015 UTC,This is outragous! What will happen to r/cpp if the script kiddies no longer can complain of non-existing features in the ms compiler!? /s
cpp,3dy9tf,ampersandal2,7,Mon Jul 20 16:00:45 2015 UTC,r/cpp .... script kiddies    hmmmm
cpp,3dy9tf,cynicalsingularity,1 point,Mon Jul 20 17:57:59 2015 UTC,"Also, intellisense works for the static asserts... Cor Blimey Guvnor!"
cpp,3dy9tf,BenHanson,1 point,Mon Jul 20 16:03:18 2015 UTC,"Only Enterprise has CodeLens, correct?"
cpp,3dy9tf,Musaab,2,Mon Jul 20 20:30:08 2015 UTC,"The feature comparison table says that CodeLens is present in Professional and Enterprise, but not Community."
cpp,3dy9tf,STL,1 point,Mon Jul 20 20:39:37 2015 UTC,CodeLens is unfortunately not that great with native C++ code. It's usefulness is limited to showing git commit history (which is still great!). Or have you had better experience (i.e. am I missing something?)
cpp,3dy9tf,Elador,0,Tue Jul 21 00:37:01 2015 UTC,"Original post from /r/programming: Visual Studio 2015 and .NET 4.6 Available for Download    I am a bot, PM me if you have any questions or suggestions"
cpp,3dxb2p,meetingcpp,31,Mon Jul 20 08:32:06 2015 UTC,"BigObject&& foo(int n) {    BigObject localObj;    return std::move(localObj);      }      int main() {      foo(1); }  Then we compile and run it, and we will get the output like this:   constructor. destructor.   Yes! The compiler does RVO! It's also noticeable that RVO calls destructor only once, but std::move calls destructor twice.   What?!? No! The compiler did not perform RVO, you're returning a reference (to a local object no less).   No object is constructed so no copy/move construction nor any RVO are performed. The fact that you now have undefined behaviour is just an added bonus."
cpp,3dxb2p,night_of_knee,4,Mon Jul 20 12:13:04 2015 UTC,"Funny, ended up returning a reference to something. Can we catch it in a BigObject& in main() and smash the stack?"
cpp,3dxb2p,devel_watcher,0,Mon Jul 20 12:22:56 2015 UTC,"Yes, that thing is not usable at all and not related to the RVO.  Just pass the result to something that takes any reference and have some magic going on:  #include <iostream>  struct A {     A() = default;     A(A&& a) = default;      int m; };  A&& f() {     A a;     a.m = 10;     return std::move(a); }  template<typename T> void g(T&& t) {     T u;     t.m = 5;     std::cout << u.m << '\n'; }  int main() {     g(f());     return 0; }"
cpp,3dxb2p,devel_watcher,18,Mon Jul 20 13:32:39 2015 UTC,"The reason why this calls move constructor isn't because of std::move. RVO is disabled because the types aren't the same, but the value is still cast back to BigObject and then returned. Since it's an xvalue, move constructor will be called.  BigObject foo(int n) {     BigObject localObj;     return std::move(localObj); }   This returns a dangling reference.  BigObject&& foo(int n) {     BigObject localObj;     return std::move(localObj); }"
cpp,3dxb2p,genije665,12,Mon Jul 20 09:48:13 2015 UTC,"You didn't say in so many words, but the returning of the dangling reference causes undefined behaviour. So the discussion following that example is bogus."
cpp,3dxb2p,OldWolf2,2,Mon Jul 20 11:58:37 2015 UTC,Returning that dangling reference doesn't per se cause undefined behavior; UB only occurs as a result of using that reference.
cpp,3dxb2p,bames53,1 point,Mon Jul 20 16:20:55 2015 UTC,You're probably right.
cpp,3dxb2p,OldWolf2,15,Mon Jul 20 21:28:45 2015 UTC,"Okay this is pretty stupid.  Foo bar() {    Foo x;    return std::move(x); }   This (usually) disables RVO.  Don't do it.    Foo bar() {    Foo x;    return x; }   This can perform RVO on x, and, if optimization is disabled, calls the move constructor.  That's right...no need to call std::move explicitly, it moves for you.    EDIT:  From the standard, section 12.32 (emphasis mine)   When the criteria for elision of a copy/move operation are met, but not for an exception-declaration , and the object to be copied is designated by an lvalue, or when the expression in a return statement is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If the first overload resolution fails or was not performed, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object’s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue"
cpp,3dxb2p,Houndie,2,Mon Jul 20 12:44:10 2015 UTC,This was my understanding of what went on.  You define a move constructor on an object and the compiler will determine when it is best to use RVO or move operations.  I'm not entirely sure when the right time to call std::move is.
cpp,3dxb2p,cogman10,7,Mon Jul 20 13:23:50 2015 UTC,"The right time to call std::move is when you're smarter than the compiler and you know something won't be used again.  For example, with this code:  void bar(Foo);  int main() {    Foo x;    bar(x) //move won't happen here because...     //...x could still be used down here. }   However, if you KNOW that x isn't needed any more after the call to bar you can tell the compiler to move it.  void bar(Foo);  int main() {    Foo x;    bar(std::move(x)) //move happens here     //Any use of x down here is possibly invalid, depending on the operation and the state of x when it's moved from. }   Basically, anytime copy elision can happen, a move will occur in an unoptimized environment.  Otherwise you need to say ""move"" yourself    An important side note to realize is that std::move is simply ""cast to r-value reference"".  The above case ""moves"" because it's being passed by value, so the constructor with an r-value reference parameter (the move constructor) is called.  If bar took a const l-value reference, or an r-value reference, then no move would occur when calling the function (which is normal for pass-by-reference parameters)."
cpp,3dxb2p,Houndie,2,Mon Jul 20 13:27:50 2015 UTC,"Can't you simply limit the scope of x in this example?   {     Foo x;     bar(x) }   The compiler now knows x will never get used after bar, and a move is safe."
cpp,3dxb2p,flyingcaribou,5,Mon Jul 20 19:34:40 2015 UTC,"Implicit moves happen wherever copy elision can happen, which according to 12.31 is return statements, throw expressions, ""movement of a temporary object"", and the exception declaration of an exception handler.  So, no not in this case.  I think what the designers were attempting to avoid (if it could move there) was how behavior could then change based on seemingly unrelated code edits.  {    Foo x;    bar(x);  //The behavior of this line changes...     //500 lines of code later     baz(x);  //...when this line is added. }"
cpp,3dxb2p,Houndie,4,Mon Jul 20 19:50:24 2015 UTC,"I'm not entirely sure when the right time to call std::move is.   In my experience, the most common usage of std::move is when you have a named rvalue parameter, since the parameter is named it itself is an lvalue (confusing right?)    // move constructor  Obj(Obj&& other) :    member(std::move(other.member))   {}"
cpp,3dxb2p,night_of_knee,1 point,Mon Jul 20 20:30:15 2015 UTC,"Shouldn't other still be considered an rvalue because it is an rvalue reference but member is not an rvalue because it's just a field of other. I mean for ""member(other)"" the move constructor of member would be called without a move, after all other is Obj&& and that's exactly the type the move constructor takes?"
cpp,3dxb2p,nerdandproud,3,Tue Jul 21 10:44:20 2015 UTC,"The example I gave wasn't the best (I wrote it on my phone late at night) but no, other is an lavalue not an rvalue.  See this example  #include <iostream> using namespace std;  class example {     public:     example() { }     example(const example&) { cout << ""=> copy constructor\n""; }     example(example&&) { cout << ""=> move constructor\n""; } };  void foo(example&& e) {     cout << ""Creating from rvalue parameter:\n"";     example ee{e}; }  void bar(example&& e) {     cout << ""Creating from moved rvalue parameter:\n"";     example ee{std::move(e)}; }   int main() {     foo(example{});     bar(example{}); }       The output is:   Creating from rvalue parameter: => copy constructor Creating from moved rvalue parameter: => move constructor"
cpp,3dxb2p,night_of_knee,1 point,Tue Jul 21 11:22:05 2015 UTC,"Wow this is fascinating and really counter intuitive, thanks for this great example.  I tried and find it even more crazy in initialization here. Note I follow C++ discussions and things like LLVM Weekly but use Java and Go most of the time and it's been a while since I had a C++ project though I want to get into C++ again, so I haven't had too much first hand experience but this really gets documented too little."
cpp,3dxb2p,nerdandproud,3,Tue Jul 21 12:52:25 2015 UTC,"I was thinking the same thing as I read this, why all this weird std::move on function return values when the compiler will move standard returns just fine?"
cpp,3dxb2p,RedAlert2,4,Mon Jul 20 18:25:22 2015 UTC,"Without meaning to be mean, there are some major issues with this article, both on the English side and the technical side. The technical side has already been covered, but the communication suffers as well: saying that ""elision"" is another term for RVO is inaccurate as elision is a very general term; ""tricking stolen objects into forgetting"" is just confusing for readers; etc.  If the author happens to read the thread, I'd like to encourage him to continue writing, but also perhaps to invest a little more time both on technical research and copy editing. Writing these kinds of posts is tough!"
cpp,3dxb2p,quicknir,2,Mon Jul 20 23:42:36 2015 UTC,"Some people will call this case using named return value optimization(NRVO), because foo returns one temporary object named localObj. They think that what returns BigObject() is RVO. You don't  need to worry about it, as NRVO is one variant of RVO.   I disagree that the distinction is unimportant.  If you mix them you will NOT get RVO of any kind.  Consider:  BigObject foo(int n) {     BigObject nrvo{};     if (n == 5) return BigObject{}; // rvo     return nrvo; }   Compiler is unlikely to optimize this.  In fact it may be that it cannot.  You must either use RVO, or NRVO--never both."
cpp,3dxb2p,Crazy__Eddie,1 point,Tue Jul 21 19:43:43 2015 UTC,"The first paragraph is poorly worded IMO. C++11 didn't change copy elision. It has been there since day one, and it was and still is optional."
cpp,3dxb2p,OldWolf2,-9,Mon Jul 20 11:53:13 2015 UTC,std::move isn't for daily use.
cpp,3dxb2p,devel_watcher,3,Mon Jul 20 09:39:55 2015 UTC,Why not?
cpp,3dxb2p,gartenriese,-4,Mon Jul 20 09:44:25 2015 UTC,"Because when you use classes that have move operations, these move operations are triggered implicitly when they are needed.  You write std::move mostly around the move constructors."
cpp,3dxb2p,devel_watcher,3,Mon Jul 20 10:31:42 2015 UTC,these move operations are triggered implicitly when they are needed.   Can you give an example of what you are talking about?
cpp,3dxb2p,OldWolf2,-4,Mon Jul 20 11:59:15 2015 UTC,"https://youtu.be/2egL4y_VpYg?t=1h1m23s  Do you see a std::move on the slide #39?  (no, because it doesn't belong to the place where classes are used)"
cpp,3dxb2p,devel_watcher,4,Mon Jul 20 12:11:22 2015 UTC,"The code in slide 39 is eligible for copy elision, which is what the article is about. Copy elision is not a move operation. Did you actually read the article? It goes into detail about the difference between copy elision, and returning via movement.    In the slide 39 code, a + b is an rvalue; so if the compiler chooses not to use copy elision, then res may be constructed via move constructor from that temporary -- only if the class actually has a move constructor, of course..   (This is a worse case than copy elision, as notted by the article)."
cpp,3dxb2p,OldWolf2,-4,Mon Jul 20 12:54:44 2015 UTC,"The point is that you don't need to write std::move in your function:  #include <iostream>  struct A {     A():         m()     {         std::cout << ""ctor"" << '\n';     }      ~A()     {         std::cout << ""dtor"" << '\n';     }      A& operator=(const A& a)     {         m = a.m;         std::cout << ""copy"" << '\n';         return *this;     }      A(const A& a):         m(a.m)     {         std::cout << ""copy"" << '\n';     }      A(A&& a):         m(std::move(a.m))     {         std::cout << ""move"" << '\n';     }      A& operator=(A&& a)     {         m = std::move(a.m);         std::cout << ""move"" << '\n';     }      int m; };  A f(int n) {     A a1, a2;     a1.m = 10;     if (n > 2)         return a1;     else         return a2; }  int main(int argc, char**) {     std::cout << f(argc).m << '\n';     return 0; }   it produces  ctor ctor move dtor dtor 0 dtor   or  ctor ctor move dtor dtor 10 dtor"
cpp,3dxb2p,devel_watcher,2,Mon Jul 20 13:51:12 2015 UTC,"The ""move"" constructor above still does a copy of the member variable m.  The canonical move constructor would be:  A(A&& a):         m(std::move(a.m)) {     std::cout << ""move"" << '\n'; }   Now this is a trivial example, and there's no difference between moving and copying an int.  But for objects with complex objects inside them, it would make a difference."
cpp,3dxb2p,mdf356,-1,Mon Jul 20 14:02:52 2015 UTC,This is irrelevant. We are talking about std::move inside f().  (added moves to ctors code)
cpp,3dxb2p,devel_watcher,1 point,Mon Jul 20 14:22:51 2015 UTC,"OK. You're talking about C++14 [class.copy]/32:   When the criteria for elision of a copy/move operation are met [...], and the object to be copied is designated by an lvalue, or when the expression in a return statement is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.   So in return a1;  , a1 may bind to a move constructor.  More importantly though, this can only happen when the code was eligible for copy elision anyway.  The article on this thread seems to use your function as an example of when copy elision doesn't happen, but that's just the compiler deciding not to do it in this case for some reason."
cpp,3dxb2p,OldWolf2,-2,Mon Jul 20 21:26:11 2015 UTC,"So, the article claimed that because of the two objects on stack instead of one it can't move or elide. That is false on my compiler. And the standard says that it will move.  The proposed fix is to stick std::move there. And override the logic to be move-only. Some day a privately owned object must be returned there, and we'll see the real meaning of std::move in that position: either return it by copy or move from it (but definitely not use std::move as a hack to fix the compiler)."
cpp,3dxb2p,devel_watcher,4,Mon Jul 20 23:17:23 2015 UTC,"It isn't used there because the copy is elided.    If you mean moves should only be part of data structures that is also not true, as moves can be used to pass parameters to functions that take an argument by value, changing ownership and sinking the argument without any heap activity."
cpp,3dxb2p,__Cyber_Dildonics__,-3,Mon Jul 20 12:37:01 2015 UTC,"Passing arguments is a bit questionable. Why getting involved with rvalue references instead of explicitly stealing the contents of the object inside the function anyways?  Besides, if you have such kind of relation, it often looks like a circulation of buffers between two subsystems. And if you don't want the heap activity, you use swap, because one-time stealing destroys the contents and doesn't bring them back into the loop."
cpp,3dxb2p,devel_watcher,3,Mon Jul 20 14:06:00 2015 UTC,"You can't steal the contents of something inside a function because that breaks encapsulation.  Then you would have to know the function is going to steal your object and you are back to the the ownership problem, where you have to somehow know if a function is going to do to your parameters instead of what it is going do with them.  The second thing you are saying is some sort of problem created from your own architecture and doesn't sound indicative of good design."
cpp,3dxb2p,__Cyber_Dildonics__,-3,Mon Jul 20 14:59:57 2015 UTC,"It is a move constructor, how does it break encapsulation?  And nobody should depend on the state of a sink parameter after it is passed by any reference. The use of rvalue reference doesn't guarantee that something will be moved.  Btw, your use of rvalue cast 'doesn't sound indicative of good design'."
cpp,3dxb2p,devel_watcher,3,Mon Jul 20 15:29:55 2015 UTC,"First you were saying stealing the contents inside a function, now you are saying talking about move constructors.    If you pass by const reference you may hold on to an object longer than you have to if the function can use it and destroy it.  In that situation using move to get the object in the function works well because the function can use it and possibly destroy it early.  When I say sink, I'm talking about passing by value.  funcname(Obj o)  You can call that with funcname(move(objInst)); and it will create an rvalue reference that will call the rvalue constructor."
cpp,3dxb2p,__Cyber_Dildonics__,-2,Mon Jul 20 15:57:00 2015 UTC,Easy: Early optimization. First do the profiling and use std::move when necessary.
cpp,3dxb2p,newmewuser4,5,Mon Jul 20 18:06:53 2015 UTC,That's like saying using const or noexceptis early optimization.
cpp,3dxb2p,gartenriese,1 point,Mon Jul 20 18:43:19 2015 UTC,Avoiding early optimization doesn't mean doing stupid things that throw away performance unnecessarily.
cpp,3dxb2p,robstoon,6,Wed Jul 22 04:36:55 2015 UTC,A pointer to what?
cpp,3dxb2p,gartenriese,2,Tue Jul 21 02:28:38 2015 UTC,Wouldn't that be a dangling pointer then?
cpp,3dxb2p,gartenriese,4,Tue Jul 21 07:42:14 2015 UTC,"In C++, if you declare an object normally, i.e. in ""automatic storage"" such as a function's local variable, as opposed to declaring it in ""dynamic storage"" by using the ""new"" keyword, involving a dynamic memory allocator; when you exit the scope, the storage for that object will be automatically gone, deallocated, repurposed for other uses. This scheme is highly efficient, and lends itself easily to optimizations like the object being stored entirely in CPU registers and not in RAM at all.  Taking a pointer that points into that object, outside the scope will only serve to produce a pointer that now points into garbage in best case and is a security hole/crash in worst case.  If you insist on taking lessons from Java land, declaring every object with ""new"", going through the behemoth that is the dynamic memory allocator behind that innocent looking little word, then yes, you can take the pointer out from the scope and out from the function, and it will stay as a ""legit allocated memory location"" as opposed to becoming a danging pointer, but then you must also worry about ownership, sharing, and knowing when is the proper time to deallocate it. You could use std::unique_ptr or std::shared_ptr to encapsulate it. Whichever way you choose, it's far less efficient than using automatic storage in the first place.  But when you use automatic storage, you must consider what happens when/if you want to take the object outside the scope it was declaring in, such as by returning it as a function return value. That's where the copying/moving/copy elision choice comes in."
cpp,3dxb2p,Bisqwit,5,Tue Jul 21 16:13:15 2015 UTC,"Certainly custom pool allocators, for particular tasks given particular limits, can be almost as efficient as automatic storage is (almost, because you will explicitly require backing memory storage, which automatic variables don't), but then you're just moving the ownership problem rather than solving it. You still need to figure out who owns the pools, and who is responsible for destructing your object instances.  And yes, custom allocators still do have their uses, and I have used them extensively as well, for things like making std::map and std::list significantly faster. But the point being addressed here is how to return objects as return values from functions, and using custom allocators + placement new is not usually the right solution."
cpp,3dxb2p,Bisqwit,3,Tue Jul 21 18:02:46 2015 UTC,"Oh, you mean you would allocate the object on the heap? But maybe I don't wanna do that?  Edit: Also, that's bad design, because the user must somehow know to delete the object."
cpp,3dxb2p,gartenriese,1 point,Tue Jul 21 18:05:07 2015 UTC,"Yes, you're right that in some cases it is better to use the heap. But your first comment sounded like you wanted to use your technique instead of RVO/std::move. I think both have their use cases."
cpp,3dxb2p,gartenriese,2,Tue Jul 21 18:14:27 2015 UTC,"Unless you are trying to get back to the 70s and fit all your info into 4k, at some point you will have to move this data into the heap.   But not all programs use objects that are bigger than 4k. This discussion is about a general use case, not the specific use case you are thinking about. When I want to program a sudoku solver, I think it's fair to say that I don't need to use the heap.   I want to make a challenge here: I propose that it is always possible to architect a solution to make a code as fast or perhaps faster without any move semantics.   And I propose that it is always possible to architect a solution in Assembler instead of C++. But it is useful? Why not use the tools you have to make your life easier?   My point is, and I dare to say that, pretty much everything since C++11 has been cosmetic.   Pretty much any programming language above Assembler has been cosmetic, if you think that way.   [...] and accuse me of ignorance [...]   The problem is that you only see your use case. I bet most of the C++ projects on Github don't use custom allocators. Yes, in some cases, your approach is useful. But in many other cases, it's simpler to not use pointers."
cpp,3dxb2p,gartenriese,1 point,Tue Jul 21 18:30:24 2015 UTC,"My point, quick check: what's the default size of the stack on say Linux/x86_64? 4k or 8k usually.    Uh, WTF? I don't think even the kernel stack is even as small as 8KB anymore. Default stack size for new threads is usually something like 2MB."
cpp,3dxb2p,robstoon,2,Tue Jul 21 21:10:23 2015 UTC,If that really solved anything we wouldn't have these features.    Also that anecdote isn't true.
cpp,3dxb2p,__Cyber_Dildonics__,3,Tue Jul 21 18:10:50 2015 UTC,"Returning a pointer means you have to have the object on the heap, incurring extra overhead and extra indirection. In most cases you should be returning by value and letting rvo handle it."
cpp,3dxb2p,quicknir,4,Tue Jul 21 18:23:33 2015 UTC,"Which is 10 cycles more than stack allocation in addition to requiring that you pass around a custom allocator as a parameter to every function, which in turn bloats your API... and your measurement doesn't factor in the cost of indirection and the effect it has on the cache every time you want to access that value."
cpp,3dxb2p,sakarri,5,Tue Jul 21 21:32:32 2015 UTC,"Yes, but rvo is free. Returning a pointer, you will forever have an extra indirection to your returned object. Most importantly, if you return by value, your code will be much simpler: no need to deal with pointers, a custom allocator, or placement new.   I just don't understand your objection to return by value."
cpp,3dxb2p,quicknir,3,Tue Jul 21 21:41:41 2015 UTC,"The thing is your opinion is not formed from the same depth of knowledge that the people who created rvalue references and move semantics.  That's fine, no problems there, but to pretend both viewpoints are equal is not true, because these experts know everything that you do about C++ and compilers plus a lot more.  Move semantics aren't actually for returning objects by value - return value optimization and copy elision already takes care of that and has been part of the standard before C++11.  It is for keeping track of ownership and in combination with deleted functions can make things like unique_ptr single owner.  This not only means you don't have to write constructors to manage memory, but also that when working with threads you can avoid copies yet be thread safe.  You can move an object to another thread instead of copying it, which is very powerful."
cpp,3dxb2p,__Cyber_Dildonics__,4,Tue Jul 21 21:57:01 2015 UTC,You can rationalize your willful ignorance and be as offended as you want but it doesn't change the reality that you've convinced yourself that something is worthless because you are scared of learning it.
cpp,3dxb2p,__Cyber_Dildonics__,3,Wed Jul 22 04:26:41 2015 UTC,"The issue as I see it is you haven't presented any sort of technical argument, the justification behind your post is some joke about Russian astronauts, and then you immediately jump to your own personal anecdotes.  When the entire basis of your point is personal, you can't exactly fault someone for bringing your own person into question.  If you wish to have a discussion that doesn't depend on your own person, then leave your own person out of the argument.  Focus on technical or management or aesthetic reasons rather than talking about how you've been programming software since before computers existed that move over 1 trillion dollars a day, but have never taken the time to learn about the difference between value and reference semantics."
cpp,3dxb2p,sakarri,2,Tue Jul 21 12:01:13 2015 UTC,"It seems to me like you are conflating RVO with move semantics. Even though they are both used for efficiency purposes, their actual goals are quite different.  The purpose of move semantics is to efficiently transfer ownership of allocated objects. This umbrella includes the things constructed using placement new with custom allocators. RVO's purpose is to avoid a copy when you return from a function. It has nothing to do with ownership.  The messiest problem with non-automatic storage variables is ""who is responsible for cleaning this up?"" Before move semantics, you can do one of three things:   use some kind of shared data type, that deallocates when the reference count is zero. This has extra overhead that usually isn't needed use a data type whose copy constructors transfer ownership instead of copying. auto_ptr in a nutshell -  these are very easy to misuse. require an explicit deallocation. This is essentially what you are recommending (""simply returning a pointer""). This forces the user to manually destroy the object, even though c++ has had destructors for this purpose since its inception. It's prone to error and something we'd rather not have to do.   With move semantics, we have a 4th option, which is to define a data type with move constructors whose only purpose is to transfer ownership. This applies to ownership of all non-automatic storage data, even custom pool allocator storage."
cpp,3dxb2p,RedAlert2,3,Tue Jul 21 16:12:26 2015 UTC,"I don't think anyone is confused about the premise of your argument, only that you haven't justified it.  You say using heap allocated memory using a custom allocator which now has to be passed around by the client to every function and requires the client to delete it as well as protect against dangling references is easier than using value semantics, where all of those factors are off-loaded to the compiler.  The compiler handles memory allocation and deallocation using the stack, so no need to pass around a custom allocator.  The compiler handles copying and moving values, so no need to worry about dangling references.  So the question is what is easier... having the human handle all these things, or placing the burden of all those things on the compiler so that the human can focus on solving their problem?"
cpp,3dxb2p,sakarri,3,Tue Jul 21 16:39:46 2015 UTC,Now your rationalization is that you're being bullied.  Wouldn't be easier to just learn something new?
cpp,3dxb2p,__Cyber_Dildonics__,4,Tue Jul 21 16:48:22 2015 UTC,"You're the one who started making it personal by citing how you make a living from c++, thereby trying to lend your opinion extra weight. You didn't give any reason as to what's wrong with rvo.   You also kind of insinuated that anyone interested in this discussion of move and rvo is a college kid in love with theory and lacking practical experience. I have news for you: I take great interest in these details, and I make a living from c++ as well. In fact, I'm sure many people here do. In any case, we'll all learn more and have better discussions and have more fun if we stick to technical reasons."
cpp,3dxb2p,quicknir,2,Tue Jul 21 18:59:27 2015 UTC,"personal, revengeful attacks.  When you graduate from college and get a job, you'll look back and rethink all this.  I dont know what these ""experts"" are doing but I have a hunch they are creating inexistent problems so they can be paid to solve."
cpp,3dxb2p,__Cyber_Dildonics__,-7,Tue Jul 21 19:01:12 2015 UTC,"C++'s support for efficient argument passing is lacking. For example, you cannot return function arguments and expect RVO to work. This prevents efficient function chaining:  t = h(g(f(source())));   C++ should add a method to specify the programmer intent, rather than the mechanism of parameter passing, leaving the exact mechanism up to the compiler. Say mark a in parameter with the keyword in.   T f(in T x);   Then the compiler can choose the exact calling convention. If T is an int, passes T by value. If it is a string, maybe pass by const reference or r-value reference, depending on whether the actual parameter is an l-value or r-value. Basically the declaration for f works as an implicit template."
cpp,3dxb2p,whichton,4,Tue Jul 21 16:46:38 2015 UTC,This is exactly why move semantics were introduced in c++11. Everything in your example will be moved assuming the functions accept parameters by value.
cpp,3dxb2p,RedAlert2,-2,Tue Jul 21 16:53:21 2015 UTC,"Not really. In the first case you spend 2 moves per function call, just moving data into and out of a function. These can be elided with proper annotation, saving 6 moves across 3 function calls.  For the 2nd case, currently we need to write 2 overloads to handle things optimally without extra moves:  T f(const T&); T f(T&&);   This is prevented with extra annotations."
cpp,3dxb2p,whichton,3,Tue Jul 21 18:32:08 2015 UTC,"That method will just invoke a bunch of copy constructors, since now you must convert your input type T&& to  your output T, which copies.  I would suggest you test with value parameters. You should only get 3 move constructors with that example"
cpp,3dvv5l,HolyCowly,13,Sun Jul 19 23:31:09 2015 UTC,"I refer to these concepts as ""reproducible"" and ""deterministic"". mt19937 is reproducible, in that its output should be identical across all implementations. The Standard even mandates what its 10,000th value should be for a certain seed. Last I checked, VC agreed with GCC. (Note that in VC 2013, I fixed mt19937's behavior for 0 seeds. I hope you're not using 2012. Now that 2015 has been released, you should upgrade.)  However, uniform_int_distribution is merely deterministic. Its output can vary according to different implementations or versions. This is because the Standard doesn't specify the exact algorithm needed to implement it. (It's actually really nasty to implement in full generality.)  If using mt19937 without uniform_int_distribution produces different results between VC 2013+ and GCC, please give me a self-contained repro and I'll investigate."
cpp,3dvv5l,STL,3,Tue Jul 21 03:04:34 2015 UTC,"Thanks for pointing that out. I had a hard time finding people with the same problem, however including uniform_int_distribution in the search revealed a few topics on stackoverflow. Seems everyone who has this problem became only aware of it after using it in a real program where using the output of the generator directly isn't that common (at least I never did).  The output is indeed the same if I don't use uniform_int_distribution."
cpp,3dvv5l,STL,2,Tue Jul 21 10:26:06 2015 UTC,"Caution: you may be tempted to use modulo to get reproducible distribution behavior, but this will introduce bias. You can avoid bias only by replicating the work that goes into implementing uniform_int_distribution. (It's somewhat easier if you can assume that the input is mt19937's range.)"
cpp,3dvv5l,F-J-W,1 point,Tue Jul 21 15:20:08 2015 UTC,"Do you know whether the outputs of uniform_int_distribution do actually vary between VC and libstdc++? Because it doesn't look to me that there are a lot of ways to implement it, if you don't safe unused data (I checked libstdc++ for that a while ago and you once told that this is also the case for VC)?  Alternatively: Is there a simple way to get the sources of VC's stdlib as a Linux-only-user to investigate that myself?"
cpp,3dvv5l,STL,2,Tue Jul 21 08:18:34 2015 UTC,"The OP has confirmed that they actually vary. There's a lot of latitude in its implementation, even for stateless distributions. Unless its implementer in libstdc++ thought exactly like I do, varying output is basically guaranteed. (I could probably replicate my output from scratch, given my thought process of ""map the engine to a bitstream and be on guard for treachery at every point"", but I'd say there's a 50% chance I'd choose differently somewhere accidentally.)  You would have to install VC in a VM to look at the STL's sources. And remember, you would be bound by VC's EULA."
cpp,3dvv5l,F-J-W,1 point,Tue Jul 21 15:16:07 2015 UTC,"You would have to install VC in a VM to look at the STL's sources.   That's why I asked for simple.  But when I think about it, it should be possible to get those files from the VC-instalation on my universities pool-computers. What is the include-path there?   And remember, you would be bound by VC's EULA.   Only to the extremely limited degree that German law permits. Which is basically „the usual laws for copyrighted work apply“."
cpp,3dvv5l,STL,1 point,Tue Jul 21 16:16:38 2015 UTC,C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\include
cpp,3dvv5l,darthpjb,1 point,Tue Jul 21 17:46:22 2015 UTC,"You have to understand that this is implementation specific behavior for a damn good reason. For 99% of cases, a programmer doesn't care about the random order being the same, what they care about is getting a random number and it being really really fast.  Bjarn wants C++ to be fast, as fast as C, if not faster - to that end there are many cases where things don't behave the same between compilers, or platforms.  If the ARM processor has a instruction for random-number, C++ on ARM will use that and that will be faster. If Intel doesn't, then the compiler should know the fastest possible assembly for it's platform.  Sure, the JVM has the same random-seed - I imagine if you benchmarked a random-something-a-million-times loop between C++ and JVM, on some (if not most) platforms, C++ will win for execution speed. (I'm not knocking Java there BTW).  Thing is, it's a difference in C++ concepts, in C++ if you can't do it - you write it. You write your own sodding Random-value library that behaves exactly how you want - or (if you absolutely have to) use one someone else wrote. That's how C++ programmers (generally) operate. Doom is a perfect example  After all, a pseudo-random function isn't really that hard - especially compared to something like writing a 3D game."
cpp,3dvv5l,__Cyber_Dildonics__,1 point,Tue Jul 21 09:01:42 2015 UTC,"Writing a good pseudo random function is not trivial which is one reason why mersienne twister is used so often.  If you use C's rand() to generate random numbers for monte carlo sampling in a ray tracer, you will see patterns show up in the noise."
cpp,3druwq,buovjaga,15,Sat Jul 18 21:19:26 2015 UTC,Why not use unique_ptr everywhere? Who's sharing?
cpp,3druwq,TemplateRex,2,Sat Jul 18 22:21:27 2015 UTC,"Why not do placement new in a std::array<char, N>, and then call the dtor of the contained object in your destructor? You can easily check at compile time in the compilation unit that the array N is big enough these days. No need for extra allocations at all. This doesn't work for maintaining ABI compatibility, as mentioned elsewhere, but if I were using PIMPLs for no other reason than hiding implementation details and increasing compilation speed, then why not do this?"
cpp,3druwq,kkrev,6,Sun Jul 19 23:59:25 2015 UTC,surely you mean std::aligned_storage
cpp,3druwq,mare_apertum,2,Mon Jul 20 08:46:16 2015 UTC,http://www.gotw.ca/gotw/028.htm
cpp,3druwq,Crazy__Eddie,11,Tue Jul 21 08:18:08 2015 UTC,"I see two potential problems with this test;  A) Using ptr to a pimpl object misses the point. Usually one uses pimpl for value types, not polymorphic types, otherwise we would use the base class interface as in the Abc test. I think it's only fair to compare the respective expected use cases.   B) I'm not convinced that the complier didn't devirtualize and inline the functions in ABCTest. I suspect it did and the slow down was caused by the extra 8 bytes of object size for the vtable ptr. I would investigate that.   Note: I posted the same comment under r/programming before I saw the post here."
cpp,3druwq,cdglove,1 point,Sun Jul 19 01:05:39 2015 UTC,"Indeed, this nails it. The pointer to a pimpl means the author is comparing two indirections to one indirection.  In addition, I'd like to add that pimpl can handle polymorphism just fine, you'd just have a base class pointer internally. You can even call a factory in the constructor of the outer pimpl.  The real benefit of pimpl is that it means that the user can deal with a class with straightforward value semantics, instead of pointers. If you plan to use pointers anyhow, there's no point at all in using pimpl.  FWIW I rarely use pimpl and don't love it, but I don't think this article gives them a fair shake."
cpp,3druwq,quicknir,9,Tue Jul 21 02:32:37 2015 UTC,"In your Create-function you should be using make_shared and in the Pimpl-constructor make_unique. In your for-loop you should stop copying shared_ptrs (thereby fiddling with the atomic reference count). Comparing the two memory allocations of the Pimpl case (shared_ptr + unique_ptr) to one memory allocation with the abstract base class (only shared_ptr) is not a fair comparison (especially considering that in this test, as it stands, the time spent on memory allocations will largely outweigh the time spent iterating)."
cpp,3druwq,genderfluid_ptr,6,Sat Jul 18 22:29:40 2015 UTC,In your for-loop you should stop copying shared_ptrs   I tried to fix that in the Core Language.
cpp,3druwq,STL,4,Sat Jul 18 23:01:26 2015 UTC,"So long as reference-to-non-const can not bind to temporaries, knowing how to use ""auto &&"" is just a fact of life in C++. I would rather the language not have the inconsistency you proposed."
cpp,3druwq,detrinoh,2,Sun Jul 19 00:42:00 2015 UTC,"Blog post author here: Point taken on the using make_shared in the Create-function. make_unique was intentionally not used to stay with C++11 (as stated in the blog post).   Comparing the two memory allocations of the Pimpl case (shared_ptr + unique_ptr) to one memory allocation with the abstract base class (only shared_ptr) is not a fair comparison    Life isnt fair: The extra allocation in the pimpl ctor is an inherent limitation of Pimpls, as a user of a Pimpl class cannot avoid that happening.   (especially considering that in this test, as it stands, the time spent on memory allocations will largely outweigh the time spent iterating).   How so? Note that for the walltime measurements 100.000 instances were allocated and the two member functions were called 100.000 times on each instance (the for-loop is nested in a while loop). For the callgrind test 1000 instances were created and the two member functions were both called 1000 times on each instance. I dont think the allocations dominate that.  In general, this test was done with a non-trivial class in mind, as only then a Pimpl or an abstract base class are justifiable. Such a class is expected to be a reference type and have possible shared ownership by clients. It was not intended for value types, which I personally thing should never need either a ABC or a Pimpl, because if they do, they already outgrew being a value type in size/complexity in the first place."
cpp,3druwq,Sweetshark,3,Sun Jul 19 14:03:59 2015 UTC,"Life isnt fair: The extra allocation in the pimpl ctor is an inherent limitation of Pimpls, as a user of a Pimpl class cannot avoid that happening.   You can get around dynamic allocation by having a fixed block of memory in the original class and then placement-new'ing into that in the pimpl class."
cpp,3druwq,grumbel,4,Sun Jul 19 15:09:00 2015 UTC,"You can get around dynamic allocation by having a fixed block of memory in the original class and then placement-new'ing into that in the pimpl class.   Yes, but that kinda defeats the purpose for having a Pimpl in the first place as you either have to have to reserve an oversized memory bock in there to allow for future extension of the implementation, or you will depend on implementation details (the size of the implementation class) again. In the first case its only a question of time until it runs either in a ""640K of memory should be enough for anybody."" kind of problem or wastes questionable amounts of memory for future extensions that possibly never happen."
cpp,3druwq,Sweetshark,2,Sun Jul 19 15:31:53 2015 UTC,But having the two levels of indirection isn't necessary: I usually pass the PimplClass by value and have a shared_ptr to its ::Impl instead of a unique_ptr. Is this bad for some reason I'm not seeing?
cpp,3druwq,abadams,2,Sun Jul 19 16:27:30 2015 UTC,"That would mean that copying the copying an instance of the outer class refers to the same implementation and state as the instance copied from. This might be quite non-obvious to client code and might lead to obscure/hard to debug errors. Having a shared_ptr to a abstract base has much cleaner semantics as its more obvious if you want to copy just-another-pointer or if you really want a new cloned instance. Very explicitly documenting this etc. might alleviate the impact somewhat, but why bother when you can have a shared_ptr to an ABC that behaves with fewer surprises overall?"
cpp,3druwq,Sweetshark,1 point,Sun Jul 19 21:15:01 2015 UTC,"It's actually incredibly easy to make a proper, shared content, copy-on-write pimpl.  https://crazycpp.wordpress.com/2014/09/13/pimplcow/  Use polymorphism only when you want polymorphism.  There's no reason at all to have abstract base if you are not using polymorphism."
cpp,3druwq,Crazy__Eddie,9,Tue Jul 21 08:22:14 2015 UTC,"Pimpl is not used to ""reduce build times"" is my experience. It is however, necessary in order to provide binary compatibility across library versions. See the KDE documentation on this at TechBase/Library Code Policy  and TechBase/Binary Compatibility Issues With C++ ."
cpp,3druwq,milliams,1 point,Sun Jul 19 13:13:46 2015 UTC,"It does reduce build times in some cases - you need to change .h files less often, and thus the files that include them do not need to be recompiled."
cpp,3druwq,ivan-cukic,3,Tue Jul 21 19:24:02 2015 UTC,"What about for cases such as QT's d pointers?  Interfaces are great, but they aren't as malleable as pImpls.  There also is always the fact someone else can implement your interface, which you might not want.  The syntax is nice for pimpls when they're actually used, since you don't always need a pointer to one.  Sometimes still abstract classes are better, but I think arguing strict superiority is wrong."
cpp,3druwq,SadisticPenguin,3,Sun Jul 19 00:27:44 2015 UTC,"Interfaces are great, but they aren't as malleable as pImpls.   Could you elaborate? What do pImpls/d pointers allow, what abstract base classes do not? (assume ""d pointers"" to be just another name for pImpl as the kde techbase link provided elsewhere says so)"
cpp,3druwq,Sweetshark,2,Sun Jul 19 14:14:15 2015 UTC,"Adding members that are not part of the interface in the pimpl is opaque.  Otoh private members are still part of a class, still afect the compile times and the abi"
cpp,3druwq,tcris,1 point,Sun Jul 19 18:27:04 2015 UTC,"I'd recommend looking up how QT actually does it, they have a couple of macros that they use together with the pImpl pattern to help make the usage of pImpl nice even in the face of inheritance and other concerns.  Note that this is mainly for plugin systems, and when you have multiple things linked to each other which are independently versioned.  With QT, their usage of D pointers allows them to easily add to classes and still maintain binary compatibility.  So you can change the interface, but still just replace the .dll and go.  When versioning abstract classes you may run into all sorts of eldritch horrors such as ISomethingV2 or ISomethingYouNeedToCastFor.  There are some work arounds for this, but they're also clunky with a lot of boilerplate.  QT's pattern might start looking attractive here.  Even still, if you're writing actually ""plug-in"" sort of code, an interface is what you want.  If you want to plug in your own Renderer, Sound Engine, etc.  The pImpl approach is attractive if very large libraries with code churn where you don't want inversion of control, or possibly for low-level engine code that needs binary compatibility and wants to use C++ over C."
cpp,3druwq,SadisticPenguin,2,Sun Jul 19 19:32:47 2015 UTC,"Would be interesting to see, if using make_shared has any more effect on your code. It would turn 2 allocations into one."
cpp,3druwq,meetingcpp,3,Sat Jul 18 21:47:53 2015 UTC,"Pimpl will speed up your compilation, true, but I wonder if the extra level of indirection won't trash the cache on modern processors and, most importantly, if the use of this idiom doesn't make the code harder to understand for the next guy that wants to modify/update your code."
cpp,3druwq,AlexeyBrin,4,Sun Jul 19 15:04:40 2015 UTC,"I've used pimpls in production code with a team of C++ developers, and as long as the community (you, me, the people in this thread) come to an agreement on the usefulness of this idiom, the next person who wants to modify/update the code will:   Be familiar with the idiom so it won't seem foreign and jarring Understand that there's a pattern being used and that it should be stuck to, reinforcing the interface/implementation separation Report back to the community about the production use of said idiom and complete the cycle.   Idioms are just that, they're patterns developed over time to solve a specific class of problems. That they may be hard to understand sometimes either means the idiom isn't idiomatic, or the developer hasn't been indoctrinated yet :P."
cpp,3druwq,whoshuu,1 point,Mon Jul 20 11:44:30 2015 UTC,"That they may be hard to understand sometimes either means the idiom isn't idiomatic, or the developer hasn't been indoctrinated yet :P.   This is true on so many levels."
cpp,3druwq,AlexeyBrin,2,Mon Jul 20 13:20:28 2015 UTC,"While I think generally abstract base classes are better for most use cases I don't think that Pimpl would be used in the way you've tested it in most implementations that would chose to use Pimpl over ABC (I've not read effective C++ however).  I'd expect Pimpl to be used to create either a value object (so std::vector<PimplClass> instead of wrapping it in a unique_ptr and implementing move construction in the PimplClass) or a reference object which is created from a factory function (like your ABC test) that allocates the necessary space for the implementation inline to avoid double dereferences.  Also your for-each loop copies shared_ptr with every iteration, I'd expect the difference between inline and either of the others to be much larger so might try to use for(auto& pInstance : vInstances).  I still don't recommend the usage of Pimpl in C++ as ABC has much better language support. I'd only consider it for cases where the virtual call overhead matters but I don't want to/can't inline the function (a much larger performance loss usually), which is very rare."
cpp,3druwq,jaschmid,1 point,Sun Jul 19 18:06:29 2015 UTC,"I'd only consider it [Pimpl] for cases where the virtual call overhead matters but I don't want to/can't inline the function (a much larger performance loss usually), which is very rare.   But when the virtual call overhead really matters, wouldnt  resolving the pImpl pointer to access members matter in much the same way? Otherwise, I completely agree."
cpp,3druwq,Sweetshark,1 point,Mon Jul 20 13:56:23 2015 UTC,"If it is implemented in the way it was in the article (requiring two indirections to get to data) then yes, but there's more convoluted ways of implementing it that avoid this, like one I tried to mentioned in my message:  // header (Foo.h)  class Foo { public:     int foo();      static std::unique_ptr<Foo, void(*)(Foo*)> createInstance(); private:     friend class Bar; // so no one else can implement it     Foo() {}     ~Foo() {} };  // implementation (Foo.cpp)  class Bar : public Foo { public:     Bar() : a(1), b(2) {}     ~Bar() {}      static void destroy(Foo* foo) { static_cast<Bar*>(foo)->~Bar(); }  int a, b; };  std::unique_ptr<Foo, void(*)(Foo*)> Foo::createInstance() {     return std::unique_ptr<Foo, void(*)(Foo*)>(new Bar, &Bar::destroy); }  int Foo::foo() {     Bar* _this = static_cast<Bar*>(this);     return _this->a + _this->b; }   like this the call to Foo::foo should be essentially identical to any regular invocation of a member function (except non-inlineable due to being in a different compilation unit) and should be cheaper than a virtual function or identical if the compiler can optimize away the virtual call. Accessing member variables is always a single pointer indirection, and static_cast is a no-op in single inheritance.  Here you could also just implement int Foo::foo() to do return static_cast<Bar*>(this)->foo(); for longer functions, then you can just implement them as you would a normal function implementation in Bar and the compiler should inline them from Bar into Foo.  The only indirect call in this case is the destructor, which is called through a function pointer and almost the same as a virtual destructor, except that the pointer is stored in the unique_ptr instead of the vftbl (the class has no vftbl).  Again usually I don't recommend this, it's uses are restricted to needing to micro-optimize function calls and knowing the compiler cannot optimize away the virtual function call. An example of this would be an API for implementations of a shared library where even link time optimization cannot remove the virtual call for ABC."
cpp,3druwq,jaschmid,1 point,Mon Jul 20 18:07:57 2015 UTC,private:     ~Foo() {}   OOPS!!
cpp,3druwq,Crazy__Eddie,1 point,Tue Jul 21 08:28:55 2015 UTC,"That's intentional, you can only create an instance with Foo::createInstance()"
cpp,3druwq,jaschmid,1 point,Tue Jul 21 08:32:59 2015 UTC,My sarcasm mode is in danger of activating...  Bar can't be properly deleted and your code should not compile.  The problem is that derived classes do not have access to private members of base classes--that's the purpose of protected.  Derived has to call base destructor.
cpp,3druwq,Crazy__Eddie,1 point,Tue Jul 21 08:40:31 2015 UTC,"The only derived class there is and can ever be is friended, making a second derived class would break things. Foo's destructor is only ever called from Bar, calling it from anywhere else would be incorrect since it's not virtual. (No instance of type Foo ever exists, so calling it's destructor or constructor from anywhere but Bar would be an error)"
cpp,3druwq,jaschmid,1 point,Tue Jul 21 08:43:03 2015 UTC,"My bad, didn't see the friendship.  Code compiles at least.  No f'n way I'd let it fly in code review though.  Complicating things for no reason."
cpp,3druwq,Crazy__Eddie,1 point,Tue Jul 21 08:50:29 2015 UTC,"I'd not accept any use of Pimpl without some serious data to back up it's necessity in a code review, so the point is kind of moot. Project requirements are different though so if it's commonly used in a project knock yourself out."
cpp,3druwq,jaschmid,3,Tue Jul 21 09:01:04 2015 UTC,"Pimpl, as suggested by Effective Modern C++ when using C++11, but not C++14:   What does ""but not C++14"" mean here?"
cpp,3druwq,OldWolf2,8,Sun Jul 19 00:18:27 2015 UTC,no std::make_unique<T> in C++11.
cpp,3druwq,sakarri,2,Sun Jul 19 01:16:12 2015 UTC,"That's just syntactic sugar though. I'm not sure what OP was trying to say, it seems like he is saying EMC++ recommends to not use pImpl in C++14 or something"
cpp,3druwq,OldWolf2,6,Sun Jul 19 01:28:23 2015 UTC,"That's just syntactic sugar though.   It's more than syntactic sugar, std::make_unique also offers exception safety for the managed object. For example:  Not exception safe:  foo(new int(1), new int(2));   Exception safe:  bar(std::make_unique<int>(1), std::make_unique<int>(2));"
cpp,3druwq,AntiProtonBoy,4,Sun Jul 19 04:21:08 2015 UTC,"OK, but with a Pimpl we're not doing anything else between the new and the binding to the unique_ptr."
cpp,3druwq,OldWolf2,1 point,Sun Jul 19 05:06:21 2015 UTC,invoking a constructor?
cpp,3druwq,seshbot,1 point,Sun Jul 19 13:28:47 2015 UTC,? New invokes the constructor as well.
cpp,3druwq,cleroth,1 point,Sun Jul 19 19:51:55 2015 UTC,"hmm, maybe i misunderstood - I thought you were suggesting that the non-make_unique() solution is somehow still exception safe. I was saying that it cannot be because your constructor may throw before ownership has passed to the unique_ptr"
cpp,3druwq,seshbot,1 point,Mon Jul 20 07:52:40 2015 UTC,"It's only not exception safe when you have multiple calls that can get evaluated in undefined order. If you change your example from one line to three, where you separately create each integer pointer before calling foo/bar, then it will be exception safe. So It's still mostly syntactic sugar."
cpp,3druwq,quicknir,2,Tue Jul 21 01:26:46 2015 UTC,"The blog post was written with LibreOffice as target project in mind. LibreOffice uses C++11 currently, but does not require C++14 from compilers (thus C++14 isnt used yet in LibreOffice)."
cpp,3druwq,Sweetshark,1 point,Sun Jul 19 14:36:20 2015 UTC,"Whatever it is, in C++11 make_unique is not available so the author uses new T.  In C++14 the author would use make_unique."
cpp,3druwq,sakarri,2,Sun Jul 19 15:49:56 2015 UTC,"It may be a shortcoming of my own brain, but I kept going crosseyed trying to read code in that Baskerville typeface.  I hope I'm not dyslexic."
cpp,3druwq,shmoopty,2,Sat Jul 18 21:52:23 2015 UTC,I don't understand something. Pimpl is used for hidding code. With abstract class the code is not hidden.  The advantage of hidding a code is that the user may continue to use the API without knowing anything about the internal code. So it will not be tempted by using internal features and it is more convenient for the code to evolve.
cpp,3dqm44,jeandudey,5,Sat Jul 18 14:34:51 2015 UTC,"Somewhere, several thousand undergraduate Machine Learning students are crying out in anguish- as the difficulty of their homework assignments increase slightly due to publishing of pre-canned solutions."
cpp,3dqm44,ksteinberg,3,Sat Jul 18 19:26:40 2015 UTC,That's what i call evolution :p
cpp,3dqm44,Elador,3,Sat Jul 18 19:33:33 2015 UTC,"Just curious, why do you define a destructor in Perceptron? I think the best practice is to leave it out in this case."
cpp,3dqm44,incongruousamoeba,1 point,Sat Jul 18 22:23:17 2015 UTC,Because the first design I had was to use dynamic arrays and thought I would need free memory in the destructor.  Thanks for the feedback!:D
cpp,3dqm44,OldWolf2,3,Sun Jul 19 13:35:29 2015 UTC,"train() is going to loop forever if you give it non-separable data, e.g. XOR -- you might want to pass in a maximum number of iterations."
cpp,3do75k,mttd,19,Fri Jul 17 21:44:04 2015 UTC,Why not a reference?
cpp,3do75k,hahanoob,2,Sat Jul 18 05:06:43 2015 UTC,references aren't reassignable
cpp,3do75k,Angarius,14,Sat Jul 18 06:29:37 2015 UTC,std::reference_wrapper is though.
cpp,3do75k,Drainedsoul,-4,Sat Jul 18 06:43:37 2015 UTC,"And is implemented as a pointer...  Edit: downvoters: Here is the libc++ code for reference_wrapper.  template <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper     : public __weak_result_type<_Tp> { public:     // types     typedef _Tp type; private:     type* __f_; /// <<<<< pointer here  public:     // construct/copy/destroy     _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT         : __f_(_VSTD::addressof(__f)) {} #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES     private: reference_wrapper(type&&); public: // = delete; // do not bind to temps #endif      // access     _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}     _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}      // invoke     template <class... _ArgTypes>        _LIBCPP_INLINE_VISIBILITY        typename __invoke_of<type&, _ArgTypes...>::type           operator() (_ArgTypes&&... __args) const           {               return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);           } };"
cpp,3do75k,doom_Oo7,5,Sat Jul 18 13:20:24 2015 UTC,so are references
cpp,3do75k,Heuristics,2,Sat Jul 18 20:24:56 2015 UTC,[optimized-out reference]
cpp,3do75k,doom_Oo7,0,Sat Jul 18 22:14:23 2015 UTC,What does that even mean?!
cpp,3do75k,Gotebe,2,Sat Jul 18 21:32:41 2015 UTC,This : http://goo.gl/vNLCz3
cpp,3do75k,doom_Oo7,3,Sat Jul 18 22:17:09 2015 UTC,"Assembly and machine instructions have no notion of pointers.  What I was trying to say was that ""references are implemented as pointers"" makes no sense.  What you have shown is that use of pointers/recerences results in same disassembly (no problem there).  But, for example, the conceptual intention of your functions is fundamentally different. When you use a pointer, you're saying: here's an optional parameter. When you use a reference, optionality is gone.  At best, one can say something along the lines ""references are like pointers, but constrained in functionality, e.g. so that you can't change the pointee, they can't be null, you can't pointer arithmetic on them...""."
cpp,3do75k,Gotebe,2,Sun Jul 19 06:12:35 2015 UTC,"What I was trying to say was that ""references are implemented as pointers"" makes no sense.   It makes sense if ""implemented as"" means the same thing as ""practically equivalent and sometimes better"", which I think was the case for /u/Heuristics"
cpp,3do75k,doom_Oo7,0,Mon Jul 20 08:48:00 2015 UTC,"How is e.g. ""can't be re-seated, can't be null, can't do arithmetic"" practically equivalent!?"
cpp,3do75k,Gotebe,16,Mon Jul 20 10:13:17 2015 UTC,"""i_promise_i_checked_for_null_t"""
cpp,3do75k,Trout_Tickler,1 point,Sat Jul 18 11:54:48 2015 UTC,can you promise something that happened in the past? shouldn't it be i_swear_i_checked_for_null_t?
cpp,3do75k,mare_apertum,10,Mon Jul 20 08:48:59 2015 UTC,I think the major issue of doing non nullable pointers in C++ is the issues of move. What's append when you move from a non nullable pointer. Looking at the code it appears that it becomes a null pointer. I wish C++ had something like Rust does that when you move from an object you can no longer use it without reinitializing it.   If I missed something and you solved the issue with moving I would be most interested to hear how it was done.
cpp,3do75k,jbandela,1 point,Sat Jul 18 01:54:09 2015 UTC,In the case of nn_unique_ptr<T> and a nn_shared_ptr<T> I think you're right.
cpp,3do75k,sellibitze,5,Sat Jul 18 07:19:31 2015 UTC,"Given this, I don't see the point of the library."
cpp,3do75k,quicknir,2,Sat Jul 18 14:13:14 2015 UTC,Declaration of intent? As long as you do not explicitly do std::move your intent is that this pointer never is nulll
cpp,3do75k,cynicalsingularity,2,Sat Jul 18 17:43:10 2015 UTC,"So it's basically a normal owning pointer, except without a default constructor or reset. For very small benefit, you have to deal with the overhead of a new type. It's still not a perfect guarantee so you'll still need checks. If the guarantee were perfect it would be worth considering."
cpp,3do75k,quicknir,2,Sat Jul 18 20:32:25 2015 UTC,If you think of it as an way to help enforce  pre and post conditions for every function that takes or returns the nn pointer it makes more sense.
cpp,3do75k,cynicalsingularity,1 point,Sun Jul 19 07:13:57 2015 UTC,I guess you won't like what the committee decided how std::variant should work.
cpp,3do75k,sellibitze,2,Sat Jul 18 18:22:50 2015 UTC,Can you elaborate? A pointer and a variant are apples and oranges. I have been following variant closely and agree with their decisions almost entirely.
cpp,3do75k,quicknir,1 point,Sat Jul 18 20:51:17 2015 UTC,"A pointer and a variant   In principle, yes. But if your implementation of the variant type family always includes a state in which a variant object does not store any value then they would share this ""nullability"" property with pointers. IIRC, std::variant will have an ""empty"" state that just got renamed to ""invalid"". Its interface tries hard to avoid this state. You can't construct a variant to be invalid, for example. But it's still possible to get a variant object into such a state. It involves exceptions."
cpp,3do75k,sellibitze,2,Sun Jul 19 18:21:13 2015 UTC,"Null for pointers is a fundamentally valid state, otherwise owning pointers are not moveable. Null can happen to a pointer through valid actions.   There is no valid similar state for variant. It only occurs when you swallow an exception. I still don't see why you thought I wouldn't like variant."
cpp,3do75k,quicknir,-1,Mon Jul 20 00:17:10 2015 UTC,Indeed. What would have been wrong with forbiding move?!
cpp,3do75k,Gotebe,9,Sat Jul 18 21:31:52 2015 UTC,I don't see the point of this (no pun intended)
cpp,3dmv72,Coder_CPP,8,Fri Jul 17 15:41:42 2015 UTC,LLVM also has a re-implementation of the libunwind interface in libc++   Not anymore. They've been properly split up into two separate repositories now.
cpp,3dmv72,hotoatmeal,3,Fri Jul 17 18:08:23 2015 UTC,I just copy-paste a small backtrace function in every project and bind it as a SIGSEGV handler.
cpp,3dmv72,devel_watcher,1 point,Fri Jul 17 17:35:32 2015 UTC,Can you go I to more detail?
cpp,3dmv72,__Cyber_Dildonics__,3,Sat Jul 18 04:38:43 2015 UTC,"Don't have final version here (there were fixes to installing the handler and two more architectures), but it looks something like that:  #if defined(__linux__) && (defined(__x86_64__) || defined(__i386)) #include <signal.h> #include <execinfo.h> #include <bits/sigcontext.h> #include <unistd.h> /* Signal handler to get crash backtraces on Linux */ void bt_sighandler(int sig, struct sigcontext ctx) {     void *trace[16];     char **messages = (char **) NULL;     int i, trace_size = 0;  #   if defined(__x86_64__)     if (sig == SIGSEGV)         fprintf(stderr, ""Got signal %d, faulty address is %p, from %p\n"", sig, (void *) ctx.cr2, (void *) ctx.rip);     else         fprintf(stderr, ""Got signal %d\n"", sig);      trace_size = backtrace(trace, 16);     /* overwrite sigaction with caller's address */     trace[1] = (void *) ctx.rip; #   elif defined(__i386)     if (sig == SIGSEGV)     fprintf(stderr, ""Got signal %d, faulty address is %p, from %p\n"", sig, (void *) ctx.cr2, (void *) ctx.eip);     else     fprintf(stderr, ""Got signal %d\n"", sig);      trace_size = backtrace(trace, 16);     /* overwrite sigaction with caller's address */     trace[1] = (void *) ctx.eip; #   endif     messages = backtrace_symbols(trace, trace_size);     /* skip first stack frame (points here) */     fprintf(stderr, ""Execution path:\n"");     for (i = 1; i < trace_size; ++i)     {         char syscom[1024];         snprintf(syscom, 1024, ""echo '#%d %s' | ""                 ""sed 's_\\(#[0-9]\\+ \\).*(\\(\\([^/]*\\)\\(+0x[0-9a-f]*\\)\\)\\?)\\( \\[0x[0-9a-f]*\\]\\)_\\1(\\3) \\4\\5_' | ""                 ""c++filt | ""                 ""sed 's/\\(#[0-9]\\+ \\)(\\(.*\\)) \\(+0x[0-9a-f]*\\)/\\1\\x1B[32m\\2\\x1B[0m \\3/'""                 "" > /dev/stderr\n"", i, messages[i]);          if (system(syscom) != 0)             fprintf(stderr, ""print failed\n"");          char exe_name[256];         ssize_t len = readlink(""/proc/self/exe"", exe_name, 256);         if (len != -1)         {             exe_name[len] = '\0';             snprintf(syscom, 1024, ""addr2line %p -e %s > /dev/stderr\n"", trace[i], exe_name); //last parameter is the name of this app             if (system(syscom) != 0)                 fprintf(stderr, ""addr2line failed\n"");         }         else         {             fprintf(stderr, ""ERROR: Cannot get executable file name"");         }     }      exit(1); } #endif   Installing handler:  #if defined(__linux__) && (defined(__x86_64__) || defined(__i386))     /* Install our signal handler */     struct sigaction sa;      typedef void (*sigaction_int_handler_t)(int);     sa.sa_handler = (sigaction_int_handler_t) bt_sighandler;      sa.sa_flags = 0;     sigemptyset(&sa.sa_mask);      sigaction(SIGSEGV, &sa, NULL);     sigaction(SIGABRT, &sa, NULL);      /* ... add any other signal here */ #endif"
cpp,3dmv72,devel_watcher,5,Sat Jul 18 10:06:54 2015 UTC,Huh I just use conditional break point and script gdb to print a backtrace before continuing. I'm amazed by how few people I work with who use scripting in gdb. Could be it's because that feature is buggy as hell...
cpp,3dmv72,glinsvad,3,Fri Jul 17 22:14:47 2015 UTC,"In Windows, there are API calls for the stack trace; you can programmatically produce the same thing you see in a debugger. Sample project here"
cpp,3dmv72,OldWolf2,2,Sat Jul 18 01:53:36 2015 UTC,"It's not as fun, but dude could also set a bunch of breakpoints and set them to print the call stack and resume when they're hit. Might save some build time."
cpp,3dmv72,WiseAntelope,-4,Fri Jul 17 17:28:44 2015 UTC,"You gotta be a true quiche eater to need a library to access the call stack.  Back in the day, when men where real men, to get access to the call stack, you would just declare a variable at the start of a function call, take it's address and subtract 8 bytes from it. Now if for some reason you're a sissy quiche eater and can't work with hex addresses, you can pull the names & addresses of every function from the ELF file to compare against.  void myfunction() {     int dummy;     uint32_t * next_instruction_ptr = &dummy - 2 }   void different_function() {        myfunction()        next_instruction() //ptr above is the location of this line  }    This works because local variables are stored 8 bytes after the frame pointer, and the frame pointer always points to the return address (aka the next instruction address)."
cpp,3dmv72,lolzfeminism,1 point,Sat Jul 18 06:24:18 2015 UTC,"This is actually cool information, but crowds are not good at separating substance from presentation and so we end up with ad hominem downvotes."
cpp,3dmv72,__Cyber_Dildonics__,1 point,Sun Jul 19 02:52:15 2015 UTC,"I can't figure out what kind of deep game lolzfeminism is playing, but I'm pretty sure they were referencing ""Real Men Don't Eat Quiche"". I really hope it was meant ironically <shudder>."
cpp,3dmv72,incongruousamoeba,1 point,Sun Jul 19 03:42:20 2015 UTC,"Real Programmers don't use Pascal   Check it out, hilarious read. It's a parody of ""real programmer"" culture and the ""real men don't eat quiche"" article.  Yes, it was tongue in cheek."
cpp,3dmv72,lolzfeminism,1 point,Sun Jul 19 06:35:41 2015 UTC,"This works because local variables are stored 8 bytes after the frame pointer, and the frame pointer always points to the return address (aka the next instruction address).   This is not portable at all."
cpp,3dlwqg,SlightlyCyborg,11,Fri Jul 17 09:38:45 2015 UTC,"Removing the object files from the repository would be a start. I would suggest using CMake instead of manually writing your Makefiles, and you should look at well organized projects on GitHub, or read through one of the many threads about this on StackOverflow. Like this one: http://stackoverflow.com/questions/13521618/c-project-organisation-with-gtest-cmake-and-doxygen"
cpp,3dlwqg,no1msd,3,Fri Jul 17 10:23:32 2015 UTC,"As long as your project stays relatively small, this style of makefile will work just fine.  You could do some things with creating a list of sources (e.g. $SRC = file1.c file2.c file3.c), convert that to a list of object files, create implicit rules, etc.  But generally speaking, this probably does the job for what you need.    Makefiles also excel at managing flat file structures, since that's the world it was made for.  They become tough to manage once you start having nested file trees.  It's manageable, but can be cumbersome.  This is why people invest in things like CMake.  I cannot recommend the solutions that have come before this like (::cringe::) Automake, or 'recursive Make'; we have better tools these days.    A weakpoint with Make is with respect to managing dependency relationships that are documented in the code, like header files.  After all, the ideal Makefile is something you can just plop into the project and it'll work with minimal configuration. This area is a mess, and there are a few approaches, but none are without drawbacks and usually require heavy amounts of scripting and/or pulling in additional tools.  Going forward, here are some things to look into:  Makefile:   At a minimum, move the common clang + flags into variables, to cut down on repetition.  Use names that make sense for the task at hand. Your clean target should remove the compiled binaries as well as the object files.  Also, you want to force removal in case there are no .o files yet.  This way, you can issue a make clean before git status, and have as few warnings as possible regarding untracked files. Add an explicit all target that builds all the binaries: Add a .PHONY line so that Make doesn't confuse meta targets with actual filenames (good form):   Example:  CLANG := clang++ -std=c++11 -stdlib=libc++ LINK := clang++ `sdl-config --cflags --libs` -lSDL_ttf -lSDL_image -lSDL_gfx -std=c++11 -stdlib=libc++ -v  sim.o: sim.cpp sim.h     $(CLANG) -g -c sim.cpp  test_sim: sim.o test_sim.o     $(LINK) -g -o test_sim sim.o test_sim.o  # other targets go here  clean:     rm -f *.o `     rm -f test_sim test_robot test_world simulatormake  all: test_sim test_robot test_world simulatormake  .PHONY: all clean   General Review:   using ']' as a filename is bad form.  Use the same rules for identifiers as you would for file names - it makes life easier on the command line. Remove the .DS_Store file from the repo since it only helps Finder on OSX, and even then, it's just a cache. Add '.DS_Store' to your .gitignore file, and check that into the project. As others have mentioned, remove the .o files from the repo Add '*.o' to .gitignore to prevent those from being checked in.   Suggested Reading:   As others have mentioned: CMake Makefile implicit rules Other C++ projects that use Makefiles - learning from other examples will be more succinct than the (awful) GNU docs."
cpp,3dlwqg,ericanderton,2,Fri Jul 17 13:27:53 2015 UTC,"A weakpoint with Make is with respect to managing dependency relationships that are documented in the code, like header files.   make handles dependencies just fine. My Makefile has perfect incremental rebuilds, and it takes just a few lines."
cpp,3dlwqg,STL,1 point,Fri Jul 17 16:42:05 2015 UTC,"Well, yes, Make is all about dependency graphs - that's what it does, and it excells at it. :)  What I was driving at is it's not aware of anything going on inside of files, by design.  That is: it only knows about the filesystem.  So you need additional tooling and clever make targets (and possibly BASH) to figure out what .h files a given .c file depends on.  Otherwise, you have to explicitly call out all of those relationships as OP has.  For example, one has to invoke something like gcc -MM to generate a C/C++ header dependency graph in order to make this more automatic.  Make doesn't do that for you:  http://stackoverflow.com/questions/2394609/makefile-header-dependencies"
cpp,3dlwqg,ericanderton,3,Fri Jul 17 17:20:06 2015 UTC,I did say that it takes just a few lines. Complaining that make doesn't handle dependencies is like complaining that C++ doesn't handle flexible-length sequences until you include <vector>.
cpp,3dlwqg,STL,1 point,Fri Jul 17 18:05:16 2015 UTC,"I did say that it takes just a few lines.   Specifically, a very basic version takes 3:  .deps:     find . -name ""*.cc"" | xargs -IQQQ $(CXX) $(CXXFLAGS) -MM -MG QQQ > .deps include .deps   That will scan all C++ files and create the relevant dependencies. This is rather simplistic since it doesn't update the dependencies automatically when the source changes, but in practice I find it works very well. I expect there are more sophisticated ones out there that do proper rebuilding of the dependencies too."
cpp,3dlwqg,serviscope_minor,2,Tue Jul 21 12:46:41 2015 UTC,Thanks for the detailed answer! I changed my file structure and makefile. I am reading up on how to use CMake
cpp,3dlwqg,jpakkane,3,Sat Jul 18 23:58:03 2015 UTC,"There's nothing wrong with writing Makefiles by hand if your needs are simple but the problem is that pretty soon you start requiring more stuff.   support for multiple compilers support for build types (debug, optimized etc) unit tests support for clang sanitizers, valgrind, cppcheck, other tools proper dependency tracking and so on   Adding support for any one of these in plain Make is not that difficult. Making more than one work properly together and not break every now and then is hard. Any time you spend massaging your makefile is time you are not coding. Not coding means not getting your problem solved.  Using a higher level build tool that does all that automatically is usually worth it. I recommend Meson but I'm biased because I wrote it. :)"
cpp,3dlwqg,maleic,5,Sat Jul 18 10:36:59 2015 UTC,"As no1msd says, you're probably better using CMake.  Otherwise, one simple thing you can do is bundle up the compiler flags as a makefile variable (as in DRY in regular coding)."
cpp,3dlwqg,DujekR,1 point,Fri Jul 17 10:34:44 2015 UTC,"+1 to CMake, I started learning about it a couple months ago and it's made my life a lot easier."
cpp,3dlwqg,devel_watcher,-3,Fri Jul 17 16:30:12 2015 UTC,"Btw, you've posted your code without watching the Stroustrups lecture: https://www.reddit.com/r/cpp/comments/3dhivo/bjarne_stroustrup_what_if_anything_have_we/  P. S. '+' to CMake"
cpp,3dlm12,SushiAndWoW,6,Fri Jul 17 07:02:40 2015 UTC,"I don't think it is necessary to allow destructors to throw exceptions. According to RAII what is the purpose of a destructor? Release resources allocated in the constructor, like memory, file handles or mutex locks.  All resource cleanup functions I have encountered can only throw, if the resource is double freed or never allocated at all. These are logic errors, the precondition for the destructor has been violated.  And precondition errors shouldn't reported via exceptions, but via assertion - log and abort. If a precondition has occured, the program is in an invalid, inconsistent state and should be terminated immediately.  Your often cited closesocket can only fail according to MSDN, if:   not initialized - precondition violation network down - ""yeah, sorry, cannot cleanup""; program can't clean it up, can be logged, but destructor should continue as normal descriptor not a socket - precondition violation blocking call in progress - precondition violation, socket should be in a state where it can be freed cleanup canceled - wait, why does another class have access to the handle while in destructor? -> bad design cleanup would block - according to description looks like a precondition violation or logic error by class programmer, too   And those precondition violations can never occur if RAII is properly used, so checking can be ommitted totally."
cpp,3dlm12,foonathan,1 point,Fri Jul 17 18:33:20 2015 UTC,"I had a similar problem recently, our application needed to mount a remote disk. I had a RAII wrapper that automatically unmounted the disk when done.. problem is, the unmount operation could fail (actually this happened quite often) and it is not ok to ignore the error ( the disk would remain mounted ).  In the end I had to do the whole thing in the old mount()/unmount() style."
cpp,3dlm12,sbabbi,1 point,Mon Jul 20 14:04:11 2015 UTC,"You cannot reasonably claim that the same error is simultaneously:   OK to ignore; a valid reason for whole program abort.   This is what you guys - I'll call you destruction error denialists - are claiming. At the same time, I should be ignoring the error, and terminating my entire service over it.  Why are you made so uncomfortable by the possibility that a destructor error could be a type 2 error, where partial program unwinding is appropriate?  You are hand-waving in order to coerce all possible types of destructor errors into being either type 1 (whole program abort) or type 3 (OK to ignore), not because you're actually sure that this is the case; but just because you don't want to make the minor adjustment of allowing destructor errors to be type 2 errors.  You're putting the cart ahead of the horse. First you must allow for the possibility that destructor errors can be type 2 errors.  Then you make a decision whether a particular error is type 1, 2, or 3; when you're no longer being coerced to choose between 1 and 3 only."
cpp,3dlm12,foonathan,3,Sat Jul 18 05:07:05 2015 UTC,"You cannot reasonably claim that the same error is simultaneously:   OK to ignore;    a valid reason for whole program abort.     I am not saying that. I am saying that most kind of errors that can occur in cleanup functions are precondition violations. And precondition violations should mean program abortion. But since those precondition violations can never occur if you use proper RAII, the checking could be omitted. I am not saying to ignore precondition violations, I am saying that they cannot occurr and thus don't need to be checked.  For the other, very small percentage of cleanup errors, like the network down for closesocket(), it might be the appropriate way to throw an exception, your error handling type 2. But I personally wouldn't do it, even if I had the language support for it. In addition, it is such a small percentage, a language extension isn't really worth the trouble."
cpp,3dlm12,griwes,0,Sat Jul 18 09:42:28 2015 UTC,I just recently made this attempt to further explain why type 2 (exceptions) is most appropriate for my usage case.  Does that help?
cpp,3dlm12,tasty_crayon,1 point,Sat Jul 18 10:00:33 2015 UTC,"Precondition violation should always mean a call to std::terminate.  Precondition violation basically means ""the program is in a state it is not allowed to be in"", which means all your other assumptions and invariants may not hold, so, say, logging can trash your operating system on disk, and throwing might crash it in memory. As soon as you detect a precondition violation, you exit.  If you expect any errors other than precondition violations in your dtors that are worth reporting, you are probably doing something wrong. Closing a file, or closing a socket, provided they are not in a dirty state (and if they are... you probably violated your preconditions somehow?), may safely fail. Log it, go on. Don't throw from dtors."
cpp,3dlm12,meetingcpp,1 point,Tue Jul 21 08:28:36 2015 UTC,"Precondition violation basically means ""the program is in a state it is not allowed to be in"",   There is a difference between precondition violations inside the program, and unexpected behavior of third party code with which I'm interfacing.  OS code, database code, any servers I'm talking to that host my resources - all of that is third party code. All of that code is outside of my trust boundary.  I have self-consistency checks in my program aplenty. Those checks are the ones that are authorized to crash the program. Checks for errors returned by database software, or from some server somewhere - those checks are not authorized to crash the program.  Checks of results from third party code are authorized to stop the progress of the current activity. That is what exceptions do. If I want to make such checks in destructors, I need support for multi-exceptions. If I can't make such checks in destructors, then I have to give up RAII.  I shouldn't have to choose between correctness and RAII."
cpp,3dlm12,gnzlbg,3,Tue Jul 21 19:38:01 2015 UTC,"I don't think std::nested_exception is the right solution for this kind of problem. nested_exception, to me, means ""I received an exception and translated it into a higher-level exception, but the lower-level exception is accessible if you need it"" (such as translating some sort of IOException class into a DatabaseException class).  Your case seems to be, some exception occurred which caused my destructor to run, and during my destructor something exceptional happened that I need to inform people of. The exceptions are completely unrelated and I don't think they should be nested in that manner."
cpp,3dlm12,griwes,1 point,Fri Jul 17 09:21:27 2015 UTC,"Yes; also, std::nested_exception aggregates in the opposite way than I would like. std::nested_exception wraps a secondary exception around the first one, and I would prefer that the other way around.  What I would most like to see is for the basic std::exception to be aggregatable, to allow any number of secondary exceptions to be added to it. For example, the outside and first exception is Smtp::TemporaryDeliveryFailure, which derives by some route from std::exception. During stack unwinding, closesocket fails, so there's an additional aggregated exception Socket::Error  also derived from std::exception.  The catch handler can then process just the outer (first) exception, which works for simple stuff, and provides same behavior as now, if closesocket result is ignored.  Alternately, the handler can go through the aggregated exceptions and e.g. log the failed closesocket, which is something that's rather tricky to do now."
cpp,3dlm12,iomonad2,3,Fri Jul 17 09:50:06 2015 UTC,"Well, maybe write a proposal? In general, its seen as bad to throw from destructors in C++ currently. So you will need good arguments, your blog post is a good start."
cpp,3dlm12,vlovich,1 point,Fri Jul 17 10:08:31 2015 UTC,"Well, maybe write a proposal?   Where should I post it?  I'm not a compiler writer, or even an STL implementor, so I may be unaware of major shortcomings of my proposal. For example, I do not envision this now, but perhaps the mechanics of automatically joining exceptions are prohibitive to implement on some important platform.   In general, its seen as bad to throw from destructors in C++ currently.   Yes, but this is directly because of the single-exception policy, and is a handicap in implementing destructors.  With unlimited exceptions, throwing from destructors would be a non-issue; it would allow destructors to be used more in the way people naturally want to use them (until they are told of restrictions)."
cpp,3dlm12,iomonad2,3,Fri Jul 17 10:15:02 2015 UTC,http://isocpp.org   There you will find everything you need to know about how to submit a proposal and also mailing list were you cans discuss your ideas before doing so.
cpp,3dlm12,vlovich,1 point,Fri Jul 17 10:21:37 2015 UTC,"Write a proposal; the committee will then explain to you why the whole idea is broken, and will do a better job at that than reddit."
cpp,3dlm12,iomonad2,8,Tue Jul 21 08:46:18 2015 UTC,"This is a bad idea. An exception should never be allowed to propagate out of a destructor because a destructor should never fail. What would it mean for a destructor to fail? It would mean that  the program can't make forward progress (it threw an exception in the first place) nor backward progress (unwinding also throws). You're left with an object that can't be cleaned up or even referred to, and you cannot avoid leaking memory and other resources.  If you think you need this, it means you're doing things in a destructor that don't belong there."
cpp,3dlm12,vlovich,3,Fri Jul 17 12:16:54 2015 UTC,"The simplest counter-example to your argument of ""destructors should never fail"" is scope guards: http://www.boost.org/doc/libs/1_58_0/libs/scope_exit/doc/html/scope_exit/alternatives.html  There's absolutely no way of implementing them without allowing them to throw in a destructor.  The C++ standards body only mandates invoking std::terminate when throwing from a destructor while already unwinding because the question becomes which exception gets propogated.  That does not necessarily mean that it's a design feature as opposed to a reasonable compromise due to the current implementation nor that it can't be changed; I do not know how the standards body as a whole feels about this topic although I suspect it runs the gamut of opinions."
cpp,3dlm12,iomonad2,2,Fri Jul 17 18:21:29 2015 UTC,I seem to be missing something here. Why do you need failing destructors to implement scope guards?
cpp,3dlm12,vlovich,1 point,Fri Jul 17 19:29:06 2015 UTC,on_success([] {     if (invariant violated) {         throw invariant_violated;     } });
cpp,3dlm12,Dascandy,2,Fri Jul 17 20:25:22 2015 UTC,"I guess that's an argument for allowing an exception to propagate out from a destructor in the non-unwinding case (though it doesn't add any weight to the case for aggregate exceptions). It still smells bad to me, though. Why is it okay to ignore ""invariant violated"" in the failure case? And why should this check/throw be in a scope guard rather than just at the end of the scope? The only argument that springs to mind is so that this code can be physically close to related code in the source. So we're just (ab-)using the destructor mechanism to move a chunk of code from one place to another - i.e. it's a destructor only in a technical sense, not in a moral one."
cpp,3dlm12,vlovich,1 point,Fri Jul 17 20:42:18 2015 UTC,"Why is it okay to ignore ""invariant violated"" in the failure case   Exactly!  Right now though you wouldn't be able to because throwing while throwing results in a termination without any way to fail gracefully.   And why should this check/throw be in a scope guard rather than just at the end of the scope   Imagine a nice long function with multiple returns:  if (!precondition 1) {     return; }  if (!precondition 2) {     return; }  error = do_work(); if (error) {     // non-fatal error     return; }  do_something_else();   Putting the invariant check in every return-path is tedious & error-prone.  It also suffers from copy-pasta.  So now you extract it into a function. And still there's copy-pasta error because a codepath might be missed.  Worse, someone might not realize it's supposed to be called from all paths so it's also a maintenance burden.   it's a destructor only in a technical sense, not in a moral one.   I'm not really concerned with morality & I'm not tied to using a destructor.  All I'm looking for is a mechanism that correctly runs a function when scope exits from which I can throw (i.e. takes into account object construction/destruction order).  Additionally, I would love being able to have multiple exceptions in-flight so that I can respond gracefully.  I suspect though that the destructor is already this mechanism & it's lower effort to figure out a way to get multiple exceptions in-flight."
cpp,3dlm12,Dascandy,1 point,Sat Jul 18 01:03:37 2015 UTC,"Right now though you wouldn't be able to because throwing while throwing results in a termination without any way to fail gracefully.   Touche. But the other arguments still apply - if we were allowed to change the on_success() to on_exit() we'd have two exceptions in flight and it's not obvious which one we'd want to catch.   Imagine a nice long function with multiple returns:   Ah, good point - I didn't consider the multiple return case. You can sort of think of ""return"" as a special case of ""throw"" (that's automatically caught by the containing function). If you'd normally be returning a value, you'd throw away that information in the ""invariant violated"" case.  I'm not sure there's much else I can say about this example without understanding the nature of the ""invariant violated"". The usual sense of that term suggests that it really should be what SushiAndWoW is calling a ""type 3"" error - one that should lead to instant termination of the program on discovery, but perhaps a more concrete example could change my mind."
cpp,3dlm12,vlovich,1 point,Sat Jul 18 08:09:10 2015 UTC,"if we were allowed to change the on_success() to on_exit() we'd have two exceptions in flight and it's not obvious which one we'd want to catch.   Exactly.  There were a few suggestions here on how such a thing would work.  I agree that it's a difficult design to figure out how to make work; maybe the answer is that there's no ""good"" answer & the language stays as-is.  Keep in mind however that Java has the same problem & their answer is not ""terminate the program"".   SushiAndWoW is calling a ""type 3"" error - one that should lead to instant termination of the program on discovery, but perhaps a more concrete example could change my mind.   My understanding is he's saying ""type 1"" is instant termination & ""type 3"" is ignore.  And he's also saying that he wants a middle-ground.  Now I don't know if this necessarily needs a language feature.  It can probably done more robustly & correctly as a language feature, but there are ways around it if you are in control of all your exceptions; for example you could make sure all exceptions inherited from something like nested_exception except so that you could attach it to the existing exception instead of having to generate a new exception."
cpp,3dlm12,iomonad2,1 point,Sat Jul 18 16:40:24 2015 UTC,How do you respond gracefully to a compound exception?
cpp,3dlm12,iomonad2,1 point,Mon Jul 20 21:08:12 2015 UTC,"By compound exception do you mean multiple exceptions in-flight?  Currently there is no mechanism in C++.  However, if there were language facilities for allowing this you could do it."
cpp,3dlm12,iomonad2,1 point,Mon Jul 20 21:38:09 2015 UTC,"Of course.  But for a second assume it exists, in whatever way you think will work best. How do you use it usefully?"
cpp,3dlm12,leftofzen,1 point,Mon Jul 20 21:42:27 2015 UTC,"Depends on the mechanism.  For example, I proposed instead of having multiple exceptions in-flight, being able to get a pointer to the current exception that's causing unwinding.  This would let me attach the generated exception to it as it keeps propogating.  In any case, how it gets to higher levels doesn't really matter.  The point is you'd have policy that dictates how to resolve multiple exceptions.  For example, if any exception is an out-of-disk error, do XYZ.  If there was a deserialization error, record something in statistics.  If there was ... etc.  Basically you would define policy that operates on multiple errors.  It does not absolve you of having a policy that makes sense.  I also do not dispute that such a mechanism could potentially be too complicated to actually be useful."
cpp,3dlm12,leftofzen,1 point,Tue Jul 21 09:17:34 2015 UTC,"An exception should never be allowed to propagate out of a destructor because a destructor should never fail.   The only reason we think destructors ""cannot fail"" is because the language lacks the concepts to handle it. All the language needs is this extension of the exception mechanism, and then destructors can fail just fine.  The failing nature of destructors does not change with this proposal. Destructors already fail. Ignoring errors doesn't mean they don't occur.  What this proposal suggests is a way for destructors to report failure. Currently, there are few good ways to handle destructor errors. You can ignore, log, or abort. If a destructor error happens in a library, there is no good way for the library to convey such an error to the user. The main ways to convey such errors are C-style hooks. Few people bother with that, so errors are being ignored.   It would mean that the program can't make forward progress (it threw an exception in the first place) nor backward progress (unwinding also throws).   Not at all! Continuing backward progress is trivial. Unwinding continues until a catch handler for the original exception is found, at which point forward progress resumes. The catch handler can process the original exception, as well as any additional exceptions that were aggregated from destructors during unwinding.  A destructor throwing doesn't mean that destruction didn't succeed to a standard sufficient for the program to continue. It means that there were issues with cleanup that do not require an abort. Such issues could be ignored, but in good implementations, would not be.  The proposal of aggregated exceptions provides an appropriate, backward-compatible, context-aware method of communicating destructor errors that aren't as critical as to require whole-program abort. There is currently no language solution for this, and alternatives (a standard logging facility?) would not be as general, or context-aware.  Adopting this proposal further allows destructors to become first-class methods, rather than second-class citizens that can't use a whole aspect of the language, and literally have to pretend like they're written in C."
cpp,3dlm12,mdf356,4,Fri Jul 17 12:28:53 2015 UTC,"The only reason we think destructors ""cannot fail"" is because the language lacks the concepts to handle it. All the language needs is this extension of the exception mechanism, and then destructors can fail just fine.   That would not fix the fundamental problem - that the failure of a destructor would leave the program in a state from which it could not recover.   The failing nature of destructors does not change with this proposal. Destructors already fail. Ignoring errors doesn't mean they don't occur.   I didn't say that they don't fail, I said that they shouldn't. If a destructor fails, the problem is not that C++ lacks the necessary abstractions to handle that, the problem is that the destructor is doing things that a destructor has no business doing. To believe that a destructor should be allowed to fail the same way that normal methods and functions can fail is to misunderstand the entire nature of a destructor.   Continuing backward progress is trivial. Unwinding continues until a catch handler for the original exception is found, at which point forward progress resumes.   That can be done perfectly well without any changes to the exception mechanism. Just put the information you want to throw out of a destructor into a global list and have the ""catch"" block go through that list and do what it will with the contents.  The semantics of an exception are ""the thing you asked me to do could not be done - execution cannot continue along the path that would otherwise have been taken"". But what you're suggesting should happen when an exception is thrown from a destructor is exactly that execution does continue along the path that would have previously been taken (continue to unwind until catch found).   A destructor throwing doesn't mean that destruction didn't succeed to a standard sufficient for the program to continue. It means that there were issues with cleanup that do not require an abort. Such issues could be ignored, but in good implementations, would not be.   That is not something that should be signalled with exceptions. An exception means ""what you asked me to do I could not do"", not ""it basically worked but here are some informational messages"". What would a program be expected to do with such cleanup issues anyway? The object they are about is already gone! About all you can do is ignore, abort or log. And you can do any of those things from inside the destructor.   There is currently no language solution for this, and alternatives (a standard logging facility?) would not be as general, or context-aware.   I don't understand what this would achieve that a logging mechanism wouldn't.   Adopting this proposal further allows destructors to become first-class methods, rather than second-class citizens that can't use a whole aspect of the language, and literally have to pretend like they're written in C.   Not at all - you can do anything inside a destructor that you can do anywhere else inside a C++ program, including throwing exceptions. You just can't let exceptions propagate out of the destructor. If you want to run code that might throw inside a destructor, you have to put a catch block inside the destructor and the possibly-throwing code inside that.  Perhaps a good way to think about it is to imagine that, while an exception is in flight and the stack is being unwound, it's almost like your program isn't being run at all but has been replaced with a completely different program (the unwinder) which shares the same memory space but has a different call stack. The unwinder contains no ""catch"" blocks of its own so if you allow an exception to escape into it, the unwinder is itself completely unwound and terminates with an ""uncaught exception"". With at least one C++ implementation I'm familiar with, this is essentially what is happening under the hood."
cpp,3dlm12,o11c,1 point,Fri Jul 17 14:47:10 2015 UTC,"That would not fix the fundamental problem - that the failure of a destructor would leave the program in a state from which it could not recover.   But destructors can already throw. They have always been able to throw. They can do so safely. It does not indicate that the program cannot continue, after unwinding to where the exception is caught.   the problem is that the destructor is doing things that a destructor has no business doing   I assume you don't suggest that we should ditch the whole Resource Acquisition is Initialization concept.  If not, then which is your opinion?   Destructors should not free resources? Destructors should not check for errors when freeing resources? Destructors should not report errors detected when freeing resources?    Just put the information you want to throw out of a destructor into a global list and have the ""catch"" block go through that list and do what it will with the contents.   Ah, wonderful. A hack! With a global object, nonetheless.  Now, how do you recommend implementing this hack as a standard mechanism for reporting errors detected in library destructors to the application user?  Yes - we could have a standard error reporting facility in the STL library. But what would make this facility superior to conveying this same information locally, in a context-aware method, via aggregated exceptions? In a way that the destructor error becomes a first-class exception, rather than a log message, when no existing exception is in flight?   An exception means ""what you asked me to do I could not do"", not ""it basically worked but here are some informational messages"".   An error in closesocket is not an informational message, it is an actual error.  It's just, possibly, a lower priority error than another exception that occurred before it.  An exception aggregation mechanism would allow higher priority errors and lower priority errors to all be reported, rather than forcing ignoring of lower priority errors. If there is no exception in flight, i.e. there's no higher priority error, the closesocket failure would still cause a legitimate, first-class, non-aggregated exception.  Better yet, aggregation allows containers to properly handle exceptions in multiple objects, which is currently difficult.   I don't understand what this would achieve that a logging mechanism wouldn't.   But the language doesn't have a logging mechanism.  Logging mechanisms are application-specific and cannot be used by libraries. Special mechanisms have to be designed for libraries to convey such information to using applications.  If you always just log this type of error, it means you cannot change program behavior when it occurs. You want to change program behavior if something unexpected happens. If closesocket fails, and there's no exception in flight, I want to throw an exception. However, if there's an exception already in flight, I'm okay piggybacking on it; I don't want to crash the program.  Likewise, if I'm destroying a vector of 1,000 objects, and one of the destructors runs into a problem, I want it to throw an exception. But currently, I cannot, because what happens if two of them throw? With aggregated exceptions, this is not a problem. If 10 or 100 destructors throw, all of them can be aggregated.  These aren't errors that we're ignoring because they're not worth reporting. We're ignoring them because the language lacks support to handle this stuff. But the additional support required seems minimal.   The unwinder contains no ""catch"" blocks of its own so if you allow an exception to escape into it, the unwinder is itself completely unwound and terminates with an ""uncaught exception"".   So generate an implicit try/catch around destructors that aren't noexcept. If exception is caught, and uncaught_exception is true, aggregate the exception with the in-flight one before returning control to unwinder."
cpp,3dlm12,mdf356,3,Fri Jul 17 15:23:49 2015 UTC,"But destructors can already throw. They have always been able to throw. They can do so safely. It does not indicate that the program cannot continue.   This was a misfeature. The situation is improved somewhat in C++11 as destructors are now ""noexcept(true)"" by default. It would be better still if C++ would detect this situation at compile time, but this is not possible with the C linker model.   I assume you don't suggest that we should ditch the whole Resource Acquisition is Initialization concept.   You assume correctly.   If not, then which is your opinion? Destructors should not free resources?   No.   Destructors should not check for errors when freeing resources? Destructors should not report errors detected when freeing resources?   One of these, depending on the situation. Or: report them by a mechanism other than throwing an exception (abort or log).   Ah, wonderful. A hack!   You're right, it is a hack. I don't except anybody to actually implement such a thing, because what it does isn't actually useful. As is common in the philosophy of C++, if you really think you need to do such a thing you can go and write it yourself. But there's no point in C++ inventing mechanisms that aren't actually useful.   An error in closesocket is not an informational message, it is an actual error.   Once closesocket() returns, either the socket in question is not open (in which case we can proceed as planned) or it is open (in which case there is no way to close it, and the program cannot proceed without leaking it, and should abort).   The language doesn't have a logging mechanism!   A standardized logging mechanism (usable by libraries) would be a much more useful addition to C++ than aggregate exceptions.   If you always just log this type of error, it means you cannot change program behavior when it occurs.   This may be key. What kind of changed program behavior do you envision? In your example of a vector of 1,000 objects and the destructors for 10 of them fail - what is the rest of the program going to do with that information? You want that information in a structured form (not just a textual log file) in order to be able to do something useful. But you just had a perfectly good structured form (the vector itself). And now it's gone! Better to do the thing you want to do with that information while the objects are still intact, in a dedicated loop over the vector which you explicitly call before you start tearing the objects down.   We're ignoring them because the language does not have the support to handle them.   No, we're ignoring them because they are not actionable (or because we have an irrational fear of terminating the program).   So generate an implicit try/catch around destructors that aren't noexcept. If uncaught_exception is true, aggregate caught exception with the in-flight one before returning control to unwinder.   Again, you're still left with the non-actionable information."
cpp,3dlm12,ScootyPuff3000,-2,Fri Jul 17 15:59:12 2015 UTC,"This was a misfeature.   It was not a misfeature. It was a 99% implemented feature which is now being shoved away behind noexcept because people aren't understanding the need to implement the final 1%.  Aggregated exceptions are that 1%. With aggregated exceptions, this feature becomes safe, and complete, and worthwhile.   In your example of a vector of 1,000 objects and the destructors for 10 of them fail - what is the rest of the program going to do with that information?    In my case, probably log all 10 failures, and continue with the rest of the program after unwinding that part.   Better to do the thing you want to do with that information while the objects are still intact, in a dedicated loop over the vector which you explicitly call before you start tearing the objects down.   Well that's just wonderful.  If I want to detect errors in resource cleanup, you're having me do resource cleanup twice:   Once for the normal case, when there are no other exceptions, to detect any errors. Another time in a destructor, in case I'm unwinding an exception.   What an amazing language this design of yours is. Instead of doing resource clean-up one time manually, like in C, I get to do it twice!   No, we're ignoring them because they are not actionable   Self-checking is an action. There are self-check failures where the appropriate response is to stop the current activity and log an error, but do not warrant termination.  You're shoehorning your error handling preferences on me, and not giving me a solution.   (or because we have an irrational fear of terminating the program).   If terminating was always appropriate, we would not need exceptions."
cpp,3dlm12,mdf356,5,Fri Jul 17 16:12:47 2015 UTC,"In my case, probably log all 10 failures, and continue with the rest of the program after unwinding that part.   In that case why no just do that logging from the destructor?   If I want to detect errors in resource cleanup, you're having me do resource cleanup twice:   It's proper division of responsibility. The destructor is responsible for one thing and one thing only (cleanup). Detection of errors is a separate responsibility and you need another pass for it.   If terminating was always appropriate, we would not need exceptions.   I didn't say it was always appropriate. I certainly agree that there are exceptional cases that don't indicate errors in the program and don't warrant termination."
cpp,3dlm12,Gotebe,0,Fri Jul 17 17:01:35 2015 UTC,"In that case why no just do that logging from the destructor?   Libraries cannot do logging from destructors. Not without awkward constructions that create a parallel interface for reporting where we shouldn't need one. We already have exceptions. Why should they not be fit for the purpose?   The destructor is responsible for one thing and one thing only (cleanup).    That's a coercive and marginalizing view; one you're imposing because you seemingly don't want to imagine more.  Most generally: destructors aren't just little cleanup whores. They are a way to schedule and order code execution, without determining exactly when the execution occurs. You are shoving them into the role of little cleanup whores, because you can't imagine a world where we can actually handle exceptions from them.  Destructors do not have to be so limited. They deserve to be first-class code. They deserve to be able to throw.  We're talking about the civil rights of a whole class of code here. Emancipation! ;)"
cpp,3dlm12,iomonad2,-1,Sat Jul 18 07:18:51 2015 UTC,"I don't think you answered the question. What exactly does it mean for a destructor to throw? What should the program do next? You say that   ""A destructor throwing doesn't mean that destruction didn't succeed to a standard sufficient for the program to continue. It means that there were issues with cleanup that do not require an abort. Such issues could be ignored, but in good implementations, would not be.""   Few questions I have off the top of my head are:   What exactly are the cleanup operations you describe. I'm curious how something which expects and handles an exception in a destructor can be considered a ""good implementation"". What happens to the memory of that object that failed destruction? Do you just mark it as 'do not use'? memset it all to zero? These are the only two valid options I can think of. Destructors commonly free memory dynamically allocated by the object. Even if you memset the object's memory to 0 and reclaim it, the dynamically allocated stuff will be leaked. If you have a bad destructor that throws exceptions every time and your program continues you'll be leaking more memory than a screen door on a submarine does water. What happens in the case of inheritance and virtual destructors? I don't even really want to think of the nightmare of a mess that will cause, but since you are proposing this, I expect that you've thought of it all. Can you tell me how it should work? Should a parent class destructor be called if the child class's destructor throws?   If you think you are going to be able to catch these exceptions 'higher up' and somehow provide a valid way to handle them, outside of the context that they were thrown, then you are sorely mistaken. The code would be extremely complex to implement correctly and prone to error. You would be far far wiser to spend your time properly designing your program not to through in destructors.  Any program that throws an exception in a destructor has been poorly designed and we should not be adding 'features' to the language that do nothing more than aid in poor program design."
cpp,3dlm12,iomonad2,0,Fri Jul 17 13:23:32 2015 UTC,"What exactly are the cleanup operations you describe.   That's specific to the destructor.  If the destructor calls closesocket, say, an exception might convey that closesocket returned an error.   I'm curious how something which expects and handles an exception in a destructor can be considered a ""good implementation"".   Loaded question expressing, as we're about to find, ignorance... :-/   What happens to the memory of that object that failed destruction?   The object did not fail destruction. The destructor reported an issue via the exception mechanism.   Do you just mark it as 'do not use'? memset it all to zero?   There's nothing wrong with the memory. You do exactly the same thing as if the destructor did not throw.   Destructors commonly free memory dynamically allocated by the object.    No! No! That's not how destructors work.  Destructors do not free object memory. operator delete, which is not the delete keyword, frees memory. If one of the destructors of a heap object throws, operator delete is called after the rest of the destructor chain to free the object's memory. A destructor exception does not stop orderly and dependable destruction proceedings.  You have major misunderstandings of the language. Destructors have always been able to throw. They can throw in C++03. They can throw with noexcept(false) in C++11. Memory has always been released in this circumstance properly. Base destructors are called properly, and will continue to be.  The question is not whether destructors can throw. They can, and can do so safely! The question is:   What happens if there's an in-flight exception already? What happens if we're destroying a collection of 1,000 objects, and 2 or more throw?   My proposal answers questions like these. It does not invent support for destructors throwing!   What happens in the case of inheritance and virtual destructors?   Same thing that happens already when destructors throw. Everything is destroyed and works properly. C++ wouldn't allow destructors to throw if there wasn't existing, and extensive, support for this!  Destructor exceptions are discouraged because of problems in some circumstances, not in the base usage case. My proposal is to address those circumstances, so that support for destructor exceptions can be complete; not that we avoid them, and resort to sweeping them under the rug like with default noexcept, because support is 99% only.   Any program that throws an exception in a destructor has been poorly designed,    I'm sorry, but  you lack basic awareness of how C++ destructors currently work.  If you make comments like these  please know the language!"
cpp,3dlm12,iomonad2,3,Fri Jul 17 14:08:39 2015 UTC,"No! No! That's not how destructors work. Destructors do not free memory. ...   Correct. But when an object news or malloc something, it usually needs this for the lifetime of the object, and then deletes/frees that in the destructor. This is common and should not be new to you.   You have major misunderstandings of the language. Destructors have always been able to throw.   So do you if you think throwing in destructors should be made safe. I never said destructors can't currently throw. Where did you get this idea?  If you are so confident then please do submit this proposal and we'll see what committee say then."
cpp,3dlm12,iomonad2,0,Fri Jul 17 15:03:24 2015 UTC,"But when an object news or malloc something, it usually needs this for the lifetime of the object, and then deletes/frees that in the destructor. This is common and should not be new to you.   Ummm... I don't see the problem. A properly implemented destructor frees what it can before throwing.   I never said destructors can't currently throw. Where did you get this idea?   You pretty heavily implied that with the expressed concerns about base destructors.   If you are so confident then please do submit this proposal and we'll see what committee say then.   Perhaps I will. :)"
cpp,3dlm12,iomonad2,5,Fri Jul 17 15:36:53 2015 UTC,"""Reporting a problem"" is different from ""throwing an exception"".  If you need to report a problem in cleanup, log something.  Don't throw an exception.  My favorite example of ""things that could have an error but you should never care"" is int close(int fd). I'd generally consider it an error to even check the return value of close() because there's nothing you can do if it fails (other than debug why your fd is a bad fd)."
cpp,3dlm12,Gotebe,3,Fri Jul 17 14:05:48 2015 UTC,It is absolutely an error to not check the return value of close if you want to tell the user that your data actually got saved.
cpp,3dlm12,Gotebe,1 point,Sat Jul 18 20:47:58 2015 UTC,"close has nothing to do with saving data, it just releases resources (if this is the last close on the fd).  The data is ""saved"" automatically, at time-based syncs, or explicitly via fsync or msync; though what ""save"" means actually depends a lot on the filesystem's semantics."
cpp,3dlm12,Gotebe,2,Sat Jul 18 22:38:29 2015 UTC,"From the manpage (http://man7.org/linux/man-pages/man2/close.2.html)         Not checking the return value of close() is a common but nevertheless        serious programming error, and is the mark of a bad programmer.         It is quite possible that errors on a previous write(2)        operation are first reported at the final close().        Not checking the return value when closing the file may lead to        silent loss of data.  This can especially be observed with NFS and        with disk quota.  Note that the return value should be used only for        diagnostics.  In particular close() should not be retried after an        EINTR since this may cause a reused descriptor from another thread to        be closed.         A successful close does not guarantee that the data has been        successfully saved to disk, as the kernel defers writes.  It is not        common for a filesystem to flush the buffers when the stream is        closed.  If you need to be sure that the data is physically stored,        use fsync(2).  (It will depend on the disk hardware at this point.)         It is probably unwise to close file descriptors while they may be in        use by system calls in other threads in the same process.  Since a        file descriptor may be reused, there are some obscure race conditions        that may cause unintended side effects.   I pray that I'll never have to use a product you developed, or that anyone's life depends on software you create."
cpp,3dlm12,Gotebe,3,Sat Jul 18 23:22:20 2015 UTC,"That manpage entry makes no sense.  First it says if you don't check it, you can lose data, but then it says the return value should only be used for diagnostics.  So I will stand by my assertion: there's nothing you can do if close returns non-zero."
cpp,3dlm12,Gotebe,-1,Sun Jul 19 03:28:49 2015 UTC,"You did not understand what OP wrote, and you do not seem to understand how data should be written to disk, to which close() is unrelated.  Manpage merely presumes that the programmer called close without calling fsync first.  THe correct way of closing the file and ensuring correct data save is:   call fsync (can fail, in which case file can't be closed with save guarantee) call close (cannot fail; if it does, error is either a coding one, in which case it's best to abort and fix he problem from the core dump, or it can be ignored, asit does not represent any issue with the program state or data)."
cpp,3dlm12,Gotebe,-2,Sun Jul 19 18:33:23 2015 UTC,"If you need to report a problem in cleanup, log something.   There is no language mechanism for a library to log this information without either (1) inventing a C-style hook mechanism to report such errors, or (2) infringe on the using application.   I'd generally consider it an error to even check the return value of close() because there's nothing you can do if it fails (other than debug why your fd is a bad fd).   On the contrary, it is an error not to check. You might be double-closing, which would be a serious error you need to detect. Yet you cannot just abort in this case, because the error might also not be your problem."
cpp,3dlm12,vlovich,4,Fri Jul 17 15:04:26 2015 UTC,"You might be double-closing, which would be a serious error you need to detect. Yet you cannot just abort in this case, because the error might also not be your problem.   Programs (and yes, even libraries) absolutely should abort if they detect such a condition, because it means it is no longer possible to reason about the program other than knowing it is in a bad state. Any attempt to continue will almost certainly turn a crashing bug into a subtle data corruption bug or (in any application that handles untrusted data) an exploitable security bug. Aborting is the safest thing you can do. The user might be initially frustrated at losing that session's data but this will maximize the chances of eventually getting the bug fixed, and lead to the best long-term prognosis for the user's data."
cpp,3dlm12,Gotebe,-2,Fri Jul 17 15:19:48 2015 UTC,"Programs (and yes, even libraries) absolutely should abort if they detect such a condition,   Yes, if you know without doubt that you detected a double close. But what if you don't know that information for certain? You know that close failed, but what if it's some kind of network resource, and really only the network connection failed?  What if this is Windows Sockets, and you're dealing with an unreliable API where the error could be returned by a crappy third party Layered Service Provider? Do you want to crash because the provider is buggy?  In that case you would normally want to throw an exception to stop the current part of the program, but let the rest of the program run because you don't have strong reason to believe that corruption has taken place.  And you would normally throw an exception, except that the close happens in the damn destructor..."
cpp,3dlm12,vlovich,5,Fri Jul 17 15:39:35 2015 UTC,"You know that close failed, but what if it's some kind of network resource, and really only the network connection failed?   You're tearing down the socket - you no longer care if the network connection failed. If it matters, it'll be reported the next time you try do something from with the network in a non-destructor context (which is when you do care).   Do you want to crash because the provider is buggy?   I'm not sufficiently familiar with Windows Sockets specifically to say, but either I can no longer trust the integrity of the running process (in which case I want to terminate it ASAP) or I can (in which case I don't care about knowing something went wrong when it is of no consequence)."
cpp,3dlm12,gtk,0,Fri Jul 17 16:09:17 2015 UTC,"You're tearing down the socket - you no longer care if the network connection failed.   But I do care, because it can suggest an issue in the rest of my code that doesn't warrant an abort, but would mean I'm using the connection in some suboptimal manner.   either I can no longer trust the integrity of the running process (in which case I want to terminate it ASAP) or I can (in which case I don't care about knowing something went wrong when it is of no consequence).   You must be amazing at chess with this black and white thinking."
cpp,3dlm12,gtk,3,Fri Jul 17 16:23:05 2015 UTC,"But I do care, because it can suggest an issue in the rest of my code that doesn't warrant an abort, but would mean I'm using the connection in some suboptimal manner.   Surely there is a way of detecting this other than from closesocket() - don't the other API functions return the information you need when you call them?"
cpp,3dlm12,gtk,-1,Fri Jul 17 17:22:47 2015 UTC,"Seriously, a program is not simply either in a full integrity or no integrity state. The program can have integrity in terms of technical correctness, but can run in some suboptimal way that you will not know about unless you care about these ""non-actionable"" errors.  The overhead I'm proposing is minimal. All it requires is a change of logic so that instead of calling std::terminate, you join my exception to the one that's already in-flight. The most overhead this might require for you is an implicit try/catch around noexcept(false) destructors, and an extra pointer in std::exception.  But we can't have that, because the world has to comply with your ideas about non-actionable errors?"
cpp,3dlm12,vlovich,3,Fri Jul 17 16:33:15 2015 UTC,"The program can have integrity in terms of technical correctness,   In that case it would be in the ""full integrity"" state. But you were talking about a double-close, which indicates a serious bug and does compromise integrity.   All it requires is a change of logic so that instead of calling std::terminate, you join my exception to the one that's already in-flight.   If you really wanted to, I think you could do that with std::set_terminate.   and an extra pointer in std::exception.   Not all exceptions derive from std::exception.   But we can't have that, because the world has to comply with your ideas about non-actionable errors?   I am not in charge of C++. But I suspect you'll get similar answers from the committee if you do write this up as a formal proposal."
cpp,3dlm12,iomonad2,0,Fri Jul 17 17:33:09 2015 UTC,"If you really wanted to, I think you could do that with std::set_terminate.   These are suggestions for more hacks. While I have no doubt that std::set_terminate can be useful, a library certainly cannot call that.  You may want to see a similar reply I made to /u/foonathan, who makes a similar argument.  The reason I'm making this proposal is because I feel coerced - and in fact am coerced - to treat all destructor errors as either type 1 errors (abort) or type 3 errors (ignore). This bothers me, and I do not wish to be so coerced.  I find it presumptuous for you to make blanket statements that all destructor errors are either type 1 or type 3, without having opened your mind to the possibility that type 2 may be useful in reasonable scenarios. You first need to allow for the possibility that destructor errors could be suitable for partial unwinding via exceptions. Then you decide whether a particular error requires treatment of type 1, 2, or 3.  If you lack proper support, your choice is biased by that the current support is poor, and that you can't imagine a world where it isn't. You may become convinced there is no need for it, because you've worked around the lack of possibility. Then you defend the continuing lack of possibility by that there isn't perceived need. This is at least partially circular logic. By this reasoning, we can't have language improvement."
cpp,3dlm12,vlovich,2,Sat Jul 18 06:39:44 2015 UTC,"These are suggestions for more hacks. While I have no doubt that std::set_terminate can be useful, a library certainly cannot call that.   Not your library that just wants to throw multiple exceptions at once, but a library that you can add to your program to add this facility (with some minimal cooperation from at least the catching side, which would also need to happen if this was added as a language facility). The C++ committee will rarely accept a proposal for a language change if it could instead be implemented as a library.   This bothers me, and I do not wish to be so coerced.   So far this is the only part of your argument that I have any sympathy for. To really make your case you need to back it up with a compelling use case - an example of a destructor that fails in a way that shouldn't be ignored or lead to termination and which is best handled by the caller rather than the library in which the destructor resides. So far I have never seen such an example. So far all the ones you have mentioned here really should be type 1 (like double close of socket) or type 3 (like network went away while we were closing socket).  I am also concerned that adding such a facility to the language would add complexity to any program which calls a library that uses this facility. The library would be burdening the program with error information that it can't do anything about (because the objects in question no longer exist), doesn't care about, or which indicates loss of integrity (or some combination of these three)."
cpp,3dlm12,iomonad2,0,Sat Jul 18 07:57:08 2015 UTC,"So far all the ones you have mentioned here really should be type 1 (like double close of socket) or type 3 (like network went away while we were closing socket).   The ones you want to handle as type 1 or 3 (abort or report) are the ones I want to handle as type 2 (exception). This is not because I never do aborts, but because I think in this particular case it's the wrong option.  This is not just about one resource; it is in practice any number of resource types, provided by any number of OS facilities. Some of those facilities are buggy; others are modular, and they allow third party implementations that are buggy. If something goes wrong, related to one of those facilities, I want to know. But I have the following issues:   My software runs outside of my control. If I just log warnings, users will absolutely ignore them. I need the issue to be reported by that one user who experiences the issue, not by someone from the 99 that don't. I need to change behavior in a way that impacts the user so they will report the issue. Whatever they wanted to do, I can't allow them to finish doing. Otherwise, most of them have no inclination to bother reporting. But I can't just crash my service, because that won't be perceived as something that just happened to go wrong with a particular task. It will be perceived (arguably rightly) as an unstable, unreliable service. Depending on how the circumstances are triggered, crashing the service also creates a denial of service attack.   I have to balance all of these considerations, and the way this tends to work out in practice is that type 2 errors are almost always what is best for me to do. Destructor errors included.  Now in addition to that, there's the potential for destructors to be more than just little cleanup fairies. They are in fact powerful tools for scheduling code to execute, except that using them this way is currently considered borderline abuse, because of the known problems with exceptions from destructors. If we solve exceptions from destructors, then this becomes a powerful and fully supported usage case. It would legitimize many existing situations where destructors are currently used this way, such as - but not limited to - various database libraries (which I do not personally use, but I have seen mentioned as examples)."
cpp,3dlm12,vlovich,1 point,Sat Jul 18 09:48:11 2015 UTC,"I am coerced to treat all destructor errors as either type 1 errors (abort) or type 3 errors (ignore).   How many of these situations do you have in your code?  If more than 5, please show at least one example. That, because I believe there will be a better way to handle your situation than your idea."
cpp,3dlm12,iomonad2,0,Sun Jul 19 18:18:36 2015 UTC,"You have commented twice before this. I have responded.  You might think you are being original, and I do appreciate feedback, but so far, you present nothing new."
cpp,3dlm12,vlovich,0,Sun Jul 19 18:21:15 2015 UTC,But what if you don't know that information for certain?   But you do know that: errno gives you EINVAL (or some such).
cpp,3dlm12,iomonad2,0,Sun Jul 19 17:40:32 2015 UTC,"you might be double-closing, which would be a serious error you need to detect.   That's a sackable offence. :-)  I'd rather abort(), get my hands on the crash dump, analyze and fix.  Same for attempting to close a bad descriptor.  In both cases, code is a headless chicken which is better taken out of its misery.  Basically, I am reacting because exceptions are best not used for programming errors."
cpp,3dlm12,vlovich,1 point,Sun Jul 19 17:37:33 2015 UTC,"You might not agree with the purposes for which I want to use destructor exceptions, but the fact is that they are necessary in other cases. Database libraries, for example, must perform rollback if an exception occurs somewhere else. But the rollback can also fail in rare cases, and now you have two exceptions.  If you're running the transaction via lambda with a try-catch block, you can throw away the original exception, and report the rollback exception as the one that's more serious. But if you're running the transaction via RAII, with an object that performs rollback in destructor, you're screwed. You cannot replace the original exception with the rollback exception, and you now have only ugly solutions available.  Support for aggregated exceptions fixes this.  I'm sorry, but I'm nearly certain that people like you are in denial. Check out What's wrong with noexcept? The language can't handle the 1% case. It would be easy to handle if we plan for it; it doesn't take much to adapt to. But the fact is that it is a 1% case, and people want to pretend that it doesn't exist. It's easier to be in denial."
cpp,3dlm12,iomonad2,0,Sun Jul 19 18:17:20 2015 UTC,"But the rollback can also fail in rare cases, and now you have two exceptions.   That is if you use the limes of a ""transaction scope"" object, e.g.  {   TrScope scope(db);   Use(db);   scope.complete(); } // transaction implicitly committed or aborted here.   But the real question is: where did you find it? Normally, db libraries do not give you a transaction scope object, and the one I linked to is much dicferent, it is for XA transactions and commit/rollback are async, so the whole discussion is moot.  Basically, I am accusing you of inventing an issue in order to prove a point.  The ""correct"" way of approaching the rollback situation is to either not put the rollback in a destructor, or to catch its errors and let the database work it out when the transaction object is destroyed (which either leads to a rollback, or the database itself signals an error to its monitoring system and something is in charge of administrative rollback or some such)."
cpp,3dlm12,vlovich,1 point,Sun Jul 19 20:10:53 2015 UTC,"But the rollback can also fail in rare cases, and now you have two exceptions.   That is if you use the limes of a ""transaction scope"" object, e.g.   If you must rollback due to an error; and then the rollback experiences another error; you have two errors. There is no way to structure the program in this case to avoid, potentially, two errors. The issue is how you deal with them. Your reply circles this issue, and tries to find workarounds for the language not being able to convey two errors.   Basically, I am accusing you of inventing an issue in order to prove a point.   That's an interesting choice of words. See  accusations are not helpful. I read what you write, and reply, by choice. I would like to benefit from any insights you express; and to the extent that I do not, I'm replying as a courtesy.  You make it less likely that I will see benefit in your views; and more likely that I will no longer see value in courtesy; when you reply out of ego, and out of pride for what seem to me narrow-minded convictions.  When I may see things in a way that you do not, that doesn't mean your views are superior because you don't understand mine. Any difference in understanding must be approached with respect and caution. Ignorance is a bad thing of which to be proud; and it's easy to confuse ignorance with principles."
cpp,3dlm12,vlovich,2,Mon Jul 20 09:00:42 2015 UTC,"If you must rollback due to an error; and then the rollback experiences another error; you have two errors. There is no way to structure the program in this case to avoid, potentially, two errors. The issue is how you deal with them. Your reply circles this issue, and tries to find workarounds for the language not being able to convey two errors.   The language absolutely is able to convey as many errors as you want.  What the language is not able to convey is the second error appearing on the cleanup path, from a destructor.  I am still accusing you of inventing an issue in order to prove a point, and it appears that I am right to do that, because you actually do not have a real-life example of the deficiency you're trying to fix, your example of a transaction scope is all in your head, isn't it? Please show the example of the DB library that does the rollback in the destructor.  That said... I do have certain sympathy for your idea. IIRC, the D language does implement the behavior you want.  My issues with the idea are:   reports of its usefulness are greatly exaggerated (to paraphrase a writer) it is trivially solved by moving all ""can-fail"" operations out of the cleanup path."
cpp,3dlm12,vlovich,0,Mon Jul 20 10:12:10 2015 UTC,"One such library is SOCI, which I do not personally use, but I've seen as an example on Andrzej's blog.  Another example can be found in this thread, in the exchange between by /u/vlovich and /u/iomonad2.   it is trivially solved by moving all ""can-fail"" operations out of the cleanup path.   In my view, that this needs to be done is a defect. It means exceptions are under-designed as a mechanism.  But beyond this:   Please show the example of the DB library that does the rollback in the destructor.   Do you seriously not understand how rude you are being? Why should anyone take you seriously, when this is how you express yourself?  I have a two year old son who thinks screaming is an appropriate way to make his wants known. You're trying to communicate by bullying."
cpp,3dlm12,Dascandy,2,Mon Jul 20 10:22:02 2015 UTC,"Your code using SOCI does not, in fact, suffer from the problem we're discussing here.  SOCI does, in fact, ignore any rollback errors if they happen in a destructor. Perhaps you should ask SOCI  people what is their stance on that detail. I already gave you my opinion, above, and from the SOCI code, it rather looks that the SOCI project opinion is the same: if you feel you must inform about a failed rollback, move the rollback() call out of the destructor (I say that because transaction::rollback is public).   I have a two year old son who thinks screaming is an appropriate way to make his wants known. You're trying to communicate by bullying.   That's your opinion. Mine is: I used bold text because I asked you to come up with an example, you didn't, but you continued to argue. When somebody refuses to listen, one should better insist. So I did.    it is trivially solved by moving all ""can-fail"" operations out of the cleanup path. In my view, that this needs to be done is a defect. It means exceptions are under-designed as a mechanism.    Yes, I understand you there and I largely disagree. My stance is: yeah, it might be better, but matters little, see ""My issues with the idea are..."" above.  Please note also that the situation is similar in the likes of Java, C#, ObjectPascal etc: an exception on the cleanup path that happens while stack is being unwound replaces the ""first"" exception. If all those languages don't find it beneficial to do it more, perhaps it isn't beneficial? (Of course, this is a mere argumentation by numbers, but still...)."
cpp,3ditv9,vinipsmaker,15,Thu Jul 16 16:52:03 2015 UTC,-std=gnu11 by default! fuck yea!
cpp,3ditv9,ranma1988,12,Thu Jul 16 19:05:52 2015 UTC,Hopefully they will have std=c++11 default soon. The above default is for C.
cpp,3ditv9,jbandela,3,Thu Jul 16 20:24:11 2015 UTC,"Hopefully they will have std=c++11 default soon. The above default is for C.   This is the single biggest feature I want to see. It's not like I can't type it into every Makefile, but seriously.  '11 was 100 years ago, if my math is right."
cpp,3ditv9,ShakaUVM,3,Fri Jul 17 04:19:10 2015 UTC,And yet many embedded compilers aren't even C99 compliant.
cpp,3ditv9,pjmlp,1 point,Fri Jul 17 04:56:00 2015 UTC,Yup. Having to roll your own stdint.h and stddef.h gets really old really fast.
cpp,3ditv9,Alborak,1 point,Fri Jul 17 13:46:03 2015 UTC,stddef.h exists since C89.
cpp,3ditv9,pnKYe4IIA,1 point,Fri Jul 17 20:00:10 2015 UTC,"Thanks for the reference. The system I was building in didn't have it, probably had nostdinc on and custom headers."
cpp,3ditv9,Alborak,0,Fri Jul 17 20:13:12 2015 UTC,g++ 5.1 defaults to gnu++14 (I think)
cpp,3ditv9,OldWolf2,7,Thu Jul 16 21:52:40 2015 UTC,"No, it's changing in GCC 6."
cpp,3ditv9,Plorkyeran,1 point,Thu Jul 16 23:17:03 2015 UTC,"Sadly not, the default for the compiler is still gnu++98, if you want a newer version you got to specify it.  The standard library uses the C++11 ABI by default (noticeably string and linked list changes), headers that are new are blocked with #error directives though if you try to use them without the fitting compiler flag."
cpp,3ditv9,Addile,5,Thu Jul 16 22:53:54 2015 UTC,"Enabling extensions by default doesn't sound like a great idea... But 11, yeah, I'm all for it :)"
cpp,3ditv9,joelthelion,4,Thu Jul 16 20:13:53 2015 UTC,It's generally necessary to develop any real software with POSIX.  A lot of standard behavior depends on _GNU_SOURCE.  I wonder if this means threads.h is implemented.
cpp,3ditv9,uxcn,3,Thu Jul 16 22:50:49 2015 UTC,threads.h would be a feature of the libc. The glibc is developed separately from GCC. (Unlike libstdc++ which is part of GCC)  And it seems glibc has no threads.h support https://sourceware.org/bugzilla/show_bug.cgi?id=14092
cpp,3ditv9,the-fritz,2,Thu Jul 16 23:13:59 2015 UTC,"I think it'll probably never get implemented for any platform.  With the interface as it stands in the standard, there isn't any real benefit over pthreads which sucks.  Truly portable threading with C is still painful, at least if you don't limit to atomics.  At least C++ is portableish."
cpp,3ditv9,uxcn,5,Thu Jul 16 23:37:20 2015 UTC,glibc's slowness is good for competition. I wouldn't have heard of musl if not for their C11 thread support
cpp,3ditv9,CubbiMew,1 point,Fri Jul 17 02:09:57 2015 UTC,"There are zero dependencies of POSIX to gnu stuff.   By using GNU  compiler extensions,  they are by definition non-compliant."
cpp,3ditv9,pjmlp,3,Fri Jul 17 04:58:26 2015 UTC,"That wasn't exactly what I said.  What I said was that if you want to write programs that use POSIX, you generally need to #define _GNU_SOURCE otherwise you will likely be missing a lot of the behavior you expect."
cpp,3ditv9,uxcn,2,Fri Jul 17 05:39:10 2015 UTC,Except that macro is nowhere to be found in POSIX compliancy documents.
cpp,3ditv9,pjmlp,2,Fri Jul 17 16:00:41 2015 UTC,"I never said it was anywhere in POSIX.  A lot of the expected behavior from glibc technically isn't POSIX, but it's still heavily relied on when actually using it.  A lot ends up becoming part of POSIX.  The point was that the majority of software compiled by gcc is better served by -std=gnu11 than strict -std=c11."
cpp,3ditv9,uxcn,2,Fri Jul 17 17:20:32 2015 UTC,What GCC features have ever became part of POSIX standard?
cpp,3ditv9,pjmlp,3,Fri Jul 17 17:59:51 2015 UTC,"Not GCC, glibc.  Various aspects of system calls have been added to glibc under _GNU_SOURCE before they're actually standardized.  So, for example O_CLOEXEC originally wasn't specified in POSIX."
cpp,3ditv9,uxcn,1 point,Fri Jul 17 18:17:49 2015 UTC,"Ok, thanks for the feedback."
cpp,3ditv9,pjmlp,2,Fri Jul 17 20:16:16 2015 UTC,Funny that they're jumping straight from c89 to c11 as the default. Although I just learned a couple days ago about the c99 command and how it's required by the POSIX standard.
cpp,3ditv9,Triplanetary,2,Thu Jul 16 22:07:47 2015 UTC,changelog https://gcc.gnu.org/gcc-5/changes.html
cpp,3ditv9,ranma1988,7,Thu Jul 16 19:43:45 2015 UTC,"That's the feature changelog for the 5.x series, 5.2 is a bugfix release, here's the actual changelog."
cpp,3ditv9,otidder,1 point,Thu Jul 16 22:05:31 2015 UTC,"This is probably going to sound newbish, so I'm sorry in advance. What are the basic steps to get this installed on Ubuntu 14.04?"
cpp,3ditv9,yesterdaybacon,1 point,Fri Jul 17 12:18:52 2015 UTC,"It will probably get added to ppa:ubuntu-toolchain-r in the near future, or you could build it from source."
cpp,3djh2y,watermelon_exe,3,Thu Jul 16 19:39:58 2015 UTC,"I really hope that this new proposal make it into C++17. It would be a really nice addition to the language and would save me a lot of typing. Moreover, in its current state, I wouldn't think it would pose a lot of problems for implementation. I never really liked static if at another scope than function scope, it is where it really makes sense."
cpp,3djh2y,wichtounet,1 point,Fri Jul 17 09:31:43 2015 UTC,"I agree. I also support this idea which is simple and that will simplify the life of programmers even, espacially when reading a code another person wrote"
cpp,3djh2y,chambolle,3,Sun Jul 19 11:52:59 2015 UTC,It's not clear to me from the proposal whether this would support conditional member variables or not. Can anyone clarify
cpp,3djh2y,quicknir,3,Thu Jul 16 22:52:55 2015 UTC,It will not.
cpp,3djh2y,sakarri,6,Fri Jul 17 02:16:37 2015 UTC,"Implementability  I fully expect the implementation difficulty of such a facility to be considerable, and it's certainly well beyond the capabilities of an intermediate front-end contributor such as myself. Is that cost worth the benefit of the facility? Hard to say. I guess it would be. :)    He should have talked to Walter Bright and/or Andrei Alexandrescu before putting that in the paper.  If I recall correctly, Walter said it wasn't that difficult in D and doesn't believe it will for C++ either.  Of course C++ is a more complicated language, but Walter does have experience there too."
cpp,3djh2y,ZMeson,6,Thu Jul 16 22:46:58 2015 UTC,The facility was quite easy to implement using clang.  Here's a test file that compiles (within the relevant branch on github): https://github.com/faisalv/clang/blob/static_if/test/CXX/static_if/cxx1z-static_if.cpp
cpp,3djh2y,faisalv,2,Fri Jul 17 11:00:57 2015 UTC,"D is not C++. It is not at all obvious that the design or implementation language features in D translate cleanly or easily to C++. For example, my reading of the current proposal makes this valid:  void f() {   static_if(false) {     extern void g();   }   g(); }   Should it be? Based on my reading, yes. Does that match the intent of the proposed feature? Probably not.   What about this?  void f() {   static_if(false) { std::vector<int> v; } }   Is the default constructor for vector<int> instantiated or not? It's certainly well-formed, so it seems like it should it should be instantiated. Said otherwise, is that constructor ODR-used? It's an important question for compilers.  And these kinds of questions layer nicely, especially if you have non-dependent lambdas inside static ifs whose definitions instantiate other templates or contain extern declarations.   Are these questions about more subtle aspects of the C++ language? Certainly. Are these examples included in Faisal's test suite (comment below)? No. Am I guilty of overlooking similar obscure language interactions for Concepts Lite? Absolutely. Are these kinds of questions related to how useful the feature is? No.  My point is that language proposals for C++, even the ones that seem simple because e.g., they appear in other languages, are rarely trivial. There are always subtleties."
cpp,3djh2y,andrewsutton,3,Sat Jul 18 02:42:49 2015 UTC,"Since static_if introduces its own block scope how could the call of g() be well-formed unless it occurred within the block (or a nested block) that contained the declaration?  (i.e. the code is and should be ill-formed, I believe).  In regards to instantiating vector<int> - yes it would based on my interpretation of Ville's design (and I'm ok with that - who, asides from a compiler-writer and optimizer cares about odr-use anyways - and do users really care about lives of compiler-writers ;) - a very simple optimization would be to not dump out any code for that block - but semantic front-end analysis would be done as-if it was used - i.e. static_if blocks within lambdas would require capturing of variables from enclosing scopes if odr-used within the block).  static_if (as being proposed) adds very little (if anything) in a non-template/non-dependent scope.  Its only merit is that when used within a template (or a generic-lambda) - you can have blocks within that template that don't get substituted into (i.e. are simply ignored as if they were never there) when the template is being instantiated (perhaps it should be called instantiate_if).  Simply put, it makes the tag-dispatch trick more obvious to read and requires less boiler plate (similar to my reasons for liking concepts) which IMHO makes C++ a little easier to use  - I don't see it adding much complexity at all - but of course YMMV ;)"
cpp,3djh2y,faisalv,1 point,Sat Jul 18 13:49:56 2015 UTC,"Since static_if introduces its own block scope how could the call of g() be well-formed unless it occurred within the block (or a nested block) that contained the declaration? (i.e. the code is and should be ill-formed, I believe).   Duh. Of course. Brain fart on my part.   In regards to instantiating vector<int> - yes it would based on my interpretation of Ville's design (and I'm ok with that - who, asides from a compiler-writer and optimizer cares about odr-use anyways - and do users really care about lives of compiler-writers...   One of the guarantees of templates is that the compiler doesn't generate code that it isn't used. I don't think code in a false branch is used, but it's hard to reconcile that with the current definitions in the language. Optimizations are optional. This is fundamental."
cpp,3djh2y,andrewsutton,2,Sat Jul 18 20:16:11 2015 UTC,"I believe Richard Smith suggested that code within a false branch be considered unevaluated - I don't believe Ville is proposing that - it would complicate things - and if really felt necessary, should be either a separate feature or an addition that is justified with important use cases.  Templates seem to be specified by the standard to allow them to be tokenized but not parsed - Richard (I believe) has pointed out the complexities this introduces within the standard (since code within templates is removed from certain semantic checks that we would require on corresponding non-template entities) - which doesn't even clearly say (i believe) if a nested name specifier requires instantiation of template specializations within the nestation.  I agree that one could argue that code within Ville's static_if false branch should not be considered odr-used if written within a non-template - but i don;t believe he is asking for that  - just that it not be instantiated (and so NOT odr-used within the instantiation) - and I believe that's enough by itself to reasonably uncomplicate our lives."
cpp,3djh2y,faisalv,1 point,Sun Jul 19 13:59:13 2015 UTC,"I'm not sure if Ville has considered the issue. I think if he had, he would have written something in the proposal. I agree with Richard here. That code in a false branch should be unevaluated, since it's not supposed to be compiled anyway.  Templates are most definitely parsed after tokenization. There is a minimal degree of checking -- you know only if something is declared as a type, non-type, or template, but nothing more. But even that adds a significant degree of complexity (over just tokenization).  But for me, any proposal that drops minimal degree of checking is a non-starter."
cpp,3djh2y,andrewsutton,1 point,Sun Jul 19 23:29:19 2015 UTC,"andrewsutton   Hey!  I'm so glad to see you on reddit!  :)   D is not C++. It is not at all obvious that the design or implementation language features in D translate cleanly or easily to C++.   Indeed!  I just thought that Walter Bright said something about the ease of adding it to C++ once.  Since he has implemented C++ compilers in the past, that stood out to me.  Of course my memory could be wrong -- as my wife reminds me all to often ;-)   It's also possible that Walter's assessment could be wrong since as far as I know he hasn't worked on implmenting a modern C++ compiler (C++11 or C++14)."
cpp,3djh2y,ZMeson,1 point,Sat Jul 18 16:18:48 2015 UTC,"Honestly Walter isn't a particularly good or objective source for C++ info anymore.  I remember in a reddit post not that long ago he chimed in claiming modules would be easy to implement in C++.  There was a fairly bitter pissing contest between Walter/Andrei and Bjarne, and since that pissing contest Walter/Andrei have made some really bizarre comments regarding C++.  EDIT:  Here is the link to where is jumps in claiming C++ modules aren't hard, and also they're even easier to implement than precompiled headers:  https://www.reddit.com/r/programming/comments/36zuhl/zapcc_a_faster_c_compiler/crijif5"
cpp,3djh2y,sakarri,2,Sat Jul 18 19:16:50 2015 UTC,"His claim seemed to be that C++ modules were not hard if you ignored backwards compatibility and designed them properly from the ground up.  The standards committee will probably not see that as a valid option though, it should be relatively easy to modify existing code to use modules."
cpp,3djh2y,nikbackm,1 point,Sun Jul 19 09:26:03 2015 UTC,No such qualification was made.  What he said was that modules don't need to worry about backwards compatibility and can define their own rules with respect to symbol lookup.
cpp,3djh2y,sakarri,2,Sun Jul 19 14:58:37 2015 UTC,"It would be nice if static_if applied to function scope as well. Which is useful to constrain the function based on the static_if conditions. This can be useful for serialization:  template<class T> void print(const T& x) static_if(std::is_convertible<T, std::string>()) {     std::cout << x << std::endl; } else static_if(is_range<T>) {     for(const auto& e:x) print(e); } else static_if(boost::fusion::traits::is_sequence<T>()) {     boost::fusion::for_each(x, [](cosnt auto& e) { print(e); }); } else static_if(is_variant<T>()) {     boost::apply_visitor(fit::result<void>([](const auto& e) { print(e); }), x); } else static_if(is_streamable<T>()) {     std::cout << x << std::endl; }   If the user passes something that is not printable then the function is not callable. Plus, the compiler can give a better diagnostic in this case(as it keeps the backtrace short and to the point)."
cpp,3djh2y,pfultz2,3,Fri Jul 17 18:00:53 2015 UTC,"So all of those conditions should be, in some way, part of the function's signature? That seems... excessive.  EDIT: More thoughts.  How would that interact with overloading? What if I defined:  template<typename T> typename std::enable_if<boost::fusion::traits::is_sequence<T>(), void>::type print(T const& x) { ... }  Is this declaration legal? It overlaps with the one you gave above. What if it were in a different translation unit?"
cpp,3djh2y,andrewsutton,2,Sat Jul 18 02:45:53 2015 UTC,"It would be the equivalent to writing this:  template<class T, typename std::enable_if<(     std::is_convertible<T, std::string>() ||     boost::fusion::traits::is_sequence<T>() ||     boost::fusion::traits::is_sequence<T>() ||     is_variant<T>() ||     is_streamable<T>() )>::type> void print(const T& x)  {     static_if(std::is_convertible<T, std::string>())     {         std::cout << x << std::endl;     }     else static_if(is_range<T>)     {         for(const auto& e:x) print(e);     }     else static_if(boost::fusion::traits::is_sequence<T>())     {         boost::fusion::for_each(x, [](cosnt auto& e) { print(e); });     }     else static_if(is_variant<T>())     {         boost::apply_visitor(fit::result<void>([](const auto& e) { print(e); }), x);     }     else static_if(is_streamable<T>())     {         std::cout << x << std::endl;     } }   So those conditions to static_if become the union of all the conditions, but being able to do it at function scope its not necessary to repeat the conditions.   Is this declaration legal? It overlaps with the one you gave above. What if it were in a different translation unit?   It would be the same as now if you had a function define like this:  template<class T, typename std::enable_if<(     std::is_convertible<T, std::string>() ||     boost::fusion::traits::is_sequence<T>() ||     boost::fusion::traits::is_sequence<T>() ||     is_variant<T>() ||     is_streamable<T>() )>::type> void print(const T& x);   And another defined like this:  template<typename T>  typename std::enable_if<boost::fusion::traits::is_sequence<T>(), void>::type  print(T const& x);   It would be an ambiguous overload resolution failure when called with a fusion sequence."
cpp,3djh2y,pfultz2,1 point,Sat Jul 18 04:33:37 2015 UTC,Can someone clarify well-formed?  Would I be able to make platform-specific API calls to undeclared functions?  Am I correct in assuming nothing in this proposal restricts static_if to template functions?
cpp,3djh2y,vlovich,-2,Fri Jul 17 16:10:46 2015 UTC,"Why? Because it allows making static decisions without having to resort to multiple overloads. Having a static if allows for simple and local code, without having to know the intricacies of overload resolution, partial ordering and SFINAE.   Well maybe if you don't know how overload resolution works, you should not write a function template that requires a static_if.   Honestly I feel that this is just a syntactic sugar, it does not solve any problem, just provide an arguably nicer syntax for something that we can already do (and easily extend) via tag dispatching."
cpp,3djh2y,sbabbi,3,Thu Jul 16 23:36:33 2015 UTC,"This is the most inane argument I've ever heard. It's ""just syntactic sugar""? The entire language is syntactic sugar! Terse, transparent, human-readable syntax is literally the whole point of programming languages."
cpp,3djh2y,acwaters,6,Fri Jul 17 13:11:51 2015 UTC,"Overloading is much more verbose and less obvious, because overloading is done for lots of other reasons. static_if gives you a compile time syntax that is easy to understand because it mirrors the plain if syntax. Calling it syntactic sugar is a bit like saying constexpr functions are syntactic sugar."
cpp,3djh2y,tending,7,Fri Jul 17 03:18:50 2015 UTC,"I completely agree on that point. static_if is much clearer than using overload, SFINAE or tag dispatching, it really states the goal.   If we go down the syntastic sugar road, a lot of the language is, lambdas, foreach, ... They are nevertheless, wonderful additions to the language."
cpp,3djh2y,wichtounet,2,Fri Jul 17 09:28:29 2015 UTC,Ville Voutilainen is the C++ chair for EWG.  I'm going to trust his opinion on this & it lines up with my experience on this & every complaint I've ever heard about templates.
cpp,3djh2y,vlovich,1 point,Fri Jul 17 16:07:15 2015 UTC,"Sure and Bjarne Stroustrup created C++ and he considers static_if an abomination.  So who's tribe do we align ourselves with now, Tribe Bjarne or Tribe Ville?  This is the problem that arises when the basis of your beliefs are people rather than actual technical arguments."
cpp,3djh2y,sakarri,1 point,Sat Jul 18 19:29:51 2015 UTC,"Appeal to authority is by no means a logically invalid argument; it can be a fallacy when done incorrectly but I was very careful on this so I think I'm OK.  Certainly if my doctor says one thing & my barber says another I'm going to trust the doctor's opinion.  The barber has a higher burden of proof whereas the doctor has a lower burden of proof.  Similarly, between someone I don't know on reddit & the EWG chair, I'm going to give more weight to that persons arguments by default; AFAIK attaining Ville's position requires technical merit & the support of your peers.  I also stated that his proposal lines up exactly with my experience of writing lots of templates.  Ville is presenting ""static_if lite"" to address the valid technical concerns raised in Andrei's brilliant & ambitious initial proposal.  Why are you presuming there are tribes? Bjarne came out very critically of Andrei's proposal but Ville's is much reduced in scope.  /u/sbabbi seemed to basically say ""if you're not familiar enough with C++ templates to implement this complex piece correctly, then don't do it"".  He's entitled to his opinion but not only is it not at all the counter-arguments Bjarne & co had made, the logical path for me seems to take Ville's proposal more seriously than a random counter-attack by someone I don't know, especially since it's dangerously close to the no-true Scotsman fallacy."
cpp,3djh2y,vlovich,2,Sat Jul 18 21:58:56 2015 UTC,Two lengthy paragraphs and not a single technical justification for your position.  That is impressive to say the least...
cpp,3djh2y,sakarri,1 point,Sat Jul 18 23:17:41 2015 UTC,"As I said, I agree with the issues raised in the proposal.  I have stated that my technical justification is my experience witnessing the bloated code & difficult to read code that results from SFINAE & the complexity of getting the overloaded resolution correct.  I'm not sure what more you are looking for, but you haven't really raised any technical issues & sbabbi made a broad-sweeping claim that people who don't understand the intricacies of C++ overload resolution shouldn't write templates.  Stephan, the maintainer of Microsoft's C++ STL library, acknowledges that overload resolution is a complicated topic [1].  Do you have any supporting evidence to the contrary that overloading is a simple topic that isn't deserving of tools to simplify it & make it more accessible?  [1] https://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-Cpp-3-of-n"
cpp,3djh2y,vlovich,1 point,Sun Jul 19 01:31:33 2015 UTC,"The alternative to static_if isn't to use SFINAE, it's to use tag dispatching, the very method recommended by your second appeal to authority, Stephan T Lavavej."
cpp,3djh2y,sakarri,1 point,Sun Jul 19 02:36:08 2015 UTC,"The initial proposal of static if for C++, of which Andrei was one of three authors (so don't credit the work as just his -- he isn't even listed as first author), was neither brilliant nor ambitious, nor did it raise or address any serious technical issues related to the integration of the proposed feature with existing language mechanics. It was a straightforward proposal of D's static if to C++ that largely presented motivating examples.  However, it was a very well written proposal."
cpp,3dhivo,mttd,4,Thu Jul 16 09:09:56 2015 UTC,Slides: http://www.slideshare.net/curryon/bjarne-stroustrupwhatifanythinghavewelearnedfromc
cpp,3dhivo,nikbackm,7,Thu Jul 16 17:36:02 2015 UTC,I love Bjarne's talks on C++
cpp,3dhivo,kozukumi,1 point,Thu Jul 16 20:46:33 2015 UTC,"Me too, so much insight in them."
cpp,3djmc2,joaquintides,6,Thu Jul 16 20:18:30 2015 UTC,is it possible to get it from not sourceforge?
cpp,3djmc2,MichaelMitchell,2,Fri Jul 17 12:55:56 2015 UTC,Beman's host: http://boost.cowic.de/rc/
cpp,3djmc2,dodheim,1 point,Sun Jul 19 01:14:28 2015 UTC,"Boost requires a massive amount of bandwidth. The idea of moving the release from SF was floated but didn't have much momentum. Since it is a source release there is less to worry about wrt malware, but github releases is the next logical step since we are already hosting development there now anyway."
cpp,3djmc2,adzm,-2,Sun Jul 19 18:29:03 2015 UTC,"If using MSVC, check this"
cpp,3djmc2,Elador,1 point,Fri Jul 17 17:29:40 2015 UTC,But it links to sourceforge too...
cpp,3djmc2,Elador,1 point,Sat Jul 18 22:24:32 2015 UTC,"Ah, you're right, answered too fast"
cpp,3df614,mttd,6,Wed Jul 15 20:04:39 2015 UTC,"First I want to thank Andrzej's for his original proposal.  While I came up with this independently, the original thread where he broached this was very useful in me clarifying in my mind strong arguments why it's necessary.  While I originally favoured the policy design, David Krauss had a really brilliant suggestion to instead do something like optional<compressed_scalar<double, nan()>> & have the policy encoded in the optional type.  There is still some trickiness obviously because I would still want optional<compressed_scalar<double, ...>> to vend double not compressed_scalar as values, but I think it's possible.  I haven't had time to work on this proposal in a few weeks so I'm hoping Andrzej's on here to answer some questions.   Why compact_optional as a separate type?  I think it's because you changed the API but I just wanted to double-check. Why change the API?  While I can understand the desire to provide a less error-prone API, I worry that subtle differences in the two APIs can lead to bad assumptions.  Consistency & ease-of-use of APIs is important I think.  compact_optional feels unnecessarily restricted. I love the idea behind tagging the sentinels as different types.  I worry that it would get rejected by the standards body as unnecessary complexity.  Thoughts?  If you think it's a strong addition to the proposal I'll incorporate it.   To understand my reasoning, my motivation is as follows:   Lots of existing code uses sentinel values all over the place. Sentinel values are dangerous & error-prone.  There are no safety checks that you're not accessing a non-sentinel value. They are common in memory-mapped data structures They are common in STL interfaces (std::string::npos) It's not an uncommon concern when replacing legacy code that regression risk be minimized.   My most recent thinking on the matter is as follows:   optional<compressed_scalar<double, 0>> y = 5; y = 0;  assert(y) fails - compressed_scalar being assigned the sentinel value is equivalent to being cleared. optional<compressed_scalar<double, 0>> == 0 returns true - empty state & sentinel representing empty-state is true.  This follows from the rule above  optional<compressed_scalar<double, 0>> y = 0; y < -5 returns true - empty state always less (as with regular optional).  All relational operators for real & compressed optional work as ""expected"".  The only ""caveat"" is that sentinel values is treated as empty-state which preserves the principle of least surprise.   A more limited API makes transitioning existing code more difficult.  I'm also concerned that the sentinel value isn't asserted but that could just be a misreading on my part.  Thus I wanted to make sure that I could guarantee it's a complete drop-in replacement that would maintain all existing semantics without any further code-changes (aside from trivial compile-time issues like converting access to dereference).  Of course, now that I think about it, Andrzej is probably right about the comparisons; if we follow the definition for std::optional, std::string::npos may have been sorted at the end but if you change it to a compact_optional with relational operators it would be sorted at the beginning.  I'm not 100% convinced though that the inconvenience of not having them is better; I think at the very least == & != need to be defined.  Thanks for the great write-up Andrezj!"
cpp,3df614,vlovich,4,Thu Jul 16 05:41:35 2015 UTC,"Hi Vitali. This is to address some of your questions.  I believe that the optimization of compact_optional comes at the cost of inevitably breaking one boost::optional's (and std::experimental::optional's) guarantee. As stated in the post, boost::optional is a 0-or-1-size container. Many people even request adding iterator interface to it. This means that once you determine it is of size 1, you can read and write the element at will without affecting the ""container's"" size. compact_optional cannot guarantee that.  The above difference is sufficient (at least for me) to say that we break the interface of boost::optional. This warrants the addition of a separate type.  Now, because I have a separate type, and a liberty to change the interface, I take the opportunity to alter the interface further to service my needs. These needs are basically: 1. Avoid boost::optional's gotchas (by sacrificing notational convenience) 2. Avoid things that confuse new developers 3. Start with the minimum and expand later as needed.  The differences in API between boost::optional and compact_optional are not subtle: they are immediately visible. I consider it a safety feature: you immediately see that you are dealing with something else than boost::optional.  My experience in the teams I work in is that the use of operator bool() and operator* in optional confuses people, and although these operators are the encouraged interface, many programmers use the obsolete functions: get() and is_initialized().  Regarding operator<, I am pretty sure I do not want it. The least surprise option may still be a huge surprise. Instead, I would be willing to provide a set of function objects: less_with_empty_lowest, less_with_empty_highest, less_expect_no_empty.Regarding operator== it appears more safe. But I would rather take some time to think about the consequences of adding it.  Regarding the standardization, it is a separate issue. I have no intention of proposing compact_optional for standardization. std::experimental::optional is a very fragile compromise. Nearly every single function in the interface is controversial, and that it finally made it to the TR and is considered for standardization is amazing. Proposing any change to it (especially an experimental one) risks breaking the compromise and loosing std::optional altogether. Therefore I have made sure that my experiment does not compete with optional. This is more a political than technical question.  Regards, &rzej"
cpp,3df614,akrzemi1,1 point,Thu Jul 16 11:11:26 2015 UTC,Why do you need a detail_::compact_optional_base class in the implementation? (Why isn't this implemented inside compact_optional ?)
cpp,3df614,gnzlbg,1 point,Tue Jul 21 15:40:55 2015 UTC,"compact_optional_base has only one template parameter: it does not depend on the ""tag"". It contains all operations that do not depend on the tag. This way I prevent the code bloat: otherwise functions like has_value() would have been instantiated for every tag separately."
cpp,3df614,akrzemi1,4,Tue Jul 21 20:40:31 2015 UTC,Why can't compact_optional<T> have an operator== that simply delegates to std::equal_to<T>?
cpp,3df614,TemplateRex,6,Wed Jul 15 21:28:39 2015 UTC,"The simplest example is NaN.  Floating-point is probably the only known case in existence where there's a value that is never equal to anything, but it's an important type."
cpp,3df614,vlovich,3,Thu Jul 16 05:42:48 2015 UTC,Boost tribool's indeterminate state is similar.
cpp,3df614,Eoinoc,6,Thu Jul 16 11:13:02 2015 UTC,"Couldn't the standard optional do something similar, and let us overload how each type tests for empty?"
cpp,3df614,frog_pow,1 point,Thu Jul 16 05:19:58 2015 UTC,"Just a quick comment on performance, as I discovered after implementing a similar solution myself a while ago. Using a sentinal value for the empty state can make it difficult for the compiler to elide branches that check for empty (e.g., after constant propagating an optional value known to be assigned), since the assignment itself does not guaranteed that the value is not equal to the empty state. I hadn't thought about it at the time, but knocked up an experiment now, where it appears you can eliminate this by using an assume directive to tell the compiler the value cannot be the empty value if assigned from T. GCC godbolt proof of concept: http://goo.gl/1h7G5c"
cpp,3ddigg,nerdandproud,11,Wed Jul 15 12:36:54 2015 UTC,"Someone on here a while back posted a Github link to a C++14 HTTP library that looked promising, if a bit immature.  EDIT: Found it!"
cpp,3ddigg,acwaters,7,Wed Jul 15 13:46:42 2015 UTC,"Thanks yeah I saw that after I posted too. It returns a string as the response's body though again storing it entirely in memory, probably because of the same problem with the libcurl callback I mentioned. I like it more than the other curl wrappers though."
cpp,3ddigg,ThisIs_MyName,1 point,Wed Jul 15 14:06:29 2015 UTC,"problem with the libcurl callback   I'm not sure I understand that problem. If you want to get a stream instead of the callback, can't you do something like this:   vector<char> buffer; void curl_callback(char[] chunk, size_t size){     buffer.insert( buffer.end(), chunk, chunk+size); } char* stream_get(size_t chars){     char ret[chars];     copy(buffer.begin(), buffer.begin()+chars, ret);     buffer.erase(buffer.begin(), buffer.begin() + chars);     return ret;  }"
cpp,3ddigg,ThisIs_MyName,1 point,Thu Jul 16 05:30:52 2015 UTC,"That doesn't work because the callback is called inside curl.perform() until the request is completely done, the stream then holds the entire request which is not really stream like"
cpp,3ddigg,ThisIs_MyName,1 point,Thu Jul 16 06:14:50 2015 UTC,"er, curl.perform() is running in a different thread right?  Do you want to stop downloading data until the JSON parser wants more?"
cpp,3ddigg,ThisIs_MyName,1 point,Thu Jul 16 06:29:18 2015 UTC,"Nope it blocks the thread that calls it until the request is done. I want the json parser to process the data in the chunks that are incoming so that I only need memory for the decoded object not the object plus the json data. However all parsers I've seen are designed for reads they drive like with fread or a stream. Here they would need to be able to partially parse a char buffer, then hold that state until the next callback and then continue parsing the next buffer. With reads they drive they don't have to make their parsing state explicit because it's just the local function state."
cpp,3ddigg,ThisIs_MyName,1 point,Thu Jul 16 06:39:51 2015 UTC,"No I meant that you should be calling it with std::async and co. It's just one line, man :P"
cpp,3ddigg,whoshuu,1 point,Thu Jul 16 06:41:55 2015 UTC,Ok so you mean running .perform() async and then feeding back chunks via a concurrent channel or something? This should work but means we're doing a round trip through the scheduler for every chunk though I guess this can be mitigated by aggregating larger chunks.
cpp,3ddigg,consudeathchant,1 point,Thu Jul 16 07:31:53 2015 UTC,"but means we're doing a round trip through the scheduler for every chunk   Eh, this is exactly what happens when you use a Java async http library. The inefficiency is baked into their API. And besides, if you're running on a dual-core, curl will download at the same time that your parser consumes. There should be no overhead if you use a lock-free list.   The only alternative is to pause downloading until the JSON parser wants more and then do a round trip through the network to ask for more."
cpp,3ddigg,tpecholt,1 point,Thu Jul 16 07:40:33 2015 UTC,"Actually I think for example the netty project doesn't have a different thread handle the request than the one unblocked by epoll/select. The handlers are simply called by whatever thread was handling that socket in it's select. So imho there shouldn't be a round trip through the OS scheduler, similarly in Go the goroutine scheduler is integrated with select/epoll I expect it's also similar in node.js. I'm not sure about Apache HttpClient but I'm guessing for that one you're right.  However it looks like the libcurl multi interface will allow me to do a stream abstraction similar to http://curl.haxx.se/libcurl/c/fopen.html"
cpp,3ddigg,encyclopedist,3,Thu Jul 16 09:50:33 2015 UTC,"Hey, we were talking about this last week, CPR is pretty awesome: https://www.reddit.com/r/cpp/comments/3corbu/cpr_c_requests_library_written_in_modern_c/  Paging the dev /u/whoshuu  The only reason I'm still using POCO for http is that I don't want to do OAUTH1 signatures myself and POCO takes care of that :)"
cpp,3ddigg,OldWolf2,3,Wed Jul 15 20:35:49 2015 UTC,"Hey there. Thanks for thinking it's awesome! Just a small correction here, cpr minimally requires C++11, there's nothing in it that needs a C++14 compatible compiler.  I've got my eye on OAUTH1 support for a future release, so stay tuned."
cpp,3ddigg,consudeathchant,6,Wed Jul 15 21:43:42 2015 UTC,"C++ REST SDK  Never used it myself, just saved into bookmarks, might be worth trying (from Microsoft)"
cpp,3ddigg,mtgdjs,2,Wed Jul 15 14:32:22 2015 UTC,"I am using it for the current project. Previously I had an experience with boost asio and cpp-netlib. Some highlights:   leads to clean and short code async interface by default, turning it into blocking interface is as easy as to call .get() on resulting task supports HTTPS and compilable under windows/linux/android/ios. It even comes with a CMakeLists.txt builds on boost::asio (although on windows WinHTTP is used by default) suppport for other stuff like oauth, json   Then there are some drawbacks:   sometimes little lack of consistency between supported platforms - for example windows build uses WinHTTP which handles http redirection by default but asio version doesn't do it traditional string_t madness (UTF-16 std::wstring on windows vs UTF-8 std::string elsewhere) doesn't help the code portability.    In overall I think this library is your best bet especially for new projects"
cpp,3ddigg,OldWolf2,2,Thu Jul 16 15:04:54 2015 UTC,"That actually looks quite decent. Can someone explain to me what the advantage of async is when you're chaining them with ""then"" and waiting for the result? My gut says that actually has more overhead than just sync io with maybe another thread and a single join because those pplx things look like they need to do a lot of synchronization under the hood"
cpp,3ddigg,whoshuu,4,Wed Jul 15 15:48:55 2015 UTC,"Threads are pretty heavy (in terms of memory) and slow to switch between. Async approach allows you to handle hundreds of connections per thread. This is why, for example, nginx (async) web server is so much faster than apache (thread-based)."
cpp,3ddigg,GibletHead2000,2,Wed Jul 15 17:57:30 2015 UTC,"Yes I'm aware of the advantages of select/epoll and friends. But what is happening here, I guess their pplx thing is basically a replacement for green threads?"
cpp,3ddigg,sepehrhm,-9,Wed Jul 15 20:32:03 2015 UTC,Note: Only works with MSVC
cpp,3ddigg,lednakashim,6,Wed Jul 15 14:36:33 2015 UTC,"I do not see this requirement, can be build on Linux.  http://casablanca.codeplex.com/wikipage?title=Setup%20and%20Build%20on%20Linux&referringTitle=Documentation"
cpp,3ddigg,sepehrhm,5,Wed Jul 15 14:46:29 2015 UTC,"The page says that it supports Ubuntu, OSX, iOS, and Android, and MSVC doesn't run on any of those. I can't test that though."
cpp,3ddigg,lednakashim,-1,Wed Jul 15 14:49:16 2015 UTC,"Hmm, OK."
cpp,3ddigg,useful_idiot,3,Wed Jul 15 14:52:08 2015 UTC,It actually looks like it works with other compilers and in fact is more feature complete on other operating systems oddly enough.
cpp,3ddigg,rtomek,6,Wed Jul 15 14:47:19 2015 UTC,"Qt has a decent http library, but it might be a bit heavyweight for your needs as you have to pull in the whole of QtCore and QtNetwork to use it."
cpp,3ddigg,OldWolf2,2,Wed Jul 15 14:53:47 2015 UTC,"It is both heavyweight, and also drags you into Qt framework - which is somewhat necessary based on the design decisions in this Qt module."
cpp,3ddigg,wildcarde815,1 point,Wed Jul 15 14:58:33 2015 UTC,"The only heavy weight part is the one-time download, using Qt will slightly increase your compile times but it doesn't give a run-time performance drag. Take a look at QCoreApplication, for a console style programs."
cpp,3ddigg,__Cyber_Dildonics__,0,Thu Jul 16 06:38:06 2015 UTC,Almost all the C++ code that I've written in the past 2 years were in Qt Framework.
cpp,3ddigg,wildcarde815,0,Thu Jul 16 07:05:11 2015 UTC,I'm glad we agree :-)
cpp,3ddigg,OldWolf2,2,Thu Jul 16 07:30:25 2015 UTC,"If you're already using Qt these are a great solution, however I wouldn't link against QtCore and QtNetwork just for rpc."
cpp,3ddigg,fritzroid,1 point,Wed Jul 15 17:48:58 2015 UTC,"Not quite as big of a library, but very similar to Qt is Wt. It uses boost for signal/slot handling which is great too. There is a Wt::JSON module available.  http://www.webtoolkit.eu/wt/doc/reference/html/modules.html"
cpp,3ddigg,fritzroid,8,Wed Jul 15 21:23:51 2015 UTC,I found POCO pretty easy to get sockets up and running.  It has a JSON parser but I found minijson easier.
cpp,3ddigg,xcbsmith,3,Wed Jul 15 14:35:01 2015 UTC,"I love the list of features in poco, didn't love looking for documentation the last time I tried thou."
cpp,3ddigg,encyclopedist,2,Wed Jul 15 15:26:12 2015 UTC,There should be pdf documentation on their site.
cpp,3ddigg,cdglove,2,Thu Jul 16 00:12:06 2015 UTC,"There are a bunch of slides in pdf form but there's no formal docs (the last time I looked, I haven't in quite some time.). Ie boosts log, or the Wt framework (wt also has extensive examples). Admittedly those spoil us but they are excellent documentation."
cpp,3ddigg,cdglove,0,Thu Jul 16 00:58:05 2015 UTC,"It seems better documented than most C++libraries (which isn't saying much). The presentation slides cover the overview, and you can read the source code too."
cpp,3ddigg,tpecholt,3,Wed Jul 15 22:18:56 2015 UTC,"What you're looking is a SAP-type JSON parser. I dont know any and, to be sincere, I'd not use something that calls back at every bracket. This json parser is very clean if you dig ""modern"" C++.  If you ignore unicode handling, json is extremely easy to parse (that's the intent).    Http can get dicy due to redirections and caching. What I did in the past is to write something on top of libCURL/easy and just use the DOM-like json parser cited on top."
cpp,3ddigg,cdglove,1 point,Wed Jul 15 13:19:46 2015 UTC,"The problem isn't so much with the JSON Parser, rapidjson has a SAX interface too. Also with Jackson JSON in Java there is a really low interface where one uses only the tokenizer which is what I do in Java.   The problem is that libcurl drives the blocking reads and then calls back at the code using it with whatever it read. This runs counter to what you need to implement a stream, there one needs to block the current thread when there is no more data thus one needs to be driving the reads. The only way I see to do that with libcurl is using another thread and something like rendezvous where the libcurl thread gets blocked when no one reads the data it has and the reading thread gets blocked when there is no new data."
cpp,3ddigg,xcbsmith,6,Wed Jul 15 13:32:26 2015 UTC,"You could do curl in a non-blocking fashion using the multi interface.  What they are doing is obviously encapsulating a poll(), which is rather bulky but hey, it is easy to break down this loop into a stateful object to track it."
cpp,3ddigg,vlovich,1 point,Wed Jul 15 14:59:25 2015 UTC,Thanks this should work!
cpp,3ddigg,vlovich,5,Thu Jul 16 07:33:45 2015 UTC,"Honestly, I found cpp-netlib to be pretty awesome..."
cpp,3ddigg,dicroce,2,Wed Jul 15 15:39:42 2015 UTC,"I tried looking in the code and docs to find what the format of the response is because they cast out to strung sometimes and how to get a stream but my C++ is a bit rusty and I just couldn't find it, any pointers?"
cpp,3ddigg,ltce,2,Wed Jul 15 15:50:42 2015 UTC,"It seems there is no ""stream"" interface, but there is a callback interface:  response_ = client_.get(request_, callback)     Perform an HTTP GET request, and have the body chunks be      handled by the callback parameter. The signature of callback      should be the following:      void(iterator_range<char const *> const &, boost::system::error_code const &)."
cpp,3ddigg,ltce,1 point,Wed Jul 15 17:31:52 2015 UTC,"IIRC, there is a blocking way to do this blocking without a callback, need to find it though..."
cpp,3ddigg,pjmlp,2,Wed Jul 15 18:01:34 2015 UTC,Yeah that template magic really didn't lend itself to code as documentation
cpp,3ddigg,ltce,1 point,Wed Jul 15 20:33:02 2015 UTC,It is awesome. I never had to use a DSL for it so I don't know what OP is referring to. Sometimes I think people don't RTFM.
cpp,3ddigg,slantes,1 point,Wed Jul 15 17:55:23 2015 UTC,"Look at the link, it says the directives are it's own dsl for message passing, their words not mine"
cpp,3ddigg,cdglove,1 point,Wed Jul 15 20:34:17 2015 UTC,cpp-netlib is no longer maintained and sometimes template heavy which hurts compile time. Go for REST SDK. I used both and the later one is much easier to use.
cpp,3dbns5,STL,30,Wed Jul 15 00:43:45 2015 UTC,I am really pleased with the way Stephan has kept us up to date (and of course his work on STL in VS has been top notch). Increases our confidence in VC++ which had a lot of catching up to do.
cpp,3dbns5,Samaursa,5,Wed Jul 15 02:42:57 2015 UTC,Hearing from him that there are known flaws in the implementation of C++98 features that they're not actively even planning to address <for VS2015> makes me unhappy though. And I'm not talking about export templates.
cpp,3dbns5,Dascandy,4,Wed Jul 15 06:42:15 2015 UTC,"known flaws in the implementation of C++98 features that they're not actively even planning to address   Such as?  As far as I know, the VC team wants full compatibility.  Changing their parser will be part of that and not ready for VS2015, but as far as I understand it is something on the roadmap.  Please correct me if I'm wrong."
cpp,3dbns5,ZMeson,2,Wed Jul 15 07:14:51 2015 UTC,"https://www.reddit.com/r/cpp/comments/3c6ta6/is_there_a_way_to_understandknow_cc_standard_more/cst0a0j  Dependent bases are not being handled in a two-phase lookup but rather one-phase, making functions resolve to the wrong place and all sorts of miscompilation around it."
cpp,3dbns5,Dascandy,11,Wed Jul 15 07:23:49 2015 UTC,"If you look at u/STL's response, he says that two-phase lookup (which is what I meant by a new parser -- perhaps wrong terminology) is on the list of things to implement.  So MS does want to fix it."
cpp,3dbns5,ZMeson,3,Wed Jul 15 07:26:18 2015 UTC,".. Good point. It's not being fixed for VS2015 though, while it's a bug in a standard that's been around for 17 years when that comes out though. Edited my original comment though, because you do have a point."
cpp,3dbns5,Dascandy,7,Wed Jul 15 07:44:28 2015 UTC,"I agree that it is an important feature, but one should understand that MSVC doesn't have an AST for multiple reasons, including performance and memory consumption.   Moving the front-end to be ""AST""-based is a lot of error-prone work.   So while I consider this feature to be very important, I can certainly understand that they prioritize multiple other features that require less work and that might have a larger impact on the users."
cpp,3dbns5,gnzlbg,9,Wed Jul 15 12:16:57 2015 UTC,"VC Dev Mgr here.   folks, i'm trying to give more forward guidance to the community, but I don't want to do that in places where we aren't fairly confident we have a timeframe and a detailed plan.     No one has said we won't eventually fix two-phase lookup.   The problem is that it would break massive amounts of existing code and so we need to be very careful how we approach this.   This is just prudence.   We are not ignoring the feedback or the priority many customers put on this.   We continue to refactor C1xx (our classic front end for c++) in place to make these sorts of changes possible."
cpp,3dbns5,spongo2,3,Wed Jul 15 17:53:23 2015 UTC,I can definitely sympathize.  Preserving correct SFINAE behavior in the face of doing lookup into dependent bases has been quite a challenge in clang's -fms-compatibility mode.
cpp,3dbns5,cokernel_hacker,18,Wed Jul 15 22:33:12 2015 UTC,unordered_meow   ?
cpp,3dbns5,_IPA_,69,Wed Jul 15 02:50:17 2015 UTC,"Saying ""unordered_map/unordered_multimap/unordered_set/unordered_multiset"" is a lot of work. Making cat noises is easier."
cpp,3dbns5,Rarrum,8,Wed Jul 15 03:10:16 2015 UTC,We never meow in order.
cpp,3dbns5,KazDragon,4,Wed Jul 15 03:52:08 2015 UTC,Nobody can order those cats to do anything.  They'll do what they want.
cpp,3dbns5,gnzlbg,10,Wed Jul 15 12:38:23 2015 UTC,"Wow, rewriting <functional> must have been a considerable undertaking. When you were rewriting this, did having the list of bugs in the back of your mind motivate any implementation decisions? Or, was the focus on writing standards compliant code with the fixes happening naturally as a result?   And congrats on the upcoming release :)"
cpp,3dbns5,gnzlbg,29,Wed Jul 15 01:31:50 2015 UTC,"Yeah, it was a ton of work. It's the largest thing I've written from scratch in the STL so far, although not the most complicated checkin I've ever had (that would be when I processed Dinkumware's real-variadic-templates changes in 2013).  Excellent question about the motivations. Several things influenced my implementation design:   Structure the code to avoid repeating all reported and unreported bugs. Avoid TR1-era patterns that harmed comprehensibility and maintenance. Follow the Standard as directly as possible, including all corner cases. Avoid any trace of Expression SFINAE (which I almost managed perfectly, but had to fix one thing). Pay as little complexity as possible in order to achieve this. (Lines of code is a rough measurement of complexity.)   I would summarize the difference between the TR1-era implementation and my implementation as being object-oriented programming (in the literal sense, not with virtuals) versus function-oriented programming. In the old implementation, there were many many layers of object wrappers, needed to adapt callable objects (possibly function pointers, function objects, PMFs, PMDs) to a uniform syntax, constantly asking about their argument types and return types. This created many opportunities for bugs hiding in each layer, and made it difficult to do things like support arbitrary calling conventions, because anything manipulating a function type or PMF type would have to handle everything. In the new world order, things like std::function, reference_wrapper, and so forth take and store arbitrary callable objects while manipulating them as little as possible. They simply ensure that the callable object and any arguments are forwarded properly down to invoke(), where all of the complexity is centralized. And invoke() is purely a function, with no wrapper classes. (There are helper classes, needed to avoid Expression SFINAE; ordinarily we prefer pure tag dispatch, but that triggers compiler explosions as it considers expressions that won't compile. So I have a layer of struct specializations, used to avoid considering stuff that won't compile.) We do need to inspect callable objects in invoke(), but this is centralized as much as possible (primarily in is_function/is_member_function_pointer's support machinery, which has to inspect them anyways). This is what allowed me to handle arbitrary calling conventions, and also respect C++11's ref-qualifiers which we didn't previously support in either the compiler or the libraries.  Things like the reference_wrapper bugs were fixed for free, and we got the trivially copyable reference_wrapper feature too. bind()'s implementation is still fairly complicated by ordinary standards, but it's much simpler than before, and it's vastly easier to see how it stores the functor and its bound arguments, and then ""fixes up"" the unbound arguments.  I definitely could not have done this without studying Dinkumware's original implementation for years. (Nor could I have written a TR1-era implementation. Back then I literally didn't know how, and today I'd go crazy without access to rvalue references, decltype, variadic templates, etc.) I also received a fair number of fixes from the compiler team during this work; my new implementation exercised new codepaths and found lots of exciting compiler bugs. We were able to get fixes for all of them, with all workarounds removed, so you won't have to see any of the intermediate hackarounds that I had during 2015's development."
cpp,3dbns5,gnzlbg,3,Wed Jul 15 02:20:55 2015 UTC,"Thank you for a great response, and all the hard work.  Just curious, in the future when Expression SFINAE is available in the compiler will you be revisiting this with a mind to simplify the implementation where possible, for example with the need for the helper classes mentioned?  I can only imagine how nice it must feel to see these workarounds disappearing after having spent so much time with them (remembers _VARIADIC_MAX). Keep up the good work, I'm looking forward to what's coming down the line next."
cpp,3dbns5,flebron,11,Wed Jul 15 07:55:19 2015 UTC,"It should be possible to simplify the logic, although simplifying correct code is lower priority than fixing broken code or implementing features. I'll have to add Expression SFINAE support to std::function's ctors and result_of, so I might have time to redo invoke() then. It shouldn't be very hard, and I have exhaustive test coverage written during the overhaul."
cpp,3dbns5,adzm,3,Wed Jul 15 08:21:02 2015 UTC,Were you able to make invoke constexpr?
cpp,3dbns5,_VZ_,5,Wed Jul 15 12:19:00 2015 UTC,"No. Unlike noexcept, implementers are forbidden from ""strengthening"" constexpr. invoke() isn't depicted as constexpr in the Working Paper, so I can't mark it. (Apparently, attempting to do so would wreak havoc, although I don't completely understand the problem yet.)  Edit: Here's where Eric Niebler explained the problem with attempting to make invoke() constexpr."
cpp,3dbns5,sakarri,1 point,Wed Jul 15 16:28:46 2015 UTC,"Thanks for the answer STL! I was asking specially because of this issue in libc++.   IIRC in that issue the problem was about how libc++ uses invoke internally for things like result_of, where SFINAE takes different path at compile time when invoke is constexpr because it is then evaluated in unevaluated contexts.   ""Maybe"" your <functional> implementation does not have this problem. That is a long shot, but if you manage to give that a try and run that through your test suite the feedback would be interesting. Trying to debug this issue is very hard tho."
cpp,3dbns5,AntiProtonBoy,2,Thu Jul 16 08:14:01 2015 UTC,"Well, we never ask invoke() to SFINAE (except in bind's function call operator, where we appear to be getting away with it), so we'd probably be immune for the time being. But that will have to change soon."
cpp,3dbns5,louiswins,1 point,Thu Jul 16 08:44:40 2015 UTC,"But that will have to change soon.   Interesting, is that because of new features or could you elaborate on why?"
cpp,3dbns5,kozukumi,1 point,Thu Jul 16 13:10:07 2015 UTC,"After Expression SFINAE is implemented in the compiler, I'll need to update std::function's ctor and result_of."
cpp,3dbns5,adzm,5,Thu Jul 16 16:27:30 2015 UTC,That's an impressive list of fixes and rewrites :) Nice job!
cpp,3dbns5,adzm,3,Wed Jul 15 01:21:39 2015 UTC,Indeed; really looking forward to rtm so I can use vs2015 in production!!
cpp,3dbns5,adzm,4,Wed Jul 15 02:17:14 2015 UTC,"This is probably the least significant of the issues mentioned in this post, but I'd still like to personally thank you for dealing with C4503 (""decorated symbol name exceeded""). This warning always looked to me as if the compiler were warning its users about its own defect, so I, for one, will be very glad to never see it again."
cpp,3dbns5,Plorkyeran,5,Wed Jul 15 22:24:39 2015 UTC,"You're welcome! Figuring this one out was extremely tricky, but after I identified the things that were causing mangled name amplification, reworking them as part of the <functional> overhaul was simple."
cpp,3dbns5,uniacc3,1 point,Wed Jul 15 23:06:47 2015 UTC,"Oh it's still there, make no mistake.  It just doesn't happen as often for some fairly common combinations of STL classes."
cpp,3dduf4,Tatyanazaxarova,2,Wed Jul 15 14:26:16 2015 UTC,"It took me a moment to understand what PVS-Studio was trying to convey, since for me the overloaded operator%()implemented by the Boost.Format library was totally inconspicuous. However, even after realizing that the code would have been problematic if the operator was not actually overloaded, the generated diagnostic itself still did not make too much sense to me. In the end, I 'resolved' this message by suppressing it as well.   Sounds like either user error, or a PVS Studio bug, or both. Probably both."
cpp,3dduf4,hotoatmeal,1 point,Wed Jul 15 16:13:51 2015 UTC,"What kind of user error do you have in mind, if I may ask?"
cpp,3db7tr,meetingcpp,5,Tue Jul 14 22:40:46 2015 UTC,"This would be interesting if there were any kind of definition provided for what ""morally equivalent means"" (at least as a placeholder).  The claim that tuple<Unit, T> brings no new information over T & is thus equivalent seems intuitively false to me.  Consider instead you have two tuples: tuple<MouseDown, Coordinates> and tuple<MouseUp, Coordinates>.  Clearly MouseUp & MouseDown contain information by virtue of their type alone even if they contain nothing.  Thus the analogy seems like it's missing something important about type-theory, but since there's no definition provided anyone can substitute in their own views on what the author is trying to say.  I certainly understand the attempt at drawing a parallel & perhaps it is actually a good analogy.  The presentation I think could use something a little more formal"
cpp,3db7tr,vlovich,5,Tue Jul 14 23:03:33 2015 UTC,"[That's my blog post]  Thanks for the comment! The ""morally equivalent"" means isomorphism, which I didn't want to define formally because that requires a bit of cooking to get there, and this was initially a simple email that I lifted into a blog post. I'll think about editing the post to give more details around this. Regarding the claim that tuple<Unit, T> is equivalent to T, I'll think of a satisfying answer to your (very valid) remark and come back to you."
cpp,3db7tr,louis_dionne,1 point,Wed Jul 15 06:16:22 2015 UTC,"Great post. I agree maybe it would be nice to give intuition for morally equivalent. This is not the most familiar branch of math for me, but it seems like maybe a better way to say it would be: equivalently representable as. In other words, <Unit, T> and <T> can represent the exact same stuff, and each other. This is a bit different then saying they are equivalent. After all, natural languages can generally represent the same thoughts and feelings, but I wouldn't say French and English are ""morally equivalent"" ;-)."
cpp,3db7tr,quicknir,2,Wed Jul 15 14:33:23 2015 UTC,"Thanks for the comment. I updated the blog post to give a better intuition regarding ""morally equivalent"", and I added a link to the notion of ""isomorphism"" for those interested."
cpp,3db7tr,louis_dionne,5,Wed Jul 15 17:28:42 2015 UTC,"I liked the presentation for not being too formal.  The issue might be that MouseDown and MouseUp are not the Unit type. The Unit type is defined to be semantically meaningless (in Rust and Haskell, so maybe this is also the case in this blog post). As you say, MouseUp and MouseDown do have a semantic meaning.   Although MouseUp and MouseDown are isomorphic to Unit,  in category theory isomorphism implies everything that's true about a designated part of one object's structure is true about the other's.  I interpret this in this context as the ""meaningless"" part of MouseUp and MouseDown is equal to the ""meaningless"" part of Unit, but MouseUp and MouseDown are not equal to Unit and not equal to each other.  I guess that what /u/louis_dionne explains in the post applies to the Unit type only, but I am not sure."
cpp,3db7tr,gnzlbg,1 point,Wed Jul 15 10:17:53 2015 UTC,"I haven't really studied category theory, so at least mentioning isomorphism with a link would have been fine.  That way the reader knows there's some real math behind it & can go along for the initial ready & study up on the concept later.  Of course, if the audience is people who already know category theory then what he wrote is probably just as fine.  Since it grew out of an e-mail, it's likely the case is the latter & I'm just not the intended audience.  That being said, I'm still not convinced by the Unit argument and ""meaningless"".  How do we classify ""meaningless""?  Is that something real in category theory?  Do we just arbitrarily say that the we name some arbitrary thing and that is our unit type & everything else has extra type information that makes it not the unit type?  That seems confusing.  Do we say that all empty types are equivalent so that you cannot distinguish the type of MouseUp, MouseDown & Unit?  That doesn't seem right.  C++ obviously isn't a functional programming language but it already has two Unit types: std::nullptr_t and std::nullopt_t and a function accepting one cannot accept the other."
cpp,3db7tr,vlovich,3,Wed Jul 15 14:57:01 2015 UTC,"I gave some thought to your question, and here's what I would say.  In the post, I purposefully do not say ""equal"". I say ""equivalent"", which hints at the fact that I'm defining ""equivalence"" as some custom relation which is not the same as equality. Indeed, the definition of equivalence to which I refer in the post is the notion of isomorphism in category theory. Stripped down to the minimum which is of interest to us in this context, that definition can be written as:   Two types T and U are isomorphic if (and only if) there exists lossless structure-preserving functions from both T to U and U to T.   This means that both types contain the same ""amount"" of information, and they also have the same ""organization"" of that information. For more information, see my comment on Eric Niebler's blog here, and I'll try to precise here if you have further questions. Note that if you were able to define a category where morphisms take into account the semantic meaning that you want to attach to types like MouseUp and MouseDown, you might find that MouseUp and MouseDown are not isomorphic (in that category). I have no idea how you could define such a category, or if this is even possible.  So basically, what I'm saying is that we define ""equivalence"" as being some relation which is useful to help us reason about things, while purposefully throwing away a lot of things that we consider as details. But this is just a definition, and of course MouseUp and MouseDown are not equivalent in terms of the meaning they convey to a human (english speaking) reader. It's just that we're not interested in that precise meaning when talking about isomorphism in the C++ category (which is equivalent to the category of Sets)."
cpp,3db7tr,louis_dionne,2,Wed Jul 15 19:36:07 2015 UTC,"I haven't really studied category theory, so at least mentioning isomorphism with a link would have been fine.    Me neither, and I agree that mentioning that could be useful. For context the discussion was happening in the boost mailing list here and here (the thread got split for some reason).   How do we classify ""meaningless""? Is that something real in category theory? Do we just arbitrarily say that the we name some arbitrary thing and that is our unit type & everything else has extra type information that makes it not the unit type? That seems confusing.    I'll try to explain how I see this but i'm not a professional.  First, these rules work ""within the type system"". The type system does not know about meanings. It lets us create new types that are not equal to other types: e.g. for struct MouseUp {}; and struct Unit {}; we have that std::is_same<MouseUp, Unit> == std::false_type.   We do not classify meaningless, we define it. We can define the meaning of the type Unit to be ""without meaning"", in the same way we can define the meaning of the type MouseUp to be ""indicates that the mouse is moving up"".   Once we have a program with these types, we can redefine the meanings to be completely different, and our program still type checks: the type system knows nothing about meanings.  Within the type system, these types are isomorphic to each other, because we can write:  auto map(Unit) -> MouseUp { return {}; } auto map(MouseUp) -> Unit { return {}; } // add metafunctions here that transform one type into the other   It doesn't matter that these functions make no sense, we can still write them down and they do type check.   We could also define MouseUp to be meaningless and write it as using MouseUp = Unit and then std::is_same<MouseUp, Unit> returns std::true_type.    & everything else has extra type information that makes it not the unit type?   Well using MouseUp = Unit introduces a new ""alias"" for Unit but not a new type. It makes little sense in a programming language to allow introducing a new distinct type that is equal to another: you could use these types interchangeably and would not be able to tell them apart, so in some sense, this is exactly what using does. So we could say that ""in some sense"" (waves hands) we can use using to ""create a new type"" that is both isomorphic and equal to another type such that there could be multiple unit types (waves hands very much).   Do we say that all empty types are equivalent so that you cannot distinguish the type of MouseUp, MouseDown & Unit? That doesn't seem right. C++ obviously isn't a functional programming language but it already has two Unit types: std::nullptr_t and std::nullopt_t and a function accepting one cannot accept the other.   No, we say that these types are isomorphic because we can write these functions, but as long as std::is_same returns false they are not equal within the type system. Note also that these types are not unit, since they do have a meaning: a null pointer is not the same as a null optional, which is why functions accepting one cannot accept the other. Note also that C++ also has void, and probably many more.  EDIT: a couple of things worth noting:   Nothing forbids you from having different types with the same meaning. They are isomorphic, but within the type system they are not equal because they are not the same type. An example of using these types is Rust. Send and Sync are ""empty types"" that are not equal [*]. They are distinct isomorphic types and one uses them to ""encode meaning"" into the type system. If a function expects Send and your type doesn't provide this, the program does not type check because of a type mismatch. Rust uses this to guarantee data-race freedom as long as you use these empty types correctly (following their meaning). If you use them wrong, your program will still type check, and you will get a data race.    [*] This is a bit of a lie. In Rust they are Traits, but in C++ they would be tag types. For the discussion it is enough to consider them as types."
cpp,3db7tr,gnzlbg,2,Wed Jul 15 15:37:57 2015 UTC,"Think of Bottom type as the null set. There is only one null set. Then unit type is any singleton set. So {1} is a unit type, as is {2} or {Car} or {Pluto}. All of them are valid unit types. As you note, std::nullptr_t and std::nullopt_t are both valid unit types. So, you can have only 1 bottom type but multiple unit types. And you can distinguish between various unit types too. {2} is obviously different from {Car}.  A tuple is a cartesian product of 2 sets. The no. of elements in A x B, n(A x B) = n(A) x n(B). Now, if A is a unit type, n(A) = 1. Therefore n(A x B) = n(B).  If C is a unit type, n(C x B) = n(A x B) = n(B). That is why the author says tuple<unit,T> is equivalent to T. I can set up a bijection between A x B and C x B. However, C x B != A x B.  Lets take a concrete example. Take the set of real numbers, R. {1} x R, {2} x R and R x {1} are all lines on the cartesian plane. They are distinct, but they are all the same line, just rotated / translated.  Coming back to C++, tuple<nullptr_t, T>, tuple<nullopt_t, T> and T all contain the exact same number of elements, that of T. Their expressive power is the same.  You can also think of it like this: Given any function f: nullptr_t x T -> U, I can write a function g: nullopt_t x T -> U and a function h: T -> U which will all be equivalent. Thus the types are equivalent."
cpp,3db7tr,whichton,2,Wed Jul 15 18:37:14 2015 UTC,"That is pretty close to what I would have replied. However, note that you can have multiple Bottom types, but they will all be isomorphic. Just define  struct Bottom1 {     Bottom1() = delete;     Bottom1(Bottom1 const&) = delete; };  struct Bottom2 {     Bottom2() = delete;     Bottom2(Bottom2 const&) = delete; };   Then both types are clearly the ""empty set"", but they are also different  (in the sense of std::is_same)."
cpp,3d46ns,mttd,6,Mon Jul 13 11:28:34 2015 UTC,"There was a question on SO the other day that was sort of along these lines.   He wanted to take one branch of an if if a struct contained a particular named member, and the other branch if it didn't."
cpp,3d46ns,OldWolf2,2,Mon Jul 13 13:59:37 2015 UTC,"I think it was this question here. Basically, they wanted to define a stringifiy function that would use to_string if available otherwise it would use string stream. The simplest solution is to just to do this:  FIT_STATIC_LAMBDA_FUNCTION(stringify) = fit::conditional(     [](auto x) FIT_RETURNS(to_string(x)),     [](auto x) FIT_RETURNS(static_cast<ostringstream&>(ostringstream() << x).str()) );   So you could apply the same thing for checking a member as well."
cpp,3d46ns,pfultz2,8,Mon Jul 13 18:16:12 2015 UTC,this is all you want except simple
cpp,3d46ns,chambolle,6,Mon Jul 13 19:12:31 2015 UTC,The simplest solution is to include an unheard of third party library as a dependency that defines multiple macros that make errors hard to debug?  No thanks.
cpp,3d46ns,sakarri,4,Mon Jul 13 18:43:12 2015 UTC,Amen. Some people are really eager to toss macros at things.
cpp,3d46ns,quicknir,5,Mon Jul 13 19:48:29 2015 UTC,"an unheard of third party library   Perhaps unheard of by you, but fit is a fairly well-known library."
cpp,3d46ns,sztomi,1 point,Tue Jul 14 11:43:04 2015 UTC,"The link you sent me only reaffirms that it's not a very well known or used library, at least not according to Github's rankings.  It's only two rankings more popular than ""Tetris as a C++ Template Metaprogram"" and other fairly obscure libraries as ranked by Github.  Unless metaprogramming Tetris has become fairly popular with the C++ crowd (and I submit this is definitely a possibility), then I think it's valid for me to point out to people who may not otherwise know better that Fit is not actually a widely used library.  Its casual suggestion as a simple solution to this problem is more a form of self promotion than a recommendation based on widely adopted and standard C++ practices."
cpp,3d46ns,sakarri,-2,Tue Jul 14 18:17:10 2015 UTC,OK
cpp,3d46ns,sztomi,1 point,Tue Jul 14 21:45:48 2015 UTC,"that defines multiple macros that make errors hard to debug?   How does it make it hard to debug? FIT_RETURNS is simply defined as this:  #define FIT_RETURNS(...) -> decltype(__VA_ARGS__) { return (__VA_ARGS__); }   If you want to make it more explicit you could write it like this:  FIT_STATIC_LAMBDA_FUNCTION(stringify) = fit::conditional(     [](auto x) -> decltype(to_string(x))     {         return to_string(x);     },     [](auto x) -> decltype(static_cast<ostringstream&>(ostringstream() << x).str())     {         return static_cast<ostringstream&>(ostringstream() << x).str();     } );   It makes more explicit that the expression will constrain the function for those who are unfamiliar with the FIT_RETURNS macro(of course a RETURNS like macro is quite common among many C++11/14 libraries). However, debugability is the same. Its one line of code, and the macro doesn't change that."
cpp,3d46ns,pfultz2,4,Mon Jul 13 20:55:28 2015 UTC,That's a lot of code for something that can be done very easily with tag dispatch.
cpp,3d46ns,tasty_crayon,5,Mon Jul 13 14:19:21 2015 UTC,"As soon as I got to the point in the article where he said that there are two ways to do this, I thought the same thing. I definitely wouldn't use SFINAE; I use tagged dispatch over SFINAE in situations where you have a choice."
cpp,3d46ns,quicknir,2,Mon Jul 13 19:55:06 2015 UTC,"Could you explain why? /u/tasty_crayon's tag dispatch example seems to be more confusing that SFINAE/specialization for me, at least in this case. What if you need to add C arrays? etc..."
cpp,3d46ns,cleroth,11,Tue Jul 14 01:08:01 2015 UTC,"Tag dispatch is what we use within the STL. It's simpler because it conceals the dispatch from the user, who sees only one public signature. It's easy to create multi-way switches - just add additional tags, and think a little about ensuring that the overload resolution is unambiguous. SFINAE is a more complicated way to achieve the same effect, since you have to make each overload appear exactly when it's needed. In particular, tag dispatch centralizes the mention of the properties you're interested in, while SFINAE will typically need to have each overload repeat them (is_array versus !is_array)."
cpp,3d46ns,STL,3,Tue Jul 14 01:48:58 2015 UTC,"Everything STL said. To give an example when you'd use enable if: if you want a generic function to take primitive types by value, but user defined types by reference. In this situation, clearly tag dispatch cannot help you, because you have to change to signature of the function itself depending on the type. In almost all situations though I'd take tag dispatch over sfinae."
cpp,3d46ns,quicknir,3,Tue Jul 14 02:21:08 2015 UTC,coud you please elaborate?  thanks
cpp,3d46ns,chambolle,6,Mon Jul 13 19:11:17 2015 UTC,"Here is an example:  template<typename T> void decrement_kindof_impl(std::true_type, T& value) {     value.pop_back(); }  template<typename T> void decrement_kindof_impl(std::false_type, T& value) {     --value; }  template<typename T> void decrement_kindof(T& value) {     (decrement_kindof_impl)(std::is_same<std::string, T>{}, value); }"
cpp,3d46ns,tasty_crayon,3,Mon Jul 13 19:58:04 2015 UTC,"The key point to note in tasty_crayons' example is that the function call to the implementation is statically resolved via overloading, because the two implementations have different signatures. Because it's statically resolved, the compiler never tries to compile code with the wrong implementation."
cpp,3d46ns,quicknir,2,Mon Jul 13 20:04:02 2015 UTC,"The typical example of tag dispatching can be found in the standard library: std::distance based on the iterator_category (did you even wonder why they formed an inheritance hierarchy?):  template <typename It> auto distance(It begin, It end) {     typedef typename std::iterator_traits<It>::iterator_category Cat;     Cat cat;     return distance_impl(begin, end, cat); }   And then one implements on distance_impl for each of the category for which its makes sense:   forward_iterator_category, the base implementation in O(N) bidirectional_iterator_category, the implementation that works in both directions (still O(N)) random_iterator_category, the efficient implementation in O(1)   It's a pretty useful strategy, I remember using it for json encoding/decoding. kind(T) gives its tag (to be provided by the user, already provided for STL containers) and from then on you know whether it's to be treated as an object, list, string, ..."
cpp,3d46ns,matthieum,3,Tue Jul 14 15:28:13 2015 UTC,"Yes and no. It's library code, so if you use it several times, you'll actually have less code in total than several dispatch or even SFINAE (with takes less code than tag dispatch)."
cpp,3d46ns,wichtounet,2,Tue Jul 14 07:24:26 2015 UTC,"So, all that drama about bringing static_if into C++, and it is solved by 20 lines of code?"
cpp,3d46ns,CenterOfMultiverse,7,Mon Jul 13 17:43:37 2015 UTC,"It's 20 pretty ugly lines of code, to the point where many people (myself included) would probably just stick with tag dispatch. As Plorkyeran notes, this also doesn't cover conditional member variables.  It's not really about the number of lines of code, it's about not needing to do things that feel like hacks. Metaprogramming in c++ is cool, and it's an important part of the language. However, all too often, things that feel very simple end up being hard to do. What's wrong with making these things easier?  Edit: on the flip side, it's possible that introducing it to the language, as things stand, wouldn't work well. In depth discussion here: https://isocpp.org/files/papers/n3613.pdf. The conclusion seems to be (sadly) that static_if is not a good fit for a c++. This is a bit unfortunate, because I'm pretty sure my ideal language would have that feature."
cpp,3d46ns,quicknir,11,Mon Jul 13 20:25:00 2015 UTC,"That paper seems to have been getting a lot of links lately. But it seems like few people are actually reading it.  I think it's important to realize that this paper is about two specific proposals for ""static if"" for C++ (n3322 and n3329). There are a number of potential ways for that feature to negatively impact the language, and none of them were discussed in those papers. Hence n3613.   The most recent proposal for ""static if"" (n4461) seems reasonable."
cpp,3d46ns,andrewsutton,2,Tue Jul 14 02:27:30 2015 UTC,"That's a phenomenal comment, thanks, I'll be sure to look into what you cited."
cpp,3d46ns,quicknir,4,Tue Jul 14 03:04:40 2015 UTC,"Yep, which is why I agree it would be a bad idea to introduce static_if to C++.  The better solution is to introduce more principled features like polymorphic lambdas and concepts and then use those principled features to create your own variant of static_if."
cpp,3d46ns,sakarri,3,Mon Jul 13 18:00:54 2015 UTC,And then proggit will tell you it doesn't count because it's not in the standard.
cpp,3d46ns,Jurily,2,Mon Jul 13 20:10:41 2015 UTC,static_if is a very simple solution. However some people prefer obscur and complex code nowadays. I am sad. What's wrong with static_if? I guess this is the imperative coding style that some people hate so much... (but without it C++ will be not use in the real world like Haskell and functionnal stuff)
cpp,3d46ns,chambolle,2,Mon Jul 13 19:14:15 2015 UTC,"This doesn't support most of the more interesting applications of static_if, such as conditionally-existing member variables."
cpp,3d46ns,Plorkyeran,3,Mon Jul 13 18:39:54 2015 UTC,What kind of code are people writing that requires this. I feel like I'm working in a different language sometimes
cpp,3d46ns,BenjaminSisko,1 point,Tue Jul 14 04:56:34 2015 UTC,"As said by the other comments, it is only resolving a part of the static if features. Moreover, the user code is not as nice as static if should be if it was a language feature."
cpp,3d46ns,wichtounet,1 point,Tue Jul 14 07:23:27 2015 UTC,Can this static_if function be made constexpr in C++14?
cpp,3d46ns,gnzlbg,2,Mon Jul 13 23:02:47 2015 UTC,"Yes, it can."
cpp,3d46ns,wichtounet,1 point,Tue Jul 14 07:29:51 2015 UTC,"How? AFAIK lambdas cannot be constexpr right?  EDIT: I made this work by replacing the lambdas with constexpr function objects:  http://coliru.stacked-crooked.com/a/63f154fc7456b83e  But for binary conditions I just don't see the advantage of this over just tag dispatch on std::true_type and std::false_type:  http://coliru.stacked-crooked.com/a/869f49003af2824b  It is simpler, and cuts the lines of code by half."
cpp,3d46ns,gnzlbg,1 point,Tue Jul 14 11:27:15 2015 UTC,It's not as though we didn't have static_if equivalents in C++98.
cpp,3d46ns,AceyJuan,4,Tue Jul 14 04:04:24 2015 UTC,Like what ?
cpp,3d46ns,wichtounet,1 point,Tue Jul 14 07:29:33 2015 UTC,"I remember being faced a problem like this for a serialization framework several years ago. At the time, my project was specific to MS Visual Studio, so I used this compiler specific kludge in visual C++:  __if_exists(foo) {} or __if_not_exists(foo) {}  https://msdn.microsoft.com/en-us/library/x7wy9xh3.aspx  It wasnt ideal, but it was concise and good enough at the time. I realize that this does not fulfill your C++11/C++14 requirement, but I thought it was practical and relevant enough that someone might find it useful.  Edit: apparently __if_exists() is not recommended for new code. Here is an SO thread discussing how to do this using traits instead: http://stackoverflow.com/questions/3779466/is-there-an-equivalent-for-if-exists-in-gnu-c"
cpp,3d46ns,dgendreau,9,Mon Jul 13 20:48:21 2015 UTC,"__if_exists is an abomination, please don't use it. It's horrendously buggy, and supported only for back-compat with libraries that really should be fixed to use modern SFINAE."
cpp,3d46ns,STL,1 point,Tue Jul 14 01:45:22 2015 UTC,Fair enough. I just wish the available sfinae approaches weren't so complicated to use in practice. Can you recommend a concise example for object serialization?
cpp,3d46ns,dgendreau,2,Wed Jul 15 08:43:35 2015 UTC,"You can use void_t to detect the presence of nested types. However, it won't work for arbitrary expressions (including detecting the presence of member functions) in MSVC due to the lack of Expression SFINAE."
cpp,3d46ns,STL,0,Wed Jul 15 17:07:12 2015 UTC,"Actually, it could be written like this:  FIT_STATIC_LAMBDA_FUNCTION(decrement_kindof) = fit::conditional(     [](std::string& value) { value.pop_back(); },     [](auto& value) { --value; } );   There is no need to write the std::is_same predicate. Even further, if you wanted it to be generic to work with any type that has pop_back or decrement operator by taking advantage of SFINAE in C++(which is like a compile-time maybe monad built into the language), simple overloading will do:  template<typename T> auto decrement_kindof(T& value) -> decltype(value.pop_back(), void()) {     value.pop_back(); }  template<typename T> auto decrement_kindof(T& value) -> decltype(--value, void()) {     --value; }"
cpp,3d46ns,pfultz2,1 point,Mon Jul 13 18:27:00 2015 UTC,And what about complex conditions ? Like type is an instantiation of a specific template or that its value type is numeric ?
cpp,3d46ns,wichtounet,2,Tue Jul 14 07:26:54 2015 UTC,"Yes for more complex conditions, a predicate would be needed. However, the static_if shown is only limited to one condition and an else(ie there is no else_if). Trying to expand it to multiple conditions can get ugly unless you use dependent typing instead.  Another approach is not to chain the conditions, but rather pass them into a function which will chain them. This is the approach done with the Fit library. So, the example could be written like this:  template<typename T> void decrement_kindof(T& value) {     eval(conditional(         if_(std::is_same<std::string, T>())([&](auto id){             id(value).pop_back();         }),         [&](auto id){             --id(value);         }     )); }   And since the conditions are passed to fit::conditional, multiple conditions can be passed to it. For example, an additional check for a stack could be added(assuming there is an is_stack trait):  template<typename T> void decrement_kindof(T& value) {     eval(conditional(         if_(is_stack<T>())([&](auto id){             id(value).pop();         }),         if_(std::is_same<std::string, T>())([&](auto id){             id(value).pop_back();         }),         [&](auto id){             --id(value);         }     )); }"
cpp,3d46ns,pfultz2,-4,Thu Jul 16 15:17:20 2015 UTC,template metaprogramming: how to reinvent preprocessor macros with a lot more compiler involvement and a completely new level of fucked up.
cpp,3d46ns,esbio,3,Mon Jul 13 22:53:45 2015 UTC,Unlike preprocessor macros templates are Turing-complete
cpp,3d46ns,RubiksCoffeeCup,2,Tue Jul 14 11:10:50 2015 UTC,"and so what? just a ""while"" with assignment is Turing complete You know, just need a rubon!   I agree with esbio"
cpp,3d46ns,chambolle,4,Wed Jul 15 15:20:35 2015 UTC,"/u/esbio's statement is simply silly. Preprocessor macros are text replacement, template metaprogramming is actual programming. I just took the most concise thing preprocessor macros can't do, but templates can, to illustrate that it is silly. Of all the things I do with templates, maybe 5% could be done with the preprocessor."
cpp,3d46ns,RubiksCoffeeCup,1 point,Wed Jul 15 16:35:27 2015 UTC,"I don't think so. 5% is very low. For instance, define a generic file (yes a file) containing the code of a class with T as Template parameter and then define in the intiial source code the value of T and include the file for replacement. In that way, and by playing with #if you may be able to growth to at least 95%."
cpp,3d46ns,chambolle,1 point,Thu Jul 16 07:42:32 2015 UTC,"I don't think so. 5% is very low. For instance, define a generic file (yes a file) containing the code of a class with T as Template parameter and then define in the intiial source code the value of T and include the file for replacement. In that way, and by playing with #if you may be able to growth to at least 95%.   That isn't what a template does. Not even close."
cpp,3d46ns,RubiksCoffeeCup,1 point,Thu Jul 16 10:02:48 2015 UTC,This is what Template does in 95% of cases. The remaining 5% are mainly kind of hack that can be easily simulated with few lines of codes (more readable most of the time :-) )
cpp,3d46ns,chambolle,1 point,Fri Jul 17 22:42:29 2015 UTC,Something is funny: people are doing again with Template programming the style of code they hated so much with MACROs and that was reasonable to hate: A code containing 50% a macros. With Template programming I think that some people are close to 99% !!!
cpp,3d46ns,chambolle,1 point,Thu Jul 16 07:51:24 2015 UTC,"I am not silly at all. Some of the things that now are done with templates were done in the past with preprocessor macros. The main problems of preprocessor macros are lack of typing information and general obscurity, due to the fact that what the programmer sees is not what the compiler sees. Templates, among many other things, provide type checking for behaviors previously carried by macros, but still make what the compiler sees vs what the programmer sees a nightmare. C++ has become two languages into one, with two different programming paradigms. The result is a language so complex that does not blow up the leg. It blows up an entire country."
cpp,3d46ns,esbio,4,Wed Jul 15 16:54:27 2015 UTC,"The silly thing is comparing templates to preprocessor macros in the first place. They are completely different things, and while in your experience the things done with templates used to be done with preprocessor macros, my experience is the opposite. The things I do with templates now weren't done at all in the past. I work in an old code-base that we are slowly modernising (it's a small shop and we can't just rework everything for 2 years, so instead we rework the stuff that's being updated). I'm the template guy. We usually reduce the amount of code and oblique preprocessor macros by about 50%, and the new code is type-safe, clear (if templates aren't confusing for you in the first place), and better optimised via partial and full specialisations. We still use the preprocessor, I'm not saying it is shit. But both theoretically and from my experience, templates are not comparable at all to preprocessor macros   C++ has become two languages into one, with two different programming paradigms   C++ always was a multi-paradigm language, but yes. Templates are a meta-language.    The result is a language so complex that does not blow up the leg. It blows up an entire country.    I don't have a problem with the complexity of C++. I prefer it to the joy of debugging reams of void pointers and chasing preprocessor indirection."
cpp,3d46ns,RubiksCoffeeCup,1 point,Wed Jul 15 17:01:11 2015 UTC,"(if templates aren't confusing for you in the first place)   Problem is that they are often confusing for the compiler as well (see "". template"" disambiguations)   C++ has become two languages into one, with two different programming paradigms C++ always was a multi-paradigm language, but yes. Templates are a meta-language.   That's called overengineering.   The result is a language so complex that does not blow up the leg. It blows up an entire country. I don't have a problem with the complexity of C++.   You may have not, but the harder a language is to understand, the more expensive and rare are the programmers. I've seen plenty of code made impossible to maintain through clever tricks. I've also seen plenty of code that has these tricks mess up this or that compiler that you really need to use in order to release for this customer.   I prefer it to the joy of debugging reams of void pointers and chasing preprocessor indirection.   As opposed to templates bubbling up your class hierarchy until you have classes templated on classes that are templated?  Or what about the completely unreadable compiler error messages?  Or the fact that the templating used is so smart that solves half the problem in constexpr and clever metaprogramming so that you can't see the logic because it is not here or there, but spread around both the imperative and the functional approach?  C++ templates are at the peak of the hype curve. Kind of like XML in the 2000s. Then, suddenly a whistle is heard and everybody realizes ""wait, this thing is bullcrap"", and the final conscious, practical people will take what's needed (traits, simple forms of generic programming) and leave the rest to the inglorious death by overdesign it rightfully deserves."
cpp,3d46ns,esbio,1 point,Wed Jul 15 22:20:29 2015 UTC,As I said. A completely new level of fucked up
cpp,3d5384,meetingcpp,1 point,Mon Jul 13 16:20:33 2015 UTC,Does this - http://rosettacode.org/wiki/Man_or_boy_test#Haskell - translate well?
cpp,3d5384,leobru,1 point,Tue Jul 14 06:58:42 2015 UTC,Of course not. It is effectful code (as opposed to pure).
cpp,3d5384,gergoerdi,1 point,Tue Jul 14 08:10:28 2015 UTC,"Well, each instantiation of a templated class has a side effect in the compiler's  data structures. I hoped it could have been used in a clever way. If not, I wonder, what could be the minimum change in the language to allow this kind of effectful metaprogramming."
cpp,3d5384,leobru,1 point,Wed Jul 15 05:40:04 2015 UTC,"You could rewrite that code to use State instead of IO/ST, and then compile that (since at that point it is, ultimately, just function composition)."
cpp,3d5384,gergoerdi,2,Wed Jul 15 06:07:29 2015 UTC,"Here's a rewrite of the ""man vs boy"" example using a State monad with many variables of the same type. This should be compilable with something like MetaFun (except for the fact that MetaFun doesn't yet support typeclasses or do notation so you'll need some specialized version of >>= etc):  import Control.Monad.State  type ManyState s = State [s]  newtype Var s = Var{ zipper :: [s] -> ([s], [s]) }  newVar :: s -> ManyState s (Var s) newVar x = do     n <- gets length     modify (++ [x])     return $ Var $ splitAt n  readVar :: Var s -> ManyState s s readVar v = do     (_, x:_) <- gets (zipper v)     return x  modifyVar :: Var s -> (s -> s) -> ManyState s () modifyVar v f = modify $ \vs ->      let (xs, y:zs) = zipper v vs      in xs ++ [f y] ++ zs  a k x1 x2 x3 x4 x5 = do     r <- newVar k     let b = do             k <- pred !r             a k b x1 x2 x3 x4     if k <= 0 then liftM2 (+) x4 x5 else b   where     f !r = modifyVar r f >> readVar r  main = print $ flip evalState [] $ a 10 #1 #(-1) #(-1) #1 #0   where     (#) f = f . return"
cpp,3d5384,gergoerdi,1 point,Wed Jul 15 06:27:59 2015 UTC,"Thank you, it works, but I'm afraid my Haskell proficiency is too low to do the required modifications."
cpp,3d5384,leobru,1 point,Wed Jul 15 07:21:37 2015 UTC,"Purely functional means that all structures are immutable and functions have no side-effects.   I don't think you need immutable structures for purity, it's just one of the easiest ways to get it.  Very cool post, though. Haskell's a great language, and functional purity should be taught with the same weight as OOP."
cpp,3d5384,staticassert,1 point,Tue Jul 14 19:54:52 2015 UTC,"When I last tried programming in Haskell, I had the exact same feeling that I do when I do C++ template metaprogramming. These two, seemingly vastly different languages, are extremely similar, and it looks like this article points it out it in a nice way."
cpp,3d5384,Sunius,1 point,Wed Jul 15 05:08:55 2015 UTC,I've been spamming all subreddits where this has been posted: you don't even need to do the translation by hand. Check out MetaFun for a Haskell(-like) to C++ templates compiler.
cpp,3d1vjq,antoninj,88,Sun Jul 12 21:12:29 2015 UTC,"Welcome to the big leagues, where there are approximately 74 different build systems and a patchwork framework of 28 various package managers, most of which only support a certain platform/environment and are useless outside of it."
cpp,3d1vjq,Rhomboid,67,Sun Jul 12 22:52:49 2015 UTC,"Yup.  Nothin' to protect ya out here except yer text editor and yer wits.  Edit: Thanks fer the gold, kind stranger.  Now you best watch that claim of yours. ::tips stetson::"
cpp,3d1vjq,ericanderton,10,Sun Jul 12 23:10:36 2015 UTC,"It took this long for me to realise the hypocrisy of me laughing at the amount of javascript frameworks there are, when I work with C and C++ all the time."
cpp,3d1vjq,Pronouns,6,Mon Jul 13 08:30:55 2015 UTC,Sounds about right.   Some projects have their own dependency management system. The rest assume that you have everything installed and configured just like on the main dev't computer.
cpp,3d1vjq,ThisIs_MyName,42,Mon Jul 13 01:50:34 2015 UTC,"Currently, there is no universal way to manage dependencies in C++. The latest attempt on this topic is BiiCode. In Linux, MacOS and other Unix-likes you can use the system-wide package manager. git submodule is sometimes used to reference the dependencies, especially hosted on github."
cpp,3d1vjq,encyclopedist,4,Sun Jul 12 21:35:51 2015 UTC,The latest attempt on this topic is BiiCode   Do you have to pay to run your own BiiCode server? It seems to be open source but the website doesn't list its capabilities.
cpp,3d1vjq,ThisIs_MyName,4,Mon Jul 13 01:52:37 2015 UTC,"The server code isn't  open source, you have to pay to have a private server on Biicode's hosting"
cpp,3d1vjq,blackibiza,3,Mon Jul 13 06:07:27 2015 UTC,"Ah well that sucks. If the server was OSS, I would have started using it immediately."
cpp,3d1vjq,ThisIs_MyName,4,Mon Jul 13 06:30:06 2015 UTC,"Meson's wrapdb system is fully OSS, the source code is here. It has fewer packages available ATM, though."
cpp,3d1vjq,jpakkane,3,Mon Jul 13 08:08:16 2015 UTC,"It's open source, though the web parts are not published yet."
cpp,3d1vjq,btapi,2,Mon Jul 13 08:41:50 2015 UTC,"As long as you share your code, you will enjoy all the functionality and benefits of biicode totally free. However, if you prefer to keep your code private and only accessible to you and your collaborators, you’ll have to upgrade to a premium account.   Dunno which bots are upping the post about that builder."
cpp,3d1vjq,devel_watcher,1 point,Mon Jul 13 12:02:28 2015 UTC,"No bots, it's just that all the other responses here rub salt in the wounds and this one gave me hope.   Too bad BiiCode is completely useless."
cpp,3d1vjq,ThisIs_MyName,42,Mon Jul 13 20:09:23 2015 UTC,HA HA HA HA
cpp,3d1vjq,Porges,14,Mon Jul 13 09:39:09 2015 UTC,"At first, I thought this was a terrible comment but after reading through all the other comments, I understand and this should be higher than it is."
cpp,3d1vjq,heap42,9,Mon Jul 13 16:06:40 2015 UTC,HA Ha ha hahaPlease help
cpp,3d1vjq,grumbel,17,Tue Jul 14 18:00:11 2015 UTC,"If Linux distributions commonly ship a package, I document the dependency in the README and require the user to install it. If Linux distributions don't commonly ship a package or when I require a newer version I include the package directly source tree in a directory named external/ (as git submodule if possible) and build it along with the rest.  On MacOS and Windows it's more chaotic, sometimes you can document a few Fink/Brew/MacPorts commands to ease the install, but it's generally much more fiddly then Linux."
cpp,3d1vjq,steamruler,24,Mon Jul 13 02:02:53 2015 UTC,"Linux:   Install package with package manager compile   Windows:   find source code get a bazillion errors because your environment differs from the maintainers find precompiled binary figure out whether to put it in lib/, x86_64-mingw-idunno/lib/, etc. figure out whether to put the header in include/, usr/include, x86_64-mingw... give up at put it everywhere realize you downloaded a 32-bit dll for your 64-bit build repeat twice because the link was copy pasted and you got the same thing compile   Salty? No..."
cpp,3d1vjq,DoListening,3,Mon Jul 13 11:59:55 2015 UTC,"With msys2, if the library is in their repository (quite a few are) you just do a pacman -S library and you're done."
cpp,3d1vjq,0x6c6f6c,3,Mon Jul 13 12:06:25 2015 UTC,One of the greatest things about GNU/Linux systems.   The Package Manager
cpp,3d1vjq,DoListening,6,Mon Jul 13 15:55:59 2015 UTC,"Sure, if you can get past the ancient versions of many things, often with a bunch of weird patches applied..."
cpp,3d1vjq,rybxjfpq,1 point,Mon Jul 13 18:57:54 2015 UTC,Not sure why you are getting downvoted. Its completely true especially with the commercial/old distros. Commercial linux/unix work is a pain in the ass since we can't just tell our clients to recompile their kernel or update.
cpp,3d1vjq,MsEtheldreda,1 point,Mon Jul 13 19:24:29 2015 UTC,"… and as long as you aren't an upstream who is effectively forced by distribution vendors to support their patches because they don't label the versions as modified.  We complained to Debian about their fucking up of our software and told them that unless they want to ship an unmodified version they have to support it. Their response was basically ""but 9001 other vendors support our shitfest, you should too!""."
cpp,3d1vjq,josefx,7,Tue Jul 14 00:19:41 2015 UTC,"My experience in some cases:  Linux:   find out your distro of choice last updated the package during the cold war ( or earlier ) find current source code find the source code for all dependencies, since there are no pre-compiled binaries for your distro of choice. install autoconf, cmake, scons, etc. until you have   all available build systems set the paths and compile all dependencies repeat 5 until you have all flags right compile   Windows:   find source use visual studio 2.1 do not use mingw get all precompiled dependencies for your VS version 3.1 in case you are unable to use Google compile them using     the included VS solution file. 3.2 in case 3.1 does not apply assume that the library is inherently useless and stop.  compile done"
cpp,3d1vjq,doom_Oo7,4,Mon Jul 13 16:31:35 2015 UTC,find out your distro of choice last updated the package during the cold war ( or earlier )   Or use arch as a dev reference.
cpp,3d1vjq,sbabbi,3,Mon Jul 13 19:02:36 2015 UTC,"^   install autoconf, cmake, scons, etc. until you have all available build systems   Oh, apt-get install autoconf cmake is so hard."
cpp,3d1vjq,predatorian3,2,Tue Jul 14 11:29:18 2015 UTC,Too damn true.
cpp,3d1vjq,rybxjfpq,2,Mon Jul 13 14:05:04 2015 UTC,Your steps are correct if you target only one Linux distro. If you target more than one good luck getting the same version of a package on all of them. Often easier and more maintainable to use submodules or just archive the source to your network.
cpp,3d1vjq,jpakkane,10,Mon Jul 13 19:23:19 2015 UTC,"The Meson build system has a dependency system called Wrap (documentation here, web download service here). It's quite new so the list of packages is still modest but it's growing.  The main difference between other dependency systems is that Meson and Wrap are designed to work together with distro packages. This allows you to use distro packages whenever they are available and embed dependencies when that is not the case."
cpp,3d1vjq,fritzroid,10,Sun Jul 12 21:50:46 2015 UTC,I guess this question will be more relevant once C++ comes with modules. But it seems they wont be in (C++17) just yet.
cpp,3d1vjq,o11c,27,Mon Jul 13 04:52:44 2015 UTC,"You use your distro's package manager, and you use pkg-config to discover the flags you need."
cpp,3d1vjq,devel_watcher,6,Sun Jul 12 21:22:46 2015 UTC,"Yes, distro's package manager: there are usually separate packages with libs for normal use and headers for development. CMake's find_package should find them if they are installed (in some cases it uses pkg-config internally)."
cpp,3d1vjq,assassinii,12,Sun Jul 12 22:48:59 2015 UTC,"You're pretty much out of luck on Windows though. I think NuGet supports C++ packages now, but that's only relevant if you're using Visual Studio and the libraries you're using are available as packages there."
cpp,3d1vjq,o11c,9,Sun Jul 12 21:34:31 2015 UTC,Cygwin and mingw both have package managers.
cpp,3d1vjq,assassinii,2,Sun Jul 12 21:48:30 2015 UTC,The MinGW package manager has a very limited selection of packages. I just checked and it only offers a handful of libraries.
cpp,3d1vjq,c0bra51,5,Mon Jul 13 08:50:37 2015 UTC,MinGW.  Minimalist Gnu for Windows.  What about Cygwin?
cpp,3d1vjq,steamruler,2,Mon Jul 13 11:42:02 2015 UTC,"Cygwin has a higher performance penalty, and the license of the runtime itself requires you to release your code as GPLv2 (or higher)."
cpp,3d1vjq,Rhomboid,2,Mon Jul 13 11:52:43 2015 UTC,"the license of the runtime itself requires you to release your code as GPLv2 (or higher).   No it does not.  The Cygwin license is the GPLv3+ with an exception clause that allows it to be linked with any OSI-approved license.  As long as your project is open source, Cygwin imposes no licensing requirements whatsoever.  (If you distribute cygwin1.dll you're still obligated to provide source for it, but unless you modified it that's not really an issue.)"
cpp,3d1vjq,DoListening,3,Mon Jul 13 15:51:38 2015 UTC,"There is also msys2, which handles both the installation of mingw and other tools, and has a bunch of 3rd party libraries available."
cpp,3d1vjq,doom_Oo7,1 point,Mon Jul 13 11:15:20 2015 UTC,chocolatey ?
cpp,3d1vjq,assassinii,2,Mon Jul 13 08:44:05 2015 UTC,"As far as I'm aware, Chocolatey only has applications as packages – not libraries."
cpp,3d1vjq,doom_Oo7,1 point,Mon Jul 13 08:45:59 2015 UTC,"There are some, like GLFW, OpenCV..."
cpp,3d1vjq,MsEtheldreda,10,Mon Jul 13 08:53:09 2015 UTC,You're probably going to be better off using CMake's find_package rather than pkg-config as pkg-config does not work very well with Windows.
cpp,3d1vjq,steamruler,1 point,Sun Jul 12 21:58:06 2015 UTC,"Yeah, find_package uses pkg-config if it can't find it, afaik"
cpp,3d1vjq,o11c,-2,Mon Jul 13 11:51:49 2015 UTC,"That's usually a small matter of making sure the .pc file is installed.  CMake has all sorts of blatantly incorrect behavior, and when I filed bug reports (some with patches), they actively refused to fix them."
cpp,3d1vjq,Teemperor,10,Mon Jul 13 00:53:34 2015 UTC,"CMake has all sorts of blatantly incorrect behavior, and when I filed bug reports (some with patches), they actively refused to fix them.   [Citation needed]"
cpp,3d1vjq,MsEtheldreda,6,Mon Jul 13 08:04:21 2015 UTC,I have yet to see a project ship pkg-config files which work on Windows.
cpp,3d1vjq,jevinskie,3,Mon Jul 13 00:59:59 2015 UTC,My experience with bug reports to CMake has been the opposite. Maintainers were responsive and polite. Brad King has even gone around to several large CMake-based projects (LLVM/Clang was one) and asked them how the CMake team could improve cmake to better support the projects.
cpp,3d1vjq,dafugg,0,Mon Jul 13 16:28:02 2015 UTC,"Not if you want your project to ""just work"" in open embedded."
cpp,3d1vjq,doom_Oo7,6,Mon Jul 13 07:48:18 2015 UTC,Why ? CMake can even piggyback on pkgconfig if available.
cpp,3d1vjq,wrosecrans,1 point,Mon Jul 13 08:44:36 2015 UTC,"This was basically my response as well.  I don't really like having every language force me to learn a new set of tooling when I already have a perfectly useful package manager.  On OS-X, I have brew and such, but it's still global even if it is 3rd party.  I dunno why there's no equivalent of brew on Windows.  Porting to Windows always seems to just involve a bunch of hard coded papths in my build config, and downloading a bunch of libraries by hand.  But aside from Windows, the whole rest of the non-embedded world usually works just fine."
cpp,3d1vjq,o11c,7,Mon Jul 13 05:23:34 2015 UTC,Tbh if I had to do anything windows-based I would cross-build from Linux.
cpp,3d1vjq,doom_Oo7,1 point,Mon Jul 13 06:11:39 2015 UTC,there's no equivalent of brew on Windows   there's chocolatey
cpp,3d1vjq,steamruler,1 point,Mon Jul 13 08:45:24 2015 UTC,and soon that thing integrated into powershell
cpp,3d1vjq,maleic,2,Mon Jul 13 11:53:19 2015 UTC,oneget  which is a set/subset/superset/none-of-the-above of chocolatey and nuget.
cpp,3d1vjq,josefx,2,Mon Jul 13 13:22:46 2015 UTC,"You use your distro's package manager   Only support for one distro? Great for you, the pain of supporting multiple distro's and multiple versions of them is very real for me. It ends up being less work to manage all my dependencies myself and bundle them.   Edit: Thanks for all the downvotes, please give hints how I can:   Have a single dependency tree for every Distro a customer might want, or a simple way to support every single Distro in existence. Test my software against all versions and combinations of libpng,libzip,libdevill,libc,libtiff,Qt,OSG,tinyxml,boost, ffmpeg, cmake, etc. without going crazy. Deal with customers complaining that their installations are isolated from the internet and installing hundreds of packages in a system wide fashion is just as prohibited.    Since someone mentioned security: Not every software is internet facing or has root privileges, no need to deal with packaging here."
cpp,3d1vjq,o11c,8,Mon Jul 13 06:43:53 2015 UTC,"As someone who has had to build projects with bundled dependencies, I hate you."
cpp,3d1vjq,ChallengingJamJars,1 point,Mon Jul 13 06:49:17 2015 UTC,"Really? Why's that?  Personally, I've found that bundled dependencies are much easier. I'm often running things on a system I don't have admin for, so every dependency requires me to build it myself (don't even have chroot permissions). Secondly it's a pain when the distro's version is incompatible with the program."
cpp,3d1vjq,steamruler,2,Mon Jul 13 08:38:08 2015 UTC,"Because it requires you to bundle binaries all the way up to libc. Not to mention when major events happen like when the default ABI for C++ changes, things start to break.  Don't even get me started on security updates."
cpp,3d1vjq,ChallengingJamJars,3,Mon Jul 13 11:55:33 2015 UTC,"I don't see how the ABI changing is an issue if you're building them all. The security is an issue if you're network facing yes.  My best example of library bundling dependencies is PETSc, which will download the latest OpenMPI, or BLAS or whatever package and build it when you build the library."
cpp,3d1vjq,josefx,0,Tue Jul 14 00:19:43 2015 UTC,"Different priorities, we mostly provide binaries and headers. For an open source project this might differ."
cpp,3d1vjq,Saboot,13,Mon Jul 13 07:51:11 2015 UTC,I've used CMake's ExternalProject_Add feature to some varying degrees of success.
cpp,3d1vjq,devel_watcher,5,Sun Jul 12 21:52:45 2015 UTC,ExternalProject_Add is for people who want to invent a per-package (?!) package manager using only CMake.
cpp,3d1vjq,gnzlbg,7,Sun Jul 12 22:52:31 2015 UTC,"Some projects include their own FindProject.cmake file (e.g. Boost.Hana, Eigen), this makes it a breeze to use.   If you have the right version of the project installed, then that version is used. Otherwise the right version is fetched from github into your build directory and compiled with your project.  It is worth noting that writing a FindPackage.cmake is a 5 liner and it works on all platforms."
cpp,3d1vjq,Elador,1 point,Mon Jul 13 07:31:16 2015 UTC,"I'm quite familiar with CMake, but in my opinion things are (sadly) not quite as easy as you describe them. So I would be very interested in knowing more what you mean and how this ""5 liner"" would look like. Also, to my knowledge, Eigen's FindProject.cmake doesn't do ""If you have the right version of the project installed, then that version is used. Otherwise the right version is fetched from github into your build directory and compiled with your project.""?"
cpp,3d1vjq,gnzlbg,2,Tue Jul 14 08:19:57 2015 UTC,"This is e.g. a pretty convoluted one for range-v3 since I just basically sed it with a different library name every time I need a new library and it has grown a bit over time (been doing this for 3-4 years):   https://github.com/gnzlbg/htree/blob/master/cmake/Findrange-v3.cmake  You can wrap this into a function that does:  fetch_pkg(range-v3 range-v3 https://github.com/ericniebler/range-v3.git GIT)  and I've done so in some projects. In that directory there is another one for cppformat. You will see that they are extremely similar.  As you point out, the FindEigen3.cmake file provided by Eigen3 doesn't do this, but I just call that one first, and if Eigen is not found, I just fetch the master branch from source using a very similar file (EDIT: found the file, see below). The ones I'm using right now just completely ignore the FindXXX.cmake from Eigen, since over the years I've moved on to always use the master/develop/tip-of-trunk branch of the libraries I use.   I'd rather have sporadic breakages as soon as someone screws up upstream, than fight against an upgrade 6 months or 1 year down the road when nobody remember which commit broke what and why.   This breaks my builds some times, but ExternalProject_Add let's me easily fetch a particular commit or change the repository to a different one. That is, I can (and often do) fork the project, fix the error, send a pull request, and switch my projects to my fork until the pull-request is accepted. For releases I just fix a particular commit of the libraries in the files (typically the last one at the time I'm doing a release).  EDIT: I just found mine from Eigen3:  # Find the Eigen3 include directory # The following variables are set if Eigen3 is found. #  Eigen3_FOUND        - True when the Eigen3 include directory is found. #  Eigen3_INCLUDE_DIR  - The path to where the Eigen3 include files are. # If Eigen3 is not found, Eigen3_FOUND is set to false.  find_package(PkgConfig)  if(NOT EXISTS ""${Eigen3_INCLUDE_DIR}"")   find_path(Eigen3_INCLUDE_DIR     NAMES Eigen     DOC ""Eigen3 library header files""     ) endif()  if(EXISTS ""${Eigen3_INCLUDE_DIR}"")   include(FindPackageHandleStandardArgs)   mark_as_advanced(Eigen3_INCLUDE_DIR) else()   include(ExternalProject)   ExternalProject_Add(Eigen3     HG_REPOSITORY https://bitbucket.org/eigen/eigen/     TIMEOUT 5     CMAKE_ARGS -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER} -DCMAKE_CXX_FLAGS=${CMAKE_CXX_FLAGS}     PREFIX ""${CMAKE_CURRENT_BINARY_DIR}""     CONFIGURE_COMMAND """" # Disable configure step     BUILD_COMMAND """" # Disable build step     INSTALL_COMMAND """" # Disable install step     UPDATE_COMMAND """" # Disable update step: clones the project only once     )    # Specify include dir   ExternalProject_Get_Property(Eigen3 source_dir)   set(Eigen3_INCLUDE_DIR ${source_dir}) endif()  if(EXISTS ""${Eigen3_INCLUDE_DIR}"")   set(Eigen3_FOUND 1) else()   set(Eigen3_FOUND 0) endif()   This one tries a bit harder to find an installed version of Eigen3 even if Eigens own FindEigen3.cmake file fails (which should be called before). If it cannot find it, it just fetches the master branch from the mercurial repo."
cpp,3d1vjq,Elador,1 point,Tue Jul 14 10:55:54 2015 UTC,Thank you very much for your reply and all the information! Cool!
cpp,3d1vjq,Saboot,2,Wed Jul 15 15:36:52 2015 UTC,"I can handle my dependencies pretty sufficiently by calling ExternalProject_Add without much magic as it was intended for.  I've seen it used for simple and pretty complex projects for handling dependencies without any extra ""package managers"". It's for building from source (and then linking) however."
cpp,3d1vjq,ojd5,4,Sun Jul 12 23:57:30 2015 UTC,"I've found Hunter to be very powerful and simple to use. It's built on cmake's external project add and has no other dependencies. Currently there are a limited number of packages available, but it has support for boost and other major libraries. It is also very simple to add new packages, which can be hosted privately if required.  A typical cmake file using hunter looks something like this  cmake_minimum_required (VERSION 3.2.0) HunterGate(     URL ""https://github.com/ruslo/hunter/archive/v0.7.0.tar.gz""     SHA1 ""e730118c7ec65126398f8d4f09daf9366791ede0"" )  project(demo VERSION 0.0.0 LANGUAGES C CXX)  hunter_add_package(Boost COMPONENTS test thread system filesystem program_options date_time) find_package(Boost COMPONENTS unit_test_framework thread system filesystem program_options date_time   REQUIRED)   add_library(foo foo.cpp) target_link_libraries(foo Boost::filesystem)   Disclaimer: I've contributed a few bug fixes and packages"
cpp,3d1vjq,gnzlbg,1 point,Mon Jul 13 09:33:09 2015 UTC,"It looks very interesting, does it support getting the master branch of e.g. github projects? I cannot find that in the docs."
cpp,3d1vjq,ojd5,1 point,Tue Jul 14 11:15:30 2015 UTC,"For a more definitive answer you might want to post a new question as an issue on the github project. That said, from my understanding Hunter only supports releases."
cpp,3d1vjq,ruslo_,1 point,Thu Jul 16 14:15:22 2015 UTC,Usually I do release with github (or fork/patch/release). But this feature planned anyway: 1 and 2
cpp,3d1vjq,doom_Oo7,5,Thu Jul 16 22:14:46 2015 UTC,"Something to keep in mind is that the average C++ project requires FAR LESS dependencies that the average Node / PHP / Ruby project. I don't see many projects linking to more than 10 different libs, or if it is the case, it's through a framework that makes it easy for you. But Qt, Boost, SDL covers most needs I think."
cpp,3d1vjq,jetxee,4,Mon Jul 13 08:48:31 2015 UTC,"That's probably the other way round. An average C++ project has less dependencies (really?), because there is no package manager. And that's not a good thing. That implies more monolithic code, more wheels reinvented, and less projects written in C++ that could have been written."
cpp,3d1vjq,doom_Oo7,1 point,Mon Jul 13 21:15:02 2015 UTC,"Certainly, but in the firrst place, if you're writing your project in C++, it's certainly because you want to get some speed, and if you want speed, you'll certainly end up (even if it may not be a good idea) writing code really tied to your domain/software and hence not easily useable elsewhere."
cpp,3d1vjq,jetxee,5,Mon Jul 13 22:33:23 2015 UTC,"Well, let's look at what are the most used packages in other languages. Top 360 for Python: http://pythonwheels.com/. Some of them are dev tools and compatibility layers, but we can also see   A lot of generic data format support (XML, JSON, ASN.1, YAML, thrift, protobuf ...) Common data representation (time, dates, images, rich text, some DSLs) Lots of encryption and compression-related stuff. Interoperation with remote services and databases over well defined APIs and protocols.   Most of these things are not domain-specific. Most of these things are useful to many C++ programmers too. And I don't want to rewrite them, especially if I want speed, or portability, or correctness. If there were a dependency manager for C++, I could have chosen C++ for many projects where I used Python, Clojure or Haskell. Lack of modules and common package repository or index is really holding back C++ (re)adoption.  And no, if I'm writing in C++, it doesn't imply I want speed. I may want energy efficiency.  I may want control, predictability or direct memory access. I may want to use that C or C++ library directly. I may want to stay platform-agnostic. But I still want to exchange data with the rest of the world: read and write all common data formats, generate efficient and language-agnostic data representations, communicate over network. Given right libs, C++ could be a nice high-level language. That should not be so difficult."
cpp,3d1vjq,Plorkyeran,1 point,Mon Jul 13 23:42:08 2015 UTC,I guess that's a good point. Those frameworks pretty much provide you with 90% of what you need.
cpp,3d1vjq,doom_Oo7,2,Mon Jul 13 16:07:27 2015 UTC,"They really don't, but dragging in extra deps is painful enough that it's often easier to just reinvent all the wheels that they don't provide."
cpp,3d1vjq,nuroo,1 point,Mon Jul 13 17:16:25 2015 UTC,What would be a need common enough to be of use to... let's say 10% of all software and not present in either of those ?
cpp,3d1vjq,thuvh,6,Mon Jul 13 17:36:24 2015 UTC,"Personally I use ExternalProject_Add for all dependencies and had no issues so far on any platform. I tried CPM and BiiCode at some point, but CPM seemed immature and had a lack of traction, while BiiCode didn't allow for dependencies (not hosted by their service)."
cpp,3d1vjq,steamruler,2,Sun Jul 12 22:04:55 2015 UTC,I think cmake or gnu build tools is what you need. Cmake maybe easier to use than gnu build tools.
cpp,3d1vjq,doom_Oo7,1 point,Mon Jul 13 04:50:22 2015 UTC,may be easier to use than gnu build tools
cpp,3d1vjq,grout_nasa,5,Mon Jul 13 12:01:12 2015 UTC,is
cpp,3d1vjq,jetxee,2,Mon Jul 13 19:05:37 2015 UTC,Why not Debian? </zoidberg>
cpp,3d1vjq,devel_watcher,1 point,Mon Jul 13 15:15:51 2015 UTC,And then we see projects which work only on Ubuntu 12.04... And nothing else.
cpp,3d1vjq,MotherOfTheShizznit,2,Mon Jul 13 21:17:31 2015 UTC,"Well, everyone else (like smug Gentoo or Arch users) will figure out."
cpp,3d1vjq,ampersandal2,2,Mon Jul 13 21:50:44 2015 UTC,"If you are absolutely, positively, unconditionally convinced that you project will only ever run on one OS, go ahead and use whatever facilities that OS affords you. If, on the other hand, you're project is cross-platform, check in pre-compiled libraries in your source tree under /thirdparty/[name]/[version/[platform].  Trust me on that one. Managing multiple package managers is not worth it.  It. Is. Not. Worth. It."
cpp,3d1vjq,FeastofFiction,2,Mon Jul 13 17:51:31 2015 UTC,I use ExternalProject_add and use PATCH_COMMAND to inject my own CMakeLists.txt. Writing a cmakelist for every dependency of every dependecy sucks but there is no real other way because other people are not reliable.
cpp,3d1vjq,Sqeaky,2,Mon Jul 13 18:03:52 2015 UTC,"I compile, structure the file layout and link all my dependencies manually.  However I work on a large long term (Years) project so spending a day doing this once in a while is not a big deal; especially once you get familiar with the dependencies.  I've also found that in C++ I tend to include fewer dependencies than I do with other languages.  In my main project I add one maybe once a year...  However, when I need to do some java work (unfortunately) I find I'm adding them all the time."
cpp,3d1vjq,ChallengingJamJars,2,Thu Jul 16 04:44:57 2015 UTC,"Because of the what C++ can do and the lack of limitations it places on developers making a general purpose package manager has not yet worked. The closest to success has been Linux package managers and to a lesser extent app stores.  Think about the fundamental problem of shipping an OS Kernel, the runtime for another language, systems initialization software or device drivers. Then add on the complexity of every other package and it should be obvious why this problem is so hard. Combine the politics of everyone wanting something different and it gets truly hairy.  A package manager requires certain things to be useful like a system and network stack. Much C/C++ is the system and network stack. Imagine the circular dependency hell if you needed to download something to get your network driver working. To insure a base system is installed every OS provides different facilities for insuring packages are installed and dependencies are met (some provide none at all, I am glowering at you windows).  This isn't an impossible problem to solve, just an improbable problem to solve."
cpp,3d1vjq,jrk-,2,Mon Jul 13 03:20:19 2015 UTC,"minor, minor point: insure->ensure."
cpp,3d1vjq,jpakkane,1 point,Mon Jul 13 08:40:01 2015 UTC,"I've thought about that topic before and as others said, there's already huge fragmentation. Ideally there would be something like Cabal for Haskell, but that would require a huge homogenization effort beforehand. Cabal is possible because there is a common repository for Haskell packages (Hackage) and a common way to compile Haskell software.  Unfortunately I don't see how this could happen for C++, because C++ is way more used and larger than Haskell and there was no generic way of building C++ packages from the beginning. Right now you'd have to convince hundreds of thousands, if not millions of people that your idea of a package management system is the right thing. And you'd still have some graybeards who wouldn't use it, just because.  Imho, the only way to achieve this is a standardization effort through the C++ ISO committee. Not sure how that works, but it's probably worth to get Herb Sutter on your side first. :)"
cpp,3d1vjq,RogerLeigh,2,Mon Jul 13 09:41:56 2015 UTC,The way this is done in the Meson project (github project here)is that you first create a build system that sandbox other projects so they look like a native part of your build. Then you generate a database where people can submit build definitions for upstream projects. There's also a cli tool to install them to your source tree. It also transparently uses system dependencies it they are available.  Caveat: I'm the project lead for the Meson project.
cpp,3d1vjq,predatorian3,1 point,Mon Jul 13 18:10:20 2015 UTC,"FreeBSD: ports/pkg Linux: package manager MacOS X: homebrew Windows: suffer and build everything by hand  If you're only building on Windows, you might be able to embed all your third-party dependencies and build the entire lot inside Visual Studio.  But this won't work if you want to build on Linux/BSD where such source embedding will fall foul of being suitable for inclusion in a distribution.  And it's also a pain to maintain.  What I do currently is use CMake, and for Windows I have an optional ""superbuild"" project which will download and build all the dependencies if not already available.  This can also be used on older Linux systems with outdated dependencies if desired.  This was a pain to set up, but without it supporting Windows would be incredibly more painful.  BSD/Linux/MacOS are still vastly easier to support, but this at least makes Windows less of a burden."
cpp,3d1vjq,devel_watcher,1 point,Mon Jul 13 13:29:54 2015 UTC,"I feel there should be one. I hope/wish someone who does this a lot would make a dependency manager, or library manager."
cpp,3d1vjq,predatorian3,1 point,Mon Jul 13 14:09:28 2015 UTC,"Coming from the world of Javascript where there's a dependency manager for everything (front-end packages, back-end packages, meteor-specific packages, package manager packages...?), it feels daunting even to step into C++ and figure out how the hell I can use any library whatsoever."
cpp,3d1vjq,devel_watcher,2,Mon Jul 13 16:08:29 2015 UTC,"Don't blame C++, blame Windows.  Btw, I wasn't too happy finding out that nodejs has its own package manager that works independently of the Debian package manager."
cpp,3d1vjq,predatorian3,1 point,Mon Jul 13 21:43:36 2015 UTC,"I'm not a NodeJS, or JavaScript dev, but they don't have anything like what RubyGems does where they ship Node packages as RPMs, or DEBs?"
cpp,3d1vjq,BinaryIdiot,1 point,Tue Jul 14 12:49:48 2015 UTC,"Thank you. That is what was needed (beside an actual web dev in the team):  fpm -s npm -t deb express   (maybe some troubles to get a global install, but I see the end)"
cpp,3d212b,meetingcpp,2,Sun Jul 12 21:57:29 2015 UTC,Qt is also known to have very well designed interfaces and APIs... /s
cpp,3d212b,sbabbi,2,Mon Jul 13 07:58:41 2015 UTC,"I think recommending pass by value for ""sink"" parameters without even mentioning the alternative is questionable. A common view (that I agree with) is that sink parameters should be expressed as rvalue references; after all, that's exactly what the standard library does: what is a move constructor if not a sink for its parameter?   Scott Meyer talks about this, with others mentioning more interesting advantages of pass by rvalue reference:http://scottmeyers.blogspot.com/2014/07/should-move-only-types-ever-be-passed.html?m=1."
cpp,3d212b,quicknir,8,Mon Jul 13 00:12:00 2015 UTC,"It's not actually a common view, it's a view that was put forth by Scott Meyers and Herb Sutter quickly chimed in to point out the flaws.  Sink parameters are best passed by value, it avoids any ambiguity, it also behaves much better when it comes to function overloading, and Scott Meyers argument about performance is also incorrect.  C++ compilers already perform copy and move elision so passing by value eliminates aliasing issues which enables further optimizations.  There is a so-called ""killer argument"" that was referenced as to why pass by value should be preferred over pass by r-value-reference and it's along the lines of:  void f1(std::unique_ptr<int>&& value);  void f2(std::unique_ptr<int> value);  auto x = std::make_unique<int>(5); f1(std::move(x));  auto y = std::make_unique<int>(10); f2(std::move(y));   f1's function signature does not actually indicate or enforce any sort of sink parameter.  After calling f1 there is no guarantee that x was actually moved, but there likely is an expectation thereof.  For example an exception may have be thrown that prevented x from being moved.  However with f2 there is an enforcement that the parameter is actually a sink parameter.  There is no option but for y to be moved into f2 regardless of whether an exception is thrown or not.  The type system guarantees it."
cpp,3d212b,sakarri,1 point,Mon Jul 13 00:28:04 2015 UTC,"How is this beneficial? The user shoudn't have any expectations whatsoever with regards to x or y after they cal std::move on them. Also, I'm a bit confused, you're writing as though moving out of x/y is a good thing. If the function fails at its purpose and throws, I'd rather at least have the data in the original scope. But anyhow its irrelevant, because you can't depend on that."
cpp,3d212b,quicknir,1 point,Mon Jul 13 00:49:14 2015 UTC,"How is this beneficial? The user shoudn't have any expectations whatsoever with regards to x or y after they cal std::move on them.   So there's two possibilities.  One possibility is that when someone does an std::move their expectation that an actual move occurs is satisfied, that's the position I take.  Your position that you express is that if someone performs an std::move then:   The user shoudn't have any expectations whatsoever with regards to x or y after they cal std::move on them   I am of the opinion that it is beneficial to have users expectations be statically enforced at compile time rather than the user left with no expectation whatsoever about what will happen."
cpp,3d212b,sakarri,1 point,Mon Jul 13 00:53:24 2015 UTC,"They know that a move has been performed from x/y, but a moved from object is just in some valid state, you don't know which. You still don't ""know"" anything about the object, you can't safely call any method with a pre-condition.  If the data that was originally in x/y is left in there after calling move and the function at no extra cost, you're no worse off than you were in the first place.  This is very, very far from a killer argument. Conditional copying, slicing, better performance are strong arguments. 2N multiplicity of overloads is a strong argument. This is a very weak argument."
cpp,3d212b,quicknir,1 point,Mon Jul 13 01:08:32 2015 UTC,"They know that a move has been performed from x/y, but a moved from object is just in some valid state, you don't know which.   First they only know a move took place with f2, they have no idea whether a move took place with f1.  Second many classes have ownership semantics and a move explicitly transfers that ownership.  For example moving a unique_ptr guarantees that the unique_ptr is reset (ie. is a nullptr).  The same is true for other move-only types such as std::unique_lock or std::fstream.  Moving it results in the original object no longer having any ownership over the resource.   If the data that was originally in x/y is left in there after calling move and the function at no extra cost, you're no worse off than you were in the first place.   Yes you are in a very bad shape if you expected a resource to have been moved and it turns out it wasn't moved at all.  Referring to my previous example of using move semantics to model ownership you could deadlock your code this way."
cpp,3d212b,sakarri,1 point,Mon Jul 13 01:12:12 2015 UTC,"This is at best an argument over move only types, in which you've made some interesting points, which I still don't think are particularly strong. It's very easy to turn this whole thing on its head: maybe these functions f1 and f2 need to do other things than just take ownership of a unique_ptr. If these other things fail and f1/f2 throws, then when you passed by value you have lost the object completely. In essence, you are trading a very small amount of compiler enforcement of a safety edge condition for expressiveness.  But this was not the original topic of conversation, it was sink parameters in the context of types like vector. These types don't make any guarantees on the moved from state at all, so this argument isn't meaningful. If you look at all the other arguments Sutter makes, it's a pretty convincing case against pass by value in most situations."
cpp,3d212b,quicknir,1 point,Mon Jul 13 01:23:27 2015 UTC,"If you have a mutex held by a unique_lock and pass it by value to some function, you have no idea of when, if ever, it will be unlocked. I'm not sure what benefit you gain here compared to rvalue refs."
cpp,3d212b,detrinoh,2,Mon Jul 13 17:53:52 2015 UTC,"If you have a mutex held by a unique_lock and pass it by value to some function, you have no idea of when, if ever, it will be unlocked.   Nor should you care, once you've handed over ownership you absolve yourself of the responsibility of managing that lock.  That responsibility now belongs to the receiving function.   I'm not sure what benefit you gain here compared to rvalue refs.   The benefit is the guarantee that the unique_lock you passed to the function no longer owns the lock, a guarantee that does not exist if you pass by rvalue reference."
cpp,3d212b,sakarri,1 point,Mon Jul 13 17:57:56 2015 UTC,"Nor should you care, once you've handed over ownership you absolve yourself of the responsibility of managing that lock. That responsibility now belongs to the receiving function.   Why is this any different with passing an rvalue? Why should I care if the function never takes ownership?   The benefit is the guarantee that the unique_lock you passed to the function no longer owns the lock, a guarantee that does not exist if you pass by rvalue reference.   In practical terms, why does it matter, when I pass an rvalue to a function, I don't care about the value any more."
cpp,3d212b,detrinoh,2,Mon Jul 13 18:16:22 2015 UTC,"The practical value is one method enforces a guarantee that the object will be moved, and the other method leaves it to convention.  When possible I like to leverage the type system to enforce my pre-conditions."
cpp,3d212b,sakarri,1 point,Mon Jul 13 18:39:05 2015 UTC,"Does it though?  void func(unique_lock l, vector<double> v); ... unique_lock local_l; vector<double> local_v;  func(move(local_l), local_v);   Not guaranteed to take ownership. Here's another tricky fun thing about pass by value: order of evaluation of function parameters is undefined, and pass by value in general is a throwing operation.  What's really risky to me it seems is assuming you will lose ownership of the lock. If you really want to be 100% sure you don't own something after calling move on it and passing it into a function, the safest thing to do is just call reset on it.  Anyhow, my original point was about pass by rvalue reference as a sink parameter being a common view, and it is. As I showed you, Herb Sutter did quite explicitly come out against pass by value at his talk for sink parameters, at least of copyable types, which is what we were originally talking about.  I'll also go a step further and argue that all the reasoning that convinced him is also applicable to move only types, Scott Meyer does a great job arguing this, and gives examples from the standard library (like constructed a shared_ptr from a unique_ptr)."
cpp,3d212b,quicknir,1 point,Mon Jul 13 18:47:13 2015 UTC,"I'm confused. You preface your example by saying that it shows by-value is preferable, but go on to explain that f2 (rvalue reference) is better. What?"
cpp,3d212b,aport,1 point,Mon Jul 13 06:36:26 2015 UTC,"You swapped f1 with f2 and x with y in your comment, that's why people are confused."
cpp,3d212b,sbabbi,1 point,Mon Jul 13 08:06:13 2015 UTC,"Thanks for pointing this out, I have edited my comment."
cpp,3d212b,sakarri,1 point,Mon Jul 13 15:48:37 2015 UTC,"By the way, can you give a small example where additional optimizations resulting from eliminating aliasing are enabled?"
cpp,3d212b,quicknir,1 point,Mon Jul 13 22:29:18 2015 UTC,"By behave better during function overloading, do you mean avoiding 2N overloads?  Except, btw, that Herb Sutter was convinced, and at his talk 2 months later at cppcon, he only recommends pass by value in very specific situations. See the link I posted below."
cpp,3d212b,quicknir,2,Mon Jul 13 00:35:12 2015 UTC,"Herb Sutter was not convinced.  As the other posted said you're confusing two different things here.  One has to do with sink parameters, the other has to do with general argument passing.  Herb Sutter's talk at CppCon only says that one should continue to pass by const reference just like they did back in C++03.  But he also says that one should pass by value for sink-parameters."
cpp,3d212b,sakarri,2,Mon Jul 13 00:50:17 2015 UTC,"By sink parameters, I'm going to assume that you mean a parameter you need to make a copy of, e.g. setters. If you listen to the talk, you will see that he comes out against passing by value in most cases, instead prefer const & and && overloads. Look at the slide at 1:25:50, he calls pass by value ""too cute"" and ""probably an anti-pattern""."
cpp,3d212b,quicknir,5,Mon Jul 13 00:57:45 2015 UTC,You might want to read it again.  Scott is saying that you should use && for sink values of move-only types.  std::vector is copyable & moveable.  Using by-value sink lets you get the speed without having to implement the function twice (or worse if you have multiple).
cpp,3d212b,vlovich,3,Mon Jul 13 00:30:30 2015 UTC,"Except that you don't get the speed. Pass by value performs worse for lvalues then pass by const &, ranging from slightly to considerably. It also performs worse than && for rvalues. If you care about performance, then you should do const & + &&. If you don't, you should just do const &.   IF you have multiple parameters, and IF you care about performance, and IF you are too lazy/too averse to introducing complexity to do perfect forwarding, then yeah, pass by value is a good call. Constructors are a good example of this; they're one of the few situations where Sutter recommends pass by value.  Herb sutter talks about this in detail: https://www.youtube.com/watch?v=xnqTKD8uD64"
cpp,3d212b,quicknir,2,Mon Jul 13 00:37:19 2015 UTC,"Yes, it's advice specialized for types where the copy is expensive but the move is very cheap.  You will be hard-pressed to write a benchmark where you can demonstrate a speed difference between copy + move of a std::vector vs const& + copy.  I've watched that talk & I think Herb overstates the problem slightly & this article calls out the getline case.  There's also a class of scenarios where there is no performance concern and you want to treat it as a value-type.  I found many scenarios where people blindly follow the const& pattern & miss that the sizeof the type is an int."
cpp,3d212b,vlovich,1 point,Mon Jul 13 00:45:33 2015 UTC,"For most type of interest, copying is much more expensive than moving. If you're talking about primitives or structs the size of a word, then yes you should just pass by value.  Even if Herb overstates the problem, there still isn't much to recommend passing by value in most cases. If you don't care at all about performance, than const & is preferable for several reasons (no slicing, conditional copies, etc). If you do care about performance, usually you care quite a bit, and will happily put in the effort to do one extra overload."
cpp,3d212b,quicknir,2,Mon Jul 13 01:04:33 2015 UTC,"Well, I tried to avoid bringing rvalue references into play, as that also would require to go deeper into move semantics, overloading and when an rvalue reference actually is a forwarding reference etc.  The advice to use by value for sink parameters is from Eric Niebler, which he gave at his keynote at Meeting C++ 2013 and later repeated the talk at C++Now. I linked that recording for a reason."
cpp,3d212b,quicknir,1 point,Mon Jul 13 10:01:08 2015 UTC,"Sure, that's understandable. If it's targeted at the beginners though, personally I would just not broach the subject of sink parameters.  Yes, I saw Eric Niebler's advice in the video. I plan to ask him if he's changed his mind. Herb Sutter's talk goes into quite a bit more depth on the whole pass by value thing, and he comes out against it in the majority of cases. Herb Sutter's talk was end of 2014, so I'm not sure how that matches up time wise with Niebler's C++Now talk."
cpp,3d212b,quicknir,3,Mon Jul 13 14:07:27 2015 UTC,"I've been at CppCon and seen Herbs Keynote live, and also saw how controversial it was received. Both agree that the rules for C++03 are still mostly valid."
cpp,3d212b,jpakkane,1 point,Mon Jul 13 14:31:41 2015 UTC,"That's interesting about it being received controversially. I think it would be very interesting if someone was to dig up all the information that people have presented in various contexts and write it up. It still seems like there is a lack of consensus; you have Scott Meyer and Herb Sutter on one side, Eric Niebler and many other people (like in this sub reddit) on another."
cpp,3d212b,sbabbi,2,Mon Jul 13 16:49:54 2015 UTC,"Yes, I agree. While most controversy was about Herbs views on almost always auto.  Both view points regarding argument passing are valid, and I tend to weight the view of a library designer such as Eric is, a little more then Herb or Scotts views. Also, afaik the only difference is really about sink parameters. Which are except for setters/constructors rather rare."
cpp,3d212b,jpakkane,3,Mon Jul 13 23:07:13 2015 UTC,"Having std::vector (or any STL type, really) is very, very bad if you want to preserve ABI compatibility. STL types and compilers are free to change how the types are implemented, name mangled and so on. This means that any shared library with stable ABI requirements can't have those in their public api.  If you always compile from source, then it's ok. But note that this is fundamentally incompatible with Linux distro packaging which forbids embedded source."
cpp,3d212b,sbabbi,8,Mon Jul 13 09:03:04 2015 UTC,"No. Using any C++ class across ABI boundaries with different compilers is very bad. This has nothing to do with the STL.  And it does not really matter if they are public or private, the size of the object might be different, and there might be inline functions that use that object.  In fact if you are on linux, and you use the libstdc++, that is guaranteed to be backward compatible (unless you are using the new ABI that comes with gcc 5.*)"
cpp,3d212b,jpakkane,4,Mon Jul 13 12:57:22 2015 UTC,"I have lived through an abi transition for libstdc++ (not version 5) and I have massive scars to prove it. If you don't put templates + STL in your headers you should be pretty good for ABI compatibility across compilers and/or versions. As an example see Qt, which does do ABI stability really well. edit On windows don't mix MinGW and MSVC, that will just plain never work."
cpp,3d212b,Gotebe,1 point,Mon Jul 13 13:38:53 2015 UTC,"That might have been a libstdc++ bug (IIRC they screwed up a release on mingw). But again, it has nothing to do with the STL itself, rather with a particular implementation.  It is a library mantainer (any library) responsibility to ensure ABI compatibility, or not (i.e. msvcrt). Pimpl is not the only way to do that (and I personally dislike the pimpl abuse on qt).  This is not about the standard library, it is about any library, and it is not a good reason to not use the STL, just go and blame your standard library mantainers if they mess up."
cpp,3d212b,Wriiight,1 point,Mon Jul 13 15:13:55 2015 UTC,I'm not saying that this is a reason not to use STL. Everyone should use STL as much as possible. It's really nice and solves a lot of problems. You just have to be aware of the consequences of exposing it in your library api.
cpp,3d212b,korvirlol,0,Mon Jul 13 18:15:17 2015 UTC,"If you don't put templates + STL in your headers you should be pretty good for ABI compatibility across compilers and/or versions.    There's a difference between ""pretty good"" and ""in no way, shape or form guaranteed to work""   across compilers across compiler versions as across different build settings with one compiler version   ... and the ""not guaranteed to work"" is the case for C++ (and C)."
cpp,3d212b,vlovich,0,Wed Jul 15 08:50:09 2015 UTC,"Using any C++ class across ABI boundaries with different compilers is very bad.   I'm assuming when jp said ""If you always compile from source, then it's ok""  that implied compiling all the source with the same version of the same compiler.  Though you can still go wrong by compiling some parts with debugging or instrumentation (such as memory leak checkers or profilers.)  I used to work on a project that exposed C++ objects in DLLs (using whatever the magic MFC DLL linkage was in VS).  Worked fine if all dlls + exe were debug or all were release. Probably could have mixed debug and release if you never did anything but pass an object around by reference in other modules code, but the code had bigger problems than that, including templates in the exported header files for some modules, which pretty well messed up even attempts to do independent versioning of modules."
cpp,3d212b,grumbel,1 point,Mon Jul 13 19:51:16 2015 UTC,"This is because objects crossing a binary interface (ex: program to library, or library to library) is inherently unsafe because you cannot guarantee the compiler (or even version of the compiler?) used to build both units?"
cpp,3d0n5c,hkaiser,2,Sun Jul 12 14:53:37 2015 UTC,"Really excited by this!  Now, to complete the circle, let's hope we'll get RxCpp (or something like it) next some day, too! :-)  // Edit: for anyone interested, here's how they're related -- a presentation (different prog. lang., but shouldn't be a big deal to get the gist) that goes through futures, then composable futures, and then reactive extensions (Rx): http://plainoldobjects.com/presentations/decomposing-applications-for-deployability-and-scalability/futures-and-rx-observables-powerful-abstractions-for-consuming-web-services-asynchronously/ -- note that each abstraction has different use-cases (as covered in the presentation): in particular, Rx observables can be thought of as a generalization of futures for infinite streams.  Edit: Video: https://www.youtube.com/watch?v=aZkwIA4k2xU More recent (2014) slides: http://www.slideshare.net/chris.e.richardson/futures-and-rx-observables-powerful-abstractions-for-consuming-web-services-asynchronously-devnexus2014  On another note, Boost.Thread is another way to experiment with C++17-style future continuations: http://www.boost.org/doc/libs/master/doc/html/thread/synchronization.html#thread.synchronization.futures.then"
cpp,3d3p85,SushiAndWoW,14,Mon Jul 13 07:20:00 2015 UTC,"Why doesn't the C++ language adopt the MSVC extension, and allow a temp object to be assigned to non-const reference?   Because it's a footgun (with which you can easily shoot yourself in the foot):  void increment(long& foo) { foo += 1; } int main() {     int x = 123;     increment(x);     assert(x == 124); // Oops! }   The purpose of non-const lvalue references is to refer to specific objects and allow mutation. If you allow lvalue references to bind to temporaries like a temporary long object that's the result of an int-to-long conversion, the program looks correct at first sight but behaves very differently from what you expect because now only the temporary object gets modified. Most of the time you don't want a non-const lvalue reference to refer to some temporary object. The compiler preventing this is a way of catching these kinds of errors.  Even Microsoft engineers like /u/STL recommend avoiding this ""extension"" if I recall correctly. There are better ways to solve your problems. For example, you could turn your operator<< into a member function. Member functions don't care about the value category of the ""object expression"" (they are special in this regard) unless you use the new ref qualifiers. Alternatively you can add an inline overload using an rvalue reference. That's what they are for. I believe, this is even done in the standard library for some functions:  void foo(blah& x, blupp const& y); inline void foo(blah&& x, blupp const& y) { foo(x,y); }   If you need this often, you could write your own custom reference wrapper that automatically converts from lvalue and rvalue references:  void foo(any_ref<blah> x, blupp const& y);   But I would be surprized if you needed this often."
cpp,3d3p85,sellibitze,12,Mon Jul 13 12:20:38 2015 UTC,"I've been calling this thing the Evil Extension for a decade. It is an abomination that has caused an incredible amount of suffering. When I go into work today, I'll ask the compiler devs (again) if they can remove it in the next major version."
cpp,3d3p85,STL,4,Mon Jul 13 16:09:13 2015 UTC,"Can you show an actual bad example? Because the above is not one. MSVC does not compile it.  I've used MSVC for, well, 15+ years, and I don't remember a situation where I've been bitten by this.  I've been bitten by the conditional operator accepting ambiguous code..."
cpp,3d3p85,sellibitze,5,Mon Jul 13 17:13:42 2015 UTC,"Because it's a footgun (with which you can easily shoot yourself in the foot):   +1 for the word ""footgun"" :)  However, MSVC doesn't compile this footgun:  error C2664: 'void increment(long &)' : cannot convert argument 1 from 'int' to 'long &'   Even though it does support temporary objects as rvalues, the temporary object has to be explicit."
cpp,3d3p85,scatters,2,Mon Jul 13 17:07:05 2015 UTC,That's interesting. I saw this piece of example code somewhere as an explanation of why non-const ref to temporary is undesirable.
cpp,3d3p85,STL,1 point,Tue Jul 14 09:07:02 2015 UTC,"I haven't been able to cause this problem with classes, either. As far as I can tell, MSVC won't implicitly create a temporary to assign to a non-const ref, but an explicitly created temporary works.  I'm still waiting for /u/STL to explain why they think this extension is evil. I literally cannot remember being bitten by it in 15 years."
cpp,3d3p85,scatters,7,Tue Jul 14 13:10:52 2015 UTC,"This is why rvalue references were added. If you design your API to use rvalue references from the beginning then their use will be perfectly natural.  void StrCvtCp(Seq in, Str& out, UINT inCodePage, UINT outCodePage, Vect<wchar_t>&& convertBuf);   This works fine; if you want to reuse a common convertBuf you just need to wrap it in std::move. For compatibility you could provide 2 overloads, one taking lvalue reference and the other taking rvalue reference, and forward from one to the other.  template <typename T> Console::Out const& operator<< (Console::Out const& x, T&& a)     { ((Str&) x) << std::forward<T>(a); return x; }   Again, use rvalue references; look at [ostream.rvalue] for the preferred way to write this.  template <typename T> Str& operator<< (Str&& x, T const& a)     { return x << a; }   [Edit: removed expression SFINAE because it's very difficult to get right without triggering infinite recursive template instantiation. Aargh.]"
cpp,3d3p85,Daavee,5,Mon Jul 13 08:23:19 2015 UTC,"auto& [...] -> decltype(x << a)   This is what I usually refer to as Outlook CodeTM (i.e. code typed into an E-mail program - or Reddit in this case - not a compiler). Trailing return types are introduced with auto, not auto&."
cpp,3d3p85,scatters,1 point,Mon Jul 13 16:12:11 2015 UTC,"Right, yeah; I get worried about auto or declval giving me an object type where I wanted a reference, so I tend to put a & in even where it isn't needed (or valid). Thanks!"
cpp,3d3p85,Daavee,-1,Mon Jul 13 19:08:46 2015 UTC,"Ehm, with your first example he isn't allowed to reuse convertBuf, as it is in an undefined unspecified state after the first call to StrCvtCp."
cpp,3d3p85,devel_watcher,2,Mon Jul 13 08:34:34 2015 UTC,"Objects passed by rvalue reference parameters are left in an unspecified state, not an undefined state. It's trivial to get the object back into a known state by e.g. calling clear().  Aside: where did you get the perception that an object passed by rvalue reference parameter is left in an undefined state?"
cpp,3d3p85,Daavee,1 point,Mon Jul 13 08:39:49 2015 UTC,"Ah, my bad. I meant unspecified state. But this still doesn't solve OP's problem. In this case the move will probably take the resources of the original vector and you will have to allocate memory again, defying the purpose of the function's signature (single alloc, multiple uses)."
cpp,3d3p85,devel_watcher,3,Mon Jul 13 08:58:09 2015 UTC,"The move will just cast the lvalue ref to rvalue ref. But to take the resources, some move constructor must be called. It's not called inside the function."
cpp,3d3p85,scatters,1 point,Mon Jul 13 10:17:13 2015 UTC,"This is probably an API function so you can't say what the function actually does. std::move describes an intent to transfer an object, which in my opinion is just not correct in this case. Also additional documentation is needed for clarifying the changes to convertBuf inside the function. But why would you force the user of your API to read up, why std::move is needed, when you can just provide a sensible overload.  /u/scatters code is perfectly fine (ignoring the auto&), but it is just unintuitive for me, why I should use std::move in this case."
cpp,3d3p85,Daavee,1 point,Tue Jul 14 15:34:17 2015 UTC,"I'm just clarifying that std::move name is misleading. It doesn't mean that something will be moved.  As for original question, I prefer the uref approach. But I'm not sure, because the whole thing looks like some hack to deal with Windows-specific encoding madness."
cpp,3d3p85,JMBourguet,1 point,Tue Jul 14 15:52:05 2015 UTC,"Why would it take the resources? It's using convertBuf as a temporary conversion buffer, not as a source for a move-constructor.  Note also that when passing convertBuf by lvalue reference the called function could take resources if it wanted, even without calling std::move - std::swap being a prime example."
cpp,3d3p85,tongari95,1 point,Mon Jul 13 09:53:24 2015 UTC,"But still std::move expresses some kind of ownership-transfer for me, which a lvalue reference doesn't. Maybe it's just me, but I would always go with another overload of the function.  You're right with std::swap, but it expresses the change to the given object which StrCvtCp does not. Also swapping leaves both objects in a specified state. StrCvtCp would need additional documentation why you need to move a buffer.  With template argument deduction and reference collapsing it is a different story as I don't have to explicitly move my object."
cpp,3d3p85,encyclopedist,3,Tue Jul 14 15:27:41 2015 UTC,"C++ used to behave like you want, but it was changed for CFront 2.0, in 1989, as it was deemed too error-prone."
cpp,3d3p85,STL,2,Mon Jul 13 14:35:06 2015 UTC,"I think the major concern is object lifetime, consider this:  template<class T> struct Reference {     explicit Reference(T& t) : t(t) {}      T& get()     {         return t;     }  private:      T& t; };  Reference<SomeType> ref(SomeType{}); ref.get(); // dangling reference"
cpp,3d3p85,encyclopedist,1 point,Mon Jul 13 09:19:24 2015 UTC,"Since C++11 we have forwarding references aka universal references (not to be confused with just rvalue references), which can become both rvalue reference and lvalue reference due to reference collapsing rules (live example):  template<typename Container> void foo(Container && v) {     //modify v here     v[100] = 1; }  foo(std::vector<int>(1000)); // rvalue reference // or std::vector<int> buffer(1000); foo(buffer); // non-const lvalue reference   About example 2: there is a big danger: what if someone assigns it to a reference?  Str & x = Console::Out() << ""Ok!""; x << ""Undefined Behavior!"";   You can solve it the same way using forwarding references:  template <typename Stream, typename Value> auto operator<<(Stream && Stream, Value && v) -> Stream&& {     //... }"
cpp,3d3p85,Daavee,2,Mon Jul 13 14:14:57 2015 UTC,"Universal references are powered by the template argument deduction tweak, not just reference collapsing. This is a common misunderstanding."
cpp,3d3p85,psychob,2,Mon Jul 13 16:14:31 2015 UTC,"Indeed, thank you for correction."
cpp,3d3p85,tcanens,1 point,Mon Jul 13 16:17:21 2015 UTC,"I don't use MSVC, but is the following possible?  #include <vector>  std::vector<int>& f(std::vector<int>& v = std::vector<int>()) {     return v; }  int main() {     std::vector<int>& v = f(); }"
cpp,3d3p85,newmewuser4,2,Tue Jul 14 15:37:42 2015 UTC,"Yes, that compiles.  But note that a nearly identical thing compiles in standard C++:  #include <vector>  std::vector<int> const& f(std::vector<int> const& v = std::vector<int>())     { return v; }  int main()     { std::vector<int> const& v = f(); }   That's just substituting const ref for non-const ref. GCC compiles it fine, no warnings even with -Wall, and it results in the same problem (invalid reference to a destroyed object).  If you want the compiler to protect you from that kind of thing, I argue you should be using Rust. In my view, it's against the intent of C++ to protect against things you can see will go wrong. C++ does not intend to make errors impossible, it intends to make them visible (to a skillful programmer).  We fundamentally cannot make errors impossible while allowing for this:  *((int*) 12345) = 0;   C++ makes sense as a language that's powerful, yet allows for this type of freedom."
cpp,3d3p85,quicknir,1 point,Tue Jul 14 15:59:48 2015 UTC,"If im not mistaken, C++ standard extends object lifetime if it's bound to const ref, even if its temporary."
cpp,3d3p85,quicknir,1 point,Wed Jul 15 14:51:07 2015 UTC,Only for direct bindings.
cpp,3d3p85,tcanens,1 point,Wed Jul 15 20:52:43 2015 UTC,"In this example compiled with GCC 4.9.2:  A const& f(A const& a = A()) { return a; }  int main() {     cout << ""Before"" << endl;     A const& a = f();     cout << ""After"" << endl; }   ... the object is destroyed before the next statement:  C:\temp>g++ -std=gnu++14 TestRefExt.cpp -o TestRefExtGcc.exe  C:\temp>testrefextgcc Before A() ~A() After   VS 2013 behaves identically."
cpp,3d3p85,quicknir,1 point,Thu Jul 16 15:52:21 2015 UTC,"allow a temp object to be assigned to non-const reference? I don't see a disadvantage or danger that isn't outweighed by the benefits     C++ is not about writing less code, C++ is all about having a lot of control over the resulting binary by stating your intentions as clear as possible. Ambiguous code is nothing but a can of worms. Using that extension only to write a bit less code is just being lazy.    There are extension that allow to write less code but also allow the compiler to know more about our intentions:    for (const auto& item : container)   Less to type and the compilers knows we want to iterate over the whole container without changing its elements."
cpp,3d3p85,quicknir,2,Wed Jul 15 20:23:12 2015 UTC,"C++ is not about writing less code, C++ is all about having a lot of control over the resulting binary by stating your intentions as clear as possible.   In comparison to C, C++ is about stating your intentions clearly with less code. If it were not, everything else you said is also true about C; and if you didn't care about platform independence, about assembly.   Ambiguous code is nothing but a can of worms.   The MSVC extension is not ambiguous."
cpp,3d3p85,quicknir,0,Thu Jul 16 15:49:10 2015 UTC,"In your Example 1, I don't know that I love forcing clients of the function to deal with state, just because they want the speed boost. I would probably either make it a functor so that the state is encapsulated, or make the buffer a static variable, which will allow even ""lazy"" clients to get the speed benefits, at a minor cost in space (the buffer won't be freed until the end of execution).  If you want to stick with this approach though, you could make the last argument a pointer that defaults to null, and check for null on the first line. I actually prefer this as its more explicit, and generally the difference between reference and pointer parameters is that pointer parameters are supposed to be optional/nullable. If you don't like that you could also use boost::optional.  Your second example makes me a bit nervous. Your destructor non-trivially accesses a resource, what if it throws? Destructors should be for freeing resources, not for taking other non-trivial actions as scope exits. I'd probably just rather use one extra line of code to first dump everything into a stringstream, and then dump the stringstream into the console (which is basically what you are doing).  Remember: syntactic sugar costs lives."
cpp,3d2a5p,dany74q,3,Sun Jul 12 23:11:13 2015 UTC,"The first thing I noticed is that one of your functions is named assert. It's easy to break your code by including <cassert>, which defines an all-powerful assert macro."
cpp,3d2a5p,redditsoaddicting,2,Mon Jul 13 04:33:35 2015 UTC,Can it break given that its in a separate namespace ?
cpp,3d2a5p,redditsoaddicting,3,Mon Jul 13 05:59:46 2015 UTC,"Yup, macros are all-powerful. They're text substitution that happens before regular compilation."
cpp,3d2a5p,quicknir,3,Mon Jul 13 06:03:54 2015 UTC,"They're kind of like genies actually. All powerful, and desperately trying to twist around your wishes to do you harm at the slightest opportunity."
cpp,3d2a5p,josefx,1 point,Mon Jul 13 21:42:22 2015 UTC,MACROS are not that bad when used with care. However macros with lower case letters that hide what they are to stab you in the back are sneaky little bastards that should be purged with fire.
cpp,3d2a5p,kal_at_kalx_net,3,Sat Jul 18 08:40:02 2015 UTC,"Why not use plain C++ and assert?     assertLT(t,u); is less clear than     assert(t < u); C++ is sufficiently expressive to write tests without yet another testing framework."
cpp,3d2a5p,quicknir,3,Mon Jul 13 17:54:50 2015 UTC,"Traditionally one of the reasons for having ASSERT_LT(T, U) instead of assert(t < u) is because the former can tell you the runtime values of both T and U, the latter cannot. I'd happily pay three characters to avoid having to jump into the debugger, set a breakpoint, run my code at significantly slower speed, and query the two variables to finally find out something that I could have known from the get-go.  Another reason is that C++ assert raises SIGABRT. In a lot of unit testing, it may still be meaningful to continue testing and see if other tests fail or not. You can write signal handlers to deal with this, but if a genuine SIGABRT gets raised, it will probably be pretty confusing. It's also just ugly code to write.  Instead, typically testing framework asserts will throw exceptions that are custom to the testing framework. This way there's no way to get them mixed up with anything else. And it's easy to continue execution and try other tests.  I think that deciding to write unit tests for a large project using c++ assert and other very simple tools, instead of a framework of some kind, preferably a large and well thought out one like gtest, would be a huge mistake."
cpp,3d2a5p,bames53,2,Mon Jul 13 21:44:12 2015 UTC,"Traditionally one of the reasons for having ASSERT_LT(T, U) instead of assert(t < u) is because the former can tell you the runtime values of both T and U, the latter cannot.   I thought it was pretty cool that the Catch C++ unit testing framework allows e.g., REQUIRE(y < x) and will display failures like:   tests.cpp(33): FAILED:   REQUIRE( y < x ) with expansion:   11 < 10    So you get the best of both: clear tests and not having to use a debugger to see the expansion."
cpp,3d2a5p,quicknir,1 point,Tue Jul 14 21:26:56 2015 UTC,"I agree, it's very cool. At first I suspected macro magic, then I saw it was operator precedence magic. It would take me forever to convince myself there weren't any hidden edge cases."
cpp,3d2a5p,kal_at_kalx_net,1 point,Wed Jul 15 14:36:13 2015 UTC,I agree with everything you say. Especially about large projects. Different tools are required at that scale. For small projects I use https://github.com/keithalewis/fms/blob/master/include/ensure.h At some point a human being needs to be plopped into the debugger and have their nose put in the dog food. I should have been more responsive to dany74q's question and suggest he take a look at that to see if it solves his problem.
cpp,3d2a5p,quicknir,1 point,Mon Jul 13 23:52:09 2015 UTC,"I use something similar to ensure, but not for unit testing, for defensive programming. I just put asserts throughout my code."
cpp,3d2a5p,guepier,1 point,Tue Jul 14 00:13:07 2015 UTC,Traditionally   Yeah but that reason’s simply obsolete with the existence of Catch. Nowadays there’s no reason to have an inferior interface to Catch for a testing framework.
cpp,3d2a5p,quicknir,1 point,Wed Jul 15 13:51:11 2015 UTC,"It's not simply obsolete; it depends how much implementation salt you are willing to put up with for a very small amount of syntactic sugar. Catch still needs different macros for negation, and different macros to stipulate you expect an exception to be thrown, etc. So it's overall just a small reduction in the number of testing macros you need to know, in exchange for much higher implementation complexity."
cpp,3d2a5p,guepier,1 point,Wed Jul 15 14:38:51 2015 UTC,"I think you’re completely wrong there.   it depends how much implementation salt you are willing to put up with for a very small amount of syntactic sugar   This is largely true, but it’s been long established that a superior user experience is worth considerable expenses in the implementation. Furthermore, when it concerns the core API (as in this case) the cost–benefit analysis favours a good API overwhelmingly. Simply put, as a user I’d choose a library with a better core API pretty much ten times out of ten, even if that meant accepting a significant reduction in features. And last but not least, the work has been done already (in Catch) and since the license is extremely permissive, the code can easily be reused (with adaptation).  It’s very hard to argue that implementing a superior API here is a prohibitively costly issue.   Catch still needs different macros for negation, and different macros to stipulate you expect an exception to be thrown, etc. So it's overall just a small reduction in the number of testing macros you need to know   No, that’s not true. Yes, Catch needs more than one assertion macro but it’s an entirely different thing to have a separate macro for things like asserting exceptions thrown than it is to have one separate macro per comparison operator. That’s simply not a “small reduction”. It’s an interface that’s an order of magnitude smaller."
cpp,3d2a5p,quicknir,1 point,Wed Jul 15 17:15:02 2015 UTC,"You're entitled to your opinion obviously.  I don't think at any point I disagreed with the fundamental point that a clean interface takes priority over a clean implementation. But at some point there is a limit to the trade off. This is especially true when using macros; they don't give a clean separation between implementation and interface, so the more complicated the implementation, the worse the error messages for the user if they happen to misuse.  Catch provides one macro for true assertions, one for false, a special function for floating point, and 3 for exceptions (not double counting death vs nondeath). This is just basic, day to day stuff, requires about half a dozen macros. gtest has the same, and will additionally provide inequality macros, which is another half dozen. So gtest maybe has twice as many of these macros, certainly not an order of magnitude.  The problem is that this represents an incredibly tiny improvement to the core API; it doesn't handle any more cases, or more robustly, or anything like that. It just saves typing two characters. You can write all the same tests, with no meaningful difference in time spent.  Overall I still prefer Catch's approach as long as someone else is implementing it. But if it comes to trading off other features, it depends what those features are. I haven't explored Catch enough to know if it's missing something important. But if for instance I can't effortlessly set up type parametrized tests as in gtest for extensive testing of generic code, I certainly wouldn't give up that feature to save two characters."
cpp,3d2a5p,o11c,2,Wed Jul 15 18:15:33 2015 UTC,Without looking too much at it:  I must strongly oppose any internally-harnessed testsuites. Tests should always be harnessed by an external process.
cpp,3d2a5p,louiswins,2,Mon Jul 13 07:09:36 2015 UTC,"Why do you do auto blah = [](args) { body; }; instead of auto blah(args) { body; }? It seems less clear to me, like it's using lambdas for the sake of using lambdas."
cpp,3d2a5p,redditsoaddicting,3,Tue Jul 14 19:55:08 2015 UTC,"I can't speak for the OP, but lambdas allow auto in the parameter list whereas regular functions do not (yet). It can be a convenient shorthand template. However, I'm pretty sure the OP's usage could cause ODR violations."
cpp,3d2a5p,louiswins,1 point,Wed Jul 15 00:23:20 2015 UTC,"Ah, that's true, it saves a template <typename T>. I didn't notice the parameters. I'd personally still type out the function, but I can see the argument for OP's way. If you sort out the ODR stuff. Thanks!"
cpp,3cvxs1,anonggg,14,Sat Jul 11 05:46:32 2015 UTC,segmentation fault waiting to happen on slide 4  … typedef std::vector<…> loop_vec; loop_vec* superloops; superloops->reserve(depth); …   But I like the (presumably) real-world examples of how a big C project worked around C's limitations and ended up making the switch to C++ to get something more readable/convenient.
cpp,3cvxs1,sellibitze,2,Sat Jul 11 08:07:19 2015 UTC,"Yikes, I hope some ran some static analysis on this and realized that shouldn't be a pointer."
cpp,3cvxs1,__Cyber_Dildonics__,8,Sat Jul 11 16:08:09 2015 UTC,That is some ugly example C++ code :-(
cpp,3cvxs1,AceyJuan,2,Sat Jul 11 08:05:50 2015 UTC,GCC epitomises bad code. There's a reason that a lot of people are migrating to contributing to LLVM.
cpp,3cvxs1,MsEtheldreda,7,Sat Jul 11 11:17:07 2015 UTC,LLVM also helped move GCC in the direction of C++.    In fact I'm not sure GCC would be where it is today if it wasn't for LLVM/CLang.
cpp,3cvxs1,spinwizard69,3,Sat Jul 11 23:18:56 2015 UTC,Funny how competition works.
cpp,3cvxs1,hauzzer,2,Mon Jul 13 04:07:08 2015 UTC,"Yeah, for many years I felt like giving the GCC folks the middle finger. I still hold a small grudge against them but they're better than they were."
cpp,3cvxs1,AceyJuan,15,Sat Jul 11 23:51:21 2015 UTC,"June 17, 2008   How is this relevant?"
cpp,3cvxs1,hauzzer,8,Sat Jul 11 07:50:53 2015 UTC,"Well, GCC has actually gone through with the switch since then."
cpp,3cvxs1,jringstad,1 point,Sat Jul 11 12:15:49 2015 UTC,Since May 2013
cpp,3cvxs1,lednakashim,1 point,Thu Jul 16 06:39:58 2015 UTC,Maybe still new enough to learn stuff from it? Dunno though not my mainfield of interest.  Also is Beamer skills are not impressive :o
cpp,3cvxs1,JodderSC2,5,Sat Jul 11 07:52:16 2015 UTC,As a C++ newbie some of the C code examples were almost completely unreadable. I remember seeing on LWN when GCC approved C++ use internally. I wonder what kind of progress has been made?
cpp,3cvxs1,Blahbl4hblah,2,Sat Jul 11 14:31:34 2015 UTC,"It's a lot nicer actually, but the transition between rewritten bits and original bits is often jarring."
cpp,3cvxs1,o11c,1 point,Sat Jul 11 20:36:36 2015 UTC,Rewriting must give such a result regardless of the language change though :-)
cpp,3cvxs1,Gotebe,1 point,Sun Jul 12 19:10:29 2015 UTC,"Uh, no."
cpp,3cvxs1,o11c,5,Sun Jul 12 19:29:27 2015 UTC,"tl;Dr : C++ is a better language than C, unless e.g.   you're a tool you don't have a C++ compiler handy    :-)"
cpp,3cstd1,hun_nemethpeter,6,Fri Jul 10 14:14:59 2015 UTC,"Oh finally, thanks for the heads up. Gonna play around with it a bit later..."
cpp,3cstd1,TheCreat,8,Fri Jul 10 14:30:17 2015 UTC,I really want to get into Android development in the long term but when I looked at how things are done with their Java implementation I  got PTSD. Are things any better with C++?
cpp,3cstd1,kozukumi,12,Fri Jul 10 17:23:31 2015 UTC,"I thought about Android Dev the other day in C++ and on the NDK page:   In general, you should only use the NDK if it is essential to your app—never because you simply prefer to program in C/C++.   turned me off."
cpp,3cstd1,TheSuperWig,5,Fri Jul 10 18:13:43 2015 UTC,This is so sad.   Java has no place on a phone.   I was really hoping for a change of heart from the Android people.
cpp,3cstd1,spinwizard69,1 point,Sat Jul 11 05:35:21 2015 UTC,:( shame. Apparently Windows Phone is pretty nice to develop for?
cpp,3cstd1,kozukumi,3,Fri Jul 10 18:17:07 2015 UTC,Ubuntu Phone is for that kind of thing.
cpp,3cstd1,devel_watcher,5,Sun Jul 12 12:26:10 2015 UTC,"From what I've read, it's not recommended to C++ for ever day app development. I usually see the appeal of this feature with game engine developers, since it allows them to integrate their C++ code directly.  From what I understand, much of the bindings for UI are only available to Java so you would have to use Java at some point unless you are working with something like OpenGL.  This is my understanding of it from a few years ago. Times may have changed.  edit: Did a little bit of reading and it seems like in order to get their ""native"" UI framework to work might take a little bit of work:   Sure you can. Read up on calling Java from C(++), and call the respective Java functions - either construct UI elements (layouts, buttons, etc.) one by one, or load an XML layout. There's no C-specific interface for that, but the Java one is there to call."
cpp,3cstd1,blackraven36,5,Fri Jul 10 17:56:54 2015 UTC,"From what I understand, much of the bindings for UI are only available to Java so you would have to use Java at some point unless you are working with something like OpenGL.   Qt on Android works fine for the UI. And you can even reuse it for iOS / WP."
cpp,3cstd1,doom_Oo7,5,Fri Jul 10 20:20:47 2015 UTC,"Unfortunately Qt produces very big executables, if I am not mistaken :("
cpp,3cstd1,Cyttorak,3,Fri Jul 10 20:53:56 2015 UTC,"To give reference, I have an app with about 70kloc which calls QtCore, GUI, Widgets, SVG, Network, Xml, PrintSupport; in release mode it's 2.4 mbytes.  The combined Qt libs I require are less than 20 mbytes and if I wanted I could just build them all statically and add a dose of LTO to see if it makes it better (I guess it would)."
cpp,3cstd1,doom_Oo7,6,Fri Jul 10 21:15:24 2015 UTC,"So your total binary size would be around 25MB, which is quite a lot, even nowadays. In fact I like Qt a lot for mobile development but binary size is a big big problem.  I for example like to update/install apps over 3G sometimes and I have a 500MB data plan. Also, I have only 8GB space on my phone and no SD slot, so I unfortunately care about the size of an app."
cpp,3cstd1,Elador,0,Fri Jul 10 23:07:24 2015 UTC,It's not Qt's problem. You can install library separately. I.e. one time download 25 mb of Qt and reuse it.
cpp,3cstd1,slezyr,5,Sat Jul 11 11:04:28 2015 UTC,.so files are included in the apk and inaccessible to any other app. So every app that uses qt would package its own copy.
cpp,3cstd1,feyddragoon,1 point,Sat Jul 11 15:09:24 2015 UTC,What? Ministro - Separate app with Qt libs. All other other apps COULD use it.
cpp,3cstd1,slezyr,1 point,Sun Jul 12 03:10:54 2015 UTC,"I was unaware that Ministro existed.  Even assuming that I can trust the maintainers of Ministro, which is a far stretch, I am skeptical.     How does it work?  Unless I have a serious misunderstanding, there is no way that the binaries could be loaded into the executable segment of your process space.    This would mean that the QT API has to be implemented by interprocess communication of some kind.  This has two consequences that immediately come to mind.   Interprocess communication is going to involve marshalling of data across processes, which is inherently slow and could affect the performance of your app. You have coded your application to use this IPC implementation of the API and therefore are tied to it.  What if there are ignored bugs in the IPC layer Ministro provides, or the author/maintainer simply stops upkeep?"
cpp,3cstd1,feyddragoon,3,Sun Jul 12 03:47:24 2015 UTC,"I can, but most of the customers of my app can't or won't."
cpp,3cstd1,Elador,3,Sat Jul 11 16:41:06 2015 UTC,"Well, I mean that: adding up executable and all libs you have a nice bunch of fatty files around. I would like to create total downloads of 6, 7 or even 10 MBs (like the other native apps), but not 20MB or more.  Also, if you want to build Qt in static mode  you need a commercial license, but if you plan to release apps in Android or other mobile platforms I think you already have one due to Qt's licensing.   All that is what I think it's the current state of Qt in this area, please correct me if I am wrong, I would like really to use this fantastic library."
cpp,3cstd1,Cyttorak,2,Fri Jul 10 23:21:42 2015 UTC,This article describes that at least for Android LGPL Qt is fine because it allows dynamic link libraries: http://wiki.qt.io/Licensing-talk-about-mobile-platforms.  iOS doesn't allow it
cpp,3cstd1,tpecholt,6,Mon Jul 13 14:30:46 2015 UTC,"i use qt, but the fees are pretty hefty considering the average roi of android apps"
cpp,3cstd1,klaxion,2,Sat Jul 11 00:58:22 2015 UTC,"Calling Java from C++ is significantly slower than the other way around (and both are far slower than calling Java from Java), so even if you wrote a wrapper that made the API not terrible, an application written in C++ which actually used the native UI framework would perform miserably."
cpp,3cstd1,Plorkyeran,3,Fri Jul 10 19:24:02 2015 UTC,"This is very true. I imagine that a few calls here and there are not a huge performance it, but constantly calling to the Java implemented API is a waste of resources.   In this case the NDK is designed to be called and not to be the caller. The absence of any kind of Android API (or very limited) says volumes about how they want Java->C++ not the other other way around. The NDK is designed to allow porting of existing code bases, not the ability to write your entire app in C++ (unless of course, you are ported a game completely written in C++)"
cpp,3cstd1,blackraven36,3,Fri Jul 10 19:42:44 2015 UTC,"The NDK is really only meant to be a supplement to the Java based SDK -- the idea is that you only use native code for things that require native performance (OpenGL, video encoding, etc), or for interfacing with existing C++ libraries. It is not well supported, making it extremely difficult to build, refactor, and debug. As much as I prefer C++ to Java, you definitely want to stick to Java as much as possible on Android, as things get very ugly very quickly using the NDK."
cpp,3cstd1,BigPoopBreakfast,1 point,Sat Jul 11 04:17:37 2015 UTC,"It is not well supported, making it extremely difficult to build, refactor, and debug.    Difficult to build ? It's a matter of calling cmake with the right toolchain..."
cpp,3cstd1,doom_Oo7,1 point,Sun Jul 12 16:59:55 2015 UTC,"the bennefit of using c++ is using existing libraries/code/opengl, which all comes from you.  In my company's setup, we do the bare minimum jni bridge to talk to sensors and the OS, and every thing else is platform independent c++ code we've rolled ourselves (with a few helpful libraries, like boost)"
cpp,3cstd1,darkforestzero,1 point,Fri Jul 10 22:55:38 2015 UTC,I am afraid it is not the language but the tools the responsibles of your PTSD.
cpp,3cstd1,newmewuser4,10,Fri Jul 10 21:50:41 2015 UTC,"Well if you're a C++ freak and just love the language, then in fact Java can be a pain and take all the fun away."
cpp,3cstd1,Elador,3,Fri Jul 10 23:14:02 2015 UTC,Awesome!
cpp,3cstd1,blackraven36,2,Fri Jul 10 16:57:50 2015 UTC,HOLY FUCKING SHIT!  FINALLY!
cpp,3cstd1,darkforestzero,2,Fri Jul 10 22:53:47 2015 UTC,Is it possible to use CrystaX NDK instead of Google's?
cpp,3csqr6,JRepin,2,Fri Jul 10 13:52:42 2015 UTC,KDE Frameworks to Qt are somewhat like Boost to C++.
cpp,3cryhl,dophinehk,13,Fri Jul 10 07:59:52 2015 UTC,"I use it for any helper functions or classes that aren't part of the public interface.  In a cpp file I can use an anonymous namespace, but I don't have that luxury in .h files.  So I use the namespace ""detail"".  This is a thing that should hopefully go away with modules, I think."
cpp,3cryhl,Houndie,5,Fri Jul 10 10:46:00 2015 UTC,"Just to add, for the benefit of the OP: you can of course use an anonymous namespace in a header file. The problem is that anything declared in an anonymous namespace is available in the surrounding namespace in the same translation unit (and not available anywhere else). Since header files directly become a part of client translation units, this would mean directly putting all these implementation details into the namespace. So it doesn't do what you intend at all. The detail namespace isn't a great solution, but it at least makes it clear that you shouldn't use these functions/classes directly."
cpp,3cryhl,quicknir,15,Fri Jul 10 13:52:52 2015 UTC,"Putting unnamed namespaces in headers is even worse than that, because it creates the potential for ODR violations."
cpp,3cryhl,STL,3,Fri Jul 10 16:32:59 2015 UTC,"The convention is to put implementation detail in a sub-namespace called detail.  I suppose private would be a better name, but that's a keyword of course.   It helps to avoid polluting the local namespace and allows users of the header to skip reading that as it's not part of the interface."
cpp,3cryhl,hubhub,3,Fri Jul 10 08:14:13 2015 UTC,"I wonder if a namespace private extension would be a helpful feature.  Maybe make it like an anonymous namespace, but restrict it so only certain other namespaces can use it, maybe with a syntax like friend namespace foo;."
cpp,3cryhl,boredcircuits,12,Fri Jul 10 14:23:01 2015 UTC,"Language features have complexity costs.  ""detail"" is perfectly fine; you don't need a new feature for this.  (Everyone complains that C++ is too complicated, then they complain that they just want one extra feature...)"
cpp,3cryhl,STL,2,Fri Jul 10 16:34:10 2015 UTC,"Very, very true.  I was just wildly speculating: in reality this sort of feature is too specialized to put in to the language."
cpp,3cryhl,boredcircuits,1 point,Fri Jul 10 17:42:26 2015 UTC,"All internal used declarations, all code implementing internal used declarations, can be put in ""detail"" namespace, thus nobody can use your those code unless he ""hacks"" into the namespace. I think ""internal"" or ""private"" are better names."
cpp,3cryhl,wqking,1 point,Fri Jul 10 08:31:03 2015 UTC,A library has a public interface. Everything that does not belong to this interface belongs into a private implementation/detail namespace.  This makes it clear what a user can expect to not change - and what he should not use.
cpp,3cryhl,Tywien,1 point,Fri Jul 10 12:11:51 2015 UTC,"Libraries have used the detail approach for a while, and I reckon it has spread because of usage in boost. One thing I've started to see (and use myself) is an impl namespace, possibly because it is fewer characters to type and might be a bit more obvious as to why it exists for newcomers to the language. But that's probably confirmation bias."
cpp,3cryhl,SAHChandler,-8,Fri Jul 10 17:15:15 2015 UTC,"detail is really only for header files, especially for headers that use lots of templates. It's analogous to using the static keyword in .cpp files."
cpp,3co370,ravergames,25,Thu Jul 9 12:19:38 2015 UTC,"I really think JetBrains are missing an opportunity by not having a community edition of CLion. With Qt Creator and Visual Studio Community (11 days until 2015 comes out) there isn't really anything CLion does that would make me want to switch from something else, especially not considering I would have to pay.  They have community versions of PyCharm, IDEA, etc. so why not CLion?"
cpp,3co370,kozukumi,6,Thu Jul 9 14:37:35 2015 UTC,"Last time I used QtCreator the debugging experience was a bit lousy vs Visual Studio,  specially showing certain STL data as pointers only.   Has it improved?"
cpp,3co370,pjmlp,3,Thu Jul 9 16:27:02 2015 UTC,I used it recently (Mac version) and debugging was inferior to both XCode and VisualStudio.
cpp,3co370,jrandom,3,Thu Jul 9 17:31:55 2015 UTC,"In Qt Creator 3.4.1, I see the actual string value for both std::strings and QStrings. I can also see the number of items in a std::vector and browse through its contents and all that. It's just a (bundled) gdb plugin though, that can be used with any IDE (or without one). You could easily write a similar plugin for your own application-specific classes as well."
cpp,3co370,DoListening,2,Thu Jul 9 18:23:14 2015 UTC,"I set a breakpoint on a std::vector<int> when debugging a unit test and QtCreator popped up a graph plotting the contents. It probably would have taken me 10 seconds to find the bug by reading the code, but looking at the plot reduced that time to nothing.  How Steam uses QtCreator on Linux"
cpp,3co370,BeantraderLabs,1 point,Fri Jul 10 01:08:28 2015 UTC,How did you get that graph?
cpp,3co370,Elador,1 point,Sat Jul 11 21:11:59 2015 UTC,"Plain gdb shows the contents of std::vector.  So, it's not really a feature of QtCreator or Eclipse."
cpp,3co370,devel_watcher,1 point,Mon Jul 13 00:06:33 2015 UTC,"a graph plotting the contents   I thought you meant a graph plotting the elements. I see now that you just mean the standard text window, don't you?"
cpp,3co370,Elador,1 point,Mon Jul 13 09:05:24 2015 UTC,"No, it presented differently in each IDE."
cpp,3co370,devel_watcher,1 point,Mon Jul 13 09:50:05 2015 UTC,Really? I think the Qt Creator cdb plugin beats the pants off of visual studio for debugging Qt types. Unless you are needing specific win32 debugging (like GDI) I feel like Creator is the superior experience to visual studio.
cpp,3co370,JesusWantsYouToKnow,7,Fri Jul 10 11:51:31 2015 UTC,"I honestly don't see that as an issue. If I liked CLion better and thought it was better quality, I'd fork over $100 (or $200) tomorrow.  Developers as lucky as it is that the tools of our trade are either cheap, or payed for by our employers."
cpp,3co370,quicknir,5,Thu Jul 9 17:53:37 2015 UTC,"There's also KDevelop, which is fantastic, but I wish they'd just clean up the UI a bit."
cpp,3co370,Chodrick,2,Thu Jul 9 20:03:53 2015 UTC,"Right now there just aren't enough features to provide a value add for a Professional Edition. Now maybe if they would get remote debugging .....! Regardless, I paid up for a license because I do most of my development on Linux and it's a familiar interface after using Pycharm for over a year. I think they're going to go places with it, but they're just not there. It does feel kind of feature light right now, but it fits my environment so well with what is implemented. (Linux, CMake, and C++11)"
cpp,3co370,lurkotato,1 point,Fri Jul 10 06:36:20 2015 UTC,remote debugging   also available for free in QtCreator
cpp,3co370,doom_Oo7,1 point,Fri Jul 10 12:51:31 2015 UTC,remote debugging   also in eclipse
cpp,3co370,devel_watcher,1 point,Sat Jul 11 21:23:04 2015 UTC,"I'm not doing a feature comparison, just saying that CLion doesn't have enough features yet to strip features for a Community Edition."
cpp,3co370,lurkotato,3,Sat Jul 11 21:40:13 2015 UTC,"It just came out, it's only $100, and is currently only CMake. I'm an early adopter and I love it - I love CMake. They're working on more build tools, better parsers, and a better overall experience. That being said, I believe you will see a Community Edition in the future after early adopters have had their time to put money and feedback into something. As a business, I would certainly want to know what my paying customers are looking for before turning to my free customers for advice."
cpp,3co370,batty_alex,12,Thu Jul 9 17:30:39 2015 UTC,"You love cmake? Really?  I think cmake just happened to be the best among the worst, although I think that is no longer true any more."
cpp,3co370,banachtarski,4,Thu Jul 9 22:29:02 2015 UTC,"What is better, in your opinion?"
cpp,3co370,eric_niebler,2,Thu Jul 9 22:51:06 2015 UTC,premake5 although it's not fully released yet
cpp,3co370,banachtarski,1 point,Fri Jul 10 00:37:54 2015 UTC,i'm happy with gyp
cpp,3co370,mare_apertum,1 point,Fri Jul 10 06:14:34 2015 UTC,I like waf and premake.
cpp,3co370,Astrognome,3,Fri Jul 10 00:49:34 2015 UTC,"Maybe love is too strong of a word, you're right. I don't hate it and it doesn't give me ulcers when attempting to use it cross-platform. That's better than any other build tool (for C / C++) I've used thus far.  However, I'm open to alternatives, do you know anything better?"
cpp,3co370,batty_alex,1 point,Thu Jul 9 23:23:15 2015 UTC,Just responded to the other commenter here but I'm more partial to the new premake
cpp,3co370,banachtarski,1 point,Fri Jul 10 00:38:35 2015 UTC,"If all you've known is autotools, everything looks attractive :)"
cpp,3co370,lurkotato,1 point,Fri Jul 10 13:58:26 2015 UTC,they have the free versions to become a known brand and to sell the others making everything free would leave them rather poor
cpp,3co370,michaelKlumpy,2,Thu Jul 9 16:52:58 2015 UTC,I just find it odd they give away the product they are known most for and that costs more to buy the ultimate edition of but don't offer any kind of cut down version for a brand new product that they want to become popular. They have extremely strong competition from Visual Studio and Qt as well as other IDEs such as CodeBlocks while not as polished it is still pretty good.   Getting people using a community version of CLion would be a great way to get developers to want the same tools at work where they can sell an ultimate version for few hundred dollars a license.
cpp,3co370,kozukumi,1 point,Thu Jul 9 17:06:25 2015 UTC,"I tend to agree with you. Whatever the benefits are of having a free edition, if they apply to IDEA, the apply to CLion.  I've started a new project and decided to go with CodeBlocks. I may switch to CLion if it ends up looking like a no brainer, but inertia says I probably won't."
cpp,3co370,duuuh,-1,Thu Jul 9 18:21:20 2015 UTC,Pirate CLion?
cpp,3co370,richcracker,-4,Fri Jul 10 07:56:21 2015 UTC,Yeah I'll probably try it for a few months to see if it's any good. It's kinda funny that I make software that makes money but I don't think I'll ever buy dev software.
cpp,3co370,ThisIs_MyName,2,Fri Jul 10 09:11:31 2015 UTC,FYI the 1.1 EAP is available to evaluate without a license
cpp,3co370,lurkotato,1 point,Fri Jul 10 13:15:05 2015 UTC,Oh neat :)  Is there a time limit?
cpp,3co370,ThisIs_MyName,2,Fri Jul 10 13:17:31 2015 UTC,"Until EAP period is over. I would guess a month? The pre 1.0 EAP was pretty damn long, but this is a minor upgrade compared to releasing a new product"
cpp,3co370,lurkotato,0,Fri Jul 10 13:23:28 2015 UTC,"PyCharm, I have the full version, is awesome! However, that's because the Python IDE isn't all that great, it is plain and doesn't add much to my productivity. Mind you, it does its job great but it isn't all that. CLION is unnecessary, not even close to being great. For Cpp, I utilize Vistual Studios, which is awesome!!! Due to everything being there and being able to add more, I can't see myself ever leaving it or trying something new. I gave CLion a shot strictly because I enjoyed Pycharm and PHPStorm but it is unnecessary. If someone asked for my recommendation on a good C IDE, visual studio would be recommendation. Plus my university gave me VS back then, so I milk the shit out of it. Fucking awesome."
cpp,3co370,iloveorcas,4,Fri Jul 10 02:42:51 2015 UTC,"Does CLion play nice with the ""auto"" keyword yet? Last I checked, auto variables don't give you method/field suggestions like an explicitly typed variable would."
cpp,3co370,whoshuu,3,Thu Jul 9 15:58:35 2015 UTC,"Works in my code. You can always click the variable and press Ctrl+Q to see what type it was resolved to.  I did stumble upon some issues with operator[] though, so hopefully those will be resolved in this EAP build."
cpp,3co370,DoListening,2,Thu Jul 9 19:07:45 2015 UTC,"I'd say it works 50% of the time in my code. Sometimes I have to reload the project because an auto variable gets ""stuck"" on an old type."
cpp,3co370,lurkotato,7,Fri Jul 10 06:41:08 2015 UTC,"The parser upgrade is very welcome, but if they haven't added heuristic resolution of includes, CLion remains a giant pain to use for any project that doesn't use CMake. Their vim emulator also barely gets any love and is way behind Eclipse's."
cpp,3co370,quicknir,3,Thu Jul 9 13:54:49 2015 UTC,"Agreed. I personally decided to just drop it and continue to use Vim when I saw no will from Jetbrains to actually make the best usage of the existing tools like Clang, or compilation database. Yet another NIH syndrome IMO."
cpp,3co370,thomas-s,5,Thu Jul 9 13:57:56 2015 UTC,"I felt that way too at first, but I've seen that clang based parsing tools have a lot of issues of their own. Performance is one. Typically need some way to extract the exact compile command so they can't use heuristic resolution of includes, which means tons of time setting up your project instead of programming.  (Straps on flame shield)  I really recommend you try Eclipse with the Vrapper plugin. The vim emulation is phenomenal, and it doesn't tie you to any build ecosystem, and project setup is minimal."
cpp,3co370,quicknir,3,Thu Jul 9 14:15:52 2015 UTC,It got better with compilation database. Not need for any heuristic. Some tools like https://github.com/rizsotto/Bear allows you to generate one quite easily if you don't have a cmake based build.
cpp,3co370,thomas-s,2,Thu Jul 9 16:13:12 2015 UTC,"I've seen plenty of people use these tools, so they could use for instance rtags. It generally means extra work and extra chance of something going wrong every time you do something that changes your compile commands, which means in particular every time you add a file. Almost all of the people who used these tools eventually got stuck. If you really want tight integration between IDE and build system, then maybe all this makes sense, but personally I don't see much advantage.  Personally I wouldn't be so quick to assume that the people at Jetbrains are idiots. My guess is that they have solid technical reasons for writing their own parser. The team behind QtCreator has done all the work to use clang parsing on the backend; in fact you can use clang as the parser in QtCreator. But only for syntax checking and auto completion; it was judged to be too slow for code navigation.  Unfortunately the ecosystem for c++ development in vim is light years behind. YouCompleteMe is probably the most advanced of the lot and it's missing ton of useful features that most IDEs (including Eclipse) offer. I can't think of a single reason I'd use pure Vim over any of Eclipse, QtCreator, or CLion with their respective vim emulators, other than remote work where I'm restricted to the command line."
cpp,3co370,quicknir,1 point,Thu Jul 9 16:42:43 2015 UTC,"If you really want tight integration between IDE and build system, then maybe all this makes sense   So much this. I don't want the IDE to see a different AST than the compiler. Especially for template-heavy code."
cpp,3co370,ThisIs_MyName,2,Fri Jul 10 09:14:16 2015 UTC,If only there was some sort of specification ....... :P
cpp,3co370,lurkotato,1 point,Fri Jul 10 13:18:18 2015 UTC,"Ha fair enough.  Still, we don't always follow the standard exactly. What about system headers which have to depend on implementation-defined behavior? The compiler will parse it perfectly but a standalone parser will have to imitate all the quirks of the compiler.   I wanna follow my stack trace into system headers and back. Can CLion do that reliably?"
cpp,3co370,ThisIs_MyName,2,Fri Jul 10 13:24:40 2015 UTC,"You mean in the debugger? Or with go-to definition? Either way you can do both perfectly in Eclipse.  The problem in practice that compilers (and their frontends) have different goals that IDE parsers. Eclipse indexes template heavy code very well; I'm sure it will quit if you do heavy template metaprogramming e.g. with boost mpl. But in those situations, doing auto completion is equivalent to running the whole program... so you kind of want your IDE to quit at a certain point. Eclipse (and probably CLion) index header files only once, instead of re-indexing in every translation unit. Again, this is a massive savings in work (think about a one line change in one header file), in well written code this strategy will almost always be fine, but it's not guaranteed to be... etc.  So far the only products that are using clang entirely for indexing are ones that don't have the resources to write a good parser from scratch. I suspect it will stay that way until clang supports incremental compilation (which is a design goal)."
cpp,3co370,quicknir,1 point,Fri Jul 10 13:59:20 2015 UTC,Yeah I was talking about stepping through code and following it into headers.   btw Clang also compiles headers once and does not recompile them unless they have changed. This gives it a massive speedup over the usual. You do have to enable C++1z modules tho :)
cpp,3co370,ThisIs_MyName,1 point,Fri Jul 10 14:25:27 2015 UTC,"I have accidentally dug down into system headers when debugging in CLion, but I can't say whether it was parsing correctly or not. It was all template voodoo to me. The biggest parsing problems I've seen are with Google Test macros. I've resigned myself to letting the red squigglies live in my test code."
cpp,3co370,lurkotato,2,Fri Jul 10 13:54:53 2015 UTC,You don't have to live with red squiggles in your test code; Eclipse (and I think QtCreator) both parse that kind of code without difficulty. CLion's parser just isn't up to snuff yet.
cpp,3co370,quicknir,1 point,Fri Jul 10 17:16:48 2015 UTC,I've resigned myself to letting the red squigglies live in my test code.   0_0  Well that's a red flag if I've ever seen one :(
cpp,3co370,ThisIs_MyName,1 point,Fri Jul 10 14:22:09 2015 UTC,"I never said they were stupid :)  YouCompleteMe does the job when it comes to completion. For refactoring, true that it misses stuff, I particularly miss the macro expansion feature. However, everything considered, I'm way more efficient when it comes to development.  When I need to dig a very big code base, I sometimes fall-back on some IDE (was eclipse, but I'm considering CLion now), because the navigation and research is better (I miss an identifier database that you can look up by type, like find all member function matching XXXX."
cpp,3co370,thomas-s,1 point,Fri Jul 10 12:21:55 2015 UTC,"Even as someone who has very good vim chops, I'm still completely unable to understand people who think they're way more efficient in vim for a language like c++."
cpp,3co370,quicknir,3,Fri Jul 10 14:10:50 2015 UTC,"Its unfortunate that jet brains seems to not care whatsoever about embedded efforts, specifically low level microcontroller stuff. Platformio for example tried to get working with clion but they can't due to no developer efforts on jetbrains part via opening up the compilation process."
cpp,3co370,hak8or,3,Thu Jul 9 17:23:05 2015 UTC,Can't you just specify the alternative compiler and options in the CMake file?
cpp,3co370,steamruler,4,Thu Jul 9 21:25:41 2015 UTC,Yes.  I did this during the EAP.  Never tried debugging through a gdb server connected to jtag though.    Qtcreator handles this with a bare metal plugin.
cpp,3co370,uberkalden,3,Thu Jul 9 22:52:01 2015 UTC,I was expecting them to use Clang but I guess they think it will be fun maintaining their own buggy parser forever.
cpp,3co370,aport,1 point,Sat Jul 11 19:01:23 2015 UTC,I'm not sure if you actually read the post.
cpp,3co370,richcracker,2,Thu Jul 9 13:04:24 2015 UTC,"float a; decltype(a)(0); - Local variable 'a' might be not initialized.   Why? It's non-evaluated context, why give such warning?"
cpp,3co370,Abyxus,2,Thu Jul 9 13:08:17 2015 UTC,"That's what they are trying to say, they fixed that."
cpp,3co370,noisysignal,2,Thu Jul 9 15:56:02 2015 UTC,"No, what he posted is the warning in the fixed (1.1 EAP) version"
cpp,3co370,Elador,4,Thu Jul 9 16:01:31 2015 UTC,Will this apply to resharper C++?
cpp,3co370,TankorSmash,1 point,Thu Jul 9 23:21:36 2015 UTC,http://blog.jetbrains.com/clion/2015/07/clion-1-1-eap-starts/#comment-12123
cpp,3corbu,whoshuu,3,Thu Jul 9 15:44:43 2015 UTC,An asynchronous library would have been nice. Shameless self promotion. The problem with is that it is not really efficient though and do not offer too much control on the connection (cancelling an operation is quite hard).
cpp,3corbu,thomas-s,2,Thu Jul 9 16:22:29 2015 UTC,Very nice library! I was actually looking around to a simple http server library to hook up as the backend of my test suite. I settled on mongoose but I'm certainly not married to it.  My library is async! There are some example calls in the tests!
cpp,3corbu,vinipsmaker,3,Thu Jul 9 16:28:31 2015 UTC,"I was actually looking around to a simple http server library   Try my shameless self promotion.  I'm going to add easier to use abstractions once I prove the core set of abstractions is correct. And by proving the core is correct, I mean passing on the Boost review.  Easy to use features that I want to add after the review:   Request router. Cookies & sessions. Easier POST support.   Even if you're not interested in using the library, be sure to leave your opinion on the Boost mailing list when the review happen, then we can know what is good/bad about the library design."
cpp,3corbu,ZMeson,5,Thu Jul 9 21:33:54 2015 UTC,Question: Does the library support https?  Recommendation: I don't like the name boost.http if this is strictly for servers.  Maybe boost.httpserver or boost.http.server.  Then we could have boost.httpclient or boost.http.client in the future.
cpp,3corbu,vinipsmaker,3,Fri Jul 10 03:57:25 2015 UTC,"Question: Does the library support https?   Yes, but I have written no examples.  You can just use a SSL socket and you're good to go.   Recommendation: I don't like the name boost.http if this is strictly for servers. Maybe boost.httpserver or boost.http.server. Then we could have boost.httpclient or boost.http.client in the future.   This same library could support a low-level http client in the future. It's just that I want to focus on HTTP servers first."
cpp,3corbu,thomas-s,2,Fri Jul 10 05:14:48 2015 UTC,"I would not qualify it as simple ;)  IMO, the problem of a lot HTTP library out there is that they try to implement everything whereas sometimes you just want a request parser, response generator and connection pooler. It is especially true when you want to do a simple rest server.  For such use case, Boost.http already looks too big and some part too low. IMO everything related to socket should be as abstracted as possible, and having a read status to manage or accept connection it not something that you want to do yourself.  However, I like the string_ref usage. This is something I've been considering but given it is not yet really common, I preferred to wait a little bit."
cpp,3corbu,vinipsmaker,1 point,Fri Jul 10 12:12:35 2015 UTC,"I would not qualify it as simple ;)   Ok   sometimes you just want a request parser, response generator and connection pooler   I disagree about the user wanting a request parser. It's difficult to use a parser correctly. I use the joyent's request parser currently and I had to write a lot of tests to get it right. And the documentation is barely enough. There are many events you just don't want to handle. A request producer would be more appropriate.   IMO everything related to socket should be as abstracted as possible   Thanks for the feedback."
cpp,3corbu,vinipsmaker,1 point,Fri Jul 10 15:12:20 2015 UTC,"Thanks for the suggestion. I'll try to give your library a whirr soon to get a feel for it, and throw in a couple comments when I have a better idea of your library. Good luck in your review!"
cpp,3corbu,thomas-s,1 point,Fri Jul 10 11:53:31 2015 UTC,Great. Thank you.
cpp,3corbu,thomas-s,2,Fri Jul 10 15:13:11 2015 UTC,"Ha my bad, sorry I missed it :) Your async is a bit dangerous though. You don't offer any control to avoid too many thread to be spawned. Why do you want to force a copy for the async function ? You should let this decision to the library user."
cpp,3corbu,ThisIs_MyName,1 point,Fri Jul 10 12:01:28 2015 UTC,"You're absolutely right, there are no library controls over how many threads are spawned. That's a good feature request! Maybe v1.1 (it's at like pre alpha v1.0 right now, just missing proxy support). Right now I just let the C++11 implementation handle thread pooling, since there is some internal pooling in std::async calls.  Where do I force a copy of the async function? I think there's copy elision happening here, but correct me if I'm wrong."
cpp,3corbu,ThisIs_MyName,2,Fri Jul 10 12:08:05 2015 UTC,Why don't you forward the arguments as they are given ?
cpp,3corbu,ThisIs_MyName,1 point,Sat Jul 11 14:09:05 2015 UTC,"Oh, I see what you're saying. I think the reasoning is the same reason why async makes copies of lvalues by default -- it's exceedingly dangerous to hold direct references inside closures. I think you're right though, there should be an opt-out mechanism like there is here. I'll explore this in a future release."
cpp,3corbu,vinipsmaker,2,Sun Jul 12 18:46:19 2015 UTC,"Aww why a wrapper around libcurl? If it was plain C++ (or boost etc), I would have switched from POCO."
cpp,3corbu,nerdandproud,2,Fri Jul 10 07:35:29 2015 UTC,"Mostly because I was familiar with libcurl and not boost asio (that's what you're suggesting I use right?). It's an interesting thought, and it's totally possible to replace the backend of my interface with something like that. The interface proper makes no references to curl at all, so it can get swapped out for something else."
cpp,3corbu,nerdandproud,3,Fri Jul 10 11:46:45 2015 UTC,"Interesting, do you think it makes sense to have multiple backends like Boost, POCO, and curl?   Right now, this is how I use the Twitter streaming API with POCO:   int main(int argc, const char * argv[]) {     Poco::Net::initializeSSL();     Poco::SharedPtr<Poco::Net::PrivateKeyPassphraseHandler> pConsoleHandler = new Poco::Net::KeyConsoleHandler(false);     Poco::SharedPtr<Poco::Net::InvalidCertificateHandler> pInvalidCertHandler = new         //Poco::Net::ConsoleCertificateHandler(false);         Poco::Net::AcceptCertificateHandler(false);     Poco::Net::Context::Ptr pContext = new Poco::Net::Context(Poco::Net::Context::CLIENT_USE, """", """", """", Poco::Net::Context::VERIFY_RELAXED, 9, false, ""ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH"");     Poco::Net::SSLManager::instance().initializeClient(pConsoleHandler, pInvalidCertHandler, pContext);      Poco::URI uri(""https://stream.twitter.com/1.1/statuses/filter.json"");     HTTPSClientSession cs(uri.getHost(), uri.getPort());     HTTPRequest request(HTTPRequest::HTTP_POST, uri.getPath(),HTTPMessage::HTTP_1_1);     Poco::Net::HTMLForm params;     params.set(""track"", ""Greece"");     Poco::Net::OAuth10Credentials oauth(""-snip-"", ""-snip-"", ""-snip-"", ""-snip-"");     oauth.authenticate(request, uri, params);     request.write(std::cout);      params.prepareSubmit(request);     std::ostream& to_endpoint = cs.sendRequest(request);     params.write(to_endpoint);      HTTPResponse response;     std::istream& rs = cs.receiveResponse(response);     response.write(std::cout);     for(;;){         std::string line;         std::getline(rs, line);         handle_tweet(line);     }      return 0; }   A little messy huh?  :(  The silver lining is that POCO takes care of OAUTH1"
cpp,3corbu,nerdandproud,2,Fri Jul 10 11:55:40 2015 UTC,"Oh god...I'm not familiar with POCO so that looks like gobbledygook to me :P.  I'd love to support multiple backends, I think it's something I definitely want to move toward down the line. I wrote this library up cause at work we were getting frustrated working with libcurl, and we wanted something really simple to make requests with. We were in the process of transitioning a python codebase to C++ for embedded systems, and wanted a requests for C++, so this was born.  But yeah, libcurl is nicely decoupled from the interface so if there's enough people clamoring for a separate backend, I can try to put in some time to learn and implement them. Of course, this being open source, any help is welcome.  Edit: OAUTH support sounds swell, it's definitely in my plans"
cpp,3corbu,Zakkor,2,Fri Jul 10 12:13:15 2015 UTC,"Oh god...I'm not familiar with POCO so that looks like gobbledygook to me :P.   You and me both. The only part that matters is params.set(""track"", ""Greece""); which gets news about Greece and eventually trades greek stocks based on the news :P     Edit: OAUTH support sounds swell, it's definitely in my plans   A sane OAUTH implementation would be amazing!"
cpp,3corbu,ThisIs_MyName,2,Fri Jul 10 12:24:01 2015 UTC,"I'd love to support multiple backends   I wouldn't suggest you to go with this approach. You'd lose the ability to extract a lot from these frameworks if you have to support multiple backends.  In Boost.Asio, you have a lot of control over the executors and you pretty much choose which tasks to handle in which threads and how many threads to use. Even communication among threads is possible. You handle when to start new tasks and you can postpone a lot of work if you detect your system is within a high load scenario. This kind of stuff is not something I think you'd support with a multiple backend library, because you'd basically hide all the libraries interfaces (and its strengths)."
cpp,3cok8x,CuddlyKittens11,44,Thu Jul 9 14:51:24 2015 UTC,"Performance is not the issue.  The reason you should change it is because there should be one source of truth for each fact in the program.  If somebody comes along later and changes one of them without changing all of them, then that introduces a bug, and your goal is to make it impossible for a bug like that to happen."
cpp,3cok8x,Rhomboid,18,Thu Jul 9 15:35:19 2015 UTC,"The ultimate way to settle these issues is to use https://gcc.godbolt.org/. It shows you the assembly for whatever code you put in, with whatever compiler and flags you choose. You can write two functions, one where you cache it, one where you don't, and look at the assembly output directly. Don't be intimidated if you don't know assembly, the basics are pretty simple and you don't need to know much to draw useful conclusions in some cases (like, these two functions produce identical assembly doesn't require a lot of experience to interpret :-) )."
cpp,3cok8x,quicknir,9,Thu Jul 9 15:27:12 2015 UTC,"Or you know, run gcc -S yourself."
cpp,3cok8x,tending,1 point,Fri Jul 10 03:45:59 2015 UTC,"Sure, this is just convenient, especially for snippets. The color feature is especially nice."
cpp,3cok8x,quicknir,2,Sat Jul 11 13:44:40 2015 UTC,What a neat tool.  I just tried it:https://goo.gl/E4Xmqi  Doesn't seem like it caches it because there are eight calls to divl in testNotCached() versus one in testCached.
cpp,3cok8x,quicknir,3,Thu Jul 9 15:38:02 2015 UTC,You don't have any optimization flags on. Once you turn on optimization it caches.
cpp,3cok8x,sbabbi,13,Sat Jul 11 13:46:53 2015 UTC,"It all comes up to the alias-analysis. The compiler must be able to prove that the value of x does not change inside each function call. If x is a local variable and you do not take its address, it is trivial, and I would expect it to be optimized."
cpp,3cok8x,antiprosynthesis,-1,Thu Jul 9 17:35:42 2015 UTC,Finally a correct answer.
cpp,3cok8x,acwaters,3,Fri Jul 10 08:53:20 2015 UTC,Run GCC or Clang with the -s option to find out!
cpp,3cok8x,matthieum,8,Thu Jul 9 15:02:53 2015 UTC,"With Clang, I generally prefer the LLVM IR output rather than the assembly one. LLVM IR is pretty readable, and since it's the optimizer it already shows whether things were optimized or not."
cpp,3cok8x,Meefims,8,Thu Jul 9 16:58:23 2015 UTC,"Compilers are pretty smart. In general, you don't need to worry about helping them out.  That said, from a code maintainability perspective I would definitely create a constant local to store the value of x / 2. That way I can give it a meaningful name and I can change it to x / 3 without touching so many lines, should that ever be needed."
cpp,3cok8x,o11c,5,Thu Jul 9 15:04:39 2015 UTC,"Compilers are smart when they are smart, and really dumb otherwise."
cpp,3cok8x,ForeverAlot,5,Thu Jul 9 20:03:40 2015 UTC,This is an important point. There are a few good talks by Chandler Carruth that revolve around compilers being much dumber than we often think.
cpp,3cok8x,mttd,3,Thu Jul 9 20:42:15 2015 UTC,"Agreed.  Independently of performance, SSOT / DRY violations look problematic per se."
cpp,3cok8x,staticassert,3,Thu Jul 9 15:14:17 2015 UTC,Dealing with code like this is so horrifically bad for every reason other than performance.
cpp,3cok8x,ferruccio,2,Fri Jul 10 01:55:59 2015 UTC,Modern C++ compilers have gotten really good at optimization. Whether or not you pass in a temporary value (which should probably be const) depends on whether or not those parameters actually represent the same logical value. If they do and are thus likely to change to the same way in future updates then you assign them to a temporary value. If they just happen to be the same now but are not related and will change independently then stick to the current form.
cpp,3cok8x,o11c,3,Thu Jul 9 17:25:23 2015 UTC,"This is called ""common subexpression elimination"" by the way. It only works on pure expressions of course."
cpp,3cok8x,MartenBE,2,Thu Jul 9 20:04:28 2015 UTC,"Eitherway, using a variable like halfOfX seems a lot more readable than filling in x / 2 each time and less prone for accidental errors.  It is in my vision much better to ask yourself ""How can I make this code easier to read and maintain"" than ""will the compiler optimize this""  (except in situations where speed is extremely important, but even in that case is trusting in the compiler often not the main may to improve speed)"
cpp,3cok8x,r3v3r,1 point,Thu Jul 9 15:01:05 2015 UTC,Compilers are so smart they will even convert the division to a bit-shift if x is an integer :)
cpp,3cok8x,hotoatmeal,3,Thu Jul 9 15:10:10 2015 UTC,"Only for unsigned ints. For signed, it could be: (x<0?x+1:x)>>1, but that usually isn't profitable."
cpp,3cok8x,mark_99,2,Fri Jul 10 05:13:21 2015 UTC,"It is profitable as it can be transformed in to (x+(x>>31))>>N, which is way cheaper than an idiv (and given super-scalar architectures, a negligible cost over the unsigned case). This is exactly what modern compilers will do. Try it:  volatile int x = 5; foo(x/2);  mov dword ptr [rsp + 4], 5 mov eax, dword ptr [rsp + 4] mov esi, eax shr esi, 31 add esi, eax sar esi"
cpp,3cok8x,sakarri,1 point,Fri Jul 10 14:10:07 2015 UTC,"No they won't since that would produce incorrect results due to rounding.  -3 / 2 is supposed to equal -1, but using bit shifting you'll get -2.  If you want performance over correctness, then you have to explicitly do the bit shifting."
cpp,3cok8x,detrinoh,3,Thu Jul 9 18:17:26 2015 UTC,"Yup, and even then it's implementation defined behavior.  As far as correctness goes, I've found that I've always wanted round towards negative infinity rather than round towards 0."
cpp,3cok8x,darthpjb,1 point,Thu Jul 9 20:53:59 2015 UTC,"and using MSVC at least, it does indeed prove to be true."
cpp,3cok8x,darthpjb,1 point,Wed Jul 15 11:45:28 2015 UTC,"Also, does it say in the standard what direction rounding should be? Is there a ""correct"" way of rounding a negative value?  If you cannot define what correct is, there is no incorrect."
cpp,3cok8x,iAntonSPB,-3,Wed Jul 15 11:52:23 2015 UTC,void func1(double y) {   x += y; }
cpp,3cok8x,grout_nasa,-4,Thu Jul 9 20:26:38 2015 UTC,Smart enough not to put in extra commas.
cpp,3cok8x,lano1106,-6,Thu Jul 9 22:35:26 2015 UTC,"IMHO, this is scary how smart they have become. One reason for using C/C++ was that you had total freedom over what the code was doing. It is not true anymore, the compiler may even change the intent of the code in order to optimize. Here is an example of that: https://lists.archlinux.org/pipermail/arch-general/2013-May/033531.html"
cpp,3cok8x,quicknir,8,Thu Jul 9 17:59:02 2015 UTC,"Probably the killer point of C++ nowadays (as opposed to C) is not so much to spit out some exact sequence of assembly, but simply to present the maximum amount of information possible at compile time so the compiler can be smart. Static polymorphism, tagged dispatch, etc, all work on this concept."
cpp,3cok8x,doom_Oo7,5,Thu Jul 9 21:18:08 2015 UTC,undefined behavior according to the ISO C standard
cpp,3cok8x,lano1106,-9,Thu Jul 9 18:55:27 2015 UTC,"totally correct but in 90s early 2000, the programmer was the boss. If you wanted to go in undefined behavior because you knew better than the compiler about the hardware, it was possible."
cpp,3cok8x,RedAlert2,14,Thu Jul 9 22:48:32 2015 UTC,"That doesn't make any sense. If you know more than the compiler about optimizing code, add an asm block to your program. Utilizing UB is asking the compiler to make code for you that it has absolutely no requirements on what to do."
cpp,3cok8x,doom_Oo7,6,Fri Jul 10 01:19:43 2015 UTC,"For your projects sure, but please don't inflict this on the ones who will come after you."
cpp,3cok8x,orost,2,Thu Jul 9 22:53:56 2015 UTC,"There's no way out of that. Even assembly is somewhat high-level these days. x64 supposedly has 16 GP registers, but real proccessors have hundreds and don't care about which specific one the machine code asks for - they allocate space from the pool as they please."
cpp,3cok8x,Elador,1 point,Thu Jul 9 18:33:44 2015 UTC,"So are you saying there's kind of an ""interpreter"" or ""program"" running on the CPU that reads machine code, translates it somehow and then executes the instructions? So it can do something completely different from what the instructions in the assembly code say? It's not executing the machine instructions directly anymore?"
cpp,3cok8x,orost,10,Thu Jul 9 23:25:57 2015 UTC,Yeah. It can be actual code (microcode) or hardwired. Modern CPUs are enormously complex and do all kinds of things to improve performance. Like execute instructions in a different order than they appear in code or do calculations with missing data by guessing it and backtracking if it turns out the guess was wrong.
cpp,3cok8x,afjw0ge9h,2,Thu Jul 9 23:38:08 2015 UTC,scary
cpp,3cok8x,newmewuser4,1 point,Fri Jul 10 07:10:31 2015 UTC,Welcome to the fantastic world of Out-of-order execution!
cpp,3cok8x,newmewuser4,1 point,Wed Jul 22 00:11:50 2015 UTC,"I see no problems there: Shit in, shit out."
cpp,3cpnih,toothkiller,4,Thu Jul 9 19:43:48 2015 UTC,Have a look at Boost.Proto.
cpp,3cpnih,rabidb,2,Thu Jul 9 20:42:51 2015 UTC,That is it. You rock
cpp,3cjmph,mttd,10,Wed Jul 8 12:44:23 2015 UTC,"Question: if we're going to the trouble to embrace a standard for our minimum integer definition, why use a signed integer as the default?  Better yet, why leave it up to ambiguity and reader misinterpretation out of context?  Why not use u_int32_t instead?"
cpp,3cjmph,ericanderton,3,Wed Jul 8 14:09:19 2015 UTC,Partially this is because Google's internal style guidelines very strongly discourage the use of the unsigned integer types.
cpp,3cjmph,gruehunter,2,Thu Jul 9 03:24:38 2015 UTC,"Interesting, do you know why?"
cpp,3cjmph,BenjaminSisko,0,Thu Jul 9 04:55:19 2015 UTC,"Less things to know about, I suppose."
cpp,3cjmph,Gotebe,1 point,Thu Jul 9 05:13:00 2015 UTC,ITYM uint32_t (a standard type). But that might suffer the same issues; if a size greater than 232 is wanted then it would be silently truncated.  size_t should be used.
cpp,3cjmph,OldWolf2,4,Thu Jul 9 01:18:20 2015 UTC,Isn't uint64_t more appropriate then?
cpp,3cjmph,BenjaminSisko,0,Thu Jul 9 04:54:53 2015 UTC,"I think this is one of the first things that would be done right if a redesign was possible, but due to backwards-compatibility, it isn't possible to change it."
cpp,3cjmph,suspiciously_calm,6,Thu Jul 9 00:25:02 2015 UTC,"Checking for implicit type conversions (-Wconversion, -Wsign-conversion, and -Werror) also catches these errors."
cpp,3cjmph,uxcn,16,Wed Jul 8 23:40:52 2015 UTC,"I've been working on embedded systems for a few years (moving between 16 & 32 bit devices), and my takeaway from that is always explicitly declare your types.  No int, no float, but explicitly declare them as u32, f32, etc.  Eliminates surprises about data type sizes changing on different platforms."
cpp,3cjmph,Whitt83,16,Wed Jul 8 15:35:15 2015 UTC,"Doesn't help with this issue and doesn't really work well in general.  Different architectures have different memory limits, for example on x86 a vector<char> can have 232 elements and on x86_64 it can have significantly more.  So do you use a u32 to represent the size of the vector<char> or a u64?  The correct answer, typically is to use an std::size_t but even that is technically incorrect.  The technically correct but never used in practice solution is to use vector<char>::size_type.  So the issue is complicated whether we like it or not.  There is no simple and general purpose solution to the problem including explicit types."
cpp,3cjmph,sakarri,5,Wed Jul 8 16:39:58 2015 UTC,"Is a size? std::size_t  Is a distance between 2 iterators? std::ptrdiff_t  Is an index? unsigned  Am I serializing it to network/file? (u)int_**_t. (And handle somehow the case where the conversion loses data).  Technically you are right, you should use Container::size_type instead of size_t. But I do not know of any implementation where the two are different."
cpp,3cjmph,sbabbi,11,Wed Jul 8 20:08:54 2015 UTC,"Technically you are right, you should use Container::size_type instead of size_t. But I do not know of any implementation where the two are different.   The two are different on segmented memory architectures.  So for example x86 processors provide segmented addresses using physical address extensions.  This allows one to access up to 64 GB of RAM even on a 32 bit processor (Windows Server 2003).   Is an index? unsigned   unsigned defaults to unsigned int on many common platforms including Windows, meaning if you're on x86_64, you will be unable to index into a vector<char> beyond the first 4 GB."
cpp,3cjmph,sakarri,6,Wed Jul 8 20:22:20 2015 UTC,"If your index is bound by memory then it should be size_t, not unsigned (which can have a limit as small as 65535)."
cpp,3cjmph,detrinoh,2,Thu Jul 9 01:09:37 2015 UTC,"index should be ptrdiff_t or some other signed type. I always use p[-1] to refer to the ""previous"" element of current iterating position in an array, since p[x] is simply a syntactic sugar of *(p+x)"
cpp,3cjmph,cjxgm,1 point,Sun Jul 12 04:55:57 2015 UTC,Is an index? unsigned   Why unsigned?
cpp,3cjmph,StackedCrooked,0,Fri Jul 10 14:47:27 2015 UTC,auto to the rescue!
cpp,3cjmph,hotoatmeal,11,Wed Jul 8 17:33:59 2015 UTC,"auto doesn't cover a huge number of use cases.  auto index = ???; v[index] = 'a';  ...  void some_function(???auto??? i, char v) {   my_vector[i] = v; }  ...  struct MyIterator {   private:     auto my_index???; };"
cpp,3cjmph,sakarri,9,Wed Jul 8 17:52:36 2015 UTC,"It will also introduce surprises when migrating to a new platform. Suddenly, uint32_t is not large enough to hold the size of an array on platform X but offers poor performance on platform Y.  Fixed size types are also plagued by implicit integer casts. uint32_t * uint32_t is definitely defined behavior. Right? Right?  Using fixed types has advantages and disadvantages."
cpp,3cjmph,Tulip-Stefan,5,Wed Jul 8 16:56:11 2015 UTC,"Full Disclosure: I work on the Rust compiler, but I'm just pointing out an interesting decision it made relating to this, not making a value judgement.  Rust's approach to dealing with this is that it has only two platform dependent integer types: usize/isize which are pointer sized integers, unsigned and signed respectively. The rest of the integer types are a specific width. The idea being that most of the time you can use a fixed size integer, but in cases like indexes, buffer sizes or similar, you have the appropriate integer type for it.   Sure it doesn't necessarily account for everything, but it's at least well-defined."
cpp,3cjmph,Aatch,4,Wed Jul 8 23:35:37 2015 UTC,"Unfortunately, there is a real penalty to this on ARM.   Arithmetic on the narrow width types is significantly slower than on the native word width.  The C99 types int_fastNN_t are provided for exactly this case.  There is also a good case for a separate {u}intptr_t, too - for the segmented machine category.  size_t is wide enough for any single object, while intptr_t is large enough for any pointer.  There is a real difference on the segmented memory machines.  Finally, you also need an integer type which is a narrow as addressable memory.  In C this type is 'char', and people often think it is equivalent to {u}int8_t.  However, some conforming implementations do not provide int8_t at all - their narrowest addressable memory is a 16-bit integer!"
cpp,3cjmph,gruehunter,2,Thu Jul 9 03:23:19 2015 UTC,"Unfortunately, there is a real penalty to this on ARM.   Arithmetic on the narrow width types is significantly slower than on the native word width.  The C99 types int_fastNN_t are provided for exactly this case.   I'd hope that the optimiser could handle that. While obviously that's a bit of a cop-out it should be the kind of thing a modern optimising compiler can do.  As for the rest of your points... Well, yeah. It's difficult to balance making stuff easy-to-use for the common case with portability concerns.  Oh, and Rust's usize/isize types are approximately equivalent to C's uintptr_t/intptr_t."
cpp,3cjmph,Aatch,3,Thu Jul 9 06:02:59 2015 UTC,I'd hope that the optimiser could handle that. While obviously that's a bit of a cop-out it should be the kind of thing a modern optimising compiler can do.   Enabling this optimization is exactly why signed integer overflow is UB.
cpp,3cjmph,o11c,2,Thu Jul 9 07:38:49 2015 UTC,I think that Rust could benefit from the least and fast types from <cstdint> as well.
cpp,3cjmph,detrinoh,1 point,Thu Jul 9 01:05:06 2015 UTC,That's a perfectly sensible trade-off and one that makes sense on a great deal of architectures.  Like you said it won't account for everything but it's often times better to simply put your foot down and standardized based on simplicity rather than trying to accommodate every single possibility.  Java only has a 32-bit signed int type available to index into arrays and yet the world keeps on spinning.
cpp,3cjmph,sakarri,1 point,Thu Jul 9 01:22:14 2015 UTC,"I think this issue, together with countless other issues like this, the fragility of a C program.  In the long run, the programming language C has done a lot of harm.  I know what you will tell me, that is the programmer's fault and not the language's fault etc. Ok, it's the programmer's fault, shouldn't we provide the programmer with tools that save him from himself then? if programmers are easy to make mistakes that can potentially cost billions of dollars, then we should improve the tools and shield programmers from themselves to the max degree possible."
cpp,3cjmph,axilmar,1 point,Thu Jul 9 10:03:27 2015 UTC,What's your solution then?
cpp,3cjmph,sakarri,-2,Thu Jul 9 21:19:57 2015 UTC,Replace C/C++ with a better language in the same domain.
cpp,3cjced,meetingcpp,3,Wed Jul 8 10:45:44 2015 UTC,"I would still like to see a spinlock in the standard (yes, I know, I can easily write one with std::atomic_flag). I've heard all the arguments against spinlocks, but the truth is that there are some operations that simply don't need the overhead of a fullblown mutex but can't be realized as atomic operations. Operations on a doubly linked list for example."
cpp,3cjced,noisysignal,-1,Wed Jul 8 22:32:44 2015 UTC,"I've heard all the arguments against spinlocks, ....   Then I'd like to hear how you respond to them, because, simply put, the whole point of a mutex is to avoid the even greater overhead of a spinlock, which includes restarting & pausing a thread repeatedly, if the lock is not available."
cpp,3cjced,ggchappell,8,Thu Jul 9 00:10:59 2015 UTC,"What overhead are you talking about? I'm speaking of holding the lock for no longer than a couple of nanoseconds to update one or two references or perform some quick calculation. This is where spinlocks shine and where they beat a mutex right out of the water (so much that I know of at least one pthread implementation that spins the thread a bit trying to acquire a mutex before actually yielding it and giving up getting it any time soon).  The biggest argument against spinlocks is that they waste performance if they guard complex calculations that take a long time and have high contention. In that case it's better to play nice and give up the CPU time to another thread that can potentially perform work during that time. But what that really means is that, with always in programming, you should pick the right tool for the job, there is no perfect mutex that works in all circumstances. It's not an argument against spinlocks that they are not suited for guarding every critical section."
cpp,3cjced,noisysignal,3,Thu Jul 9 00:23:17 2015 UTC,"no longer than a couple of nanoseconds   Hell, oftentimes even less than that.  I think a large reason why spinlocks are disliked is that they are misapplied often. They are only good for when multiple threads that can actually execute concurrently (i.e. on separate cores or CPUs) need to synchronize data. If there are more threads than cores, then it isn't so good."
cpp,3cjced,mebob85,3,Thu Jul 9 01:14:01 2015 UTC,"A mutex is an abstract data structure rather than a particular implementation.  Spinlocks are a type of mutex that are implemented purely in user-space using atomic ints.  The type of mutex you're describing would be implemented using OS based primitives.  In fact, the advantage of a spinlock is it avoids the overhead that potentially comes from making an syscall and forcing a context switch if you only intend to lock a region for a very short number of cycles.  The reason to avoid a spinlock is because in practice OS based mutexes perform a short spin of their own before suspending a thread which makes spinlocks only really relevant on platforms that don't have strong support for synchronization primitives."
cpp,3cjced,sakarri,3,Thu Jul 9 01:50:55 2015 UTC,Spinlocks can be used to sync threads until something is finished. They are useful if that thing only needs to be done once or infrequently since atomic reads are cheap.
cpp,3cjti8,drac667,3,Wed Jul 8 13:47:23 2015 UTC,Most important feature - themes(since 3.4).  http://i.imgur.com/Oj0O5uA.png
cpp,3cjti8,slezyr,2,Thu Jul 9 06:34:43 2015 UTC,"I've just noticed how QT Creator 3.4 doesn't suggest C++11 code anymore. The previous one was working fine, with he std-c++11 flag"
cpp,3cjti8,blackibiza,1 point,Wed Jul 8 17:26:57 2015 UTC,I think it would help to narrow down which feature of C++11 doesn't get suggested.  A bug report with a small example would help even more ;)
cpp,3cjti8,slezyr,2,Wed Jul 8 20:51:35 2015 UTC,Can you vote for this bug?  I really hate it. QtCreator can auto-complete smart pointers but don't do this because of this bug.
cpp,3cjti8,doom_Oo7,2,Thu Jul 9 06:47:14 2015 UTC,I think that the more general bug is that QtCreator doesn't really support variadic templates...
cpp,3cjti8,blazar0112,1 point,Thu Jul 9 08:08:08 2015 UTC,It troubles me too. I'm glad that they fix decltype and std::unique_ptr in this version.
cpp,3cjti8,blackibiza,1 point,Sun Jul 12 12:10:35 2015 UTC,"Well, I don't get any suggestion for C++11 (no async, lambdas, smart pointers). The previous version works marvelously"
cpp,3cjti8,MsEtheldreda,2,Tue Jul 14 18:27:32 2015 UTC,Does anyone know when Qt Creator is going to switch to generating QBS project files instead of QMake?
cpp,3cjti8,no1msd,2,Wed Jul 8 19:41:21 2015 UTC,"QBS? Oh noes, what is that? I thought they would make CMake their official build system..."
cpp,3cjti8,doom_Oo7,2,Wed Jul 8 21:33:16 2015 UTC,Especially given that CMake works very well and CMake + Qt is used by major projects :(
cpp,3cjti8,MsEtheldreda,1 point,Thu Jul 9 08:06:09 2015 UTC,http://blog.qt.io/blog/2012/02/15/introducing-qbs/
cpp,3cjti8,quicknir,1 point,Wed Jul 8 23:36:10 2015 UTC,"I expect people will think I'm being a jackass, but... I can't believe Qt people are getting this excited over scroll bar highlights. Eclipse has had this feature for years, and configurable to the nth degree. When I click on a variable for instance, it shows read and write occurrences in two different colors on the scroll bar. Same with warnings, errors, etc.  This sort of thing makes me wonder how much actual investigation people with ultra strong opinions on IDEs have really done. People will tell you that they hate X but love Y, and then cite something great that Y can do, but already actually exists in X. I see this stuff all the time and it drives me bananas."
cpp,3cjti8,Monfico,3,Fri Jul 10 14:19:35 2015 UTC,"Well, I personally never saw someone saying that his/her favorite IDE was X because it had scroll bar highlights. I think it is not just a matter of what features X or Y have. It's about the overall experience. For example, Eclipse has a great set of features, but it just feels too much sluggish and cluttered to me, while Qt Creator feels snappy and lightweight (even though it is now that lightweight)."
cpp,3cjti8,quicknir,0,Fri Jul 10 17:23:47 2015 UTC,"Of course, an IDE feeling sluggish is a good reason not to use it, and while I don't have that problem, I don't know what your setup is. I do know that many people that have this issue have never spent 5 minutes modifying their eclipse.ini; it defaults to only giving Eclipse 300 megs of ram which results in a very sluggish app as its always swapping.  As far as feeling cluttered, the view is extremely customizable with a minimum of effort; so I'm not sure what exactly you mean.  It's the same way I've heard Eclipse people say that Eclipse can search for any type in the codebase by name (when comparing to QtCreator). If they had used QtCreator for more than 5 minutes, they'd know it has extremely similar functionality. Just want to be clear that this attitude flows in all directions: between IDEs, from IDE to vim/emacs and back, etc."
cpp,3cmdrx,gold328,4,Thu Jul 9 01:05:28 2015 UTC,"There's a reason this site exists.  I quickly developed strong feelings about it as well, as its own C++ syntax parser would fail on not-so-complicated stuff."
cpp,3cmdrx,TheBlackElf,1 point,Thu Jul 9 09:05:41 2015 UTC,Haha fair enough
cpp,3cmdrx,ChatFrais,7,Thu Jul 9 10:44:18 2015 UTC,Sorry but Eclipse for C++ is one of the worst choice. If you are on windows and dont need GCC go to Visual Studio Community Edition 2015 (or the 'old' express 2013) because it's the best debugger availaible.  If you need Linux or GCC choose QtCreator or Codeblock. The only one I've not used yet is Clion but I'm sure it's better than Eclipse too.
cpp,3cmdrx,darthcoder,-5,Thu Jul 9 08:49:53 2015 UTC,"Qt is based on Eclipse. Eclipse is really showing its age I think. Intellij is so much more responsive to use.  I'm an old school vim guy, so I use sublime text and vintageous.  I wish I could get behind visual Studio. Once they moved to managed runtime instead of native C++ it became a dog, just like eclipse. 6.0 was the last great usable version IMHO, even though it continues to improve in usability, ii feel like in 2015 I shouldn't be waiting for my computer to finish basic tasks like opening projects or creating new classes. Vs2008-2013 feels like an oil tanker where VS6.0 felt like a speedboat."
cpp,3cmdrx,drac667,4,Thu Jul 9 12:26:36 2015 UTC,Qt Creator is not based on Eclipse!  Cevelop is based on Eclipse.
cpp,3cmdrx,darthcoder,1 point,Thu Jul 9 12:50:47 2015 UTC,"You are correct, I'm confusing Qt Creator with BBRY Momentics, which does a lot of what QtCreator does."
cpp,3cmdrx,STL,13,Thu Jul 9 20:29:47 2015 UTC,"Visual Studio's Community edition offers a first-class development environment on Windows (2015 RC is available now, with 2015 RTM on July 20, and the setup team has sworn that upgrading from RC to RTM will be supported). Or if you want an installer-free environment, my MinGW distro is available. In no event would I recommend Eclipse or Cygwin for C++."
cpp,3cmdrx,TemplateRex,6,Thu Jul 9 05:03:37 2015 UTC,"Eclipse works just fine with your MingW distro. If you develop on multiple platforms, a consistent IDE is convenient. QtCreator is a good lightweight alternative to Eclipse though."
cpp,3cmdrx,quicknir,0,Thu Jul 9 07:12:34 2015 UTC,"QtCreator is not lightweight compared to Eclipse. This seems to be one of those ""facts"" that everybody knows but nobody has measured. On my Fedora box, QtCreator uses 3 gigs of memory, while Eclipse uses 2, even though my JVM settings allow it to use more."
cpp,3cmdrx,drac667,1 point,Thu Jul 9 13:56:11 2015 UTC,"Just tested with the CMake project I'm working on a Windows 7 64bit with lots of RAM:    IDE Private Bytes Working Set    Visual Studio 2013 251.716 K 283.936 K   Eclipse Luna 4.5 (CDT 8. 7) 356.468 K 245.664 K   Qt Creator 3.5 beta1 226.008 K 213.240 K    Screen shot from Process Explorer here.  RAM usage is not everything, the responsiveness of the editor when you type and so on."
cpp,3cmdrx,quicknir,1 point,Thu Jul 9 15:46:43 2015 UTC,"First of all, these projects are way too small for these numbers to be meaningful. I had nearly 10 times the level of  memory consumption. Using 220 or 350 megs of RAM is irrelevant; gmail uses more than that.  Second, I didn't say anything about windows. There's about a million possible sources of discrepancy between my results and yours.  The main point of my claim is not so much that I think Eclipse is more efficient than QtCreator, my point is that ultimately they're both comparably big and bulky IDEs, which is understandable because they're both trying to do something extremely hard (parse C++). A 10% difference in memory usage either way is irrelevant. Actually, even the 1 gig difference I cited is basically irrelevant. The difference is that for about the same resource costs, Eclipse does a much better job.  I haven't had any issues with responsiveness of the editor with either QtCreator or Eclipse."
cpp,3cmdrx,dakotahawkins,3,Thu Jul 9 16:33:25 2015 UTC,"Just to chime in:  I ""used"" eclipse for C++ at my last (embedded linux) job, probably because I guess I couldn't seriously learn vim/gdb fast enough or well enough.      It sucked balls. The Visual Studio IDE (any version, as far back as 2005) beats eclipse or similar (traditionally java) IDEs hands down at C++.       If you want a full-featured C++ IDE and it's at all possible to use Visual Studio, use it."
cpp,3cmdrx,STL,2,Thu Jul 9 05:59:22 2015 UTC,Downloading VS community as I type this. Thanks for the help.
cpp,3cmdrx,STL,1 point,Thu Jul 9 10:50:42 2015 UTC,I have installed Visual Studios but C++ is not included in the languages I can pick from when starting a new project. My only options are C# and Visual Basic. How do I add C++ to my visual basic?
cpp,3cmdrx,STL,1 point,Fri Jul 10 12:34:01 2015 UTC,"You have to select C++ during installation. I believe that you can rerun the installer to perform a ""repair"" and choose different options."
cpp,3cmdrx,quicknir,1 point,Fri Jul 10 16:28:40 2015 UTC,"Extra question: you installed 2015 Community RC, right? (VC should have been enabled by default in RC; the change to make it disabled by default was done for RTM, which is 10 days away from shipping. So we're a little confused as to how you got into this state.)"
cpp,3cmdrx,devel_watcher,1 point,Fri Jul 10 17:58:55 2015 UTC,I ended up reinstalling it and it asked me something along the lines of which language I wanted to start off with and I was able to select from every language. Now when I go to start a project it allows me to go between all supported languages. Not sure why it didn't let me do this the first time. But thanks for the help.
cpp,3cmdrx,megagreg,1 point,Fri Jul 10 18:28:55 2015 UTC,"Cool, glad to hear it works now."
cpp,3cmdrx,cpp_dev,5,Fri Jul 10 18:56:31 2015 UTC,"Every time an IDE convo comes up, I notice the same trends with regards to Eclipse. Then I realized Eclipse is very similar to c++:   From the internet, you'd get the idea it's terribly unpopular and disliked, but it has enormous real world usage It's unintuitive and hard to learn compared to its competitors, but extremely powerful and featureful Many people use old versions of it, and don't realize how much it has improved Many of the people complaining about it have never learned to use it to its full potential   By all accounts, Visual Studio is amazing, so I'd probably suggest using that on windows. On Linux, it's improved tremendously in the last couple of years and has been the best option for a while in any reasonably objective comparison. Maybe the newest CLion version will surpass it, at least for CMake projects."
cpp,3cmdrx,benfitzg,2,Thu Jul 9 14:03:06 2015 UTC,"Eclipse works great. Things I like:   Navigation/SyntaxColoring: indexer is almost as smart as the compiler to the level of class members/functions and some templates (for at least 5-7 years, I think). Forward and reverse call tree (kind of related to navigation). Automatic code formatter. Renaming anything. Lots of places to stick external tools: like CMake build, UI rearrangement scripts, some weird remote debugging sequence, etc. AutoCodeFormatter/Navigation/SyntaxColoring understands C++14. AutoCodeFormatter/Navigation/SyntaxColoring understands Qt.   (only Qt C++ part, I believe; the QML part may enjoy AutoCodeFormatter/Navigation/SyntaxColoring/Refactor of the js-language-plugin, but there is no link to the C++).   One unrelated huge little thing: when on Linux, the second copy-paste buffer can be enjoyed (the middle-click one)."
cpp,3cmdrx,devel_watcher,1 point,Sat Jul 11 21:04:58 2015 UTC,"Switch to the internal cdt builder. It's in the options somewhere near the top of the compiler settings tree.  If you really need to use makefiles, make sure you can find make on the command line. You need the cygwin bin on your path.  Edit: I just reread the error, and it wasn't what I thought, but might be closely related. Do you actually have the header file installed in cygwin? Also did Eclipse detect cygwin correctly when you made the project? You may need to add the include path in the compiler settings."
cpp,3cmdrx,net_goblin,1 point,Thu Jul 9 05:09:34 2015 UTC,"Eclipse is bad for C/C++ development. If you have freedom to choose an IDE stay away from Eclipse, I work in automotive and here they have some 6 years old Eclipse somehow glued with plugins (because Eclipse is such an extensible IDE and it's FREE) to work with C code, you can't change anything in it, nor upgrade it, because 'if it works, don't change anything'. For me CodeBlocks and CLion are pretty lightweight cross-platform solutions for an IDE (I used CB with wxWidgets for desktop apps), also for cross-platfrom and Windows you might want to try MSYS2 as shell environment."
cpp,3cmdrx,afjw0ge9h,3,Thu Jul 9 09:18:20 2015 UTC,I have many years java dev (now cpp hence reading this). Eclipse is also imho terrible for java.
cpp,3cmdrx,jiahaowoo64,1 point,Thu Jul 9 10:49:07 2015 UTC,"Okay, I work in telecommunication and here they have a VC++ 6. I'm not joking. And you can't do anything about it because of the same reason.  So, ""I figured out what's wrong with life: It's other people."" (Scott Adams)"
cpp,3cmdrx,drac667,1 point,Sat Jul 11 21:13:59 2015 UTC,"Another vote for QtCreator from me. A bonus of it is, it can use both a GNU toolchain as well as a VS toolchain, which I personally find really great."
cpp,3cmdrx,Borisas,-2,Thu Jul 9 12:14:43 2015 UTC,just use linux.
cpp,3cmdrx,drac667,0,Thu Jul 9 08:54:17 2015 UTC,"Have you added both the JRE and JDK paths to your environment variables. Another cause could be you installed the wrong version of eclipse, make sure you installed Eclipse CDT or the CDT plugin if you already have a version of Eclipse"
cpp,3cimvf,Teknoman117,7,Wed Jul 8 05:07:12 2015 UTC,"So I was playing around with C++11 constant expressions today and got the c++ compiler to generate hashes (using MurmurHash 2) for constant strings. Was a pain because the only thing you can do in constant expression functions is direct computation off parameters (i know its constant for the inputs, but no temporary variables) and the only control flow you get is the conditional operator and recursion (no loops or if/else, switch, etc.) (EDIT: in C++11, C++14 relaxes these rules but MSVC is barely getting c++11 support)  Output: Hash of ""Does a set of all sets contain itself?"" = -2163680713539448014  Snippet from generated assembly:      .type _ZL11aStringHash, @object     .size _ZL11aStringHash, 8 _ZL11aStringHash:     .quad -2163680713539448014   Useful for when you have a bunch of strings known at compile time (names of parameters) and you need an efficient way / constant comparison time of using them in a map, etc. You can have the compiler generate the hashes so you don't have to do them at runtime."
cpp,3cimvf,ohell,16,Wed Jul 8 05:07:58 2015 UTC,You can use it to implement switch on strings.
cpp,3cimvf,p2rkw,6,Wed Jul 8 07:15:39 2015 UTC,"Neat! I think it is an error to have multiple case clauses with the same constant, so I expect you would get a compile time error if there are collisions (rather than unexpected behaviour).  This is technique eminently useable I shall directly proceed to do so :)"
cpp,3cimvf,theICEBear_dk,4,Wed Jul 8 12:53:56 2015 UTC,So nice. I really liked llvm::SwitchString but your implementation definitely beats it with simplicity and efficiency.
cpp,3cimvf,more_exercise,2,Wed Jul 8 09:21:37 2015 UTC,This could be very useful. Thanks for posting
cpp,3cimvf,Ozwaldo,1 point,Wed Jul 8 10:43:42 2015 UTC,Is there any recourse if the hash of the input accidentally collides with the switched constant?
cpp,3cimvf,vlovich,1 point,Wed Jul 8 18:06:14 2015 UTC,crap that is cool
cpp,3cimvf,SushiAndWoW,3,Mon Jul 13 15:42:40 2015 UTC,"Neat trick.  Are you aware that C++14 introduced generalized constexpr which lifts the restriction on temporary variables, loops, if/else etc?"
cpp,3cimvf,Sify007,4,Wed Jul 8 06:16:58 2015 UTC,"An advantage of OP's code is that it will work with VC 2015. (They've announced support for C++11 constexpr for RTM, but not C++14)"
cpp,3cimvf,MontagFTB,4,Wed Jul 8 06:45:21 2015 UTC,"Yeah I'm totally aware of that.  Bumped into it plenty of times working on this.  And as stated by SushiAndWow, a particular company's C++ compiler is barely getting complete support for C++11.  I'm on Linux, but I wanted my project to be able to be compiled by any C++11 compiler."
cpp,3cimvf,TheQuietestOne,2,Wed Jul 8 07:26:30 2015 UTC,"Not exactly a new idea - http://www.gamasutra.com/view/news/127915/InDepth_Quasi_CompileTime_String_Hashing.php The constexpr is a natural ""modern"" way to do this. C++14 gives you this. It's also a bit unfortunate that C++11 is in this weird spot that you can almost do without tricks, but not quite."
cpp,3ckkmc,epidemicz,11,Wed Jul 8 17:11:19 2015 UTC,"There is an amazing website with such a documentation: cppreference.com. It is a wiki (written by users, so not 'official'), but quite a high quality and up-to-date.  You can read in online or download it in several formats for offline use."
cpp,3ckkmc,encyclopedist,12,Wed Jul 8 18:05:13 2015 UTC,"Is there any particular reason we don't have xml documentation in the standard library?   Yes: the reason is that “the standard library” isn’t a code library. It’s a description in the C++ standard of the features that must be fulfilled by a code library to implement the standard library.  Different compilers ship with different standard library implementations (and some implementations come without a compiler). Different implementations also use different documentation.  In the C++ world, the de facto standard for inline code documentation is Doxygen, not Microsoft’s XML comments, and that is supported by a large number of tools.  The implementations shipping with GCC and clang — libstdc++ and libc++, respectively — both come with Doxygen comments that are usable by a large selection of IDEs."
cpp,3ckkmc,guepier,12,Thu Jul 9 16:57:41 2015 UTC,XML? Don't see the connection between the quality of the documentation and the format.
cpp,3ckkmc,devel_watcher,1 point,Wed Jul 8 20:11:34 2015 UTC,"By xml documentation, I mean this:  http://i.imgur.com/bnjdgQo.png"
cpp,3ckkmc,sbabbi,10,Wed Jul 8 20:29:04 2015 UTC,Any decent IDE will provide you with documentation that is written just before the function declaration. I do not know why anyone would use XML to document some code when there is a de-facto standard (doxygen) that does his job quite decently.
cpp,3ckkmc,frog_pow,1 point,Wed Jul 8 20:57:57 2015 UTC,"What do you see under std::stringstream.str, anything useful that comes up?  Perhaps I'm missing something, but I only see what I posted in the original post, which are the basic types and parameter names, no explanations."
cpp,3ckkmc,Gotebe,3,Wed Jul 8 21:53:51 2015 UTC,"if microsoft bothered to comment the STL it would appear, at least with Visual Assist, I don't use VS without it so not sure what stock VS does."
cpp,3ckkmc,doom_Oo7,8,Wed Jul 8 22:28:44 2015 UTC,"What you call ""xml documentation"" is a .net convention to produce one, and is used with .net languages.  What you have shown on the screen has no necessary connection to xml.  You use VS and want better code insight (which hou call intellisense because that's what Microsoft calls it) from the IDE.  You should ask Microsoft why they didn't do something. Other environments did do it. It's not a question of C++ nor xml.  :-)"
cpp,3ckkmc,raevnos,1 point,Thu Jul 9 05:27:46 2015 UTC,"Okay, can you recommend or perhaps tell me what environment that you use which will give me code insight on the standard lib?"
cpp,3ckkmc,rifter5000,4,Thu Jul 9 07:20:51 2015 UTC,With QtCreator you can install cppreference help files which will bring you the complete documentation when pressing F1 on a symbol. http://en.cppreference.com/w/Cppreference:Archives   There are even pre-made package for Arch Linux.
cpp,3ckkmc,raevnos,3,Thu Jul 9 08:21:12 2015 UTC,"There's lots of documentation of the standard library. Are you just wanting your development environment to pop up the description of a function or class for you? That sounds nifty, but what does it have to do with xml?"
cpp,3cegu1,cntx,3,Tue Jul 7 07:30:11 2015 UTC,Thanks I needed that.
cpp,3cegu1,yesterdaybacon,-9,Wed Jul 8 01:30:45 2015 UTC,"Nice talk, but it would have been much better with vim. ;)"
cpp,3cegu1,nunudodo,1 point,Tue Jul 7 20:54:58 2015 UTC,Bo Qian's tutorials he uses vim.
cpp,3cegu1,slezyr,1 point,Wed Jul 8 01:17:58 2015 UTC,"To each his own - I can see how you can be very efficient with all the shortcuts (once you know them), clang-complete and the-like, but I would not want to work without a graphical debugger. (particularly not without Image Watch)"
cpp,3ccfjo,mttd,8,Mon Jul 6 20:45:01 2015 UTC,that guy is a beast
cpp,3ccfjo,noplace_ioi,6,Mon Jul 6 22:20:31 2015 UTC,Indeed. I was surprised to see he is a bus driver and not a professional programmer.
cpp,3ccfjo,kozukumi,4,Mon Jul 6 23:57:10 2015 UTC,I just read that as well. It's really incredible.
cpp,3ccfjo,Elador,4,Tue Jul 7 00:31:19 2015 UTC,"In case anyone is curious, here's his self-promo with him driving his coach/bus? https://www.youtube.com/watch?v=3bIcbnDXSRg  I'd like to meet this guy, he's very intriguing, and also a hint of robot."
cpp,3ccfjo,chazzeromus,3,Tue Jul 7 01:19:31 2015 UTC,"I'm kind of glad he's not a professional programmer, I'd hate having to pick his stuff up after him! Absolute beast though, love his voice."
cpp,3ccfjo,ElFeesho,4,Tue Jul 7 16:35:49 2015 UTC,He is actually the reason I decided to learn to program. I don't want to be a professional programmer but I still want to be good at it. Seeing this guy do all this crazy stuff just for fun gave me a massive boost. He made me realise there are amazing programmers who just do it for fun not for a career.
cpp,3ccfjo,kozukumi,3,Tue Jul 7 19:41:30 2015 UTC,"His videos are strangely addictive, the code he writes is very difficult to follow but at the same time has a certain elegance to it.  His Doom like 3d engine thing was a memorising watch and his explanation of algorithm use is great and comical. I need to brush up on my vector mathematics!"
cpp,3ccfjo,ElFeesho,3,Tue Jul 7 22:11:32 2015 UTC,It was this video that made me realise I can be a programmer without having to have a job as one https://youtu.be/_vbMJ3-LuFk?t=5m54s  I have included the time from the relevant comments made in the video but the whole video is an interesting watch!
cpp,3ccfjo,kozukumi,4,Wed Jul 8 00:22:16 2015 UTC,Brilliant. He also sounds like a the younger brother of the G-Man from Half-Life.
cpp,3ccfjo,dgendreau,4,Tue Jul 7 02:13:49 2015 UTC,Bisqwit is the owner and proprietor of http://tasvideos.org/
cpp,3ccfjo,rogueyoshi,9,Tue Jul 7 03:27:43 2015 UTC,"Was. I created TASVideos in 2003 or so, and gave it out in 2009. Glad I'm still remembered though :-)"
cpp,3ccfjo,Bisqwit,3,Tue Jul 7 08:09:33 2015 UTC,<3
cpp,3ccfjo,rogueyoshi,1 point,Tue Jul 7 16:16:40 2015 UTC,Love your  videos. Hopefully one day I can get to your level.
cpp,3ccfjo,FordDent42,5,Wed Jul 8 21:58:18 2015 UTC,"At first I was like, ""what..."" and then I was like, ""woah..."". This dude is a beast. The MR Rodger's of hobbyist programming."
cpp,3ccna9,1osb,12,Mon Jul 6 21:41:54 2015 UTC,"I used to work on a product with extensive plugin capabilities. Plugins that run in your process are a bad idea in the long run because they incur high compatibility and security costs. For example, if a plugin is running in the same process as your application then it can do anything your application can do and should be able to read and modify data elsewhere in your process. It is difficult to create a useful threat model in which your process may be attacking itself. Similarly you may run into other problems: What if someone writes their plugin in .Net 3 and another in .Net 2? Both plugins cannot be loaded at the same time because only one version of the .Net Framework can be loaded per process before 4. What if the plugin crashes a lot? Your product will take the blame. Etc.  An alternative is to have a host process which loads a single plugin and which communicates with your main process. So many concerns are resolved with this architecture and there are several advantages. For example, you can now change the protocol between your application and the host at will and still maintain compatibility with older plugins. You may be able to detect problematic plugins and report issues to the appropriate ISV, etc."
cpp,3ccna9,Meefims,1 point,Tue Jul 7 00:38:46 2015 UTC,"Uhm yeah, I guess I'll just bundle them with the application and release in different consecutive versions as new features. Thanks!"
cpp,3ccna9,AntiProtonBoy,1 point,Tue Jul 7 08:10:40 2015 UTC,Know of any good resources and tutorials on writing a plugin system in C++?
cpp,3ccna9,tongari95,2,Tue Jul 7 08:35:17 2015 UTC,http://apolukhin.github.io/Boost.DLL/index.html
cpp,3ccna9,jbandela,2,Tue Jul 7 09:54:50 2015 UTC,"Take a look at cppcomponents https://github.com/jbandela/cppcomponents  It allows you to write C++ classes that can be used by different compilers and standard libraries. It also makes writing plugins pretty easy. You can use std::string, std::vector, std::tuple and such in your interface as well as exceptions."
cpp,3ccna9,Digitus_Impudicus,1 point,Tue Jul 7 15:02:40 2015 UTC,This looks impressive! Any examples of this library in use in the wild?
cpp,3ccna9,jbandela,0,Tue Jul 7 20:52:33 2015 UTC,"I have helped somebody else to use this as a plugin system, though I do not know what the final software was.  If you are interested, I would be happy to help you and answer any questions you may have about this, Just PM me."
cpp,3ccna9,Digitus_Impudicus,1 point,Tue Jul 7 21:21:11 2015 UTC,"The use case I have in mind is  a 'universal' database access program that at runtime can load database specific dlls (plugins) (e.g. MySQL, SQLite, Postgress etc.) that are compiled and linked to their respective native APIs separately."
cpp,3ccna9,jbandela,0,Tue Jul 7 22:35:04 2015 UTC,cppcomponents  would be perfect for this. If you write a regular c++ abstract base class for this it is pretty easy to convert that to cppcomponents that can work across dll boundaries
cpp,3ccna9,doom_Oo7,1 point,Wed Jul 8 00:28:56 2015 UTC,"For GUI apps with Qt : http://doc.qt.io/qt-5/plugins-howto.html , from ""The Low-Level API: Extending Qt Applications"""
cpp,3ccna9,notsure1235,1 point,Tue Jul 7 19:19:54 2015 UTC,"How would one implement this cross platform without exposing the  user to unholy issues and IPC?  I would create a dummy exe that handels the IPC, and the user then supplies his plugins as .dll/.so files, which is loaded and used by the dummy exe ... thoughts?  What about python plugins? And .net ... how does a native program load .net libraries anyways?"
cpp,3ccna9,Meefims,1 point,Tue Jul 7 12:27:30 2015 UTC,"The host application would be the dummy executable and plugins would still be dynamic libraries. The plugins themselves don't need to perform any IPC.  As for cross platform considerations, I don't know. I haven't made a cross platform plugin system."
cpp,3ccna9,notsure1235,1 point,Tue Jul 7 16:23:50 2015 UTC,"How do you run dynamic libraries without hosting them in some sort of ""dummy"" process`?"
cpp,3ccna9,Meefims,1 point,Tue Jul 7 18:37:44 2015 UTC,The host application is the dummy process.
cpp,3ccna9,c0r3ntin,2,Tue Jul 7 19:34:01 2015 UTC,"Does is really matter ?  In order to install a malicious or non-endorsed plugin a ""hacker"" would have to  * Have a preexisting access to the user computer, in which case you are doomed  * Make the user download the plugin from a third party site, either voluntarily or by phishing.  * Hack the store, if you provide one.   The last case must be taken into account, there is little to nothing you can do for the other two.  On windows, it may be possible to use some api to check a binary signature prior to installation ( and all your binaries should be signed anyway).   But keep in mind that a hacker could very well install a modified version of your application that skip the check. and the average joe won't be concern if the certificate of the main application changes.  Mac come to increasingly long lengths to prevent applications to augment themselves after the initial installation, specifically over security concerns.  Your best bet is to educate your users.   Plugins often make for a great architecture, don't be to much concerned over client-side security / piracy."
cpp,3ccna9,Gotebe,2,Tue Jul 7 09:13:46 2015 UTC,"You are mixing two separate aspects.  Piracy protection has nothing to do with plugins running in-process or in any other way.  That said, piracy protection is a scale, it all depends whom you're protecting your thing from. At this point, I don't think you know who that is, you're fishing for opinions here.   I don't want to use authenticity checking via some web service, because I can't guarantee that the clients will be connected to the internet, and anyway I don't want to be obliged to run a server   Forget good piracy protection then.  The thing is, when you give your thing to users, they have total control over it. You can't control their system, and you wouldn't want to - who do you think you are to do that? And if so, they will beat your protection, whatever that is."
cpp,3ccna9,sazzer,1 point,Tue Jul 7 14:16:56 2015 UTC,"Since you say ""The plugins don't have to be necessarily written in C++"", why not implement the plugins in a scripting language that runs in a sandbox in your main application. There are many such languages that you can easily plug in, like Lua, Python, Ruby, Javascript, and so on.  That way you can control what the plugins can and cannot do much easier, and build in some form of piracy control into the delivery mechanism if you so desire. I can think of a few ways that you can achieve this, ranging from a simple bundled manifest that contains license information all the way up to a cryptographic signature that proves that the plugin was purchased for the same user as the application."
cpp,3cavtc,Nomto,5,Mon Jul 6 13:55:34 2015 UTC,"lock() throws if the unique_lock instance it's called on currently owns the mutex (§30.4.2.2.)  That's not the same as the mutex being locked — it could be held by a different thread, but it must not be held by this instance — so that wording does need to be updated, yes."
cpp,3cavtc,Rhomboid,4,Mon Jul 6 14:34:13 2015 UTC,"It is not an error. The ctor of unique_lock will lock the mutex; if you want to call unique_lock::lock explicitly, you must call unique_lock::unlock before that.  Unless the underlying mutex is recursive, in which case unique_lock::lock will not throw an exception, if the calling thread already owns the mutex."
cpp,3cavtc,velco,2,Mon Jul 6 14:25:00 2015 UTC,"The ctor of unique_lock will lock the mutex; if you want to call unique_lock::lock explicitly, you must call unique_lock::unlock before that.   This much is clear, but cppref' seems to imply that lock() will fail if the mutex is locked at all (e.g. by another thread), even when the calling thread does not hold the lock."
cpp,3cavtc,tavianator,1 point,Mon Jul 6 14:31:45 2015 UTC,"In both cases they are using ""already locked"" to mean ""locked by the current thread.""  This isn't very explicit but it is fairly common anyway."
cpp,3cavtc,TiagoRabello,2,Tue Jul 7 02:49:45 2015 UTC,"That's an error, the exception is thrown only if the mutex was locked by this unique_lock, as it would cause a deadlock. The relevant section of the standard is 30.4.2.2.2 of n4431:   void lock();  1 Effects: pm->lock()  2 Postcondition: owns == true  3 Throws: Any exception thrown by pm->lock(). system_error if an exception is required (30.2.2).                system_error with an error condition of operation_not_permitted if pm is 0. system_error with                an error condition of resource_deadlock_would_occur if on entry owns is true."
cpp,3cavtc,velco,1 point,Mon Jul 6 14:17:31 2015 UTC,"Actually, the exception will be thrown if the caller thread owns the mutex and it is non-recursive, regardless of whether it has obtained ownership via this instance of unique_lock or by some other means.  Otherwise, yes, the wording of the article at cpprference.com is erroneous."
cpp,3cavtc,TomSwirly,0,Mon Jul 6 14:33:45 2015 UTC,Did you try it out?  The best proof is a test.  You can do it here and link to it...
cpp,3cavtc,o11c,2,Tue Jul 7 02:19:34 2015 UTC,"Concurrency problems are really unreliable to solve with the ""it seems to work"" approach."
cpp,3cact1,tongari95,13,Mon Jul 6 10:14:05 2015 UTC,"As long as the RAII wrapper only owns a single resource, it doesn't matter how much extra state you need to store to represent said resource."
cpp,3cact1,vlovich,0,Mon Jul 6 11:39:56 2015 UTC,"The Device-Resource relationship in the example is more like container-iterator relationship, and people typically don't use RAII for iterators, as everything would be cleaned up by the container eventually, but during the container's lifetime, if you forget to remove the unused elements from the container, it's still considered resource leaking. I'm just wondering if it's a good discipline to use RAII in such cases..."
cpp,3cact1,TiagoRabello,7,Mon Jul 6 13:37:48 2015 UTC,This is not a good analogy as iterator don't own any resources and as such you can't leak by letting an iterator fall out of scope.
cpp,3cact1,vlovich,2,Mon Jul 6 13:53:18 2015 UTC,"Yes, still good discipline to use RAII.  Anytime you find yourself having begin/end, create/destroy, etc kind of APIs, it's a very good candidate for using RAII as it ensures you never forget.  Where it's of more questionable benefit is when your begin/end is across scope (i.e. you have a higher-level begin/end); even then I would say use it."
cpp,3cact1,Pronouns,8,Mon Jul 6 17:38:49 2015 UTC,"If Device*isn't being looked after, how do you do it in the example you've given? Assuming the same device creates and destroys the resource, it would make sense that the device owns it."
cpp,3cact1,ericanderton,3,Mon Jul 6 10:59:45 2015 UTC,"In fact, if the same Device must be used to destroy the resource, then you most certainly would want an RAII wrapper to maintain that relationship.  To do otherwise would be to invite disaster."
cpp,3cact1,ericanderton,3,Mon Jul 6 13:33:39 2015 UTC,"At a minimum, you want a wrapper to contain both handles, in order to do this job.  I would recommend wrapping the call to CreateResource inside the RAII constructor if at all possible, in order to keep the potential for error as low as possible.  You could even provide smart-pointer like semantics to keep it nice and transparent.  That said, a more correct pattern would be for the Resource to contain its Device handle since they appear to be coupled.  If Resource instances are permitted to move from Device to Device, provide mutators for that job.  I don't know what kind of API or library you're using, so that may not be possible; in such cases, an RAII wrapper is the next best thing."
cpp,3cact1,STL,-4,Mon Jul 6 13:43:25 2015 UTC,"There's not a specific API I'm talking about, and don't think too further, it's very the same as container-iterator relationship - an element inserted into a container must be cleaned up by the same container. RAII for Resource* is probably not a good idea here because: 1) it duplicates the handler size (consider an iterator + a pointer to its container). 2) it may introduce another lifetime bug: if the RAII wrapper gets moved and out-lives the Device, DestroyResource will call on a dangling Device*."
cpp,3cact1,adzm,7,Mon Jul 6 14:28:47 2015 UTC,shared_ptr.
cpp,3cact1,panderingPenguin,1 point,Mon Jul 6 14:56:14 2015 UTC,"That's a valid solution to the dangling problem, but more overhead. Safety or efficiency, we have to take our poison."
cpp,3cact1,mark_99,1 point,Tue Jul 7 01:22:39 2015 UTC,You can use aliasing shared_ptrs when lifetimes are related - this might apply to some situations you are envisioning.
cpp,3cact1,quicknir,2,Wed Jul 8 15:42:13 2015 UTC,"I'm not sure I'm understanding this. If you need the device to destroy the resource then why can you ever have a resource that outlives the device? Aren't you pretty much hosed at the point anyways, if there's nothing pointed to at the device *?  It sounds like the lifetimes of these resources and devices are related so they probably need to be coupled in some way.  Also, side note, why the hell are you worried about a single extra pointer for the device *? Unless you have tons (and I mean tons) of these resources that should be negligible in the grand scheme of your program's memory usage."
cpp,3cact1,ericanderton,1 point,Mon Jul 6 18:16:35 2015 UTC,"Something like this:  // Unique Resource handle resource_handle res; {     // Unique Device handle     device_handle dev = make_device(...);     res = make_resource(dev, ...); } // Oops, DestroyResource is called on a dangling Device*   As others have pointed out, one can use shared semantic for Device instead of unique semantic, so the dangling problem can be avoided.   why the hell are you worried about a single extra pointer for the device *   I always prefer a way to have C++ wrapper over the C API with zero overhead, if the C++ API is less efficient than the C API, it won't be attractive to the users.  Indeed, I was considering that the user may want to have tons of them form library's designer's POV (who knows your users won't?). Leaking the raw handle (i.e. Resource*) with something like unique_ptr::get and allows the construction from a raw handle seems what we can offer at best."
cpp,3cact1,encyclopedist,1 point,Tue Jul 7 01:39:44 2015 UTC,"If the Device is the actual heavyweight parent class (like say a wrapper on a D3DDevice or a CUDADevice) you might be better with weak_ptr as you don't want resources keeping the device alive after it should have been destroyed.  Another option is for the device wrapper object not to be destroyed in the C++ sense, but you call some destroy() method which releases everything but keeps the wrapper object itself alive. The the resource calls device->exists() before accessing it (or if that's an efficiency concern and it shouldn't really happen anyway, then assert on it instead).  In this case we're assuming that owned resources are cleaned up when the device is released, so the RAII class has no work to do anyway.  Also if it's a more lightweight view/handle onto the main device that doesn't acutally manage its lifetime or own its resources, then shared_ptr is ok.  BTW the manual ""device->exists()"" technique also means storing an 8-byte pointer (which you're already worrying is too big) whereas shared_ptr and weak_ptr are typically 16 bytes (but check on your compiler).  Also have a look at std::make_shared() and std::enable_shared_from_this (http://en.cppreference.com/w/cpp/memory/enable_shared_from_this) to avoid extra overhead."
cpp,3cact1,Gotebe,1 point,Tue Jul 7 12:32:33 2015 UTC,"If you're concerned that someone is going to create many resources from a single device, then you can create an RAII object supporting that specific goal, i.e. an object that encapsulates a single device and allows for the creation and management of many resources.  If they are creating many resources all from different devices, then in any case you need some way of storing and keeping track of all the devices that go with the resources, so it's not really a waste.  Your c++ API can have several different RAII objects, which fit different use cases. The same way we use both unique_ptr and shared_ptr."
cpp,3cact1,demozon,1 point,Tue Jul 7 15:29:19 2015 UTC,"if the RAII wrapper gets moved and out-lives the Device, DestroyResource will call on a dangling Device*.   Ouch.  I've learned that at some point, an application with enough object lifetimes to track converges on something resembling a GC to manage reliably.  I can easily see a setup where things are flipped around, and a Device has a list/hash/map of Resource instances to destroy upon its own destruction.  Maybe there's some smart-pointer types that can come in handy? Of course, there are innumerable permutations here, the essence of which is the fact that Device has a longer lifetime than Resource."
cpp,3cact1,afiefh,1 point,Mon Jul 6 15:24:41 2015 UTC,"As some users already mentioned here, there is such a thing: shared_ptr and weak_ptr. A shared pointer keeps track of weak pointers pointing to it, and 'notifies' them on destruction."
cpp,3cact1,Sqeaky,1 point,Tue Jul 7 14:45:27 2015 UTC,an element inserted into a container must be cleaned up by the same container   Must is a big word. What about naked or shared pointers?
cpp,3cact1,Gotebe,3,Tue Jul 7 05:34:51 2015 UTC,"If Devices have unpredictable lifetimes, wrap Device in a shared_ptr, and attach that shared_ptr to the RAII-wrapper."
cpp,3c8exs,meetingcpp,3,Sun Jul 5 21:36:58 2015 UTC,"Yes, it's novel, but the other ""real-world"" issue I see with this is that some xml files can get rather large; copying, pasting and reformatting valid xml into this form would be a real pain."
cpp,3c8exs,YouFeedTheFish,3,Sun Jul 5 23:41:14 2015 UTC,"As I thought: for a samll amount of XML, method rarely matters; for a large amount, the non-standard syntax prevents any XML tools like validation or even correct syntax highlighting.   So maybe for a large amount of small XML snippets to be maintained..."
cpp,3c8exs,elperroborrachotoo,1 point,Mon Jul 6 09:02:09 2015 UTC,"Blasien is was written with projects that generate complex XML from a memory model in mind. Schemas for ODF, DOCX, SVG, HTML, MusicXML are all non-trivial. Having a recognizable syntax and good compiler checks should make development for such projects simpler."
cpp,3c8exs,vandenoever,14,Mon Jul 6 13:16:49 2015 UTC,"how about instead of this, WE STOP USING XML! :)  (admittedly, that'll be REALLY REALLY HARD)"
cpp,3c8exs,MachinShin2006,6,Mon Jul 6 00:17:38 2015 UTC,"Sure, just give us another format that is as easy as XML to build tools and transformation processors on top of, without having to re-invent parsers."
cpp,3c8exs,pjmlp,2,Mon Jul 6 10:58:03 2015 UTC,"Nah, we need proper reflection support in C++, which would make serialisation tasks so much easier. But we won't get reflection in the standard for at least another 5 years from today."
cpp,3c8exs,AntiProtonBoy,0,Mon Jul 6 03:16:09 2015 UTC,you mean json?
cpp,3c8exs,redditor___,3,Mon Jul 6 02:07:51 2015 UTC,You can write your JSON in XML. https://www.reddit.com/r/programming/comments/h0chx/need_more_enterprise_introducing_jsonx_an_ibm/
cpp,3c8exs,armb2,2,Mon Jul 6 10:23:24 2015 UTC,How do you handle collections with Blasien? (so some sort of looping for construction?)  Imho it would be nice to show an example with some kind of list and a complemented complex type in XML that should be generated within the root-element.
cpp,3c8exs,Bolitho,1 point,Mon Jul 6 11:10:10 2015 UTC,http://www.vandenoever.info/blog/2015/07/05/literal-xml-in-c++.html#how-to-use-it shows looping over a set of inputs. This is done with a functor.  sink < div < create_paragraphs{{mylist}} > div;   There is currently no way to write a loop inside of such a statement. Suggestions on how to do that are very welcome.
cpp,3c8exs,vandenoever,1 point,Mon Jul 6 12:29:02 2015 UTC,"Hm... this is imho a common problem, but the suggested approach shadows the structure of the xml again - so the original goal fails here.  Unfortunately I cannot make a better proposal 😉"
cpp,3c8exs,Bolitho,1 point,Mon Jul 6 14:04:36 2015 UTC,"This syntax is possible with the right definition of for_each():  QString r; QXmlStreamWriter stream(&r); auto items = std::list<QString>({""A"",""B""}); XmlWriter<xhtml11::XHtmlDocument> xml(stream); using Sink = decltype(xml<html<body);  xml <html     <body         <for_each(items, [](Sink sink, const QString& text){return sink             <p                 <text             >p;         })     >body >html;   The definition of the local Sink type is needed because the lambda expression needs explicit types for its parameters."
cpp,3c8exs,vandenoever,1 point,Mon Jul 6 15:11:48 2015 UTC,"And in C++14 this can use auto in the lambda:  <for_each(items, [](auto sink, auto text){return sink"
cpp,3c8exs,vandenoever,2,Mon Jul 6 17:06:08 2015 UTC,"This is really nice, but construction of the document still seems to take place at run-time. The compile-time validation is a perk, but since the cost of construction is being incurred at run-time, I'm not sure I'm willing to pay the cost of:   non-intuitive operator overloading polluting the global namespace with names like ""p"", or else having to reference them long-hand   I use a method-based HtmlBuilder, which is used like this:  html.H1().T(""User "").T(m_dispAppUser->f_name).EndH1()     .SideEffectForm(Str(""/appadm/user/"").Add(m_dispAppUser->f_name))         .Table()             .Tr()                 .Td().T(""Name"").EndTd()                 .Td().T(m_dispAppUser->f_name).EndTd()                 .Td().EndTd()             .EndTr()   As you can see, I hate operator overloading, so my string even has Add() instead of operator+().  The run-time costs bother me, so I would love to replace this with something that would construct most of the document at compile time, but still allow construction to be dynamic where needed. I'm not sure that will be possible until some future C++ version supports constexpr string concatenation, though. :/"
cpp,3c8exs,SushiAndWoW,7,Sun Jul 5 23:36:08 2015 UTC,"polluting the global namespace with names like ""p"", or else having to reference them long-hand   There's no need for that  void yadayada() {   int somvar = somestuff();   {     using namespace blasien;     // ..   } }   See: http://www.cplusplus.com/doc/tutorial/namespaces/#using"
cpp,3c8exs,Scaliwag,2,Mon Jul 6 04:48:37 2015 UTC,"You're still bringing all the element and attribute names into the function, and there's more than just ""p"".   There's things like a, b, i, s, id, name, rel, src, and so on and so forth; and you can add more in the future.  The following might be a solution:  namespace XmlLibrary {     namespace h {         // declare HTML tags here ... }}   Then you could do this:  void yadayada() {     using namespace XmlLibrary;     XmlWriter() < h::html < h::body < ... }   That would clean up the issue somewhat...  But it still leaves the operator overloading. I mean, I tip my imaginary hat, this is nifty:  <img(src=""http://example.com/hello.jpg"",alt=""Hello"")>img   But... that's a new language. It took me a while to figure it out:  template <typename String_, const String_* Ns, const String_* Name> struct XmlTag {     ...     template <typename... Atts>     ElementStart<Self, Atts...>     operator()(Atts... atts) const {         return ElementStart<Self,Atts...>(atts...);     }     ...     AttributeNode<Self> operator=(const String& val) const {         return AttributeNode<Self>(val);     } }; ... using SrcTag = XmlTag<QString,&empty, &srcTag>; using AltTag = XmlTag<QString,&empty, &altTag>; ... xhtml11::SrcTag src; xhtml11::AltTag alt;   That's ingenious and all, but... gosh, man. Code that uses too many of these constructs becomes write-only. It's cool if a pattern like this is easily recognized and frequently used, but that's a gamble. If few people adopt this, and familiarize themselves with it, this is going to be hard for someone down the road to comprehend and maintain..."
cpp,3c8exs,SushiAndWoW,1 point,Mon Jul 6 16:05:09 2015 UTC,"Reminds me of XSMELL:  using namespace xsmell;  document doc =       _       <html>_           <head>_               <title>""XSMELL demo""<!title>_           <!head>_           <body>_               <p>""Yesssssssssssssssss!""<!p>_               <img .src(""chucknorris.png"") .alt(""sneezing eyes open"")>_ <!img>_           <!body>_       <!html>       _;  std::cout << doc << '\n';"
cpp,3c8exs,pfultz2,1 point,Mon Jul 6 15:31:43 2015 UTC,"That's an interesting alternative syntax. Thanks for the hint. XSMELL uses macros [1] to make the schema definition simpler. Compared to Blasien it has some limitations. It does not check nesting and cannot handle the use of arbitrary attributes because attributes are member functions. An alternative syntax in XSMELL that allows arbitrary attributes would be:  <img(src(""chucknorris.png""),alt(""sneezing eyes open""))>_ <!img>_   or  <img(src=""chucknorris.png"", alt=""sneezing eyes open"")>_ <!img>_   or  <img(src=""chucknorris.png"", alt=""sneezing eyes open"")>!_   [1] https://bitbucket.org/edd/xsmell/src/3551ac07c4711a87f3f70dfa703a87eee3a7e292/xsmell.hpp"
cpp,3c8exs,vandenoever,1 point,Mon Jul 6 16:25:34 2015 UTC,Anyone remembers http://web.archive.org/web/20111124194643/http://weegen.home.xs4all.nl/eelis/analogliterals.xhtml ?
cpp,3c7why,mttd,4,Sun Jul 5 18:57:54 2015 UTC,"When they vote in concepts will it be all of concepts? Or just the initial stuff?  I recall seeing some ""extra"" stuff for concepts published as separate papers, some of it looked really good."
cpp,3c7why,frog_pow,3,Sun Jul 5 19:22:16 2015 UTC,"Concepts Lite. That is, without concept maps."
cpp,3c7why,gnzlbg,2,Mon Jul 6 08:44:22 2015 UTC,Don't hold your breath waiting for concept maps.
cpp,3c7why,andrewsutton,1 point,Tue Jul 7 01:00:56 2015 UTC,"Won't do, I think they make concepts nicer to use but since the C++ ecosystem is already wired to work around this I don't know how much value can this bring in practice.   I would be more excited to see how the Open Multi Methods proposal would/could interact with Concepts Lite: foo(virtual Concept* a);, where a is then a fat pointer with the vtable embedded in the pointer."
cpp,3c7why,gnzlbg,1 point,Tue Jul 7 08:14:16 2015 UTC,"There are a lot of ""extra"" ideas around what's being proposed. But I expect that the concepts TS will undergo some changes before it becomes part of C++ proper (a TS is not part of the standard)."
cpp,3c7why,andrewsutton,3,Tue Jul 7 01:02:09 2015 UTC,"So am I reading this right in that this will both take care of the wall-of-line-noise error messages, and provide a terse syntax where you don't need the 'template <typename T>' part?"
cpp,3c7why,hgjsusla,5,Sun Jul 5 22:47:56 2015 UTC,"Well the error messages would depend on the compiler, but it should theoretically shorten that wall, as template errors could be determined farther up the call stack assuming you make appropriate concepts.  I believe that foo(auto x) is part of the proposal, so yes, you would be able to get rid of the template<typename T> part without even having to write a concept."
cpp,3c7why,Houndie,3,Mon Jul 6 03:09:17 2015 UTC,This and more. Like foo(vector<auto>)
cpp,3c7why,andrewsutton,1 point,Tue Jul 7 01:03:39 2015 UTC,"What about:   std::vector<auto> a;  // auto deduced to int foo(a);  // if foo(std::vector<int>)   This is an example more or less analogous to the following Rust code which is pretty cool:  let address = from_str(""0.0.0.0:10000"").unwrap(); server_socket.bind(&address).unwrap();   Basically from_str<ToWhichType>(str) -> ToWhichType parses a string into some type ToWhichType. Since bind(&SocketAddress) takes a &SocketAddress, the variable address is deduced to have typeSocketAddress, and thus the generic parameter of from_str is deduced to be SocketAddress. I am still amazed at this."
cpp,3c7why,gnzlbg,2,Wed Jul 15 11:47:29 2015 UTC,"Not in the Concepts TS. the auto rules are essentially unchanged. You still need an initializer for the declaration.  Although, huh. Deducing across multiple statements would be interesting. Not totally different than what we do for return type deduction in the presence of multiple return statements."
cpp,3c7why,andrewsutton,1 point,Thu Jul 16 00:54:40 2015 UTC,"Not totally different than what we do for return type deduction in the presence of multiple return statements.   Never thought about it this way, but interesting idea."
cpp,3cds9v,sandeepylp,14,Tue Jul 7 03:10:58 2015 UTC,unique_ptr <char> ptr (new char[size]);   Incorrect! This mismatches array new[] with scalar delete.  (Not to mention that the depicted example is incomprehensible; unique_ptr is not implicitly convertible to a raw pointer.)
cpp,3cds9v,STL,9,Tue Jul 7 04:39:11 2015 UTC,"Prefer make_unique to new where possible. Or if you're deliberating coding 11 and not 14, make note of that fact and at least the existence of make_unique."
cpp,3cds9v,quicknir,3,Tue Jul 7 03:59:46 2015 UTC,class ShapeFactory  {  protected:    ShapeFactory()   {    g_factories.push_back(this);   }  public:    virtual unique_ptr<Shape> Create() = 0;    virtual string getName() = 0;  };   Just stay away from C++ please.
cpp,3cds9v,rifter5000,1 point,Wed Jul 8 23:07:28 2015 UTC,"Here is a question I've seen conflicting reports on: given a vector templated on unique_ptr, with unique_ptrs created by make_unique (so, push_back( make_unique<SomeClass>( ... ) ) ), should one use push_back or emplace_back? I've read that emplace_back can leak, whereas push_back can't?"
cpp,3cds9v,flyingcaribou,5,Tue Jul 7 18:29:25 2015 UTC,"make_unique/make_shared can't leak, for both push_back and emplace_back. new T(args) won't compile for push_back (as T * isn't implicitly convertible to unique_ptr/shared_ptr). new T(args) will compile for emplace_back and can leak. If vector reallocation throws, the exception will be emitted before a smart pointer has been constructed from the raw pointer.  This is why modern code should avoid saying new as much as possible, and why I wrote up make_unique for C++14."
cpp,3cds9v,STL,2,Wed Jul 8 01:51:04 2015 UTC,"Can you give a source? It's not immediately obvious to me how either can leak. It seems to me like either way, first a unique pointer will be created as the argument to the function must fully evaluate, and then it will move construct a new unique ptr at the back of the vector.   Is there a meaningful difference between push and emplace when an copy of the contained type is what's passed?"
cpp,3cds9v,quicknir,1 point,Wed Jul 8 00:54:34 2015 UTC,Maybe it is me or my device but the example code in this article is very difficult to read.   Whatever happened to proper indentation and formatting?
cpp,3cds9v,spinwizard69,1 point,Wed Jul 8 06:41:40 2015 UTC,"This is why properly documented ownership semantics beat smart pointers. You are not only giving up total control of the object lifetime, but newcomers will mess the code anyway and it will become a monstrosity trying to be java coded in C++."
cpp,3c6ta6,grishavanika,7,Sun Jul 5 11:42:19 2015 UTC,"For these kind of questions, cppreference is a great help: http://en.cppreference.com/w/cpp/language/overload_resolution  If i can't find what i'm looking for there, i refer to the standard. It usually takes me a while to find the correct paragraph. Recently i wanted to check the exact semantics of pointer aliasing, but the word aliasing does not occur in the paragraph that describes this behavior, making it harder to find than it should be."
cpp,3c6ta6,Tulip-Stefan,14,Sun Jul 5 13:14:41 2015 UTC,/u/stl/ has made a very pedagogical series of videos on core C++ that explains this stuff in great detail
cpp,3c6ta6,TemplateRex,6,Sun Jul 5 12:20:35 2015 UTC,"Yes, I watched all his series. /u/stl/, we need more !:)"
cpp,3c6ta6,STL,19,Sun Jul 5 12:24:40 2015 UTC,"I plan to film more soon, now that I'm done with working on 2015 RTM."
cpp,3c6ta6,CUsurfer,1 point,Sun Jul 5 17:59:11 2015 UTC,This is great. Thanks for the post.
cpp,3c6ta6,Dascandy,3,Mon Jul 6 20:03:24 2015 UTC,"Program fairly-complex C++ stuff a lot and run into corner cases yourself, and be good enough at debugging & compiler-error-fixing to fix them and understand them. Then you learn."
cpp,3c6ta6,Dascandy,2,Sun Jul 5 14:42:13 2015 UTC,Program fairly-complex C++ stuff   There is one problem: I have poor imagination to come up with something complicated for yourself. Any ideas ?
cpp,3c6ta6,STL,2,Sun Jul 5 14:51:21 2015 UTC,"One that taught me a lot was making my own event class for registering callbacks. Found me a bug in GCC4.3.0 mis-parsing event<std::function<void()>> even, let alone the variadic template stuff to forward arguments, the thing with dependent base types (template class X inheriting from template class Y does not immediately get its members to access) and so on.  Reminds me, I found what I think is a bug wrt dependent bases in VS2012 and I wanted to see if it reproduces in 2015... brb :-)  Another one that was fun was making expression templates - classes & objects that store the compile-time inserted expression so that it can be actually repeatedly evaluated at runtime, plus a handle class to hold it. That makes it possible to construct arbitrarily complex runtime variables where the variable doesn't have a value, but an expression tree assigned to it. I then added the ability to put a spline function in there, or a segmented split of functions, based on a variable that I called ""time"". The result of that is that, because it's templates, it can interpolate 3D cameras, colours, positions and so on, and you can do so with smoothing functions, switchovers and you can replace the function at runtime with something else, so you get really smooth variable definitions. Fun bug in this was finding that VS2005 doesn't support having a const and a non-const copy constructor in one class - I used that to distinguish between referring to a variable by-ref or by-value (which is actually too unstable to do like that, but it's fun finding bugs)."
cpp,3c6ta6,Dascandy,2,Sun Jul 5 15:03:00 2015 UTC,"VC allows unqualified name lookup to reach into dependent bases, which it should forbid. This rule is associated with two-phase name lookup (not yet implemented) but is technically separate.  (VC will enforce the rule with the /Za compiler option, but you shouldn't use that - it's ""enable extra conformance and extra compiler bugs because these codepaths are rarely tested"".)"
cpp,3c6ta6,STL,1 point,Sun Jul 5 18:01:51 2015 UTC,So my test case is actually valid... Here it is for your reference:  struct A {   template <typename X>   struct B { static B& Instance(); };   template <typename X>   struct C : public B<X> {     void f() { Instance().Function(); }   };   static A& Instance();   void Function(); };   On GCC and Clang this just works; on Windows it resolves to the wrong Instance() and complains about the function not existing. Do you want me to send it to Connect?
cpp,3c6ta6,rifter5000,4,Sun Jul 5 18:20:57 2015 UTC,"This is the unqualified name lookup issue. MSVC will reach into B<X>, GCC/Clang won't and will then see A's Instance(). I personally wouldn't bother filing a bug (the lack of two-phase name lookup and this associated rule are a known issue, and they're on the list of things to implement)."
cpp,3c6ngf,Nephyst,22,Sun Jul 5 09:55:42 2015 UTC,"The high-perf methodology you're probably asking about (I gather, since it's popular in the gamedev community) is called ""data-oriented design"" (DOD). Personally, I see absolutely none (as in: zero) connection with RAII, though.  This has been a pretty popular (often referenced) talk:   Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf   More:   http://www.dice.se/wp-content/uploads/2014/12/Introduction_to_Data-Oriented_Design.pdf http://gameprogrammingpatterns.com/data-locality.html http://www.dataorienteddesign.com/dodmain/   Personally, I find many of the underlying principles to be solid (e.g., Mike Acton's ""where there's one, there's more than one"").  The reason is that this is just good software systems' performance engineering, relying on the classical foundations, like the trade-offs between AoS (Arrays of Structures) and SoA (Structures of Arrays) data layouts. ""Don't forget how computers work,"" basically. Courses like Computer Organization & Architecture are the right background for this.  I mean, hey, Bjarne Stroustrup states just that (and, notably, he's definitely not an opponent of RAII):   I use this example to illustrate some points, encourage thought about algorithms, data structures, and machine architecture, concluding:   don’t store data unnecessarily, keep data compact, and access memory in a predictable manner.  I emphasize the importance of cache effects. In my experience, all but true experts tend to forget those when algorithms are discussed.    https://isocpp.org/blog/2014/06/stroustrup-lists  Side-note: At the same time, again, I (personally) also think that using DOD with RAII can be perfectly fine (OTOH, 1990s-style / possibly-strawman OOP, heavy with polymorphic class hierarchies & run-time pointers chasing -- not so fine). I suspect (may be wrong) that folks who claim it ain't usually don't even bother to look at the generated assembly and/or use a profiler (and rely on ""instincts"" instead; well, that, and bad experiences with poorly optimizing compilers for consoles, may agree on that much)."
cpp,3c6ngf,mttd,3,Sun Jul 5 20:56:06 2015 UTC,This should be higher. You actually answered OPs question rather than speculate or get involved in a paradigm Holy War.
cpp,3c6ngf,jaLissajous,1 point,Mon Jul 6 01:27:02 2015 UTC,Thanks! I'll check these out.  edit: Any chance there is a video to go along with the pdf?
cpp,3c6ngf,Cyttorak,20,Sun Jul 5 21:09:51 2015 UTC,"I understand not going OOP (or going heavy OOP with deep class hierarchy) but not using RAII? A class with a destructor adds 0 overhead of what are you doing already (calling some init() and later a destroy(), close() or whatever)"
cpp,3c6ngf,Spiderboydk,-1,Sun Jul 5 11:27:27 2015 UTC,"I've heard one semi-valid argument against C++ RAII, and that is it's quite verbose; you have to type a lot (make wrapper classes) to get the effect."
cpp,3c6ngf,rdtsc,15,Sun Jul 5 12:14:03 2015 UTC,"You might have to write a few abstractions, but using them is the opposite of verbose because it's done automatically by the compiler. Also no chance to accidentally miss calling a close(), destroy() or whatever function."
cpp,3c6ngf,Spiderboydk,4,Sun Jul 5 12:22:21 2015 UTC,"I agree. I'm a strong supporter of RAII myself. This is just the only argument I've heard, which wasn't completely nonsense.  Edit: And for those who follow Handmade Hero, this is more or less the only argument Casey made against RAII. If a reactionary veteran like Casey only is able to present a single, rather weak argument against RAII, then it can't be that bad."
cpp,3c6ngf,minno,9,Sun Jul 5 13:20:17 2015 UTC,It's more typing at declarations and less typing at use. I'm fine with that tradeoff.
cpp,3c6ngf,Spiderboydk,1 point,Sun Jul 5 13:32:46 2015 UTC,Me too.
cpp,3c6ngf,elperroborrachotoo,2,Sun Jul 5 13:39:46 2015 UTC,"This is less than semi-true.   There's no requirement to wrap all functionality that applies to the resource handle - only the handle itself. which is basically creation, destruction and assignment behavior (e.g. non-copy, moving, or reference counted).   An implicit cast allows interaciton with the native API, at the risk of a buggy managed-to-raw transition. However, for most resource types, this is not much of a problem, most common is  api_destroy(rawhandle), which can be made to not work for the managed handle."
cpp,3c6ngf,Spiderboydk,1 point,Sun Jul 5 22:13:50 2015 UTC,"I agree. I too find the argument quite weak, but it's nevertheless the only argument I've heard, which I could make sense of."
cpp,3c6ngf,neet_programmer,1 point,Mon Jul 6 01:22:50 2015 UTC,"I am new to C/C++, and I've never actually programmed anything using RAII. I'm hoping to understand the pros and cons of different approaches better.  I don't think the arguments against RAII have to do with its verbosity. I've heard the argument that C++ itself is verbose and that OOP in C++ is verbose, but I have no heard that argument for RAII on it's own.  The style I was first exposed to was allocating all the memory you are ever going to use up-front, and then writing components in such a way that they never exceed those bounds. Memory is divided into permanent and temporary blocks, where temporary memory gets cleared at the start of each frame. When an object gets free'd it gets moved onto a linked list. When a new object is needed it is pulled from the free list, and if the free list is empty its allocated into next spot in the memory block. This might not be possible with every type of program, but it seems to work well for video games.  I see two downsides of RAII being worse performance due to multiple memory allocations and not knowing exactly how much memory your program is going to need. If you want to run on a Raspberry Pie or a cell phone where memory is limited, pretending you have unlimited memory seems dangerous.  Jonathan Blow makes the argument that RAII only exists because the language supports exceptions, and that exceptions are entirely unnecessary in language design. (See: https://www.youtube.com/watch?v=TH9VCN6UkyQ&t=38m15s)"
cpp,3c6ngf,neet_programmer,5,Sun Jul 5 21:27:12 2015 UTC,That in itself is not an argument against RAII since you can overload the new and delete operators to specify how allocations and deallocations are done. I develop games as a hobby and I use pool allocators for almost all objects. With overloadable new/delete operators low-level resource management is still better done with RAII.
cpp,3c6ngf,Spiderboydk,1 point,Sun Jul 5 21:54:22 2015 UTC,Does this still apply if you are using a more functional style of coding and not using OOP?
cpp,3c6ngf,Spiderboydk,4,Mon Jul 6 00:32:06 2015 UTC,"Functional as in haskell? or do you mean imperative like C?  Basically the new and delete operators can be overloaded on a per class basis so every object of that class that is allocated/deallocated using new/delete (or using smart pointers) uses the given allocation/deallocation function. Whenever you allocate an object using new it actually calls two functions, operator new, which is basically malloc, returns a pointer to a free block of memory, and then it calls the constructor. deleting an object first calls the destructor and then calls operator delete(free).  A* a = new A; delete a;   is the same as:  A* a = (A*)::operator new(sizeof(A)); //allocates some memory new(a) A; //placement new(simply calls the constructor on a memory adress) a->~A(); //calls the destructor ::operator delete(a); //deallocates the memory   Overloading the new and delete operators for a class replaces the calls to ::operator new and ::operator delete for all objects of that class.  Here is a template pool allocator that I wrote myself and use for almost everyting:  template<unsigned BlockSize, unsigned ChunkSize, unsigned NumChunks = 64> class ArenaAllocator { private:    union Block   {     Block* next;     char padding[BlockSize];     //T t;   };    Block* _memory[NumChunks];   Block* _next;  public:    void* getAdress()   {     if(_next == nullptr)       reserve();      Block* block = _next;     _next = _next->next;     return (void*)block;   }    void* getAdress(size_t size)   {     if(_next == nullptr)       reserve();      Block* block = _next;     _next = _next->next;     return (void*)block;   }    void freeAdress(void* block)   {     ((Block*)block)->next = _next;     _next = (Block*)block;   }    void reserve(uint8_t num_chunks = 1)   {     for(auto& chunk: _memory)     {       if(chunk == nullptr)       {         chunk = new Block[ChunkSize];          for(unsigned m = 0; m < ChunkSize - 1; ++m)           chunk[m].next = &chunk[m + 1];          chunk[ChunkSize - 1].next = _next;         _next = chunk;         break;       }     }     if(num_chunks != 1) reserve(num_chunks - 1);   }    void deallocate()   {     _next = nullptr;      for(auto& chunk: _memory)     {       delete chunk;       chunk = nullptr;     }   }    ArenaAllocator()   {     _next = nullptr;     for(auto& c: _memory)       c = nullptr;   }   ~ArenaAllocator()   {     this->deallocate();   } };   given that you can pool allocate all dynamically allocated objects of a certain class like this:  class Foo; ArenaAllocator<Foo, 256> foo_pool;  class Foo {   //content public:   void* operator new(size_t s)   {return foo_pool.getAdress();}   void operator delete(void* ptr)   {foo_pool.freeAdress(ptr);} };  Foo* f = new Foo; //this object will be constructed into the pool"
cpp,3c6ngf,Spiderboydk,1 point,Mon Jul 6 09:37:22 2015 UTC,Yes.
cpp,3c6ngf,Spiderboydk,4,Mon Jul 6 01:29:13 2015 UTC,"Allocating everything at startup is fine, but you can't always do that. RAII is also more than memory allocation - it can manage file handles, sockets, locks, etc. for you.  I know Jonathan Blow's arguments, and frankly I think he's a bit misguided about C++. For example, a lot of his claims regarding exceptions are misleading at best, but that's a whole other discussion."
cpp,3c6ngf,frog_pow,1 point,Mon Jul 6 01:27:46 2015 UTC,"I am intrigued by his idea that programming should be fun and aesthetic. I am interested to see where he goes with his language.  In any case, I do this there is good reasoning to look at how you might redesign programming languages that fit today better. C++ was written in 1979 and a lot has changed since then."
cpp,3c6ngf,JNighthawk,3,Mon Jul 6 05:19:46 2015 UTC,"Fun and aesthetic? Those are curious words to describe a programming language. :-)  I don't follow his project. I saw part 1 and disagreed with a lot of his reasoning, so I haven't bothered to follow the development and frankly don't take his project very seriously. I follow and enjoy Handmade Hero on the other hand because I see a raison d'être for it.  I have a lot of respect for Jonathan Blow as a game designer, but I have no respect in him as a language designer. That is a whole other field, where he has no theoretical knowledge - only practical experience. He is nothing but an experienced layman.  C++ has also changed hell of a lot since 1979. It's barely the same language anymore.  There are already dozens of ""new"" programming languages who have tried to compete with C++ by doing the same with a bit nicer syntax, and yet no-one have had a breakthrough. There is a reason why C++ has been one of the most used languages for decades. Jonathan Blows new language will just be adding to that pile."
cpp,3c6ngf,TomSwirly,4,Mon Jul 6 09:43:58 2015 UTC,"I forgot to tell you pros and cons. From the top of my head:  Pros:   Cleanup is handled automatically. You don't need to remember to clean up manually at every code branch. Helps with seperation of concerns making the code more modular and thus more clear. Works very well with exceptions. Works with all kinds of resources: memory, handles, locks, etc. You only allocate what you need when you need it and free the resources as soon as you don't need them anymore (as opposed to greedily allocate everything for the entirety of application execution).   Cons:   In some cases the setup can be a bit verbose.   There might be others I couldn't think of. People are welcome to add."
cpp,3c6ngf,JNighthawk,1 point,Mon Jul 6 01:56:46 2015 UTC,"Why on earth would RAII have multiple memory allocations? RAII has nothing to do with allocating memory.  JB's argument that it exists solely for exceptions is clueless.  You are free to not use exceptions, whilst using RAII.  Also, Rust has RAII, but no exceptions."
cpp,3c6ngf,Spiderboydk,-8,Mon Jul 6 19:05:31 2015 UTC,RAII hides performance costs. It's no longer obvious where you need to look for performance problems.
cpp,3c6ngf,JNighthawk,9,Sun Jul 5 23:03:15 2015 UTC,"You should be looking for performance problems with a profiler, which will work just as well with or without RAII.  But honestly, I don't see your argument anyway - can you give a code example illustrating your point?  For me, it makes it clearer where performance issue might be, because of separation of concerns.  A nice code sample would make your argument much clearer..."
cpp,3c6ngf,Spiderboydk,-5,Sun Jul 5 23:52:10 2015 UTC,"You should be looking for performance problems with a profiler, which will work just as well with or without RAII.   It's a lot simpler to write performant code when the costs are not hidden.   But honestly, I don't see your argument anyway - can you give a code example illustrating your point? For me, it makes it clearer where performance issue might be, because of separation of concerns.   You can no longer trivially read code and look at what it's doing. Hidden function calls in constructors/destructors/overloaded operators hinder this.  The downvotes here are why I don't bother posting or reading /r/cpp. Established best practices when working on games are suddenly controversial because people don't understand what it takes to make a AAA game."
cpp,3c6ngf,JNighthawk,4,Mon Jul 6 01:15:02 2015 UTC,"What exactly is hidden? Stack variables are destroyed when going out of scope, which is common knowledge. If an uncaught exception is thrown and propagating up the stack, the stack is unwound, which causes a bunch of function calls. Also reasonably well-known. What am I missing?  Like the AAA game industry has a perfect track record of well-performing releases. Just look at the last year and a half AAA releases and tell me again with a straight face that the industry is competent at making well-performing software.  PS: You are right about the downvoting BS. Have an upvote from me to counter it."
cpp,3c6ngf,Spiderboydk,-1,Mon Jul 6 01:42:38 2015 UTC,"Stack variables are destroyed when going out of scope, which is common knowledge.   To know if a constructor or destructor is expensive, you have to inspect every type on the stack to see if they have expensive constructors or destructors. This is much harder to do than to just look for function calls.   If an uncaught exception is thrown and propagating up the stack, the stack is unwound, which causes a bunch of function calls.   Pretty irrelevant here. Games don't use exceptions.   Like the AAA game industry has a perfect track record of well-performing releases. Just look at the last year and a half AAA releases and tell me again with a straight face that the industry is competent at making well-performing software.   You have no idea what you're talking about. The conditions programmers are required to meet for games are absurd. It's a minor miracle hitting 30 FPS on a game with a 2 year development cycle."
cpp,3c6ngf,neet_programmer,3,Mon Jul 6 06:40:03 2015 UTC,"To know if a constructor or destructor is expensive, you have to inspect every type on the stack to see if they have expensive constructors or destructors. This is much harder to do than to just look for function calls.   True, and for that reason should constructors and destructors be extremely lightweight.  Besides, the work still needs to be done, so if you put init-calls all over the place you still need to inspect.   Pretty irrelevant here. Games don't use exceptions.   Some games don't.   You have no idea what you're talking about. The conditions programmers are required to meet for games are absurd. It's a minor miracle hitting 30 FPS on a game with a 2 year development cycle.   I know. It was just a snarky comment on the fact that the AAA industry's ""best practices"" don't seem very convincing lately with games like the PC version of Arkham Knight, Assassin's Creed Unity and a dozen of other infamous recent AAA titles."
cpp,3c6ngf,JNighthawk,-1,Mon Jul 6 09:34:56 2015 UTC,"True, and for that reason should constructors and destructors be extremely lightweight.   Then you aren't doing RAII. RAII says ""if I have an object, it's valid"" - meaning your expensive initialization and shutdown needs to be done in constructor/destructor.   Besides, the work still needs to be done, so if you put init-calls all over the place you still need to inspect.   Yes, but with a function call, it's immediately obvious at the calling site that work is being done. It is not immediately obvious that work is being done when creating an object on the stack, or when it goes out of scope.   Some games don't.   I would be very surprised if you found a AAA game that used exceptions, especially one on consoles."
cpp,3c6ngf,rifter5000,1 point,Mon Jul 6 22:00:24 2015 UTC,"RAII says ""if I have an object, it's valid"" - meaning your expensive initialization and shutdown needs to be done in constructor/destructor.   Of course. I meant as efficient as possible. My point is the work has to be done no matter how it is expressed in the code.   It is not immediately obvious that work is being done when creating an object on the stack, or when it goes out of scope.   It is, when it's a part of your mindset. I literally see work when I see a stack object declaration or a closing bracket.   I would be very surprised if you found a AAA game that used exceptions, especially one on consoles.   I have gotten exceptions before, but I don't remember which game(s) it was.  I know nothing about consoles, so I take your word for that."
cpp,3c6ngf,Spiderboydk,2,Mon Jul 6 22:09:52 2015 UTC,"To know if a constructor or destructor is expensive, you have to inspect every type on the stack to see if they have expensive constructors or destructors. This is much harder to do than to just look for function calls.   A function call will not tell you much about the cost of constructing an object unless you know what that function call does. You will not get around that abstraction by not using RAII."
cpp,3c6ngf,Spiderboydk,1 point,Mon Jul 6 13:18:00 2015 UTC,A function call will not tell you much about the cost of constructing an object unless you know what that function call does. You will not get around that abstraction by not using RAII.   That's not the point. The point is that you now obviously see a function call as something you may want to inspect. You don't get that obvious flag from constructor/destructor/overloaded operators.
cpp,3c6ngf,neet_programmer,0,Mon Jul 6 22:11:15 2015 UTC,You don't get that obvious flag from constructor/destructor/overloaded operators.   You don't.
cpp,3c6ngf,Spiderboydk,3,Thu Jul 16 00:54:36 2015 UTC,"What costs?  RAII guarantees cleanup regardless of which codepath you follow exiting the scope. What the compiler generates corresponds to what you would have done manually to get the same behaviour, i.e. inserting a (possibly inlined) cleanup function call at every exit.  Are you thinking of stack unwinding?"
cpp,3c6ngf,image_linker_bot,6,Mon Jul 6 01:32:01 2015 UTC,"I think this subreddit is just fine for this. C++ is a very versatile language and there is a lot of really smart people here.  I don't know the name of those development methodologies.  Casey's ""compression oriented programming"" is not about not using OOP or RAII per se - it's a kind of agile programming, where you first make a prototype to get use cases and then figure out the best interface afterwards - i.e. anti-waterfall and anti-premature-optimization."
cpp,3c6ngf,ExcessPhase,2,Sun Jul 5 12:09:45 2015 UTC,"This is pretty much the only cs-related subreddit I follow these days because there is a much greater focus on perf and low-level stuff (within reason) than on most others, even /r/gamedev.  I think OP is thinking of a strictly low-level/high-perf sub, but this is the best one as far as I know. Having it burrowed in higher-level stuff is not a problem since the sub is slow enough as it is. And you can always learn good stuff about high-level programming as well.  whynotboth.jpg"
cpp,3c6ngf,quicknir,2,Mon Jul 6 13:23:09 2015 UTC,"As I understand /r/gamedev doesn't really focus on the gritty technical side og being a developer as they also discuss stuff like implementing achievements, marketing, finding assets, etc.  /r/cpp is fine for low-level stuff, because a lot of C++ devs care a lot about the low-level stuff."
cpp,3c6ngf,ssg2,1 point,Mon Jul 6 15:57:40 2015 UTC,whynotboth.jpg      Feedback welcome at /r/image_linker_bot
cpp,3c6ngf,jesyspa,6,Mon Jul 6 13:23:20 2015 UTC,"When I see the expression ""C/C++"" I usually go elsewhere. It is similar to asking for ""C/Z80-assembler""."
cpp,3c6ngf,oracleoftroy,2,Mon Jul 6 03:23:52 2015 UTC,"This, times a million. C++ is nearly a superset of C which is convenient on the relatively rare cases you should need to go low level. But idiomatic C++, even on embedded systems, should look extremely different from C. Programming well in one does not mean you can program well in the other. I'm not sure if the C++ and C communities agree, broadly speaking, on more issues, than the C++ and Java communities."
cpp,3c6ngf,jaLissajous,7,Tue Jul 7 15:36:41 2015 UTC,"Beware that many if not most game developers are proponents of ""C with classes"" style of coding and would say things like ""I wish it was feasible to code everything in assembly"". It has to do not only with valid technical reasons, but also with culture. For example, see this talk by Mike Acton (if you haven't seen it, I think it would be an interesting resource in the context of your question). When towards the end of the video he is asked why he is using C++ in the first place (instead of C), he doesn't really have an answer. Also, while there definitely are valid concerns about performance, a lot of this is cargo cult - I've seen quite a few people arguing for contorted style and basically for coding in C with just some syntactic sugar added to it from C++, ostensibly in the name of performance (and sometimes even readability), at the same time never bothering with profiling, not having any real grasp of assembly, writing everyting in this ""highly performant"" style instead of saving it for some critical parts of the code, etc. I would advise you to keep in mind that:   if you're interested in writing optimized code, you should have good understanding of what makes the code you write efficient and whether it's applicable in your case. I say this because I've seen lots of people, especially in gamedev, using built-in arrays instead of vectors, never using the standard library because it's ""slow"" and stuff like that - simply because they were told by somebody that ""if you want perf, never use STL"", ""programmers who care about perf only use arrays"" - that's just cargo cult; realize that a lot of the time, performance doesn't matter. If you're writing a small game or a casual game, it doesn't matter 99% of the time. If you're working on an AAA game, it still matters only part of the time; always make sure that you have some valid metrics of what you're optimizing. If it's not worth the time to have them, then it's not worth optimizing. I saw ugly ""efficient"" code that was written like that just because ""it's obviously more efficient to do it that way"". Benchmarks or it didn't happen; don't buy into the idea that game developers care about performance all of the time and are superstars in this regard. Like, for example, the XCOM remake would visibly lag on a superfast machine if the number of saves is more than N, where N is about 50-100 (I'm not sure if it was fixed later, but the game has shipped like that) - that's obviously an inefficient algorithm (and they didn't even move the loading to a separate thread), and a very visible problem, and also it's definitely an AAA game; in the context of OOP bashing, a lot of the time the OOP presented would be a strawman - crazy hierarchies with endless inheritance and every method virtual; if you limit your learning of C++ to listening to only what game devs say, you will get a very specific (and limited) view of the language. Some of them would flat-out reject a lot of C++ killer features like templates with the arguments that, in the end, amount to ""it's too hard"" (it would be presented as ""unmaintainable"", ""unreadable"", ""obscure"" and stuff like that). My feeling is that quite a few of them are not so much programmers as they are domain experts (where their domain would be things like the workings of specific hardware and knowledge of algorithms related to rendering). Basically, I'd advise to focus on the important domain-specific things (like true performance concerns) and mostly ignore their choice of language tools to get there."
cpp,3c6ngf,Triplanetary,1 point,Mon Jul 6 19:38:38 2015 UTC,"Thanks for the reply.  The arguments I have heard are to not worry about optimizing anything until you have to. They definitely talk about using performance timers when it's time to worry about performance, and the only time they jump into any assembly (as far as I have seen) is when they are trying to optimize math functions that are used quite a bit. Jonathan Blow made the point that Braid was like 80,000 of code and only about 6,000 of those lines had to be heavily optimized for performance. I think colleges and industry best practices have you doing a lot of premature optimization and in my experience I've seen a lot of overly complex code bases arise because of it.  Casey's makes a point that the thing he optimizes the most is dev time. As an example, he doesn't like to use templates because it adds increased compile time and reduces the quality of error messaging. He makes some good points, but I do enjoy understanding other views, which is why this post exists. :)  Of course the idea behind Handmade Hero is to write everything by hand, as an educational exercise. So some of what he does on the project isn't what he would do in his normal day job."
cpp,3c6ngf,quicknir,1 point,Mon Jul 6 20:48:24 2015 UTC,"I wonder, given the ""everything is a transformation of data"" approach that he advocates, what reasons (other than efficiency) there are to not use a functional programming language."
cpp,3c6ngf,encyclopedist,6,Mon Jul 6 23:26:12 2015 UTC,"Honestly, I think a lot of the arguments from game devs against RAII is coming from a vocal minority who don't really like C++ all that much and won't let the facts get in the way of their two minute hate. As a counterpoint, this series of articles from another game dev offers a positive take on C++ and rebuts some of the claims Jonathan Blow makes in his language design videos.  I know Blow (and Mike Acton, and probably Muratori, but I haven't followed his work) have a lot of valuable information to offer on the mindset you should be thinking in for high performance games, but I would caution you to take everything they say about C++ with a grain of salt. Study up on whatever feature they are criticizing, understand the C++ way better than they do, and I think you will find that C++ gives ways to solve their concerns more elegantly than they would admit, and often the feature they criticize actually doesn't have the performance implications they imply. Unfortunately, sometimes it does, so you really do have to understand the features you are using for a AAA game.  My advice for a personal project, first just make the game. Don't worry about how it performs, just push through those doubts and make it work. Make it badly and learn from it. Examine what didn't work, read up about other techniques and improve it. Failing is the best way to learn."
cpp,3c6ngf,quicknir,3,Mon Jul 6 23:34:27 2015 UTC,"Edit: On further consideration I still don't know what methadology this would be called (bespoke perhaps?) but I think you can find out more in embedded systems or high-performance computing sub-reddits. Someone has to be good at this sort of thing after all: I'm thinking NASA Satellites.  Assembly Language Programming? High Performance Computing? Optimization?     Ah the old ways. Warning OP: here there be dragons.      I too would be curious to hear if there are formal names for such methodologies, but hesitant to employ them. OOP and RAII have their downsides yes, but they address very specific problems inherent in low level memory management and design abstraction. You always have the option of manual memory management, it's just something that experienced programmers have learned is easy to fuck up in big projects. The unofficial motto of C++ (often given it by users of other languages) is ""It's your foot"".  If you're not already familiar with assembly level programming, and manipulating memory on the level of addresses and registers then I recommend spending some time on it. It's a fascinating discipline, and it's a world that developers are too often abstracted away from by high level languages.  I used this resource a while back, but its a little out of date. Still uses 32bit systems. http://savannah.nongnu.org/projects/pgubook/"
cpp,3c6ngf,quicknir,1 point,Sun Jul 5 10:19:22 2015 UTC,"Knowing how the computer works from a ""bare-metal"" standpoint is often the difference between top-level programmers and programmers who can never quite master their art.   This is how fistfights start. :P"
cpp,3c6ngf,encyclopedist,3,Sun Jul 5 19:12:54 2015 UTC,"The obvious question when I hear this sort of thing is: what's the advantage? OOP is contentious, the more so because it's often overused (Bjarne has called it the most overused aspect of C++). Not making your programming ""oriented"" around objects is fine I think, but if someone is not using objects at all or avoiding them when they are an obvious fit, that's not good.  If people are advocating against RAII, I'd be very suspicious. I suppose if you really want to avoid objects badly, it would be hard to do RAII. But manual resource acquisition and release is incredibly bug prone, this really shouldn't be controversial.  I'd say in the eyes of the vast majority of C++ developers, RAII is a huge strength of the language. It prevents bugs by ensuring resources are reclaimed, does so in a deterministic and usually (barring things like shared_ptr) in an easy to understand way.  C++ is one of relatively few languages that has real destructors, in which you can put meaningful code. In C, you don't have destructors at all since you don't have objects. In Java, Python, etc, you don't know when the destructor (or finalizer) will be called because of the GC. In both languages, people at the highest level have recommended never putting ""important"" code in destructors. When I program in one of these languages after C++, this is what hurts the most."
cpp,3c6ngf,autowikibot,2,Sun Jul 5 18:00:01 2015 UTC,"The arguments against RAII are coming from game developers. The approach they use is to allocate all the memory you are going to need at the start, and then write each component such that it gets a block of memory and never goes over.  The only C/C++ programming I have done has been following along with Handmade Hero, and one of my goals of the post is to try and understand RAII better and maybe get a better feel for the trade-offs of both approach."
cpp,3c6ngf,Spiderboydk,5,Sun Jul 5 21:12:39 2015 UTC,"The only C/C++ programming I have done has been following along with Handmade Hero   -- ah, that explains something.   Let me give you a little advice: try to use different points of view, not to stick to one guru. While it is very good on early stages of learning to see the world through the eyes of your mentor, some day everyone must ""leave the mother's home"" and see the world themselves, from different points of view. Become critical to anything you hear, regardless of how guru the speaker is. Just participate in some projects in different styles.  There is a danger for every professional working in their field: (in Russian we call it ""be boiled in it's own juice""), to become closed in their field, becoming unaware of the developments in other fields.  I think this is what might have happened to Casey. For example, he does not recommend to use STL. Why? Because some bad experiences he got in the moddle of 90s. I can tell you, since then everything has changed: STL itself, the compilers quality and optimization. And the same comes to many other his recommendations.  Regarding OOP, by that abbrevielion he means quite narrow subtype of OOP, which someone could call ""everything is a class"", or ""Java style"" or ""Patterns everywhere"". This style was likewise popular in 90s, but since when OOP in C++ has evolved long way. That style is now widely considered bad, but there are other OOP styles."
cpp,3c6ngf,Spiderboydk,1 point,Mon Jul 6 13:24:11 2015 UTC,"This is exactly why I came here, haha. I've only been following HMH for a couple of months, and it's my first jump into the C world coming from Java. I'lll still follow HMH for a while, but I was looking to expand my understanding with other points of view. :)"
cpp,3c6ngf,Spiderboydk,3,Mon Jul 6 20:40:43 2015 UTC,"That kind of approach is actually pretty easy to implement using allocators. You start with one giant memory pool at the start, use a custom allocator with a reference to the pool that gives a pointer to the earliest unused address and increments that address by the amount allocated. Deallocation is a noop.   Such a program can basically never destroy an object with heap resources until termination, or it will leak.   Not an easy way to program, but might well have good performance, no real time cost to allocation.  I'd be curious to see if there is really a paradigm of manual memory management that's hard to duplicate using raii."
cpp,3c6ngf,kidorbekidded,1 point,Sun Jul 5 21:59:34 2015 UTC,"The memory allocator is what I was describing. There's two ways to deallocating memory.  First, a block of memory is set aside for transient storage. The pointer gets set to the start of the memory block on each frame and its used for any processing that needs to happen while calculating a single frame.  The second is that when an object is deallocated, it gets put into a linked list of freed memory of that type. When a new struct is allocated it first tries to pull from the free list, and if the list is empty it allocates a new one.  It seems incredibly trivial to manage memory this way as long as your program is okay with never needing more memory. I'm not sure it would work with something like a word processor as you won't know how much memory the text buffer will need as it grows."
cpp,3c6ngf,AntiProtonBoy,3,Sun Jul 5 22:29:35 2015 UTC,"Your case one sounds very reasonable. You may also want to look at stack based allocators.   For case two, keep in mind that if you are reclaiming  memory from deallocation in a general way, what you are really doing is re implementing the general allocator (i.e. malloc). No allocator can be good at everything, so you'll either want to make sure your allocator performs better for your usage, or use different allocators depending on circumstance.   The general allocator is pretty good for few large allocations, but poor for many small ones. If memory serves, Modern c++ design has an incredibly detailed design of a small object allocator.   I may do a post discussing a specific kind of stack based allocator if I can get it to work the easy I want :-)"
cpp,3c6ngf,Gefrierbrand,1 point,Sun Jul 5 23:17:27 2015 UTC,"To be clear, Memory is only allocated once at the very start of the program. All the memory management is around splitting that single block into pieces that can be used by different parts of the program.  I guess when I said allocate I didn't really mean allocate. I meant that I take a piece of memory from the already allocated block and use it, and then move a pointer to just beyond the part that was used. When I said deallocate, I didn't mean return the memory to the OS, I meant do a tiny bit of work to allow the program to re-use that piece of memory later without actually deallocating anything."
cpp,3c6ngf,grandmaster789,6,Sun Jul 5 23:30:13 2015 UTC,"What you are describing is an allocator.   new and delete (I will call them ""conventional allocators"") do essentially the same thing: given a large chunk of memory (from OS), they give you the requested piece of memory and take it back making available for later use. Most modern conventional allocators don't request memory from the OS or return memory to the OS on every allocation/deallocation (but normally only then deallocating big regions of memory).  The real difference between what are you describing and conventional allocators is that the conventional one is equally suited for objects of every size. So what it must do, is first to find a gap in the allocated memory of the requested size. This is heavy operation, requiring some additional data structures to hold freed memory blocks. On delete, it marks that memory as free, merges it with adjacent free regions and inserts into the data structure of freed blocks. You allocator does the same thing, but because of knowledge of the object size and maximum allowed memory size, you can keep the data structure of freed memory extremely simple (linked list), and make the allocation and deallocation extremely fast operations. Again: it is the need to allocate the objects of arbitrary size that makes the conventional allocator so complex and slow.  As of the allocator you are describing, it is a well-known and widely used technique, called ""pool allocator"" or ""Memory pool"". It is perfectly compatible with RAII, OOP and whatever else. It is also implemented in boost as boost.pool.  By the way, modern high performance conventional allocators, like jemalloc (used at Facebook, Mozilla) or tcmalloc (Google) use similar techniques internally (they create a number of pools for objects of different sizes). (And another thing, that adds huge amount of complexity to conventional allocators, is thread safety and multithreading performance.)"
cpp,3c6ngf,jackthereader,1 point,Mon Jul 6 00:55:08 2015 UTC,"Memory pool:       Memory pools, also called fixed-size blocks allocation, is the use of pools for memory management that allows dynamic memory allocation comparable to malloc or C++'s operator new. As those implementations suffer from fragmentation because of variable block sizes, it is not recommendable to use them in a real time system due to performance. A more efficient solution is preallocating a number of memory blocks with the same size called the memory pool. The application can allocate, access, and free blocks represented by handles at run time.     Relevant: Memory Pool System | Memory virtualization | Zswap   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
cpp,3c6ngf,jesyspa,2,Mon Jul 6 00:55:59 2015 UTC,"Handmade Hero is a good project, but I don't think it's very suitable for novices.  You'll be better off doing generic tutorials - even if your end goal is to make games."
cpp,3c6ngf,TomSwirly,1 point,Mon Jul 6 10:36:11 2015 UTC,"I've been programming for almost a decade now professionally, but almost all of that time has been using Java to do enterprise web stuff. A big chunk of that time was working for Amazon.com."
cpp,3c6ngf,Spiderboydk,1 point,Mon Jul 6 20:42:06 2015 UTC,"Ok, I got the impression you were a novice. I won't assume that anymore. :-)"
cpp,3c6ngf,Spiderboydk,1 point,Mon Jul 6 21:47:37 2015 UTC,"Memory management is Java consists mostly of passing a flag to the JVM to increase the maximum heap space. And pointers exist, but not beyond dealing with a few ""pass-by-value"" edge case. Dealing with pointers to pointers makes sense to me, but it's not something that is intuitive or second nature to me yet.  Things like data structures, run-time complexity, algorithms, are fairly second nature to me. C++ seems like a much broader world, and finding a place to jump in can be a slightly daunting task.  I'm also trying to think about what pain points I've had with my past experience and what sort of a programmer I want to be going forward.  I have lost count of how many times I've had to deal with someones factory factory that was only ever used to create a single object and I'm not sure how many hours I've spent writing getters and setters for objects with absolutely no benefits over just making the members public. These sorts of things make sense on paper, but in practice just seem to make it harder to get things done."
cpp,3c6ngf,aport,3,Mon Jul 6 23:04:52 2015 UTC,"C++ indeed is daunting because it is such a huge language. It sounds like you are well on the way though, so I wouldn't worry about it if I were you.  My advice is to not try and understand everything at once. Take one step at a time, and let the overview gradually come with experience. :-)"
cpp,3c6ngf,Spiderboydk,2,Mon Jul 6 23:14:02 2015 UTC,Using c++ without oop and other defining features is like using a high intensity laser for lighting a cigarette. Why bother with the laser in the first place when a match would do?
cpp,3c6ngf,aport,5,Sun Jul 5 11:13:28 2015 UTC,"I'd consider RAII the single most important thing in C++, in my opinion. Without it, might as well drop back to C."
cpp,3c6ngf,Spiderboydk,3,Sun Jul 5 15:01:39 2015 UTC,having references is still quite nice ;)
cpp,3c6ngf,Spiderboydk,3,Sun Jul 5 12:02:50 2015 UTC,"I can totally imagine that someone would like a straightforward language like C, which is simple to reason about. That said, there are many situations where some C++ feature would be really nice to have.  If you go that route, you end up using C++, but mostly the C subset and sporadically using stuff like templates, overloading, exceptions and objects. Which is a totally reasonable thing to do - 'normal' code is simple to reason about, while the verbose and errorprone repetition from C can be avoided at will. As a bonus, the relation between such code and the generated assembly is pretty direct, which means that optimizing your code (counting cache line usage, memory alignment etc) becomes more straightforward.  Now, this does mean that this particular style is geared towards smaller programs - objects, exceptions, templates and the like are useful in that they allow reasoning about code on a higher level and allow for better cooperation in teams."
cpp,3c6ngf,frog_pow,2,Sun Jul 5 14:26:33 2015 UTC,"The style of programming used in Handmade Hero is basically C, but compiled with C++ to use a very small subset of C++ features (like operator overloading)."
cpp,3c6ngf,Spiderboydk,1 point,Sun Jul 5 21:06:02 2015 UTC,"What about C with templates ? Sometimes you cannot afford building/parsing objects and need to work on the raw pointer, but you don't want keep strong typing, metaprogramming and don't want to write the same code N times ?"
cpp,3c6ngf,Spiderboydk,1 point,Sun Jul 5 12:26:15 2015 UTC,"The difference seems to come down to whether one uses exceptions or not.  I can't think of any specific subreddits that discuss this, especially seeing as both sides tend to think they're ""using C++ the way it should be used"", but it's not a hard sentiment to notice."
cpp,3c6ngf,Spiderboydk,1 point,Sun Jul 5 11:30:39 2015 UTC,"Jonathan Blow discusses this specifically in this video: https://www.youtube.com/watch?v=TH9VCN6UkyQ&t=38m15s  The idea that adding exceptions to your language makes everything more complex, and there are probably cleaner ways to handle it.  I'm still trying to wrap my head around some of these ideas."
cpp,3c6ngf,encyclopedist,2,Sun Jul 5 21:16:40 2015 UTC,"there are probably cleaner ways to handle it.   ""Probably""?  That's not very encouraging.  Exceptions are really clean compared to the two alternatives:   Returning an error code with every function.   messy if you are already returning a value. and how do you enforce that callers check the error code? particularly if it's new in this revision?  Setting an error value as a side-effect.   ""Spooky magic at a distance"" breaks encapsulation. Threading and concurrency issue. How do you enforce that callers check the error code? Worse, how do you enforce that callers don't accidentally overwrite a non-OK error code?"
cpp,3c6ngf,jesyspa,2,Sun Jul 5 23:57:54 2015 UTC,"I'd like to add:   When returning error codes the code becomes harder to read because you have to litter it with error-checking if-sentences everywhere. Exceptions are theoretically slightly faster than checking return codes in the case of no exceptions, because throwing is a glorified goto, so you don't pay for all those if-sentences.   There are a lot of myths regarding exceptions, even among professionals."
cpp,3c6ngf,oracleoftroy,1 point,Mon Jul 6 10:46:28 2015 UTC,"Thanks for the reply!  I think I understand the arguments you make if the first section and I think right now my opinions are different than yours here (which is totally cool).  Adding exceptions adds a lot of complexity to the language, so using multiple return values seems fine to me. I realize this is totally subjective and opinions will differ here.  I'm not I really care if a caller checks my error messages or not. I'd like to think about it more, but I don't think I see any issues with saying ""Here's how this function works, ignore the errors at your own risk.""  I don't think I understand the last point you made. Could you explain what you mean by setting an error value as a side-effect and maybe provide an example?"
cpp,3c6ngf,klugez,2,Mon Jul 6 00:29:49 2015 UTC,Exceptions really aren't that complex. I have a suspicion that you think they are because you are not familiar with them.  I suggest you find a few talks about the subject on Youtube and get a good grasp on what they actually are.
cpp,3c6ngf,oracleoftroy,1 point,Mon Jul 6 10:51:13 2015 UTC,Exceptions really aren't that complex.   That's not what my linker says when my binary size explodes without -fno-exceptions
cpp,3c6ngf,ChallengingJamJars,1 point,Mon Jul 6 17:35:13 2015 UTC,"I think it might be because some library with a lot of unused code is implicitly linked into the binary. I've seen something similar happen before, and it isn't exception-specific."
cpp,3c5zz0,MoTTs_,15,Sun Jul 5 03:47:31 2015 UTC,"Depends on the situation:   If the RAII class doesn't own the resource, instead it just does some work on the resource at construct/destruct, I'll call it xxx_guard. If the RAII class owns the resource and the resource is accessible via a pointer, it's typically defined as using xxx_handle = std::unique_ptr<XXX, XXX_deleter>; If the resource is not accessible via a pointer and thus std::unique_ptr cannot be used, I'll write the RAII wrapper myself and name it unique_xxx.   That's what I mostly used in my experience."
cpp,3c5zz0,tongari95,3,Sun Jul 5 04:57:45 2015 UTC,See this excellent answer on how to use unique_ptr even for resources not accessible by pointer  http://stackoverflow.com/a/11002936/955273
cpp,3c5zz0,skebanga,4,Sun Jul 5 15:40:32 2015 UTC,thing_guard is a popular choice. thing_handle is also a good convention.
cpp,3c5zz0,minno,5,Sun Jul 5 04:36:00 2015 UTC,"I tend to code objects as read-only as possible (everything that can be const must be const), so this means nearly all of my classes are RAII by necessity. If you have an instance of an object, it's guaranteed to be 100% initialized and ready to use. When it goes out of scope (via local scope or shared_ptr), it is cleanly removed with no leaks of any kind.  I don't understand this ""RAII is more verbose!"" mindset I'm seeing all over the place now. My objects are no more or less verbose than they used to be. The code just got shifted to constructors is all.  Anyhow, this means the objects are simply named after what they represent or what they do."
cpp,3c5zz0,jrandom,3,Mon Jul 6 04:04:02 2015 UTC,"If there's no common name (like Ptr for smart pointers) and they do not wrap a ""real"" resource like some handle I tend to think of them as scopes. For example a RAII class changing a thread's priority and restoring it again would be a ThreadPriorityScope."
cpp,3c5zz0,rdtsc,3,Sun Jul 5 08:15:27 2015 UTC,RAIIMOND   *chirp*
cpp,3c5zz0,donvito,1 point,Sun Jul 5 12:25:11 2015 UTC,groan
cpp,3c5zz0,bstamour,1 point,Sun Jul 5 14:23:15 2015 UTC,DesiRAII
cpp,3c5zz0,hoople,1 point,Mon Jul 6 02:44:44 2015 UTC,"I'd have to agree, because Everybody Loves RAIIMOND.  (ducks)"
cpp,3c5zz0,robthablob,2,Thu Jul 9 09:45:40 2015 UTC,ThingRAII. (Seriously)
cpp,3c5zz0,POGO_POGO_POGO_POGO,5,Sun Jul 5 12:34:15 2015 UTC,"Awful.  RAII is a tool used for a variety of different activities.  It's also not something that comes trippingly off the tongue.  ScopedThing, ThingDeleter, ThingGuard, UniqueThing - all fairly standard, understandable - and pronounceable."
cpp,3c5zz0,TomSwirly,1 point,Sun Jul 5 21:03:20 2015 UTC,"For some wierd reason the 2 classes I cooked a few years back only have ThingRAI.  It's never too late to refactor right?  So far I've only used custom guards for things like progress bar advancing or for printing scoped timing information.  I know, I know, multiple exit points are bad..."
cpp,3c5zz0,bnolsen,8,Sun Jul 5 17:38:31 2015 UTC,ThingGuard for me. I dislike _ in names. It's like a stump on a straight road of typing.
cpp,3c5zz0,Ksecutor,5,Sun Jul 5 06:23:53 2015 UTC,"It's not about the typing, it's about reading. I find it much easier to read. Specially if you name your variable SomethingLikeThis, vs something_like_this. It's basically a space without being a space. ImagineIfWeTalkedLikeThisOnTheInternet. That's how I feel about PascalCase."
cpp,3c5zz0,cleroth,6,Sun Jul 5 14:58:51 2015 UTC,"Probably it's a question of personal preference and perception. I have no problems reading PascalCase or camelCase. But when_there are a_lot_of_underscores that_look like spaces_then sometimes I have_problems visually_distinguishing where_one_thing_ends and_another_starts. Especially if my IDE underlines current line (error, warning etc) and I literally can't easily distinguish space from an underscore.  someObject.someMethod();//here dot also creates space and I can clearly see separation some_object.some_method();//here dot is just another space and I need additional concentration to separate them when reading."
cpp,3c5zz0,Ksecutor,1 point,Mon Jul 6 04:52:35 2015 UTC,"I use PascalCase for methods/functions. I suppose you might kind of say it's a mixed style but I've never any problem with it. I've tried a bunch of styles and it just seems this way feels the best to me. So for your example I'll have some_object.SomeMethod();. What IDE do you use? I don't think I've ever had the problem of misinterpreting underscores as spaces, at least not often. Maybe it just needs getting used to."
cpp,3c5zz0,cleroth,1 point,Mon Jul 6 05:18:17 2015 UTC,"I use Eclipse. Some time ago I had to support one underscore heavy project, and it was quite annoying experience. I had to clear warnings/errors before editing."
cpp,3c5zz0,Ksecutor,3,Mon Jul 6 06:26:06 2015 UTC,"I agree with you on this. It saves incredibly little using a typing style that saves you time typing, versus the incredibly large amount of time spent reading and debugging."
cpp,3c5zz0,salgat,0,Sun Jul 5 21:31:37 2015 UTC,"I prefer underscores, but I wouldn't use them in Java.  You might prefer not using underscores, but you should still use them in C++."
cpp,3c5zz0,rifter5000,1 point,Wed Jul 8 22:55:37 2015 UTC,I named my wrapper around Unix file descriptors (which are plain ints) as filedesc.  But I haven't needed to write a significant number of wrappers to have a naming convention.
cpp,3c5zz0,mdf356,1 point,Sun Jul 5 14:52:34 2015 UTC,I usually call them with a leading C followed by the function creating the resource:  Copen (for UNIX open) CCreateFile (for Windows open) CMapViewOfFile CCreateFileMapping Cmmap  Of course there is always a check for success and in case of no success a system error exception is thrown.
cpp,3c5zz0,ExcessPhase,2,Mon Jul 6 03:26:55 2015 UTC,"I've noticed this convention in Windows code, such as the ATL (e.g., CComPtr). Do you happen to know what the leading ""C"" is supposed to stand for?"
cpp,3c5zz0,ferruccio,2,Mon Jul 6 06:18:55 2015 UTC,"It stood for ""Class"". This was before C++ had namespaces. The idea was that you were supposed to name all your classes with a common prefix to avoid name collisions. So Microsoft decided to prefix all their class names with a C. Unfortunately, every one else saw that and decided to start all their class names with C too, which defeated the entire purpose of having a naming convention."
cpp,3c5zz0,robthablob,1 point,Mon Jul 6 20:29:39 2015 UTC,"Actually, MS explicitly recommended using 'C' as a prefix for all classes. However, they also recommended using Cthulhian Hungarian notation, so they've improved massively."
cpp,3c5zz0,peolorat,1 point,Thu Jul 9 09:47:38 2015 UTC,namespace mylib {     namespace raii     {         class myclass         {          };     } }
cpp,3c5zz0,AceyJuan,-2,Thu Jul 9 11:24:53 2015 UTC,AutoThing. I have no idea why people like underscores for names. It's one of the least pleasant characters to type.
cpp,3c5zz0,jaLissajous,5,Sun Jul 5 06:51:57 2015 UTC,"It's one of the least pleasant characters to type   Time for me to evangelize! I too used to find tying some characters unpleasant, but then I built my own split-pcb semi-ortholinear keyboard and re-mapped all the special character keys so they were easier to type. Plus I used special mechanical key switches that provide a satisfyingly chunky click when activated. Using it helped alleviate my wrist and back pain, it was great.  If you're anything like me you will completely re-design the existing standard keyboard and create a custom mapping to better type those pesky underscore characters. And open & close parenthesis, brackets, and braces."
cpp,3c5zz0,silverforest,1 point,Sun Jul 5 09:56:43 2015 UTC,What's your keylayout out of curiousity?
cpp,3c5zz0,jaLissajous,2,Sun Jul 5 10:37:43 2015 UTC,"Most recently it was this: https://www.massdrop.com/ext/ergodox/?referer=PJQRPT&hash=b8251fb3744e4af73f58f99126b032ba  But I added a Colemak layer recently and I'm mostly using that. My future plans are to remap the number 'row' to a symbol only row and add a 10-key numpad layer, but that's several months off while I struggle my way through Colemak."
cpp,3c5zz0,cleroth,6,Sun Jul 5 11:13:48 2015 UTC,"Because reading is a lot more important than typing. Underscored names are much easier to read, specially if they contain more than two words. We are just used to spaces between words, SoSomethingLikeThisReadsMuchHarder than something_like_this_instead. Although, I use Dvorak Keyboard Layout, so underscore is pretty easy to type on it."
cpp,3c5zz0,AceyJuan,0,Sun Jul 5 15:02:19 2015 UTC,It's no easier to read _ names. CamelCase is very easy to get used to.
cpp,3c5zz0,cleroth,2,Sun Jul 5 20:19:24 2015 UTC,I've used PascalCase/camelCase for years. Then I switched to underscores. It feels much easier to read for me.
cpp,3c5zz0,lithium,0,Mon Jul 6 05:15:21 2015 UTC,"You seem to have trouble grasping the fact that this isn't a universal_truth. ToEachTheirOwn, I suppose."
cpp,3c5zz0,jrandom,2,Mon Jul 6 01:44:52 2015 UTC,"I've found that some short names are easily readable with PascalCase, but special cases and longer names Benefit_From_Underscores_Because_The_Brain_Can_Visually_Chunk_The_Words_Faster.  Granted, one should try to keep method and member names as short as possible..."
cpp,3c5zz0,cleroth,2,Mon Jul 6 04:05:59 2015 UTC,"Unfortunately in some projects names longer than 2 words can be pretty common. One example is Unreal Engine 4:  UPrimitiveComponent* Primitive = MyActor->GetComponentByClass(UPrimitiveComponent::StaticClass()); USphereComponent* SphereCollider = Cast<USphereComponent>(Primitive); if (SphereCollider != nullptr) {     // ... }   I honestly find that code to be really damn confusing, specially because the PascalCase is applied everywhere, from classes to variable names, whereas the Unity equivalent code (C#, but irrelevant) is much easier/faster to read:  Collider collider = game_object.GetComponent<Collider>; SphereCollider sphere_collider = collider as SphereCollider; if (sphere_collider != null) {     // ... }"
cpp,3c5zz0,jrandom,1 point,Mon Jul 6 05:26:08 2015 UTC,"I'm a big fan of underscores myself. I only use PascalCase in those rare instances where it actually is more readable, and then only for method names and constants."
cpp,3c5zz0,cleroth,1 point,Mon Jul 6 06:06:17 2015 UTC,"I didn't say it was a universal truth. Just that because it ressembles how you normally read text, it should logically be much easier to read. I've used both for years and I certainly that to be the case. Just saying that those that have tried both and go for the logic of ""I don't use underscores because it's harder to type"" is flawed."
cpp,3c5zz0,F-J-W,-4,Mon Jul 6 05:20:01 2015 UTC,Because camel-case is inconsistent with the standard-libraries naming-conventions and it is childish to deviate from them. PascalCase in C++ is as stupid as snake_case in Java.
cpp,3c5zz0,TomSwirly,3,Sun Jul 5 08:54:34 2015 UTC,"Because camel-case is inconsistent with the standard-libraries naming-conventions    Some people see that as an asset - to distinguish STL classes, functions and methods from everything else.  (I'm really not sure if I'm in that category or not.)   and it is childish to deviate from them.   ""They disagree with ME!  They are no better than children!!"""
cpp,3c5zz0,rifter5000,1 point,Sun Jul 5 21:06:49 2015 UTC,"Some people see that as an asset - to distinguish STL classes, functions and methods from everything else. (I'm really not sure if I'm in that category or not.)   Half the point of C++'s complexity is to enable you to create things that feel as native to the language as built-in types."
cpp,3c5zz0,Eoinoc,4,Wed Jul 8 22:58:34 2015 UTC,"PascalCase in C++ is as stupid   It seems like template types (and examples of concepts) use PascalCase. Though if anything I think that supports your argument. If now PascalCase has a meaning, using it for other purposes can be counter productive."
cpp,3c5zz0,F-J-W,0,Sun Jul 5 10:20:19 2015 UTC,"You are right, I was talking only about classes there. In fact, I am already laughing over all those who will be unable to distinguish functions and function-templates, because void fun(Foo arg) will tell me that fun is a function-template (because the argument-type is in caps, therfore a concept, therefore a function-template), while that will not be the case for those people."
cpp,3c5zz0,AceyJuan,4,Sun Jul 5 10:38:07 2015 UTC,"it is childish to deviate from them.   What are you thinking? Should we have all removed .h from our header file names for C++98 and added them back for C++11?  The standard headers aren't meant as a style guide. Even if they were, who would buy style-by-committee?"
cpp,3c5zz0,F-J-W,2,Sun Jul 5 09:04:56 2015 UTC,"Why follow any naming-convention at all then? Make it php: force everyone to guess how the function is spelled, because everyone does whatever they want.   Every major language that came later (php aside) managed to make people use consistent naming. Because it matters! In what way do naming conventions help with readability if every library uses a different one?  Also what is the problem with style-by-committee? Picking a style is one of the things where it is important that there is a consistent way, not what it is, therefore it is one of the best examples for something where it is almost impossible for a committee to fuck up. Again: It doesn't matter which style they choose, it matters that they choose ONE and everyone uses that.  Ans since almost everyone uses the standard-library, getting consistency with any other style is basically impossible, so you have to use that, whether you like it, or not!"
cpp,3c5zz0,cleroth,1 point,Sun Jul 5 10:12:07 2015 UTC,"Ans since almost everyone uses the standard-library   Dunno. I honestly wrap the STL with my own library. Most of the STL is a huge pain in the ass to use, and is missing quite a lot of useful stuff. It also has the benefit using whatever style I like most in my code. Only drawback is that you have to be familiar with the library (which is nearly identical to the STL), but isn't such a big problem since I'm the only one using it."
cpp,3c5zz0,TomSwirly,0,Sun Jul 5 15:07:22 2015 UTC,"If there's only one developer, and you never expect to have more than one developer, you can do pretty well anything you please, but that's not a good example for the real world"
cpp,3c5zz0,cleroth,1 point,Sun Jul 5 23:40:26 2015 UTC,Why isn't it? Big companies write their own STL all the time.
cpp,3c5zz0,cleroth,1 point,Mon Jul 6 05:26:49 2015 UTC,Point taken.
cpp,3c5zz0,bycl0p5,1 point,Thu Jul 9 10:00:36 2015 UTC,"Even if they were, who would buy style-by-committee?   What does that have to do with anything? Or do you avoid everything designed by committees and so presumably avoid the standard language and very language addition introduced since C++ got moved beyond just being Bjarne?"
cpp,3c5zz0,spinwizard69,-7,Sun Jul 5 10:23:30 2015 UTC,"Are you serious?    Name them whatever you want, just be sensible like you would for any other class."
cpp,3c5zz0,hapygallagher,19,Sun Jul 5 04:10:08 2015 UTC,Yes make sure you don't ask about best practices/preferences from people who have more experience than you.
cpp,3c5zz0,jrandom,2,Sun Jul 5 05:54:29 2015 UTC,"just be sensible like you would for any other class   Careful, man. We apparently downvote good common sense 'round these parts."
cpp,3c5yay,quicknir,2,Sun Jul 5 03:27:31 2015 UTC,"tiny, but important error:  you never set m_cached to true."
cpp,3c5yay,meetingcpp,1 point,Sun Jul 5 11:06:29 2015 UTC,Thanks!
cpp,3c5yay,notlostyet,2,Sun Jul 5 13:03:21 2015 UTC,"Here's a version which:   Doesn't require the 'mutable' keyword Works safely on rvalue SetStringers (and doesn't update the cache). Doesn't leak const refs to members that may later be mutated or become invalid. Actually uses between 0 and 24 bytes less memory when str() is never called, depending on your STL implementation and padding wrt your bool. It's never worse.   Code:   #include <algorithm> #include <memory> #include <set> #include <string> #include <sstream> #include <iterator>  class SetStringer {     public:         void to_string (std::string&) const;         std::shared_ptr<std::string const> str() &;         std::shared_ptr<std::string const> str() const&;     private:         std::set<double> m_set;         std::weak_ptr<std::string const> m_cache; };  void SetStringer::to_string (std::string& str) const {     std::ostringstream oss;     copy (begin(m_set), end(m_set), std::ostream_iterator<double>(oss, ""\n""));     str = oss.str(); }  std::shared_ptr<std::string const>  SetStringer::str() & {     auto cached = m_cache.lock();     if (!cached) {         auto str = std::make_shared<std::string>();         to_string (*str);         m_cache = str; /* Update cache */         return std::move (str);     }     return std::move (cached); }  std::shared_ptr<std::string const>  SetStringer::str() const& {     auto cached = m_cache.lock();     if (!cached) {         auto str = std::make_shared<std::string>();         to_string (*str);         return std::move (str);     }     return std::move (cached); }"
cpp,3c5yay,notlostyet,3,Sun Jul 5 11:33:53 2015 UTC,"It's very nice, but let's be clear that writing the best possible SetStringer was really not my intent. There's also nothing wrong with ""leaking"" const references, btw, there's no way that reference can become invalidated, only mutated. Using shared_ptr sort of takes the design in a completely different direction."
cpp,3c5yay,notlostyet,3,Sun Jul 5 13:09:05 2015 UTC,"there's no way that reference can become invalidated, only mutated   Returning a const& to a member breaks the temporary lifetime extension mechanism.  SetStringer get_ss(); {     auto const& stringer = get_ss();     auto const& str = stringer.str(); // Safe } {     auto const& str = get_ss().str(); // Unsafe }   This is the kind of refactoring that many developers might expect to be safe.  As an introduction to rvalue references and overloading members on rvalues, it's a good article. But I feel it's important to stress safety. To fix your solution the && overload of str() needs to exist and return by value. There are very very few cases anything should ever return T&&."
cpp,3c5yay,notlostyet,1 point,Sun Jul 5 13:58:58 2015 UTC,"Returning by value would defeat the purpose.  It's an interesting example with breaking the temporary lifetime extension, I can't say I think that's a very wide pit to fall into.  Returning by const & in the wild is pretty common where efficiency is important. Your example works just as well to create a dangling reference with std::vector."
cpp,3c5yay,cdglove,1 point,Sun Jul 5 14:32:08 2015 UTC,"Returning by const & in the wild is pretty common where efficiency is important.   In this case you'll see  no difference in anything but an insane myopic micro-benchmark. Moving a good implementation of std::string is 3 MOV  instructions on x86 [0]  The vector argument is a bit flimsy because op[]  is almost exclusively used for iteration and arrays make terrible immutable data structures. There are no bounds checks either. You're already screwed, may as well be fast. The STL was never really designed with safety in mind, which is why iterators are unchecked by default. Some of the more recent decisions in the standard library do in fact return by value though, look at std::future's get() method vs std::vectors pop_back as an example.  [0] http://goo.gl/VZdxRD"
cpp,3c5yay,detrinoh,1 point,Sun Jul 5 15:14:45 2015 UTC,"Who said anything about moving? When you don't return by const & you force a copy. E.g. string stream:  stringstream ss; // Add stuff... // I want to know how long the string is now const auto & s = ss.str() // does a full copy, O(N) auto l = s.size(); // O(1)   By not returning by const reference, stringstream has turned an O(1) operation into an O(N) operation. This inspires questions like this: http://stackoverflow.com/questions/3213954/how-to-get-length-of-stdstringstream-without-copying. Notice how crappy the best answer is: it depends on an obscure member function, and it's not even necessarily correct.  I'd suggest you thoroughly read your own example: http://en.cppreference.com/w/cpp/thread/future/get. You have the option to return a reference, and if it returns a value then that value is moved. Nowhere is the cost of a copy incurred."
cpp,3c5c7l,mttd,2,Sat Jul 4 23:08:35 2015 UTC,Fun read. Thanks for sharing!
cpp,3c68h8,skln,6,Sun Jul 5 05:40:18 2015 UTC,"[Disclaimer: I am the author of the Hana library.]  You might want to look into the Hana library, which makes a lot of these constructs (and related metaprogramming constructs) much easier in C++14. The exact part of the library which you seem to be looking for is documented here.  For the record, your example would look like:  auto has_nested_type = hana::is_valid([](auto t) -> decltype(hana::type<     typename decltype(t)::type::type >) {});   and then you would call it as  has_nested_type(hana::type<YourClass>)   Sure, it is still slightly convoluted, and the word type appears many times, but at least you can define this SFINAE-checker locally inside functions, and there are also other benefits documented at the link I mentioned."
cpp,3c68h8,louis_dionne,1 point,Sun Jul 5 07:38:37 2015 UTC,this is really great -- how were you able to achieve this?
cpp,3c68h8,samkellett,2,Tue Jul 7 06:01:50 2015 UTC,"type<T> is a variable template returning an object which represents a type. This object has a nested ::type alias equivalent to T. Then, is_valid uses SFINAE on the function object it is given and returns whether the call is valid."
cpp,3c68h8,louis_dionne,1 point,Wed Jul 8 05:31:17 2015 UTC,ah yeah.. i kinda meant how did you implement is_valid! :)
cpp,3c68h8,samkellett,2,Wed Jul 8 08:38:43 2015 UTC,Oops. See here
cpp,3c68h8,louis_dionne,4,Wed Jul 8 18:11:24 2015 UTC,"Using Walter Brown's ""detection idiom"", which was voted into v2 of the Library Fundamentals TS at the last committee meeting:  template<class T> using type_member_t = typename T::type;  template<class T> using has_type = std::experimental::is_detected<type_member_t, T>;"
cpp,3c68h8,tcanens,5,Sun Jul 5 09:52:48 2015 UTC,void_t is really useful here. Upvote and more info:  how it works - stackoverflow  docs - cppreference  template metaprogramming talk - walter brown
cpp,3c68h8,rabidb,2,Sun Jul 5 10:00:12 2015 UTC,I have a question: Why did the committee select SFINAE idea and not simply #if preprocessor macro for selecting actions depending on type?  Honestly SFINAE is ugly and without any readibility
cpp,3c68h8,chambolle,3,Sun Jul 5 11:50:42 2015 UTC,"Macros aren't type safe or scoped. See Bjarne Stroustrup's page:  So, what's wrong with using macros?  With the changes in C++11/14/17 and STL functional, SFINAE / template work has become a lot simpler."
cpp,3c68h8,rabidb,-1,Sun Jul 5 12:06:05 2015 UTC,Thanks for the answer. However I disagree: a code like   #if T=int     something here   looks very simple and natural in imperative language Honestly SFINAE are really ugly and very difficult to understand. Is there a reason for not choosing simple tests in an imperative language? BTW nobody writes code like fn(i++) as mentioned by Stroustrup.
cpp,3c68h8,chambolle,6,Sun Jul 5 13:58:47 2015 UTC,"The preprocessor has no idea about actual code semantics; that's a dead end. I think you want something like static if; N4461 is the most recent incarnation. You'll have to wait and see how it fares in the committee.  I don't think the committee intentionally ""chose"" to use SFINAE over something else. Some form of the SFINAE rule is needed to make overloaded function templates usable - deduction failure shouldn't cause hard errors. Then people came up with ""creative"" ways to use this rule to manipulate overload resolution. Afterwards, since you have a widely-used workaround, it's much less pressing to come up with a better-looking alternative."
cpp,3c68h8,tcanens,1 point,Sun Jul 5 18:40:44 2015 UTC,Thank you for your clear answer.     static if  is exactly what I would like to have! It would really improve the readibility of the code.  I was thinking that SFINAE was the answer brought to the type checking requests we have with templates.
cpp,3c68h8,chambolle,3,Mon Jul 6 07:04:48 2015 UTC,SFINAE is not the weird stuff that people to get various overload solutions. SFINAE is what makes your programs not fail to compile when template substitution fails during overload resolution. Overload resolution doesn't work without this.  What you're talking about is the way that people have exploited this language property to support library design. It turns out to be important.  Concepts will help alot with the readability you're looking for.
cpp,3c68h8,andrewsutton,-1,Tue Jul 7 01:15:30 2015 UTC,Thanks. I understand. Here are some information about static if http://forum.dlang.org/thread/cdgzdesltjefjvnjbspk@forum.dlang.org Concepts is useful but not enough general. For debugging for instance.
cpp,3c68h8,chambolle,2,Tue Jul 7 07:06:19 2015 UTC,"You know I'm one of the authors of that paper being discussed in that forum, right? I'm also the author of the most recent concepts proposals.  I look forward to hearing how concepts is not sufficiently general, but a language feature -- as previously proposed for C++ -- that would completely disable syntax checking in template is a good idea."
cpp,3c68h8,andrewsutton,0,Thu Jul 9 00:39:26 2015 UTC,"I din't notice that you were an author!  Ok, debugging a code and a code that you didn't write is very important in programming. Imagine that you have a Template which is used a lot for several types. However it seems that is a bug only for one known type. So you would like to debug it only for this type. By debugging I means adding some traces into the code. Currently you can't do that. However you really need to do it.  This is why templates are sometimes complex to use."
cpp,3c68h8,chambolle,1 point,Fri Jul 10 08:29:06 2015 UTC,Concepts readily helps with this problem.
cpp,3c68h8,andrewsutton,1 point,Tue Jul 14 02:51:00 2015 UTC,"The drawback is that concept introduce one again a new features for expressing things that most of the time can be expressed in a different way. Having two ways for doing the same thing is one more than what is reasonnable. It is very difficult to teach and to learn C++ because there are some many things for doing almost the same things. Not being able to read the code written by another user means the end of the language. Concepts here also looks like a ""marteau pilon pour excraser une mouche"". Why simple thing cannot be accepted in this language?"
cpp,3c68h8,chambolle,1 point,Wed Jul 15 15:25:01 2015 UTC,"Just because a feature seems simple, does not mean it is a good idea -- or that it's actually simple.   What's so complex about concepts, anyway?"
cpp,3c68h8,andrewsutton,1 point,Thu Jul 16 01:08:57 2015 UTC,"Concepts is just a way to define the ""protocol"" that should follow some classes. In OOP we have the concept thanks to interface or inheritance. So, now we are going, once again, to have another way to express the same thing. That is, the same idea can be expressed by 2 different methods. For me: it is really bad. Thus, some people will be happy because inheritance could be removed in some cases. I don't really understand how concept may solve my simple problem? How can I have the equivalent of static_if in only one line? Anyway, we can simulate huge part of static_if usage with SFINAE and enable_if. So you can do whatever you want: people are going to use the simplest way to do something"
cpp,3c68h8,chambolle,2,Thu Jul 16 07:49:12 2015 UTC,Pretty much this: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3613.pdf
cpp,3c68h8,sbabbi,-2,Sun Jul 5 20:16:22 2015 UTC,"Thanks ! Nice reference. it's funny! ""static if"" answers to a real need of the real world. However, it is considered too much verbose and they don't like the style of coding! For sure this is an imperative style. C++ is going wrong..."
cpp,3c3w4q,hkaiser,5,Sat Jul 4 14:58:54 2015 UTC,"clang -Weverything will also catch unused variables, implicit conversions, mismatches between copy constructors and assignment operators, and much more. You can add explicit -Wno-xxx commandline options to disable benign warnings for issue  xxx"
cpp,3c3w4q,TemplateRex,1 point,Sat Jul 4 17:59:18 2015 UTC,"And clang's static-analyzer can take a CMake compilation data-base as input, so it is really easy to give that a try as well if your project is CMake based.  In my experience, however, the static-analyzer finds 0 real problems with modern C++ projects. If you are using RAII and smart pointers it just doesnt find anything worth changing (if you are already compiling your project with clang -Weverything).   It might be useful for C projects tho, but I don't know how many C projects use CMake."
cpp,3c3w4q,gnzlbg,1 point,Sun Jul 5 08:03:45 2015 UTC,"In my experience it is always beneficial to use more than one tool for the job. Every tool has its strength and weaknesses, why not use those for our benefit? PVS-Studio's advantages are clearly the nice integration into the IDE and the possibility to suppress diagnostics on an instance by instance bases. I don't like -Wno-xxx as it may hide something important."
cpp,3byibd,STL,24,Fri Jul 3 05:06:17 2015 UTC,"Ulzii, the FE dev lead, posted this yesterday. Bonus fact: they fixed over 1300 non-Connect bugs (of which I filed over 130; my Homeric epithet would be STL, breaker of compilers)."
cpp,3byibd,gnzlbg,10,Fri Jul 3 05:25:26 2015 UTC,"STL, a.k.a. ICEman."
cpp,3byibd,SushiAndWoW,20,Fri Jul 3 07:12:48 2015 UTC,"Some say the world will end in fire. Some say in ICE. From what I've tasted of compilers, I hold with those who favor fire."
cpp,3byibd,SushiAndWoW,10,Fri Jul 3 08:24:22 2015 UTC,"Can I pray that, among those fixes, there is one for the traditionally dangerous VC conditional operator?  The page I linked to shows VS exhibiting dangerous behavior: it compiles ambiguous code silently and against developer intent, and there's no way to get even a warning. GCC and Clang both emit errors."
cpp,3byibd,CPPOldie,4,Fri Jul 3 13:20:37 2015 UTC,"DevDiv#553676 ""If you want a picture of the future, imagine a conditional operator stamping on a human face - forever."" is still active."
cpp,3byibd,AceyJuan,2,Fri Jul 3 18:32:59 2015 UTC,"I'm having trouble finding that as a reference. Is 553676 an actual ID where this issue is tracked? Is that internal only, or available for public viewing?"
cpp,3byibd,Grammar_Nazi_Party,1 point,Fri Jul 3 19:08:31 2015 UTC,It's our internal TFS database.
cpp,3byibd,AceyJuan,9,Fri Jul 3 19:28:24 2015 UTC,"STL, I appreciate the efforts your team is putting into the library and compiler, however....  In the past you mentioned the compiler and library testing process utilizes plum-hall.   Now if that were truly the case, then many of say Majnemer's if not a larger number of the total 750 bugs fixed would have been caught at internal testing time - as an example ""crashes during class template instantiation with void template argument"" really - in the year 2015?  Makes one wonder what those ""1300 non-connect bugs"" were all about."
cpp,3byibd,artanis2,24,Fri Jul 3 08:25:03 2015 UTC,"We have multiple conformance suites, including Plum Hall and McCluskey. But remember, C++ is big. Enormously big. There's a ton of mindless rules interacting with each other, and the system is set up so that the rules behave with what appears to be simpler, comprehensible intent (this is why language complexity does not necessarily imply harmful complexity exposed to programmer-users). However, compilers have to deal with the raw complexity of the underlying rules. Even a comprehensive test suite will miss certain interactions - and the stuff that's easy for a test suite writer to forget about, is also easy for a compiler writer to forget about.  Take a look at Connect#1004350's repro. It's not as silly as the title makes it sound. It involved an alias template (relatively new feature) attempting to form a reference to void. That's ill-formed, but the compiler's alias template expansion codepaths didn't expect this, so it ICEd. ICE-on-invalid is a bug, but it's one of the least harmful kinds.  My job has been analyzing compiler and library misbehavior for almost a decade. There are basically three categories of bugs: Hello World bugs in new code (there's nothing with a dependency on new code, so it's easy for major stuff to be broken), obscure bugs that are obvious if you know exactly where to look (these usually have simple repros that exercise a small fragment of Standardese that wasn't handled somewhere; they sneak through due to their obscurity, which also limits their damage), and bugs that are caused by complicated interactions between fairly ordinary code (these are missed because the stars have to align just right for the stuff to break; as a result they usually don't affect too much code). After looking at it for a minute, I'd categorize Connect#1004350 as the last one, an unexpected interaction. Alias templates work elsewhere, and the compiler knew that references to void are ill-formed elsewhere, but the combination went boom. A test suite wouldn't catch that unless the author thought, ""hmm, are alias templates going to enforce all the usual rules that I take for granted?"".  (As an example of a Hello World bug, the earliest implementation of constexpr was eagerly enforced on templates. That was just due to a misunderstanding of the Standardese, and it was found easily during the Library's first attempt to use constexpr, so we were able to fix it before shipping that to customers. As an example of an obscure-rule bug, I'd point to rethrow_with_nested() being given a final class - this obviously needs to be handled when you think about it, but the Standard and at least one of libstdc++/libc++ (I forget which) didn't handle it. I noticed while implementing nested_exception from scratch.)"
cpp,3byjiu,eric_niebler,4,Fri Jul 3 05:18:08 2015 UTC,"Overall looks very good, but I'm disappointed by the inclusion of a default constructor for the first type. Not having default constructors would force people to explicitly choose what they are constructing. Also avoids behind the scene construction:  variant<expensive, cheap> v; unordered_map<string, variant<expensive, cheap>> u; u[""hello""] = cheap() // default constructs expensive, then assigns cheap   Just kill the default constructor entirely."
cpp,3byjiu,quicknir,1 point,Fri Jul 3 14:02:12 2015 UTC,"This was discussed at Lenexa. The fact that ""regular"" types in C++ require a default constructor is an odd C++-ism. The idea here is that putting regular types in a variant shouldn't remove regularity. If you're going to choose an alternative to be the default, the first one is the most reasonable choice.  I appreciate, though, the desire for explicitness which this proposal doesn't enforce, but does allow."
cpp,3byjiu,david_sankel,3,Sat Jul 4 04:07:38 2015 UTC,"The idea here is that putting regular types in a variant shouldn't remove regularity.    Agreed, but a variant can be SemiRegular independently of its types being Regular or not. Depending on the ""regularity"" of its types, it can be made conditionally Regular.  I'm not arguing this is something worth pursuing, just that this is something worth thinking deeply about.   What worries me about default constructing the first element is that the mathematical discriminated union that the variant is trying to model does know nothing about ordering. That is, in my opinion, variant<T, U, V> and variant<U, V, T> should be completely equivalent and have exactly the same behavior. Default constructing to the first element violates this.  This might seem to be a minor problem, even worth violating for practical purposes, but do we really want variants that might be SemiRegular depending on the order of its elements? Do we want the default initialization cost of a variant to also depend on the order of its elements? Idk which are the right answers to these questions, there are a lot of things to weight here, but I do not want these outcomes if they are avoidable."
cpp,3byjiu,gnzlbg,1 point,Sun Jul 5 20:47:51 2015 UTC,"In type theory variant<A,B> is different from variant<B,A> (see: https://en.wikipedia.org/wiki/Tagged_union). We also need the difference in order to generate a proper ordering for operator<.  I'm not sure I understand the ""default initialization cost"" since one can always assign a variant explicitly if they so choose."
cpp,3byjiu,david_sankel,1 point,Mon Jul 6 20:10:52 2015 UTC,"Changing the order of the types in Haskell sum types has no observable behavior in a program (unless one lets the compiler generate code automatically by e.g. deriving Ord). That is, one can change the sum type data T = A | B to be data T = B | A without altering the program's behavior.  C++'s Eggs.Variant goes pretty far into defining an ordering lhs < rhs for every variant:   if both lhs and rhs have an active member of type T:  *lhs.target<T>() < *rhs.target<T>(), else if !rhs: false, else if !lhs : true, otherwise: lhs.which() < rhs.which().   Only the last step depends on the order of the types within the variant and it is there to give an arbitrary unique order. Note that this order is as arbitrary as rhs.which() < lhs.which(). For instance it will give a non-meaningful order to variant<std::true_type, std::false_type>.  There are alternatives, for example D's std.variant throws an exception if the comparison is not sensible (see opCmp), and while Haskell let's you derive this order automatically, that is opt-in, the user can always derive the order manually.   In type theory variant<A,B> is different from variant<B,A> (see: https://en.wikipedia.org/wiki/Tagged_union)   Could you point to the part of the article where this is explained (or any other article)?   I'm not sure I understand the ""default initialization cost"" since one can always assign a variant explicitly if they so choose.   This only happens when one does not assign to a variant explicitly. As a consequence changing the order of the arguments might require to inspect all the places in a code base where the variant is default initialized without assigning it a value of a particular type explicitly. At this point we are better off without default initialization."
cpp,3byjiu,gnzlbg,2,Mon Jul 6 21:03:17 2015 UTC,"And what happens when I am modifying my code, and change it so that the first type no longer has a default constructor? It's very easy to do this without realizing it. Does it then go to default constructing the second type, or not having a default constructor?  I understand that regularity is a nice property, but I just think the cost is quite high. One of the main applications for a default constructor in practice is to have a state to leave moved-from objects in. But with a variant, if you request a move from one variant to another, you anyway just leave the variant in the moved from state of the type you've just moved.  Beyond regularity as a nice concept, what concrete reason is there to have default constructors?"
cpp,3byjiu,quicknir,2,Sat Jul 4 14:38:29 2015 UTC,"what happens when I am modifying my code, and change it so that the first type no longer has a default constructor?   The variant itself no longer has a default constructor.   One of the main applications for a default constructor in practice is to have a state to leave moved-from objects in.   We've had default constructors and regular types long before we had ""moved-from"" objects. I think the idea is that it is sometimes convenient to initialize the value of an object after it is constructed, and sometimes it makes a lot of sense semantically to have a default state (as in a variant<empty_t, A> modeling an optional value)."
cpp,3byjiu,david_sankel,1 point,Mon Jul 6 20:14:43 2015 UTC,"This is good to hear, I was worried that it would default construct the second type. Interestingly, that means that those that prefer a variant with no default constructor can trivially create one:  class ethereal {    ethereal() == delete;   ethereal(const ethereal &) == delete;   ethereal(ethereal &&) == delete; }  template<class ... Types> using my_variant = variant<ethereal, Types...>;   Or something similar. Since ethereal can never be created, there's no risk of putting one in the variant, so it's not necessary to check it for the ""invalid"" type."
cpp,3byjiu,quicknir,1 point,Tue Jul 7 03:45:47 2015 UTC,"In C++, constructors do 2 things - they acquire storage for an object and construct the object in that space. You can separate the two using placement new, but it is convoluted. I would really like to see a way in C++ to refer to an unconstructed object, which has storage but has no constructor called. Only thing you can do with such and object is call a constructor or free the memory. Then you can do things like destructive move on a stack allocated object which is not currently possible in C++.  Its possible, rust does something equivalent, but I am not sure if the requisite static checking can be bolted onto C++."
cpp,3byjiu,whichton,5,Sat Jul 4 23:07:26 2015 UTC,An explanation of the Lenexa variant design.
cpp,3byjiu,gnzlbg,3,Fri Jul 3 05:18:59 2015 UTC,"Hi Eric,  IIUC the main argument against an empty state is that the empty state becomes a common case, and as a consequence users need to be ready for it everywhere, which is really bad.  Still, the post says the following about the invalid variant:   The operations related to inspecting the variant’s contents have a validity precondition. Note that the valid() method, which returns a boolean corresponding to whether or not the variant is valid, has no preconditions.   If this precondition is checked, the empty variant can do the same to avoid the checks in user code. This makes empty variants more common than invalid ones, but it also makes empty variants fail loudly as opposed to e.g. default constructing an invalid variant to its first element, which might fail silently and behave differently depending on the order of the elements. In the mathematical discriminated union the order of the elements is irrelevant.  If this precondition is not checked in the invalid variant due to run-time cost, then the advantage of the invalid variant becomes way more clear. However, if the standard encourages implementations to assert the preconditions as a QoI issue, the advantage becomes less clear since this can also be done for the empty variant.  So I guess this means I'm still not sold. I would expect at first sight that a C++ variant follows ""don't pay for what you don't use"" and thus provide a zero-cost default constructor (i.e. default construct to empty). This will also allow default-constructing variants of non-default-constructible types.   It seems to me that the empty variant can provide a strong debug mode, and a fast-unsafe release mode, with the advantages of the invalid variant proposal plus some perks. I'm not sure if it's worth it."
cpp,3byjiu,gnzlbg,8,Fri Jul 3 09:36:51 2015 UTC,"If you want an extra state that is zero-cost to default construct to, with the Lenexa variant you just use empty_t (or monostate or whatever) as the first alternative. Giving all variants an empty state is paying for something that you don't need."
cpp,3byjiu,gnzlbg,1 point,Fri Jul 3 22:27:15 2015 UTC,"But then we are back to square one: users must pattern match on the empty state and deal with it everywhere.   I want the invalid variant proposal to default construct to the invalid state, not to some arbitrary value (like the first one). This gives a variant that works on non-default constructible types, has zero-cost default construction, is resilient to reordering of the variant types (like the mathematical discriminated union), and prevents users from dealing with an empty state everywhere.   What should happen when a user violates the variant's precondition? We have to answer this already anyways during unwinding, and there are a lot of choices, from just declaring this UB, to call std::terminate, throw, assert, ... I personally prefer UB + assert, but discussing this is a different issue.  EDIT: I just saw that /u/pfultz2 comment below discusses the same thing."
cpp,3byjiu,pfultz2,2,Sat Jul 4 10:27:34 2015 UTC,"But then we are back to square one: users must pattern match on the empty state and deal with it everywhere.   Not if you default-construct to the first alternative. Then the only source of invalid variants are failed assignments, which means that only exception-handling code will see the invalid state. All other code can happily assume the variant contains one of the alternatives.  If you default-construct to the invalid state, two bad things happen: (1) now all code needs to check for the empty state, and (2) you can't tell the ""bad"" invalid variants (those for which an assignment failed) from the ""good"" invalid variants (those that merely default-constructed into that state).   What should happen when a user violates the variant's precondition?   I prefer UB+assert, but that's a whole separate discussion."
cpp,3byjiu,david_sankel,2,Sun Jul 5 17:05:30 2015 UTC,"I prefer UB+assert, but that's a whole separate discussion.   I  agree, I prefer this too. UB + assert means you cannot use a variant that has an invalid state unless you opt into unsafely via -DNDEBUG.   Not if you default-construct to the first alternative. [...] If you default-construct to the invalid state, two bad things happen: (1) now all code needs to check for the empty state,   How so? Code can just assume the variant is not invalid. If it is invalid the program will just terminate, loudly.    (2) you can't tell the ""bad"" invalid variants (those for which an assignment failed) from the ""good"" invalid variants (those that merely default-constructed into that state).   To me they are both equally bad. Unless my duty is to initialize a variant, if I receive one I assume it has a value. If it doesn't the program will just terminate loudly.   Not if you default-construct to the first alternative. Then the only source of invalid variants are failed assignments, which means that only exception-handling code will see the invalid state. All other code can happily assume the variant contains one of the alternatives.   The problem I see with the first alternative is that:   it is an arbitrary choice (and has nothing to do with a mathematical discriminated union), it is sensitive to changes in the order of the variant parameters (a problem that is artificial to the mathematical discriminated union), it doesn't work if the first parameter is not default constructible.   That is: I'd rather have non-default constructible variants than variants that default construct to the first choice. In particular, variants should not have a notion of first, second, and third. They are not tuples, they do not support duplicated types, get<0>(variant) should be meaningless or simply just not work.  Either the user has to say explicitly to which element it does default construct, or we default construct it to an invalid state that makes the variant useless until someone assigns it a meaningful value (and fails loudly otherwise)."
cpp,3byjiu,pfultz2,4,Sun Jul 5 19:59:12 2015 UTC,"So I guess this means I'm still not sold. I would expect at first sight that a C++ variant follows ""don't pay for what you don't use"" and thus provide a zero-cost default constructor (i.e. default construct to empty). This will also allow default-constructing variants of non-default-constructible types.    Yes, it would seem better for variant to default construct to the invalid case."
cpp,3byjiu,pfultz2,5,Fri Jul 3 17:47:13 2015 UTC,"As Eric mentioned above, if you want this behavior you can supply your own empty_t or monostate as the first alternative of the variant. There is no performance penalty here. Most use cases of variant don't require this behavior so there's no benefit to push it on everyone."
cpp,3byjiu,gnzlbg,3,Sat Jul 4 04:04:07 2015 UTC,"However, that injects an empty state into the visitor. Rather, the only operations valid on the invalid state is assignment and destruction, which is true for default constructed regular types that are partially formed as well(such as ints).  Also, it may not be possible to change the variant to inject the extra state. For example, if it the variant is returned from a function like this:  variant<A, B> foo();   Then I can't write code like this:  variant<empty_t, A, B> x; x = foo();   Or can I? I would rather like to write code like this:  variant<A, B> x; x = foo();   Of course, that appears to lower the type safety. However, I think it would be better to improve the language to have better compile-checking for partially formed objects as that applies to more things than just variant.  Furthermore, even though compile-time checking is not planned to be added for partially formed objects(as there is no proposal for it), it would be better still to pick the better design(ie default constructor is partially formed), since it can't be changed latter when C++ has support for checking the use of partially formed objects."
cpp,3byjiu,gnzlbg,2,Sat Jul 4 04:45:22 2015 UTC,"However, that injects an empty state into the visitor. Rather, the only operations valid on the invalid state is assignment and destruction, which is true for default constructed regular types that are partially formed as well (such as ints).   If you default-construct to an empty state, you must handle it in visitation because these variants will be common.  Also, it's not accurate to say that an invalid variant is partially formed. In the thinking of the proposal's author, you can copy/move invalid variants, and you can as them if they're valid(). You just can't access one of the alternatives. In that sense, it's no different than an empty vector, from which you can't pop an element."
cpp,3byjiu,guepier,2,Sun Jul 5 17:10:48 2015 UTC,"If you default-construct to an empty state, you must handle it in visitation because these variants will be common.   Yes, thats exactly my point. We should be able to default construct a partially formed object, so we don't have to handle extra empty states everywhere.   Also, it's not accurate to say that an invalid variant is partially formed. In the thinking of the proposal's author, you can copy/move invalid variants, and you can as them if they're valid().   It would still be partially formed, since you can't use fully use the object yet, even though there may be a few more operations besides the basic assignment and destruction that are valid for partially formed objects."
cpp,3byjiu,gnzlbg,2,Sun Jul 5 17:48:46 2015 UTC,"Partially formed vectors do not exist, either the vector has some elements or it does not have any. Both states are fully formed. A variant is a different beast.  In my opinion a variant is more like an int and there are a partially formed ints:  int i;   Here i is partially formed, it doesn't have any meaningful value.   i = 3; int j = move(i);   After moving fromi, it doesn't have a meaningful value either: it is in a partially formed but destructible state.   None of this is true for vector. Moving from a vector gives an empty vector, which is in a fully formed and destructible state."
cpp,3byjiu,guepier,1 point,Sun Jul 5 20:22:36 2015 UTC,https://www.reddit.com/r/cpp/comments/3byjiu/a_variant_for_the_everyday_joe/csruni3
cpp,3byjiu,gnzlbg,2,Sat Jul 4 10:46:05 2015 UTC,"The problem is that the empty proposal sacrifices type safety. If the variant has a legitimate empty state, you cannot issue a compile-time guarantee about code with a “not empty” precondition.  With the invalid state, you can issue this compile-time guarantee: the only way of violating the validity of the variant is if your code is already in an invalid state (failure to handle exception properly). Importantly, failure to handle exceptions properly always puts your program into an invalid state, regardless of which variant design you choose (and also when there’s no variant in the code at all). So with the “invalid” variant proposal, there’s no additional weakening of the type system beyond what’s already there. With the “empty” variant design, we introduce an additional weakness into the type system, and furthermore one that is going to be very common: failure to initialise the object properly.  It’s generally agreed that compile-time safety is superior to runtime safety. By that maxim, the “empty” design is clearly inferior to the “invalid” design."
cpp,3byjiu,guepier,6,Fri Jul 3 11:19:36 2015 UTC,"I agree that the invalid variant is ""almost always"" compile-time safe, and that this is good.   This comes at the expense of less flexibility (non-default constructible types) and worse performance in some situations (no zero-cost initialization).   From a safety point-of-view, both variants need run-time checks everywhere to be completely safe since the invalid variant is not ""always"" compile-time safe. From an usability pov, user code is not affected by this since in both cases the checks can be inside the variant.  In some situations, I consider the invalid variant to be actually less safe than the empty variant. An example would be that forgetting to logically initialize properly an invalid variant can result in silent run-time logic errors. This is not the case for an empty variant since it fails loudly at run-time.   From a performance point-of-view, both variants need run-time checks everywhere. Unless the compiler can remove these checks everywhere where it is safe to do so for the invalid variant, the performance of both is the same. The empty variant has the small advantage of zero cost default construction."
cpp,3byjiu,gnzlbg,2,Fri Jul 3 11:35:31 2015 UTC,"I don’t think the missing default constructor is a problem — on the contrary, I think it’s kind of a boon. Having non-meaningfully initialised objects in your code is a flaw in the code. I certainly cannot remember the last time I’ve default-initialised an object or left it uninitialised1. Contrary to what you’ve said, this also doesn’t carry a performance penalty.   the invalid variant still has, in practice, run-time checks   Not during normal code execution, as far as I understand (that would be a major design flaw). During unwinding, sure. But performance isn’t relevant there.   Failing to logically initialize properly an invalid variant can result in silent run-time errors.   Can you give an example of this? I’m not sure I understand what you mean here.    1 The exception being when having an empty, pre-sized buffer for performance reasons. However, even this is something I very much try to, and usually can, avoid."
cpp,3byjiu,guepier,3,Fri Jul 3 11:51:23 2015 UTC,"I don’t think the missing default constructor is a problem    Without a default constructor a variant is not a Regular (nor a SemiRegular) type. Note that the empty variant is always default constructible, while the invalid variant is only conditionally default constructible (if its first type is default constructible).    Contrary to what you’ve said, this also doesn’t carry a performance penalty.   A variant that on default construction default constructs its first element carries a performance penalty over a variant that does nothing on default construction. Doing nothing is less work than doing something, this is in the spirit of C++ ""pay for what you use"".     the invalid variant still has, in practice, run-time checks   Not during normal code execution, as far as I understand (that would be a major design flaw). During unwinding, sure. But performance isn’t relevant there.   During unwinding the invariants of the variant must be checked ""on every method call"" (except for valid() and copy/move assignment); these checks are inside the variant methods. Calling these methods when no stack unwinding is taking place also performs these checks unless a sufficiently smart compiler can infer at compile-time from the ""type-safety"" provided by the variant that these checks are not necessary. I doubt such a compiler exist nowadays but will happily be proved wrong here.    Failing to logically initialize properly an invalid variant can result in silent run-time errors.   Can you give an example of this? I’m not sure I understand what you mean here   Sure:  // T,U,V are default constructible using my_variant = variant<T, U, V>; // ... far away my_variant a; // ... far away a.visit(...);   When calling visit with:   an empty variant: the variant is in an empty state, that is, visit will assert, throw, std::terminate, or in other words, fail loudly at run-time (at least in debug mode).  an invalid variant: T, it's first type, has been default constructed, so Twill be visited. This might be a logic error since the user did not explicitly initialize the variant with T. That is, this might always work, some times work, always fail, or fail only in front of a client. In particular, changing the definition of my variant to:  using my_variant = variant<U, V, T>;   will result in different run-time behavior, that again might always work, some times work, always fail, or fail only in front of a client. In particular, default constructing the first element has nothing to do with the underlaying mathematical concept of a discriminated union. I can see why it is practical to do so, but at the same time it feels a bit arbitrary, so I'd rather never default construct than default construct to the first element.   I certainly cannot remember the last time I’ve default-initialised an object or left it uninitialised   If you have used the STL, then you probably have used code that does."
cpp,3byjiu,david_sankel,3,Fri Jul 3 12:05:41 2015 UTC,"Without a default constructor a variant is not a Regular type.   Quite right, but not a big problem. Sure, regular types have some nice properties but it simply doesn’t make sense to shoehorn a non-regular type into a regular type shell at the expense of correctness.   Doing nothing is less work than doing something, this is in the spirit of C++ ""pay for what you use"".   Which is why a variant simply shouldn’t default construct. It’s a nonsense operation. The current proposal allows this for convenience but I think this will prove to be a mistake in hindsight. At any rate, users don’t have to use this property — they can ensure that their objects are always properly initialised. Like I said, I haven’t needed default-initialised objects in my code for ages, so there’s no performance penalty in practice.   these checks are inside the variant methods   Is the code actually (going to be) implemented like that? This would be a glaring quality of implementation issue, and I don’t believe it barring evidence. The proposal only mentions that index handles this case."
cpp,3byjiu,jackkuuse,3,Fri Jul 3 12:40:28 2015 UTC,"Quite right, but not a big problem. Sure, regular types have some nice properties but it simply doesn’t make sense to shoehorn a non-regular type into a regular type shell at the expense of correctness.   I'm undecided but since I lack practical experience using these variants (good that they go into a TS first!) I just by inertia would try to make it SemiRegular (which requires DefaultConstructible), and conditionally Regular.    Like I said, I haven’t needed default-initialised objects in my code for ages, so there’s no performance penalty in practice.   As I said, that you don't write them in your own code does not mean that you don't use code that uses them. The STL uses them for example. Variants are also a very common way of sending messages/events e.g. through a network or file I/O. You allocate a vector of ""empty"" variants, and use that as network buffer. Why would you initialize them to any value if you are just going to, right after, initialize them from data from the network. In particular, this is one of my most common uses of boost::container::vector since it has a constructor that allows you to do exactly this.   Is the code actually (going to be) implemented like that? This would be a glaring quality of implementation issue, and I don’t believe it barring evidence. The proposal only mentions that index handles this case.   I don't think it will be required, but implementations will hoepfully be encouraged by the standard to assert their preconditions. It is a one liner assert(valid());, and the precondition of which methods need a valid variant is in the standard text. I'm in general fine with undefined behavior as long as it delivers real value (e.g. performance) and is 100% preventable in debug mode."
cpp,3byjiu,guepier,1 point,Fri Jul 3 12:48:03 2015 UTC,"Fair enough, and that’s apparently what they did. The problem is that you effectively can never go back on this decision. We’re stuck with it for good once it ships."
cpp,3byjiu,jackkuuse,3,Fri Jul 3 12:50:49 2015 UTC,"these checks are inside the variant methods   Is the code actually (going to be) implemented like that? This would be a glaring quality of implementation issue, and I don’t believe it barring evidence. The proposal only mentions that index handles this case.    For the case of visit, you already need to inspect the index. For the case of get, you already need to inspect the index. There is no performance overhead of checking those invariants."
cpp,3byjiu,guepier,0,Sat Jul 4 03:59:24 2015 UTC,"I certainly cannot remember the last time I’ve default-initialised an object or left it uninitialised   using my_variant = variant<Expensive, AnotherExpensive>; std::vector<my_variant> vec(10); // 10 calls to Expensive default constructor...   here, you pay for what you don't use"
cpp,3byjiu,frog_pow,1 point,Sat Jul 4 09:50:44 2015 UTC,"Let me quote my own comment above, since you skipped over the relevant part:   The exception being when having an empty, pre-sized buffer for performance reasons. However, even this is something I very much try to, and usually can, avoid.   I rarely use empty, pre-sized vectors. Either I reserve the necessary size or I’m using an appropriate constructor to initialise the vector correctly from the get-go."
cpp,3byjiu,david_sankel,1 point,Sat Jul 4 10:12:48 2015 UTC,"I rarely use empty, pre-sized vectors. Either I reserve the necessary size or I’m using an appropriate constructor to initialise the vector correctly from the get-go.   Not using it yourself does not mean others do not use it. This overload of vector constructor has existed for a long time and must probably be used quite much. And it is a problem with the ""invalid"" flavor of variant."
cpp,3byjiu,ThePhantomDerpstorm,2,Sat Jul 4 12:21:26 2015 UTC,"Not using it yourself does not mean others do not use it.   There are tons of things people do that we don’t need to encourage. Now pre-allocating a vector’s space isn’t a problem per se — but with a type like variant it is. There’s no obligation at all for library implementors to support this pattern, since it is problematic and there are better alternatives.  EDIT: And just to get misunderstandings out of the way, preallocating vectors of variant is of course not a huge problem either way. What I’m saying is that not supporting this operation is nowhere near as tragic as some of the debaters here seem to think. People would notice it not working, would shrug and find another (and, often, better) way of solving their problem."
cpp,3byjiu,ThePhantomDerpstorm,2,Sat Jul 4 12:48:31 2015 UTC,"Bleh, I thought we weren't supposed to pay for what we don't use.  Most people don't use exceptions or care about them. And especially out of memory exceptions, trying to handle that is waste of time.  Just make it not default constructable, no silly ""invalid"" state, and ditch the horrible code to handle pointless exceptions like OOM."
cpp,3byjiu,david_sankel,3,Sat Jul 4 04:00:22 2015 UTC,You aren't paying for what you don't use in this case. If you don't handle out-of-memory exceptions then your variants will always be valid and you never have to care about the invalid state.  Whether or not a variant is default constructable has nothing to do with exceptions. The Lenexa variant will only be default constructable if the first alternative is default constructable.
cpp,3byjiu,sakarri,1 point,Sat Jul 4 04:21:01 2015 UTC,"I have a bit of a question, because I saw all these posts about variants and the committee... and has it occurred to anyone that they could maybe just add a policy parameter to the variant to allow for a person to choose what happens in these exceptional conditions?  I know for the default argument case, I managed to basically create a policy called union_policy that makes it behave like regular union. And then there's an optional_policy that allows the variant to be constructed in the empty state...  My implementation isn't complete, and I still need to figure out the additional places I could use the policy, but the variant_base (or what should probably be called basic_variant to make it like the string style of standardese-naming...) works pretty well in enforcing requirements so far: https://github.com/ThePhD/Furrovine.Heart/blob/master/include/Furrovine%2B%2B/variant.hpp#L77 -- there might be a bug or two since it's not as in-depth as boost::variant or even the everyday variant presented here."
cpp,3byjiu,quicknir,5,Fri Jul 3 16:35:26 2015 UTC,"As others have mentioned, since this is a vocabulary type that will likely appear in library interfaces, you really have to man up (ehm, person up) and pick a design. Having 2 or 3 or N variant types is the worst of all possible worlds, IMO."
cpp,3byjiu,sakarri,1 point,Fri Jul 3 22:31:05 2015 UTC,"I would like the ability to have a single type that's used at the interface boundaries that everyone agrees is the best default. But I would also like, for other use cases, to be able to flex the design a little bit: I think that flexibility is worth it, given the amount of discussion around which one would be right in the first place. Having a ""tough, this is the standard one"" is great and all, but I'd still like a ""and you can adapt for this other one if you like, too"".  E.g., having a variant<...> = basic_variant<union_policy, ...>; that the standard library typedefs/usings for us so that everyone who uses the regular ""variant"" vocabulary can get behind (or whatever style of variant people get with), while people who deal with the empty-default cases can enjoy their optional_variant<...> = basic_variant<optional_policy, ...> without having to explicitly wrap it up in an optional<> or some such."
cpp,3byjiu,ThePhantomDerpstorm,1 point,Fri Jul 3 23:49:00 2015 UTC,"people who deal with the empty-default cases can enjoy their optional_variant<...> = basic_variant<optional_policy, ...> without having to explicitly wrap it up in an optional<> or some such.   As the post hopefully demonstrated, there isn't a compelling benefit to having a variant without an invalid state. The only reason someone would want this is if they are doing some thing wrong in their exception handling code."
cpp,3bw7al,eons93,14,Thu Jul 2 17:33:50 2015 UTC,"Honestly, for C++, you'll benefit more from a good book than any online resource. Check out the recommended book list on Stack Overflow."
cpp,3bw7al,bstamour,1 point,Fri Jul 3 00:21:54 2015 UTC,"I agree. Websites tend to be a little superficial; books tend to be more rigorous. I'm halfway through C++ Primer (because I saw it listed on there) and I feel lucky that I found it. If you want to really get to know the language more than hobby-depth, I say start there. Not for the impatient, though. For example: the if statement isn't really introduced until around page 180. (It never really feels slow though). But for sure, the investment in a solid foundation will pay off not just for C++, but your whole programming experience."
cpp,3bw7al,manowar2324kenshin,2,Fri Jul 3 00:56:54 2015 UTC,"I really highly recommend Accelerated C++. It's one of the first more modern C++ approaches, where it starts off by teaching you how you should do things in C++ using the STL.  The older way of learning C++ is teaching pointers and arrays for months, and then eventually the students learn that you're not supposed to use these things 99% of the time.  Accelerated is a great book, and it's probably the fastest way you can start writing some small programs that do something interesting  as STL suggests.  After you finish that book and write a few programs, I'd follow up with both a) Effective C++ by Scott Meyers, and b) any resource on pointers and the lower level parts of C++, as you will eventually need it.  Once you've assimilated all this and you're able to apply it, you'll be a strong beginner."
cpp,3bw7al,quicknir,5,Fri Jul 3 02:03:05 2015 UTC,"If you genuinely seriously want to get up on C++ as quickly as possible, I always recommend buying Nico's ""The C++ Standard Library"" (the C++ 11 edition) and memorising it, which will take you about 100-200 hours.  I reckon doing this will shave a good 2000-2500 hours from the 10,000 hours required to become fairly proficient in C++. It's the single best investment of your time you can do when learning C++."
cpp,3bw7al,14ned,6,Fri Jul 3 08:54:29 2015 UTC,"Go to https://github.com/fffaraz/awesome-cpp Find any project written in C++ that you find interesting Get it to build Contribute patches   You will be doing something useful with your time, you will get your code reviewed by more experienced programmers and you even do something you can mention in your CV when applying as a C++ programmer. There is no better way to learn IMHO.  Edit: point to a project on github about awesome C/C++ stuff:-) It lists my favorite (Qt Creator), so that must be good:-)"
cpp,3bw7al,t_hunger,1 point,Thu Jul 2 18:02:24 2015 UTC,"I took a look and understood very little. What's cv, qt, and the d3j thing says its JavaScript. Sorry, I'm like an beginners with basic knowledge, not sure I'm ready for that."
cpp,3bw7al,STL,5,Thu Jul 2 19:19:49 2015 UTC,"I recommend writing small programs that do interesting things. For example, I learned C++ by implementing a data compressor."
cpp,3bw7al,t_hunger,3,Thu Jul 2 19:53:19 2015 UTC,"""CV"" is that thing potential employers want you to sent to them so that they can read through it and then maybe invite you to an interview. It is always nice if you can point to some pieces of code used by real people that you actually wrote in there.  Qt is a C++ toolkit that provides things like basic data structures and more complex things like user interface elements. Qt Creator is an integrated development environment built using Qt (also written in C++). No idea what that d3j thing is though.  The URL I put into my last comment is just a list of cool projects written in C++. Just poke around in that list, find something you are interested in and start reading the code. Build the project, then look into the bug tracker of that project and try to find a bug that you can reproduce, then try to fix it. You will fail a couple of times, but you will also learn a lot:-) Once you fixed some bug, send your patch to the project and they will tell you how to improve it and eventually apply your patch (usually after several iterations).  Especially the part where more experienced devs comment on your code is invaluable, or at least was to me when I started with C++.  Yeap, this is a lot harder than following some tutorial, but you are doing something that produces actual results and you get feedback - no tutorial can provide that!"
cpp,3bw7al,t_hunger,1 point,Thu Jul 2 20:01:54 2015 UTC,"I'll take a look when I get home, won't open on phone, but I think I worded my post badly. I probably a collective knowledge of 20 hours of c++ knowledge. And that high balling. I'll still give it a try but I had more in mind as a tutorial series. Thanks for the help though."
cpp,3bw7al,neet_programmer,2,Thu Jul 2 20:59:09 2015 UTC,"I got that, but a programming language is a bit like a normal language: You need to use it to learn it.  Get a good book on C++ and start to read code. Try to understand it (Google helps a lot here as it lets you look up stuff) and play with it. Try to improve it.  Open source is a great way to learn IMHO: You get to work on a real project and not just the toy stuff found in tutorials and examples. Navigating a real project is a skill in and off itself and you can not pick that up with toy projects."
cpp,3bw7al,batty_alex,5,Fri Jul 3 05:39:20 2015 UTC,"Someone really need to make a proper C++ tutorial that teaches to C++s strengths. Most of the learning material I've found online don't even touch on the STL, and if they do it's usually an appendix.  Maybe I need to get on that..."
cpp,3bw7al,STL,3,Thu Jul 2 22:03:35 2015 UTC,"It's MSVC, but channel 9 has a good series on the STL from one of Microsoft's keepers of the implementation at the time: https://channel9.msdn.com/Tags/stephan-t-lavavej?page=3  I remember it being aimed more towards intermediate devs, though."
cpp,3bw7al,neet_programmer,8,Thu Jul 2 23:12:10 2015 UTC,"My original STL series was aimed at intermediate-level programmers with a reasonable familiarity with the Core Language (like, you know what for-loops are, and how to call functions), but it assumed no prior knowledge of the Standard Library."
cpp,3bw7al,ChrisSharpe,1 point,Thu Jul 2 23:23:29 2015 UTC,Stl?
cpp,3bw7al,STL,3,Thu Jul 2 22:45:30 2015 UTC,"Standard template library. I highly recommend looking it up as it unlocks pretty much the most useful features of the language. Especially std::vector, std::unique_ptr and the whole algorithms library(look up lambda functions in C++).  Reference for the standard library here."
cpp,3bw7al,autowikibot,3,Fri Jul 3 10:23:44 2015 UTC,"The other answers are correct, but: The STL was the name of a library from which components were taken to put into the Standard Library. There is nothing in C++ that officially is called the STL. But you will hear people talk about it a lot. It can sometimes be rather confusing to know if they mean the original version or the standardised version. Such is life, the unofficial name has stuck."
cpp,3bw7al,ChrisSharpe,3,Fri Jul 3 14:57:38 2015 UTC,"It's metonymy. People mean either ""the C++ Standard Library"" or ""the subset of the C++ Standard Library that was strongly influenced by the historical library"". They're never talking about the historical library, except when it's obvious.  It's like the White House. People mean the executive branch of the US government, except when they're obviously talking about the historic mansion."
cpp,3bw7al,STL,2,Fri Jul 3 18:30:10 2015 UTC,"Metonymy:       Metonymy (/mɨˈtɒnɨmi/ mi-TONN-ə-mee)  is a figure of speech in which a thing or concept is called not by its own name but rather by the name of something associated in meaning with that thing or concept.  The words ""metonymy"" and ""metonym"" come from the Greek: μετωνυμία, metōnymía, ""a change of name"", from μετά, metá, ""after, beyond"" and -ωνυμία, -ōnymía, a suffix used to name figures of speech, from ὄνῠμα, ónyma or ὄνομα, ónoma, ""name"".   For instance, ""Wall Street"" is often used metonymously to describe the U.S. financial and corporate sector, while ""Hollywood"" is used as a metonym for the U.S. film industry because of the fame and cultural identity of Hollywood, a district of the city of Los Angeles, California, as the historical center of film studios and film stars.  The national capital is often used to represent the government or monarchy of a country, such as ""Washington"" for United States government.  Metonymy and related figures of speech are common in everyday talk and writing. Synecdoche and metalepsis are considered specific types of metonymy. Polysemy, multiple meanings of a single word or phrase, sometimes results from relations of metonymy. Both metonymy and metaphor involve the substitution of one term for another.  In metaphor, this substitution is based on some specific analogy between two things, whereas in metonymy the substitution is based on some understood association or contiguity.       Relevant: Metaphor and metonymy | Bench (metonymy) | Condensation (psychology) | Trope (literature)   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
cpp,3bw7al,ChrisSharpe,1 point,Fri Jul 3 18:30:44 2015 UTC,"I brought it up because I've had genuine confusion over it. In the last month, at least. For some reason, discussions here (my office) that mention the original STL are not as rare as you might think. There are a few Stepanov fans around, especially with his 2 books out over the last few years, and the interest in generic programming coming from the concepts work."
cpp,3bw7al,lurkotato,1 point,Mon Jul 6 06:16:31 2015 UTC,"Well, people should be more careful when they're talking about the Russian White House, to explain that they're referring to the lesser known thing."
cpp,3bw7al,NotUniqueOrSpecial,1 point,Mon Jul 6 06:35:39 2015 UTC,"If people are genuinely confused by that reasonably often, then yes, they should."
cpp,3bw7al,blind-raven,3,Mon Jul 6 09:16:53 2015 UTC,/u/STL   </snark>
cpp,3bw7al,blind-raven,2,Fri Jul 3 16:17:04 2015 UTC,"Standard Template Library. It's the language's standard-defined library of containers (vectors, lists, etc.), algorithms (sorting, finding, etc.), and more."
cpp,3bw7al,blind-raven,2,Thu Jul 2 23:01:24 2015 UTC,"An approach that's worked well for me and which I heartily recommend is to pick up a comprehensive book and delve into a project you find interesting.  Read the book in parallel with your project's development.  If, in the course of coding, you run into a roadblock, look further in the book or online for a possible solution.  Often times you will discover multiple ways of solving a problem, each with their own strengths and weaknesses.  Eventually you will develop your own style, preferences, and an intuition regarding what components of the language might be suitable for a given task.  Do you mind if I ask where in computing your interests lie?"
cpp,3bw7al,gott_modus,1 point,Fri Jul 3 04:51:52 2015 UTC,"I know it's hard to get into as far as the whole scope of programming goes but I'd prefer game design. That said, I want to do the least amount of school possible."
cpp,3bw7al,doryappleseed,1 point,Fri Jul 3 05:27:47 2015 UTC,"I was anticipating it would be game design.  It seems to be a thing that draws a very large number of people into programming.  Games programming is a wonderful pursuit in how much it draws from so many other areas of computer science: graphics, algorithms, data structures, simulation, etc.  That said, you're already further ahead than most, in that you recognize it as a challenging area.  While not exactly game design, what do you think of computer graphics?  It plays a large part in games programming, and is not as 'dry' for most as algorithms work is.  And you pick up quite a few special algorithms along the way.  Exploring computer graphics would give you solid knowledge of what is a large portion of modern commercial game engines.  And it's fun (or, at least, I thought so) to build a simple game engine with that knowledge.  I completely understand the desire to learn on your own -- it's how I do it.  If you want to go that route, then definitely shop around for a well-respected text book on the subject you end up delving into."
cpp,3bw7al,CubbiMew,0,Fri Jul 3 14:38:08 2015 UTC,"tell me more about ""computer graphics."" when i start up dark souls 2, what parts of the game is computer graphics? I'm interested in doing anything programming for video games, my dream job would be a game designer but a designers rarely sits in an office all day pitching ideas, they have some other skill they through into the field to help make that game. Hell, software programming is a close second but I have all these ideas that I'd love to implement."
cpp,3bw7al,gott_modus,1 point,Fri Jul 3 15:05:10 2015 UTC,"Well, I've always believed programming to be just another tool, but that's because I am an ideas person focussed on c.s. theory.  Programming is a mode of expression, enabling us to actually implement ideas, building fantastic worlds inside these universe-boxes we call 'computers.'  So, I'd say knowledge of programming is essential to being a designer of any kind of software system.  Certainly, ideas change form depending on the constraints placed upon their realization.  In brief, computer graphics is concerned with all aspects of producing images using a computer.  That's not an 'image' in the sense of a *.png image, but 'image' as in any graphical depiction of a scene.  The field has evolved considerably since its inception, and so has a very mature, easy to grasp theoretical background.  Modern computer graphics sees expression in building and rendering scenes with a computer's graphics card, be it integrated or discrete, PC or console.  In most all games, including Dark Souls 2, the entire visual experience is accounted for by computer graphics.  Every visible object in the game world needs to be drawn in order to be seen, and graphics programming is just the way this is accomplished.  There's so much more to it than that, but this is the best high-level summarization/sales pitch I can come up with.  And this comment is becoming rather lengthy."
cpp,3bw7al,TankorSmash,0,Fri Jul 3 16:38:02 2015 UTC,"so as a computer graphics programmer, i would be implementing the 3d/2d models into the game? what kind of schooling do you see this taking? Do you work at a video game studio of some kind?"
cpp,3bug6u,al-khanji,14,Thu Jul 2 06:25:09 2015 UTC,"We're happy to announce the release of Qt 5.5.  For me the highlights of this release are support for Windows 10 and improved 3D functionality.  Under Windows 10 Qt applications can be run as either traditional Win32 applications or as WinRT applications - just choose the appropriate platform plugin. This also means that you can upload your applications to the Windows Store, which requires WinRT. Note however that automatic styling is not yet supported in the WinRT port. Once Windows 10 is released we will add official support in the next Qt 5.5.x patch release.  On the 3D side of things the Qt Canvas 3D module has moved from tech preview to fully supported status. Qt Canvas 3D exposes a WebGL-like API within Qt Quick. For a higher-level API we ship a port of three.js. Additionally Qt 3D is now available as a tech preview. The API has been completely revamped from the Qt4 times, courtesy of KDAB.  On the commercial side we've simplified the product offering. We are of course also fully committed to the open source version. At the Qt Contributor's Summit that was held in Oslo last month we discussed with the community how to decrease the differences between the open source and commercial versions, and I'm hopeful that before long we will be able to open many of the currently commercial components.  Thanks to the entire Qt community and to all of our loyal customers!"
cpp,3bug6u,arendjr,6,Thu Jul 2 06:49:49 2015 UTC,"Oh, one more thing - we've now added support for C++ value classes to QML, which has been requested often. In practice you can now expose any class to QML, no need to inherit from QObject. See here for an example."
cpp,3bug6u,playmer,1 point,Thu Jul 2 06:51:21 2015 UTC,"Thanks! I think I was the one who opened the original ticket requesting support for value classes. That really was sorely missing from the QML engine if you were used to Qt Script, glad it's supported now!  I was a bit worried when Qt Script was being deprecated, but with this I hope I can port my code to use the QML engine now :)  Edit: Found the ticket: https://bugreports.qt.io/browse/QTBUG-29769"
cpp,3bug6u,playmer,1 point,Thu Jul 2 08:20:03 2015 UTC,"Always good to see tickets marked as done. :)  Note that Qt Script is not yet deprecated - we've merely announced our plan to do so, to make people aware of it. Currently the plan is to deprecate it in Qt 5.7, Qt 5.6 will still include it.  We're also planning to drop support for C++98-only platforms with Qt 5.7 to utilize newer C++ features. Currently the plan is to require at least GCC 4.7 and MSVC 2012. We would have liked to move to MSVC 2013, but unfortunately the latest compiler available for Windows Embedded Compact is MSVC 2012. However, within the limits of MSVC 2012 we can finally start to use more modern approaches.  edit I am referring here to Windows Embedded Compact 2013."
cpp,3bug6u,givemesomelovee,2,Thu Jul 2 09:28:05 2015 UTC,"By the way, when do you plan to start shipping VS 2015 built binaries? We do two semester long game projects at my school and we're planning to integrate Qt for our editor. So far I've set it up and played around with prototyping interface stuff. But I'm planning to evaluate VS 2015 sometime in August so that we can get all the C++ features we want, but I wasn't sure how easy it would be to get the pre-built Qt binaries (or even just building it myself). (We only have one other dependency.)  Also thanks for all the hard work you guys put in! Qt is pretty great!"
cpp,3bug6u,dodheim,1 point,Thu Jul 2 19:39:35 2015 UTC,"Qt 5.5 already should compile out of the box with VS 2015 but since there isn't yet an official release of the compiler the support is tentative.  Once VS 2015 is officially supported the plan is to add official support in the next patch release. Qt 5.5.1 is currently scheduled for September, but I don't know for sure which binary builds are planned."
cpp,3bug6u,dv_,2,Fri Jul 3 07:49:42 2015 UTC,"I understand, and appreciate the response! Consider this my vote toward doing a build on that platform. (If it's not too much trouble!)"
cpp,3bug6u,jgcoded,2,Fri Jul 3 08:05:51 2015 UTC,automatic styling is not yet supported in the WinRT port   What do you mean by automatic styling?   Also I'm currently learning QT and I would like to say it is an amazing piece of framework and everything right from community to IDE is perfect :).
cpp,3bug6u,SGH-5450,2,Thu Jul 2 08:31:59 2015 UTC,Drawing controls using Windows' built-in theming system.
cpp,3bug6u,SGH-5450,2,Thu Jul 2 09:20:09 2015 UTC,"Thanks for the kind feedback. :)  While both QtWidgets and QtQuick work, they do not currently automatically follow the platform style. We're currently researching how to support this on WinRT, but I'm unfortunately not 100% up to date on the latest status."
cpp,3bug6u,STL,6,Thu Jul 2 09:38:04 2015 UTC,"Yaay, GStreamer 1.0 support! ｡◕‿◕｡"
cpp,3bug6u,STL,1 point,Thu Jul 2 11:52:47 2015 UTC,Please let us know how it works for you - it's the first release where we support it officially!
cpp,3bug6u,SGH-5450,2,Tue Jul 7 06:29:58 2015 UTC,I'm using a qwidget control that comes from a third party dependency in one of my projects. Am I now able to use that qwidget control in a QML application?
cpp,3bug6u,SGH-5450,2,Thu Jul 2 15:33:07 2015 UTC,"As far as I know this is currently not possible.  You can embed Qt Quick within a traditional QWidget-based application using QQuickWidget, but unfortunately this is currently not possible the other way around.  Perhaps it's possible to reuse the base code of the widget by porting it on top of QQuickPaintedItem? The way this is done is analogous to working with a QGraphicsItem."
cpp,3bug6u,tcris,2,Tue Jul 7 06:33:50 2015 UTC,Feedback: ANGLE fails to build on Nuwen 5.1 MinGW (tries to call sprintf_s). Didn't look at it that much due to lack of time. Can it be fixed via ./configure ?
cpp,3bug6u,kozukumi,2,Fri Jul 3 01:26:09 2015 UTC,"Nuwen 5.1 MinGW   I don't think we test this compiler. Can you open a bug report and attach a build log?   It looks like there was a similar bug previously, my guess is that the patch needs to be updated. It looks like it shouldn't be hard to fix though."
cpp,3bv6jw,nikbackm,24,Thu Jul 2 12:26:24 2015 UTC,"There's IMHO too much time spent discussing Rust in the c++ reddit, and especially Rust's borrow checker. Actually, I think I would welcome hearing more about some other part of Rust.  I've worked on several large c++ codebases that used smart pointers, older ones using boost's scoped and shared, newer ones using a lot of unique. None of them have issues with memory leaks, double frees, etc. Achieving that wasn't a matter of doing a lot of extra work. It was very natural, use smart pointers for ownership and raw pointers/references for views (mostly commonly for passing into functions).  I think that empirically in terms of programming hours, the article's claim of ""so much more can be done"", is maybe 5 or 10%. In other words, in terms of time spent to produce high quality code, the current system in c++11 (with regards to pointers and ownership) gets us at least 90% of the way there (compared to the new/delete days).  So while I appreciate the author's points (and in particular, if he thought of what is basically very similar to Rust's borrow checker independently, he deserves huge kudos), I think it's a lot of work to solve what is now a very small problem. By the way, if you want to be even more clear that passing a raw pointer constitutes a view to the object, you can use observer_ptr: http://mnmlstc.github.io/core/memory.html."
cpp,3bv6jw,quicknir,6,Thu Jul 2 15:26:48 2015 UTC,Thanks for the shoutout! :)
cpp,3bv6jw,SAHChandler,7,Fri Jul 3 00:11:46 2015 UTC,Thanks for the code!
cpp,3bv6jw,quicknir,6,Fri Jul 3 01:09:15 2015 UTC,"Yep. Sometimes I wonder if the extra complexity and annoyance that Rust goes through to guarantee that last 10% at compile time is really worth it, when you consider too that that last 10% is often used as a way to do quick prototypes when the ownership is not set yet. Something I would see in C++, rather than a port of Rust's borrow checker, would be some way to make an object ""lose uniqueness"" explicitly and be upgraded to be garbage collected. In new code I write, most objects are on the stack and 95% of the heap is in unique pointers. GC's are not universally bad, and if they could be transparently used in this hard-to-manage 5% they would have a good chance of being simpler and more efficient than shared/weak pointers kludges.  The current hate for GC's was born from GC's trying to be a golden hammer to the point of replacing the stack, but I think in 4-5 years we'll realize it was an overreaction."
cpp,3bv6jw,mojang_tommo,1 point,Thu Jul 2 17:28:00 2015 UTC,"if they could be transparently used in this hard-to-manage 5%   That's a nice idea but achieving that transparency is hard (if not impossible) to do in practice, IME."
cpp,3bv6jw,mcmcc,3,Thu Jul 2 19:33:34 2015 UTC,"Yep. If you just take Rust and replace all cases where you need to tag a reference with an explicit lifetime with ""upgrades to GC"", that's still a whole lot more than 5%, and a GC pointer is owning where a ref is not, so you lose semantics as well."
cpp,3bv6jw,mojang_tommo,1 point,Thu Jul 2 19:53:03 2015 UTC,"I think it is worth it.  Rust does a lot of things built in elegantly that people have figured out how to build in to C++.  Both work but Rust will probably end up being a little more readable.  Since we know how valuable deterministic yet automatic memory handling is, it makes sense to have it built in.  I agree that a fair amount of gc difficulty is due to wayyy too much being on the heap in the first place, and the objects on the heap that can go away at scope exit being tracked by a GC.  I actually have not yet even needed a shared ptr after 2 years. Even unique_ptr is something I've uses sparingly (many times due to atomics).  Even so, when memory is an issue, having deterministic memory freeing at the soonist possible point is vital.  The next big issue though is concurrency. Just like memory everyone is realizing that higher level primitives are needed on top of threads, mutexes, and atomics."
cpp,3bv6jw,__Cyber_Dildonics__,0,Fri Jul 3 21:57:52 2015 UTC,"Because of the blowing feet ! Seriously. Given a big enough codebase, errors will be made. Either because you are tired or because your coworker is a moron. Both will occur. The breakage may be hard/costly to track.  Linus chose a minimalist (or, at least very understood) language to ease peer review.  The rust guys came up with more compile-time guarantee.  And, as crazy as it seems, it's easier to come up with a new, innovative language + its libraries than to hire and educate, top notch & rigorous developers.  And no. Producing high-quality code at scale is neither a small problem, nor a solved one. Look at the average enterprise code.  On the other and, C++, notably clang; gets better and better at static analysis, and detecting some errors mentioned in the blog post seems quite doable.  mostly, use-after-move errors can probably be tracked down nicely."
cpp,3bv6jw,c0r3ntin,2,Fri Jul 3 21:42:31 2015 UTC,"Please if you're going to paraphrase me, do so correctly. I did not say that producing high quality code at scale is a small or solved problem. All my comments were strictly confined to pointer/ownership/memory related issues, and I stand by my comment.  I haven't spent even 10 minutes in the last two years tracking down memory leaks or double frees that would stem from issues like this.   I have spent hours tracking down double frees that resulted from static initialized singletons (i.e. singletons that were initialized before main entered), and vagaries of the linker. Rust doesn't have life before main at all. Is this good, or bad? I don't know, it has pros and cons. Talking about that would beat talking about the borrow checker for the tenth time, though.  A lot of enterprise code also has tons of legacy code in it, and has memory leaks since 1995 that were never dug up, and now valgrind has too much noise to help you locate the segfault you just introduced, etc... This is not an apples to apples comparison with rust, and not what I was talking about.  Using after move is not an error necessarily in C++, because unlike Rust, things are in a valid state after. Also unlike Rust, in C++ moves only occur with temporaries that you cannot use afterwards (because they're gone and no variable refers to them), or when you explicitly ask for one. Using after move may be a logical error, but because it would involve an explicit cast, it's extremely rare in my experience."
cpp,3bv6jw,quicknir,14,Sun Jul 5 03:44:38 2015 UTC,"These examples are... Really really underwhelming. You're supposed to use unique ptrs as the exclusive owner of the object; passing a raw pointer (for instance, as required by an API) should not open you up to risk of that pointer being deleted. Even if there was no .get(), I can always do &*my_unique_ptr.  Or, for instance, that Foo object that deletes the Bar ptr. Obviously, it should itself be using a unique ptr rather than a raw ptr. If it absolutely must use a raw ptr, transferring a unique ptr to it should be done via .release, not .get. These features and usage patterns are well documented."
cpp,3bv6jw,Lucretiel,8,Thu Jul 2 18:47:28 2015 UTC,"6 years old, why post now?"
cpp,3bv6jw,TemplateRex,-3,Thu Jul 2 12:58:53 2015 UTC,"Seems like an interesting parallel to Rust, that was just released. C++ could/should have gotten there first! ;)"
cpp,3bv6jw,suspiciously_calm,2,Thu Jul 2 14:43:47 2015 UTC,"While I like the type system in Rust, this just seems to produce too many problems for interfacing with existing code to be feasible in C++.  Not leaking raw aliases from a unique pointer isn't that hard if your code (and the code you're interfacing with) is reasonable. (If you actually go ahead and store a global pointer to an object whose lifetime you do not control, then you deserve to get shot.)"
cpp,3bv6jw,guepier,3,Thu Jul 2 20:19:52 2015 UTC,"The article gives this definition of unique_ptr:   It is a (smart) pointer that is the only reference to the object it’s pointing to.   This is really wrong, and a glaring misunderstanding of the semantics of unique_ptr. In reality, unique_ptr dictates ownership semantics, it (deliberately) says nothing about the number of references. So, let’s correct the definition given above:   unique_ptr is a (smart) pointer that is the only owner of the resource it’s pointing to. Only it, and nobody else, is allowed to manage the resource’s life time.   With this realisation, some (but not all) of Bartsz’ objections simply go away. More importantly, there are other designs that restrict the number of references rather than owners of a resource. However, they are very restrictive in practice, which is the reason for unique_ptr’s design.  Incidentally, this is a mistake that many made at the time (2009), and I don’t think Bartosz would make it now."
cpp,3bv6jw,whichton,2,Fri Jul 3 11:31:04 2015 UTC,"This would be great, but doubt it will ever get added to C++. I will be happy enough with a destructive move in C++ 17 in the meantime, but it seems that is not happening :(."
cpp,3bv6jw,minno,4,Thu Jul 2 17:20:21 2015 UTC,"If you're interested in seeing an application of these ideas, check out the language Rust."
cpp,3bv6jw,whichton,1 point,Thu Jul 2 13:26:59 2015 UTC,"Also, if you are interested in the underlying theory, google Linear type system."
cpp,3bv6jw,neet_programmer,1 point,Thu Jul 2 17:13:03 2015 UTC,"So many of the examples given here really come down to just not understanding the language. While rust can do a lot to ensure safety, imo it actually kind of gets in the way when designing more complex algorithms. Just test all the code you write! It never works the way you want it to on the first try.  Also: regular C-style pointers are not obsolete! You can still use them! Honest!!"
cpp,3bv6jw,peolorat,2,Fri Jul 3 10:30:56 2015 UTC,"Also: regular C-style pointers are not obsolete! You can still use them! Honest!!   Indeed. If you have a std::unique_ptr<Foo> that owns a Foo object, and you need to pass this Foo object into another function; don't pass a reference to the unique_ptr, pass a raw pointer.  Don't do this:  void func(std::unique_ptr<Foo> &obj) {     // stuff }  void main() {     auto foo = std::make_unique<Foo>();     func(foo); }   Do this:  void func(Foo *obj) {     // stuff }  void main() {     auto foo = std::make_unique<Foo>();     func(foo.get()); }"
cpp,3bv6jw,eras,1 point,Sat Jul 4 22:47:12 2015 UTC,"Why not use a reference, though?"
cpp,3bv6jw,grumbel,1 point,Sun Jul 5 11:38:49 2015 UTC,"Better yet, do this:  void func(Foo & obj)   or  void func(Foo const& obj)   No need to play with raw pointers unless you are dealing with C code or require nullptr as a valid value."
cpp,3bv6jw,Minecraft_Expert,-4,Sun Jul 5 11:39:56 2015 UTC,"/u/mojang_tommo I saw your tweet: ""It could be a bit late to have it in 0.12, but if there aren't huge stoppers it could be possible :)"" are you indicating that you and /u/darngeek are just working on a few features for 0.12.0 whilst the team in Redmond have been working on bigger features for a while, so release will be quite soon? :P"
cpp,3btsf5,solodon,24,Thu Jul 2 02:18:06 2015 UTC,wtf
cpp,3btsf5,pepper_chico,7,Thu Jul 2 02:36:56 2015 UTC,This is voodoo to me. And I LOVE IT.
cpp,3btsf5,Xirious,-1,Thu Jul 2 22:32:21 2015 UTC,"Or more importantly, why? What is the practical usage for doing this?"
cpp,3btsf5,Deadboss,9,Fri Jul 3 01:31:57 2015 UTC,Intellectual masturbation
cpp,3btsf5,aport,2,Fri Jul 3 05:19:09 2015 UTC,Ok thanks... was just wondering.
cpp,3btsf5,Deadboss,10,Fri Jul 3 05:48:24 2015 UTC,"Since the program must be run (repeatedly) to play, it's a little inaccurate to call this whole system ""compile-time"".   It's still an interesting project.  Compiling the code produces a binary.  Running the binary produces updated code."
cpp,3btsf5,shmoopty,6,Thu Jul 2 04:44:07 2015 UTC,So what are you proposing?  Entering commands into the console during compile-time?  Interactive compiling?  That would be an amazing feature!!! Looking forward to C++20
cpp,3btsf5,neet_programmer,7,Thu Jul 2 21:53:29 2015 UTC,Print the code for the next step as a compiler error message.
cpp,3btsf5,3453280,1 point,Thu Jul 2 22:41:56 2015 UTC,Msvc does have a pragma message.
cpp,3btsf5,__Cyber_Dildonics__,-8,Mon Jul 6 14:59:16 2015 UTC,"Amazing approach and demo, but for real life projects, the code becomes a nightmare to maintain, especially in enterprise industry.  Kudos!"
cpp,3btsf5,blackibiza,23,Thu Jul 2 05:31:04 2015 UTC,"I don't think a post from a series called ""stupid template tricks"" aims to talk about code for a professional context."
cpp,3btsf5,BaroTheMadman,0,Thu Jul 2 07:15:03 2015 UTC,in the sense that all the metaprogramming wonder it's super cool but not so productive
cpp,3btsf5,blackibiza,10,Thu Jul 2 15:59:01 2015 UTC,Excuse me? My SQL-at-compile time implementation is so super efficient that Google and Amazon are about to switch their database backends to clang!
cpp,3by79h,thunder9861,4,Fri Jul 3 03:24:17 2015 UTC,"Use this if you're a student or some such, for learning.  Otherwise, use tools like valgrind or MSVC CRT leak detection.  Also, there's no thread safety in there."
cpp,3by79h,Gotebe,2,Fri Jul 3 04:50:47 2015 UTC,By default all threads share the same heap so you will need to synchronize those operations. Take a look at std::atomic to know how to make sure the compiler will generate the appropriate code.
cpp,3bslbj,Plorkyeran,19,Wed Jul 1 20:27:14 2015 UTC,"In my ideal world, the default would be -std=c++14 not -std=gnu++14.  You should have to ask for non-standard GNU language extensions, they should not be enabled by default.  Every time I see someone using a VLA in C++ and claiming it as proof that arrays in C++ don't need compile-time constant sizes I want to cry, and then go back in time to 1994 or whatever and have a stern talk with whoever thought that was a good idea."
cpp,3bslbj,Rhomboid,5,Thu Jul 2 03:10:16 2015 UTC,"You should have to ask for non-standard GNU language extensions, they should not be enabled by default.   That is not how vendor lock-in works."
cpp,3bslbj,josefx,3,Thu Jul 2 08:18:56 2015 UTC,GNU aren't going for vendor lockin though.
cpp,3bslbj,OldWolf2,4,Thu Jul 2 10:17:18 2015 UTC,"They are. It is one part of their many attempts to cause GPL supremacy. (No, seriously... various ""vendor lock-in""s of GCC are regarded as a feature)"
cpp,3bslbj,Dragdu,2,Thu Jul 2 12:24:20 2015 UTC,"I guess that's why Clang calls the GNU lock-in ""heinous GNU extensions"" then."
cpp,3bslbj,MsEtheldreda,1 point,Thu Jul 2 19:08:36 2015 UTC,Is there anywhere that summarizes the differences between these?
cpp,3bslbj,panicnot42,1 point,Thu Jul 2 20:57:16 2015 UTC,"The fine manual.  (You have to read both the C extensions and C++ extensions sections, as most C extensions are valid in C++ too.)"
cpp,3bslbj,Rhomboid,18,Fri Jul 3 05:38:37 2015 UTC,About time
cpp,3bslbj,acwaters,6,Wed Jul 1 20:40:56 2015 UTC,"Cool! I wonder whether that implies binding to the updated ABI? I bet it does.  It's interesting that GCC has had the dialect flag forever (and it had been set to C++98). MSVC, on the other hand, does not support dialect selection, there is no ABI compatibility promise and each compiler revision just supports the ""current"" libs. (lets ignore _BIND_TO_CURRENT_VCLIBS_VERSION)  I find the ""current"" moto more suitable as I always rebuild my little world and/or ship the updated runtime. Can somebody point out cases where you are irrevocably stuck with an ABI?"
cpp,3bslbj,os12,2,Wed Jul 1 21:02:22 2015 UTC,Cool! I wonder whether that implies binding to the updated ABI? I bet it does.   I doubt it does. The ABI choice is independent of the language dialect choice. If they decide to change the default ABI it will therefore be made in a separate discussion.
cpp,3bslbj,the-fritz,1 point,Wed Jul 1 23:48:45 2015 UTC,The language dialect dictates the ABI though.  There are fundamental changes in C++14 that require a different ABI.
cpp,3bslbj,sakarri,2,Wed Jul 1 23:52:01 2015 UTC,"GCC separates it, you don't get the string or list changes by only changing the language mode. You have to pass a separate ABI flag to get those and be fully standards compliant."
cpp,3bslbj,tending,1 point,Thu Jul 2 02:05:40 2015 UTC,"Great, I was missing more compiler dependent flags to keep track of."
cpp,3bslbj,Dragdu,1 point,Thu Jul 2 12:25:48 2015 UTC,"Actually, I believe it's the opposite of what /u/tending describes.  The default behaviour right now is to use standards-compliant implementation: https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html  There is a way to use the old implementation and usage of both implementations can typically co-exist for the most part."
cpp,3bslbj,vlovich,-4,Mon Jul 6 02:20:00 2015 UTC,"Is this a joke? C++14 support is far from bug free in gcc 5.1...  GCC 4.9 compiles range-v3 without problems in C++11 mode, gcc 5.1 fails in C++11 mode, and also fails in C++14 mode due to internal compiler errors. Yes, ICEs in C++11 mode in gcc 5.1. And they want to set the default from C++98 to C++14.  Does this feel like a responsible thing to do for a tool all linux distros depend heavily on?  EDIT Downvoted to death because somehow Boost has something to do with gcc 5.1 not being able to compile libraries like range-v3 (and Hana, and Eggs.Variant) which have no dependencies? In particular since range-v3 compiles fine with gcc 4.9 and clang 3.4, 3.5, 3.6, and 3.7 (and from 3.5-3.7 has C++14 relaxed constexpr support).  To put things in perspective, clang supports all of c++14 since version 3.5 but it is widely usable since version 3.7. That is, it took them one year of bug pruning to make it usable, and they are not even considering making it the default yet.  So I truly ask if this is a joke, because it feels extremely irresponsible for the GCC project to do something like this when gcc's C++14 support has only 1 month of real world usage and doesn't even work yet without crashing the compiler."
cpp,3bslbj,gnzlbg,3,Wed Jul 1 22:33:16 2015 UTC,"Your rant certainly has merit, I have also run into various C++11/C++14 bugs in GCC (and clang as well) over the years.  But my understanding is that the point is to encourage developers  to switch to C++1x, by making it somewhat easier to use (i.e., C++1x code will work ""out of the box""). Most C++98 and C++03 code will keep on compiling with -std=c++14 and will be unaffected by the current C++1x bugs.  Compare it with the situation with MSVC, which defaults to C++11 mode despite having really poor conformance (nevermind the tons of bugs present in the implemented feature set)."
cpp,3bslbj,bluescarni,0,Thu Jul 2 13:48:12 2015 UTC,"But my understanding is that the point is to encourage developers to switch to C++1x, by making it somewhat easier to use (i.e., C++1x code will work ""out of the box"")   They are switching from C++98 to C++14 in a way that breaks valid C++11 code that used to compile with old versions of gcc and they still cannot really compile C++14 code.   They could have pushed C++11 first, and if they want to set C++14 as default they could work hard the next year to slay all ICEs and major bugs in C++11 and C++14 before making C++14 the default."
cpp,3bslbj,gnzlbg,2,Thu Jul 2 14:59:13 2015 UTC,"I can only speculate, but maybe they want to make C++14 the default (instead of C++11) as it is a ""bugfix"" release of the standard."
cpp,3bslbj,bluescarni,4,Thu Jul 2 16:01:19 2015 UTC,"Some of these problems are bugs in the other libraries such as Boost though, not GCC.  I've seen a similar issue with Boost.Variant with 1.58 and -std=c++14 (gcc and clang)."
cpp,3bslbj,RogerLeigh,3,Wed Jul 1 22:39:06 2015 UTC,"Interesting, would you mind directing me to more info on this?  Edit: Is this what you're referring to, by chance?  https://svn.boost.org/trac/boost/ticket/11285"
cpp,3bslbj,AntiProtonBoy,1 point,Thu Jul 2 00:40:13 2015 UTC,"There are/has been lots of other similar bugs when adding C++11/14. I had some problems with Boost.Asio, and the fix involved using -DBOOST_ASIO_DISABLE_STD_ATOMIC when I enable C++11. It may not have been a bug in Boost, but developers of libraries that depend on it can have a hard time tracking these bugs (e.g. long segv backtraces that end up inside the inner parts of Boost you're not familiar with).  The first distributions moving to C++14 (Arch?) will probably have some rough weeks at the beginning, but even if we keep on waiting, the problem will remain the same."
cpp,3bslbj,gaijin_101,1 point,Thu Jul 2 05:47:55 2015 UTC,"Yes, that's it.  I don't see this as much more than an annoyance though--when a compiler implements new features or switches the default some minor breakage in libraries is expected.  I ran into a similar issue with Boost and Qt two days back, but should be fixed with yesterday's release.  When Boost 1.59 comes out, and the same for other library releases, it will all be solved.  For now, I've just had to back down to C++11 to avoid breakage."
cpp,3bslbj,RogerLeigh,3,Thu Jul 2 07:34:04 2015 UTC,some minor breakage in libraries is expected   We are talking about Internal Compiler Errors here. GCC 5.1 is not even able to emit diagnostics.  https://travis-ci.org/gnzlbg/range-v3/jobs/66921303#L3293
cpp,3bslbj,gnzlbg,1 point,Thu Jul 2 10:12:51 2015 UTC,An ICE is never a library error. It is by definition a compiler bug.
cpp,3bslbj,guepier,1 point,Fri Jul 3 11:38:42 2015 UTC,How can this be a bug in other libraries like boost when the libraries I mention have no dependencies?
cpp,3bslbj,gnzlbg,1 point,Thu Jul 2 09:38:13 2015 UTC,"Your original post didn't provide any details of what the failures were.  I've recently run into problems with libraries such as Boost.Variant breaking when compiled with -std=c++14 (both gcc and clang), and made the assumption that you were running into a similar problem.  Getting ICEs is definitely bad.  That said, I've not run into any myself, so I don't know if the specific bugs you've tripped up on mean it's not ready to change the default yet or not.  Personally, I think it's time to flip the switch and get the last issues worked out with wider exposure."
cpp,3bslbj,RogerLeigh,1 point,Thu Jul 2 15:14:17 2015 UTC,GCC has had 1 month of real world usage of C++14 (it was officially completely supported in the last release). I think that switching from C++98 to a not widely tested C++14 mode is an irresponsible thing to do for such a fundamental tool within the linux ecosystem.
cpp,3bslbj,gnzlbg,2,Thu Jul 2 15:22:17 2015 UTC,They aren't releasing it with the default set to C++14 tomorrow. They have another year of bugfixing before 6.1 is released.
cpp,3bslbj,TemplateRex,1 point,Thu Jul 2 15:30:36 2015 UTC,"I have a small (15 kloc) c++14 library that compiles under clang 3.5 through 3.7 tip of trunk, but also ICEs on gcc 5.1. I isolated (and submitted to gcc bugzilla!) half a dozen constexpr related bugs before giving up (there were several variable template related bugs as well). After 2 months, half of those bugs are fixed in gcc tip of trunk. The C++17 proposed Range-v3 and soon to be accepted Boost.Hana libraries fare no better. /u/gnzblg/ is completely on the money with his claim that gcc is not ready for prime time with c++14."
cpp,3brezz,tongari95,41,Wed Jul 1 15:24:26 2015 UTC,"This behavior is indeed nonconformant. (However, I consider the optimization to be worth it anyways.) If you want to disable the optimization (Identical COMDAT Folding), pass /OPT:REF,NOICF to the linker. (You still want to request the removal of unreferenced functions, that's always safe.)"
cpp,3brezz,STL,11,Wed Jul 1 15:35:44 2015 UTC,"Thanks for the info STL! Actually I like the optimization but I hope MSVC can do as what the gold linker does in its safe setting by default, that is, perform the optimization only if the address is not taken."
cpp,3brezz,mizvekov,6,Wed Jul 1 15:43:34 2015 UTC,"In addition to that, if the address is taken, only a trampoline needs to be generated anyway, not a whole copy."
cpp,3brezz,Dascandy,2,Wed Jul 1 18:28:34 2015 UTC,"As far as I know you don't have the guarantee that it's different for conceptually-different but practically-identical functions. Any decent LTO will do the same thing and correctly IMO - you have two identical implementations, there's only overhead in keeping them separate and you may even reveal further mergeable functions."
cpp,3brezz,STL,8,Wed Jul 1 18:29:43 2015 UTC,"The Standard guarantees that pointers to different functions compare unequal, see N4527 5.10 [expr.eq]. f() and g() are different functions regardless of whether they have the same codegen."
cpp,3brezz,Dascandy,-1,Wed Jul 1 18:49:39 2015 UTC,"... Seems to me like something that will prohibit LTO. If f() and g() are functionally indistinguishable, I would say let them compare equal."
cpp,3brezz,o11c,3,Wed Jul 1 19:04:16 2015 UTC,"You don't compare function pointers very often, do you?  The fact that std::function does not operator== support it is a huge reason for me not to use it (even without regarding the lack of copy/share/move/borrow options)."
cpp,3brezz,STL,4,Wed Jul 1 19:50:37 2015 UTC,"Interestingly, Boost.Function's rationale for not supporting op== is outdated; Expression SFINAE allows the existence of op== to be sensed. Such support could probably be added with no cost except codegen size (which is actually a concern for std::function)."
cpp,3brezz,tending,2,Wed Jul 1 20:43:52 2015 UTC,"I use function pointers a lot, but don't find myself comparing them very often. How does that come up for you? Usually I have an array of them where the whole point is it's populated with distinct values and there's no reason to compare."
cpp,3brezz,sakarri,2,Thu Jul 2 02:24:52 2015 UTC,"In my case, I use function pointers as keys in the map to implement a type-based dictionary for type-erased objects."
cpp,3brezz,Dascandy,3,Thu Jul 2 03:21:44 2015 UTC,"Given your description I can see using function pointers as values in a map, but as keys???  That seems unusual."
cpp,3brezz,mr-agdgdgwngo,1 point,Thu Jul 2 04:04:09 2015 UTC,"Well, it's not unusual, in my case:  obj.set<Type, Tag>(...); obj.get<Type, Tag>();   Internally it's an intrinsic map that uses the deleter function as the key, so calling set/get will lookup the key deleter<Type, Tag>.  In some signal system, you can connect a function callback and disconnect it with the same function pointer."
cpp,3brezz,STL,1 point,Thu Jul 2 05:13:11 2015 UTC,"I wouldn't know why I would want to compare them. And in case of equivalent functions, I would not want them to compare nonequal - you could save some processing time by having them compare equal, given equal arguments and a logically-pure function."
cpp,3brezz,mjklaim,2,Wed Jul 1 20:27:38 2015 UTC,Couldn't it just not perform the optimization under circumstances (such as this) one where it causes non-conforming behaviour? The way MSVC currently handles it sucks.
cpp,3brezz,STL,3,Thu Jul 2 04:36:48 2015 UTC,"Yeah, it's a bug, and it could be fixed. I actually forget if this is tracked by an active bug in our database, but the compiler/linker team is certainly aware of it."
cpp,3br7wi,JJKirsch,10,Wed Jul 1 14:28:44 2015 UTC,This bug is caused by a race condition in libc++'s  implementation of std::future. I have already fixed this in the libc++ trunk.    Fixing Commit  Bug report
cpp,3br7wi,Enemii,0,Wed Jul 1 18:55:01 2015 UTC,"auto future = std::async(std::launch::async, []{   return std::error_code(); });  future.get();   Why do this? You have an asynchronous call with a blocking get immediately after it,,, won't the performance of this be the same as inlining the error_code call into the main thread?"
cpp,3br7wi,Volatile474,6,Wed Jul 1 19:34:43 2015 UTC,"I think the sample code is intended to reproduce the bug, I wouldn't read too much into it."
cpp,3bpbbk,thunder9861,3,Wed Jul 1 01:47:25 2015 UTC,"Great post! :) Btw, I wrote a library with an improved version of the serializer that inspired that post available at https://github.com/catedrasaes-umu/jsonip . It also includes the deserializer."
cpp,3bpbbk,asenac,1 point,Wed Jul 1 17:29:43 2015 UTC,"Indeed, your original blog post was very useful and provided most of the functionality I was looking for. Thanks again! I'll check out the deserializer, I was going to try and tackle that next!"
cpp,3bozpm,spongo2,2,Tue Jun 30 23:47:25 2015 UTC,There was another stackless coroutine proposal - N4453 Resumable expressions. Can anyone summarize what is the difference between the two proposals ?
cpp,3bozpm,whichton,3,Wed Jul 1 17:30:30 2015 UTC,"There is an awesome part of N4453, namely that you can have a generic function that can either output into an output iterator or to transform itself into a generator.  The paper also shows how it can be used to emulate resumable functions, though, the mechanisms shown may not be as efficient as what resumable functions give you.  Resumable functions consists of customizable syntactic sugar for await, yield patterns with library hookup providing semantics and (hidden) coroutine machinery that allows functions to be suspended and resumed. Additionally, customizable syntactic sugar can be used to apply to other monads, such as optional / expected. Moreover, unlike N4453, ""resumable-ness"" is a property of the implementation. It does not change the ABI. From the outside it is just a normal function."
cpp,3bozpm,GorNishanov,1 point,Thu Jul 2 03:15:53 2015 UTC,"There was a proposal that await can be used for unwrapping any monad, like optional / expected. Is that still on the cards? Not able to watch the video atm, so not sure if it is covered in the video."
cpp,3bozpm,whichton,1 point,Wed Jul 1 07:15:14 2015 UTC,"Expected directly mentioned in video, so likely optional supported too"
cpp,3bozpm,KindDragon,6,Wed Jul 1 07:56:32 2015 UTC,"Expected, Optional, etc, will be supported, but, it requires a few tweaks to the design to make it efficient and safe.  There will be a small proposal in the fall that extends coroutines to handle expected/optional/and others and matching implementation in VS update 1.  Essentially the extension will allow to explain to the compiler that coroutine return type (such as optional) cannot represent the idea that value is not here yet and thus awaiting on a future will be a compile time error. Also, knowing that a coroutine can never be suspended, allows the compiler to generate better code."
cpp,3bozpm,GorNishanov,1 point,Wed Jul 1 17:27:01 2015 UTC,"Thanks. I really prefer the Maybe monad to both exceptions and error codes. Await will make writing binds so much easier.  A couple of questions:   How does your proposal differ from N4244? I understand you can make lambda's resumable. So if I copy a suspended lambda, does the execution context gets copied? Or are resumable lambda's non-copyable?"
cpp,3bozpm,whichton,2,Wed Jul 1 17:53:54 2015 UTC,"As I mentioned in another reply that resumable functions are customizable syntactic sugar over coroutine machinery that can be thought of as a lambda*, essentially a lambda which closure object contains not just a captured variables, but also, all the objects with automatic storage duration of operator () of the closure object.  You can think of N4244 as an attempt to specify what the lambda* is on top of which resumable functions could be built.   In N4499, suspended resumable lambda can be copied but most likely it will result in undefined behavior when you resume it. You can copy the lambda object as many time as you'd like before you call operator().  Consider this lambda:  string s = ""hello""; auto f = [s] { for(auto ch: s) yield ch; };   Once you start executing f, hidden iterator that range-based for is using to iterate over s, will be pointing at a string embedded in the closure store in f. (I assume that ""Hello"" is small enough to trigger small string optimization), when you move the lambda, all of the captured objects will be moved, but, compiler won't figure out that because iterator used to point inside of string s in the object f needs to be repointed into a copy of the lambda."
cpp,3bozpm,GorNishanov,1 point,Thu Jul 2 03:27:53 2015 UTC,Tnx for the nice interview. Your code examples seem very convincing until I read N4453 that uses the proposed keyword resumable similar to how constexpr is tagged on an expression or function. Can you say something about the merits of that proposal?
cpp,3bozpm,TemplateRex,2,Wed Jul 1 19:53:07 2015 UTC,See https://www.reddit.com/r/cpp/comments/3bozpm/goingnative_39_await_coroutines_with_gorn/csphdbg
cpp,3bozpm,GorNishanov,1 point,Thu Jul 2 03:29:49 2015 UTC,"This was a very interesting video, but would appreciate a lower-level view of what's going on eg. stack growth, saving the execution context vs function call perf. However this is a compelling tool I would welcome in C++17, I would like to experiment in GCC / Clang first."
cpp,3bozpm,fixxxeruk,2,Wed Jul 1 10:17:39 2015 UTC,"Glad you liked it!  (I'm the guy in the green shirt in the beginning and the interviewer)   I'm actually working to make sure the content of these videos skews a little bit more towards relevant for non-MS platform viewers, so I'm glad that is working :)   Also, Gor is in regular contact with other compiler devs implementing this feature.   This C++17 feature is particularly useful in a bunch of MS-internal scenarios so that's one reason we are pushing to get this one out first."
cpp,3bozpm,tongari95,1 point,Wed Jul 1 17:06:22 2015 UTC,"FWIW, here's a macro-based emulation for c++14 that you can play with GCC / Clang."
cpp,3bnhpe,cpp_cache,14,Tue Jun 30 17:11:14 2015 UTC,It's part of Concepts TS.  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4377.pdf http://en.cppreference.com/w/cpp/language/constraints#Abbreviated_templates
cpp,3bnhpe,VadimVP,7,Tue Jun 30 17:17:49 2015 UTC,Someone mentioned concepts in C++17.  You can already do this with lambdas in C++14 if you were actually thinking of that:  auto x = [](auto any_parameter) { };   You can get the equivalent via:  static auto my_func = [](auto any_parameter) { }   Slightly odd syntax but it's basically the same as the my_func you are describing & usable in all the same spots.  Some TMP may notice that it's actually a struct instead of function but zero-capture lambdas are special since they can be used where a plain C function pointer is expected.
cpp,3bnhpe,vlovich,1 point,Wed Jul 1 02:06:04 2015 UTC,What's the difference between the static and non-static versions? Does that mean that the lambda won't reallocate memory each time its parent function is called? Same as static int var...
cpp,3bnhpe,Gangstuh_Nugget,2,Wed Jul 1 10:35:56 2015 UTC,There is no memory allocated for a lambda with nothing captured.  It is equivalent to a function.  static here is the same as it always is - it just modifies the linkage rules.  Using static means that every compilation unit has a copy of the function whereas not having static means that all copies of the lambda should get merged.  Keep in mind that adding static usually lets the compiler be more confident about inlining which may or may not be a good thing.
cpp,3bnhpe,vlovich,3,Wed Jul 1 21:23:00 2015 UTC,"What I'd really like to do is to be able to handle types individually, like in-scope type awareness for variables sent through templates or this thing.  But I know that isn't possible. :("
cpp,3bnhpe,I_AM_INTERFACED,2,Wed Jul 1 01:36:45 2015 UTC,Care to elaborate?
cpp,3bnhpe,boredcircuits,3,Wed Jul 1 03:52:42 2015 UTC,"For example, lets say you have  pass_vm_function_parameters(auto p1)  Then with p1 you do an if/else case with typeof and adjust functionality according to the variable that is passed through it.  More useful in this example would be variadic parameters with the same functionality.  call_vm_func(func_handle, ...)  Then later: if(typeof(vararg[1]) == typeof(int))  So, something like JS where there is type awareness for each variable passed to it.  I never realized I needed/wanted it until I got into lower level programming where, for example, creating assembly stubs which call functions (I used VM for this example but it works for actual assembly as well) with specified parameters.  I was told, though, that C/++ has very little meta-awareness of these variable types at compile time, so it wouldn't really work and would probably be quite complex to implement"
cpp,3bnhpe,I_AM_INTERFACED,5,Wed Jul 1 04:17:44 2015 UTC,You mean like... pull the if content to separate function and use template specialization?
cpp,3bnhpe,ukalnins,4,Wed Jul 1 09:24:09 2015 UTC,Sounds like he wants template specialization or overloading/tag dispatch...
cpp,3bnhpe,suridaj,2,Wed Jul 1 12:58:37 2015 UTC,"I was told, though, that C/++ has very little meta-awareness of these variable types at compile time   This is absolutely 100% backwards – C++ is strongly, statically-typed, and all value types are always known at compile-time.  Also, you're really just describing overloading (or specialization, depending on the approach); no new language construct (e.g. static_if) is needed to accomplish this, and this isn't even new to C++11 or C++14."
cpp,3bnhpe,dodheim,1 point,Thu Jul 2 00:00:19 2015 UTC,"I get what you're saying.  I could almost see an extension to static if like the following:  template<class T> void foo(const T& t) {     ...     template<T> static if<int> {         ...     } else if<double> {         ...     }     ... }   Where I would generally use this is with class templates, actually:  template<class T> class Foo {     void bar();      template<T> static if<int> {         void baz();     } };   Now, you can do all this with existing C++ functionality.  In the first example, you would extract that code into a set of overloaded functions.  The second example would be a template specialization, extracting out common code into a base class that's inherited from in the main template and in the specialization.  Essentially:  template<class T> class FooBase {     void bar(); };  template<class T> class Foo : public FooBase<T> { };  template<> class Foo<int> : public FooBase<int> {     void baz(); }   Luckily we have inheriting constructors, which make this a bit easier to swallow.  But a type-aware static if would be nice."
cpp,3bnhpe,boredcircuits,3,Wed Jul 1 16:18:17 2015 UTC,I would love to be able to do that
cpp,3bnhpe,riceshrug,2,Tue Jun 30 23:53:58 2015 UTC,Duck typing in cpp? IS NOTHING SACRED?
cpp,3bnhpe,TagSmile,19,Wed Jul 1 00:00:21 2015 UTC,Hasn't C++ been duck typed since the introduction of templates?
cpp,3bnhpe,JackAtlas,11,Wed Jul 1 00:08:46 2015 UTC,"Actually, auto as a parameter type is just fancy syntax for the templates we all know and love."
cpp,3bn0sm,tongari95,7,Tue Jun 30 15:11:23 2015 UTC,"I agree it's very neat code, but personally I'd never use something so complicated just to save a line of code. You can do almost exactly the same thing with tuples:  auto f(int x, int y) {   return std::make_tuple(x, y); }  int x, y; std::tie(x, y) = f(3, 4);"
cpp,3bn0sm,quicknir,3,Tue Jun 30 19:29:23 2015 UTC,"If you put them in a header and include it when you use it, it's as simple as how you use std::tuple, not complicated at all, isn't it? ;-)  The implementation of tuple is much more complex than this under the hood, it's just that you don't even care how it is implemented because your compiler vendor already implemented it for you. Anyway, the complexity in implementation doesn't mean the complexity in usage."
cpp,3bn0sm,quicknir,5,Wed Jul 1 02:03:10 2015 UTC,"Unfortunately, with a macro there isn't really a good barrier between interface and implementation, because macros do not follow the rules of the rest of C++ which we commonly use.  For instance, your code breaks if there are multiple exit points, even if they are precisely identical. So:  auto f(int x, int y) {     if (true)      return LOCAL(x, y);     else      return LOCAL(x, y); }   breaks. This is pretty unintuitive. Similarly, LOCAL(0, 0) will break. LOCAL(x, g(x)) will break. This construct basically doesn't obey any of the rules of regular C++.  Here's something even worse that it does: renaming local variables inside your function has now become a breaking change, because you've sucked in the names of those variables as the fields of the struct. Not only does the LOCAL macro not have a clean separation between interface and implementation, but it actually actively destroys that separation in client code."
cpp,3bn0sm,quicknir,1 point,Wed Jul 1 02:51:19 2015 UTC,"The problem you shown in the code is not inherent to macro, even if C++ would have built-in inline-struct support, I'd expect your example to break since you're trying to return 2 different types which is invalid for return-type-deduction anyway. LOCAL(0, 0) or LOCAL(x, g(x)) is invalid by design, as its name (i.e. LOCAL) implies, you have to provide some local variables instead of expressions like 0 or g(x).  As for the renaming problem, similar problem applies to std::tuple as well - if you change the order of args you return (e.g. std::make_tuple(a, b) -> std::make_tuple(b, a)), you also break the current code (even worse, silent bug if the type of a & b are compatible, in which case you won't observe it as an compile error).  Neither of them is better than the other in all cases, all depends on your need :)"
cpp,3bn0sm,quicknir,5,Wed Jul 1 03:40:21 2015 UTC,"""even if C++ would have built-in inline-struct support"": What do you mean by inline struct support? Is this not it?  auto f(int x, int y) {     struct local { int x; int y; };      if (true)         return local{x, y};     else         return local{x, y}; }   That's the thing: functions in C++ depend only on their inputs *. So the fact that LOCAL(x, y) returns (seemingly) two different types is extremely unintuitive.  Again: they are not similar problems. C++ programmers are very used to the order of arguments to a function mattering. They are very not used to the names of their variables mattering.  Obviously you're entitled to your opinion, but I'm obligated to say something that sounds a bit harsh: using std::tie or an explicit created struct is better in all cases than the code you posted, in any practical situation involving production code and a team of developers. The gain is either small or zero, and the cost in complexity, violation of the principle of least surprise, and macro usage (always a negative) is very large.  (*and occasionally on global variables, which we all know are bad)(and occasionally on static locals, which can be good but probably shouldn't be used to track state in that fashion)"
cpp,3bn0sm,quicknir,2,Wed Jul 1 04:03:32 2015 UTC,"That's just plain-old local struct not the imaginary inline struct I'm talking about, but I see that the name LOCAL may be the cause of your confusion. The intent of LOCAL is to provide an feature of inline struct which is not available in C++, so the imaginary code should expand to:  auto f(int x, int y) {     if (true)         return struct { int x; int y; } {x, y};     else         return struct { int x; int y; } {x, y}; }   It's saying that you're making 2 different types, and that's what a c++ programmer would expect as writing []{} twice would give you different lambda types.  Let me give the real case which I prefer LOCAL to std::tuple: I have a GUI library that is used like:  w->on<paint_event>([](paint_event& evt, widget& self) {     auto& canvas = evt.canvas;     auto& res = self.init_once([&]     {         auto background = canvas.make_bitmap(canvas.size(), [](canvas_ref canvas)         {             // draw background here         });         auto gradient = canvas.make(radial_gradient_brush(...));         auto path = canvas.make(some_complex_geometry);         return LOCAL(background, gradient, path);     });     canvas.blit({}, res.background);     canvas.fill(res.path, res.gradient); }   Where self.init_once will imbue some data into the widget and the data is initialized once by the enclosed lambda, in this case, it's the drawing resources. The major benefit of LOCAL is that it provides mnemonic names instead of numeric indices. If I return std::make_tuple(background, gradient, path), I have to call std::get<0>(res), std::get<1>(res) and so on, which are more obscure in their meaning. You may argue that one could use enum for that, for example enum{background_tag, gradient_tag, ...}; and then use std::get<background_tag>(res), std::get<gradient_tag>(res), etc. But to be honest, do you really think you prefer writing code like that to simply using LOCAL here?"
cpp,3bn0sm,dodheim,1 point,Wed Jul 1 05:51:38 2015 UTC,"I understand how the code works, and why it generates two different types. Your argument is now basically that this macro does not simulate a function, but rather a language feature that doesn't exist, and people should adjust their expectations accordingly.   Inventing a new language feature using macros is, on its own, a very bad thing to do. It can be justified in some cases because the invented feature is so useful and lacking in the language, which is not the case here.  To answer your question I would rather use a struct, a tuple, a tuple with enums, or std::tie (which you ignored in your answer), anything, over LOCAL. It's way too much complexity to introduce to a codebase, and too much non intuitive behavior for too little gain.  Note that LOCAL basically acts as compile time reflection. Compile time reflection doesn't exist in C++ yet. When it does, and it becomes a standard technique that good developers are aware of, I will of course use it. I'm not going to use an attempt to hack it together use macros.  Anyhow, I'm sure this isn't what you wanted to hear, as you wrote some very clever code. Clever code isn't always good code though, in fact it's often not. Out of the developers I know with years of top notch c++ experience, I'm fairly confident that every single one of them would not allow code like this to be merged into a production codebase."
cpp,3bn0sm,StoneCypher,3,Wed Jul 1 14:21:29 2015 UTC,"OK, so we have disagreement in philosophy, arguing on that further won't be constructive, so I'll just explain why I ignored std::tie in my example - you may already noticed, that I used auto all around, and that's the point. To use std::tie, you have to specify the types of those resources explicitly beforehand, and that's what I want to avoid in the first place. If I were going to spell the types, I would rather use plain-old local struct and return it directly.  BTW, do you use Boost or not? I hope you won't curse it to death ;-)"
cpp,3bn0sm,quicknir,2,Wed Jul 1 15:07:29 2015 UTC,"I use boost extensively. Boost filesystem, program options, date time are some of my favorites. I've used boost PP before. It was used to support certain parts of code that had to iterate over a list of supported types, in ways that couldn't be done reasonably with templates. The code is very hard to read and maintain, after you haven't touched it for a few months your eyes just glaze over when reading it. My boss said if it had been up to him he probably would have just written things out by hand (this code predates my boss or I being on the team). All this does not even take into account the fact that as new team members join, the learning code for that code will be terrible.  This was his opinion, even when we were using it to avoid code repetition that was basically impossible to avoid any other way. In other words, that was the only way to do it, and the costs of using macros in general, and really complicated boost preprocessor macros in particular, still were comparable to the fairly significant benefit.  Implementation complexity only doesn't matter if someone else is going to support it, and support it well. So I don't mind using boost program options, or boost lexical cast, despite these things having very complex implementations, because externally they present clear interfaces, and the interface and implementation are well separated using proper functions. None of those considerations apply here.  In many cases I've observed that more experienced c++ developers make a greater effort to avoid complexity, and potentially dangerous things like macros. I think that it's not about whether or not you can use something correctly, it's about how much time you will waste one day when some edge case you didn't consider crops up. Or about how much time you will spend helping a new team member learning to avoid all these edge cases."
cpp,3bn0sm,minno,1 point,Wed Jul 1 15:59:15 2015 UTC,"I think it would be more along the lines of  struct{int x, y;} f(int x, int y) {     if (true)         return {x, y};     else         return {x, y}; }   which seems very sensible to me, actually."
cpp,3bn0sm,quicknir,2,Wed Jul 1 23:37:00 2015 UTC,"did you just point out, to the guy that said ""as an alternative to tuples"", that you could use tuples instead"
cpp,3bn0sm,TagSmile,4,Tue Jun 30 22:00:08 2015 UTC,"I did. I think it's useful to point out/emphasize just how small the difference in code size/convenience is, especially for people who aren't familiar with std::tie. I don't see anything wrong with my comment."
cpp,3bn0sm,dodheim,2,Tue Jun 30 22:10:46 2015 UTC,"The difference is that his version is name-linked. If you wrote std::tie(y, x) you'd get x and y swapped from what you might expect."
cpp,3bn0sm,Monfico,3,Tue Jun 30 22:36:08 2015 UTC,"Yes, I am aware, the OP did a good job making that clear through his code and comments.   I suppose that depends on your expectations, doesn't it? In c++, tie is constructing a tuple, tuple values are ordered strictly based on index, i.e. their order. So, personally, I would argue that TIE(y, x) just doing the ""right"" thing is what violates expectations. I'm not generally a fan of ""do what I mean"" programming, but naturally that's just my opinion.   Just want to emphasize that my post is not intended to discourage the OP, who clearly has some good c++ chops, or to be a jerk. Just giving another perspective."
cpp,3bn0sm,cabbageturnip,2,Tue Jun 30 22:55:25 2015 UTC,"You do have a point in the expectation on TIE, I had also considered that but I couldn't think of a better name. Frankly, I don't have a need for TIE thus far, I only use LOCAL in practice, TIE is a byproduct when I wrote this, out of interest :)"
cpp,3br166,mathophilic,22,Wed Jul 1 13:28:13 2015 UTC,"here's (...) why Java is better than C++: One can readily build complicated and sophisticated programs in Java, thanks to the numerous libraries it has. (...) C++, on the other hand, allows coders access to the deepest labyrinth of the system, but requires coders to reinvent the wheel every time.   Oh how I wish C++ had support for libraries! Greatest missing feature from the language. /sarcasm"
cpp,3br166,no1msd,9,Wed Jul 1 13:49:09 2015 UTC,"I agree - the author of the original article is not sufficiently knowledgeable on the topic. IMHO, the more important point is that a vast majority of these students learning C++ will graduate with a ""C with classes"" understanding of the language and limited exposure to many of the modern developments."
cpp,3br166,MrBushido2318,2,Wed Jul 1 14:02:02 2015 UTC,"It's not ideal, but I think it's a decent compromise depending on the course. If it's compsci where hardware architecture is often a significant part of the course then learning C++ as if it were C can give a better understanding of the fundamentals of a computer which can be more valuable than learning the standard library."
cpp,3br166,dodheim,3,Wed Jul 1 18:45:53 2015 UTC,which can be more valuable than learning the standard library   Not if they ever want to actually write anything in C++.
cpp,3br166,robthablob,5,Thu Jul 2 00:52:19 2015 UTC,"It may have support for libraries, but the standard libraries have gaping holes that would raise derision in most other languages - like those in Java and .NET.  Unicode support - awful, file system support - nearly there (in 2015), networking - in your dreams.  I know much of this is present in 3rd party libraries, but that means moving between teams often involves learning a new bunch of stuff."
cpp,3br166,rybxjfpq,3,Wed Jul 1 14:04:29 2015 UTC,Unicode support I'll give you as there isn't a one size fits all solution even in Boost. Just try dealing with a cross platform console app which needs to input and output any one specific form of UTF and you'll understand. Networking is pretty nicely dealt with by Boost Asio which is being considered for addition to the standard.
cpp,3br166,peolorat,3,Wed Jul 1 20:23:03 2015 UTC,File system support is hard because extremely platform dependent and you can't make a portable API that is satisfactory over different platforms.  Windows paths can take the following formats:  \\server\share\file.ext  \\?\server\share\file.ext  C:\directory\file.ext  file://C:\directory\file.ext  Unix paths all look like this:  /dir/dir/dir/file  Go ahead and design a portable API that can work with both. You'll end up with something that will disappoint.
cpp,3br166,robthablob,1 point,Sat Jul 4 22:57:22 2015 UTC,"The file system library is actually fairly long along the way to being part of the standard, as an optional feature (available if the file system is hierarchical)."
cpp,3br166,doom_Oo7,2,Sun Jul 5 17:52:43 2015 UTC,"Unicode support - awful, file system support - nearly there (in 2015), networking - in your dreams.   If you need all of this just use Qt; it's the closer you'll get from the java standard library ported to C++ (everything inherits from QObject! whoo!)."
cpp,3br166,robthablob,7,Wed Jul 1 16:16:15 2015 UTC,"The difference is:   It's not really idiomatic C++. It's not standard.   The prior is the largest issue for me. I don't want Java libraries in C++, I want better C++ libraries."
cpp,3br166,doom_Oo7,1 point,Wed Jul 1 16:51:04 2015 UTC,"It's not really idiomatic C++.    Idiomatic C++ changes every two years, good luck making a library today that will be ""idiomatic"" by the end of the decade.  And the java model is, imho, better adapted to the building of applications, whereas the C++ model shines for library building. In the end you'll need a tree of objects."
cpp,3br166,AntiProtonBoy,2,Wed Jul 1 16:59:33 2015 UTC,"I believe the author was implying that Java offers a much richer selection of features in their libraries compared to C++ STL. Therefore, writing applications in Java is easier as a result, whereas writing a similar app in C++ will involve spending a bit more time rolling your own libraries on the side."
cpp,3br166,whichton,11,Wed Jul 1 14:50:42 2015 UTC,I believe the author has no fucking clue regarding what she is talking about.
cpp,3br166,Moschops_UK,7,Wed Jul 1 16:30:54 2015 UTC,"In my experience, what's holding back programming education in India isn't the choice of language so much as the choice of dialect (i.e. twenty-five years old) and the tools.  A brief search will find numerous webpages in which people explain to each other how to get Turbo-C V3 working on Windows 7 (or later). These students are being taught using a tool that's almost 25 years old, aimed at 16 bit DOS. They are being taught using truly atrocious textbooks that, likewise, are decades out of date.  Anyone remember conio.h ?  That's right, the additional header provided by Borland (aimed at 16 bit DOS) twenty-something years ago that was superseded back in the nineties. It's what these students are routinely taught to use. It's painful to have to explain to someone who comes looking for help with their code that they're being taught how to program in the year 1990 and if they don't have a time machine to actually get a job in 1990, they're in for a big shock when they hit the job market. People keep rewriting conio.h and the associated libraries so that people can keep learning how to use it in a bizarre self-perpetuating cycle; suffice to say that when I'm interviewing fresh graduates, seeing conio.h in their code is a big red flag.  It's the schools and the teachers. They picked particular versions of  Turbo-C and Turbo-C++ and a bad textbook literally twenty years ago, and they haven't changed since. Students turn up with modern machines (if Linux, even already coming with a modern, effective C++ compiler) and then find a way to install DOSBox so they can run a massively outdated IDE, because their schools and teachers are incompetent."
cpp,3br166,quicknir,4,Thu Jul 2 11:07:25 2015 UTC,"I think a key point neglected in the article (that may upset some non-c++ people) is that going from c++ to most other mainstream languages is much easier than doing the reverse. In particular Java and python, while they have their quirks and difficult parts, someone from c++ can jump into these languages and grok things quite quickly. Jumping the other way is much harder.  There's a good Joel on software about why it's important to learn a) a language with raw pointers everywhere, i.e. C/C++, and b) a functional language. http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html. I think in freshman year especially, universities should focus on producing good programmers, not good {Java,RubyOnRails,Python} programmers."
cpp,3br166,newmewuser4,1 point,Wed Jul 1 19:36:44 2015 UTC,"Thanks for the link - havent read this article yet and looking forward to it.   While I agree that going from C++ to other languages is easier, IMHO this is a bit like saying climbing your local mountains is easier once you've done Mt. Everest. To a large extent, context is everything. Coming from India myself, I agree that modern C++ is an excellent language for Computer Science students as a starting programming course. However, most engineering students in all other disciplines also take a programming course to introduce them to a ""Computational way of thinking"". In this context, the intricacies of handling raw pointers, passing pointers vs references vs value to functions etc is not only overkill, but gives the impression of programming being a very hard exercise."
cpp,3br166,jcoffin,1 point,Wed Jul 1 21:12:38 2015 UTC,impression of programming being a very hard exercise     And that is a good thing. The sooner those kids realize Computer Science is or is not for them the better. If they don't have neither the will or the gift for coding better for them to look at something else and stop wasting time and money only to quit later.
cpp,3br166,dodheim,2,Thu Jul 2 22:27:15 2015 UTC,"Every time I see an article like this, I'm tempted to write a parody (only one that's really pretty serious) about how the widespread teaching and use of Java is causing American students and companies to fall behind.  The difference would be that (of course) I'd actually demonstrate some expertise in the languages in question, and show actual examples of how trivial it is to get C++ to do what you want, and how much larger, uglier, and clumsier your code ends up if you insist in using Java to do the same.  Ultimately, I think this author makes the same mistake as many others: he mistakes the idea that Java is easier to learn than C++ (which is probably at least partly true) for the idea that Java is easier to use than C++ (which I've become convinced is only true for people who don't actually know C++).  I'll agree that C++ does take a great deal of time (and sometimes effort) to learn--but once you do know it, using it to accomplish myriad tasks is downright trivial compared to Java (or compared to many other would-be competitors like Go).  I've quite literally, however, produced production quality code in C++ for a particular task in less time than a team of 5 spent attempting to design what a prototype in Java would look like (i.e., they hadn't written any actual code yet--just drawn diagrams and such). Admittedly, part of this was simply the advantage of a single programmer over a group--but part of it was that Java didn't provide anything particularly well suited to the task at hand in its library, and the minute you run into that, you start to realize that the Java language itself is much more limited, requiring a great deal more code to be written for many tasks.  It doesn't help that Java's standard libraries, for all their size, are actually pretty poorly designed. Instead of a real system that all fits together, it's basically a giant collection of special cases, almost none of which follows any really general rules, and the few rules that are really general require an extremely warped mind-set to make sense at all (e.g., what's the commonality between a rainbow and a unicorn? They both have hash codes.)"
cpp,3br166,quicknir,1 point,Wed Jul 1 22:19:40 2015 UTC,"but part of it was that Java didn't provide anything particularly well suited to the task at hand in its library, and the minute you run into that, you start to realize that the Java language itself is much more limited, requiring a great deal more code to be written for many tasks.   I'd gild you for this, but alas, I'm broke."
cpp,3br166,dodheim,1 point,Thu Jul 2 01:07:13 2015 UTC,"I greatly prefer C++, but I'm not sure I generally agree with what you're saying. Java just has many more libraries than C++, even if they're not amazingly designed they still let you accomplish something very quickly in practice.  Java also has some significant advantages stemming from reflection. In general I think designing around reflection is usually not a great idea, but it's hard to deny it's usefulness when you want to e.g. serialize a class.  I'm sure we could find dozens of tasks that would be easier in either language, to sum up."
cpp,3blzm6,VitiyPP,2,Tue Jun 30 08:21:34 2015 UTC,"site appears down, cache: http://webcache.googleusercontent.com/search?q=cache:UKdv0VLkEWgJ:vitiy.info/immutable-data-and-serialisation-in-cpp11/+&cd=1&hl=en&ct=clnk&gl=us"
cpp,3blzm6,FearlessFred,1 point,Sun Jul 5 16:15:54 2015 UTC,It's some 'planned' temporary hosting troubles. Should be up soon enough.
cpp,3blzm6,Ksecutor,2,Sun Jul 5 16:28:10 2015 UTC,Have you considered code generation instead of ugly macro magic? :)  Several years ago I created code generation tool to port xml based administrative protocol between c++ and java applications to something better and easier to support and extend. The tool parses definitions of protocols(s) and messages (and a few more things) and populates text templates with results of parsing. Best thing about this approach is versatility. You can generate code compatible with code style of your project and use containers that are used in the project. Resulting code is easy to read and debug. It's not necessarily  must be used for generation of protocols. You can generate arbitrary data structures with handy serialization/deserialization with it. One thing that is missing - comprehensive documentation :)
cpp,3blzm6,Ksecutor,1 point,Tue Jun 30 09:35:23 2015 UTC,"This is completely other way which has it's advantages and disadvantages. Like you have to stick to such code generation tools, regenerate all declarations all the time, deal with 'expanded' generated versions when you explore your classes, etc. And whole approach is close to writing your own custom preprocessor, which is not so different from black magic. But still this is the possible optional way.  I more like the way to convert all this into templates somehow, but this needs some template's syntax extensions in future standards."
cpp,3blzm6,reuscam,1 point,Tue Jun 30 10:38:04 2015 UTC,"Using macroses is not really different. You invent some intermediate language to declare your data. You have to stick with these definitions and rules. I only run code generation after changes to definitions or templates (as a separate make target). Which happens not too often. Then I commit newly (re)generated code to repository and don't touch it till next change in definitions or templates. But it's not too difficult to dynamically generate dependencies and corresponding rules to run generation automatically during build process. You have folding in editors to deal with 'expanded' code, but you can't really unfold macro, right? :) But if you change the template, you don't need to revisit whole lot of structures and make some minor change to them. You regenerate code and that's all. Also, you can use different templates for production code and tests. Test code might benefit from additional validation and some extended meta information. My colleagues (especially java guys) were sceptical about this tool. But now they even implemented special ant task for it! I created XText based plugin for Eclipse, so definitions can be edited with all the comfort - code completion and validation."
cpp,3blzm6,reuscam,1 point,Wed Jul 1 07:32:58 2015 UTC,"FYI, your website is blocked by my corporate McAfee for malicious downloads."
cpp,3blzm6,mcmcc,1 point,Tue Jun 30 13:07:34 2015 UTC,There should not be any executable downloads. McAfee gives some more specific information (some links)?
cpp,3blzm6,txzzzuu11,1 point,Tue Jun 30 13:31:24 2015 UTC,"Nope.  No info other than your url and IP, and the reason for blocking."
cpp,3blzm6,FearlessFred,1 point,Tue Jun 30 13:36:29 2015 UTC,"That is unexpected. I tried several online checking tools and they don't show anything suspicious. I'll try to explore this, thanks for information. (ps. that's the reason to hate wordpress)"
cpp,3blzm6,pfultz2,1 point,Tue Jun 30 13:51:13 2015 UTC,"It's probably some historical collateral damage related to your IP address.    I used to have similar problems with http://bartoszmilewski.com who, if you've never met Bartosz, is about as far away from ""malicious downloads"" as you can get.  I'm not sure what he had to do to get it cleaned up..."
cpp,3blzm6,pfultz2,1 point,Tue Jun 30 14:54:57 2015 UTC,My previous post in blog was related to Bartosz. :)
cpp,3blzm6,pfultz2,1 point,Tue Jun 30 16:17:51 2015 UTC,Nicely done. I did something similar a few years ago.   Actually my final conclusion was that the only way to do serialization in C++ is using something like Protocol Buffer. So you have a generic format where you can write your struct and then you generate code from this. The reason for this is that It turns really ugly when you start using attributes you cann't expect others to take care of C++ naming limitations.  I really hoped for the reflection proposal for C++17 but this doesnt really fix the error with naming.
cpp,3blzm6,sakarri,1 point,Tue Jun 30 14:59:09 2015 UTC,"Thanks. Yes, that's one of the ways. And reflection proposal would be nice anyway."
cpp,3brbu9,keshav96,2,Wed Jul 1 15:00:26 2015 UTC,"Please don't link to sites that require a login to see the content. It's not worth the effort and inevitable ""newsletter"" spam to read an article that is so vaguely titled here that I can barely imagine the content."
cpp,3bkhjb,TiagoRabello,2,Mon Jun 29 23:28:24 2015 UTC,Really looking forward to this release! Microsoft seem to have (almost) caught up with Clang and GCC which is awesome.
cpp,3bkhjb,kozukumi,2,Tue Jun 30 00:25:13 2015 UTC,"VS2015 is at about clang 3.3 levels for C++ 11/14, see https://svn.boost.org/trac/boost/wiki/BestPracticeHandbook#a3.PORTABILITY:StronglyconsidertryingyourlibraryonMicrosoftVisualStudio2015. In a good chunk it matches clang 3.5's C++ 14 support. Brilliant!"
cpp,3bkhjb,14ned,9,Tue Jun 30 09:02:13 2015 UTC,"MSVC is an IDE, GCC is a compiler... I would expect there to be a difference. Also you can get cl.exe for free and it is a few MB so Im not sure what your point is?   edit: it is available for 'free' but no, it is not available separately from vs201x express which does defeat the purpose also archival edit for grammar"
cpp,3bkhjb,newuser1892435h,3,Tue Jun 30 11:20:21 2015 UTC,How can i get the latest cl.exe without downloading whole Visual Studio?
cpp,3bkhjb,Ivan171,1 point,Tue Jun 30 11:36:48 2015 UTC,"Yeah sorry about that I always thought it was available separately with link.exe, you can of course get it as a CTP but that is less than ideal. Now it is entirely possible that the compiler/linker arch is available as a redist and/or available as a .dll in system32 but that is also not what I was thinking of... :/"
cpp,3bkhjb,newuser1892435h,1 point,Tue Jun 30 12:26:17 2015 UTC,"It used to always be available with the Windows SDK, but they recently stopped doing that since SDK 8.0, IIRC. Quite unfortunate. I like and use VS, but it was very useful having it available separately, especially for setting up build servers which should never need a full VS install."
cpp,3bkhjb,oracleoftroy,2,Tue Jun 30 12:32:19 2015 UTC,"Yeah I can understand that. A MinGW install is like 100MB. I remember circa 2003 Microsoft had the Visual C++ 2003 Toolkit which was what you are asking for. Just the compilers, headers and some related tools. Shame they don't offer something like that anymore.   At least Visual Studio Community is free for the majority of people now though. Much better than the horrible Express version."
cpp,3bkhjb,kozukumi,-1,Tue Jun 30 13:13:21 2015 UTC,Its not current but there is the Microsoft Visual C++ Compiler for Python 2.7 which is the command line compiler from Visual Studio 2008. 84 MB. http://www.microsoft.com/en-au/download/details.aspx?id=44266
cpp,3bkhjb,nyamatongwe,4,Thu Jul 2 02:17:40 2015 UTC,It is 2015 – do not use this!
cpp,3bkhjb,dodheim,2,Tue Jun 30 11:38:33 2015 UTC,I know it supports more of C++11/14 which is good..  Any performance improvements to the generated code?  Better SSE/AVX intrinsics codegen or vectorization?
cpp,3bkhjb,frog_pow,4,Wed Jul 1 03:14:56 2015 UTC,"There's been a whole bunch of compiler back-end work, as usual. I'd have to ask a BE dev for specifics, but I know they've been looking at autovectorization. For example, Eric Brumer contributed an improvement to std::allocator, where in 2015 we'll highly align large allocations to be AVX2 friendly. This can increase performance by 10-15% (IIRC), when BE devs usually drool over 0.5% improvements.  I know they've also been fixing devirtualization bugs."
cpp,3bkhjb,STL,4,Wed Jul 1 03:19:09 2015 UTC,"Been using VS2015 very extensively throughout beta. As a personal experience, for C++ 03 code VS2015 is very competitive with GCC if building for x64, but there is a very slight performance regression over VS2013 when programming with C++ 11/14 constructs. VS2015 remains about 15-25% slower than GCC 4.9 for my C++ 14 code. I've noticed a particular cause could be poor optimisation of acquire-release atomic semantics, plus VS2015's inliner gives up a lot sooner than GCC's or clang's. STL knows about some unfortunate legacy ABI requirements which forces VS2015 to be a lot slower/more verbose than GCC or clang and he'll fix them when he is allowed.  Obviously these are personal experiences, your experience may vary."
cpp,3bkhjb,14ned,3,Tue Jun 30 00:38:50 2015 UTC,"Doh, I use C++11/14 heavily, why would it be slower in VS2015?"
cpp,3bkhjb,frog_pow,2,Tue Jun 30 01:08:40 2015 UTC,"New language support in any compiler tends to get optimisation passes added later not sooner for it. As a very simple example, VS2015 now has proper rvalue semantics, so even in your C++ 03 code it'll now use move construction when it can instead of only when asked or it has no choice. If they had not fully tweaked optimisation for move construction yet (I assume they have, but this is an example) then all code might run slightly slower as a result of the improved language support changing how the optimiser works. Equally of course, move construction happening more often is likely a performance win too, so it's not open and shut either way. Some code might lose, other code might win. All I was claiming was that in my own code, I have seen a slight (~1-2%) performance degradation going from VS2013 to VS2015. Other code bases are likely different."
cpp,3bkhjb,14ned,3,Tue Jun 30 08:59:55 2015 UTC,"As a general rule, the compiler back-end (which is responsible for codegen and optimizations) doesn't know anything about C++. The front-end digests C++ into an intermediate representation, which is then consumed by the back-end. Despite my general BE ignorance, I'm pretty confident in saying that it knows nothing about move semantics - all it sees are function calls.  There are special exceptions to this rule, however. Anything involving EH interacts deeply with the BE, so noexcept has required coordinated FE and BE work. For example, one of the bugs that we found and fixed before RTM was that pure virtual functions marked noexcept require their overriders to be noexcept (the FE will emit a hard error, required by the Standard, if overriders aren't noexcept), so when the compiler sees a call to such a pure virtual, it should assume that exceptions cannot be emitted, and optimize accordingly. The bug was that the BE didn't understand that, so it was emitting expensive EH logic, despite the STL's attempt to carefully mark its pure virtuals as noexcept. This was fixed, significantly improving codegen for shared_ptr. (And then I audited all of the STL's pure virtuals; there are a couple more that need to be marked which are on my todo list, but neither of them should be perf-relevant.)"
cpp,3bkhjb,STL,2,Tue Jun 30 15:07:39 2015 UTC,"Thanks for the clarification. And I agree with everything you just said.  I was thinking without a FE/BE distinction, as that's what non-compiler writers care about which I assume is the audience here. Note everything I about to say comes purely from twiddling with C++ and watching the effects on assembler output, so it's all pure hearsay based on my best mental model of how it works, and I actually have no idea what really happens.  From watching how assembler changes according to C++ changes, GCC and clang do a lot of work to avoid ever calling copy and move constructors using the ""as if"" and RVO rules, so if you take care to make your copy and move operations non-weird then GCC and clang will eliminate any copying and moving, and operate in place on a single copy or on a double buffered copy as appropriate. This can have weird rules, like don't do std::move on a lvalue being returned by value from a function which is you being weird which is highly counter intuitive (RVO being the reason of course). But there you go.  By my best understanding this elimination of copying and moving works by identifying where the compiler must synchronise memory e.g. any atomics, any syscall, any extern call etc and trying to eliminate as much code in between as possible. In the ideal case, GCC will, if it can, prune logic branches based on as-if known memory contents starting from the beginning going forwards, potentially reduce to no code at all, whereas clang's optimiser appears to start from where a result must be synchronised to memory and prune logic backwards up the stack to the next memory synchronisation point instead. Two very different approaches, in my own code GCC's approach has a slight average case performance edge most but not all of the time.  MSVC, on the other hand, doesn't appear to optimise using memory synchronisation points as the start and end of its graph folding, and it appears to spit out code as the programmer wrote it except for very trivial inlining based on function calls not memory synchronisation points. In other words, if I write three functions calling one another and any of those could touch global memory state, MSVC appears to simply skip inlining completely and it spits out all three functions as-is unless you give it a poke with __forceinline, and even then it often refuses. I assume this is done because LTCG, which is very involved on MSVC as compared to GCC or clang, can do much more aggressive inlining if it knows more about effects on global memory state. In other words, MSVC is very quick on the compiland by not trying to hard during the compile and gives you the option for a very slow link, whereas clang and GCC try to do much better from the very start.  This is the basis of what I meant by MSVC not appearing to take much advantage of acquire-release atomic semantics. It basically treats them as seq_cst, whereas GCC especially will do a ton of reordering to push together all global state affecting operations into consecutive locations across many inlined functions such that the code between these clusters is maximised, and therefore opportunity to optimise it out is maximised. People still think that atomic acquire-release has no effect on Intel x86/x64, and it doesn't at the opcode level. It has enormous affects on what compilers like GCC can do to your code though, you just don't see the same radical effects on optimisation yet on MSVC, at least up to VS2015.  Hopefully this clarifies what I meant. Just to be clear again, VS2015 can be very competitive to GCC 5.1 and clang 3.7 in x64. It's just if you're working a lot with C++ 11 atomics/spinlocks, it can fall a bit short, though I've never seen worse than 15% and it's usually more like 5-8%. In other words, most users really need not worry."
cpp,3bkhjb,14ned,3,Tue Jun 30 17:42:45 2015 UTC,"Note that the RVO/NRVO doesn't care whether copy/move ctors have side effects - the Standard grants compilers extra permission beyond the usual As If Rule.   In other words, if I write three functions calling one another and any of those could touch global memory state, MSVC appears to simply skip inlining completely   That's incorrect.  C:\Temp>type meow.cpp void f1(int * p) {     *p += 11; };  void f2(int * p) {     *p *= 22;     f1(p); }  void f3(int * p) {     *p += 33;     f2(p); }  C:\Temp>cl /EHsc /nologo /W4 /O2 /c /FAs meow.cpp meow.cpp  C:\Temp>type meow.asm ; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23030.0 [...] ?f3@@YAXPAH@Z PROC                                      ; f3, COMDAT  ; 11   :     *p += 33; ; 12   :     f2(p);          mov     ecx, DWORD PTR _p$[esp-4]         imul    eax, DWORD PTR [ecx], 22         add     eax, 737                                ; 000002e1H         mov     DWORD PTR [ecx], eax  ; 13   : }          ret     0 ?f3@@YAXPAH@Z ENDP                                      ; f3 _TEXT   ENDS [...]   Here, f3() read/writes through an arbitrary pointer. It performs *p = (*p + 33) * 22 + 11; which is equivalent to *p = *p * 22 + 737;. Not only has the compiler inlined f1() into f2() into f3(), it's performed the math necessary to reduce the computation. And this is happening without LTCG, and without the inline keyword-hint."
cpp,3bkhjb,STL,2,Tue Jun 30 18:00:40 2015 UTC,"In other words, if I write three functions calling one another and any of those could touch global memory state, MSVC appears to simply skip inlining completely   That's incorrect.   I had a feeling you were going to say that :)  Your above example works as you describe, and moreover I can provide examples which contradict what I just said earlier too. However, it doesn't make me wrong, just inaccurate through ignorance. I suspect there is something to do with exception handling in there too in that it might confuse the optimiser.  Here's a bug I will be sending to Microsoft after your VS2015 RTM: many of the optimisation failures for lightweight future promise on VS2015 I can see a reason for e.g. we might touch an exception_ptr, however this one has no reason at all:  https://ci.nedprod.com/view/Boost%20Thread-Expected-Permit/job/Boost.Spinlock%20Test%20Win8%20VS2014/lastCompletedBuild/testReport/%28root%29/constexprs/min_option_next_msvc/  Compare that to GCC:  0:  8d 14 76                lea    (%rsi,%rsi,2),%edx 3:  48 89 f8                mov    %rdi,%rax 6:  c6 47 04 01             movb   $0x1,0x4(%rdi) a:  89 17                   mov    %edx,(%rdi) c:  c3                      retq</pre>   The code is this:  extern BOOST_SPINLOCK_NOINLINE option<int> test1(int n) {   return option<int>(n).next([](option<int> m) { return m.get()*3; }); }   .... which is called via test1(5), and it simply returns an option<int> containing 15. You can think of option<T> as an optional<T> for this example i.e. very lightweight.  The 185 opcodes which spew, most of which the compiler knows for a fact can never be called (as GCC and clang figure out), are due to a failure to inline the .next() member function despite it being marked __forceinline, and instead it calls a stock .next() implementation which assumes an unknown global memory state. I tried turning on /Wall, and it simply warns it didn't inline the function, no explanation.  This is the absolute smallest reduced example I can show your compiler team. If you can fix that, I suspect I have more optimisation fails which clang and GCC don't do for you, but this is easily the simplest of the lot.  Anyway once I've verified this on RTM I'll send it into you. And stop talking to me on reddit! Go enjoy your vacation Stephan, we can deal with all this when you get back. I'll be unemployed yet again in a few weeks from now, so I'll have plenty more free time too. Right now it's prep for the Boost.AFIO review in a few weeks time!"
cpp,3bkhjb,14ned,1 point,Tue Jun 30 18:56:26 2015 UTC,"Go enjoy your vacation Stephan, we can deal with all this when you get back.   If he's anything like me, he probably enjoys catching up on bleeding-edge language and toolset updates in his spare time. ;-]"
cpp,3bkhjb,dodheim,1 point,Tue Jun 30 19:56:31 2015 UTC,"Go enjoy your vacation Stephan, we can deal with all this when you get back. If he's anything like me, he probably enjoys catching up on bleeding-edge language and toolset updates in his spare time. ;-]    Me, since May I have spent an average 23 hours per week earning money and an average 45 hours per week preparing a new Boost library for peer review later this month. I'm not into languages and toolsets personally, always been a libraries man for some reason, ever since the beginning. Weird what motivates us."
cpp,3bkhjb,14ned,2,Wed Jul 1 01:04:50 2015 UTC,"there is a very slight performance regression over VS2013 when programming with C++ 11/14 constructs.   Please give me a self-contained repro.   I've noticed a particular cause could be poor optimisation of acquire-release atomic semantics   Ditto for this one (I believe you, but I need a repro to report to the back-end team).   STL knows about some unfortunate legacy ABI requirements which forces VS2015 to be a lot slower/more verbose than GCC or clang and he'll fix them when he is allowed.   Remind me what this is? (I and my brain are on vacation.) In the STL, we don't have any ABI requirements. The compiler tries not to break ABI, which is why x86 is locked into code-based EH, but that's about the only limitation I can think of."
cpp,3bkhjb,STL,1 point,Thu Jul 2 01:25:58 2015 UTC,"I've noticed a particular cause could be poor optimisation of acquire-release atomic semantics   Ditto for this one (I believe you, but I need a repro to report to the back-end team).   I thought I sent you one based on concurrent_unordered_map?    STL knows about some unfortunate legacy ABI requirements which forces VS2015 to be a lot slower/more verbose than GCC or clang and he'll fix them when he is allowed.   Remind me what this is? (I and my brain are on vacation.) In the STL, we don't have any ABI requirements. The compiler tries not to break ABI, which is why x86 is locked into code-based EH, but that's about the only limitation I can think of.   I hope you don't mind if I quote you directly:   The error_category immortalizer is my workaround to make the Standard's ""only one generic_category/etc."" object compatible with our DLLs and _ITERATOR_DEBUG_LEVEL scheme.   and   We've got a circularity problem with shared_ptr, so that's why exception_ptr stuff is separately compiled. I've got a todo on my list to see if we can do anything about that. ... The one thing I'm aware of is that exception_ptr is copyable-only but should be movable.   VS2015 can be very competitive, but it needs poking with __forceinline. You can see some benchmarks I literally posted today for lightweight future promise at https://plus.google.com/+nialldouglas/posts/GkvJgipzPjR where VS2015 is handily beating out clang and GCC on the same hardware. You'll also see that Dinkumware's future-promise is about half the performance of libstdc++'s.  BTW STL, you can worry about this after vacation, but there is a standards conformance problem in your future<T>.get(). See Anthony Williams' comments at the bottom of the google plus post. As he says, it's probably a standards defect and your STL is not wrong, just different."
cpp,3bkhjb,14ned,1 point,Fri Jul 3 02:50:20 2015 UTC,"I thought I sent you one based on concurrent_unordered_map?   I see a thread in my E-mail archives from Sep 2014, where JoEmmett believed you were seeing a noexcept perf bug that was fixed in CTP4. If you're still seeing problems in RC, please send us another repro. It would really help if you can make it minimal - e.g. if it involves acquire-release semantics, then use only <atomic>, not all of concurrent_unordered_map (that's a large, non-Standard header).  You're seeing perf impact from the error_category trickery? If you were absolutely hammering generic_category()/etc., I suppose the TLS access from magic statics might be an issue, but otherwise that should be invisible.  Thanks for the exception_ptr reminder, that is definitely a perf issue (but it's not for ABI reasons - changing it is just a lot of mechanical, tedious work).  If the Standard is defective (and it sounds like it is, since he's correct that postconditions don't apply to exceptional cases), he should file a Library Issue."
cpp,3bkhjb,STL,1 point,Tue Jun 30 17:13:34 2015 UTC,"plus VS2015's inliner gives up a lot sooner than GCC's or clang's   Are you using #pragma inline_depth? If not, why not?"
cpp,3bkhjb,dodheim,1 point,Tue Jun 30 17:37:22 2015 UTC,I'm not aware that pragma inline_depth has had any effect in any recent MSVC. It's been defaulted to its maximum setting for a long time now.
cpp,3bkhjb,14ned,1 point,Tue Jun 30 17:52:54 2015 UTC,"Ah, this is news to me – do you know where this is documented, or at least noted by someone authoritative from MSFT in a blog/ML/somesuch?  EDIT: This contradicts the docs, which state the default to be 254, when unlimited (specified with 255) is the maximum."
cpp,3bkhjb,dodheim,1 point,Tue Jun 30 23:59:35 2015 UTC,"Ah, I didn't know it was 254. I just knew it didn't seem to have any limit I'd run into in recent years. What stops the inlining is not call depth, it's something else going on."
cpp,3bkhjb,14ned,1 point,Wed Jul 1 00:20:55 2015 UTC,"Ah, gotcha. Hopefully the resumption of this discussion is in a public forum, I'm very interested to see the outcome.  And FWIW, 254 vs 255 is readily apparent when using complex grammars in Spirit v2, and complex MSM machines."
cpp,3bkhjb,dodheim,1 point,Wed Jul 1 01:52:00 2015 UTC,"Personal anecdote: they've fixed an avx regression that I've run into with auto vectorization from vs 2013 which is great, and also I'm getting some better codegen from some intrinsics too which previously still did some silly memory dances."
cpp,3bkhjb,adzm,1 point,Wed Jul 1 02:43:00 2015 UTC,"I tested the RC and it was very good! I hope you fixed the two/three bugs I reported with the smile button! Two notes: - It could have been really interesting if we got intermediate updates after the RC, or an RC2 - I would really would like to read the follow up post on the Universal CRT story. You said that app-local would be added in time for RTM, it is still true?"
cpp,3bkhjb,QbProg,7,Wed Jul 1 02:48:56 2015 UTC,"Send A Smile bugs do get filed in our internal TFS database, but I'd need your titles in order to look them up. When resolving them, we have the ability to look up the submitter's E-mail address (if given) and directly E-mail them, although I suspect that not all devs do this (I try to remember for my STL bugs).  I think I can say a little bit about our development process without risking the wrath of my brain bomb. Up until RC, it's mostly open season for changes (e.g. we can make binary compatibility breaking changes in the libraries). Between RC and RTM we go through an increasingly strict lockdown. At first we can't make breaking changes, then we can't sneak in even minor features, then we have to ask for dev manager approval for any fixes, then director approval, then they upload the gold-plated bits to the servers and we're shipping. This ensures that we don't destabilize the product. It also means that shipping a public ""RC2"" wouldn't be very useful, since we wouldn't be able to react to any feedback other than the most dire ""setup melts my SSD and the metal fumes are making me dizzy"" bugs, and we can (hopefully) get that kind of validation through our internal testing. We may or may not change our prerelease cycle in the future, but it should be safe to say that with 3 weeks until RTM, there won't be a 2015 RC2. (A webcompiler update would be feasible, although I don't know if one is planned or has happened; I'm on vacation this week! :->)  I'm not sure if James has another Universal CRT post planned. App-local deployment of the CRT/STL/etc. will definitely be supported in RTM (for desktop apps; inapplicable to Store apps); I got official confirmation and mentioned it in a VCBlog comment.  My ""STL fixes, part 2"" blog post is in the works and I'll finish it when I get back from vacation."
cpp,3bkhjb,STL,2,Wed Jul 1 21:22:33 2015 UTC,Have a nice vacation!
cpp,3bkhjb,KindDragon,1 point,Tue Jun 30 06:29:59 2015 UTC,Question: I own 2013. Any type of free upgrade or am I going to have to look at getting MSDN again?
cpp,3bkhjb,WineVirus,1 point,Tue Jun 30 07:02:11 2015 UTC,"If not, maybe free Community edition will enough? I guess they will release free edition as did with Visual Studio 2013 Community Edition."
cpp,3bkhjb,Talkless,2,Tue Jun 30 20:57:14 2015 UTC,"Yeah, there's a 2015 Community edition. (And the setup team has sworn that 2015 Community RC can be updated in-place to 2015 Community RTM.)"
cpp,3bkhjb,STL,1 point,Tue Jun 30 16:20:15 2015 UTC,"Cool, thanks!"
cpp,3bkhjb,Talkless,1 point,Tue Jun 30 17:20:28 2015 UTC,"BTW, is there any chance to see OpenMP >= 3.0 in MSVC?"
cpp,3bjuly,joaquintides,2,Mon Jun 29 20:29:51 2015 UTC,Interesting article! What made you decide to not use the move constructor/assignment methods in this case?
cpp,3bjuly,Bart_V,1 point,Tue Jun 30 05:59:51 2015 UTC,"Yes, the proper way of writing this in C++11 would be with &&'s and std::move, but I conciously decided not to use them in my example as I feel some readers not be that familiar with them and so miss the point of the article."
cpp,3bjuly,tecknoize,1 point,Tue Jun 30 06:03:28 2015 UTC,Very interesting and well explained. I'm in the middle of a hard design problem and its soothing to see a nice solution to a problem. Thank you!
cpp,3bi8ea,pmost,1 point,Mon Jun 29 13:03:08 2015 UTC,"The <algorithm> header has a lot of really sweet stuff to make your life easier, like std::transform, std::all_of, std::any_of, std:find_if etc."
cpp,3bi8ea,Leandros99,1 point,Mon Jun 29 16:13:38 2015 UTC,"And it's about to get a whole lot better when Eric's ranges are integrated. The first step (his current C++17 proposal) is a blessing, and then it gets more awesome after that."
cpp,3bi8ea,redditsoaddicting,16,Tue Jun 30 09:51:13 2015 UTC,"I'm aware of it, but it's a mistake to ever use wchar_t.  Keeping everything in utf-8 is the only sane approach."
cpp,3bi8ea,o11c,5,Thu Jul 2 03:12:03 2015 UTC,"I agree with ""utf-8 everywhere"" but I have found myself having to use wchar_t, wstring, etc for Windows GUI code that interfaces with my cross-platform (utf-8) code."
cpp,3bi8ea,RowYourUpboat,2,Mon Jun 29 18:35:36 2015 UTC,"Also qt, ICU, Java and C# integration.  Non-utf-8 data and APIs are in more places than naive people care to admit :-)"
cpp,3bi8ea,Gotebe,1 point,Mon Jun 29 19:32:34 2015 UTC,"I also believed that back in 2004. Since then I've believed the opposite. I presume you work exclusively on linux, is that right?"
cpp,3bi8ea,AceyJuan,3,Tue Jun 30 16:47:24 2015 UTC,eli5?
cpp,3bi8ea,givemesomelovee,3,Tue Jun 30 07:43:16 2015 UTC,This is a nice eli5: https://en.wikipedia.org/wiki/Byte_orientation  Edit: And the wiki bot has practically the entire text of the article since it's so short.
cpp,3bi8ea,JamesMean,3,Mon Jun 29 16:34:26 2015 UTC,"Byte orientation:       Byte orientation refers to forms of data processing in which digital data are processed bytewise. For example, communication is called byte oriented or character oriented when the transmitted information is grouped into bytes.  The latter term is deprecated, since the notion of character has changed. An ASCII character fits to one byte (octet) in terms of the amount of information. With the internationalization of computer software, wide characters became necessary, to handle texts in different languages. In particular, Unicode characters can be 8, 16, or 32 bits long, i.e., 1, 2, or 4 bytes.  Byte oriented transmission makes use of byte-oriented protocols, that may involve transmission of additional bits as terminators, means of error recovery, etc.     Relevant: Bitstream | Endianness | Bit | Word (computer architecture)   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
cpp,3bi8ea,autowikibot,9,Mon Jun 29 17:30:35 2015 UTC,"For clarity, most people don't think of FILE* as a C++ stream."
cpp,3bi8ea,Steve132,2,Mon Jun 29 17:31:18 2015 UTC,"Yep.  Unfortuately it's useless with the standard streams.  You can only call fwide(3) once, after which the orientation is immutable.  This means if you need a wide stdout but some other library or setup code set it to narrow, you're screwed.  I'm not sure why the rule here is so draconian; what would be so bad about allowing it to be changed multiple times?  It's fine for streams you create yourself, of course."
cpp,3bi8ea,RogerLeigh,-16,Mon Jun 29 17:10:24 2015 UTC,"This was around since C95, everyone knows about it."
cpp,3bi8ea,CubbiMew,9,Mon Jun 29 18:57:16 2015 UTC,"Well, I was out of the loop..."
cpp,3bi8ea,AntiProtonBoy,1 point,Mon Jun 29 13:29:20 2015 UTC,Me too (and probably a major part of the readers that down-voted /r/CubbiMew).
cpp,3bi8ea,furbyhater,2,Mon Jun 29 14:26:19 2015 UTC,Some people were born after that
cpp,3bi8ea,Herbert_Von_Karajan,2,Mon Jun 29 19:13:36 2015 UTC,Some people were born that exact year
cpp,3bi8ea,Kyyni,2,Mon Jun 29 16:42:36 2015 UTC,You must be really smart!
cpp,3bi8ea,gegoggigog,-1,Mon Jun 29 21:12:34 2015 UTC,"I am simply questioning the usefulness of picking a random old library function for a reddit post. It's not like it's std::invoke or std::void_t. What next, ""Hey, have you ever heard of strcspn?"""
cpp,3bi8ea,CubbiMew,1 point,Mon Jun 29 17:28:17 2015 UTC,"It's not just about a random function like fwide() but also about the orientation, which I'm guessing, a lot of developer who use FILE * didn't know about."
cpp,3bi8ea,CubbiMew,1 point,Mon Jun 29 17:46:02 2015 UTC,"Yes, that's what I learned yesterday. It's rather alarming, actually."
cpp,3bg8jc,jrandom,5,Sun Jun 28 23:18:37 2015 UTC,"thread_local is supported in clang++-3.5 on Linux, so it just depends on what version of clang XCode is using. I don't use a mac, so I may not be striking at the correct point here. Is it possible to update the front- (middle? back? middle-back? I'm not sure where they put clang in the mix.) end of XCode?"
cpp,3bg8jc,OmegaNaughtEquals1,5,Mon Jun 29 02:06:32 2015 UTC,"Turns out, Apple specifically disabled thread_local. :("
cpp,3bg8jc,guepier,3,Mon Jun 29 02:46:11 2015 UTC,"So why not just use the Homebrew clang then? I understand that that’s a bit annoying as a requirement for other people to compile your code but in the end you’re simply requiring a conforming C++11 compiler (with hints of how to get one easily for Mac), which isn’t too much to ask nowadays."
cpp,3bg8jc,RogerLeigh,1 point,Mon Jun 29 08:50:41 2015 UTC,"This is the solution I'm leaning towards, if it'll run with XCode. I'd rather not write a bunch of workaround code I'll just be deleting later when thread_local gets support again."
cpp,3bg8jc,guepier,1 point,Mon Jun 29 16:03:09 2015 UTC,"You can get into a mess quite easily due to the homebrew-provided compiler needing lots of manual options setting to ensure that the paths are correct both and compile-time and run-time.  We ran into problems last week with libgcc--using the older system one rather than the homebrew clang-provided one caused problems with exception handling.  It may well cause threading-related oddness as well.  I'd love to use homebrew clang more; I just wish it integrated better with the system.  On Debian, I can have multiple compilers installed and running without any extra hoops to jump through, so I'm not sure why it's so difficult on MacOS other than Apple making it unnecessarily difficult."
cpp,3bg8jc,OmegaNaughtEquals1,1 point,Mon Jun 29 18:50:19 2015 UTC,"Good question, I’d love to know this as well (I suspect the answer lies in Homebrew trying to be nice and not overriding Apple’s default install). That said, during the installation of Homebrew clang, it displays a message showing how to configure the paths properly. In principle it’s enough to put those as environment variables into your shell’s rc file."
cpp,3bg8jc,jules1972,2,Mon Jun 29 23:16:04 2015 UTC,Ugh. Apple. Just... ugh.
cpp,3bg8jc,vlovich,2,Mon Jun 29 06:14:09 2015 UTC,"To work around this I had to roll our own fallback implementation for the JUCE ThreadLocalValue class It's not too hard to do, and although less optimal than something that the compiler can generate, there's not much overhead if you only have a modest number of TLVs and threads."
cpp,3bg8jc,foonathan,1 point,Mon Jun 29 14:16:57 2015 UTC,I doubt there's a timeline.  Does [NSThread threadDictionary] provide something for what you're looking for?  Also I think __thread works on OSX.  You probably can also use the POSIX API via pthread_setspecific/pthread_getspecific
cpp,3bg8jc,vlovich,2,Mon Jun 29 00:13:09 2015 UTC,"I'm using strictly standards-only C++ 11/14, so no NSThread. I'll try out __thread and if it works, isolate it so I can easily replace it when (better not be ""if""!) thread_local gets support.  Edit: Well drat. __thread only supports trivial POD types and I need a thread-local std::unordered_map."
cpp,3bg8jc,vlovich,2,Mon Jun 29 02:05:25 2015 UTC,"You can have a __thread std::aligned_storage big enough for an std::unordered_map and use the nifty counter technique with thread local counter to call placement new and the destructor respectively.  That doesn't leak, ensures a well-defined initialization and destruction, and I have used it many times, e.g. in my temporary_allocator here: https://github.com/foonathan/memory/blob/master/src/temporary_allocator.cpp"
cpp,3bg8jc,vlovich,1 point,Mon Jun 29 08:57:04 2015 UTC,"__thread std::unordered_map<X, Y> *m; if (m == nullptr) {     m = new std::unordered_map<X, Y>(); }"
cpp,3bg8jc,vlovich,3,Mon Jun 29 02:15:45 2015 UTC,That leaks memory whenever a thread exits.
cpp,3bg8jc,afjw0ge9h,1 point,Mon Jun 29 02:45:04 2015 UTC,"Have you explored the pthread API for this?  __thread std::unordered_map<X, Y> *m; pthread_cleanup_push([](void *x) {     delete reinterpret_cast<std::unordered_map<X, Y> *>(m); }, m);"
cpp,3bg8jc,vlovich,2,Mon Jun 29 11:57:51 2015 UTC,I'd like to stick with C++11/14's std::thread and related calls. Is there a non-pthread way to do that?
cpp,3bg8jc,afjw0ge9h,1 point,Mon Jun 29 13:58:25 2015 UTC,Highly unlikely.  There are a number of suggestions in this thread:   Use the platform-specific APIs & hide it as a platform-specific implementation detail. Use the POSIX APIs & hide it as a braoder platform-specific implementation detail Use __thread to a pointer & destroy it manually on thread exit Use boost's TLS implementation. Compile clang yourself from upstream   The toolchain provided by the platform you're targeting doesn't support thread_local.  I am not aware of any other options that aren't problem-specific.
cpp,3bg8jc,djshadow2,1 point,Mon Jun 29 15:12:19 2015 UTC,I think the next thing I'm going to try is to recompile Clang. I'd very much like to stick with non-platform-specific C++ since I'll be wanting this thing I'm writing to eventually be compilable on both Linux and Windows as well as Mac.
cpp,3bg8jc,guepier,1 point,Mon Jun 29 16:05:00 2015 UTC,"That's what I assumed.  Personally, I think using boost is an easier proposition than having to compile the compiler myself but that's just my preference.  Something else to keep in mind is that I'm pretty sure you'll be unable to take this approach with iOS.  Something else to keep in mind. In my experience, having written quite a bit of cross-platform code, aside from the most trivial of applications, platform-specific code is inevitable.  Trying to avoid it at all costs instead of planning for it ahead of time can lead to some ridiculous contortions.  My recommendation is abstract the pieces that are platform-specific behind sensible generic APIs.  For example, I might provide generic_tls.cpp and darwin_tls.cpp.  Then generic_tls.cpp gets compiled for all platforms but OSX/iOS.  There's a single platform_tls.h header that defines the interface I want it to have.  Of course, I'm using TLS as a place-holder.  You typically want to do it at a slightly higher-level than this so you can make the optimal decision for this platform.  For example, if the unordered_map is a cache of some kind, I might use libdispatch to synchronize a thread-safe cache on OSX/iOS & mutexes for Linux.  On Windows I might use a thread_local implementation if I felt that was the best performing mechanism on that platform.  I would use CMake as the build system to make managing all of this easier."
cpp,3bg8jc,14ned,1 point,Mon Jun 29 16:42:58 2015 UTC,"This particular project is a world-agnostic AI system I've been hammering away at since 2005 (started out in C99 of all places). After a decade my programming skills have finally  matured to the point where I think I can finally pull it off.  Since it's an AI framework, it doesn't have to deal with any  system-specific pieces, not since threading was added as part of the C++ standard library. Except for this thread_local nonsense. (I'm not targeting iOS or any other mobile platform -- the CPU usage it will incur makes it useless for small battery-powered devices. I'm going full many-cores pc-master-race with this one. :) )"
cpp,3bg8jc,14ned,0,Mon Jun 29 18:03:23 2015 UTC,yes. but depending on your use-case you could delete it before thread exists. If you are able to determine that moment.
cpp,3bg8jc,guepier,2,Mon Jun 29 09:06:45 2015 UTC,"That can be difficult/impossible to actually do correctly/robustly.  I only proposed it as a possible solution in case it's OK to leak (e.g. the number of threads never changes until the program dies).  You can try using boost's TLS but unless you're using boost threads, you may be SOL.  There's not a whole lot of guidance to what conditions it works under."
cpp,3bg8jc,guepier,1 point,Mon Jun 29 11:55:19 2015 UTC,"sure, could be difficult/impossible, depends on usecase"
cpp,3bg8jc,Plorkyeran,1 point,Mon Jun 29 12:18:34 2015 UTC,Can you use boost::thread_specific_ptr ?
cpp,3bg8jc,Gotebe,0,Mon Jun 29 02:56:50 2015 UTC,"I've kinda sworn off boost, after an initial torrid affair. :)  I'm going to make a stub allocator that just aliases to std::allocator for the time-being so I'll be able to simply plug in mine once there's support from Apple for thread_local.  The use-case is that I'm going to have a lot of threads constantly allocating and deallocating little fragments of memory darn near constantly (it's for a stochastic goal solver for autonomous AIs) where work units can get shifted from thread to thread, so I wanted to write a custom allocator that uses a static thread-local map of freelists stored in a base class (keyed by size in bytes). Without thread-local storage I'd have to wrap each access in a mutex and that would just be bad news."
cpp,3bg8jc,sbabbi,10,Mon Jun 29 03:03:20 2015 UTC,"I've kinda sworn off boost, after an initial torrid affair. :)   Back up here. Using modern C++ without Boost is madness. You don’t have to use all the libraries (nobody does, almost certainly) but using none of them is almost certainly a mistake, especially when you have complete control over the project (as you seem to have). Boost simply offers some of the most high quality, general purpose libraries for C++."
cpp,3bg8jc,Gotebe,2,Mon Jun 29 08:52:35 2015 UTC,"Boost comes with a complexity cost and compile-time hammer I no longer want to deal with. I used it for years and finally decided it wasn't worth the trouble despite some very nice libraries within.  I see I'm getting downvoted by boost fanatics and that's okay. I understand. I was there, for a time. :)"
cpp,3bjt4b,sdesimonebcn,5,Mon Jun 29 20:19:21 2015 UTC,How many more times will these articles be posted?
cpp,3bjt4b,acwaters,6,Mon Jun 29 20:31:01 2015 UTC,"Really. Any time I see someone ask what a good language to learn is, most of the time I see either:  a) C++  b) Java  or c) Python.  Sure, C++ isn't quite the ""top dog"", but I get tired of seeing entire articles written out to make it seem like C++ had disappeared. Seeing those articles makes me feel like, ""oh, maybe I shouldn't be using it anymore"" when really it is still perfectly fine. Why learn an entire new language  (or 3) to do exactly what C++ was designed to do?   C++ didn't go anywhere, people's dedication to making good programs did."
cpp,3bjt4b,J04T13,5,Mon Jun 29 20:57:44 2015 UTC,"For a while it fell out of favor in some circles.  Clearly there are some circles where it never left.  But the rapid iteration and deliverables of Boost, GCC and - whoda thunk it - the ISO WG in the past 3-4 years have made for a full-on language renaissance. It is fun to write C++ again!  PS can't leave out /u/STL and the folks at Microsoft who have pushed C++ on Windows a long way in this time as well!"
cpp,3bjt4b,cae,4,Tue Jun 30 03:05:41 2015 UTC,It disappeared completely for you if you live a bubble of webdev and JS frameworks.
cpp,3bjt4b,orost,9,Tue Jun 30 10:02:51 2015 UTC,aka hell
cpp,3bjt4b,cynicalsingularity,1 point,Tue Jun 30 11:44:27 2015 UTC,"Looks like this link got double posted to reddit, I posted my comment in the other one:  I think an ok article, a decent brief summary of some the issues surrounding c++'s evolution in the modern space. I think that anyone who is interested in this topic should view Herb Sutter's talk: https://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C. Herb gets into many more details, uses a lot of hard data."
cpp,3bjt4b,quicknir,1 point,Tue Jun 30 16:05:38 2015 UTC,"Very true, but I've not seen any articles that really shed light on the subject (probably because no-one knows any actual interesting facts), just a load of 'me too' click bait."
cpp,3be34n,mttd,5,Sun Jun 28 10:21:21 2015 UTC,Doxygen is indispensable but I really wish they would test their html on mobile devices. I'm on Android/chrome ATM and I cant pinch zoom or scroll their site at all.
cpp,3be34n,dgendreau,3,Sun Jun 28 11:05:06 2015 UTC,Breathe with Bootstrap Theme is a nice mobile-friendly alternative to Doxygen's HTML output.
cpp,3be34n,aearphen,3,Sun Jun 28 14:49:01 2015 UTC,"Thanks, that sounds great for my own needs, but I was referring to the Doxygen website itself, which is generated using Doxygen. I couldnt read any of the new features past 3 or 4."
cpp,3be34n,dgendreau,1 point,Sun Jun 28 15:57:56 2015 UTC,Does it use clang yet it is still based on its own parser?
cpp,3be34n,tending,1 point,Mon Jun 29 02:41:40 2015 UTC,"Looks like they added ""clang asssisted parsing"" in 1.8.4 in 2013."
cpp,3bccp5,quicknir,8,Sat Jun 27 21:42:51 2015 UTC,I've been wanting to fully move towards using Rule of Zero for some time now but as I primarily use Visual Studio for my development needs I haven't quite been able to do so until this week... Why? Because pre VS2015 move constructors and operators weren't being automatically created by the compiler...  Edit: Also wrote a similar class that could handle polymorphism once... Was planning on using it in a project but after I finished I realised I could rewrite it in another way that removed its need... Code here if anyone is interested... It uses boost::any as the actual holder of the item but all access happens trough a cached pointer...  Edit2: Just gotta add that after looking at my implementation of value_ptr again it isn't actually currently working. It's pretty easy to fix and it doesn't have some basic functionality that should have been there... Thats what you get for sharing something that you stopped working on when you realized you didn't actually need it...
cpp,3bccp5,CptBread,2,Sat Jun 27 23:01:50 2015 UTC,"Does VS2015 not generate special functions even if you use the = default syntax? Some people think you should actually write =default for the special functions, which of course is fine, does not alter the essence of the article.  Interesting use of boost::any, wouldn't have thought of it. Glad I read your code, helped me understand how boost any correctly copies its type. I do think though it's a bit overkill, in the sense that all we want to do is change the copying behavior, boost::any is primarily for type erasure which isn't the goal.  Also, it wasn't clear from your post if you were saying otherwise, but to be clear: copyer can handle polymorphism, it's just a matter of defining a different functor and template copyer on it (which is just a few lines)."
cpp,3bccp5,STL,8,Sun Jun 28 02:31:32 2015 UTC,"VS 2013 didn't automatically generate moves, and didn't allow defaulted moves. VS 2015 does both, following the Standard."
cpp,3bccp5,CptBread,1 point,Sun Jun 28 02:32:57 2015 UTC,"Sorry, I missed the ""pre"" in the original post."
cpp,3bccp5,CptBread,0,Sun Jun 28 02:36:54 2015 UTC,I currently fail to see how you would easily add proper polymorphism support with your copyer unless you basically do what boost::any is doing... Or am I missing something obvious?  On the topic of using boost::any for storage I fail to see the problem as the main meat of if is dealing with copying objects without knowing compile time what its type is...
cpp,3bccp5,CptBread,1 point,Sun Jun 28 21:12:01 2015 UTC,"Usually if you are writing polymorphic objects you think you'll be interested in copying, you add a clone method that returns a copy of the object (by value or by pointer). You would use this clone method in the functor that you would templatize copyer on.  This is in fact exactly what boost::any itself does internally (use the clone method to make copies).  The meat of boost::any is, well, the fact that you can store anything. Because boost::any fully erases the type, you can e.g. have an array of totally unrelated objects, stored in boost::any."
cpp,3bccp5,CptBread,1 point,Mon Jun 29 02:18:52 2015 UTC,"Ah... Thought you meant adding requirements for the types that uses it... But yeah that does make sense and I guess the case where you can't add something like that would be very rare.    The meat of boost::any is, well, the fact that you can store anything.    Kinda what I was saying except I'd argue that it's storing and copying... Because if you only needed storing the implementation would basically be a void pointer with a type_info...  Edit: Just gotta add that after looking at my implementation of value_ptr again it isn't actually currently working. It's pretty easy to fix and it doesn't have some basic functionality that should have been there... Thats what you get for sharing something that you stopped working on when you realized you didn't actually need it... That doesn't mean that the point I have been arguing is wrong though..."
cpp,3bccp5,CaptainCrowbar,1 point,Mon Jun 29 10:11:21 2015 UTC,"With boost::any, you also get any_cast which using dynamic_cast internally to perform a safe (run time checked) cast to the object in question. Much better than void pointer. If you put something in boost::any, you are always erasing the type, and you will basically always any_cast it to use it. You use boost::any when you want type erasure, you may also need to copy it, you may not, but you always want type erasure.  Our solutions are also doing two very different things. Your solution solves polymorphic copy when a clone is not provided, but that's all it does. My example is about altering or even creating (in this case of unique_ptr) copying behavior. The only place they intersect is for polymorphic copying.  In that case, I would use my solution when clone was available (on the grounds of simplicity, and avoiding a redundant pointer), and yours when it wasn't."
cpp,3bccp5,CaptainCrowbar,1 point,Mon Jun 29 15:03:42 2015 UTC,"With boost::any, you also get any_cast which using dynamic_cast internally to perform a safe (run time checked) cast to the object in question.   No it doesn't... It does a comparison check between the type_infos and then does a static_cast. Which is why I wrote void pointer and type_info.   My example is about altering or even creating (in this case of unique_ptr) copying behavior.   And the problem is that it isn't actually creating correct copying behaviour for any use of unique_ptr. Which is fine as long as you make it clear.  And now that I read it again I do see you do make this clear when talking about DeepCopyPointer so that's good. Did I miss it the first time or did you add it afterwards? Not meant in an aggressive way just want to know if I was blind or not"
cpp,3bccp5,CaptainCrowbar,1 point,Mon Jun 29 16:03:27 2015 UTC,"Correct you are, I could have sworn it was dynamic. Seems like there's a different boost container I was thinking of. void pointers and type_info are much worse for two reasons: first, you're much more likely to mess something up carrying around naked void pointers. Second, type_info is implementation defined, requires RTTI to be enabled, etc, generally a much worse mechanism than using templates.  Anyhow, I think we've agreed as much as we're going to on boost::any. I think it's a great solution when you need type erasure, I would almost never use it otherwise. My solutions are templated on the contained type, which is preferable if you don't need type erasure. Correct copying behavior for a polymorphic class that a) you don't control and b) doesn't have clone, is a very interesting edge case I'll keep in mind, so thank you for that.  I did not change those parts. I think it's clear in multiple places that the copying behavior is non polymorphic, and that the whole point of copyer is just to remove boilerplate and allow classes to easily redefine copying behavior of their members, not to provide a new pointer type with universally correct copying semantics."
cpp,3bccp5,nikbackm,1 point,Mon Jun 29 16:16:00 2015 UTC,"void pointers and type_info are much worse for two reasons: first, you're much more likely to mess something up carrying around naked void pointers. Second, type_info is implementation defined, requires RTTI to be enabled, etc, generally a much worse mechanism than using templates.   You seam to have misunderstood what I meant before. I meant that if boost::any didn't need copying then internally all that would be needed would basically be a void pointer and a type_info... So to be more exact I'd had a unique_ptr<void> and a type_info. The type_info would be set during assignment or construction and because we statically know the type in those functions(as long as they are templated) using typeid would not require RTTI to be enabled. And for casting there would be no problem in copying what boost::any_cast does as we would just do the same comparison it does and then do a static cast on the void pointer...   I did not change those parts.   Just me being blind then... Sorry about that...   not to provide a new pointer type with universally correct copying semantics.   It did kinda seem like that when you created your copying_ptr though...  And just one final thing, I'd argue that down casting to a base class pointer is just a specialized type of type erasure."
cpp,3bccp5,nikbackm,1 point,Mon Jun 29 16:40:35 2015 UTC,"I see what you're saying. I'm not claiming that copying is not an important part of any, just that it's not the most important part. The current implementation of boost::any is still cleaner and uses less space than what you're proposing, ignoring the copying issue.  Sure, it is partial type erasure. When it comes to type erasure you want to erase as little of the type you need to, to keep as much of the type safety system as you can. I prefer partial type erasure to total type erasure."
cpp,3bccp5,mare_apertum,16,Mon Jun 29 17:00:05 2015 UTC,"There's one problem with applying ""rule of zero"" and letting the compiler generate all your special member functions: it (sometimes) doesn't give you strong exception safety.  The strong exception safety guarantee says that an operation either succeeds or does nothing: if an exception is thrown, the objects involved are left in their original state. This isn't always possible or desirable, but providing it where you can makes reasoning about your code easier.  Suppose you have two classes, Cat and Dog, each of which has nontrivial copy operations that might throw, but which provide the strong guarantee. Now you make a composite class that has one of each:  class Zoo: public:     // all special members auto-generated private:     Cat c;     Dog d; };   The problem here is the copy assignment operator. Zoo's auto-generated one will look like this:  Zoo& operator=(const Zoo& z) {     c = z.c;     d = z.d;     return *this; }   If Cat's copy succeeds but Dog's throws, the Zoo object that was the target of the assignment is left in a partially updated state. Not necessarily an illegal state, but not one that matches either its state before the operation or its intended state after. The usual way to fix this is the copy-and-swap idiom, but the compiler won't do that for you; if you want a strongly exception safe copy assignment operator, you have to write it yourself.  That means you also have to declare the move constructor and move assignment operator (although you can just =default those), since a user defined assignment operator suppresses both of those. (I have a vague memory they might be planning to change that rule in C++17, but I'm not sure about that.)"
cpp,3bccp5,mare_apertum,5,Sun Jun 28 05:29:19 2015 UTC,"This is a terrific comment. If you don't mind, I'd like to add a brief section mentioning this. Of course, I can give credit by your Reddit alias or whatever you prefer.  I would like to say though: while providing a copy assignment operator through CAS isn't technically following the rule of zero, I think the spirit is still very much inline with my post. Why? Because you don't need to mention any of the individual data members. And you are still getting the correct behavior from the members, it's just that now the copy assignment operator gets it indirectly through the copy constructor.  Maybe the rule of zero should actually be: mention zero of your data members in any of your special functions :-)."
cpp,3bccp5,BaroTheMadman,4,Sun Jun 28 14:01:26 2015 UTC,"Thanks for the compliment :) (If you want to mention me in your blog, my real name is Ross Smith.) Good point about not mentioning data members, but it does mean you have to write a swap() function that will list them internally. Of course a non-throwing swap is usually much easier to write than a non-throwing copy."
cpp,3bccp5,doom_Oo7,2,Sun Jun 28 17:44:26 2015 UTC,"Great!   It shouldn't be necessary to write a swap at all, the default swap implementation will just call the move constructor and move assignment which are already defined elsewhere, so I don't see an issue. Am I missing something? I tend to avoid defining custom swap functions."
cpp,3bccp5,doom_Oo7,2,Sun Jun 28 18:25:00 2015 UTC,"Oh, I hadn't noticed std::swap() had been updated to use move instead of copy. Thanks."
cpp,3bccp5,vombert,2,Sun Jun 28 18:34:55 2015 UTC,"The blog post has been updated, please let me know if there's something you don't like, or something inaccurate. Thanks again for your comment, I think it really helped improve the post. Maybe the ""new"" rule of zero will catch on!"
cpp,3bccp5,vlovich,1 point,Sun Jun 28 20:44:45 2015 UTC,"Shouldn't you take the other/rhs parameter by value when you implement the assignment operator in terms of copy constructor + swap?  That should allow you to move from temporary values, now it will copy them each time."
cpp,3bccp5,sakarri,2,Mon Jun 29 05:34:53 2015 UTC,"Notice above where implement the copy assignment operator, I default the move assignment operator. This overload will trigger when moving from temporaries, so a copy will not be made.  Edit: I know some people advocate this so called ""unified assignment operator"", or more generally functions taking arguments by value. In the context of the assignment operator, it's always a bad idea. More generally, it's usually not a good idea but it does have some uses."
cpp,3bhe53,Resistor510,0,Mon Jun 29 06:11:24 2015 UTC,"I think an ok article, a decent brief summary of some the issues surrounding c++'s evolution in the modern space.   I think that anyone who is interested in this topic should view Herb Sutter's talk: https://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C. Herb gets into many more details, uses a lot of hard data."
cpp,3bd8id,bluescarni,2,Sun Jun 28 03:00:35 2015 UTC,"Just curious, why did you use a bare union instead of a boost variant?"
cpp,3bd8id,quicknir,2,Sun Jun 28 03:22:24 2015 UTC,"Memory. On a 64-bit architecture, the bare union with the rolled-in tagging mechanism uses 24 bytes, an equivalent Boost variant would use 32 bytes."
cpp,3ban6p,tanyatik,9,Sat Jun 27 11:16:20 2015 UTC,Take a look at https://github.com/BartoszMilewski/Okasaki  This is by Bartosz Milewski. He has some nice articles about functional programming in c++. Here is an article where he talks about a functional list http://bartoszmilewski.com/2013/11/13/functional-data-structures-in-c-lists/
cpp,3ban6p,jbandela,-11,Sat Jun 27 12:10:40 2015 UTC,What does that have to do with persistent data structures?
cpp,3ban6p,__Cyber_Dildonics__,5,Sat Jun 27 15:24:10 2015 UTC,His second link is an article about implementing a persistent data structure in an imperative language
cpp,3ban6p,jgcoded,6,Sat Jun 27 15:41:35 2015 UTC,The persistent data structures are in the functional programming sense not the in disk sense
cpp,3ban6p,jbandela,1 point,Sat Jun 27 15:54:04 2015 UTC,"Unfortunately a major impediment to implementing persistent data structures in C++ is lack of garbage collection. Most implementations rely on sharing immutable linked nodes across instances to avoid full copies. With reference counting (std::shared_ptr) this could cause a stack overflow during destruction if it starts a cascade of deletions. I'm guessing that's why there isn't a good library for persistent data structures in C++.  In your case, I would recommend using concurrent/lock-free data structures instead of persistent data structures. They won't scale as well due to synchronization but their performance should be better than copying. Both C++ AMP (Visual C++) and Intel Thread Building Blocks provide implementations of common data structures."
cpp,3ban6p,philippecp,-1,Tue Jun 30 03:50:30 2015 UTC,I used to play around with a library. linq to c++. I don't remember which one of them. But that should give you something to google.
cpp,3ban6p,Swahhillie,-7,Sat Jun 27 18:49:06 2015 UTC,Boost.Serialization if you have access to boost. (Which you should because in my opinion boost is de facto standard)
cpp,3ban6p,cdglove,4,Sat Jun 27 12:29:08 2015 UTC,Apparently I missed the bus on what was meant by persistent data structures.
cpp,3ban6p,cdglove,-8,Sat Jun 27 18:17:19 2015 UTC,"Persistent to what? For persistence to a database, take a look at ODB, it has out of the box support for most standard containers and some more interesting ones, like boost muli-index."
cpp,3ban6p,berium,11,Sat Jun 27 12:23:44 2015 UTC,https://en.m.wikipedia.org/wiki/Persistent_data_structure
cpp,3ban6p,mcmcc,5,Sat Jun 27 12:41:17 2015 UTC,"Persistent data structure:       In computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure.  A data structure is partially persistent if all versions can be accessed but only the newest version can be modified. The data structure is fully persistent if every version can be both accessed and modified. If there is also a meld or merge operation that can create a new version from two previous versions, the data structure is called confluently persistent. Structures that are not persistent are called ephemeral.   These types of data structures are particularly common in logical and functional programming, and in a purely functional program all data is immutable, so all data structures are automatically fully persistent.  Persistent data structures can also be created using in-place updating of data and these may, in general, use less time or storage space than their purely functional counterparts.    Image i     Relevant: Hash tree (persistent data structure) | I/O request packet   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
cpp,3ban6p,autowikibot,-8,Sat Jun 27 12:42:11 2015 UTC,"If you don't find what you are looking for, you might be able to make something by wrapping what you need around sqllite3."
cpp,3ban6p,__Cyber_Dildonics__,2,Sat Jun 27 12:49:44 2015 UTC,Only one l in SQLite ;)
cpp,3bb0y3,SinanUnur,-2,Sat Jun 27 14:28:59 2015 UTC,This is the typical low quality self-promoting fodder this submitter is known for - in short he's just trying to drive traffic to his site.  As an example take a look at his previous spam related to command line arg parsing using boost:  https://www.reddit.com/r/cpp/comments/37n5di/c_parsing_command_line_arguments_with_boost/crp8mj7
cpp,3bb0y3,CPPOldie,8,Sat Jun 27 15:32:09 2015 UTC,I think he's talking about the original C++ code and not what OP wrote...
cpp,3bb0y3,CptBread,3,Sun Jun 28 00:21:57 2015 UTC,My original response to @CPPOldie.
cpp,3bb0y3,quicknir,1 point,Sun Jun 28 00:28:06 2015 UTC,"I don't see anything wrong with his code. It's an interesting article, and the OP's code is perfectly reasonable, modern c++ code."
cpp,3bb0y3,3453280,5,Sun Jun 28 16:53:07 2015 UTC,"As an aside, while the difference between struct and class doesn't amount to much, it is still needlessly cute to define a class in C++ using struct.   Why? I always use struct."
cpp,3bb0y3,RubiksCoffeeCup,2,Tue Jun 30 19:37:25 2015 UTC,"As an aside, while the difference between struct and class doesn't amount to much, it is still needlessly cute to define a class in C++ using struct.   Why? I always use struct.   I used to use struct to indicate that something is semantically a pod type, even if it isn't, but that also can be apparently confusing, because many of my colleagues asked me why something was a struct and what that meant.  So I've stopped.  I think consistency is also a value."
cpp,3bb0y3,dodheim,7,Sat Jun 27 15:45:15 2015 UTC,"For consistency's sake, I always use struct because I almost always want public inheritance and always want my public interface declared first. What does class bring to the table other than a keyword that people cling to for no real/technical reason?"
cpp,3bb0y3,RubiksCoffeeCup,4,Sat Jun 27 16:51:16 2015 UTC,"The reason is readability. Class tells you that there's more to the object than just the datastructure. At least that's the idea.  As I said I now use class exclusively for the benefit of coworkers but none of my structs would have had transparent type casts or sideeffects in accessors and sich,  while classes might."
cpp,3bb0y3,3453280,3,Sat Jun 27 16:57:33 2015 UTC,"I also used to mix them (with slightly different connotations) and changed for the sake of consistency (which one for incomplete types? which one for types that only exist for TMP?). I just picked struct instead :)  If its for the sake of coworkers, maybe its for the best, but I think there are good reasons to prefer struct: the following cases are all simpler with struct: aggregates with all public members; the standard's style of listing all public members before all private members in a class; cases like struct Foo : std::integral_constant<bool, ...> {};, etc.  There was a little discussion on this here too, with both sides represented."
cpp,3bb0y3,dodheim,4,Sat Jun 27 17:03:43 2015 UTC,"Class tells you that there's more to the object than just the datastructure.   That's your convention, not anything intrinsic to the language – others will (sensibly) have different conventions, hence calling use of struct ""needlessly cute"" is simply uncalled-for editorialism."
cpp,3bb0y3,RubiksCoffeeCup,4,Sat Jun 27 17:27:10 2015 UTC,"Are you faulting an author of an opinion piece for voicing their opinion? ;)  But in any case, I agree with you. Use what you are comfortable with and what the code guidelines you work under tell you. I currently have to do a lot of things I don't want to do because of code guidelines. I just gave one avenue of reasoning to explain why someone might not want to use struct in a C++ program."
cpp,3bb0y3,quicknir,2,Sat Jun 27 17:13:33 2015 UTC,"It's a pretty broad convention. It's the google style guide convention, the llvm style is similar, the most common answer here: http://stackoverflow.com/questions/54585/when-should-you-use-a-class-vs-a-struct-in-c."
cpp,3bb0y3,oracleoftroy,2,Sat Jun 27 17:17:26 2015 UTC,"a keyword that people cling to for no real/technical reason?   I think it is unfair to discount convention; every project and team will build up their conventions as it helps teams communicate and get the work done more consistently and faster.  As for technical reasons, I like to use class because the defaults are more restrictive. When I mess up somewhere, the compiler tells me a base class or method is inaccessible. The compiler won't tell me if I forgot to make a field private when using struct. I will use struct for POD types, containers of pure data, and (pre C++11) function objects (code is data!), or anywhere it is strictly required (usually headers designed to be fully compatible with C).  Obviously, there are easy ways to make things public that shouldn't be, but I try to design my code so that mistakes are caught as early as possible, preferably by the compiler. Using class is an easy and low impact, though not foolproof, way to catch some issues early."
cpp,3bb0y3,dodheim,2,Sun Jun 28 03:33:36 2015 UTC,"I think it is unfair to discount convention   Oh, I don't mean to do that at all. I'm just refuting the author calling use of struct ""needlessly cute"" simply because he, purely by convention, prefers class."
cpp,3bb0y3,oracleoftroy,3,Mon Jun 29 16:40:37 2015 UTC,"Ah, I see. Yeah, that's a pretty arbitrary argument. I think there is a good case to be made for either struct or class. I can see a case for calling OO style classes a class rather than a struct so as to use the keyword to document intent, but to dismiss any possible reason to use struct over class in that code like he does is just silly."
cpp,3bb0y3,Paddy3118,1 point,Tue Jun 30 00:41:16 2015 UTC,"A little late to the party as I am not a member of r/cpp.  I did like the post and will probably add a link to it from either the RC task or mention it on the talk page.  I did note the comment on performance and the Python code taking many passes through the word list and would just like to explain. I very much see speed as an optimisatio If you are going to spend more time downloading the word list and the code runs in an ""acceptable time"" then there is no requirement for a minimum speed of execution in the task, and no implied secondary use for code examples beyond fulfilling the task.   I did write the original version of the task and its Python example and try to gave an initial Python example that does verge on the simplistic - Writing a good task description in tandem with the code takes effort to attract other authors of examples.   P.S. I am glad you found the time to follow up on my reddit comment :-)"
cpp,3bb0y3,Paddy3118,1 point,Tue Jun 30 04:17:24 2015 UTC,RC has a link here
cpp,3bbpgs,gold328,5,Sat Jun 27 18:13:44 2015 UTC,This is a well known algorithm and is likely used by many other games. It is also a valid algorithm if you also count rays that pass tangent to the polygon as either a zero crossings or two crossings.
cpp,3bbpgs,Meefims,4,Sat Jun 27 18:18:18 2015 UTC,"As in I can think of many situations where there would be an even amount of crosses but the point still be inside   Got an example? If you've crossed an even amount of times, you have surely gone inside and outside each time and are therefore outside?"
cpp,3bbpgs,sftrabbit,2,Sat Jun 27 18:30:06 2015 UTC,"I have probably walked into something I don't properly understand, but I think of the point as an entity which it might well stand for anyway (I don't properly understand C++ and games programming). Does this rule apply only to external walls or all walls? As if I have a square and then I also put a wall going from the north face of the square to the south face splitting the square in half and the point is placed in the right section, then surely the point crosses 2 walls but is still inside? Or have I got the wrong end of the stick with this whole algorithm?"
cpp,3bbpgs,hahanoob,4,Sat Jun 27 18:48:45 2015 UTC,"You're referring to ""Inside a concave polygon"" here: http://fabiensanglard.net/duke3d/build_engine_internals.php.  The algorithm tells you if a point exists inside of outside of a polygon. If you've bisected the polygon (by adding a wall) then you have two polygons and the point can only be inside one or the other."
cpp,3bbpgs,sftrabbit,2,Sat Jun 27 19:32:03 2015 UTC,Thanks.
cpp,3bbpgs,scatters,3,Sat Jun 27 23:56:01 2015 UTC,"Putting a wall through the square means you essentially have two rectangles next to each other. The wall in the middle is therefore two edges occupying the same space - the right edge of the left rectangle and the left edge of the right rectangle. When you cross that wall, you would +2 to your count.  You can alternatively think of this as having two rectangle polygons that you would check separately (i.e. am I inside rectangle 1? If not, am I inside rectangle 2?)"
cpp,3bbpgs,DerDangDerDang,2,Sat Jun 27 19:40:25 2015 UTC,"Oh right, thanks. This was very helpful."
cpp,3bbpgs,DerDangDerDang,2,Sat Jun 27 23:53:59 2015 UTC,Do you know what a polygon is?
cpp,3bb29p,Brianmj,9,Sat Jun 27 14:42:01 2015 UTC,It's nothing like stack pointer abuse (your second snippet); the nodes are chained together on construction so as long as you don't access the chain after any node is destructed the behavior is fully defined and indeed fully deterministic.   Perhaps you should diagram a run of the program?
cpp,3bb29p,scatters,3,Sat Jun 27 14:54:46 2015 UTC,"It is dangerous. For one thing, I believe that storing ptr as a static local in get_head means that any two lists of the same type will share that value. Additionally it depends on data layouts by casting this into a different type, which I suspect violates some type-based alias rules."
cpp,3bb29p,minno,2,Sat Jun 27 14:50:25 2015 UTC,"Additionally it depends on data layouts by casting this into a different type, which I suspect violates some type-based alias rules.   It's ok for standard layout types like this."
cpp,3bb29p,NasenSpray,1 point,Sat Jun 27 15:59:32 2015 UTC,I agree with your first point.
cpp,3bb29p,quicknir,2,Sat Jun 27 21:40:43 2015 UTC,"I can't see anything wrong with this program as you've written it, though I wonder why the head pointer is scoped to getHead rather than just being a private class member, which would make the pointer-reference-returning gymnastics you're performing here unnecessary.  The only mildly dangerous part of this is the static_cast: as you've written it it's safe, but if you or anyone else came along later and created a list of something not a subtype of the list class, it would invoke undefined behavior (?) and then break."
cpp,3bb29p,acwaters,3,Sat Jun 27 15:16:51 2015 UTC,"perhaps it was to avoid the gymnastics of writing the definition of a static template class member variable =)  It's a snippet gleaned straight from a lecture on TMP @ Digipen https://youtu.be/dyHWVQE3Oo4?t=18m20s. It's cool, but esoteric and prior to what /u/scatters said, I didn't know C++ made any guarantees about node construction like in the example."
cpp,3bb29p,cdglove,2,Sun Jun 28 01:45:29 2015 UTC,"Burying a static in a function is a common trick because it avoids the static initialization order problem. It's talked about in one of Scott Meyers books. The first one, I think, Effective C++"
cpp,3b8ku9,pixel_fcker,6,Fri Jun 26 21:07:10 2015 UTC,"There is a (long) talk by Herb Sutter about lock free programming in general, which is very good. While it doesn't directly answer your question, it does provide s good starting point for the subject as a whole.  I don't have a link, but I think it was on the MS video site (channel 9?). It's in two parts due to the length."
cpp,3b8ku9,TheCreat,2,Fri Jun 26 23:29:37 2015 UTC,"I'd also recommend Jeff Preshing's blog, it's pretty great: http://preshing.com/  For instance, this is a nice intro: http://preshing.com/20120612/an-introduction-to-lock-free-programming/  He's also had a good talk at CppCon 2014: http://preshing.com/20141024/my-multicore-talk-at-cppcon-2014/"
cpp,3b8ku9,mttd,5,Sat Jun 27 12:47:47 2015 UTC,moodycamel::concurrentqueue is a lock free queue implementation that I've used before with good results. He also has a series of blog posts explaining the library.
cpp,3b8ku9,RichieSams,4,Sat Jun 27 06:07:54 2015 UTC,"Great implementation, I'm using this in production right now on a video transcoding platform."
cpp,3b8ku9,termoose,1 point,Sat Jun 27 06:32:58 2015 UTC,This one looks pretty good thanks! I'll give it a go.
cpp,3b8ku9,__Cyber_Dildonics__,1 point,Sat Jun 27 11:57:58 2015 UTC,"This seems really awesome, but it also seems fairly windows/gnu centric from what I can tell by glancing at github and the source.   I have to say though, there is a lot of good stuff there.  He gets a thread id by taking the address of a thread local static.  Why not use the hash of the C++11 thread_id?  Anyone know?"
cpp,3b8ku9,velco,6,Sat Jun 27 12:32:16 2015 UTC,Maybe Intel TBB https://software.intel.com/en-us/node/506081
cpp,3b8ku9,__Cyber_Dildonics__,2,Fri Jun 26 21:55:30 2015 UTC,"This link from this same thread:    https://github.com/cameron314/concurrentqueue  says that both boost and Intel's concurrent queues require trivial copy constructors, and Intel's is not lock free."
cpp,3b8ku9,dicroce,5,Sat Jun 27 12:37:25 2015 UTC,"Not exactly what you asked for, but pretty close: http://liblfds.org/ It includes a multi-producer multi-consumer lock free queue."
cpp,3b8ku9,AntiProtonBoy,3,Fri Jun 26 21:38:18 2015 UTC,Boost has something as well.
cpp,3b8ku9,ddrcoder,3,Sat Jun 27 03:15:14 2015 UTC,"This is an excellent implementation which is used heavily at Facebook. It supports multiple producers and multiple consumers, yet it's still faster than most single producer/consumer implementations we've benchmarked it against.  https://github.com/facebook/folly/blob/master/folly/MPMCQueue.h"
cpp,3b8ku9,dyreshark,2,Sat Jun 27 15:43:51 2015 UTC,"I made a toy one one a while back + released it under the Apache license. Hasn't been used in a production environment, but clang's TSAN didn't complain after ~10m of battering the impl on my desktop. No dependencies except for the C++14 stdlib (would be C++11 if not for std::experimental::optional IIRC)."
cpp,3b8ku9,fsecilia,6,Sat Jun 27 05:21:04 2015 UTC,The following link is a good C version. Use as is or adopt to c++. http://www.1024cores.net/home/lock-free-algorithms/queues/intrusive-mpsc-node-based-queue
cpp,3b8ku9,NasenSpray,2,Sat Jun 27 01:08:37 2015 UTC,I've used this before for an event queue. It's pretty magical. Breaking down exactly WHY it works is a worthwhile exercise.
cpp,3b6e64,mttd,5,Fri Jun 26 10:00:43 2015 UTC,"OT: JUnit has also spread its pestilence into the Python standard library unittest module, which I find abhorrent.  The idea of typing foo.assertEqual(bar) (vs. the much more sane assert foo == bar of other Python testing modules, and not having to inherit everything from some base class) feels so wrong.  Why in the world has JUnit been copied so much?  I guess it's supposed to feel familiar, but I don't want familiarity with Java."
cpp,3b6e64,Rhomboid,1 point,Fri Jun 26 13:45:40 2015 UTC,"JUnit's design works in any language with OO features and some form of reflection, while better designs generally involve leveraging some more language-specific features. This means that if you're looking to write a basic testing framework for a new language, by far the simplest thing to do is to just copy JUnit, and while JUnit is never great, it is somewhat nice to be able to use five different languages and have basically the same testing framework in all of them."
cpp,3b6e64,Plorkyeran,1 point,Fri Jun 26 20:02:34 2015 UTC,"not having to inherit everything from some base class   This hasn't been necessary since JUnit 4, which is nearly 10 years old and came out relatively shortly after Java added annotations. I don't think blaming JUnit for lousy ports is fair. I definitely agree that the notion of familiarity past a certain point is silly or actively harmful, but JUnit (especially with AssertJ) also provides some of the best testing tooling I've used."
cpp,3b6e64,ForeverAlot,1 point,Fri Jun 26 20:22:53 2015 UTC,"eh?  JUnit looks like this Assert.assertEquals(""foo is bar"", foo, bar); or if you have the static import assertEquals(""foo is bar"", foo, bar);.  You don't extend JUnit classes using JUnit."
cpp,3b6e64,cogman10,2,Fri Jun 26 21:15:13 2015 UTC,"Here's the unittest module documentation.  Why does every example implement a class that inherits from unittest.TestCase?  Why can't I just write free functions?  (Free functions don't exist in Java, so I'm not surprised this isn't an option.)  And the point about assertEquals is not about its specific form, it's that it exists at all.  I should be able to write a standard assert, not call some method.  Why do I need all this garbage:  assertEqual(a, b) assertNotEqual(a, b) assertTrue(x) assertFalse(x) assertIs(a, b) assertIsNot(a, b) assertIsNone(x) assertIsNotNone(x) assertIn(a, b) assertNotIn(a, b) assertIsInstance(a, b) assertNotIsInstance(a, b)   And before you can say ""so that the test can print the expected and actual values"", please see my comment elsewhere in the thread showing that a standard assert statement under a different testing framework is perfectly capable of this.  This is what I mean about JUnit spreading its pestilence."
cpp,3b6e64,Rhomboid,1 point,Sat Jun 27 01:28:13 2015 UTC,"For java, at least, the reason you need the assert is to make the unit test framework pluggable. The reason for the various types of asserts is a readability thing (Yes, you could do all of these with a simple assertEquals) for future test maintainers.  Further, the reason for these methods to exist also surrounds java's retardedness around assert.  assert is somewhat garbage in java, it requires a special build parameter to be activated. It isn't pluggable, and it kills off the entire jvm.  You would pretty much need to execute every test in isolation (which sucks because the jvm is a HOG when it comes to shutdown/startup behavior).  As for ""Why does every example extend this"".  Well, that certainly isn't JUnit's fault.  That was a choice by the python people who implemented unittest.  JUnit tests don't do that, so you certainly can't (or shouldn't) blame them for how other languages choose to implement things.  JUnit's structure makes sense for java.  It is very Javay.  The problem is that because it works well for Java, people mimic (sometimes poorly) for their language of choice.  That is where the trouble is.  Java is an extremely verbose language, it doesn't make sense to try and copy a library from java in languages that are more expressive."
cpp,3b6e64,cogman10,1 point,Sat Jun 27 02:21:44 2015 UTC,"The idea of typing foo.assertEqual(bar) vs. the much more sane assert foo == bar of other Python testing modules   The bonus of that pattern, or assert_eq(foo, bar), is that the error message can print out the values of foo and bar rather than just saying ""they weren't the same""."
cpp,3b6e64,minno,2,Sat Jun 27 00:03:42 2015 UTC,"Nope.  $ cat testme.py  def test_foo():     foo = 3     bar = 4     assert foo == bar  $ nosetests3 -d testme.py  F ====================================================================== FAIL: testme.test_foo ---------------------------------------------------------------------- Traceback (most recent call last):   File ""/usr/lib/python3/dist-packages/nose/case.py"", line 198, in runTest     self.test(*self.arg)   File ""/tmp/work.eVjk/testme.py"", line 4, in test_foo     assert foo == bar nose.proxy.AssertionError:      3 = 3     4 = 4 >>  assert 3 == 4   ---------------------------------------------------------------------- Ran 1 test in 0.011s  FAILED (failures=1)"
cpp,3b6e64,Rhomboid,2,Sat Jun 27 01:21:06 2015 UTC,"I guess that applies more to languages (like Java) that can't do quite as much language manipulation. If you call unitTestAssertMakeThisLongToMakeItObviousThatThisIsJava(foo == bar), all the function gets is true or false."
cpp,3b6e64,minno,2,Sat Jun 27 01:48:44 2015 UTC,"Right, I understand.  That's why I think it's so distasteful that the blessed testing framework that was given the privilege of being in the standard library brings the baggage of so many foreign concepts that don't make sense when translated to Python.  Why are people copying JUnit so widely, even when it's such a bad fit?  And that's where this relates to the actual linked article, which is pointing out another example of how doing it the Java Way (i.e. new up an instance for each test) doesn't make sense when translated into C++."
cpp,3b6e64,Rhomboid,1 point,Sat Jun 27 01:59:11 2015 UTC,"We use UnitTest++, it supports ""fixtures"" that provide this ability natively.  It's lightweight and fast, and works well for us."
cpp,3b6e64,coachkler,1 point,Fri Jun 26 14:55:02 2015 UTC,Also in GoogleTest and QtTest is possible to perform setup and teardown for each test and it's really well handled.
cpp,3b8n76,pifighting,15,Fri Jun 26 21:25:19 2015 UTC,"If you try to write Java in C++, you're only going to get frustrated.   Design patterns are language-specific: they are techniques to work around the deficiencies of a particular language, language family or paradigm. There's merit in coding to an interface, but just because in Java you would do that with subtype polymorphism does not mean that the same technique is correct for C++.  The more natural technique would be to use parametric polymorphism: parametrize your algorithm on the matrix type. If you want to ensure restriction to the interface you can then do so with a minimal exemplar type.   If you really want to use subtype polymorphism the handle idiom would be appropriate here. You would however have to solve double dispatch, which is not an issue with parametric polymorphism."
cpp,3b8n76,scatters,1 point,Fri Jun 26 22:38:18 2015 UTC,"Yup, the last 2 posters kind of convinced me of the errors of my ways.    I think they're both hinting at parametric polymorphism as the approach I should be taking as well!  Thanks!"
cpp,3b8n76,cogman10,3,Fri Jun 26 23:21:57 2015 UTC,"I may be in the minority here, but I think that the motto of ""always program to an interface"" is a dangerous one (especially if you do it without understanding why).  Our codebase (Java) has large swaths of code where things were programmed against an interface.  The problem? All of our interfaces only had one implementer.  Further, those interfaces were defined in such a way that a second implementer would be nearly impossible to pull off (To large, expected too much, leaked implementation information all over the place).  That isn't to say that programming against an interface is totally bad, but it is to say that you should use caution and weigh the pros and cons.  My feelings are that if there is only ever going to be 1 implementer of the interface, don't do it.  Further I agree with what others have said, parametric polymorphism is awesome and I wish we could do it in java.  Barring that, your interfaces should be really, REALLY, simple.  IMO, matrix is more complex than most interfaces should be.  Rather you should be thinking ""What sort of interface would other matrix like things need, such as vectors or numbers?"" Addable? Subtractable? Crossapplyable?  Something along those lines if you must have an interface (Though you mostly don't need it for c++ as the template engine works fantastically to eliminate the need for such things).  Another bonus of preferring the template engine for your interfaces is that future C++ will (probably) be introducing the notion of ""concepts""  Which is pretty much exactly what you want, a well defined set of type requirements for the parameters."
cpp,3b8n76,vlovich,2,Fri Jun 26 23:51:29 2015 UTC,"The problem with trying to achieve this kind of model is that mathematical concepts rarely map well, at least in my experience, to inheritance.  Now you could of course allocate everything on the heap & use unique_ptr/shared_ptr everywhere for the ownership.  That is a quick way to kill your performance of course; the JIT in Java can devirtualize & the VM smarter about allocations whereas smart pointers in C++ are not quite so smart.  Of course you could do (*a) * (*b) * (*c).  You could also make sure that you have a const Matrix& or Matrix& where you actually try to use said objects.  My suggestion is that you make good use of templates instead.  SparseMatrix can be a standalone type & operations are just templates that operate on the underlying types (e.g. multiplication in SparseMatrix is a templated operator overload).  Also, I would recommend you start with an existing C++ math library (e.g. eigen) instead of trying to roll your own unless you're just doing it as a learning experience.  If it's a learning experience, looking at how eigen & other libraries tackled these problems will be informative anyway."
cpp,3b8n76,doom_Oo7,1 point,Fri Jun 26 21:41:39 2015 UTC,"Yea I just started looking into shared_ptrs after I posted this.  I didn't know there'd be that big of a performance hit.  Good to know.  This might be mathematical for this example, but there might come a time where it's valid even if it's not mathematical.  If I dereference the pointer as is, won't it become the parent class object and cause some kinda core since it's purely virtual and core since nothing is really implemented yet?  Won't const Matrix& also end up with the parent Matrix object as well where I won't be calling SparseMatrix's implementation of the call?  edit:  By using Matrix as the object itself, I'm not really using RTTI anymore.  I might've picked a bad example to test this out, but all I wanted to do was code to an interface in C++ and I ended up with this snag. And I cannot think of a way out of it."
cpp,3b8n76,doom_Oo7,2,Fri Jun 26 21:56:52 2015 UTC,"One of the key points there is that I should code to an interface as opposed to using the objects outright.   should  Also, in C++ the interface can be defined by the code only, thanks to templates. For instance all the containers (list, vector, etc...) obey the same begin / end interface without any hint of inheritance.  But here, your code sounds much more Java-like than C++-like."
cpp,3b8n76,oracleoftroy,1 point,Fri Jun 26 21:47:24 2015 UTC,"But that's different isn't it?  You're talking about having list<int> a and vector<string> b explicitly defined in the code.  And then list<int> and vector<string> follows the same begin & end which allows me to use/reuse algorithms like transform.   I'm talking about Matrix* defined in the code. Matrix* is instantiated elsewhere as SparseMatrix.  For someone else they might instantiate it as WholeMatrix.  But my function manipulating Matrix*  adheres to the interface defined somewhere.    These are 2 different things right?  To clarify/understand your meaning, you're saying RTTI is a bad way to approach this problem.  I should be implementing it via real objects and calling function<SparseMatrix>(a,b,c).  But wouldn't I have to change the code later on if SparseMatrix sucks and I need to implement WholeMatrix by replacing function<SparseMatrix> with function<WholeMatrix>?"
cpp,3b8n76,doom_Oo7,2,Fri Jun 26 22:13:28 2015 UTC,"I'm saying that your function manipulating Matrix should manipulate a Matrix_T with the interface that you deem reasonable (if it's good enough for Matrix* it's good enough for Matrix_T). If the function can infer the template type from the parameters you're good to go and else, you could always have a using ConcreteMatrixType = SparseMatrix somewhere for your instantiations...  Of course, the difference being that it's completely done at compile time (but are there really places in your code where it might be instantiated as WholeMatrix ? Do you have some kind of plug-in architecture ? Do you need to store both SparseMatrices and WholeMatrices and OtherKindOfMatrices in a single container ?)"
cpp,3b8n76,Gotebe,1 point,Fri Jun 26 22:29:30 2015 UTC,"I understand what you're trying to get at.  It's not entirely what I'm after.   No, all I wanted to do was properly understand/code up a functional example of implementing towards an interface.  (Which to me translate to implementing towards a purely abstract class in C++, not sure how true that is)  The great thing about an abstract class is that I know what methods needs to be implemented when spawning derivations of it.  As with your example, I'm not sure who makes sure begin or end is enforced for those std containers or if I want to create my own container.    edit: Enforced as in those methods are required for that derived class.  Aside from compile time errors when testing it against my driver which has all the methods I'm testing against.  I chose Matrices because I can verify this against Wolfram Alpha.  But it sounds like a bad idea from the other post.    If that is ever successful,  I was going to start thinking about how to say produce a plug-in like architecture that takes advantage of me coding towards an interface using RTTI.  It then would allow me to instantiate variations of Matrix implementations, pass that into the object using it and still produce the same result.  If that is also successful, then I can say ooo this is what they mean by coding towards an interface, and I can say yup, I totally get how badass it can be.  But if the solution is to accomplish this via generic programming or typedefs or using, then I guess that's the C++ way of doing things.  That's fine too.  I just want to know.  Thanks!"
cpp,3b5nof,pipsqueaker117,30,Fri Jun 26 04:17:59 2015 UTC,"the compiler gave me errors when I tried to implement in in a .cpp   (ignoring some complicated details) Templates need to be implemented in headers. That's because class templates and function templates aren't classes and functions - they simply have the ability to stamp out classes and functions. (The usual way I explain this is, cookie cutters aren't cookies. Cookie cutters are made of metal and you don't want to eat them.) You can't declare a template in a header and define it in a source file stuff.cpp, because if another source file other.cpp includes that header and instantiates the template for OtherType, the compiler needs the template's definition in order to generate a class or function that uses OtherType.  (The obvious exception to ""templates go in headers"" is if you define a template in a source file, and then use it only in that source file. That's fine.)   #include ""vector""   Should be <vector>. Use angle brackets for installed headers (and Standard headers are the best example), use double quotes for your own headers.   class common {   Why do you have a class whose only purpose in life is to have static member function templates? This isn't Java. Non-member function templates are perfectly fine. (And if you want a namespace, use that.)   template<typename V> static bool are_equal(int size, V v1[], V v2[]) {   First, never declare functions as taking arrays by value. (There are few absolute guidelines in C++, but this one is a never-ever.) Doesn't matter if they're unknown bounds like you have here, or known bounds like V arr[3]. When the language/compiler sees an array passed by value, it immediately ignores what you wrote, and rewrites it to a pointer. This rule goes all the way back to C. You don't get any sort of bounds checking, and you can even pass pointers to individual objects to such a function. If you want to write a function taking pointers, declare it as taking pointers. Never arrays.  In general (and now this is just a recommendation, not ironclad) modern code should use STL containers like vector and std::array, not builtin arrays, which so readily decay to raw pointers.  If you use STL containers, you can compare them directly for equality with ==.  Second, if you aren't using STL containers (or you have containers of different types), <algorithm> contains equal(). In C++14 it has a good signature, equal(first1, last1, first2, last2). Use this instead of writing your own. (In C++98 through 11, it has a dangerous signature equal(first1, last1, first2), where you're expected to check the lengths first.)   static void push_iterable(const int length, V start[], std::vector<V>* vector) {   Good work passing length by const value. However, you generally shouldn't use a raw pointer when a reference will do. Here, you're assuming the pointer is non-null, so you should just take a reference.   for (int s = 0; s < length; s++) {   Conventionally, C++ uses preincrement except when postincrement is necessary. There are minor and mostly historical efficiency considerations (that apply to iterators of class type), but mostly it's for code clarity. Preincrement is the simpler one, so if you use it by default, you make the more complicated postincrements stand out due to being rare.  Instead of a push_back loop, you can use a much more efficient range-insertion call. This looks like: v.insert(v.end(), first, last) where first and last are a range of stuff to insert. It's more efficient because the vector can do a capacity check and potential reallocation exactly once.  To get a pointer to a vector's contiguous data, use v.data() in C++11.  But if you're starting with a vector, it's pointlessly bad to drop down to the level of raw pointers, when you're going to keep working with them in your own code. You should stay at the higher level of iterators, unless you need to work with C APIs that expect pointers to contiguous data.  delete vertex_source; indicates that you've got owning raw pointers. These are extremely bad and should be avoided like the plague until you're an expert (then they should be avoided like the common cold). Avoid dynamic memory allocations if you can, use unique_ptr/shared_ptr if you must. In this case, your optimized_verts should just be a local variable vector. Learning this is one of the most important things as a beginner - screwing it up is why people grow to hate C++, which is so sad, because it's such a very nice language.  For example, you are leaking your optimized_verts. Using modern C++ properly, your program would be structurally immune to memory leaks. You're already so close, since you're getting vector to handle your element allocations.   unique_vertices += 1;   Preincrement was invented for a reason. Use it. (Again, this makes the more complicated += 2 and whatevers stand out.)   common::GenOptimizedArrays<GLfloat, GLint>(2, &source, optimized_verts, &ebo);   You shouldn't use explicit template arguments unless absolutely necessary. Let the compiler deduce them. The compiler is your friend.  return 0; is unnecessary at the end of main() in C++ (it's a special rule, added implicitly even though main() must return int).  I believe your algorithm could be simplified (it looks like you'd want an indirect sort-and-unique), but I'd have to think hard about that."
cpp,3b5nof,STL,5,Fri Jun 26 05:09:43 2015 UTC,"Conventionally, C++ uses preincrement   ...I agree, but I just have to point out the irony here."
cpp,3b5nof,minno,1 point,Fri Jun 26 13:19:45 2015 UTC,"I know this isn't exactly helpful but you can define templates in headers followed by a forward declaration of the specialisations and then define the specialisations in the source files. For me that resulted in a far messier code setup, having to guess the types in advance which essentially defeats the purpose of templates so I just stuck to defining the entire template in the header file when I came to this problem myself. Agree with everything else 100% though."
cpp,3b5nof,Xirious,1 point,Fri Jun 26 06:05:40 2015 UTC,"Thank you for taking so much time to answer! I updated the source, which you might want to take a look at- this is a lot to take in at once, and I might not have implemented some of your advice  I appreciate the advice and, as you probably shouldn't be surprised to hear.   Why shouldn't I pass ""arrays"" to my functions? From what I've read a c-style array is just a pointer to its first element, which is what I want here- isn't it better to make it clear that I expect some sort of contiguous list of values by declaring my argument as an array rather than a pointer, with the same effect? You say that I'm passing length as a const pointer. However, doesn't using const int length just pass in a plain old integer? Why would I need to use a reference there? My confusion on this is exacerbated by the fact that I don't really know why you would ever use a reference over a pointer or vice versa, they seem like two ways to achieve the same thing. What's the difference between an ""owning raw pointer"" and a plain old pointer? Why can I use (raw?) pointers elsewhere in my program, yet as soon as I try to delete it it becomes a ""bad"" kind of pointer? You say I'm leaking optimized_verts, but all I can see that I did was initialize it as a vector and append elements to it. What do you mean?   Also, do you know of any good modern c++ tutorials? I used the cplusplus tutorials just to teach myself the syntax, but from what I see here I get the impression that those teach me stuff I shouldn't be doing (concerning pointers and arrays, anyways)"
cpp,3b5nof,STL,5,Fri Jun 26 21:21:34 2015 UTC,"If you want to pass an array as an array, declare your function as taking a reference to an array, which looks like int (& arr)[3] (in English: arr is a reference to an array of 3 ints). If you want to pass an array as a pointer (triggering decay), declare your function as taking a pointer, which looks like int * ptr.  What I'm saying is, never declare a function as taking an array by value, because if you take int meow[3] or int meow[], the compiler immediately rewrites that to int * meow, which is unnecessarily surprising.   From what I've read a c-style array is just a pointer to its first element   You have been misinformed (this is a common point of confusion). Arrays and pointers are different things, but arrays can be easily converted to pointers (to their first elements); this process is known as decay.   You say that I'm passing length as a const pointer.   No, I said ""Good work passing length by const value.""  Taking const int length is good, because it prevents you from accidentally modifying length within the function.  Taking int length makes no difference to whoever's calling your function, but within the function, length can be modified, which is usually undesirable.   What's the difference between an ""owning raw pointer"" and a plain old pointer?   A raw pointer is owning if you have to say delete ptr, delete[] ptr, free(ptr), or something like that eventually. It's non-owning if the lifetime of what you're pointing to is controlled by somebody else.   You say I'm leaking optimized_verts, but all I can see that I did was initialize it as a vector and append elements to it. What do you mean?   As a silly analogy, imagine that whenever you say new Something(args), you're borrowing money from the mob. When you say delete ptr, you're returning the money. With the mob, if you forget to return the money, they break your kneecaps. In C++, if you forget to delete allocated objects, you leak memory (i.e. permanently wasted, until the process terminates). Good lessons to learn from this are: don't borrow money from the mob unless you really have to, and then be really careful with it. In C++ that means avoid dynamically allocating memory (new/delete) unless you really have to, and then be really careful with it (i.e. get vector, shared_ptr, unique_ptr, etc. to manage it for you).  The leak happens because main() says std::vector<GLfloat> * optimized_verts = new std::vector<GLfloat>(); and never deletes it, or calls anything that deletes it. The only delete in your original code was if (cleanup) { delete vertex_source;}, but (1) cleanup defaults to false and you weren't passing true, and (2) that's deleting vertex_source, but you were passing optimized_verts as vertex_out.  I'm afraid I'm not familiar with good beginner resources (I learned in the 2002-2004 era, in a really strange way). I hear C++ Primer, Fifth Edition (not C++ Primer Plus) is good, and I have a copy on my bookshelf, but I haven't read it. I've thought about writing my own, but it would be so time-consuming and I already have a day job."
cpp,3b5nof,STL,1 point,Sat Jun 27 02:05:37 2015 UTC,"So if I had declared optimized_verts as std::vector<GLfloat> * optimized_verts; the pointer would be deleted when it went out of scope, and the vector's memory freed?  Also, don't all non-owning pointers have to become owning at some level of the program? If C++ doesn't have a garbage collector, then memory has to be managed explicitly by the coder eventually, right?"
cpp,3b5nof,vlovich,5,Sat Jun 27 02:19:17 2015 UTC,"So if I had declared optimized_verts as std::vector<GLfloat> * optimized_verts; the pointer would be deleted when it went out of scope, and the vector's memory freed?   There's a couple points of confusion here. First, local variables are destroyed when they go out of scope, but destroying a raw pointer doesn't delete what it points to (if anything). Second, if you have an uninitialized raw pointer as a local variable, it contains a garbage address (not guaranteed null), and it definitely doesn't point to a vector.   Also, don't all non-owning pointers have to become owning at some level of the program?   No. Consider:  int x = 1729; int * p = &x; // p is a non-owning raw pointer    If C++ doesn't have a garbage collector, then memory has to be managed explicitly by the coder eventually, right?   In modern C++, memory and other resources are managed automatically, with as little manual involvement as possible. This is what makes garbage collection unnecessary (and indeed harmful). For example, if you have a vector<int> v = { 11, 22, 33 }; then v owns dynamically allocated memory. When v is destroyed, the memory it points to is destroyed - automatically."
cpp,3b5nof,STL,6,Sat Jun 27 02:36:03 2015 UTC,"In C++11, &((*vertex_source)[0]) is vertex_source->data() (or vertex_source.data() if you pass it by const& as I recommend below)  Prefer namespaces over classes that contain only member functions: much more elegant way of expressing free functions.  Take vertex_source by const& in GenOptimizedArrays.  It's a good idea to not modify things that are input parameters.  That also hints that the if (cleanup) { delete vertex_source; } is an anti-pattern; you're overloading GenOptimizedArrays with too much responsibility.  Leave the memory ownership to someone else.  To bring the point home that memory ownership should be relegated to using smart pointers, note that you are allocating optimized_verts on the heap but freeing source - unclear if this is intended.  std::vector will already allocate things on the heap for you so prefer to pass it around by-value (or moving it where needed).  There are cases where you might still want the heap (i.e. to share ownership of a single large instance) but err on the side of not doing that.  Typically return types are better suited as proper return values instead of output parameters.  If GenOptimizedArrays is intended to be used in a tight-loop & you intended to optimize it by re-using the output vector over & over again, that's fine.  If you are unsure, then err on the side of using proper return types & optimize later.  Use built-in algorithms instead of writing your own (e.g. std::equal()).  Use C++ type-safe collections or iterators instead of C-arrays.  Use size_t instead of int when referring to sizes of collections (or that will be compared against such things).  The C++ STL uses size_t throughout so no matter how much people would like to use int, you're going to have a large impedance mismatch.  You should also turn on -Wall -Werror so that the compiler will tell you when you make things considered to be mistakes but are technically allowed in the language (don't know the flags for Visual Studio if that's what you're using).  Make GenOptimizedArrays more generic.  Instead of hard-coding the usage of a vector, use iterators instead.  This will also put you in a good spot to clean-up the code with C++17 concepts & Ranges when they become available:  template <typename RandomAccessInputIterator, typename VertexOutputIterator, EdgeOutputIterator> void GenOptimizedArrays(size_t vertex_size, RandomAccessInputIterator vertex_source_begin, RandomAccessInputIterator vertex_source_end, VertexOutputIterator vertexOutput, EdgeOutputIterator edgeOutput) {     bool vertex_is_unique = true;      std::copy(vertex_source_begin, vertex_source_begin + vertex_size, vertexOutput);      size_t edgeOutputSize = 0;     auto addEdgeOutput = [&edgeOutputSize, &edgeOutput](auto value) {         *edgeOutput = value;         ++ edgeOutputSize;         ++edgeOutput;     };      addEdgeOutput(0);      auto  num_vertex_source_elements = vertex_source_end - vertex_source_begin;      size_t unique_vertices = 1;      for (size_t source_vertex = 1; source_vertex < num_vertex_source_elements / vertex_size; source_vertex++) {         for (size_t element_vertex = 0; element_vertex < edgeOutputSize; element_vertex++) {             auto vertex_source_comparison_begin = vertex_source_begin + source_vertex * vertex_size;             auto element_source_comparison_begin = vertex_source_begin + element_vertex * vertex_size              if (element_vertex == source_vertex) {                 continue;             }              if (!std::equal(vertex_source_comparison_begin, vertex_source_comparison_begin + vertex_size, element_source_comparison_begin)) {                 continue;             }               addEdgeOutput(element_vertex);              vertex_is_unique = false;              break;         }          if (vertex_is_unique) {             std::copy(vertex_source_begin, vertex_source_begin + vertex_size, vertexOutput);             addEdgeOutput(unique_vertices);             unique_vertices += 1;         } else { vertex_is_unique = true; }     } }   Caveat: I did this refactoring by-hand so there can be bugs.  Note the usage of std::copy & std::equal.  Note that nowhere I std::vector hard-coded so this algorithm will also work with std::array or any other random-access iterator.  Additionally, for the output you might use a vector, or an array or even a list."
cpp,3b5nof,vlovich,7,Fri Jun 26 08:32:44 2015 UTC,"For beginners, I wouldn't recommend going all the way to writing generic iterator-based algorithms. That level of abstraction is difficult and unnecessary early on. Working with vector iterators of a concrete type is plenty. This is a judgement call, though."
cpp,3b5nof,vlovich,2,Fri Jun 26 08:45:52 2015 UTC,That's a good point.  Sticking to std::vector will probably be more helpful but it's good to demonstrate what an iterator-based algorithm looks because it makes it harder to get confused about pointers & memory ownership.
cpp,3b5nof,mark_99,2,Fri Jun 26 08:56:09 2015 UTC,"Hi! Thanks for your reply! I have a question or two for you.    What's the big deal with const references over (const) pointers? I've seen the ""use const references for inputs"" before, but I don't really understand why you would do this as opposed to just using a const pointer Why would I pass a vector / list of things around by value? I thought that involved a lot of unnecessary overhead.   Your iterator code looks a bit scary, so I didn't implement it in my updated version. I'll definitely take a look and try to understand it though.   Thanks for taking the time to respond!"
cpp,3b5nof,zvrba,3,Fri Jun 26 21:31:35 2015 UTC,"const ref makes it clear that it's not optional. I recommend you look into move semantics & NVRO/UNVRO optimizations.  Returning from functions is usually better than output parameters; output parameteres have 1 performance corner-case that is usually not a concern when it's a learning exercise.   Sure.  Iterators are just much more elegant to work with since it doesn't matter what your source data is; could be a std::vector, std::array, std::initializer_list, std::experimental::array_view etc.  Templates of course are trickier to work with so there's a tradeoff."
cpp,3b5nof,RedAlert2,4,Fri Jun 26 21:47:15 2015 UTC,"if (v1[i] != v2[i]) return false;   Typically (in any language) you never want to compare floating point types directly like this - small inaccuracies will make it unreliable. You need to use some sort of comparison tolerance, the exact form of which depends on whether the values are all in the same approximate range or not. See e.g. http://stackoverflow.com/questions/17404513/floating-point-equality-and-tolerances  There are some exceptions to this, like if you can be 100% sure that any duplicates are exact copies, but in general don't do it. Write an inline function which calls fabs() etc. and use that instead. In your toy example it's fine, but in the real world your verts may have come from an external tool, and/or have been through transform(s) etc.  BTW once you change the vector to a reference instead of a pointer I think &vertex[0] is perfectly fine, indeed arguably it's clearer than data().  Also the whole signed vs unsigned thing is debatable. Personally I prefer signed types as you can do this: assert(length >= 0);.  That way if you have a bug which miscalculates length you'll catch it more easily than if it's unsigned and wraps around (do litter your code with asserts for anything you think should be true at any given point, particularly if it has dependencies outside the local function). Another common bug using unsigned is if you write a loop going backwards from length to 0 (although legitimate compiler warnings might save you here).  That STL uses unsigned size_t is an unfortunate design decision IMHO, but sometimes in C++ what seemed like a good idea 20-30 years ago sticks; however there are other ways to silence any spurious warnings if you choose to continue using signed types."
cpp,3b5nof,zvrba,1 point,Fri Jun 26 10:28:32 2015 UTC,"but sometimes in C++ what seemed like a good idea 20-30 years ago sticks;   Personally I can't fathom how could it ever look like a good idea given that usual arithmetic rules break down and that unsigned has higher rank than signed for the purpose of implicit conversions (for example, x < y <=> x-1 < y-1 breaks down in unsigned arithmetic in the singular case of x being zero.. a nasty source of bugs).  Do you have some historical account of why STL uses unsigned size type?"
cpp,3b5nof,mark_99,1 point,Fri Jun 26 16:55:05 2015 UTC,The STL probably uses unsigned integers for sizes because it allows for twice as many usable values. Perhaps not as much as a selling point now that 64-bit machines are ubiquitous.
cpp,3b5nof,OmegaNaughtEquals1,1 point,Fri Jun 26 23:21:05 2015 UTC,"It was a selling point only in the 16-bit era, though I don't think STL is that old.  For the difference between 31 and 32 bits for counting is relevant only if you're regularly dealing with vectors of chars -- with any other element type you'll be out of virtual memory space long before you reach the count of 2**31."
cpp,3b5nof,OmegaNaughtEquals1,1 point,Sat Jun 27 05:34:49 2015 UTC,"I don't have a historical reference but if I had to speculate it might be that 16-bit architectures were still considered mainstream, and the difference between a max size of 32KB and 64KB seemed significant (whereas now if you're anywhere near 2-4GB you should probably be using 64-bit ints anyway)."
cpp,3b5nof,Symaxion,3,Thu Jul 9 14:20:39 2015 UTC,"template<typename V, typename E> static void GenOptimizedArrays(const int vertex_size, std::vector<V>* vertex_source, std::vector<V>* vertex_out, std::vector<E>* ebo_out, bool cleanup = false)   C++ has come a long way in the last few years. C++11 really changed the way programmers think about the language and how we write code. Many advances in the language help us to write more fluid, almost prosaic code now. In my mind, the single facility in C++11 that helps us do that most is move semantics. In C++98 if you wanted to return two1 vectors from a function like you are doing here, you had no choice but to pass them in as in/out parameters (either via non-const references or by pointers like you are doing). In C++11 we have move semantics, so let's use those.   template<typename V, typename E> std::pair<std::vector<V>, std::vector<E>> GenOptimizedArrays(const int vertex_size, std::vector<V>* vertex_source, bool cleanup = false) {     std::vector<V> vertex_out;     std::vector<E> ebo_out;     /* Do stuff */     return std::make_pair(std::move(vertex_out), std::move(ebo_out)); }   Much better! Since we are refactoring, let's get rid of that ugly cleanup business. I want you to repeat after me ""I will not use owning raw pointers in my code."" Now say it 1000 times and give three hail Bjarnes. :p  template<typename V, typename E> std::pair<std::vector<V>, std::vector<E>> GenOptimizedArrays(const int vertex_size, const std::vector<V>& vertex_source)   The only thing that is ugly now is the return type. If we move to C++14, we can write  template<typename V, typename E> auto GenOptimizedArrays(const int vertex_size, const std::vector<V>& vertex_source)   Not even Robert Frost could write such elegant prose. Speaking of the return type, let's look at the code in main now. Normally when you are dealing with a std::pair, you access its members using p.first and p.second. That's ugly and doesn't allow for more of our beautiful prose. Fortunately, C++11 introduced std::tie.  int main() {         std::vector<GLfloat> source = { 1, 2, 3, 4, 5, 6, 5, 6, 1, 2, 7, 8 };     std::vector<GLfloat> optimized_verts;     std::vector<GLint> ebo;      std::tie(optimized_verts, ebo) = GenOptimizedArrays<GLfloat, GLint>(2, source);      for (auto &v : optimized_verts) {         std::cout << v << "" "";     }     std::cout << ""\n"";     for (auto &v : ebo) {         std::cout << v << ' ';     } }   There are several things to notice here:   I got rid of the heap allocation of optimized_verts Because we are no longer passing in the ""return"" vectors, we have to specify the template parameters for the function. You don't get template type deduction anymore, so we have to disregard /u/STL's advice about leaving off the template arguments. I think it's a small price to pay for a much cleaner function interface. I converted your for loops to range-based for loops. I strongly recommend using them.   I have heard tell that C++17 might be getting a feature where we can declare objects inside of std::tie so that we could write  int main() {         std::vector<GLfloat> source = { 1, 2, 3, 4, 5, 6, 5, 6, 1, 2, 7, 8 };     std::tie(auto optimized_verts, auto ebo) = GenOptimizedArrays<GLfloat, GLint>(2, source);     /* stuff */ }   Super cool!  [1] Returning one vector could be done with NRVO and you should still use that in C++11."
cpp,3b5nof,5fc,2,Fri Jun 26 09:54:29 2015 UTC,"Thank you! I didnt end up implementing your std::pair suggestion, since in working w/ OpenGL I'm using a bunch of old-style functions which work by the output-pointer method, and I thought it would be best to keep it consistent. However this is a pretty beautiful feature that I didn't know about before, and I'll definitely try to use it in other C++ projects!  One question- why did you get rid of my declaring optimized_verts as new std::vector<GLfloat>()? I actually didn't think there was a difference in the two declarations.  EDIT: I just tried adding -Wall -Wextra to my compiler options and it looks like my IDE (CLion) just prints out the warnings for a split second and then moves to another view with no option to reset to the warning output. Is there a way I can make the -Wall -Wextra generate legitimate errors so that I can read the messages?"
cpp,3b8o8i,vreid,6,Fri Jun 26 21:33:49 2015 UTC,"For vim:   vim-plug is a nice plugin manager: it has on demand plugin loading (based on filetype) and parallel updates/installs As you mentioned, YouCompleteMe is really good. It takes some time to set up (separately for each of your projects), but the clang-based autocomplete is really nice ctrlp is very nice for quick in-project navigation vim-easytags for auto-generating tags and ctags based syntax highlighting syntastic for on-the-fly syntax checking vim-fugitive for git   As an alternative, I really like QtCreator. Good syntax highlighting, clang based autocomplete and (on Linux) valgrind integration. It also has good CMake integration."
cpp,3b8o8i,Gustorn,2,Fri Jun 26 22:08:27 2015 UTC,Qt Creator is the only C++ IDE I use these days. Pretty hard to beat tbh...
cpp,3b8o8i,antiprosynthesis,2,Sat Jun 27 03:34:15 2015 UTC,"It uses (or can) a dual mode indexer where it uses clang for auto completion and syntax analysis, but a built in thing for go to definition, finding classes etc. The built in parser is very fast to parse, but is terribly inaccurate. I investigated Qt Creator for a while but returned to Eclipse when I saw how unreliable go to definition and code navigation generally were (I also missed some features like call graphs)."
cpp,3b8o8i,quicknir,1 point,Sat Jun 27 22:53:49 2015 UTC,"I can't handle CLion's responsiveness (or lack thereof) after using either QtCreator or vim. But you're right, basing an IDE or editor on the LLVM tools would be really nice."
cpp,3b8o8i,Gustorn,1 point,Sat Jun 27 15:34:10 2015 UTC,As a starting point this could be used
cpp,3b8o8i,ji23oh,1 point,Sun Jun 28 19:16:41 2015 UTC,Thanks! Will try those and report back😊
cpp,3b8o8i,givemesomelovee,1 point,Tue Jun 30 09:35:49 2015 UTC,You don't need syntastic with YCM. and you can add ultisnips and tagbar to your list.
cpp,3b8o8i,F-J-W,5,Fri Jun 26 22:17:04 2015 UTC,"I've been spending the last days (among other things) with redoing my vim-config basically from scratch. You can find it here: https://github.com/Florianjw/vimrc (if you use the install.sh, backup everything you want to preserve before and delete the old .vim and .vimrc)  (C++-relevant) plugins are:   YouCompleteMe (note that this makes syntastic redundant) Gundo fugitive fugitive-blame airline taglist   One huge advantage that vim has over almost every other text-editor is that it permits a very unique workflow: open two or three terminals navigate to the project in question and open the files you want to edit; whenever you feel the need for it, close vim, do, whatever it is that you want to do on the console directly, and reopen it. Since it starts very fast this works great. (May not be for everyone but I am very happy with that approach.)"
cpp,3b8o8i,Zakkor,4,Sat Jun 27 00:34:27 2015 UTC,What did you dislike about Clion?
cpp,3b8o8i,no1msd,1 point,Sat Jun 27 00:10:50 2015 UTC,See my other comment:)
cpp,3b8o8i,quicknir,3,Sat Jun 27 00:29:53 2015 UTC,"If you want to use CMake anyway, what's wrong with CLion?"
cpp,3b8o8i,finalpatch,1 point,Sun Jun 28 20:29:37 2015 UTC,The price tag. I'm looking into alternatives for personal projects; but those are silly and not open-source so I don't want to invest money into an IDE (for now).
cpp,3b8o8i,AnAirMagic,1 point,Sat Jun 27 08:20:00 2015 UTC,"IMHO it's a bit shameful that they're already charging for CLion, when it's quite clearly inferior to more than one existing IDE that are free.  Now pycharm, I would gladly pay for if there weren't a community edition."
cpp,3b8o8i,Xirious,3,Sun Jun 28 20:28:36 2015 UTC,Magit
cpp,3b8o8i,pepper_chico,2,Sun Jun 28 20:48:13 2015 UTC,"C/C++ Development Environment for Emacs is a pretty long and thorough guide. It may or may not cover everything you need, though."
cpp,3b8o8i,aport,1 point,Sat Jun 27 00:17:57 2015 UTC,"Will take a look, thank you!"
cpp,3b8o8i,quicknir,2,Sat Jun 27 00:03:30 2015 UTC,I love Sublime but I cannot for shit get codetags / code completion / function suggestions / parameter suggestions to work. I would love it if this thread could share some light on how someone else got it right.
cpp,3b8o8i,quicknir,1 point,Sat Jun 27 09:52:55 2015 UTC,I have an YCM fork specially targetted for C++: https://github.com/oblitum/YouCompleteMe  My dotfiles: https://github.com/oblitum/dotfiles
cpp,3b2glr,nico159,16,Thu Jun 25 12:54:28 2015 UTC,"nstead of bumping the library soname (I still do not understand why that was not done…), the GCC developers decided to have a dual ABI   Can someone explain why GCC made this decision?"
cpp,3b2glr,pfp-disciple,19,Thu Jun 25 18:42:06 2015 UTC,"Probably because different libraries with common symbols can't be loaded at the same time. So if a gcc-5 program uses a gcc-4 library, it would be impossible to start it. Source: Comment on the blog page."
cpp,3b2glr,Vogtinator,13,Thu Jun 25 18:51:49 2015 UTC,"The last time G++ went through an ABI change, back in the 3.x period, we changed the soname of libstdc++, which was widely regarded as a mistake. Changing the soname caused a lot of pain but is not sufficient to deal with changes in symbol ABIs: if you load multiple shared objects that depend on different versions of the library, you can still get clashes between different versions of the same symbol.  So the plan for this ABI change has been to leave the soname (and the existing binary interface) alone, and express the new ABI using different mangled names.   source"
cpp,3b2glr,p2rkw,1 point,Thu Jun 25 23:11:41 2015 UTC,Thanks for the clear response. I consider myself more educated now.
cpp,3b2glr,pfp-disciple,5,Fri Jun 26 12:53:10 2015 UTC,"Versioning symbols is more granular than versioning whole libraries, and it has been used for some time for the C library.  It works reasonably well, and some people consider it the least bad of the alternatives, while everybody agrees that no option is perfect."
cpp,3b2glr,wrosecrans,3,Thu Jun 25 19:34:56 2015 UTC,"I don't know the reasons for which they made that decision.  I know that bumping the soname is problematic for central things like a standard library, they usually prefer to use the symbol versioning provided by the linker. In practice that leads to fewer problems than bumping soname, at least when done correctly.  That is also done by libc for instance.  One of the thing achievable with symbol versioning (I don't know if it was a GCC library team goal) is to allow interoperability within a program using several version at once, as long as the communication between the components is restricted to common types.  That is useful for instance with plugins where the plugin interface is well controlled."
cpp,3b2glr,JMBourguet,4,Thu Jun 25 18:59:41 2015 UTC,Supporting the C++11 standard required incompatible changes to libstdc++ ABI.   Is there a short explanation of why this is the case?
cpp,3b2glr,ggchappell,23,Thu Jun 25 18:21:24 2015 UTC,"libstdc++ used copy-on-write std::string, which is no longer permitted in C++11."
cpp,3b2glr,Plorkyeran,11,Thu Jun 25 18:30:07 2015 UTC,"In addition to that, libstdc++ uses a std::list without an size field embedded, making std::list::size() an O(n) operation."
cpp,3b2glr,Tulip-Stefan,0,Thu Jun 25 21:05:23 2015 UTC,What? I always thought I could trust things like this from the STL. I guess that's why people don't like using the STL in performance critical code.
cpp,3b2glr,nat1192,8,Fri Jun 26 00:49:59 2015 UTC,http://en.cppreference.com/w/cpp/container/list/size  You can see here it was allowed to constant or linear until C++11.
cpp,3b2glr,frutiger,7,Fri Jun 26 01:02:42 2015 UTC,Scott Meyers covers this in item 4 of Effective STL. There was a choice between making size() constant-time or splice() constant-time with the other operation then being linear. Some implementers thought one operation or the other more important so implemented their preferred one as constant-time.
cpp,3b2glr,nyamatongwe,3,Fri Jun 26 07:47:41 2015 UTC,"I guess that's why people don't like using the STL in performance critical code.   Actually, this decision of C++11 to have size be O(1) is seen by many as a mistake in the case of std::list, because there's a trade-off:   O(1) size and O(N) splice   OR   O(N) size and O(1) splice   libstdc++ had picked the second alternative at a time where either was good, reasoning that the only good reason to use std::list was to have O(1) splice; the C++ committee decided to go the other way to be more newcomer friendly (too many people use std::list where other containers would be more appropriate).  Personally, I preferred the former behavior..."
cpp,3b2glr,matthieum,8,Fri Jun 26 17:20:05 2015 UTC,This always makes me laugh. I've used STL in tons of performance critical code; which usually means vector + algorithms.
cpp,3b2glr,cdglove,7,Fri Jun 26 02:27:04 2015 UTC,We wouldn't be using list in performance critical code.
cpp,3b2glr,adzm,6,Fri Jun 26 01:05:11 2015 UTC,"STL implementations vary quite widely in terms of performance, and sometimes in semantics as well... so yes it's a reason why people roll out their own implementation or use boost."
cpp,3b2glr,sakarri,5,Fri Jun 26 00:56:12 2015 UTC,"Nonsense, performance critical code uses no std::list at all.  Also, chances are that the code who does, can do it because size() inefficiency makes no difference whatsoever (he who didn't profile, has no idea what is slow)."
cpp,3b2glr,Gotebe,1 point,Fri Jun 26 04:56:10 2015 UTC,"In most languages I know the default list types are generally backed by an array, which in c++ is the std::vector . std::list is a linked list and is generally used for other properties than its laughable performance (among others pointers into it stay valid unless the item pointed to is deleted )."
cpp,3b2glr,josefx,10,Fri Jun 26 17:56:20 2015 UTC,"Some (most?) of the ABI breaking changes in C++11:   basic_string is completely different (as mentioned below), it's now a glorified vector with short string optimization. This snowballed a bunch of other changes across the library Changes to list::size() requirements (as mentioned below) ios_base::failure now derives from system_error (which in turn is a new exception type) map/set::erase() now returns an iterator real() and imag() defined for complex"
cpp,3b2glr,otidder,1 point,Fri Jun 26 00:33:38 2015 UTC,Are moveable streams considered an ABI change (I'm thinking yes)? What about the proposed change in C++17 to the iterators no longer inheriting from std::iterator? Will we be back here for another ABI breaking change in GCC 6?
cpp,3b2glr,OmegaNaughtEquals1,1 point,Fri Jun 26 16:26:44 2015 UTC,"Are moveable streams considered an ABI change (I'm thinking yes)?   No. Adding entirely new functions to an existing class is not a breaking change.   What about the proposed change in C++17 to the iterators no longer inheriting from std::iterator   No, std::iterator doesn't even exist in the compiled product, so it doesn't have any sort of ABI impact."
cpp,3b2glr,Plorkyeran,4,Fri Jun 26 19:47:06 2015 UTC,Are gcc versions bumped more quickly these days? GCC 5 is just out and they've already got plans for GCC 6?
cpp,3b2glr,dreugeworst,2,Fri Jun 26 10:54:07 2015 UTC,"Yes, they are trying to be as cool as Chrome now and increase the major version with every release."
cpp,3b2glr,voltaic_spear,1 point,Fri Jun 26 15:32:03 2015 UTC,"They concluded that the first number was entirely pointless since they didn't plan on ever incrementing it under the old versioning scheme, so they shifted everything over by one."
cpp,3b2glr,Plorkyeran,1 point,Fri Jun 26 19:49:11 2015 UTC,does anyone know how did LLVM handled this change? or they didn't have this ABI problem (why?) ?
cpp,3b2glr,afjw0ge9h,2,Fri Jun 26 13:26:03 2015 UTC,"C++11 was mostly done when libc++ was created, so it just did things the C++11-compatible way to begin with."
cpp,3b2glr,Plorkyeran,1 point,Fri Jun 26 19:50:21 2015 UTC,"This post shows the reasoning used by GCC guys (or rather, their clients).  IMNSHO, they are wrong.  Neither C nor C++ languages deal with an ABI. C easily has a de facto ABI for a given platform, but that is because C is dead simple. But for C++, this is much harder (name mangling, inlining, exceptions, templates, standard changes in this case...).  I do not understand why gcc people bother trying to have an ABI, nor why clang people try to follow.  Microsoft does it better: no ABI between compiler versions. Even an upgrade can break it (ok, I don't remember that happened since VC6 TBH).  This seems so much saner to me.  But then, Windows has had a really good cross-language ABI for a really long time, which might have played a part in forgetting one particular language. :-)"
cpp,3b2glr,Gotebe,2,Fri Jun 26 18:18:37 2015 UTC,"I do not understand why gcc people bother trying to have an ABI, nor why clang people try to follow.   There's no less reason to have a C++ ABI than a C ABI.  IMO it's Microsoft that's been mistaken in not supporting a consistent C++ language ABI. That decision caused a lot of pain for a lot of their developers. They're now partially addressing that with their ""Universal CRT"", which moves the C and C++ libraries over to being part of the OS. This is now more similar to the way OS X and most Linux distributions work."
cpp,3b2glr,bames53,1 point,Fri Jun 26 20:15:28 2015 UTC,"name mangling, inlining, exceptions, templates, standard changes in this case...   There's no less reason to have a C++ ABI than a C ABI.   How about the above?  There are reasons why diversity is good.   ""Universal CRT"", which moves the C and C++ libraries over to being part of the OS   I think you need to be able to see past the marketing. This makes the CRT version shipped with VS part of the OS. Msvcrt.dll, the C runtime, has been part of the system since forever. Interestingly (or perhaps not), that's the version mingw uses. Universal CRT will merely dispose off the need to deploy VC merge modules (or the redistributable), uh oh big deal. The deal with the Universal CRT is more a clean(er) slate than anything else IMO.  The pain Microsoft developers endured in the past was caused by incompetence morethan anything else. It is only noobs who do not understand how stuff is deployed. Well, tough for them.  For those who know, many (all) version-related questions are a done deal. Having an ABI is by no means a better solution (as we see here) Having a ""system"" version of the runtime is a poor idea, because... why C and C++, and not all other languages?! Neither C nor C++ are special."
cpp,3b2glr,Gotebe,-7,Sat Jun 27 06:46:44 2015 UTC,Seems like a stupid feud.
cpp,3b2glr,xcbsmith,9,Thu Jun 25 17:09:19 2015 UTC,"It doesn't look like a feud to me.  Looking at here, I don't see anyone refusing to do this or that because screw those guys, or anything along those lines.  It sounds more like the gcc folks were just inconsiderate, or maybe just did something dumb without realizing the consequences. (Humans are prone to doing that, after all.)"
cpp,3b2glr,looneysquash,2,Thu Jun 25 17:33:28 2015 UTC,"Looking at here, I don't see anyone refusing to do this or that because screw those guys, or anything along those lines.   That's the LLVM bug list, where they are talking about working around it.  As was pointed out, this was posted on the GCC mailing list, and the problem received, at best, a mild level of response."
cpp,3b2glr,xcbsmith,2,Fri Jun 26 08:29:23 2015 UTC,"Where do you see a feud? People in the relevant bugreports seem to be totally civil. Arch is an early adopter distro, so I'm sure it'll all be ironed out until it hits mainstream distros."
cpp,3b2glr,jringstad,5,Thu Jun 25 17:36:18 2015 UTC,"This is a simple oversight, not a feud."
cpp,3b2glr,xcbsmith,1 point,Thu Jun 25 18:02:00 2015 UTC,Oversights happen when people don't point something out to you.
cpp,3b2glr,o11c,-16,Fri Jun 26 08:29:37 2015 UTC,That is a perfect description of the entirety of the LLVM project.
cpp,3b2glr,hotoatmeal,1 point,Thu Jun 25 17:56:52 2015 UTC,Sauce?
cpp,3b2glr,o11c,-2,Fri Jun 26 01:35:14 2015 UTC,"Sauce: have spent a lot of time working with GCC and LLVM teams.  GCC team is generally a lot nicer and more likely to fix bugs, but they are still overcoming some of the political baggage of old times.  LLVM team has Apple marketing behind them."
cpp,3b2glr,hotoatmeal,-2,Fri Jun 26 02:21:53 2015 UTC,Appeal to authority.
cpp,3b2glr,spinwizard69,-6,Fri Jun 26 02:30:18 2015 UTC,smells of a screw up actually.   I wonder how clang addresses this.
cpp,3b2glr,sakarri,8,Fri Jun 26 01:23:14 2015 UTC,"What do you think is the screw up?  It's pretty interesting hearing people make absolutely bold claims about how this must be some kind of error, or how they obviously know better than the GCC team, without actually going into any detail whatsoever.  It's almost as if ignorance makes people more assertive."
cpp,3b4qx7,klaxion,14,Thu Jun 25 23:25:40 2015 UTC,"From the official tutorial:  root()->addWidget(new Wt::WText(""Your name, please ? "")); nameEdit_ = new Wt::WLineEdit(root()); Wt::WPushButton *button = new Wt::WPushButton(""Greet me."", root()); root()->addWidget(new Wt::WBreak()); greeting_ = new Wt::WText(root()); button->clicked().connect(this, &HelloApplication::greet);   FIVE times new! In six lines!  You really don't need to look further. This is the kind of library that was written by incompetent people without a clue about API-design in C++.  On the contrast cppcms (I don't know what you dislike about their website: It works which is sadly not something that can be said about a lot of websites these days):   class chat : public cppcms::application { public:   chat(cppcms::service &srv) : cppcms::application(srv)   {     dispatcher().assign(""/post"",&chat::post,this);     dispatcher().assign(""/get/(\\d+)"",&chat::get,this,1);   } ... };   (Again: randomly chosen from the tutorial)  This is more or less how a good API should look.   It does not require tons of new and naked pointers (IIRC there were some rare situations where you needed them, but not nearly on the same level) It works nice with common idioms like iteratos It follows the stdlibs naming-conventions …   Seriously: new is worse than goto and yes, I am completely serious when I say that. (This doesn't say that there is never a place for it, as is true for goto, just not in normal code.)"
cpp,3b4qx7,F-J-W,3,Fri Jun 26 20:50:07 2015 UTC,"Just a small note: Wt is inspired by Qt, which also uses this new infested coding convention, so to speak. I find it repulsive BTW, but Qt at least has a historical excuse (compilers back then, etc etc)."
cpp,3b4qx7,Cyttorak,2,Sat Jun 27 17:03:47 2015 UTC,"Seriously: new is worse than goto and yes, I am completely serious when I say that   +10000 to that. new/delete have no sense in any way nowadays. You should be using containers/etc, and in the very rare case you are dealing with low level stuff (i.e. implementing your own container or talking with a C API) you end up using an allocator or raw malloc. So, where are new/delete these days?"
cpp,3b4qx7,Manu343726,1 point,Sat Jun 27 10:49:37 2015 UTC,why raw malloc over new/delete? So you can realloc?
cpp,3b4qx7,djshadow2,1 point,Sat Jun 27 10:50:44 2015 UTC,"what I mean is that new/delete are not neccessary since, in the very few times you play with this kind of low level management, you have access to the C/system/your-own API for dynamic allocation, then call placement new and dtors when needed. For me, placement new should be called construct or something like that."
cpp,3b4qx7,Manu343726,1 point,Sat Jun 27 11:04:41 2015 UTC,"Also the fact that new/delete are a mess: new/delete, new[]/delete[], placement new, global new/delete operators overloading. That's a bunch of confusing shit that's far better suited by calling raw malloc()/free()and calling ctors and dtors by hand; i.e. an allocator. Clean the allocator interface, add support for polymorphic allocators, and we all will be free (no pun intended) of new/delete and happy with a customizable memory allocation system that's not a mess.  C++ without an explicit way to raw-dynamically allocate an object. Imagine that. I think it's perfectly reasonable, to completely deprecate and then eliminate new/delete. Raw-dynamic mem is discouraged by everybody these days with this RAII-glorified C++, and I'm very happy with that."
cpp,3b4qx7,Manu343726,2,Sat Jun 27 10:54:14 2015 UTC,Cppcms is LGPL3 thus an none starter for alot of people.
cpp,3b4qx7,cynicalsingularity,1 point,Sat Jun 27 17:16:52 2015 UTC,"CppCms has really shitty const-correctness.  Query functions are non-const so that objects you'd like to be const, and should be const, cannot be."
cpp,3b4qx7,Crazy__Eddie,6,Sat Jun 27 19:34:00 2015 UTC,"I use cppcms whenever i need a c++ web service, and even done some personal projects (web apps) with cppcms.  It is, imo, quite awesome. It works well, very well.  I quite like the architecture, and the fact that I can very easily build web services with it (and for web apps, just put an angular front-end).  Wt - i looked at it, but it looks more like one would create a desktop app, but for the web. Sorry, I don't agree with that concept. Not anymore. Not since 2010.  Proxygen - never head of it until now, but looking at their github page and the sample, doesn't look too bad.   Cppcms though, works. Easy to get into, easy to learn, very flexible, very powerful."
cpp,3b4qx7,alonjit,6,Fri Jun 26 04:04:33 2015 UTC,"I looked at Wt, but it seemed more like a framework that was different from everything else out there. I have done 2 projects recently using a C++ server. For the first one, I used a combination of AngularJS for the front-end and cpp-netlib for the back end.  For the second, I used ReactJS for the front-end, and crow (https://github.com/ipkn/crow) for the backend. I really like ReactJS more than angular, and crow makes writing C++ REST services so painless. I plan on using this combination for other services."
cpp,3b4qx7,jbandela,1 point,Fri Jun 26 14:28:04 2015 UTC,Is crow fully async?  I've been toying with building a home automation daemon with cpp-netlib.
cpp,3b4qx7,darthcoder,1 point,Fri Jun 26 20:13:25 2015 UTC,Wt dbo is cool but haven't used the web stuff
cpp,3b4qx7,__notmythrowaway__,1 point,Fri Jun 26 11:51:35 2015 UTC,"I've looked into Wt in the past when I was bouncing around some concepts in my head.  I've never ended up doing any web development though so I've never used it.  I agree with alonjit 's comments it does seem a bit more like creating a desktop app in the browser which could be useful at times but not great for a lot of things, and I understand the toolkit is very efficient making it good way to create a web interface for a small embedded system."
cpp,3b4qx7,Vadoola,1 point,Fri Jun 26 14:08:50 2015 UTC,"I don't have much experience with serious web programming. From my limited perspective I've never quite understood the number, size, and scope of all these web frameworks. It seems like a handful of libraries is all you need, not some huge ""framework"" with its tentacles in everything.  FastCGI + http library + templating library + some sort of database. What am I missing? None of that stuff seems super complicated and worthy of a huge complicated framework. Pick the pieces you want and just use them.  POCO appears to have all the stuff you would need bundled up in one package."
cpp,3b4qx7,kkrev,2,Fri Jun 26 16:58:16 2015 UTC,"What am I missing?   A lot of these frameworks are more than just request/response services. A lot of these frameworks exist to facilitate things like so-called ""REST-ful"" services and data-driven applications. Instead of doing a request to a given URI and sending back a fully-processed HTML template with values filled in, the ""fancy"" frameworks send a JSON blob that the client-side JavaScript framework uses to modify the client-side HTML templates.  It's all a matter of what you want to accomplish, what you want to optimize for, and how much/what work you want to do on the server-side."
cpp,3b4qx7,greyfade,-5,Fri Jun 26 20:49:33 2015 UTC,"To be honest, I wouldn't use C++ for web development, and client-side web dev in c++, is definitively not the right tool for the job.  Use a JS framework, or a similar language designed with web client in mind."
cpp,3b4qx7,c0r3ntin,3,Fri Jun 26 13:09:57 2015 UTC,is definitively not the right tool for the job.   This is pretty debatable.
cpp,3b4qx7,doom_Oo7,1 point,Fri Jun 26 18:16:18 2015 UTC,Don't forget that the first internet clients were made using raw UNIX sockets (aka with C)
cpp,3b3eb8,dplong,5,Thu Jun 25 17:22:04 2015 UTC,Coliru also has clang and some special libs (range-v3).
cpp,3b3eb8,TemplateRex,2,Thu Jun 25 20:24:18 2015 UTC,"How can you tell? They don't provide much information about what's going on behind the scenes. Just today, I saw someone publish a link to a generated page that #included boost libraries and that had commands for g++ and clang in the command-line window so that, when you click ""Compile, link, and run,"" it does so for both.  Seriously, do you have access to a list of the site's capabilities?"
cpp,3b3eb8,CubbiMew,4,Thu Jun 25 23:13:23 2015 UTC,http://coliru.stacked-crooked.com/a/6f72d5a72de2bf64
cpp,3b3eb8,redditsoaddicting,2,Fri Jun 26 02:11:34 2015 UTC,I've just tested whether something I want is there and occasionally bugged the owner to update a part (you can thank me for Clang 3.6). The command window at the bottom is very general; you can put whatever you want within permissions.
cpp,3b3eb8,ismaildonmez,1 point,Fri Jun 26 03:43:17 2015 UTC,coliru misses libc++abi which quite unfortunate for libc++ use.
cpp,3b3eb8,o11c,5,Fri Jun 26 07:23:17 2015 UTC,I'm particularly interested in knowing if there's an online MSVC compiler that shows assembly. I suppose it might be possible to open argv[0] and dump it as hex and disassemble locally ...
cpp,3b3eb8,MarekKnapek,1 point,Thu Jun 25 20:01:12 2015 UTC,Hmm... I didn't come across one.
cpp,3b3eb8,redditsoaddicting,3,Thu Jun 25 22:54:30 2015 UTC,Here are some form my bookmarks (may be outdated):  http://melpon.org/wandbox/  http://codepad.org/  http://codetwist.com/  http://coliru.stacked-crooked.com/  http://www.compileonline.com/compile_cpp_online.php  http://gcc.godbolt.org/  http://ideone.com/  http://liveworkspace.org/  https://compilr.com/  http://webcompiler.cloudapp.net/  http://comeaucomputing.com/tryitout/  *Edit: one per line.
cpp,3b3eb8,14ned,1 point,Thu Jun 25 21:40:09 2015 UTC,"I'll have to check out liveworkspace.org when I get home. Proxy says it's now a ""Parked Domain.""  compilr.com was taken over by lynda.com, which is a video learning site. As far as I can tell, the online-compiler component of compilr.com did not make the transition. That's why it's not on the list.  I have all the others. Thanks."
cpp,3b3eb8,hcspel,2,Thu Jun 25 23:02:40 2015 UTC,"LWS used to be my go-to over ideone, but yeah, then everything kind of died."
cpp,3b3eb8,zxmarcos,3,Fri Jun 26 03:45:20 2015 UTC,"If you're automating a playpen for your C++ library per commit, knowing which ones provide a push API is handy. Coliru and Wandbox do. Wandbox also lets you push a background file with your library, and lets the user play with a simple front example program.  https://svn.boost.org/trac/boost/wiki/BestPracticeHandbook#a14.USERFRIENDLINESS:Considerlettingpotentialuserstryyourlibrarywithasinglemouseclick has some scripting for pushing playpens per CI commit if anyone is interested."
cpp,3b3eb8,OldWolf2,2,Fri Jun 26 00:03:11 2015 UTC,Great list. Thanks! Here is another one to the list: https://dbgr.cc/
cpp,3b3eb8,Elador,2,Thu Jun 25 17:58:25 2015 UTC,"Okay, looks good. I added it to the list."
cpp,3b3eb8,spongo2,1 point,Fri Jun 26 05:12:17 2015 UTC,"Thanks to you, too! A corporate proxy blocks that site due to ""Suspicious Content,"" so I'll have to try it at home."
cpp,3b3eb8,o11c,2,Thu Jun 25 18:50:02 2015 UTC,C++ Shell
cpp,3b3eb8,ZMeson,1 point,Thu Jun 25 21:32:00 2015 UTC,"Yeah, that's already in the list."
cpp,3b0bga,joaquintides,8,Wed Jun 24 23:05:58 2015 UTC,"This is an interesting approach, the resulting data structure looks a lot like a heap and thus probably allows similarly efficient tree traversal.  But I only see a very narrow range of use cases for this. It's not sorted anymore and element insertion and deletion is probably rather expensive. A sorted array may have a slower binary search but also allows very efficient iteration in sorted order. A hash table probably allows even faster lookup for most types of keys and would additionally allow faster mutation. The only advantage I see is that it is slightly more memory efficient than a hash table. This seems to limit the reasonable use cases for this data structure to large read-only lookup tables in very memory constrained environments.  I never really understood why tree based data structures are and have historically been so popular in C++ and why there hasn't been a decent hash table in the standard library for so long. While I haven't tried other implementations, the unordered_map in Visual Studio 2013 at least is still of questionable quality. Last time I checked a naive flat array based implementation (2n sized) with open indexing turned out be about twice as fast for insertion and lookup with the same hash implementation."
cpp,3b0bga,x4u,13,Thu Jun 25 02:11:41 2015 UTC,"The guts of VC's unordered_map are very old, since they're shared with the non-Standard hash_map. I've deprecated hash_map in 2015, so I can remove it in the next major version, and then we can think about reimplementing unordered_map."
cpp,3b0bga,STL,3,Thu Jun 25 02:39:13 2015 UTC,Hash tables in C++ are typically implemented as a linked list of nodes with an array of pointers to those nodes. So they're not cache-friendly at all.
cpp,3b0bga,minno,7,Thu Jun 25 02:32:20 2015 UTC,"This is not really accurate, it would be more correct to say that std::unordered_map is generally implemented this way. Because of various guarantees on iterators and when they can and cannot be invalidated, and a desire to have robust performance across different types and degrading gracefully with the fill factor, the implementation you described is typical for std::unordered_map.  However, usually when people implement their own unordered_map, they do it because they want very good performance for specific types. The most common choice is usually a flat, open address hash table which is fairly cache friendly."
cpp,3b0bga,quicknir,2,Thu Jun 25 03:18:26 2015 UTC,"Yes, looking at the specs for std::unordered_map, it's clear that they had separate chaining in mind.  That explains why std::unordered_map will generally be implemented using separate chaining. But it does not explain why the interface was written with separate chaining in mind, given its cache-unfriendliness. True, as you noted, the performance of separate chaining degrades more gracefully than that of open addressing, as the load factor approaches one. That is why we put an upper limit on the load factor, and remake the hash table using a larger array when the limit is reached. Since std::unordered_map is going to do this regardless, I don't see that the performance degradation when the load factor nears one is an issue.  And it isn't just C++. It appears that the standard hash tables for Perl and Ruby use separate chaining as well (I think). CPython uses open addressing (I'm sure on this one), but it might be the only major language to do so.  I'm very unclear on why separate chaining is so much more popular."
cpp,3b0bga,ggchappell,2,Thu Jun 25 06:10:55 2015 UTC,"I'll preface this with saying I'm not an expert on hash tables, but hopefully this is useful.  To write an open address hash table, you have to make many more decisions. You have to decide what kind of probing to use, you have to decide how the key and value will be laid out in memory, whether it's worth storing the hashes, etc etc. All these decisions will have a strong effect on performance trade-offs, and it's really hard to make them intelligently with knowing a) the ratio between inserts, accesses, and deletes, b) the sizes of the data types, c) the distribution of the hashed data d) probably more things I'm forgetting. In other words, it's hard to make choices that are both good and generic.  It's especially worth noting how different the hash distribution issue is for open and closed. In closed addressing, you simply need to avoid excessive repeats of the hash modulo the size. In open addressing, you also have to worry about clustering, both primary and secondary. You generally need a better hash, and a probing scheme that fits well with your hash.  Separate chaining is a lot more straightforward, it's behavior won't be as dependent on the details of the types. It provides additional useful features. For example, if you have a function that needs to insert elements but is latency sensitive, it can crank up the load factor before insertion. You can't do this with open addressing.  In python, everything is based around pointers, so the types stored in the hash table are always the same size. Also, the philosophy of the python standard library guys is different from the c++ standard library in my experience. Python people care a lot about typical performance, c++ people care about worst case. The python sort (TimSort I believe) is O(N) on sorted or nearly-sorted data, because this is a very common use case. C++ uses a quicksort variant with limited descent and other clever features, to give very good guarantees in the worst case. Python's hash function for integers is just the integer itself, because this is fast and often performs very well (insertions with keys that are consecutive integers);  c++ would probably refuse to ever do something this naive. Python's hash tables perform well in practice in most reasonable cases and that's their main concern. Also as a fun FYI Python uses quadratic probing. I've heard that the ""worst case"" mentality is also why c++ had tree based data structures before hash; because it's much easier to generically put worst case guarantees on tree structures, and that's why the authors picked those first.  Anyhow, pretty long, but I hope that helps a bit?"
cpp,3b0bga,quicknir,1 point,Thu Jun 25 23:00:47 2015 UTC,"Yes, that was very helpful. Thanks!   In python, everything is based around pointers, so the types stored in the hash table are always the same size.   It seems that lots of design issues end up coming back to this. Recall the discussion a month or so ago about specifying a custom sort order via a comparison function vs. a key function. Python is big on key functions, and, again, the fact that everything is referred to by pointer is critical in making this work well.  Also, you said:   In open addressing, .... You generally need a better hash, ....   And:   Python's hash function for integers is just the integer itself, ....   Kinda ironic, no?"
cpp,3b0bga,ggchappell,2,Fri Jun 26 02:27:03 2015 UTC,"Haha, yes, it is, good catch! Hard for me to fully explain that. I suppose it all comes back to the trade offs I mentioned, but maybe a real expert can illuminate this discussion."
cpp,3b0bga,quicknir,1 point,Fri Jun 26 03:15:41 2015 UTC,"Yeah, I saw the similarities to a heap pretty quick too.  I would call this a narrow use case though. It's certainly not general, but there are a lot of use-cases for constructing sets/maps once at setup and never modifying them."
cpp,3b0bga,o11c,1 point,Thu Jun 25 08:26:38 2015 UTC,nice post
cpp,3b0bga,chambolle,1 point,Fri Jun 26 18:02:31 2015 UTC,"I had a use case for a compact ""cache-friendly"" map with LRU characteristics, ie keep the least recently used ones in cache. I implemented a vector-based splay tree that worked wonders."
cpp,3b0bga,fritzroid,1 point,Mon Jun 29 13:46:17 2015 UTC,std::vector or std::deque of pairs and sort it.  Cache and space friendly!
cpp,3b0bga,bnolsen,4,Thu Jun 25 01:45:18 2015 UTC,Did you read the article? The whole point is that sorting is not as cache-friendly as you can get.
cpp,3b0bga,o11c,2,Thu Jun 25 08:24:35 2015 UTC,"deque is not very friendly to caches, even with largeish blocks. vector (and array) is much better."
cpp,3b0bga,STL,3,Thu Jun 25 02:39:56 2015 UTC,"I guess it's all relative, and it depends a lot which benchmarks you pick, but it seems to me that the difference between vector and deque is not that huge. Or, to be concrete: deque is much closer to vector than list. E.g. consider linear search benchmarks: http://baptiste-wicht.com/posts/2012/12/cpp-benchmark-vector-list-deque.html"
cpp,3b0bga,quicknir,2,Thu Jun 25 03:20:47 2015 UTC,"You really need to specify the operations when making a claim like this. For example, while random access will almost always have an extra cache miss in large enough deques vs vectors, linear access with reasonably sized blocks can be nearly as good (You get diminishing returns in increasing the block size for this)."
cpp,3b0bga,detrinoh,1 point,Thu Jun 25 18:03:14 2015 UTC,"That's a very good point about random access, thanks for pointing that out."
cpp,3b1cq2,tallassrob,3,Thu Jun 25 04:25:22 2015 UTC,"Did the interview style improve?  Listened to the first couple of episodes and it went on like:"" Did you read that article?"" ""Yeah, I did. It had some interesting points."" "" Wow, that's interesting."" And then they went on to the next topic and rinse and repeat. Very little substance and kinda annoying."
cpp,3b1cq2,PaulPlasmapuster,2,Thu Jun 25 06:29:07 2015 UTC,I hope we're getting a bit better with each episode. Appreciate the feedback.
cpp,3azj6h,mttd,2,Wed Jun 24 19:31:35 2015 UTC,I'm glad they published the talks. 1350 EUR for a 3 day conference pass... Nope.
cpp,3azj6h,Stusseligheten,1 point,Wed Jun 24 19:58:40 2015 UTC,"looks very interesting, but vimeo doesnt seems to work. would it be possible for you to post on youtube?"
cpp,3azj6h,okiujh,1 point,Thu Jun 25 12:19:39 2015 UTC,Anyone got a C++ track playlist from NDC Oslo? The vimeo catalogue doesn't seem to be organised by track and I can't figure out how to search it by tag.
cpp,3azj6h,notlostyet,-2,Thu Jun 25 15:28:37 2015 UTC,Why is everyone trying to turn c++ into haskell?
cpp,3azj6h,cynicalsingularity,4,Thu Jun 25 07:32:43 2015 UTC,"The world has woken up to the value of functional programming and C++ being inherently multi-paradigm is being adapted to it.  That said, C++'s STL has always been somewhat functional."
cpp,3azj6h,dicroce,4,Thu Jun 25 13:42:27 2015 UTC,Meta-programming allows to turn C++ into any other language.
cpp,3azj6h,doom_Oo7,3,Thu Jun 25 15:04:13 2015 UTC,Why everyone wants to fixate the imagination of other people?
cpp,3azj6h,__Cyber_Dildonics__,2,Thu Jun 25 11:34:47 2015 UTC,"Even though that is of course not true, for better or worse when C++ gets a feature it becomes non academic, since there are the compilers, tools, manual memory management and  threading to back it up."
cpp,3az16s,mttd,1 point,Wed Jun 24 17:19:02 2015 UTC,Thanks for sharing!
cpp,3az16s,Orakar,0,Thu Jun 25 00:15:57 2015 UTC,Is pure TDD practical with the third-rate refactoring tools C++ has? In my experience the answer to that question has been no.
cpp,3az16s,nat1192,1 point,Thu Jun 25 02:03:50 2015 UTC,"I don't think it is so much availability as it is polish.  I've yet to use CLion so I can't speak to it.  But I have used a lot of other C++ ides and while they may have all the ""Autocomplete, syntax highlighting, etc"" checkboxes, many of them feel incomplete/buggy/less than useful.  Java, on the other hand, has really spectacular tooling/IDEs.  The autocomplete/syntax highlighting/code helps/etc on java IDEs is really good (Netbeans is the one I use for work, but I've heard good things about Intellij as well).  But that is just what I've seen.  This opinion may be way out of date because it has been a couple of years since I've done anything major with C++."
cpp,3az16s,cogman10,1 point,Thu Jun 25 03:21:05 2015 UTC,"Certainly.  I've dabbled with intellij IDEs before and they are pretty nice.  I have a lot of faith in them to do a good IDE for C++ because they are generally good at that sort of stuff.  OTOH.  I've constantly heard that QTCreator is pretty awesome, yet when I went to use it I really wasn't all that impressed.  It just wasn't a smooth ride (I feel like Visual studios does a better job at C++ handling than QT creator, other than their slow adoption of C++11).  This is just my impression though.  I'll have to take CLion for a spin to see how good it is."
cpp,3azi39,mttd,21,Wed Jun 24 19:23:18 2015 UTC,"Spends the first 28 minutes describing how shared_ptr<T> and weak_ptr<T>.  Then spends time describing how multi-threading is hard.  Around minute 47, he finally gets around to saying ""this makes passing shared_ptr by value slow"", and showing numbers.  Presentation tip:  Lead with the problem, then provide explanation.  I have no idea what parts of your explanation are important if I don't know why you're providing it.  TL;DR: Passing shared_ptr<T> by value is slow because you might use them in threads.   Watch from the beginning if you want to know how shared_ptr works. Watch from 28m if you want to know the problems with shared_ptr in multiple threads.  (I highly recommend Herb Sutter's atomic<> weapons talk for how the C++ memory model works. Watch from 47m for benchmarks (sans any charts, sadly). Watch from 51m for problems with passing shared pointers by reference. Watch from 54m for his own summary."
cpp,3azi39,Benabik,6,Wed Jun 24 23:30:51 2015 UTC,"I found that refcounted smart pointers are virtually only interesting in multithreaded scenarios.  Without multithreading, handling object ownership through... well, ownership design, beats shared ptr any day of the week for me."
cpp,3azi39,Gotebe,4,Thu Jun 25 05:11:42 2015 UTC,ownership can be designed in with threading still.  that's the bulk of the thread stuff I do.
cpp,3azi39,bnolsen,1 point,Thu Jun 25 09:58:04 2015 UTC,"Thanks so much for the summary!!  Hmph.  Passing shared_ptr by value isn't ""slow"".  ""Slow"" is a relative term! As I said in a previous post, if any method on std::shared_ptr appears in the top 20 calls in your profiling, there's almost certainly something wrong with your program's fundamental design.  std::shared_ptr doesn't use synchronization mutexes but rather atomic variables to accomplish its magic (as the article says).  It's only slow by the standards of ""passing a pointer"" - by any real world standards, it's fast.  Passing a shared_ptr by value sends a message to the programmer - ""this routine expects to keep that shared pointer copy you just made.""    A good case could be made that 90% of the time the three logical choices are shared_ptr<T> by value (if the routine will keep a copy of the shared_ptr) or T& or const T& (if it won't) - that the only time to use  shared_ptr<T> const& is in those rare cases when you don't know whether or not you're going to keep a reference.  (Honestly, I personally use shared_ptr<T> const& most of the time because its our team's style, but other ideas have been discussed.)  Overall, this is in the category of micro-optimization.  Good to know, but the chances that it'll have any real-world impact on the performance of your code is small.  (If you're that worried about performance, a lot of the time you can get rid of the shared_ptr in favor of unique_ptr entirely, at some violence to the code...)"
cpp,3azi39,TomSwirly,10,Thu Jun 25 01:35:54 2015 UTC,"Please don't use shared_ptr most of the time. This is becoming the latest symptom of a big-ball-of-mud.   First try to design your software so that there are clear ownership semantics. It creates a cleaner, simpler, faster design that is simpler to reason about. If creating clean, simple and fast software isn't your team's style then it should be. Only use shared_ptr when objects must have shared ownership for some reason.  Also, don't pass any kind of smart pointer as an argument when you don't have to. If your function uses a T and doesn't deal with ownership then let it take a (const)T(&). What makes you think I'm holding my T with your favoured smart pointer?  End of rant."
cpp,3azi39,hubhub,3,Thu Jun 25 05:16:17 2015 UTC,"Please don't use shared_ptr most of the time.    Absolutely.  With C++11 and move semantics, you rarely need it.  It shouldn't be your ""go to"" memory management.   What makes you think I'm holding my T with your favoured smart pointer?   Well, as I said, ""shared_ptr<T> by value (if the routine will keep a copy of the shared_ptr)"".  In that case, if you don't have T with the shared_pointer, you can't on principal use my routine!  Given that you are forced into using a shared_ptr, the receiving method often needs to keep that shared_ptr.  Given that you must use a shared_ptr, value semantics are cheap and easy.  Of course, you should prefer passing a reference, and you should prefer overall designs that have clear ownership of your pointers."
cpp,3azi39,TomSwirly,1 point,Thu Jun 25 23:34:17 2015 UTC,"That's great if it's a single threaded programming, but keeping track of everything in a non-deterministic multi-threaded environment can be very hard and is what I consider a wasteful micro-optimization; who is to say the thread holding the pointer won't idle for tens of thousands of cycles by the scheduler? Why keep track of that manually instead of just using a shared_ptr which, itself, takes only a negligible fraction of the total cycles in your program. I think many of the arguments on here stem from two camps of people, one who deals with multi-threaded environments, and one who deals with sequential where pointer safety is much simpler and easy to track."
cpp,3azi39,salgat,5,Thu Jun 25 14:32:57 2015 UTC,Sometimes it might be necessary to have multiple threads controlling the lifetime of an object. If that's the case then use shared_ptr. It's what it's there for. But usually that's not what you want. If you're just sharing an object between threads then let the parent  thread control its lifetime.
cpp,3azi39,hubhub,1 point,Thu Jun 25 16:12:03 2015 UTC,"FWIW we had an array of ~1000 shared_ptr with the same thinking (porting from Java).  This is a numerical simulation & finally getting rid of the shared_ptr sped-up the program by 20% even though we couldn't see shared_ptr in the sampling instrumentation.  The main improvements are two-fold: contiguous memory was cache friendly & we didn't have a bunch of unnecessary compiler & CPU fences that prevented optimization.  Additionally, the code is much clearer now since ownership is very clearly defined.  We still use shared_ptr for caching of expensive cross-thread resources but we try hard to limit shared_ptr (& even unique_ptr); using value types as much as possible really makes the code simpler to work with."
cpp,3azi39,vlovich,1 point,Thu Jun 25 18:23:48 2015 UTC,"You're talking about an exception to the rule, where pointers make up a large part of your program; I am talking about the general case. Almost all tools in the STL are bad in specific cases where a much more optimal case exists."
cpp,3azi39,salgat,2,Thu Jun 25 20:06:47 2015 UTC,"I would agree there are tradeoffs with any abstraction & you have to know which one to pick & when you are unnecessarily paying for the wrong abstraction.  Performance considerations aside, shared_ptr usually can be overkill & demonstrates a larger complexity in the code than something like unique_ptr because the ownership is unclear when reading the code (e.g. does ownership imply you can mutate it? maybe, maybe not).  I think the general advice still applies: use value types when possible, use unique_ptr when something needs to live on the heap and ownership is still clear, use shared_ptr when ownership is unclear or you need to share the lifetime between threads.  Prefer to write your own move-only/copy-only/nocopy & nomove value-types when multi-threading isn't a concern to express your needs clearly."
cpp,3azi39,vlovich,1 point,Thu Jun 25 22:03:19 2015 UTC,Very nicely put.
cpp,3azi39,salgat,0,Thu Jun 25 22:25:52 2015 UTC,First try to design your software so that there are clear ownership semantics.   Sounds so easy i theory but in the real multi threaded world it's not.
cpp,3azi39,cynicalsingularity,2,Thu Jun 25 11:17:08 2015 UTC,"Having a whole bunch of objects shared between threads is a great way to run into bugs even with shared_ptr. Sometimes it's exactly what you need, but in most cases it's only solving the simplest of your problems."
cpp,3azi39,Plorkyeran,2,Thu Jun 25 18:35:40 2015 UTC,Not easy at all but working in a better design is more rewarding than debugging.
cpp,3azi39,newmewuser4,4,Fri Jun 26 20:58:35 2015 UTC,std::shared_ptr doesn't use synchronization but rather atomic variables to accomplish its magic    Uh...using atomics is a form of synchronization.  The cost is not negligible.  Every CPU has to update its cache value for the variable for example.
cpp,3azi39,Crazy__Eddie,2,Thu Jun 25 02:40:06 2015 UTC,"He means that it's negligible compared to the entire program. Optimizing for hundreds or thousands of cycles in a program where the loop takes millions is not always worth it. I hate using atomics but each atomic update typically only requires around what, 100 cycles?"
cpp,3azi39,salgat,1 point,Thu Jun 25 14:36:37 2015 UTC,"It depends greatly on the program.  For many it will be a small cost.  But for something that is parallel intensive, where the copies are created and destroyed on a frequent basis, the cost of updating CPU information for an atomic can quickly become an issue.  So if you are passing around by copy everywhere, even for trivial functions, you might be beating the fuck out of your CPU for no reason."
cpp,3azi39,Crazy__Eddie,1 point,Thu Jun 25 16:07:27 2015 UTC,Obviously for special cases exceptions to the rule are necessary; this applies to all niche programming.
cpp,3azi39,salgat,1 point,Thu Jun 25 17:35:14 2015 UTC,"Obviously all of this is application-specific as all optimization problems are.  shared_ptr is obviously a valuable tool in the toolbox.  No one is disputing that.  However it's important to not under-estimate the performance implications.  Remember that it's not just that every CPU has to update the cache.  These are fences that prevent out-of-order execution which can create pipeline stalls & slow down your CPU.  Additionally, these same fences prevent your compiler from optimizing your code which can further slow down your program.  Finally, all of this is predicated on the usage of make_shared.  If you don't, there's another hit which is that your CPU cache will be unnecessarily pressured."
cpp,3azi39,vlovich,1 point,Thu Jun 25 18:27:18 2015 UTC,"I'd not assume that it's ""niche"" programming.  The cost of altering an atomic value can quickly cause some serious performance degradation in any program where that atomic value is shared across threads.  It's worth developing a coding style that limits these effects."
cpp,3azi39,Crazy__Eddie,1 point,Thu Jun 25 20:34:01 2015 UTC,"Thanks for the synchronization catch!  Poor form from me.   The cost is not negligible.   In almost all real-world programs, the cost is negligible."
cpp,3azi39,TomSwirly,2,Thu Jun 25 15:49:22 2015 UTC,"""Slow"" is a relative term!   It's slow relative to passing raw pointers around (assuming the shared_ptr has to be copied and cannot be moved). Whether that actually matters in your program is a different question.   doesn't use synchronization but rather atomic variables   I'd say that using atomic variables are a form of synchronization.  I agree with you on the other points you raised.  Personally, I almost never use shared_ptr. So far, I've used it once to write a copy-on-write wrapper à la  template<class T> class cow {     std::shared_ptr<T> ptr_; public:     cow();     cow(T const& x);     cow(T && x);     T const& operator*() const;     T const* operator->() const;     T const& read() const;     T& write(); };"
cpp,3azi39,sellibitze,1 point,Thu Jun 25 12:23:46 2015 UTC,Stand by for trolls
cpp,3azi39,cynicalsingularity,1 point,Thu Jun 25 11:18:48 2015 UTC,"Passing a shared_ptr by value sends a message to the programmer - ""this routine expects to keep that shared pointer copy you just made.""   Euh... not any more so than a pass by (const) ref. That's rather some convention your team invented?"
cpp,3azi39,Gotebe,1 point,Thu Jun 25 18:03:47 2015 UTC,"I just wanted to mention that ""pass by value"" does not imply copying. We also got move semantics. I expect shared_ptr's move constructor to be very cheap."
cpp,3azi39,sellibitze,2,Thu Jun 25 12:12:36 2015 UTC,"I would expect that a majority of uses of shared pointers is not going to be passing a temporary.  If you do something like foo(make_shared(ptr)), then ptr is going to be deleted when foo returns, which is probably not what you meant to do."
cpp,3azi39,Benabik,2,Thu Jun 25 13:44:26 2015 UTC,"If you have a foo which takes a shared_ptr<T> by value or const-ref and does not store the shared_ptr elsewhere to increase the lifetime of its pointee beyond the function call, then you probably should not have passed a shared_ptr<T> at all ... more like T&. Anyhow, ownership transfer is a thing and we have std::move to support it. Taking a cheaply movable type by value if you want to have your own value is sometimes exactly what you want. For example:  class Person {     std::string name; public:     explicit Person(std::string n): name(std::move(n)) {} };   That's as simple as it gets and it still avoids all unnecessary copies."
cpp,3azi39,sellibitze,1 point,Thu Jun 25 16:23:40 2015 UTC,"One cannot use const t& in lieu of any form of a shared ptr because a shared ptr is nullable. const t* should be used.  Pointer is not a reference, however smart :-)"
cpp,3azi39,Gotebe,2,Thu Jun 25 17:52:58 2015 UTC,What about optional<T&>?
cpp,3azi39,vlovich,1 point,Thu Jun 25 18:19:47 2015 UTC,"Never crossed my mind, thanks!  That said, going from shared_ptr to optional has a bigger runtime cost of more stack use and a branch :-)."
cpp,3azi39,Gotebe,1 point,Fri Jun 26 04:49:23 2015 UTC,There is no way going from shared_ptr<T> to optional<T&> has a larger runtime cost.  sizeof(optional<T&>) == sizeof(T *) & the branch only occurs if you use .value().  If you dereference optional it's equivalent to a pointer dereference.  Even if you did optional<T> that's likely going to be lighter-weight than shared_ptr.
cpp,3azi39,vlovich,1 point,Fri Jun 26 08:54:11 2015 UTC,"Euh... how does the optional know it has an object in if not by maintaining an ""empty"" (or full:-)) flag? It can't be the same size as T!  That said, yes, optional is lighter than a shared ptr, but not lighter than a naked pointer."
cpp,3azi39,Gotebe,1 point,Fri Jun 26 18:04:29 2015 UTC,"optional<T&> is specialized.  T& can never be null so internally optional<T&>stores a pointer with null as the disengaged state.  That being said, even if it didn't that would be cheaper than shared_ptr which has 2 pointers (control block + block to storage) & if you copy it by value there's a bunch of atomic operations that come into play that would be more expensive than copying a little bit more for the empty flag in optionl."
cpp,3azi39,vlovich,1 point,Fri Jun 26 19:35:29 2015 UTC,"Of course, it depends on the function and whether you know if the pointer is null or not. I'm sure even you dereference a pointer from time to time. ;) That's what they are for…"
cpp,3azi39,sellibitze,1 point,Fri Jun 26 09:00:08 2015 UTC,"depends on the function and whether you know if the pointer is null or not   Yes, but the difference is that with a reference I really know that it is not null :-)"
cpp,3azi39,Gotebe,1 point,Fri Jun 26 17:58:56 2015 UTC,...which might be exactly the reason why you would want to use a reference for a function parameter. ;)
cpp,3azi39,sellibitze,1 point,Fri Jun 26 20:37:45 2015 UTC,"Yes, but not from a shared ptr, which is what we have here, because shared ptr is a moral equivalent of a pointer, not reference.  There has to be a non-empty flavor of a shared ptr, I say! :-)"
cpp,3azi39,Gotebe,1 point,Sat Jun 27 05:10:00 2015 UTC,I know what you mean. You know what I mean. Let's stop this nonsense.
cpp,3azi39,sellibitze,2,Sat Jun 27 08:05:30 2015 UTC,"The ""interesting"" parts start at 28:00"
cpp,3azi39,cynicalsingularity,2,Wed Jun 24 21:22:37 2015 UTC,tl;dr anybody?
cpp,3azi39,fahrnfahrnfahrn,2,Wed Jun 24 21:57:14 2015 UTC,"I found his advice for passing shared_ptr by reference to be very strange, compared to Herb Sutter's advice to just pass the reference or pointer to the object itself. References especially in c++ are synonymous with non-owning views (pointers are too, but this is obfuscated by their heavy use in C APIs and older C++).   If your function takes an a reference to an object, that clearly indicates that the object in question will not be owned or co-owned by the function. It also allows the function to be used completely independently of whether the object is on the stack, managed by a unique_ptr, or shared_ptr.  If your function needs a reference to the shared_ptr itself for manipulation, co-ownership, etc, that's fine, don't be bashful. But there's no reason to do it otherwise. I also find the double indirection to be unnecessarily confusing for most situations."
cpp,3azi39,quicknir,3,Wed Jul 1 22:17:37 2015 UTC,"Gosh, I don't have an hour to listen to someone talk - I don't suppose there's a transcript?"
cpp,3azi39,TomSwirly,2,Wed Jun 24 19:48:35 2015 UTC,I wish they've used Youtube for hosting. On Youtube you can change the playback speed of the video (at least on Chrome).
cpp,3azi39,drac667,5,Wed Jun 24 20:51:14 2015 UTC,"If you have VLC, you can use it to play the videos at whatever speed you want."
cpp,3azi39,m42a,1 point,Thu Jun 25 01:14:22 2015 UTC,"Depending on how familiar you already are with shared_ptr there is possibly little new information. It's basically about how shared_ptr is implemented w.r.t. to the control block that stores the ref counters and the deleter (memory overhead, make_shared using only a single allocation, thread-safe ref counters using atomic variables). The message is that copying shared_ptr might be more expensive than you think due to atomic ref counting."
cpp,3azjlx,mttd,1 point,Wed Jun 24 19:34:51 2015 UTC,"Just look at his github page: https://github.com/jfbastien  He wrote the WebAssembly design document.  https://brendaneich.com/2015/06/from-asm-js-to-webassembly/ ""[...] Having both the PNaCl team and the V8 team from Google, along with key people from Microsoft and the asm.js and Emscripten gurus from Mozilla, collaborating closely once everyone saw the light, has been inspiring. [...]"""
cpp,3azjlx,hun_nemethpeter,1 point,Wed Jun 24 22:54:36 2015 UTC,"Yes, talk was mostly on Native Client, but at the end, that is what partly WebAssembly is based on.  Its been just the day before his talk that this WebAssembly thing was announced."
cpp,3azjlx,meetingcpp,1 point,Wed Jun 24 23:13:32 2015 UTC,Looks like they created a unix inside a browser: https://code.google.com/p/naclports/wiki/PortList
cpp,3azjlx,hun_nemethpeter,1 point,Wed Jun 24 23:48:29 2015 UTC,I'm still waiting for the port of NaCL and WebAssembly to NaCL and WebAssembly ;-)
cpp,3aveip,CaptSpify_is_Awesome,18,Tue Jun 23 20:31:59 2015 UTC,An alternative would be to switch to CMake (it generates makefiles compatible with both)
cpp,3aveip,RogerLeigh,1 point,Tue Jun 23 21:03:23 2015 UTC,I've found CMake to be very useful -- our use case is compatibility between Windows and Ubuntu 12/14.
cpp,3aveip,Whitt83,11,Wed Jun 24 14:29:52 2015 UTC,"Nothing to do with the kernel. Your problems will be with the C library.   If it's c++ there is a big chance it's been built on top of the standard libraries and not used many calls to the libc.  FreeBSD and other BSDs use libc, not glibc like GNU/Linux OSs as Debian and Redhat.   libc has some extensions that might have been used by your code, most likely not though. But 90% or more of it is standard Posix, to which all comply.   That said, the first step is to get it to compile, to which using cmake will help you wonders. Makefiles can be messy.   I would make sure to set a baseline though. You can compile with the same compiler on BSD and test it throughly to set the expected behavior.   On another machine with Linux, compile using the same cmake/makefile.  If it does not compile,  you'll have to go fixing it manually.  Once it compiles, run the very same tests side by side and diff the results. That will give you the first assurance everything is sane.   Then of course you'll have to go about checking every glibc call in your source - or just roll with it depending on your schedule."
cpp,3aveip,fritzroid,3,Tue Jun 23 22:47:18 2015 UTC,"Are there any tips or resources, like a list of changes to the language or coding standards or anything like that?   You will find general talking points everywhere (easy part), but the devil will be in details of your code, therefore the best tip imho is: make sure you know what your code (including build scripts) does and why (very hard part)."
cpp,3aveip,Gotebe,1 point,Wed Jun 24 05:17:00 2015 UTC,"yeah, I totally agree that's what it will look like. Just was hoping for something like a magical ""diff of changes to the languages"" or something. So far it's going well, but small things (like scoping changes, Makefile syntax) are getting me."
cpp,3aveip,o11c,2,Wed Jun 24 14:56:10 2015 UTC,"What compiler/version were you using on freebsd 4.10? That makes a huge difference.  You'll also want to install libbsd for additional functions that the glibc developers are too politically motivated to want, and make sure you pass the right features.h defines to prefer BSD, at least at first."
cpp,3aveip,o11c,1 point,Wed Jun 24 05:43:39 2015 UTC,"looks like gcc 2.95.4  Thanks for the suggest about libbsd, that looks like it will help a lot"
cpp,3aveip,millenix,2,Wed Jun 24 14:54:31 2015 UTC,"Okay 2.95 was the last of the ""definitely nonstandard"" C++ compilers. Over the course of 3.0 to 3.4, gcc became more standard-compliant. If it is difficult to get everything working with a recent compiler, I would choose 3.4 as an intermediate.  GCC 4.0 was the beginning of modern GCC, but was quite unstable. I suggest GCC 4.2 if you need something from its era.  GCC 4.3 was the beginning of C++11 support, which did affect the compiler even in C++03 mode as well. GCC 4.4 is significant because it was used for LTS on both RedHat and Debian, so it is likely to be very solid. GCC 4.6 was a major change that affected both modes; GCC 4.7 and 4.8 mostly only affected C++11 compatibility, though 4.8 is the time when . GCC 4.9 was the last release before the breakage in GCC 5.  GCC 5 changes the default ABI, though this might be disabled in distro toolchains. I suggest avoiding it for a couple years.  Besides just making your code able to compile, I strongly recommend cranking up the warnings at each step, and using #pragma GCC diagnostic on the sites where they are unavoidable.    As for libc, there were also major changes every few versions, but I think they will be dwarfed by the BSD-related changes. Though note that in the very latest glibc, BSD compatibility has been dropped somehow, though I'm not very aware of the details.    The above is from my personal experience and gut feelings. Here are convenient links to upstream's:   https://gcc.gnu.org/gcc-3.0/features.html https://gcc.gnu.org/gcc-3.1/changes.html https://gcc.gnu.org/gcc-3.2/changes.html https://gcc.gnu.org/gcc-3.3/changes.html https://gcc.gnu.org/gcc-3.4/changes.html https://gcc.gnu.org/gcc-4.0/changes.html https://gcc.gnu.org/gcc-4.1/changes.html https://gcc.gnu.org/gcc-4.2/changes.html https://gcc.gnu.org/gcc-4.3/changes.html https://gcc.gnu.org/gcc-4.4/changes.html https://gcc.gnu.org/gcc-4.5/changes.html https://gcc.gnu.org/gcc-4.6/changes.html https://gcc.gnu.org/gcc-4.6/porting_to.html https://gcc.gnu.org/gcc-4.7/changes.html https://gcc.gnu.org/gcc-4.7/porting_to.html https://gcc.gnu.org/gcc-4.8/changes.html https://gcc.gnu.org/gcc-4.8/porting_to.html https://gcc.gnu.org/gcc-4.9/changes.html https://gcc.gnu.org/gcc-4.9/porting_to.html https://gcc.gnu.org/gcc-5/changes.html https://gcc.gnu.org/gcc-5/porting_to.html"
cpp,3aveip,RogerLeigh,1 point,Wed Jun 24 17:36:55 2015 UTC,"You'll want to step forward the compiler you use as incrementally as possible, rather than in one leap, so that you can fix compatibility errors one step at a time. Maybe load up VMs of successive Debian releases or Ubuntu LTS releases, and walk through versions of g++ and glibc there.  My experience working with a fairly old C++ code base (dating from ~1995, pre-standard) is that there have been very few cases where old code breaks in newer environments.  Unless you're dealing with kernel module code, or the code uses some weird system calls from old FreeBSD that Linux has never implemented, the kernel is almost entirely irrelevant to this.  After the compiler, you'll need to care about libraries (as noted by fritzroid) and build environment, as you noted yourself."
cpp,3aveip,bnolsen,2,Wed Jun 24 01:49:57 2015 UTC,You could also do this the other way around: make it build on a current FreeBSD 10.1 with clang 3.4 and then build on Linux after that.  i.e. modernity then portability.
cpp,3au307,ethanxxx,6,Tue Jun 23 14:51:26 2015 UTC,"The two Walter Brown ones were the best -- he's a bit verbose, but there are some nuggets there for beginning/intermediate TMP viewers.  If you only have time for one, then watch part 2.  The void_t that he proposed in the 2nd part is truly worth watching, understanding, and learning -- it works and makes a lot of boilerplate TMP code a lot simpler"
cpp,3au307,craptacus,2,Tue Jun 23 18:04:47 2015 UTC,This talk is one of my favorite C++ talks. Really eye opening. I also found the book from  Davide Di Gennaro  helpfull to get started with template metaprogramming. But i am far away to be an expert on this topic.
cpp,3au307,Gorebutcher666,1 point,Wed Jun 24 11:58:31 2015 UTC,"I agree. I had to take a few breaks while watching his talk to keep focused, but I still found it very interesting to watch. It's good to know that people at the C++ Committee are thinking about adding cool TMP features into the standard."
cpp,3au307,LordAro,1 point,Tue Jun 23 19:36:28 2015 UTC,"The Fibonacci example is broken - not sure where the _2 stuff comes from, but it's not necessary"
cpp,3aqjr7,haris3301,22,Mon Jun 22 18:20:56 2015 UTC,"Ok I took time off from my delivery tomorrow. Took one hour to table up those. HOPE YOU APPRECIATE THAT :)  The test loops through sizes 1 up to 512 in powers of two. For each size, it forks a separate process and allocates a vector of 1M pointers. Then it starts by calling malloc() on all of them, then realloc() for a size 2x bigger and finally free().   I measure all these calls with a RDTSC, of course taking care of all the pitfalls following Intel instructions. Also I take steps to avoid out-of-order execution by both compiler and processor, discounting ""dead time"", ie time to actually execute the timing instructions (RDTSC, RDTSCP, CPUID).   All results in clock cycles.  For the first batch, I used a pretty old AMD Phenom 2 running Ubuntu 14.04.2 LTS kernel 3.13.0, glibc 2.19, gcc 4.8.4.   First set, I allocate all vectors in a serial manner, ie with a loop ( j=0; j<N; ++j ). Results:      Pattern: SERIAL           |  Alloc    | Realloc   | Free      |     Size  | Avg | Med | Avg | Med | Avg | Med |         -------------------------------------------     1     | 40  | 1   | 5   | 1   | 2   | 0   |         2     | 131 | 90  | 58  | 51  | 42  | 37  |     4     | 131 | 90  | 58  | 51  | 42  | 37  |     8     | 131 | 91  | 58  | 51  | 41  | 37  |     16    | 132 | 92  | 203 | 150 | 44  | 37  |      32    | 162 | 102 | 236 | 163 | 49  | 39  |     64    | 214 | 114 | 312 | 192 | 215 | 146 |      128   | 299 | 116 | 594 | 415 | 325 | 277 |      256   | 462 | 122 | 897 | 558 | 407 | 280 |     512   | 777 | 117 | 1450| 805 | 499 | 294 |   On the second set, I allocated the vectors in random order to kill all possible cache read-ahead effects. Results:      Pattern: SHUFFLE           |  Alloc    | Realloc   | Free      |     Size  | Avg | Med | Avg | Med | Avg | Med |         -------------------------------------------     1     | 132 | 91  | 144 | 208 | 47  | 42  |         2     | 133 | 92  | 142 | 208 | 43  | 38  |     4     | 134 | 92  | 148 | 209 | 43  | 39  |     8     | 133 | 92  | 145 | 209 | 46  | 41  |     16    | 133 | 92  | 303 | 250 | 45  | 38  |      32    | 165 | 103 | 348 | 274 | 53  | 42  |     64    | 216 | 115 | 438 | 320 | 213 | 142 |      128   | 298 | 117 | 711 | 538 | 321 | 270 |      256   | 459 | 129 | 1027| 693 | 409 | 281 |     512   | 770 | 117 | 1586| 943 | 495 | 291 |   What is interesting is that usually the average is higher than the median, which indicates normal spikes of high duration on the samples. However on this batch for realloc() with SZ<16 the median is larger. Digging into the stats, I see a double mode pattern. For example for realloc/SZ=1:  32-64 cycles: 42.2% 64-128 cycles: 2.3%  128-256 cycles: 50.8% 256-512 cycles: 4.2%    Ie the majority of the samples take 208 cycles but a distinct group - ~40% of them - take much less, I'd guess ~60 cycles.  For the second batch, I used a newer Haswell i7-5820k (hyperthreading enabled) on Ubuntu 14.04.2 LTS kernel 3.16.0, glibc 2.19, gcc 4.8.4.       Pattern: SERIAL           |  Alloc    | Realloc   | Free      |     Size  | Avg | Med | Avg | Med | Avg | Med |     -------------------------------------------     1     | 94  | 54  | 1   | 1   | 1   | 1   |     2     | 84  | 58  | 44  | 43  | 30  | 30  |     4     | 85  | 58  | 41  | 40  | 20  | 20  |     8     | 76  | 52  | 40  | 39  | 28  | 28  |     16    | 76  | 52  | 118 | 91  | 28  | 28  |     32    | 88  | 52  | 134 | 93  | 31  | 28  |     64    | 111 | 52  | 174 | 95  | 79  | 47  |     128   | 155 | 51  | 243 | 145 | 316 | 279 |     256   | 248 | 51  | 349 | 162 | 348 | 275 |     512   | 430 | 51  | 655 | 249 | 408 | 280 |      Pattern: SHUFFLE           |  Alloc    | Realloc   | Free      |     Size  | Avg | Med | Avg | Med | Avg | Med |     -------------------------------------------     1     | 87  | 57  | 101 | 95  | 14  | 13  |     2     | 77  | 52  | 120 | 92  | 29  | 28  |     4     | 77  | 52  | 163 | 95  | 29  | 28  |     8     | 77  | 52  | 115 | 92  | 29  | 28  |     16    | 77  | 52  | 221 | 182 | 31  | 28  |     32    | 89  | 52  | 332 | 330 | 45  | 28  |     64    | 112 | 52  | 403 | 364 | 88  | 47  |     128   | 155 | 50  | 466 | 359 | 320 | 274 |     256   | 248 | 51  | 613 | 415 | 348 | 275 |     512   | 428 | 51  | 963 | 635 | 407 | 280 |   As one can see, times in general improved quite substantially as expected. Struck me that on the newer Haswell the cache effects were much less noticeable.  EDIT: I quickly ran the same tests with a memory pool - I think that was proposed on one of those C++ books, I think Exceptional C++ or Modern C++. For shuffle/512 I get  alloc: 50 avg, 2 med  realloc: 59 avg, 4 med  and free: 9 avg, 1 med.  (In this approach realloc is a free followed by an alloc). So glibc's alloc/realloc/free are really orders of magnitude more expensive than what you can do yourself implementing your own allocators.  ANOTHER EDIT: Dang, I just realized the article's central point was for LARGE realloc's so I just ran another batch with the newer Haswell and in serial mode, now for blocks 1k up to 256M. Results:      Pattern: SERIAL           |  Alloc    | Realloc   | Free      |     Size  | Avg | Med | Avg | Med | Avg | Med |     -------------------------------------------     1024  | 800 | 57  | 1382| 672 | 536 | 292 |     2048  | 1520| 2922| 2526| 3008| 802 | 314 |     4096  | 3028| 2939| 5076| 6721| 1320| 339 |     8192  | 3094| 2972|10419|10432| 2327| 447 |     16384 | 3184| 3010|20833|20833| 3703| 435 |     32768 | 3263| 3062|40868|40868| 6229| 514 |     65536 | 3437| 3155|81491|81491|11704|11807|     131072| 4021| 3750| 4547| 7281| 3257| 3063|     262144| 4031| 3808| 4548| 7383| 3290| 3078|     524288| 4117| 3935| 5182| 8492| 3571| 3314|    1048576| 4261| 4243| 5171| 8878| 3987| 3727|    2097152| 5815| 4638| 6727|11743| 5887| 5387|    4194304| 5669| 4574| 6747|11885| 6031| 5565|    8388608| 4415| 4415| 5949|10851| 5306| 5306|   16777216| 4158| 4118| 5930|10859| 5481| 5481|   33554432| 4500| 4021| 6006|11031| 5655| 5655|   67108864| 4256| 4075| 6453|11952| 6023| 6023|  134217728| 4457| 4070| 7354|13723| 7428| 7428|  268435456| 5152| 4111| 9233|17378| 9175| 9175|   I think the 128kb threshold is pretty evident in these tests.   UPDATE: checked with the glibc folks, ends up you can tweak this parameter with something like   #include <malloc.h>  mallopt (M_MMAP_THRESHOLD, 8*1024);   This brings the peak down a lot. Here are the new results: imgur  Questions/comments?"
cpp,3aqjr7,fritzroid,3,Tue Jun 23 02:39:01 2015 UTC,"David • a year ago  Now I am looking forward to know wether std::vector in C++ uses realloc or resorts to the poor-man copy, anyone has dug there ?      Xavier Roche Mod  David • a year ago  Haha. No. Not even in your dreams. The C++ committee seems to be more interested in allowing turing complete template metaprogramming and lambda functions. But you still can not reallocate an array of objects (even of base types) in 2014. (I'm sure I'm going to be flamed for that)   Is this really true? Shouldn't the STL implementers make use of realloc? :("
cpp,3aqjr7,ThisIs_MyName,6,Tue Jun 23 10:39:21 2015 UTC,"It is true that this is very unlike to happen, realloc copies memory, doesn't call copy constructors, could possibly do this with POD but not a pretty thing to handle.  If you want some useful stuff which hasn't made it into the C++ standard checkout   N2045: Improved STL Allocators N2271: EASTL -- Electronic Arts Standard Template Library   While I havne't used EASTL based on what I've seen online from performance comments it definitely looks nice to use. (However licensing could screw you over)"
cpp,3aqjr7,ReDucTor,0,Tue Jun 23 13:32:14 2015 UTC,looks pretty dated - 2007 Some of the ideas there are interesting like intrusive lists. But nothing that popped up and blew my mind. Will look again though but I believe EA took it offline. I found a clone on github though.
cpp,3aqjr7,fritzroid,1 point,Tue Jun 23 18:20:01 2015 UTC,"I think the STL - as implemented by gcc and clang - does an amazing job within the constraints of the language, requirements (reentrancy, thread-safe, completeness) and the multiple platforms it has to support.   I have to confess that given the needs of my industry (HFT/trading), I barely use std::vector from all STL. std::map and std::unordered_map only in reports or other non-critical applications.  That said, there is plenty of room for improvement if you specialize on an algorithm and on platform or throw away some reentrancy or thread-safe requirements (which we do). But that would require a new ""STL2"" interface.   I think it is as good as you get as it is right now."
cpp,3aqjr7,fritzroid,9,Tue Jun 23 11:23:14 2015 UTC,"If I post some real numbers, would I get severely downvoted?"
cpp,3aqjr7,fritzroid,13,Mon Jun 22 23:33:08 2015 UTC,"Maybe if those numbers are unrelated to the topic of the article. Like, if you just posted ""523"", then yeah. But some benchmarks would be great."
cpp,3aqjr7,minno,7,Tue Jun 23 00:02:17 2015 UTC,Benchmark posted
cpp,3aqjr7,fritzroid,3,Tue Jun 23 02:46:47 2015 UTC,very interesting. thanks!
cpp,3aqjr7,wfpoulet,3,Mon Jun 22 20:00:00 2015 UTC,Throwing in a graph with the results.
cpp,3aqjr7,fritzroid,-6,Tue Jun 23 12:29:34 2015 UTC,"Hmm, posted to /r/cpp even though the allocator interface doesn't have a ""realloc"" function, so standard containers won't have this behavior. And couldn't for non-POD types anyway.  Edit: Yeah, this sounded snide. Other comments go into more detail."
cpp,3aqm1q,vlovich,18,Mon Jun 22 18:38:10 2015 UTC,You're going to incur the structure padding one way or another due to the alignment of the larger type: http://ideone.com/ubKV6Z  The reason for not having a special templated version for types with a sentinel value is because the whole point of optional is to avoid sentinel values -- if sentinel values solve the problem then there's no reason to use optional.
cpp,3aqm1q,astraycat,11,Mon Jun 22 19:23:28 2015 UTC,"Well, optional does throw an exception when trying to use an uninitialized value whereas a sentinel will not.  In addition to that, an optional<> is a clearer way to express intent & provides a more elegant API (i.e. value_or)."
cpp,3aqm1q,londey,7,Mon Jun 22 19:42:56 2015 UTC,"Only optional .value() throws. The dereference accessors do not. I ran into this using boost optional a few months ago.  ""The behavior is undefined if this does not contain a value"" http://en.cppreference.com/w/cpp/experimental/optional/operator"
cpp,3aqm1q,doom_Oo7,2,Mon Jun 22 20:40:46 2015 UTC,So actually only the STL optional is guaranteed to throw.   Boost defines it as undefined behavior (which surprised me too).  I agree that the dereference operators don't throw and the reason for that makes sense: you may have already verified that the optional is not so you need a way to unwrap it without the overhead of a check.
cpp,3aqm1q,Houndie,2,Mon Jun 22 21:32:40 2015 UTC,Boost defines it as undefined behavior   http://www.boost.org/doc/libs/1_58_0/libs/optional/doc/html/boost_optional/reference/header__boost_optional_optional_hpp_/detailed_semantics.html#reference_optional_operator_asterisk  There is an assert in there.
cpp,3aqm1q,doom_Oo7,2,Tue Jun 23 12:44:14 2015 UTC,"IMO I like having the assert there, rather than throwing.  I get all the nice debug-time checks to make sure my code doesn't suck, and no run-time checks when I fix all my bugs :-)"
cpp,3aqm1q,astraycat,3,Tue Jun 23 12:53:58 2015 UTC,I like it too. Code should crash as quick as possible when something goes wrong.
cpp,3aqm1q,astraycat,1 point,Tue Jun 23 15:02:27 2015 UTC,Correct.  It is typically disabled when compiling with NDEBUG (i.e. release).  The behaviour of calling * on an uninitialized state is undefined.
cpp,3aqm1q,Plorkyeran,1 point,Tue Jun 23 16:46:09 2015 UTC,I made a mistake.  boost::optional::value does throw.  Not sure why I thought it doesn't.
cpp,3aqm1q,astraycat,3,Tue Jun 23 17:28:42 2015 UTC,"It's safer and more elegant to be sure. But it's not necessary if your function can work with just a sentinel value. Either way you have to check to see if the value is valid, and as you've pointed out, optional<T> is not as optimal as a sentinel value."
cpp,3aqm1q,Kyyni,4,Mon Jun 22 19:48:48 2015 UTC,"However optional encapsulates the logic to guarantee that I can never access a sentinel value (i.e. an exception will be thrown).  Significantly reducing the number of ""is valid"" checks throughout the code means fewer opportunities to make a mistake."
cpp,3aqm1q,doom_Oo7,1 point,Mon Jun 22 20:13:17 2015 UTC,"You still have to do the little dance of if(value) {} each time you use optional, which is equivalent to the amount of work you have to do to check a sentinel value.   You're certainly not going to try{}catch{} around it instead are you?  Think about it this way: sometimes you want to put up a nice picture of your family. You get a frame, commit a nail to the wall, and hang your picture. Sometimes you just want to put up a neat poster in your dorm room. You just tape that shit to the wall. Framing and hanging it is superior in every way except that you don't need any of that for a poster in your dorm room.  If you need the features provided by optional<T>, then use optional<T>. But don't just use a tool because you can -- use it because it actually meets the requirements of your problem in a way that a simpler tool cannot."
cpp,3aqm1q,gnzlbg,6,Mon Jun 22 20:57:55 2015 UTC,Throwing an exception rather than silently doing the wrong thing is a much better failure case for when you do forget to check it.
cpp,3aqm1q,o11c,3,Mon Jun 22 21:23:14 2015 UTC,"Well, according to /u/londey's comment, it only throws if you use it right. I agree though -- it's a better failure case. However, you don't always need that sort of error checking.  As an aside, I always feel like exceptions should be used for errors in user input rather than errors made by developers (those should be asserts, IMO). But that's a wholly different debate."
cpp,3aqm1q,OldWolf2,2,Mon Jun 22 21:32:57 2015 UTC,"Also, the expected execution path of your program probably shouldn't throw any exceptions, they should be, well, for exceptional situations. You pay just about zero performance cost for them as long as they aren't thrown, but once they are, performance will be butchered. Not that it really matters in small use cases, but still."
cpp,3aqm1q,OldWolf2,1 point,Tue Jun 23 07:53:46 2015 UTC,"The Knuth truism applies here.  It seems like a premature optimization to worry about the performance cost of asserts.  The cost of validating the state is minimal; you can apply __builtin_expect upfront to optimize the compiler, LTO + PGO when it really matters to get larger gains, & use instrumentation if a particular assert is actually a hotspot.  In other words the tradeoff, at least for me, is to know that my code will crash when it reaches a bad state.  That way I can usually debug the problem in 5 minutes instead of scratching my head because the program crashed later or corrupted memory or anything else due to UB.    Now logging is a different matter & is quite trickier because the costs there are really hard to avoid."
cpp,3aqm1q,tisti,1 point,Tue Jun 23 16:22:12 2015 UTC,"If you need the features provided by optional<T>, then use optional<T>. But don't just use a tool because you can -- use it because it actually meets the requirements of your problem in a way that a simpler tool cannot.   I think that an important thing in optional is that it can help to make the difference with non-optional values.  For instance, if I consistently use optional<> for...well... optional values in my code, then when I see a raw pointer member (like that legacy FILE*) I know for sure that it should never be null after construction."
cpp,3aqm1q,OldWolf2,1 point,Wed Jun 24 08:20:32 2015 UTC,std::experimental::optional is designed for the case in which there is no sentinel value; you can always write your own optional-like wrapper for your particular use-case with a sentinel value.
cpp,3aqm1q,tisti,5,Mon Jun 22 21:44:12 2015 UTC,"if sentinel values solve the problem then there's no reason to use optional   Absolutely wrong. There are a lot of cases where you want something like optional<T *>, optional<fd_t>, etc.  Integration with existing libraries is hugely essential to avoid frameworkization."
cpp,3aqm1q,Plorkyeran,6,Tue Jun 23 04:55:29 2015 UTC,Having the bool after the struct wouldn't make any difference to the total amount of space used; the bool can't live inside the trailing padding area of the struct.   It's meant to be a wrapper for having a value plus a flag to indicate if that value is valid or not.
cpp,3aqm1q,tisti,5,Mon Jun 22 19:41:40 2015 UTC,That is correct & explains why it's up to a sizeof(void *) extra.  Do you have any insight into why sentinel values aren't supported?
cpp,3aqm1q,tisti,3,Mon Jun 22 20:14:35 2015 UTC,"Obviously, the general case cannot have sentinel values because all possible values of the type might be valid.  I guess you could write your own specialization for your own types that uses a sentinel value."
cpp,3aqm1q,tisti,3,Mon Jun 22 21:04:16 2015 UTC,"No obviously it cannot in the general case.  However, specializing it myself:  A) requires re-implementing optional which is a non-trivial proposition B) doesn't work with primitive/builtin types (eg double)  If there was another template parameter that defined what initialized:uninitialized look like, you could have the flexibility to define it at the call-site for any type without a lot of complexity."
cpp,3aqm1q,OldWolf2,0,Mon Jun 22 21:36:15 2015 UTC,Becaues the standard defines this for optional   The initialization state of the contained object is tracked by the optional object.   making sentinal values a moot point.
cpp,3aqm1q,STL,2,Mon Jun 22 21:00:13 2015 UTC,What standard? It's not part of ISO C++.
cpp,3aqm1q,OldWolf2,2,Mon Jun 22 21:03:41 2015 UTC,The ISO C++ standard.  I'm looking at page 503 of the N3690 draft of the C++14 ISO standard.
cpp,3aqm1q,STL,3,Mon Jun 22 21:13:05 2015 UTC,It was cut from the final version of C++14.
cpp,3aqm1q,OldWolf2,1 point,Mon Jun 22 21:24:02 2015 UTC,"Ninja edited the reply, should give a better example why optional can't have zero-cost sentinal functions, since they would cause the class to behave radically different under the same conditions."
cpp,3aqm1q,tisti,1 point,Mon Jun 22 22:34:11 2015 UTC,"Hm, then this I'd guess?  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3848.html#optional.general  Not sure, seems existing implementations follow the cut optinal text I posted. Plus, sentinals are a can of worms if you ask me. A NaN may be a sentinal value to you, but to someone else it may be a meaningful result.  To solve this, you'd have to injecting sentinal detection code into optional via a template, since there are no valid defaults for built in types.  Ninja edit:  It may be that you are looking for a different class? Optional, as it is now, is pretty clear in that it only is interested whether the stored type has been initialized or not. What about this far fetched example:  auto foo(){    auto val = std::optional<super_complex_class_type, complex_sentinel_function>{}; //no bool flag, just a inlinable function that check the value    ...code which does not assign/initialize a value to val...    return val; }  //Uh oh, got an uninitialized sential guarded optinal auto foo_result = foo();  //What is the correct thing for the sentinel check function to do here? //Seems like a case of undefined behaviour, which was *not* present before with the bool guard. if(foo){     cout << *foo; }    Using a sentinal guard causes optional to be undefined, while with the initializtion flag it would have been safe. Two wholy different behaviours.   The only proper solution for this is a whole new class, where it is clear that it must be initialized, so that the sentinal function does not cause undefined behaviour."
cpp,3aqm1q,cdglove,1 point,Mon Jun 22 21:56:10 2015 UTC,"I did say ""domain-specific knowledge"".  In the general case I'm perfectly OK with the existing implementation.  However, why cannot I specialize std::optional with something like std::optional<double, my_invalid_state> where my_invalid_state is the empty-object & validates state by asserting NaN?  This lets me apply domain-specific optimizations at 0 cost to the API, runtime or complexity of the normal case.  Having to specialize std::optional for optimizations is:   cumbersome since the API footprint is large tricky since the implementation has pitfalls for novices impossible to apply to built-in types like double"
cpp,3aqm1q,OldWolf2,1 point,Tue Jun 23 16:25:58 2015 UTC,"Because under your proposal std::optional has become something utterly different. When supplied with a sentry function it will no longer keep track if the stored data has been initializer or not. What this now implies is that the initialization of data no longer optional, but mandatory, making the class name and its purpose missleading. If the data is not initialized and the sentry function is called on uninitilized data you have undefined behaviour. Even with doubles.   If you want a helper class that does value validation, you need a totally new class than std::optional. Shoehorning functionality where it does not belong will not end well. Case in point, the std::vector<bool> optimization, where its behaviour differs from other vector<T> types all for the sake of optimization (granted bigger than what you are proposing)."
cpp,3aqm1q,cdglove,1 point,Tue Jun 23 20:50:33 2015 UTC,"it will no longer keep track if the stored data has been initializer or not   Why do you say that?  Please don't take my code-snippet as the end-all be-all of such a customization point.  It was just meant to be illustrative of what a customization point might look like.  I don't see that you've pointed out any fundamental unsolvable problem with having a customization point but I'm probably misunderstanding what you're saying.   Case in point, the std::vector<bool> optimization, where its behaviour differs from other vector<T> types all for the sake of optimization   The problem with vector<bool> is that they shoe-horned a bitset implementation under-the-covers, the API for vector doesn't lend itself to bitset & you can't avoid it.  Of the three, the middle one is the biggest problem (i.e. the API impedance mismatch).  In this proposal, this is still an optional, the exposed API still makes perfect sense, & it's an opt-in mechanism to apply domain-specific knowledge as an optimization.  I'm not sure I understand why you're having such a visceral reaction."
cpp,3aqm1q,tongari95,2,Tue Jun 23 21:21:52 2015 UTC,N3690 is not the ISO standard. optional is not in any ISO C++ standard. It appeared in some drafts and was removed again. Consult N3936 to see what is actually in C++14.
cpp,3aqm1q,newmewuser4,2,Tue Jun 23 02:04:29 2015 UTC,N3936 wasn't C++14 either. That was N4140/N4141.
cpp,3aqm1q,Causeless,2,Tue Jun 23 06:06:13 2015 UTC,N3936 has the same text as C++14 (to my understanding) -- unless you are aware of any differences?
cpp,3aqm1q,Kyyni,3,Tue Jun 23 08:37:54 2015 UTC,"See the editor's report - there were editorial fixes, including a normative editorial fix (!) caused by several constexprs in the transparent operator functors having been dropped on the floor originally and restored just in time for the final Standard."
cpp,3aqm1q,Kyyni,2,Tue Jun 23 08:56:37 2015 UTC,"STL: any thoughts on why an additional template parameter defining the empty state would be a bad addition?  I'm thinking of writing up a proposal but I'm sure I'm missing something.  Something like std::optional<T, S> where S holds the empty state & sizeof(std::optional<T, S>) == sizeof(T) iff std::is_empty<S>?  S would be defined to have a member function like is_valid that takes a const T*.  The nominal implementation of std::optional could just apply the empty base-class optimization & inherit from S directly or store everything in a std::tuple."
cpp,3aqm1q,tjgrant,1 point,Tue Jun 23 16:31:09 2015 UTC,"OK, thanks"
cpp,3aqm1q,OldWolf2,2,Tue Jun 23 09:06:20 2015 UTC,"Yea, got the wrong working draft. Will need to purchase the ISO one I guess."
cpp,3aqm1q,snowhawk04,-2,Tue Jun 23 07:37:35 2015 UTC,"This is incorrect. Consider the following  struct { int i; short s; }   This struct will require 4 byte alignment, but it has two bytes of slack space that can be used when when placed inside another struct. If we assume that most things stored in an optional have stricter than one byte alignment, as above, and are likely not sized as an integer multiple of that alignment, then it will generally be better to be ordered as T followed by bool, if we only consider space requirements.   This is a good general rule of thumb; when ordering structs, sorting by largest to smallest will give a good baseline packing; maybe not 100%, but very good.    Of course, there are other considerations such as having the bool at the leading edge might put it at the front of the cache line, which is desirable if the validity check is frequent, etc.   Edit: My example is wrong because sizeof() needs to be a multiple of 4. Trying to come up with a better example, but it could be that I'm just wrong..."
cpp,3aqm1q,raghar,6,Tue Jun 23 03:14:05 2015 UTC,The trailing padding is part of the struct's size. It has to be that way because there is no padding in an array; sizeof(T[2]) has to be 2 * sizeof(T).  If your system has int alignment then your sample struct's size will be 2 * sizeof(int).
cpp,3aqm1q,raghar,1 point,Tue Jun 23 03:29:35 2015 UTC,"Yes, it seems I can not come up with an example where there's any difference between bool first and bool last. I think this is because there's only two objects; it takes a third to introduce the possibility of more optimal ordering."
cpp,3aqm1q,raghar,1 point,Tue Jun 23 11:07:31 2015 UTC,"It does matter in some cases, depending on your compiler: https://plus.google.com/111825405052388689490/posts/5knfu9psJR7"
cpp,3aqm1q,raghar,6,Tue Jun 23 14:29:26 2015 UTC,"Don't be the bean counter worrying about cents while at the same time losing millions.     2x space overhead       Actually the typical overhead should be sizeof( void* ) - 1 because data structure alignment. Also having the bool declared before the returning type allows deterministic relative position of the bool, at position 0, and the returning type, at a typical position of sizeof( void* ) because data structure alignment."
cpp,3aqm1q,CptBread,5,Mon Jun 22 19:27:03 2015 UTC,"Don't be the bean counter worrying about cents while at the same time losing millions.   Not sure if you're trolling, but the overriding philosophy of C++ (at least as espoused by lots of people in the community & prominent members of the standards body) is to provide 0-overhead abstraction.  If it doesn't there should be some pretty good justification.   Also having the bool declared before the returning type allows deterministic relative position of the bool, at position 0, and the returning type, at a typical position of sizeof( void* ) because data structure alignment.    Can you clarify why these are valuable properties?  I concur that the padding is the same regardless of where the bool is declared."
cpp,3aqm1q,CptBread,8,Mon Jun 22 20:06:27 2015 UTC,0-overhead abstraction is the language philosophy. The philosophy of libraries (including the standard library) and of compilers is completely separate.
cpp,3aqm1q,jasonthe,1 point,Mon Jun 22 22:24:52 2015 UTC,"The returning type could have variable size Different returning types can have different size, so having the bool before it gives both a constant starting point in memory, instead of having to hunt down the bool by first getting the size of the return type.  Or something like that."
cpp,3aqm1q,OldWolf2,2,Tue Jun 23 07:58:27 2015 UTC,Can you give an example of a returning type with variable size? AFAIK there is no such case in standard C++ (in case you're thinking about C VLA which are not part of the standard).
cpp,3aqm1q,jasonthe,2,Tue Jun 23 16:33:34 2015 UTC,"No, I can't, because that isn't a thing. I have no Idea what I was smoking when I wrote that.  But still, it does give constant starting points between different return types, so there's that. Not that it's a big deal anyways, but getting the points doesn't require computing sizeof(big_honking_return_type) internally."
cpp,3aqm1q,OldWolf2,1 point,Tue Jun 23 18:01:04 2015 UTC,"Also having the bool declared before the returning type allows deterministic relative position of the bool, at position 0[...]   Ah makes perfect sense when you think about what might be happening at the compiler, assembler, or hardware level.  In fact I'd imagine this allows for some optimization at the hardware level for the cache, branching, and I'm sure other optimization a when you know your first element is going to be a flag.  All of this is so non-obvious though."
cpp,3aqm1q,jasonthe,2,Tue Jun 30 05:12:55 2015 UTC,According to the docs it does not seem to be specified that boost::optional must be implemented in any particular way.  One suggestion was to use a Boost::Variant with a null type option. Are you just referring to some particular compiler/library's choice of implementation?
cpp,3aqm1q,OldWolf2,2,Mon Jun 22 21:05:07 2015 UTC,"There is no reasonable way to implement optional without some kind explicit initialized/uninitialized state.  However, domain-specific knowledge can often be used to alleviate this problem."
cpp,3aqm1q,jasonthe,2,Mon Jun 22 21:37:29 2015 UTC,"From the boost::optional Design Overview:   A variant<T,nil_t> follows naturally from the traditional idiom of extending the range of possible values adding an additional sentinel value with the special meaning of Nothing. However, this additional Nothing value is largely irrelevant for our purpose since our goal is to formalize the notion of uninitialized objects and, while a special extended value can be used to convey that meaning, it is not strictly necessary in order to do so.  The observation made in the last paragraph about the irrelevant nature of the additional nil_t with respect to purpose of optional<T> suggests an alternative model: a container that either has a value of T or nothing.   As for the initialized bool coming before the storage, it likely has to do with keeping the most accessed members at the start of a class record."
cpp,3aqm1q,OldWolf2,1 point,Mon Jun 22 23:35:02 2015 UTC,"The reason is that originally the reason for creating std::optional/boost::optional/maybe/Option in many languages is to:   provide well defined behavior of values that could be in some way absent (monadic laws) - usage of sentinel value would create sort of gap in type system, division into correct and incorrect values which would change the whole meaning of what is semantic meaning of on optional type, provide nice interface to achieve goal above.   Example: you have a collection of doubles, some of them might be NaNs, some might be infinity. You want to find a value basing on some predicate - you cannot rule out that predicate would be true for NaN or infinity. You run find on the collection and it return std::optional<double>. Have you provided sentinels some completely valid values (from the point of predicate) would create ""noting found"" result.  Now, what when you want to use some type and use sentinels to indicate... something? Then you actually create new type - e.g. double with NaN as would create double \ { Nan } type - which might be completely legitimate use case BUT of completely different semantic meaning and assumptions. Using optional in such way would be confusing and could easily spawn hard to detect bugs as in find example, because at this point optional type is not a wrapper for nullptr but has a meaning attached to it.  So for the sake of avoiding ambiguity and bugs resulting from it, optional type is defined as it was, and what you ask for should be defined under different name, to explicitly state what one can expect from it.  EDIT:  On a side note: for what you want to achieve you might want to try to implement specific Either monad modification. Either was two fields - left and right and could be understand as some sort of double optional where exactly one of them has value. With C++ you could try to pull off some microoptimization using union and in case type of left and right matches and where value lands is decided on e.g. being a sentinel (you know, SFINAE, template metaprogramming) you could avoid using additional variable for marking valuee left/wright. You would achieve something much closer to what you want BUT without abusing the semantic meaning of type you used."
cpp,3aqm1q,jasonthe,2,Mon Jun 22 21:21:45 2015 UTC,Perhaps a more concrete example might solidify things for me.  All I'm saying is that perhaps it makes sense to have a template parameter that defines the initialized/uninitialized state.  Then a user could override it to get domain-specific optimization.
cpp,3aqm1q,OldWolf2,1 point,Mon Jun 22 21:39:10 2015 UTC,"Basically problem boils down to expectations and assumptions - with optional people expect the type to potentially contains all possible values of embedded type and use it assuming so.  But with either you explicitly state that value belongs to one of two domains. For instance:  either<Error, double> result = someOperation(); // by convention ""right"" result is ""the right one "";) if (result.hasRight()) {   // code for double } else {   // code for error }   It would obviously need to store one of two possible values and indicate somehow which one it has. One way to optimize space would be to store both of them in an union (if this is possible - AFAIK this can be checked with template metaprogramming, some predicates should already be defined in either boost or std in newer versions of C++).  But that doesn't get rid of left/right indicator. Let's say however that our templates declaration is something like this:  // for clarity I skipped SFINAE checking whether L and R can be packed into the union but final version should do that template < class L, class R, Pred<L> predicate = defaultPred<L> > class either;   Then you could do some optimization:  template < class LR, Pred<L> pred > class either<LR, LR, pred>{   // ...    bool isRight() const {     return pred(value_);   }    // ...   private:   LR value_; };   Then you could just us it like:  bool sentinelCheck(double value) { return  }  typedef either<double, double, sentinelCheck> guarded_double;  guarded_double value = getSomeResult(); if (value.isRight()) { // function passed in as template argument is used - no overhead for additional variable   // code for valid value } else {   // code for sentinel value }   Main difference here is in people's expectations about both types - in optional people expect any value of a wrapped type indiscriminately or no value at all. With either people expect that there is some sort of distinction. Functional programming use it to avoid throwing exceptions - you simply return left value and when you use map or flatMap it remains unchanged and keep on indicating that error occurred and needs to be taken care of (and you still have the access to the value describing said error). Sentinels are within expectations - you simple make some distinction on right and wrong values, and in case when their type happen to match and some predicate can assign value to the left/right domain, you can use that knowledge to avoid overhead."
cpp,3aqm1q,14ned,2,Mon Jun 22 22:35:42 2015 UTC,"I'm not sure why you're adding all this complexity.  struct default_optional_state {     template <typename T>     inline bool is_initialized(const T*) const { return _initialized; }     inline void set_initialized(bool initialized) { _initialized = initialized; }     bool _initialized = false; };  template <typename T, typename S = default_optional_state> class optional { private:     std::tuple<S, storage_t<T>> _data; };   So the semantics of optional<T> in the general case remain.  However, I can now do:  struct nan_optional {     bool is_initialized(double v) { return !std::isnan(v); }     void set_initialized(bool initialized) {} };  std::optional<double, nan_optional> foo; static_assert(sizeof(foo) == sizeof(double), """");   Now in 4 extra lines of code I have managed to attain a std::optional that has the same space requirements as a double which makes it a more convenient drop-in for existing code without worrying about performance and you don't have to hand-code any checks anywhere since the compiler enforces it.  Arrays of optional are 0-overhead, you can have an optional member variable in a structure that comes from a memory mapped file, etc."
cpp,3aqffi,mttd,3,Mon Jun 22 17:48:34 2015 UTC,The answer to the first part (why does Ninja provide a bigger boost in Debug vs Release builds) is that since wall-clock time is being measured debug builds are faster so the overhead of the build system is going to be more pronounced.  In release builds most of the time is spent in the compiler so you won't see as much of a benefit.
cpp,3aqffi,vlovich,3,Mon Jun 22 19:12:12 2015 UTC,Using cotire also speeds up cmake-based builds a helluva lot. It's especially cool with unity builds... On travis CI we went from about 25 minutes to 3 minutes for our build with it.
cpp,3aq2iu,14ned,9,Mon Jun 22 16:11:53 2015 UTC,Is there a copy that doesn't require using an untrusted connection?
cpp,3aq2iu,pfultz2,2,Mon Jun 22 16:36:30 2015 UTC,"Also why is it on svn? Didn't boost move over to git and github? Most/all the boost libraries and examples you link to seem to be on github, so why not put the best practices page on github too? It seems a bit weird."
cpp,3aq2iu,Raphael_Miedl,6,Mon Jun 22 18:21:16 2015 UTC,"Technically it's not on ""svn"", svn is a version control software.  It's on a physical server somewhere on the interwebs with the domain name ""svn.boost.org"" pointing to it, which is simply a name and by itself has no relation whatsoever to the version control software (although I think we can probably infer that this same physical server once held the svn software sever).  This is simply a webpage."
cpp,3aq2iu,Houndie,0,Mon Jun 22 18:35:33 2015 UTC,"The old Trac wiki and issue tracker originally installed for svn is still in heavy use, including for wiki pages such as the Best Practices Handbook. We are currently deciding whether to upgrade it from v0.12 to v1.0 in order to make it git and github compatible, or replace it entirely with something different. That particular committee will likely report in Sept, and again in May 2016. Action may happen sometime thereafter."
cpp,3aq2iu,pfultz2,0,Mon Jun 22 19:14:23 2015 UTC,"Due to some personnel changes, the Boost server with the SSL cert is currently inaccessible to us. We have a new cert, just no way of installing it without replacing the server. As servers cost money, the longest possible period is being given to reacquiring access to that server. Hence the ~3 month wait, and it'll probably be 6 months before any drastic action is taken."
cpp,3aq2iu,STL,2,Mon Jun 22 19:11:35 2015 UTC,Wiki pages can be created on github as well. So this could be posted there for easier access until the SSL problem is corrected.
cpp,3aq2iu,ThisIs_MyName,3,Mon Jun 22 19:18:00 2015 UTC,"Firstly, github's markdown is not trac markdown. The conversion is non-trivial.  Secondly, the web presence committee is tasked with converting all the content from the existing website and trac to whatever the new platform they choose. Content, and issues on github are not included. Indeed, though nothing is currently ruled out, my best understanding is that the direction will be less github, not more github. Github isn't trusted.  Thirdly, the SSL cert problem is not a problem apart from that it looks bad. No security problems result, and no one is trying to M2M Boost's trac server as there is no point. I'd worry far more about the antiquated trac install on there and general - approaching total in some places - lack of infrastructure maintenance. Heartbleed for example was entirely ignored at the time, though I am told we were running such an ancient OpenSSL library it didn't matter, but my point is that we couldn't have responded quicker than in a few weeks even at best effort speeds.  I have advocated hiring a full time employee dedicated exclusively to infrastructure and maintenance, but Boost is very conservatively managed. By past standards, it takes about two years from arguing an idea to them accepting it."
cpp,3aq2iu,ThisIs_MyName,2,Mon Jun 22 23:30:59 2015 UTC,Servers are so cheap these days as to be practically free. My Linode is $20/mo and I'm pretty sure it'd be more than enough to handle Boost's usage. (I used to pay $325/mo for a Rackspace dedicated server.)
cpp,3aq2iu,lurkotato,1 point,Tue Jun 23 06:20:07 2015 UTC,"Most of the cost of replacing the server is not the rental, in fact Boost typically gets its servers for free as part of its university support and the Software Freedom Conservancy! Firstly, one off payments have a much simplified procedure over recurring payments, the latter have to go through US charity law validation procedures, and that's all compliance stuff undertaken by the SFC etc. In other words, it's a big ball to start rolling which takes a while to get there, and you try to avoid rolling it if you can. Secondly, those on the steering committee have exceptionally little free time as compared to back when Dave took up all the slack which he could as a consultant and could allocate his time as he saw fit between contracts. As someone would need to do the replumbing to swap that server, and volunteers for that type of role are very light on the ground or else are not trusted/liked by the committee, that means someone on the committee would have to do it and they all have higher priorities (after all, it's just an expired SSL cert, it doesn't really matter apart from appearance).  BTW I've never understood why someone would pay so much for a VPS! You can get a fully dedicated Core i3-2130 with 8Gb of RAM for $21/month! You could run your own KVM and OpenVZ container cluster on that, I used to have my one running a personal private Jenkins! :)"
cpp,3aq2iu,Houndie,1 point,Tue Jun 23 08:55:33 2015 UTC,"BTW I've never understood why someone would pay so much for a VPS! You can get a fully dedicated Core i3-2130 with 8Gb of RAM for $21/month! You could run your own KVM and OpenVZ container cluster on that, I used to have my one running a personal private Jenkins! :)   Very good point, this is why I rent a dedicated i7 w/ 24GB ram for $30/mo.  That said, you can also get a VPS for dirt cheap: ChicagoVPS charges $1/mo."
cpp,3aq2iu,Houndie,1 point,Tue Jun 23 10:57:23 2015 UTC,"$30/month for 24Gb dedicated is pretty good.  Two of my three DNS servers are on $15/year 128Mb VPSs with Ramnode and BuyVM. Both are all SSD storage, and whippet fast. Anyone interested in reviews of such VPSs http://lowendbox.com/ is your friend."
cpp,3aqx4o,xgien,4,Mon Jun 22 20:00:38 2015 UTC,"These discussions are always so funny. Advocates of high level languages love to talk about how ""speed isn't everything"" and that ""performance doesn't matter as much as developer time does"". Oh, but suddenly, if there is a hint of that high level language being faster than the low level language, it's time to talk about it."
cpp,3aqx4o,TheBuzzSaw,9,Mon Jun 22 22:39:25 2015 UTC,"The people banging out web related python or perl are mostly just slinging around and dicing large utf8 strings with regex and so forth. Naive scripting code is likely to be faster than naive C++ for that stuff. So at a certain level the misconception is understandable.  It's a bit puzzling that so many scripters remain unaware that  C or C++ numeric code is going to be, like, 300 times faster."
cpp,3aqx4o,kkrev,3,Tue Jun 23 01:58:35 2015 UTC,"It makes sense though. While very high level languages have their place, it'd be quite incredible for productivity to be able to translate low level performance over to higher level languages for ""free"" so to speak.   If Python was as fast and lightweight as C++ for more tasks, I'd probably use it a lot more."
cpp,3aqx4o,salgat,2,Tue Jun 23 02:08:10 2015 UTC,How is C++ lower level than Python ? You can write pretty abstract code.
cpp,3aqx4o,doom_Oo7,2,Tue Jun 23 07:53:37 2015 UTC,By default C++ does not involve the heap or a long slew of runtime checks for simple operations like 1 + 1.0 .
cpp,3aqx4o,josefx,1 point,Thu Jun 25 07:56:44 2015 UTC,"Because C++ has a policy of zero-cost abstractions, so those abstractions are inexpensive at run-time. Further, it allows you to address the machine directly - managing memory allocation, flow of execution and such like more directly."
cpp,3aqx4o,robthablob,3,Tue Jun 23 11:41:51 2015 UTC,"I don't think that having zero-cost abstraction or not is a matter of being low or high level.  I am split between saying that C and C++ are low level because you can easily infer the memory layout of everything, and saying that C++ is (very) high level because of templates, inheritance, operator overloading, lambdas, and all this syntactic sugar, but maybe it's really two distinct concepts, one being relative to how the language translates to machine code, and the other to how abstract things one can write."
cpp,3aqx4o,doom_Oo7,1 point,Tue Jun 23 12:41:12 2015 UTC,"I'm in total agreement. It is simultaneously very low level, very high level, and filled with so many complexities its dang frustrating."
cpp,3aqx4o,robthablob,2,Tue Jun 23 13:12:35 2015 UTC,"I wouldn't say that C++ is either lower or higher level than Python (or any other language for that matter). That implies the ""level"" of a language is a fixed point on a scale. I would rather say that C++ has a much wider range than many  other languages. It's at home whether you're coding down to the metal or doing some really high-level abstractions."
cpp,3aqx4o,ferruccio,3,Tue Jun 23 15:07:00 2015 UTC,I use various combinations of both. Python with OpenCL. Or Python to do one thing in project such as to import/purify terrible source data but then the C++ to bash it hard during some sort of numeric analysis.  Python is great for some interfaces while an interface that really needs to dance might need to be in C++.   Oddly enough what I rarely do is to have the two languages talk to each other directly.   I love having the two languages ready in my toolkit. Each has its strengths and weaknesses but with this pairing they compliment each other very well.
cpp,3aqx4o,LessonStudio,3,Tue Jun 23 02:51:34 2015 UTC,"Is it only me, or did that discussion very quickly went to cache coherence, list versus vector etc discussion? :-)  I understand, it was a not very interesting noob question, but still..."
cpp,3alsf1,mttd,1 point,Sun Jun 21 13:54:03 2015 UTC,"On Slide 24 this replaces the generate call:  std::iota(v.begin(). v.end(), 0u);   Futhermore the count_if can be simplified if is_prime is just a simple function or you use this:  std::count_if(v.cbegin(), v.cend(), &is_prime);"
cpp,3alsf1,F-J-W,1 point,Sun Jun 21 20:53:57 2015 UTC,"A tiny bit of criticism (some might call it nitpicking):   Slide 7: You're using the default by-value capture mode for the lambda. The default capture modes are considered bad. Prefer C++14 init or copy r into it explicitly.  Slide 24: Consider adding a hint the init capture is a C++14 feature.  Slide 28: Modules, most likely, wont make it into C++17. Co-Routines is mentioned twice."
cpp,3alsf1,Leandros99,1 point,Sun Jun 21 17:35:24 2015 UTC,Slide 14 has a memory leak although that may have been mentioned in the talk instead of the slides.
cpp,3alsf1,vlovich,1 point,Sun Jun 21 21:12:39 2015 UTC,Nice presentation about C++  However. I disagree on some points (not your fault). it is not easy to learn or to teach. Generics and functionnal are absolutely not clear and not easy to maintain
cpp,3allsj,mttd,3,Sun Jun 21 12:24:05 2015 UTC,"The 'get rid of STL' seems a little bit risky, especially when dealing with strings. B. Stroustroup & co. suggest the way around, 'use STL as much as possible'"
cpp,3allsj,blackibiza,1 point,Mon Jun 22 05:46:09 2015 UTC,"Great article on optimizing memory usage. Lots of cool tips with practical usage, for the occasions when performance is really important."
cpp,3allsj,bogon_flux,1 point,Mon Jun 22 11:14:31 2015 UTC,The resulting structures are too low level for my taste. Imagine having to modify this! I'm interested to see where they're going though; perhaps we're simply at a low level intermediate stage.
cpp,3ale53,sztomi,4,Sun Jun 21 10:04:02 2015 UTC,"Reviews seem to be done, notifications are pending. Not sure how long it will take, but I guess you'll know soon."
cpp,3ale53,meetingcpp,2,Sun Jun 21 11:15:31 2015 UTC,I got a mail saying the new deadline is June 28.
cpp,3ale53,jpakkane,2,Mon Jun 22 07:48:07 2015 UTC,"Me too, a couple hours ago."
cpp,3ale53,berium,2,Mon Jun 22 08:02:33 2015 UTC,I don't think they have been sent yet. I am on the program commetee (but not part of the group that makes the final call) and this year there are even more submissions than last year. So that makes the job harder. Also remember that all this is done in people's free time on volunteer basis (I know I dropped the ball on my reviews this year because of work demands). So let's give them a bit more time. Boris
cpp,3alwyn,newuser1892435h,14,Sun Jun 21 14:44:58 2015 UTC,"You do not need to specify the template parameters inside the class body. This already works:  /*start of file, pragma once and misc headers*/  /* A simple stack only array like container with an opt-in no-except policy that specializes the container */ template<typename stored_t, size_t storage_allowed, bool no_except> class Array { public:     Array() = default;     Array(Array&) {...}      Array operator =(const Array rhs) {...}     /* etc...*/ };"
cpp,3alwyn,dscharrer,2,Sun Jun 21 15:00:14 2015 UTC,"This doesn't work inside method definitions though, right? At least if they're defined outside the class.  Also that doesn't help with CRTP -- it would be nice if self_t worked in the inheritance list."
cpp,3alwyn,tending,4,Sun Jun 21 15:09:42 2015 UTC,"It does work inside method definitions and in the parameter list. For the return type you have to use the auto syntax:  template<typename stored_t, size_t storage_allowed, bool no_except> auto Array<stored_t, storage_allowed, no_except>::member(…) -> Array { … }"
cpp,3alwyn,dscharrer,2,Sun Jun 21 15:22:45 2015 UTC,"Oh neat, didn't realize that was one of the benefits of that syntax. What about parameters though, like defining the copy constructor outside the class?"
cpp,3alwyn,tending,6,Sun Jun 21 16:14:29 2015 UTC,"It works there too. This is called an injected-class-name, and it's available as soon as the compiler knows what class it's working with. C++ is (conceptually) parsed left-to-right, top-to-bottom, so this information is known when the compiler sees MyClass::meow. That's why trailing return types let you use injected-class-names."
cpp,3alwyn,STL,1 point,Sun Jun 21 19:12:06 2015 UTC,"Hmm, doesn't that create an issue where the compiler thinks 'Array' refers to a concrete class now, but you might legitimately try to pass it as a template template parameter, in which case it should be interpreted to be the name of a template?"
cpp,3alwyn,tending,5,Sun Jun 21 19:57:11 2015 UTC,"The compiler has a disambiguation rule. If it sees Array by itself, it's an injected-class-name. If it sees Array<Args>, it's not using the injected-class-name. (Code isn't parsed strictly left-to-right.)"
cpp,3alwyn,STL,7,Sun Jun 21 20:09:15 2015 UTC,"Technically, it's an injected-class-name in both cases. The difference is whether it's being used as a type-name or a template-name. (See [temp.local]/p1.)"
cpp,3alwyn,tcanens,5,Sun Jun 21 22:20:19 2015 UTC,"You're absolutely right - I had either forgotten that, or didn't know it in the first place, despite dealing with injected-class-names in the past. (It's ""fun"" with private inheritance.) Please enjoy your gold!"
cpp,3alwyn,STL,1 point,Mon Jun 22 02:55:36 2015 UTC,But what about TakesATemplateTemplate<Array> ? That's the case I meant.
cpp,3alwyn,tending,1 point,Sun Jun 21 22:37:55 2015 UTC,"/u/tcanens pointed out how this works - it's always an injected-class-name, but it can be used both ways (like I said). N4527 14.6.1 [temp.local]/1: ""Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-class-name can be used as a template-name or a type-name. When it is used with a template-argument-list, as a template-argument for a template template-parameter, or as the final identifier in the elaborated-type-specifier of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent to the template-name followed by the template-parameters of the class template enclosed in <>.""  This directly answers your question about template template-parameters."
cpp,3alwyn,STL,1 point,Mon Jun 22 02:47:03 2015 UTC,"Ah didn't see his answer, thanks. Huh, so I guess that's one reason for not allowing a template<class A> void foo(); and template<template<class> class A> void foo(); to coexist. Then foo<Array>() would be ambiguous."
cpp,3alwyn,tending,2,Mon Jun 22 03:09:28 2015 UTC,"Oh I had no idea, well this simplify's things dramatically... I feel silly now having brought it up but I have honestly never seen/noticed this in the 5 years i have been using C++."
cpp,3alwyn,OldWolf2,1 point,Mon Jun 22 08:44:00 2015 UTC,"Also, typedef Array self; can be written to achieve the same effect as OP.  I occasionally do this for clarity, and typedef ParentName inherited; for the parent class. Not when using multiple inheritance though!"
cpp,3aix1s,mttd,33,Sat Jun 20 17:10:28 2015 UTC,Is it normal to want to claw my eyes out every time I see an overloaded comma operator?
cpp,3aix1s,minno,14,Sat Jun 20 19:16:40 2015 UTC,You... you can overload the comma operator? TIL
cpp,3aix1s,Saucy_,13,Sat Jun 20 23:29:36 2015 UTC,"http://en.cppreference.com/w/cpp/language/operators  You can overload anything, except for . and whitespace."
cpp,3aix1s,minno,21,Sat Jun 20 23:33:51 2015 UTC,And overloading . is proposed for c++17.
cpp,3aix1s,Plorkyeran,17,Sun Jun 21 02:25:06 2015 UTC,christ
cpp,3aix1s,aport,12,Sun Jun 21 06:38:27 2015 UTC,"You can overload anything, except for . and whitespace.   Can't overload ternary conditional either."
cpp,3aix1s,Drainedsoul,16,Sun Jun 21 05:03:20 2015 UTC,And the .* pointer-to-member operator.
cpp,3aix1s,STL,13,Sun Jun 21 06:44:49 2015 UTC,And the :: scope operator.
cpp,3aix1s,cleroth,1 point,Sun Jun 21 09:38:48 2015 UTC,See boost::assign for a use for the overloaded comma.
cpp,3aix1s,punanetiiger,1 point,Sun Jun 21 12:24:55 2015 UTC,Yeah. If I ever meet someone who does that intentionally I'm going to hit him with a fucking tire iron.
cpp,3aix1s,madwilliamflint,6,Thu Jun 25 14:05:19 2015 UTC,"On BASIC, it is."
cpp,3aix1s,fr0stbyte124,7,Sat Jun 20 19:45:58 2015 UTC,"It has some uses, but they're very limited."
cpp,3aix1s,cleroth,3,Sat Jun 20 21:52:38 2015 UTC,Which is the interesting thing about C++ I think.  It works incredibly well when there is good judgement at every step of the way.   Unfortunately we realize that most people do not have great judgement.  Thank god there are so many libraries that really are so refined.
cpp,3aix1s,__Cyber_Dildonics__,2,Sat Jun 20 22:44:51 2015 UTC,"Thank god there are so many libraries that really are so refined.    Thank god there are so many other languages. Can you imagine for every language to ask ""good judgement"" from the programmer? Where would people be? Half the software would never get written."
cpp,3aix1s,alonjit,3,Mon Jun 22 01:35:29 2015 UTC,Overloaded comma operator for pre-C++11 safe printf.
cpp,3aix1s,krum,5,Sun Jun 21 04:48:39 2015 UTC,You could support other data types too by using auto.
cpp,3aix1s,sim642,4,Sun Jun 21 07:00:14 2015 UTC,"Kind of cool! :-)  It doesn't allow nested FOR loops, right? (IIRC they were allowed in basic?)"
cpp,3aix1s,Elador,9,Sat Jun 20 21:13:21 2015 UTC,I disagree.
cpp,3aix1s,AceyJuan,8,Sat Jun 20 20:23:03 2015 UTC,"Didn't click the link either, I see."
cpp,3aix1s,AndreDaGiant,3,Sun Jun 21 08:26:27 2015 UTC,"Oh, I did. It was cute, but I still disagree."
cpp,3aix1s,AceyJuan,1 point,Sun Jun 21 09:10:44 2015 UTC,It only looks as simple as. :-)
cpp,3aix1s,Gotebe,-11,Mon Jun 22 17:49:07 2015 UTC,"Pointless?  Also, lel #define LET double (and this limitation is also mentioned), so it isn't even particularly elegant. Could have at least made a variant type."
cpp,3aix1s,suspiciously_calm,14,Sat Jun 20 20:49:08 2015 UTC,"Yes, jokes are normally pointless beyond the humor value."
cpp,3aix1s,Plorkyeran,2,Sat Jun 20 23:16:12 2015 UTC,"There's quite a few language that use double for all number variables, like JS."
cpp,3ak6lt,toothkiller,21,Sun Jun 21 00:20:27 2015 UTC,"Why C++? It really doesn't seem like an obvious choice for those layers, unless you've got some requirements that are several sigmas away from the typical web / mobile app.  It's really more of a business decision more than a software engineering decision - and finding good C++ developers to work on that sort of code is likely to be significantly harder / more expensive than decently skilled developers in other languages."
cpp,3ak6lt,lluad,2,Sun Jun 21 01:18:18 2015 UTC,"Thanks, I thought it was obvious because it be able to be shared in all of the different mobile environments and run on the server. I can reevaluate."
cpp,3ak6lt,hoverX,7,Sun Jun 21 02:32:59 2015 UTC,You might have a point if you wanted to develop native mobile apps but it sounds like you are already using Xamarin for that.
cpp,3ak6lt,jimdidr,3,Sun Jun 21 04:17:28 2015 UTC,"Wouldn't it be a good choice to go native tho, Android Studio 1.3 is supposed to be C++ friendly, and then there is the new Windows phone stuff.  I don't know if I'm biased but to me it seems like the world is turning to C++ in many ways, with the over-saturation of the IndieGameDev market using sometimes bloated and sometimes expensive frameworks I believe your edge is in good code executed elegantly.   There is also that PHP has a bad security record.  I never did .Net so I don't know but I have done C# and all I wanted was more control.   Then there is Java which everyone and their mother is forced to know too much about because 0-day security issues and constant update prompts given to people who really shouldn't have root access to their own computers. (ex. ""everyone's"" mother/father over 60 who never worked behind a desk in their life. but they still need access to their bank.)  I'm a C++ noob still so please tell me if I'm wrong.   (I'm at the stage where I'm working really hard at wrapping my head around passing pointers into function and manipulating the objects pointed at without returning any thing except maybe a error code.)"
cpp,3ak6lt,tisti,2,Sun Jun 21 18:30:22 2015 UTC,"I don't know if I'm biased but to me it seems like the world is turning to C++ in many ways   Battery technology did not advance as much as anticipated it would seem. The only way forward is to do things as close and efficiently to the metal as possible to get better battery life.  Though the modern QHQ screen is the biggest guzzler of battery resources. Soon to be QFHQ, crazy."
cpp,3ak6lt,jimdidr,1 point,Sun Jun 21 20:18:12 2015 UTC,"I have been hoping for leaps and bounds in eInk screens since I first heard of the Kindle. Its really strange to me that it seems to be going slow or the news is just dodging me.   to be fair I wasn't putting the good of the world first, more like ""that would be cool"" and ""maybe my sleep pattern will get better""*.   *(fake sunlight effect and the possibility that eradiating my face with whatever these monitors give off might be found to be less that optimal 8++ hours aday.)"
cpp,3ak6lt,tisti,2,Sun Jun 21 21:33:32 2015 UTC,"eradiating my face with whatever these monitors give off   Photons are pretty harmless, don't worry. What the sun gives off should scare you much more :)  But yea, strange that eInk has not advanced as much. Guess it came to a ""good enough for our usecases"" point.  Ninja edit: visible light photons :)"
cpp,3ak6lt,jimdidr,1 point,Mon Jun 22 08:58:45 2015 UTC,hehe yeah I was just acting a little extra paranoid about what LCD/LED monitors mix in with their photons :)
cpp,3ak6lt,devel_watcher,1 point,Mon Jun 22 12:42:36 2015 UTC,"I think that Java is for that. (never used, except for two small university projects)  The discussion in this thread is Microsoft biased: MS once was promoting C++, now - C#. People here are mostly from that environment."
cpp,3ak6lt,AceyJuan,10,Mon Jun 22 21:04:12 2015 UTC,"The two advantages of C++ are portability and performance (aka control). For business logic, you probably don't care about performance and answering the portability question will require research.  C++ will do the job. It can do most any job. But it's not obvious that it's the best choice."
cpp,3ak6lt,psydave,4,Sun Jun 21 01:40:22 2015 UTC,"After you've been using .net languages, which make things very cushy for the developer, it's going to be very hard to convince anyone  to give up things like, garbage collection, modules, a HUGE plethora of 3rd party libraries to serve any purpose you could imagine, decent build times, and decent enough performance...  Unless you really need the performance and Mono just doesn't cut it for some reason, you won't be getting any benefit from C++ in terms of longevity.  How long do you want this code to last?  What's the likelihood that it needs to last that long?  Most codebases last 5 years or so before they get obsoleted to the point of being rewritten from scratch anyway.  Standards change, new technologies get implemented, and new patterns become prevalent--you don't want your company to get stuck in 10-15 year old code that becomes so huge it's unmaintainable while simultaneously being the company's primary product...  (been there, done that...)"
cpp,3ak6lt,mrpisto,3,Sun Jun 21 02:31:10 2015 UTC,"http://www.itworld.com/article/2936294/social-networking/facebook-turns-to-wizened-old-c-to-power-new-photosharing-app.html maybe? ""for portability""."
cpp,3ak6lt,Gotebe,2,Sun Jun 21 00:36:03 2015 UTC,"C++ is not a good choice for this kind of thing. It has not much to do on the server side, and mobile front-end is rarely done in C++, too.  If you want to use C++, use it where it can contribute well. Is there a lot of C code to interface with? If yes, on the server, then consider C++/CLI over interop (I would never recommend interop for anything but the simplest things). If yes, on the device, then sure, use C++ as a glue.  At the moment, you sound like your case seriously lacks business motivation. Why would C++ be better, quantifiably?"
cpp,3ak6lt,no1msd,5,Sun Jun 21 09:35:45 2015 UTC,Are you saying C++ is only ever useful when for some reason you have to interface with legacy code?
cpp,3ak6lt,Gotebe,1 point,Sun Jun 21 10:01:23 2015 UTC,"No, but in his described situation ( a lot of existing .net code, asp.net...).  If the client part was graphics, then C++ gets interesting, esp. on mobile, but that doesn't seem to be the case.  The low levev C doesn't need to be legacy, who knows? :-)"
cpp,3ak6lt,theICEBear_dk,1 point,Sun Jun 21 17:44:34 2015 UTC,"Hmm, well I know of some reasons to go C++ for cross platform mobile support (since C++ is the only language equally available on the major platforms so code reuse is a factor there).   And for backend with the emergence of the high speed web framework platform such as https://github.com/stefanocasazza/ULib, the OkCupid libraries, Facebook's Proxygen and so on I'd go:   HTML5+JS+CSS   or   Native Mobile + C++    on the Mobile end and C++ Web / Microservice on the backend. And for the data model I'd use http://www.codesynthesis.com/products/odb/ (C++ ORM) with a PostgreSQL database. Mostly all code in one language for everything and you'd be sure there was no weird GC/VM or large environment issue slowing you down and everything would be one language (C++11 or better depending on your selected compiler). Get GCC5 or clang and just go nuts. Developers available if a bit more expensive but you'd have massive control over your entire product.  If you suddenly needed RPC, parsing, protocol serialization, unit testing... All out there right now for C++ there is no need to drop into stuff like JS, Java or C# unless you really need a lot of already existing libraries packaged into a large environment."
cpp,3ak6lt,lingua_franca,1 point,Sun Jun 21 18:48:17 2015 UTC,"like someone already said, use Facebook's ""Moments"" as an example:  https://code.facebook.com/posts/498597036962415/under-the-hood-building-moments/"
cpp,3ak6lt,mc_hammerd,1 point,Mon Jun 22 19:58:40 2015 UTC,"hehe.  hehe.  hehe.  you happen to ask the right person. did you see the new windows 10 hello world?  First declare your main function.  in any one of these App.xaml, App.xaml.h, App.xaml.cpp, MainPage.xaml, MainPage.xaml.h, MainPage.xaml.cpp, put  namespace HelloWorld     public ref class MainPage sealed     {       public:           MainPage();     }; }  MainPage::MainPage() {     auto navigationHelper = ref new Common::NavigationHelper(this);     navigationHelper->LoadState += ref new Common::LoadStateEventHandler(this, &MainPage::LoadState); }   To make your window resizable or for responsive design you have to add:  <VisualStateManager.VisualStateGroups>     <VisualStateGroup>         <VisualState x:Name=""wideState"">             <VisualState.StateTriggers>                 <AdaptiveTrigger MinWindowWidth=""641"" />             </VisualState.StateTriggers>         </VisualState>         <VisualState x:Name=""narrowState"">             <VisualState.StateTriggers>                 <AdaptiveTrigger MinWindowWidth=""0"" />             </VisualState.StateTriggers>             <VisualState.Setters>                 <Setter Target=""contentPanel.Margin"" Value=""20,30,0,0""/>                 <Setter Target=""inputPanel.Orientation"" Value=""Vertical""/>                 <Setter Target=""inputButton.Margin"" Value=""0,4,0,0""/>             </VisualState.Setters>         </VisualState>     </VisualStateGroup> </VisualStateManager.VisualStateGroups>   Dont forget your bitmaps  Windows::UI::Xaml::Media::Imaging::BitmapImage^ bitmapImage = ref new Windows::UI::Xaml::Media::Imaging::BitmapImage(); bitmapImage->SetSource(fileStream);   And finally add your XAML  <StackPanel  Margin=""120,30,0,0"">     <TextBlock HorizontalAlignment=""Left"" Text=""Hello World"" FontSize=""36""/>     <TextBlock Text=""What's your name?""/>     <StackPanel Orientation=""Horizontal"" Margin=""0,20,0,20"">         <TextBox x:Name=""nameInput"" Width=""300"" HorizontalAlignment=""Left""/>         <Button Content=""Say &quot;Hello&quot;""/>     </StackPanel>     <TextBlock x:Name=""greetingOutput""/> </StackPanel>   Dont forget to translate any backslashes to html entities for XAML processing  no more \"", use & quot; instead!  gl :)  [ from https://msdn.microsoft.com/en-us/library/windows/apps/dn996906.aspx ]"
cpp,3ak6lt,_java_csharp_cpp_c,-5,Tue Jun 23 19:50:57 2015 UTC,"From the sound of what you're describing, you should be using something like .Net already. I'm not sure what you think you'll gain by moving to C++. Mono provides a very decent platform for running C# on non-MS operating systems. With the open-sourcing of pretty much everything C# related, Mono and the rest is only ever going to get better. C# is the 4th most popular language on the planet, with the biggest software company on the planet moving more and more onto C# every year. Win10 puts even more focus on ""Modern"" apps, which are .Net. Win32 apps are becoming less and less prevalent every year. There's really not going to be a point where you'll be ""oh geez, should have used C++ since C# has died"" or something. It's not like you're writing Object Pascal or something."
cpp,3ak6lt,rsclient,-2,Sun Jun 21 03:22:07 2015 UTC,"From personal experience, I was a C and then C++ program for 20 years, and now pretty much do everything in .NET.  I'll never go back.    As a person who programs in .NET, but deals with C++ programmers, I'm constantly frustrated at how frickin slow C++ development is.  Everything is hard; nothing is easy.  Those trivial libraries in .NET that are awesome?  In C++, you slowly and painfully initialize your apartment threading, initialize, set, addref, and more crap.  Or you painful wade through pages of documentation for ""helper"" classes that break, or have weird side-effects.  Worse, every time we think about making the code faster, it's a painful conversation.  ""Can't we just switch the type of blah?"", ""Can't we try moving this here and wait for that"".  The answer is generally, ""no"" or ""if will take a week to get the allocations straightened out and to stop crashing.""  Whereas with C#, refactoring is simple and fast.  And now that I've gotten used to the Async/Await pattern, every language that doesn't have that pattern is frankly a loser."
cpp,3aicse,14ned,2,Sat Jun 20 13:47:39 2015 UTC,"Finally! Just one thing..  The name confuses me, I'm left wondering ""Which type of Monad is it?"".  The post doesn't help me much either, since your type looks to be anything but single purpose: is it a future/optional/result/expected/variant...? It looks that this type can be used as any of these."
cpp,3aicse,gnzlbg,2,Sat Jun 20 15:41:42 2015 UTC,"Monad would be the Concept in C++, but monad would be a type.  The choice of the name monad<T> was taken after an extended period of consultation on boost-dev. The names suggested were:  maybe, result, holder, value, retval, potential, likely. expected is another option, but that's an existing Boost library.  Having considered all these options, I decided on monad<T> exactly because it's confusing and would make people check the documentation to see what it meant :) which is a better outcome than people thinking it's something it's not from the name.  As is idiomatic in C++, monad<T> is specifically intended to be subclassed. Lightweight promise<T> and future<T> (forthcoming) are monad<T> underneath, and just implement a lazy monad. Proposed Boost.AFIO will then further subclass lightweight future<T> into a boost::afio::future<T> which does extra AFIO-specific stuff.  There is nothing stopping one from subclassing std::future<T>, but the usefulness there isn't much and you do a lot of inefficient boilerplating to implement the custom semantics. Having direct access to the internal monad<T> inside a lightweight future<T> lets one implement a custom afio::future<T> with perfect efficiency, plus you can convert out of and into monad<T> at any time - a make_ready_future(T) simply constructs a monad<T> when is then fed to a future<T>.  Lightweight future<T> will be able to participate in the Concurrency TS when_any/when_all by the way, just as if a std::future<T>. So you lose little and gain much with these. If Boost likes the design, they'll probably eventually end up in the Boost.Thread rewrite, but that's a long way away yet."
cpp,3aicse,aport,1 point,Sat Jun 20 16:09:28 2015 UTC,"Pardon my ignorance, but what makes this useful? Like... what's the application for something like this?"
cpp,3aicse,lostman_,5,Sun Jun 21 06:41:27 2015 UTC,"Monad are an incredibly useful programming pattern and having a generic monad library helps avoid code duplication by building libraries that work with any monad. Is is also often the case that all you need to know is that ""X is a monad"" and you can write your code without caring what X is.  Promises, futures, async calls, computations that may fail, computations that return errors and many more are monads.  Suppose you have two futures f1 and f2 that both return an integer. You want to combine them into a future that returns a sum of those integers. How do you do this? What if I told you that future<T> is a monad?  Then you don't even have to look at future<T> api!  The code will be something like  f1.bind([](int x) { f2.bind([](int y) { return x + y }) });   What if you have a vector<future<T>> but you want a future<vector<T>>? You can implement this for any monad and not just future<T>. So when you'll need it, you'll know that it is a valid operation because it is for any monad and future<T> is a monad.  Few months ago I was looking at Elm language (compiles to JavaScript) and I was writing some code to parse JSON data. The author chose to hide the fact that JSON parser is a monad and so this information was omitted form the documentation. Furthermore the two monadic operations have strange names: succeed instead of more typical return and andThen instead of bind and unhelpful documentation:   succeed : a -> Decoder a A decoder that always succeeds.  What? That's not useful at all. return of the Decoder monad, that would tell me all I need to know. So I was staring at the documentation trying to figure out how to write my parser (which was too complicated to be easily handled by the library's built-in -- written in JS and exposed to Elm -- convenience functions) until it occurred to me that succeed is return and andThen is bind. The rest was trivial since I know how to write monadic parsers.  So if you know monads and I tell you X is a parser monad, go write a parser, then you'll immediately know where to start and how to proceed. Sure, the specific library you may use will have richer API and most certainly will contain functions that will simplify the code, but from the moment you hear monad you know the general structure of the code you'll need to write.  Monads are not complicated. They are incredibly simple. Bind and return is all you need to get started :)"
cpp,3aicse,chambolle,2,Sun Jun 21 11:47:45 2015 UTC,"For the average C++ programmer, a monadic return transport lets you match C++ semantics much closer to the semantics of what you're doing, which in turns makes your code more maintainable and lessens the learning curve for new developers. See https://svn.boost.org/trac/boost/wiki/BestPracticeHandbook#a8.DESIGN:Stronglyconsiderusingconstexprsemanticwrappertransporttypestoreturnstatesfromfunctions for an explanation. That's why I want it as lightweight as possible, because it crosses off a ""major feature"" Rust claims over C++. And besides, once you're using to thinking monadically, about 20% of the time when writing functions you really ought to return a monadic return and mark the function noexcept, that saves you having to implement exception safety in all code using the monadically returning function because no exceptions can ever be thrown ever. That's an enormous time saver when speccing out test code, and makes your functional testing vastly simpler.  Of course, if you don't use exceptions or don't aim for exception safety (plenty of shops don't), none of that matters to you.  For the standards setting/Boost library guru type C++ programmer, we almost certainly are just about to accept into Boost the very first all C++ 14 (or even C++ 11) Boost library, and it's a real corker of a library which pushes C++ 14 to its absolute limit. Won't currently compile on anything except recent clangs and GCC trunk. No one is expecting MSVC support until VS2017, but Microsoft are very aware of the new Boost library, and I am sure will make special efforts to get it working on MSVC sooner rather than later.  Why this matters is that that new Boost library, proposed Boost.Hana, is a compile time programming toolkit based heavily on functional programming and of course Monads which transform sequences of heterogeneous types at compile time. This is expected to dovetail nicely with Eric Niebler's Ranges v3 expected to reach the standard soon which is a toolkit for functional programming of transforming sequences of things at runtime. What is missing in there is a lightweight runtime monad which fixes the unfortunate design decisions in promise-future, and can bridge between Hana, Ranges and proposed C++ 1z coroutines/resumable functions in a ""you only pay for what you use"" fashion.  That's the hope, anyway. My efforts are only a very tiny piece of a much bigger effort."
cpp,3ahwoj,corvusoft,1 point,Sat Jun 20 09:42:45 2015 UTC,If I'm not wrong and you use this to parse the http messages: https://github.com/Corvusoft/framework/blob/master/source/corvusoft/framework/detail/http_impl.cpp  I think the parser will have a very bad performance compared to some other parsers.
cpp,3ahwoj,txzzzuu11,1 point,Sun Jun 21 06:05:51 2015 UTC,You will find the parser here: https://github.com/Corvusoft/restbed/blob/master/source/corvusoft/restbed/detail/session_impl.cpp#L491
cpp,3ahwoj,frymode,1 point,Sun Jun 21 10:14:55 2015 UTC,"This (^(.*): *(.*)\\s*$) does not look like correct headers handling, for instance try to parse User-Agent: Mozilla:4.0. Are you aware of RFC 7230 to speak about compliance?"
cpp,3afk9v,STL,13,Fri Jun 19 18:51:59 2015 UTC,"Huge improvements from VS 2013, looks like I can finally use some of the modern C++ libraries that weren't compiling with 2013 :)"
cpp,3afk9v,Nimelrian,2,Fri Jun 19 19:30:36 2015 UTC,Like what?  Modern libraries are a big part of the payoff.
cpp,3afk9v,__Cyber_Dildonics__,13,Sat Jun 20 05:33:05 2015 UTC,Holy shit you guys must have been working like crazy!
cpp,3afk9v,kozukumi,32,Fri Jun 19 21:00:11 2015 UTC,"Oh man, totally. Feature tables conceal how much effort went into each thing. N4389 bool_constant was a one-liner, while N4169 invoke() took me something like 4 months of overhauling <functional>. And features commonly require coordination between different teams - e.g. complex UDLs needed support from the C1XX and EDG front-ends, while noexcept-izing the STL required tons of work from the C1XX front-end and UTC back-end."
cpp,3afk9v,whichton,1 point,Fri Jun 19 22:06:50 2015 UTC,Never understood why you just don't use the EDG frontend for the compiler proper. I thought you have modified EDG to support C++ / CLI / CX stuff...
cpp,3afk9v,mcmcc,1 point,Sun Jun 21 17:50:08 2015 UTC,"That was seriously considered at one point. I'd have to ask a compiler dev about the reasons for the decision, but I believe that compiler throughput was one of them."
cpp,3afk9v,spongo2,7,Sun Jun 21 18:52:25 2015 UTC,"Terse static_assert  | No   | No   Dammit, of all the C++17 things to not implement...    It should take like 5 minutes, right?"
cpp,3afk9v,vlovich,12,Fri Jun 19 19:47:44 2015 UTC,"I asked, and they told me that it wasn't trivial. It's not hard, but it's not a one-liner that we could sneak in at the very end of the product cycle."
cpp,3afk9v,spongo2,14,Fri Jun 19 20:10:00 2015 UTC,"vc dev mgr here, but thanks for the feedback.   We will get everything eventually but it is always good to get a sense of what are the most demanded features for our prioritizations."
cpp,3afk9v,gnzlbg,8,Fri Jun 19 21:32:03 2015 UTC,Probably because that is a language feature & I bet you the compiler team was focused on other priorities.  It's easy to ignore low-hanging fruit when you have deadlines.
cpp,3afk9v,spongo2,18,Fri Jun 19 19:58:29 2015 UTC,"vc dev mgr here, although ironically one of the most common pieces of feedback I hear from customers is ""why are you wasting time on <insert c++17 feature here> when you don't have <insert c++11 feature here> ?""   So these aren't necessarily the slam dunk you would think they are.   In general, we try to get features in a priority that includes cost to implement, importance to build common libraries, and a few other dimensions.   Then we have to weigh it against our work items to clean up the compiler infrastructure which have been the key to helping us up the implementation pace."
cpp,3afk9v,gnzlbg,-4,Fri Jun 19 21:35:12 2015 UTC,"""why are you wasting time on <insert c++17 feature here> when you don't have <insert c++03 feature here> ?""    FTFY"
cpp,3afk9v,spongo2,2,Sat Jun 20 11:43:33 2015 UTC,touche'.  ;-)
cpp,3afk9v,__notmythrowaway__,1 point,Mon Jun 22 02:49:43 2015 UTC,"I really like all the work you guys are putting on C++11/14/17 conformance but there are some important C++11/14 libraries [*] that don't work yet under visual studio mainly due to lack of C++98's two-phase look-up.   Other language features can be ""easily"" worked around, but working around two-phase look-up is just unfeasible.   Nobody is asking for C++03 conformance and export templates, but without C++11 conformance one really needs to pay a lot of attention to which header-only libraries one use to write portable code.  [*] basically any library that uses some form of concept checking like Hana, FIT, range-v3, ... and meta-programming libraries like meta"
cpp,3afk9v,gnzlbg,1 point,Mon Jun 22 08:55:42 2015 UTC,thanks.   that's helpful.   We're tracking range-v3 directly (most expression sfinae or concepts blocked from my understanding).   will check out others.
cpp,3afk9v,BenHanson,1 point,Mon Jun 22 17:20:51 2015 UTC,Actually you didn't... On mobile I see no difference
cpp,3afk9v,gnzlbg,1 point,Sat Jun 20 12:16:20 2015 UTC,"c++11 vs c++03  I should have probably said c++98 tho, since the feature I had in mind was two phase look up."
cpp,3afk9v,BenHanson,2,Sat Jun 20 12:31:58 2015 UTC,"Yes, but they are fixing that in an update to 2015 RTM, so you don't have to stress about it for too much longer. It's truly mind boggling how MS have picked up the pace with standards conformance with this upcoming release.  I'm particularly chuffed with the constexpr work and looking forward to the C++14 version!"
cpp,3afk9v,alonjit,1 point,Sat Jun 20 20:32:51 2015 UTC,Really? That is truly awesome news!    Do you have a link to that?
cpp,3afk9v,BenHanson,3,Sat Jun 20 20:40:25 2015 UTC,"Gah, I think I'm mixing two phase lookup and expression SFINAE! Sorry about that. Anway, I still think it's a little unfair to snark too hard given the recent progress - and I say that as someone who was mightily pissed off how far they were behind with previous releases."
cpp,3afk9v,newmewuser4,3,Sat Jun 20 21:12:41 2015 UTC,"Yeah. It's unlikely that we'll ship two-phase name lookup in an Update, because it can break (non-conformant) code. We do that sort of thing in major versions, but Updates really shouldn't do that. (The exception is when we discover silent bad codegen; blocking that with an error is a reasonable thing to do in an Update.) In contrast, doing Expression SFINAE properly has basically no potential to break code, conformant or otherwise."
cpp,3afk9v,d-frey,1 point,Sat Jun 20 21:48:25 2015 UTC,how MS have picked up the pace   would that have anything to do with the current compiler/OS/machine-type distribution landscape ? I wonder...  competition does wonderful things
cpp,3afk9v,RogerLeigh,1 point,Sun Jun 21 05:47:24 2015 UTC,competition does wonderful things   :-) I'm not going to disagree!
cpp,3afk9v,spongo2,1 point,Sun Jun 21 09:34:24 2015 UTC,Only when it takes like 5 months of debugging.
cpp,3afk9v,ismaildonmez,10,Fri Jun 26 21:42:02 2015 UTC,"As a non-Microsoft user, I have to give you (that is: the whole VS team) some credit. It's obvious that you are taking things serious and you've made some impressive progress. VS2015 is the first version which is reasonably feature-complete and bug-fixed that it was able to compile some more advanced code of mine, e.g., https://github.com/ColinH/PEGTL  That said, a feature list on its own is nice, but the usability and acceptance also depends on being more than just that. As a Unix/Mac developer, I often find myself looking for two things in VS: First, an online compiler where I can try to check some code in order to write a proper bug report (and a reasonable way to report those bugs) and secondly a reasonable build-system that I can support without having VS.  The first part is partly solved by http://webcompiler.cloudapp.net/ - except that there seems to be no way to pass flags to the compiler. I have one bug in the above mentioned PEGTL which seems to apply only to Debug-mode, but I can't create a SSCCE without the online-compiler.  Also, it would be nice to have some easy way to report those bugs. Something like Bugzilla or even a simply email-address.  The second part about the build system is mostly about out-of-the-box support for VS from some project. If you look at the PEGTL, there is a 66 lines Makefile which should work for almost all Linux/MacOS users. It doesn't care which version, etc. Something similar for VS would be very nice, just telling it: Here's the headers, here's the code, here's the unit-tests, ... Does something like this exist? I don't want to use some non-preinstalled tools (that I can't even test) and then generate large amounts of project files for each version of VS and commit all of that to my small library."
cpp,3afk9v,spongo2,8,Sat Jun 20 05:55:51 2015 UTC,"I use CMake for this.  Write one set of rules, and then generate Makefiles for Linux/MacOS and Visual Studio solution/project files on Windows (at build time).  Of course, you do need testing in place to make sure it's functional on all platforms since you could unintentionally introduce some Unix-specific logic and break the Windows build, but it does mean you can have build/test logic which will work on all platforms.  It's a lot better than having multiple build systems supported in-tree which will inevitably become outdated.  It's not the prettiest language in the world, but it works, and handles details like shared library generation on all platforms which you'd otherwise have to resort to the GNU autotools for (and which would be UNIX-only)."
cpp,3afk9v,spongo2,3,Sat Jun 20 09:17:40 2015 UTC,"(vc dev mgr here) This is GREAT feedback.   I'll pass the webcompiler feedback on to the team.   We weren't sure how much it would get used but after all the amazing stuff that the community helped us find after the constexpr feedback request, i'm very interested in investing more in webcompiler.    project system pain for cross-platform devs is something we understand and are doing some exploration of."
cpp,3afk9v,d-frey,3,Mon Jun 22 00:46:05 2015 UTC,"WebCompiler should have an API to use from command line, I hacked up a small Python utility to do that for now: https://github.com/ismail/hacks/blob/master/compilers/vcpp.py"
cpp,3afk9v,spongo2,1 point,Mon Jun 22 07:29:02 2015 UTC,"dude, that's awesome.   nice work!"
cpp,3afk9v,raistmaj,2,Mon Jun 22 17:21:13 2015 UTC,check out the latest version.   We added the ability to add flags.  :)  http://webcompiler.cloudapp.net/
cpp,3afk9v,bluescarni,1 point,Tue Jun 30 22:46:09 2015 UTC,"Cool, thank you! Now I'll have to figure out how to reproduce this bug where one of our users got a bogus C4789. My naive attempts to reproduce it failed - or maybe the bug is solved by now? Hard to tell... :)"
cpp,3afk9v,spongo2,1 point,Tue Jun 30 23:38:18 2015 UTC,"we did update to a newer version as well, so that's possible!"
cpp,3afk9v,kozukumi,6,Tue Jun 30 23:48:11 2015 UTC,"An amazing job, well done :-)."
cpp,3afk9v,Leandros99,5,Fri Jun 19 19:44:33 2015 UTC,"No expression SFINAE yet? It looks like it will be shipped (hopefully soon) with an update, but still... this drastically clips the wings of many modern template metaprogramming techniques."
cpp,3afk9v,alonjit,13,Fri Jun 19 20:48:31 2015 UTC,VC++ Dev Mgr here!   We know!   Expression SFINAE is our highest priority for conformance.
cpp,3afk9v,alonjit,3,Fri Jun 19 21:30:49 2015 UTC,So do we have an ETA for 2015 release? I am guessing the plan is to release sometime just before the Windows 10 RTM on July 29?
cpp,3afk9v,Elador,2,Sat Jun 20 10:33:59 2015 UTC,"As I commented on VCBlog: Aside from ""this calendar year"", we haven't announced RTM's release date, nor can we hint at it."
cpp,3afk9v,Leandros99,2,Sat Jun 20 16:25:24 2015 UTC,"I still remember your last post, and was kinda disappointed Microsoft still couldn't keep up with clang / gcc / icc, but this is looking great!  Unfortunately this should've been in VS 2 or even 3 years ago.   Honest question: What takes so long? Why is every other compiler vendor faster? Especially clang."
cpp,3afk9v,AntiProtonBoy,6,Fri Jun 19 22:57:47 2015 UTC,"One-word answer: 2012.  By the way, I invite you to compare VC 2015's STL feature table to clang/libc++'s table. I believe that 2015's STL is comparable to, or even slightly ahead of, libc++ 3.6 (current) and even 3.7 (next), although not strictly ahead (as VC lacks result_of/function SFINAE)."
cpp,3afk9v,epyoncf,1 point,Fri Jun 19 23:33:27 2015 UTC,One-word answer: 2012.   What happened in 2012?
cpp,3afk9v,epyoncf,2,Sun Jun 21 05:50:04 2015 UTC,C++/CX.
cpp,3afk9v,spongo2,1 point,Sun Jun 21 06:41:02 2015 UTC,"Oh, haven't played with WinRT yet."
cpp,3afk9v,vlovich,1 point,Sun Jun 21 06:53:30 2015 UTC,"Regarding icc: From the feature tables I've seen, icc lacked even more behind (or similar to) VS 2013. Are you sure about that?"
cpp,3afk9v,RogerLeigh,1 point,Sat Jun 20 21:01:08 2015 UTC,"It has full C++11 compliance, IIRC. I could be wrong, though."
cpp,3afk9v,spongo2,2,Sun Jun 21 10:21:30 2015 UTC,"It's not enough, you know. I want you to drop everything and get variable templates working. :P  Nice work by the way. I'll look forward giving VS 2015 a spin."
cpp,3afk9v,Elador,2,Sat Jun 20 01:11:41 2015 UTC,"Does ""using base_class::base_class` to import all inherited constructors finally inherit constexpr constructors properly? It was broken in the RC.  Great job on VC2015 apart from that :)"
cpp,3afk9v,spongo2,3,Sun Jun 21 01:10:05 2015 UTC,"Can you use http://webcompiler.cloudapp.net to test a self-contained repro? If it still doesn't work, send me the repro and I'll file a bug in our internal database for you. (The STL doesn't use inheriting constructors, so we didn't encounter this.)"
cpp,3afk9v,Elador,2,Sun Jun 21 06:43:48 2015 UTC,"It's fixed!   This code : http://ideone.com/UpSjOK - compiles on the webcompiler, while on RC it gives ""error C2134: 'intermediate::intermediate': call does not result in a constant expression"". Great job!   I feel stupid of not knowing there's a VC++ webcompiler out there. I found quite a few minor annoyances while implementing a cross-platform STL replacement - now I can double check them finally."
cpp,3afk9v,_java_csharp_cpp_c,5,Sun Jun 21 12:29:35 2015 UTC,"Great to hear. The webcompiler is linked from https://isocpp.org/get-started (by its old URL rise4fun, which is rewritten-redirected). For clang/gcc, I prefer wandbox."
cpp,3afk9v,Ivan171,3,Sun Jun 21 19:01:03 2015 UTC,don't feel stupid.   it's relatively new and we just started updating it regularly recently. :)   it's been very useful though
cpp,3afk9v,_java_csharp_cpp_c,2,Mon Jun 22 00:52:21 2015 UTC,"Looking good STL!  Now you just need to start convincing your standards committee peers to stop their good-nature ribbing of VS conformance & you'll be all set :)  I only use gcc & clang currently but it helps everyone that modern support on Windows is coming since any cross-platform code tends to pick the lowest common denominator.  I don't know how many Windows-only C++ enthusiasts there are, but I'm sure there's a lot of them & getting them the tools to start writing better code is great for modern C++ adoption."
cpp,3afk9v,Elador,6,Fri Jun 19 19:37:48 2015 UTC,"We can't talk about future release scheduling, but history is fair game. I believe that ""3 years between releases"" is an inaccurate characterization. Observe:  2003 (+2) 2005 (+3) 2008 (+2) 2010 (+2) 2012 (+1) 2013 (+2) 2015"
cpp,3afk9v,Ivan171,6,Fri Jun 19 19:54:36 2015 UTC,"How come the compiler and standard library are tightly-coupled to the IDE?  Couldn't you update it on a more regular basis and allow the visual studio IDE to select the compiler to use.  On Linux and FreeBSD I routinely use multiple GCC and clang versions with ease; being able to do so on Windows without the baggage of the IDE would be a massive improvement.  It causes us no end of trouble having to install the many gigabytes of visual studio when all we want is the latest (or older) compiler to build stuff; cl and msbuild are all we actually want.  When you end up with e.g. 2010, 2012, 2013 and 2015RC that's a significant amount of disk used; particularly when installed on a jenkins build node on a shared VM cluster; and the time wasted by the admin installing it all is not insignificant."
cpp,3afk9v,RogerLeigh,9,Fri Jun 19 20:17:34 2015 UTC,"The toolset (compiler, linker, libraries) knows virtually nothing about the IDE. (We've got a few lines in the STL that help the debugger properly visualize our data structures.) My day-to-day work involves building and using the toolset from the command line. I install the IDE in a VM only when I need to update the visualizers. The IDE already has the ability to use different toolsets (there's a ""Platform Toolset"" property, e.g. v120 or v140).  As for how we ship the product, our dev manager is aware of the requests for a toolset-only edition/SKU. We definitely can't promise anything, since this sort of thing (shipping vehicles and frequencies) is decided at the upper levels of management, but it is on the radar."
cpp,3afk9v,millenix,6,Fri Jun 19 22:01:39 2015 UTC,"dev mgr here.   just to amplify, we also have the ability to do this in the IDE already for clang vs gcc in the android tools, not just within versions.   hearing loud and clear on desire for better acquisition experience for toolkit that doesn't involve installing multi-GB IDE :)"
cpp,3afk9v,Plorkyeran,7,Fri Jun 19 22:20:11 2015 UTC,"It's funny how a very fine-grained selection was possible in the installer of VS 6, 2003, 2005, and somewhere along the lines of VS 2008 or 2010 it got worse and worse until VS 2013 where we have no other option than installing the whole C#, .NET, SQL and whatever shabang comes with it (luckily we get to at least de-select MFC... ;-) ).  Extremely bad management decisions that are now being reversed?  What I would want is the C++ toolchain and the IDE only."
cpp,3afk9v,bnolsen,4,Fri Jun 19 22:33:52 2015 UTC,"noted!   VS acquisition is something we are investing in.   So you are saying that you want to have a VS install where you can uncheck C#, F#, etc, ASP.Net, right?"
cpp,3afk9v,RogerLeigh,2,Sat Jun 20 21:07:17 2015 UTC,Exactly! :-)
cpp,3afk9v,vlovich,-2,Mon Jun 22 00:49:11 2015 UTC,"I'm not sure why this is really a big issue. Having the option to pick and choose made a lot more sense back in VS6/2003 days, when disks were much much smaller and more expensive. Now one can buy a 500GB Samsung 850 Evo for $270, or a 4TB WD Black for $200, or a 1TB Black for around $65 if you're really pressed for budget. With disks being so cheap, it doesn't make a whole ton of sense to really worry about a few GB of features being added that some people might not use."
cpp,3afk9v,ismaildonmez,1 point,Mon Jun 22 09:08:32 2015 UTC,"Then buy me one of those and i will gladly install all that junk i don't use, and waste as much space as i can.  Wait a minute, i'll send you my shipping address... ;)"
cpp,3afk9v,contre,1 point,Sun Jun 21 01:41:28 2015 UTC,"I was really just stating that it probably doesn't make much difference to most people if their disk is 34% full or 36%. Unless you're hoarding mp4s or something, it's really hard to fill up a modern drive. I'm a huge data-hoarder myself, but I keep it all on a NAS (well, a Windows 2012r2 server, actually), so my system disks are for the most part rather empty."
cpp,3afk9v,melak47,1 point,Sun Jun 21 02:18:07 2015 UTC,"Oh come on - I'm not ever going to use a HDD anymore as my main drive (even more so in a laptop). So let's ignore the HDD prices you gave.   500GB Samsung 850 Evo for $270   $270 is a lot of bucks. I have a 250GB Samsung that came with my laptop (a year old) so just because of software-bloat I should spend $270 to buy a 500GB drive and not use the 250GB anymore?   Yes, it's easy to fill 250GB. I hardly have any data on it (data is on my NAS - but some of it I need on the SDD, ""on-the-go"", fast (ever tried loading 5000 png's over sshfs/webdav?)). Windows with updates takes 30GB+, a Linux VM takes 30GB+, after a year of running or so Windows takes another 30GB+ for junk in Windows\, temp, cache, whatever (yes I ran the cleaning wizard), now add VS2012, VS2013, Office, Cygwin, Boost, OpenCV, Qt, most of them in several versions, which each take 5GB+), Android SDK+NDK, and maybe a game or two to unwind (30GB+).  250GB is full rapidly. Yes I care about whether VS takes 15GB or 3GB."
cpp,3afk9v,zauucy,3,Sun Jun 21 02:33:27 2015 UTC,One of the reasons that I want to cut /clr:pure is that its LIBs and PDBs consume around 0.25 GB. We've deprecated it in 2015 and will hopefully remove it in the next major version.
cpp,3afk9v,AceyJuan,2,Sun Jun 21 11:26:56 2015 UTC,"It would be really nice to have a toolchain only edition.  There's a lot of reasons i don't like to download the whole IDE. But the most important one is, i don't use IDEs. I code on Sublime, and my build system is CMake+ninja. So, having only the toolchain (including the Windows SDK) would suffice for me."
cpp,3afk9v,AceyJuan,1 point,Sun Jun 21 18:58:00 2015 UTC,"Thanks guys, great to know you're aware of this!"
cpp,3afk9v,nikbackm,1 point,Sat Jun 20 00:58:13 2015 UTC,"Count my vote for tool-chain only installations as well. I have cross-platform software that I need to build and test on MSVC, but we never use the IDE at all."
cpp,3afk9v,Plorkyeran,2,Sat Jun 20 08:32:21 2015 UTC,"Even if you can't ship a toolchain-only SKU for business reasons, an installer option to skip installing the IDE itself would often be good enough."
cpp,3ajw2o,JedaVedia,2,Sat Jun 20 22:33:17 2015 UTC,"No, we won't do your homework for you.  Here is how you get help with these sorts of questions: you show what you've tried. Because, you have tried something already, right? You're not just posting your homework questions here without attempting them, right. No, nobody would do that... would they?"
cpp,3ajw2o,srnull,1 point,Mon Jun 22 15:16:23 2015 UTC,I've already figured it out thank to /u/uint65_t. So thanks anyway
cpp,3ajw2o,uint65_t,1 point,Mon Jun 22 21:19:18 2015 UTC,"This is not the appropriate place for basic programming questions. There are subreddits for this; see the sidebar.  But to answer your question, if you want to keep it simple you should probably make a pass over the array to calculate the average, and then make a second pass keeping track of the smallest difference from the average and the associated value. (Where by pass I mean a for statement or a ranged for statement depending on what you've studied so far.)"
cpp,3afcpm,frostmatthew,1 point,Fri Jun 19 17:55:04 2015 UTC,How do we compare this library to hpx?
cpp,3afcpm,si_abruzzo,1 point,Sat Jun 20 10:42:48 2015 UTC,"On a side note: from what I can tell from the blog post their collect looks like sequence for the Future Monad, with a signure similar to Monad m => [m a] -> m [a]. I quickly skimmed the documentation and indeed, they even have a section about Futures as Monads."
cpp,3agknb,cplusplustutor,7,Fri Jun 19 23:53:19 2015 UTC,"I've been a tutor for an algorithms-lecture and have taught several people stuff about C++ in a non-official context, so I guess my experience is close enough.    First of all: If you haven't seen it, watch this talk: https://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style  After you covered the basics, watch it with your class.    Teach the language in a top-down fashion. Pointers should be the last thing that you touch, the first 90% should be showing ways how to avoid them.  There is no legit reason at all for people being able to understand details about pointers to pointers if they don't even understand std::vector, iterators and the algorithm-library.  Pointers are for experts to implement advanced functionality. The common beginner should be taught how to avoid them, just as they should be taught functions and loops instead of gotos.    Do not hide the fact that there is undefined behavior. In fact: Teach that a the very beginning. These are the safety-instructions that are required for the language. And if you ask any biologist/chemist/, they will tell you that safety-instructions may be boring, but they are always taught at the very beginning, before you can seriously blow things up.    There are tons of very typical problems that badly taught beginners have, try to look into what those are and make sure that you apply countermeassures.  For a list of some of the things that I often encounter on /r/cpp_questions, you can look here, including explanations what better ways are: https://florianjw.de/en/modern_cpp.html    Teaching the “how” is utterly useless if you don't teach the “why”. I remember painfully how I wasn't able to understand why the hell I would want to use const, even though I understood how it worked. (I learned C++ from bad online-sources, you don't want to give your students that pain. It can be done, but it is neither efficient nor usefull.)    Whenever I have some time and feel like it, I write on my C++-tutorial, which you can find here; The pre-alpha warning is to be taken very seriously and you should certainly not use it for teaching, but it might serve to give you some ideas and demonstrate what I personally would do. (https works to, but you need to trust ca-cert (which you should))."
cpp,3agknb,F-J-W,2,Sat Jun 20 18:37:39 2015 UTC,Incredibly insightful and helpful! Thank you so much!!
cpp,3agknb,Gangstuh_Nugget,1 point,Sat Jun 20 20:57:44 2015 UTC,"As a beginner I would say that const indicates a clear message that the variable is not to be changed once initialised (run-time constant as opposed to compile time constant constexpr). It also allows the compiler to make optimisations intended for read-only operations.  Apart from that I'm not sure if there's much else. I'm confused about the fact that const_cast and mutable capabilities exist though as they spit in the face of what const stand for and in the case of the former, even cause undefined behaviour."
cpp,3agknb,F-J-W,3,Sun Jun 21 05:30:55 2015 UTC,"As a beginner I would say that const indicates a clear message that the variable is not to be changed once initialised   Yes, but why would I want to do that? Why can't I just write the values directly into my calculations?  These questions are relatively easy to answer, but they must be answered and way to often they are not or not in a good way. Furthermore making a variable const is a nice thing, but you can really live without it; the really important point for const is to add it to function parameters and, in case of methods to *this, the important point being that this eradicates entire classes of bugs without much effort and makes the code much easier to understand.  Contrary to popular opinion however, const doesn't help that much with optimization (unlike constexpr).     Why is there const_cast   Because some library-authors are idiots and don't anotate function-parameters that never change their argument as const. const_cast can be used to work around that without having to sacrifice const-correctness in your own code.  If you only use well written libraries, you should never need it.   Why is there mutable?   Because a const method should not change the semantic value of an object but may change the bit-representation of that value. A very simple example:  class foo { public:     void set(const std::string& str) {         std::lock_guard<std::mutex> guard{m_mutex};         m_str = str;     }     std::string get() const {         std::string tmp;         {             std::lock_guard<std::mutex> guard{m_mutex};             tmp = m_str;         }         return tmp;     } private:     std::string m_str;     mutable std::mutex m_mutex; };   Putting aside that we would normally like to stay away from that lowlevel synchronization, this shows how we can use mutable in a reasonable way:  Even though the const-method actually changes the value of the mutex, the value that I care about from a semantic perspective (the string) will stay the same.  Yes there are only very few situations like that and the important thing to note is that C++ is a language that is not intended to be extremely pure but for experts in the real world where it is important that you are able to override some rules."
cpp,3agknb,chambolle,1 point,Sun Jun 21 11:56:10 2015 UTC,I disagree with the pointers. Pointer are not complex to learn. Use pictures showing what happens in memory. If you avoid pointers then the student will use badly the language and not really understand what they do. This is acceptable in Python but not in C++. Pointer define an indirect access to data. You can not avoid this concept in programming or in algorithmics. Students have to understand the difference between the index i of an array T and the content of T[i] Pointers is just the same thing.
cpp,3agknb,F-J-W,2,Sun Jun 21 09:49:36 2015 UTC,I am not saying that they are hard to understand. I am saying that they are hard to use without creating memory-related bugs and that most of the time they can (and should) be avoided. I am not saying they should never be taught. I am saying that the ways to avoid them should be taught first in order to prevent the people from thinking that pointers are something that should be used all the time.
cpp,3agknb,chambolle,1 point,Sun Jun 21 12:01:06 2015 UTC,"I understand what you say and I disagree. Java uses pointers all the time and people have no problem with that. Thinking that we can avoid considering the memory allocation deallocation while programming in C or C++ is a non sense. If people do not want that then they have to use another language. Honestly, hidden call of ctor, copy ctor, operator= is really more complex to understand than using pointer: you have to use the pair new/delete. What you have to avoid is to return a pointer because in this case the ownership is not clear. If it is what you wanted to say in this case I agree with you"
cpp,3agknb,chambolle,-1,Sun Jun 21 18:33:27 2015 UTC,"I understand what you say and I disagree. Java uses pointers all the time and people have no problem with that. Thinking that we can avoid considering the memory allocation deallocation while programming in C or C++ is a non sense. If people do not want that then they have to use another language. Honestly, hidden call of ctor, copy ctor, operator= is really more complex to understand than using pointer: you have to use the pair new/delete. What you have to avoid is to return a pointer because in this case the ownership is not clear. If it is what you wanted to say in this case I agree with you"
cpp,3agknb,newmewuser4,1 point,Sun Jun 21 18:33:21 2015 UTC,"For some crazy reason pointers to pointers are a different beast for many beginners. It also doesn't help they are introduced coupled with dynamic memory management, for pure sadistic purposes. :)"
cpp,3agknb,diaphanein,3,Fri Jun 26 21:49:45 2015 UTC,"While I was never a tutor, but happened to be in the lab when people were having issues. One of the most common issues i heard was linking problems. I.e. not making the connection between declaration and definition. Its an easy mistake to make, especially if coming from a java or .net background where you dobt typically have to repeat your declarations.  Similarly, unresolved names due to either missing forward declarations, or trying to use members where only a forward declaration has been supplied. For a novice, these can be hard problems to solve where someone with a few laps around their belt may easily spot."
cpp,3agknb,jetucker,1 point,Sat Jun 20 01:58:45 2015 UTC,Thank you!!
cpp,3agknb,johnniebalkany,2,Sat Jun 20 20:56:48 2015 UTC,"In my limited experience I've found one of the biggest hurdles for beginners is a lack of understanding that c++ is value based, ie. assignment creates a copy not a reference. I've seen on a number of occasions bugs to the effect of:  void Foo(Bar b) { /*changes made to b somewhere in here*/ } ... Bar bar; Foo(bar); // bar is unchanged here but person doesn't understand why because Foo should have changed it. // If this were similar code in, for instance, Java or C# bar would have changed.   I'd say a good explanation of object life-cycles, ownership and probably a quick dive into the memory model would help a lot with this. The less black magic there is for the student the better."
cpp,3agknb,mr-agdgdgwngo,1 point,Sat Jun 20 01:10:14 2015 UTC,Thank you so much for your suggestions!!
cpp,3agknb,samsonx,2,Sat Jun 20 20:58:12 2015 UTC,"Make them solve problems on paper first, catch the logic, syntax can always be corrected. By not staring at a screen they are forced to think."
cpp,3agknb,sellswordsc,1 point,Sat Jun 20 16:44:55 2015 UTC,So true! Thank you!!
cpp,3agknb,AntiProtonBoy,2,Sat Jun 20 20:59:44 2015 UTC,"Pointer syntax confused me until I started thinking of the pointer operator as being part of the type. Everything made more sense to me that way. Example:  double* x;   Rather than  double *x;   Now I can think about pointers either way, but at the time when I was learning, the former was crucial to my understanding. I've also found when teaching others about C++ that they've felt much the same way."
cpp,3agknb,iamalsome,3,Sun Jun 21 15:31:27 2015 UTC,"Pointers, pointers and more pointers.  I get the impression that lots of beginner programmers learn a bit about pointers and 'muddle' through without really gaining a deep understanding of them."
cpp,3agknb,biocomputation,1 point,Sat Jun 20 00:05:30 2015 UTC,Thank you for your advice! It is much appreciated!
cpp,3agknb,chambolle,1 point,Sat Jun 20 20:56:25 2015 UTC,"For me, they never really clicked until I started writing assembly.  I initially found references pretty confusing too.  They have confusing syntax, imo."
cpp,3agknb,DragoonX6,0,Sat Jun 20 00:34:04 2015 UTC,"Yes, I was quite confused about references, particularly because of the dot notation for accessing class members. Took me a little while to arrive to the realisation that references were kinda like a safer alternative to pointers."
cpp,3agivb,sellswordsc,2,Fri Jun 19 23:36:47 2015 UTC,"Check out Modern C++ Design by Andrei Alexandrescu. It's a bit dated now, but it's a good starting point for wrapping your head around TMP. You can also find his latest talks on template programming on youtube and msdn's channel9."
cpp,3ad798,klaxion,6,Fri Jun 19 03:56:05 2015 UTC,"I tried it for a bit back in the day (2011) and it basically was completely useless to me.   Maybe I approached it wrong but it went like this:   write some code, and run it, my program goes to state A write some more code containing a syntax error (missing ;), and run it, error happens try to find a way to come back to the previous program state (like reloading my commands in order from the beginning). Never found out how to do this.  go back to an editor, copy the code back there, compile it, fix the error, compile it, run it never tried cling again   Most REPL are convenient because you don't have to wait to compile the code. The interpreters are just blazing fast. In python or ruby the waiting time between editing the code and running it is essentially zero. Try feeding a small C++ code base to cling (is there a way to do this from a CMake compilation database?).   In C++ a big problem is that modifying a single function changes the code of all functions that call it (via inlining), so changing a single function leads you to recompile at least a single TU, and if the code is generic you might have to recompile the world.  Rust is able to compile generic functions to an intermediate representation because all generics are constrained, so there might be a future where such a smart compiler might be possible in Rust. C++ will always have unconstrained generics so this is just too hard."
cpp,3ad798,gnzlbg,2,Fri Jun 19 09:01:39 2015 UTC,I started it and played around with it but I couldn't even figure out how to make functions work.
cpp,3ad798,LoveandRockets,3,Fri Jun 19 07:55:14 2015 UTC,"To use functions, you have to use the .rawInput meta command. They work just fine."
cpp,3ad798,dnesteruk,1 point,Fri Jun 19 15:50:01 2015 UTC,That was helpful. It was kind of hard to find clear examples with Cling.
cpp,3ad798,LoveandRockets,2,Sat Jun 20 06:47:48 2015 UTC,"i use it to test small snippet of code where i try to use constructs that i'm not too familiar with. Cling also helps me in embedded programming: if a piece of code is not directly tied to the hardware, I can check it quickly without having to write immediately a unit test. It helps in the prototyping stage."
cpp,3ad798,nifraicl,1 point,Fri Jun 19 09:19:30 2015 UTC,"My Cling workflow is this: write C++ code in CLion, then pop open CLion's terminal window, fire up Cling, use .L to load up a 'root' header (I typically have one) and run everything on it. If I need to test ideas in place, I will write a function in situ and then transplant it back into my source files.  Unfortunately Cling does not allow modifying existing definitions, so you'll need to .L again to update changes (losing all saved state). Also, Cling is currently not capable of loading Boost headers, which is a bit of a problem."
cpp,3ah4jp,babymoemoe,3,Sat Jun 20 03:17:47 2015 UTC,"Here's why you're getting Z-A sorting: return a.title > b.title;  When you give a comparator to sort(), assuming it follows the rules, then sort() will produce a sequence where each successive element is either equivalent to the previous one, or satisfies the comparator. sort() defaults to using operator<, which produces ascending order. For example, it could produce a sequence 1, 1, 5, 6, 6, 20. In that sequence, 1 is equivalent to 1, then 1 < 5, then 5 < 6, then 6 is equivalent to 6, then 6 < 20. If you want to reverse the order, you can pass greater<int>() to sort(), or better yet greater<>() in C++14.  Your comparator, which is valid, compares titles for greater-than, so you get descending ordering. If you want ascending ordering, you need to compare titles for less-than.  (Never use less-equal or greater-equal with sort(), that violates the rules.)"
cpp,3ah4jp,STL,1 point,Sat Jun 20 03:52:54 2015 UTC,"The code formatting is completely messed up on Reddit, you should put it on Pastebin  Edit: But the problem is in your compareByName function. std::sort wants the comparison function to return true when the first input (a) is less than the second (b). Your comparison function returns true when the first input is greater than the second."
cpp,3ah4jp,switchcasebreak,2,Sat Jun 20 03:36:44 2015 UTC,"You just have to indent your code by 4 spaces:  #include <iostream> using namespace std;  int main() {     cout << ""Meow"" << endl; }"
cpp,3ah4jp,STL,1 point,Sat Jun 20 03:42:11 2015 UTC,"By the way, as far as formatting on reddit goes, add a ""\"" before the ""#"" so that your includes don't show up as header text."
cpp,3a97m2,mttd,3,Thu Jun 18 05:54:25 2015 UTC,"On slide 32, isn't this broken in a more fundamental way then what is outlined on slide 33? This is the bit of code in question:  std::atomic<unsigned> push_pos{0}; void push_back(T t){ unsigned my_pos=push_pos.load(); while(!push_pos.compare_exchange_weak(my_pos,(my_pos+1)%buffer_size)){}   The author states that ""The problem on the previous slide only occurs if the buffer is full."" That's not true though, is it? Isn't there a fundamental race between obtaining the value of the atomic and the compare_exchange_weak? Two producer threads could obtain the same value for my_pos, no?"
cpp,3a97m2,one-oh,5,Thu Jun 18 14:18:03 2015 UTC,"Two threads might at some point have the same value for my_pos, but two threads can never end up with the same values for my_pos after the while loop: After the loop push_pos has been successfully, atomically, updated. That means that the compare_exchange operation a) observed the expected value in push_pos and b) modified it.  Because the operation is atomic, it's not possible that any second thread will also observe the same value and successfully update it to the same new value. Instead a second thread would fail, my_pos would be updated to the new value, and the second thread would try again with the new value of my_pos.  (This is of course ignoring the issue of push_pos wrapping around due to that %buffer_size)"
cpp,3a97m2,bames53,2,Thu Jun 18 15:39:38 2015 UTC,"The problem I see isn't so much with the atomicity, but rather the behavior. The thread that failed the compare_exchange_weak is left waiting for that position to be push_pos again; not to mention it could be beaten to it again. It's a strange way to enqueue."
cpp,3a97m2,one-oh,2,Thu Jun 18 22:55:42 2015 UTC,"If I understand what you mean, that doesn't happen; when compare_exchange_weak fails, it updates my_pos to the new value, so when the thread tries again it's expecting the new value, not the one set by its initial my_pos = push_pos.load()."
cpp,3a97m2,bames53,1 point,Fri Jun 19 01:23:07 2015 UTC,"Damn. I RTFM too quickly. You're absolutely right. Thanks for your time and patience. Makes sense now.  I guess I better order that book on C++11 now. I'm not using it yet, but that's no excuse."
cpp,3a97m2,one-oh,0,Fri Jun 19 12:44:31 2015 UTC,"A little bit of nitpicking, but this is a bad push:  void push_back(T t){   {     std::lock_guard<std::mutex> guard(m);     q.push(t);   }      c.notify_one(); }   This way notify may squeeze between predicate check and actual wait in pop and here your are - waiting on a queue that already has an item. A proper push would be something like this:  void push_back(T t){   std::lock_guard<std::mutex> guard(m);   if(q.empty())c.notify_one();   q.push(t); }"
cpp,3a97m2,Ksecutor,3,Fri Jun 19 08:57:08 2015 UTC,I actually find your way to be slower in practice and the usual advice is to avoid doing a notify while holding a mutex.  If you do a notify while holding a lock then often the waiting thread wakes up only to go back to sleep because the mutex is locked.
cpp,3a97m2,sakarri,-1,Fri Jun 19 15:18:57 2015 UTC,"1) It's 'correct, but may be slower' vs 'incorrect, but may be faster'. An item stuck for an indefinite time in a queue is, in most cases, very bad.  2) Have you noticed that 'if' before notify? On high speed most of the time pushing happens in batches. During the batch notify will be called only once. On low speeds it doesn't really matter."
cpp,3a97m2,Ksecutor,2,Fri Jun 19 17:06:17 2015 UTC,"There's nothing incorrect about it.  It is correct and faster.  Can you perhaps explain what you consider to be incorrect about it?  I'm not sure I follow on your second point.  Doing the notify before you even perform the push only exacerbates the issue I mentioned, since it makes it that much more likely that a consumer thread will wake up, try to re-acquire the mutex, and then go back to sleep because the mutex is still being held by the producer thread who is in the process of doing a push."
cpp,3a97m2,sakarri,6,Fri Jun 19 17:11:25 2015 UTC,Releasing the mutex before notifying the condition_variable is absolutely correct and more efficient. Source: we're doing this in the STL's implementation.
cpp,3a97m2,STL,0,Sat Jun 20 04:02:44 2015 UTC,"Uh. That was a brainfart about incorrectness. Sorry about that. However, this whole thing with notify outside of synchronization was still troubling me. By moving notify outside you don't decrease the load on push. Actually you increase it, since notify is called every single time. Whole idea with 'wake up, try to re-acquire' is somewhat questionable. If I were OS developer, I would move notified thread from 'wait on condition' to 'wait on mutex' without actually switching context. But what notify outside of synchronization might do is increase number of useless wakes. If pushed item is consumed before notify, then some thread will wake, lock mutex, check that the queue is empty, and wait again. I throwed a quick test. It's in no way comprehensive, but at least simulates one of possible scenarios.  #include <mutex> #include <thread> #include <atomic> #include <condition_variable> #include <functional>  int main() {   using namespace std;   int miss[2]={0,0};   mutex mtx;   condition_variable cnd;   volatile uint64_t q=0;   atomic<bool> theEnd(false);   auto consumer=[&](int n)   {     while(!theEnd.load(memory_order_relaxed))     {       {         unique_lock<mutex> ul(mtx);         while(q==0 && !theEnd.load(memory_order_relaxed))         {           cnd.wait(ul);           if(q==0)++miss[n];         }         if(q>0)--q;       }       std::this_thread::yield();     }   };   thread t1(bind(consumer,0));   thread t2(bind(consumer,1));   const int N=1000000;   for(size_t i=0;i<N;++i)   {     {       lock_guard<mutex> lg(mtx);       //my variant       //if(q==0)cnd.notify_one();       ++q;     }     //your variant     cnd.notify_one();     std::this_thread::yield();   }   while(q!=0)std::this_thread::yield();   theEnd.store(true);   cnd.notify_all();   t1.join();   t2.join();   printf(""%d+%d=%d\n"",miss[0],miss[1],miss[0]+miss[1]); }   Tested on Mac mini with corei7 and latest Mac OS X. Compiled using Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn).  Here are results for 10 runs:  My variant:  miss: min=3, max=499, avg=105.3 time: min=0.939, max=1.563, avg=1.3959   Your variant:  miss: min=121337, max=134549, avg=126771.7 time: min=4.952, max=5.144, avg=5.0301   I understand, that this test is synthetic and all, but it shows, that at least in some cases notify outside of synchronization might be worse than inside."
cpp,3a97m2,Ksecutor,2,Sat Jun 20 04:41:40 2015 UTC,"If you want your mind absolutely blown, then do one simple change to your test to see just how much faster it is to do the notify outside of the critical section rather than inside of it.  Change this snippet:  for(size_t i=0;i<N;++i) {   {     lock_guard<mutex> lg(mtx);     //my variant     //if(q==0)cnd.notify_one();     ++q;   }   //your variant   cnd.notify_one();   std::this_thread::yield(); }   To this:  for(size_t i=0;i<N;++i) {   bool notify;   {     lock_guard<mutex> lg(mtx);     //my variant     //if(q==0)cnd.notify_one();     notify = q == 0;     ++q;   }   //your variant   if(notify) cnd.notify_one();   std::this_thread::yield(); }   The correctness is preserved.  I changed your code so that N = 30000000 and these were the results:  notify inside of the lock time ./a.out 22+21=43  real    0m20.619s user    0m15.595s sys     0m25.506s  notify outside of the lock time ./a.out 2+1=3  real    0m13.668s user    0m10.268s sys     0m16.920s   That's about a 1.5x speedup."
cpp,3a97m2,sakarri,-1,Sat Jun 20 05:00:11 2015 UTC,"My mind is intact. Yes, it's faster now. I increased number of cycles to 100. Looks like there was something running in background last time, or may be some kind of cache magic, but I rerun tests again and here are results:  My variant:  miss: min=1, max=566, avg=20.85 time: min=0.417, max=1.528, avg=0.814283333333333   Your updated variant:  miss: min=1, max=654, avg=22.25 time: min=0.365, max=1.475, avg=0.89333   Now they are more or less equivalent within statistical deviation.  I compiled this test on Windows 8.1 using Microsoft (R) C/C++ Optimizing Compiler Version 19.00.22816 for x86  Here is my version:  miss: min=1, max=75194, avg=19507.2871287129 time: min=2.56, max=3.691, avg=3.1139900990099   Here is your updated version.  miss: min=1, max=254469, avg=114157.88 time: min=2.622, max=3.745, avg=3.23932   And g++.EXE (i686-posix-dwarf-rev2, Built by MinGW-W64 project) 4.9.2 strongly dislikes your variant. It hangs time to time in notify."
cpp,3a97m2,Ksecutor,2,Sat Jun 20 06:08:07 2015 UTC,"Can't come close to reproducing your results, not by a long shot.  I'm going to assume that you are running your benchmark on a more ad-hoc computer rather than one reserved for performance testing.  Your earlier statement that you were running this benchmark while things were running in the background leaves me to think that perhaps the testing conditions are not exactly well suited for measuring something as sensitive as context switches.  One huge hint that your setup is not remotely appropriate for running sensitive performance tests is the huge margin of error in your tests as well as the deviations.  When I see some tests producing a low of 1 miss, and a high of 75k misses or 250k misses, it suggests that there is simply too much noise to come to any sensible conclusion.  When I run your tests, the deviation from to test to test is incredibly small.  I tend to get a low of 0 misses on both of our tests, and a high of about 15 on my tests and a high of about 90 using yours.  That is a far cry more reasonable than a range from 1 to 250,000 which is basically nonsense.  That basically means that the range of misses when you conduct these benchmarks is anywhere between 0% and 25% (since you're using an N of 1000000).  Also the times in my tests deviate by less than 2% when I run both mine version and yours, whereas your times deviate by 3x to 5x which is absurd...  A deviation from to test to test of 3x-5x pretty much means that your entire test is dominated by noise rather than the actual phenomenon being measured.  I mean think about it... if a run of the program can vary by more than 2x, it means the actual thing you are trying to isolate as part of your measurement is too insignificant to be meaningfully measured compared to other factors and it's those other factors that are dominating the benchmark, not the actual phenomenon being investigated.  One way you could try to alleviate this issue is that instead of running your application 100 times and taking an average... increase the N in your benchmark by 100 and run it once.  As my professional work is very sensitive to performance (automated trading systems), I have access to a variety of machines with different configurations that are reserved and properly setup for doing these kinds of benchmarks.  I can run a very bare bones version of Linux and Windows to make sure that no other process or even hardware interrupts a benchmark to get a measurement that very finely reflects the benchmark itself.  Also if you're saying G++ hangs when doing a notify, that can really only indicate an issue with your setup itself rather than my example.  There is absolutely no reason why condition_variable::notify would hang, in fact it is guaranteed to succeed.  This means that either you didn't properly translate my version and rather introduced undefined behavior somehow, or some other issue which does not in any way reflect the performance of doing a notify outside of a critical section.  EDIT:   Looking over the benchmark the undefined behavior is being introduced by this:  while(q!=0)   q is an std::uint64_t and it's not being protected by any synchronization primitive in that snippet of code.  Reading and writing q is not going to be atomic if you build a 32 bit application, which you suggest you are doing on Windows.  This introduces a date race and hence undefined behavior."
cpp,3a97m2,sakarri,-1,Sun Jun 21 04:11:30 2015 UTC,"On the other hand, real apps are running along with other apps, right? I did some more tests, remade it into more realistic way, with actual queue and deviation decreased a lot. But still no noticeable advantage for notify outside of the mutex lock. I also googled about this topic, and here is what I've found:   Most modern operating systems have wait morphing optimization. I.e. what I mentioned above - the thread is simply moved from waiting on condition to waiting on lock, without any context switching. notify outside of the mutex lock increases number of unnecessary awakes (we saw this). notify outside of the mutex lock breaks predictable scheduling behavior. I.e. if your operating system supports FIFO scheduling policy , it won't work with notify outside of the lock. notify outside of the mutex lock leads to more cases of priority inversion.   And finally - in real apps queue overhead is so small compared to other activities, that even 2x performance gain probably won't be noticeable on a bigger picture. But the person who will support the code after you will probably scratch his head look at that notify..."
cpp,3a97m2,Ksecutor,2,Sun Jun 21 04:31:45 2015 UTC,"Except that I ran your version and my version where the time varied by about 2%, and the difference in performance between those two versions is 1.5x.  You keep running these benchmarks and the deviations keep radically changing, the times vary by 100%s of percentage points, the misses go from 0% to 25%, it's all very ad-hoc and my point is when something is that ad-hoc and wild, you can not make any meaningful statement about it.  Now you can argue that a difference of 1.5x on a queuing operation is tiny or insignificant and by all means depending on your domain it may very well be.  Furthermore if someone wants to do a notify within a mutex, by all means go ahead and do it, it's not actually the end of the world and I wouldn't have even bothered to comment on this issue except that you decided to make the following rather bold claim:   A little bit of nitpicking, but this is a bad push   ...   A proper push would be something like this:   You can't say you want to nitpick on an issue, claim something is improper, it's incorrect and suggest a correction... and then when it turns out that your correction is actually not really a correction at all but just a personal preference of yours... decide to retreat on your original nitpick.  If it's just a personal preference of yours that doesn't make a big deal because you feel the OS will take care of it anyways, then that's fine and you can simply make a post saying ""Hey, I prefer doing a notify within a critical section.""  But if you decide to go all out and claim something is actually wrong, well you can't fault people like myself and STL who actually maintains the C++ standard library for pointing out not only that it's right, but actually is standard practice.  http://en.cppreference.com/w/cpp/thread/condition_variable/notify_one  Quote from the above:   The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.   And your point is also reflected as follows:   However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this ""hurry up and wait"" scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.   But that point only serves to show that you can hold the lock and many pthreads implementations will accomodate your usage, it doesn't justify your claim that doing the notify without the lock held is bad or incorrect or worthy of a nitpick."
cpp,3a6nqx,Resistor510,14,Wed Jun 17 17:23:54 2015 UTC,"I know these posts are just glorified ads for PVS studio, but they're so damned interesting!"
cpp,3a6nqx,youarenotafish,8,Thu Jun 18 01:56:50 2015 UTC,"Yeah, some of the content is a good read. And they are quite clear about the product advertisement, like literally in the first paragraph of the article. I'm okay with that."
cpp,3a6nqx,AntiProtonBoy,8,Thu Jun 18 07:54:47 2015 UTC,"It always bothers me that the majority of the bugs found by this sort of thing are easily solved by ""don't use raw pointers""."
cpp,3a6nqx,o11c,10,Wed Jun 17 17:40:48 2015 UTC,"And compile with ""warnings as errors"" if at all possible. That said, there are a few errors in the article that even a pedantically configured gcc or llvm wouldn't find."
cpp,3a6nqx,ericanderton,1 point,Wed Jun 17 20:59:56 2015 UTC,The biggest power of C++ is also its biggest weakness...
cpp,3a6nqx,henk53,4,Wed Jun 17 18:01:14 2015 UTC,Pointers are definitely not C++'s biggest power
cpp,3a6nqx,Lisoph,1 point,Thu Jun 18 14:03:42 2015 UTC,"I don't know... I mean there's no rating or ranking of ""power"" of course, but it has definitely been said before that C's biggest power is its ability to let you reference memory via a pointer and then do nothing more with it than just that.  Now C is not C++ and C++ brings other things to the table, but I think it still holds to some degree."
cpp,3a6nqx,henk53,1 point,Thu Jun 18 20:10:49 2015 UTC,It is easier to say not to use C++ :). But if you need high perfomance of the library there is no getting away from C++ and raw pointers.
cpp,3a6nqx,chambolle,-1,Thu Jun 18 12:34:22 2015 UTC,don't make statistics on examples.
cpp,3a6nqx,mrmessiah,1 point,Thu Jun 18 08:43:51 2015 UTC,These articles are always fascinating but they make me wish I could afford a license for pvs studio so I could spend all day debugging open source projects. Its a great tool but that price tag!
cpp,3a6nqx,doom_Oo7,5,Wed Jun 17 18:27:25 2015 UTC,"You can also try coverity scan, cppcheck, clang-analyze, clang's -Weverything, address/ub/etc... -fsanitizers, and running your code in 3 different compilers (gcc, clang, msvc) on multiple architectures (i386, amd64, armv5/6/7, mips?). It will catch a ton of things."
cpp,3a6nqx,hotoatmeal,2,Wed Jun 17 22:53:51 2015 UTC,"Valgrind too, although it's being (been?) subsumed by the sanitizers."
cpp,3a6nqx,doom_Oo7,2,Thu Jun 18 07:39:34 2015 UTC,callgrind is awesome however.
cpp,3a6nqx,ericanderton,1 point,Tue Jun 23 15:05:49 2015 UTC,"My biggest gripe with Valgrind is that some libraries perform black magic with memory allocations and throw it for a loop.  Xerces-c comes to mind here.  It requires some deep, dark knowlege in order to get such configurations to yield usable information.  I would much sooner rely on black-box testing of heap behavior, coupled with a tight style guide and static analysis, as you mention.  For me, Valgrind (with all it's amazing potential), is a tool of last resort."
cpp,3a6nqx,klusark,6,Thu Jun 18 13:46:05 2015 UTC,"They give free licenses for open source projects.  http://www.viva64.com/en/b/0092/  Other options if you are interested in doing that. The Clang Analyzer is free and open source. Coverity has a free scan system for open source projects. Visual Studio has a built in analyzer in some versions (used to be ultimate only, but I think it's on more now)."
cpp,3a6nqx,jringstad,7,Wed Jun 17 18:56:02 2015 UTC,"You can also use the free trial which allows you 300 clicks and then just not use the mouse to navigate around, so your clicks won't decrease. Yeah, it's a weird system."
cpp,3a6nqx,STL,8,Wed Jun 17 21:50:59 2015 UTC,VS's /analyze is available in Community.
cpp,3a6nqx,mrmessiah,1 point,Thu Jun 18 02:02:06 2015 UTC,"Thanks for the links. I don't actually have my own open source project, so I don't think I qualify for a free license, I was thinking more about being a free-floating open-source bug-fixing angel, but perhaps I can do something similar with one of those."
cpp,3a6nqx,klusark,2,Wed Jun 17 22:48:25 2015 UTC,Just email them with your plan. I'm sure they'll be accommodating.
cpp,3a6q0t,mttd,8,Wed Jun 17 17:39:37 2015 UTC,"A concise description: ""WebAssembly is a new format for native programs on the web. It aims to support everything that asm.js supports, but allows the VM to sidestep the JS parsing and profiling pipeline entirely. This is a good thing for the VM - less work to support native code.""  More information:  ""WebAssembly is a new virtual ISA being designed to efficiently run compiled code in web browsers and other things, starting with C/C++, and eventually many other languages. WebAssembly distinguishes itself from other virtual ISAs with optimizations to reduce download size and decode time, strong portability and predictability invariants (for example, the base has no undefined behavior in the C/C++ sense), and participation from several browser vendors.""   http://thread.gmane.org/gmane.comp.compilers.llvm.devel/86952 https://github.com/WebAssembly/design/blob/master/README.md https://github.com/WebAssembly/design/blob/master/HighLevelGoals.md https://blog.mozilla.org/luke/2015/06/17/webassembly/ https://blogs.msdn.com/b/mikeholman/archive/2015/06/17/working-on-the-future-of-compile-to-web-applications.aspx"
cpp,3a6q0t,xcbsmith,6,Wed Jun 17 17:41:49 2015 UTC,"Alternative interpretation: ""We're retconning Browser JavaScript to be what Java should have been if Sun had at all figured out how to better integrate it with browsers."" ;-)"
cpp,3a6q0t,__notmythrowaway__,1 point,Wed Jun 17 21:20:59 2015 UTC,Holy shit... You're right. That's one long-ass iteration.
cpp,3a6q0t,BrendanEichMoz,2,Thu Jun 18 00:46:00 2015 UTC,"I play the long game, generally.  /be"
cpp,3a6q0t,greyfade,5,Fri Jun 19 00:17:02 2015 UTC,Finally. This is what I've been arguing for for years!
cpp,3a6q0t,cogman10,1 point,Wed Jun 17 21:44:16 2015 UTC,"Same. The great thing is it has support from Mozilla, Microsoft, and Google.  This is happening!  Finally, the browser is going to break free of its JavaScript shackles."
cpp,3a6q0t,sime,1 point,Thu Jun 18 03:23:46 2015 UTC,"/u/mttd linked to this bug at WebKit: https://bugs.webkit.org/show_bug.cgi?id=146064 Filip Pizlo opened this issue and according to https://www.webkit.org/team.html, he is an Apple employee which is a promising sign in the absence of an official statement from Apple Inc."
cpp,3a6q0t,__Cyber_Dildonics__,1 point,Thu Jun 18 10:46:38 2015 UTC,What are the recent disappointments of C++? Past disappointments I understand.
cpp,3a6q0t,Elador,1 point,Fri Jun 19 04:15:26 2015 UTC,"This is awesome. I hope Visual Studio adds some tooling support in the near future.  That part I found particularly interesting:   WebAssembly applications can use high-level C/C++ APIs such as the C and C++ standard libraries, OpenGL, SDL, pthreads, and others, just as in normal C/C++ development. Under the covers, these libraries implement their functionality by using low-level facilities provided by WebAssembly implementations. On the Web, they utilize Web APIs (for example, OpenGL is executed on WebGL, libc date and time methods use the browser's Date functionality, etc.). In other contexts, other low-level mechanisms may be used.   I'm a bit afraid though that they nowhere mention C++11/14."
cpp,3a6q0t,__Cyber_Dildonics__,2,Sat Jun 20 17:35:29 2015 UTC,Why would that even be a factor?  This is a compilation target. You mean you are worried they won't support all the new multi-threading in C++11?
cpp,3a6q0t,Elador,1 point,Fri Jun 19 08:35:31 2015 UTC,"Well what about the whole C++11/14/17 STL? It sounds like they are using their own somehow? (I didn't read it in too much detail, but it sounded a bit like it)"
cpp,3a6q0t,__Cyber_Dildonics__,2,Sat Jun 20 17:50:13 2015 UTC,"Which parts? If it is data structures and algorithms, they just operate on memory, there is no need for an underlying compilation target to care about high level libraries.   This isn't a new language they are creating."
cpp,3a6q0t,Elador,1 point,Sat Jun 20 21:10:07 2015 UTC,"I don't know exactly to be honest, I'm too little familiar with the stuff. But just look at VS's struggles with offering a C++11/14 compliant STL, and the state of the matters on Android. I think the last thing we need is another STL from another vendor that lacks C++11/14 things (whatever ""things"" are :-) )."
cpp,3a6q0t,__Cyber_Dildonics__,3,Sat Jun 20 21:21:25 2015 UTC,"Ok, please realize this isn't a compiler it is a compiler target.  They aren't making a new stl or C++ compiler."
cpp,3ac6s3,mttd,11,Thu Jun 18 22:28:10 2015 UTC,"It doesn't seem like any intentional hiding to me.  The C manual states that it was based on B, and the B manual states that it was based on BCPL, so the chain of derivation is all there. The C manual omitting that it is based on BCPL doesn't seem that much different than the C++11 standard omitting that it was based on B."
cpp,3ac6s3,vaughncato,3,Thu Jun 18 23:32:00 2015 UTC,"Saw this Olve's talk on the history of C at ACCU 2015 in Bristol - highly entertaining! He is also the reason why I now write my #includes in ""closest first"" order, with the standard library at the bottom, after a previous talk on C++ style."
cpp,3a64no,_VZ_,13,Wed Jun 17 15:05:54 2015 UTC,"Either it should never be empty, or empty should be a relatively normal thing. It being a very rare thing just creates bugs because people will ignore it.  Regarding the solutions: One is missing: require noexcept move-ctor and do a three step assignment:   Create a temporary variable t by copying the new value (may throw) destruct the old value (always noexcept) move-construct the new value from t. (noexcept per requirement)   That aside: I believe that a default-ctor that creates an instance of one of the many arguments is a bad-idea. Make that ill-formed and maybe offer to pass in an instance of std::integral_constant<std::size_t, N> that tells the ctor to default-construct the N'th value.  Regarding a tag-type to allow empty states if they are not always allowed, I believe that we already have that “type” in the core-language: void  I think it is obvious what it would mean and it represents a clean solution."
cpp,3a64no,F-J-W,3,Wed Jun 17 15:58:31 2015 UTC,"I actually implemented a variant for fun a while ago. I went with this solution, and still believe it is the only logical way to implement the assignment. Who the hell writes a type that is not nothrow_move_ constructible, seriously?"
cpp,3a64no,sbabbi,8,Wed Jun 17 18:10:01 2015 UTC,Everyone who forgets to annotate a non-implicit move-ctor.
cpp,3a64no,F-J-W,1 point,Wed Jun 17 18:18:51 2015 UTC,"Who the hell writes a type that is not nothrowmove constructible, seriously?   That's just what I thought but it seems this is very common :/"
cpp,3a64no,gnzlbg,1 point,Thu Jun 18 08:54:15 2015 UTC,"std::pair<legacy_type_with_throwing_copy_ctor, std::string> has a possibly throwing move ctor."
cpp,3a64no,sellibitze,1 point,Thu Jun 18 12:45:10 2015 UTC,I've written one when I had to pass the address of an object to a legacy C function and couldn't modify it after initialization. But that's a rare case...
cpp,3a64no,Shokwav,2,Fri Jun 19 04:58:38 2015 UTC,"You could also make the presence of a default constructor conditional on whether void is one of the possible types. If it is, enable the default constructor and have it construct a void variant.  Also, if void is a possible type, you could drop the requirement that the move constructors be noexcept and do it like the article suggests."
cpp,3a64no,suspiciously_calm,1 point,Wed Jun 17 20:56:59 2015 UTC,"I thought so as well but the article explains it better than I can:   Secondly, it changes the order of operations: the old value is not destroyed until after the new one has been constructed, which can have surprising consequences if you are not expecting it."
cpp,3a64no,vlovich,0,Wed Jun 17 17:24:30 2015 UTC,"You can say that just about everything, I fail to see how this specific thing affects code that isn't terrible to begin with though."
cpp,3a64no,F-J-W,2,Wed Jun 17 17:55:27 2015 UTC,"What else can you say this about? Such ""out of order"" execution almost invariably leads to at least some problems and it would clearly be better to not have it even if, admittedly, this is a second order concern compared to not allowing empty variants which is absolutely critical IMO."
cpp,3a64no,gnzlbg,1 point,Wed Jun 17 22:07:12 2015 UTC,"I like your solution: move constructors are noexcept for most of std types and it is a general guideline that they should be noexcept for user defined types as well.  At the same time, I want variants to be default constructible, and thus they should have an empty state, but I don't like to have a tag type for that.   What does a default constructed variant mean?  Since a variant can have many values, but the user didn't care enough to pass any to me it means that is empty. All the arguments about default constructing the first type that is default constructible seem very complicated. At least if one access an empty variant one gets a loud exception. Getting a default constructed random value from the variant looks like more prone to cause silent bugs to me."
cpp,3a64no,eric_niebler,3,Wed Jun 17 17:41:20 2015 UTC,"move constructors are noexcept for most of std types   The node-based containers (list, map, set and friends) do not have noexcept move constructors, and can't (depending on how you choose to read the standard).   I want variants to be default constructible, and thus they should have an empty state   That doesn't follow.   All the arguments about default constructing the first type that is default constructible seem very complicated.   Nobody is arguing for that (at the moment)."
cpp,3a64no,minno,2,Wed Jun 17 18:38:37 2015 UTC,"Could you explain why those containers can't be moved without possibly throwing exceptions? As I understand them, default-construction followed by an elementwise swap should be a valid move constructor."
cpp,3a64no,sakarri,2,Thu Jun 18 00:11:43 2015 UTC,"Those containers use so-called sentinel nodes to mark the end of the container.  So std::list has a dummy/sentinel node to represent the end().  These dummy nodes can be dynamically allocated, or they can be embedded within the container.  If they are dynamically allocated well then obviously even just constructing the container may throw an exception since that involves a dynamic allocation.  The same goes for moving it as well since a move operation will have to allocate new sentinel nodes which could fail.  So dynamically allocating the sentinel node can not be nothrow.  If they are embedded within the container then you avoid a dynamic heap allocation, which is generally a good thing... but the downside is that you end up with iterator invalidation when doing a swap.  Since the sentinel node is embedded inside of the container and is used to refer to the end() it means that after a swap, the iterator to the end() will be invalid.  Now this is where there is contention.  The standard says it's permissible for a swap to invalidate an iterator to the end(), but it also implies that it's okay for it to not invalidate that iterator.  It's basically up to the implementation to decide.  An implementation can choose to make move constructors non-throwing, or make swap preserve end iterators, but it can not do them both."
cpp,3a64no,Plorkyeran,2,Thu Jun 18 03:45:21 2015 UTC,Wouldn't only move construction and not move assignment require allocating? In the latter case both containers already have sentinel nodes created.
cpp,3a64no,sakarri,2,Thu Jun 18 03:56:20 2015 UTC,"For move assignment, A = std::move(B)... to preserve iterators you would need to move B's sentinel over to A and B would need to allocate a new sentinel to represent its new end.  That allocation could potentially throw, and hence move assignment can not be noexcept.  I read the ISO C++ mailing list and remember reading about various ways to solve this problem, and it's unbelievably ugly, not to plug Rust or anything, but they got this right.  In Rust, move operations never throw, for any object, period.  Moves in Rust just work as you would expect them to and I think C++ could potentially learn from that language by making move semantics destroy the original object, as in make the object unusable after a move operation.  If the object becomes unusable after a move... this problem goes away, along with a host of other issues."
cpp,3a64no,Plorkyeran,4,Thu Jun 18 04:00:45 2015 UTC,"For move assignment, A = std::move(B)... to preserve iterators you would need to move B's sentinel over to A and B would need to allocate a new sentinel to represent its new end.   Why can't you just swap the sentinels?"
cpp,3a64no,whichton,2,Thu Jun 18 04:23:51 2015 UTC,"There was a proposal for destructive move, but it got rejected I believe. Destructive move is very useful for things like sorting a container.   Problem is C++ constructor does 2 very different things - it allocates memory, whether on stack or heap and then it constructs the object on the heap. C++ has no way to express the ""has memory but not yet constructed"" state. Hence we often find the default constructed object being used as a proxy, which is incorrect. Stepanov has argued for such a state is his papers, and I believe the destructive move proposal was in response to his ideas"
cpp,3a64no,whichton,1 point,Thu Jun 18 05:35:34 2015 UTC,"Why can two different lists not share the same sentinel node? That is:  list<int> x; list<int> y;   will have the same sentinel node, which will be a static member of list<int>. Does that not work ?  Also, are sentinel nodes mandated by the standard? You can have an end iterator without using sentinel nodes."
cpp,3a64no,sakarri,2,Thu Jun 18 04:42:39 2015 UTC,"std::list is a doubly linked list, so it allows forward and backward iteration.  If two different lists shared the same end() node then you wouldn't be able to decrement from the end()."
cpp,3a64no,whichton,1 point,Thu Jun 18 04:57:21 2015 UTC,"Doh! Thanks for the explanation, I need more coffee it seems :)"
cpp,3a64no,TiagoRabello,1 point,Thu Jun 18 05:36:18 2015 UTC,"AFAIK, some node-based containers require allocation of sentinel nodes even for the empty state and as such may throw while making the moved from variable destructible. Maybe /u/STL can give us more insight into the problem."
cpp,3a64no,STL,2,Thu Jun 18 03:27:42 2015 UTC,"Between them, /u/sakarri and /u/Plorkyeran have explained it. Move assignment doesn't have to allocate, ignoring POCMA."
cpp,3a64no,TiagoRabello,1 point,Fri Jun 19 05:23:16 2015 UTC,"Yeah, that was what I thought. Thanks for the reply!"
cpp,3a64no,gnzlbg,2,Sat Jun 20 14:28:17 2015 UTC,"I want variants to be default constructible, and thus they should have an empty state   That doesn't follow.    How can I default construct a variant of non-default constructible types without an empty/invalid state?  IIUC at least one type must be default constructible for this to be possible.   Nobody is arguing for that (at the moment).   That's sad! The OP mentioned it briefly:    One alternative options is that default construction picks the first default-constructible type from the list, if there are any, but this still has the problem of different orderings behaving differently.   I don't want empty variants but I want default constructible variants. When should a variant be default constructible? If    all of the types are default-constructible, or the first type is default-constructible, or any of the types is default-constructible,    and why?   After giving this some thought, all options suck a bit. In the mathematical discriminated union that the variant is trying to model, the order of the types does not matter. I am getting more inclined to eliminate element access by index and allow only access by type, which is possible if there are no duplicated types. Then, the variant should try as hard as possible to be default constructible, that is, be default constructible if any of the types it contains can be default constructed. Which type it will be default constructed should be unspecified, if the user didn't care to default construct a particular type, then that is just the way it is.  In particular, I would hate to see variant wrappers or generic code in the wild that reorders the element of the variant just so that it can be default constructible.   The node-based containers (list, map, set and friends) do not have noexcept move constructors, and can't (depending on how you choose to read the standard).   TIL this. That's really unfortunate! These have to be left in a valid state and this requires sentinel heap allocated nodes so I don't see a way for them to provide a noexcept move constructors."
cpp,3a64no,STL,3,Thu Jun 18 08:18:01 2015 UTC,"The node-based containers can be implemented with dynamically allocated (Dinkumware/VC) or container-internal (libstdc++, libc++) sentinel nodes. While container-internal sentinel nodes avoid allocating in default/move ctors, they sacrifice iterator stability guarantees."
cpp,3a64no,gnzlbg,1 point,Fri Jun 19 05:28:02 2015 UTC,"they sacrifice iterator stability guarantees.   Is this only for iterators pointing to the old sentinel nodes (end iterators) or are there other cases? I think storing end iterators in e.g. a vector is not common (one typically stores iterators to the elements), but I guess this means that these can't be moved while iterating since any loop [begin, end) will break if end is invalidated.   container-internal (libstdc++, libc++) sentinel nodes   Does this mean that for move assignment the container needs to find nodes pointing to the sentinel, and change them to point to the new sentinel?"
cpp,3a64no,STL,2,Fri Jun 19 09:20:03 2015 UTC,"Only end iterators are affected. The scenarios would be storing pairs of iterators representing ranges (which can easily involve the end), or storing iterators to elements that can sometimes represent ""no element"" without an additional bool/optional (you store end to represent it).  With container-internal sentinel nodes, the implementation simply invalidates end iterators during swapping and moving."
cpp,3a64no,gnzlbg,1 point,Fri Jun 19 15:30:55 2015 UTC,"I wonder if iterators of different types as proposed by /u/ericniebler could help here: end could return a sentinel for a doubly-linked list, whose operator!=(iterator, sentinel) checks if iterator points to a node, and if that is the case, if that node has a next element or not."
cpp,3a64no,STL,2,Fri Jun 19 17:21:04 2015 UTC,"No, because end iterators wouldn't be decrementable. And what would happen if you incremented an ordinary iterator to the end?"
cpp,3a64no,eric_niebler,21,Fri Jun 19 17:58:33 2015 UTC,"I was at the committee meeting where this was discussed, and I argued strongly in favor of the current design. The problem with default-constructing to an ""empty"" state is that your programs are now replete with empty variants. It is promoting the empty state to a valid state. This complicates code every time a variant is used. You must now sprinkle your code with ASSERTs or conditionals. That's really undesirable.  By default-constructing to the first element in the variant (like built-in unions do), the only source of ""empty"" variants will be throwing moves. Not only are these rare, but since it's an exception, you have already been notified that your variant is now invalid. Yes, if you swallow the exception and proceed as if nothing has gone wrong, then you can end up accessing an invalid variant. The answer is simple: DON'T SWALLOW EXCEPTIONS. You shouldn't be doing that, anyway.  The design the committee is currently looking at makes it possible to code as if a variant<int, string> can only have an int or a string, without paying for the never-empty guarantee.  Notice the changed terminology. The current design doesn't have an ""empty"" state. It has an invalid state. I don't consider that mere sophistry. If you don't swallow exceptions, you can have your cake and eat it."
cpp,3a64no,eric_niebler,5,Wed Jun 17 18:25:06 2015 UTC,"I was at the committee meeting where this was discussed, and I argued strongly in favor of the current design.    I'm very relieved to hear this! It seems so obvious to me that it must be possible to have a never-empty guarantee that I had real trouble believing the committee was seriously considering removing the possibility to have it, which was the impression I got from the original blog post. It's reassuring to know that this is not the case, thanks."
cpp,3a64no,Plorkyeran,5,Wed Jun 17 20:28:41 2015 UTC,"A valid variant can never be empty. It is possible to have an invalid variant, but only by ignoring exceptions. Well-behaved code doesn't do that."
cpp,3a64no,eric_niebler,3,Wed Jun 17 20:40:38 2015 UTC,Not writing throwing moves seems like a pretty good rule of thumb too. Are there any actual sane use-case for them?
cpp,3a64no,sellibitze,3,Wed Jun 17 20:36:28 2015 UTC,"For rather obscure reasons having to do with sentinel nodes and iterator invalidation, the node-based containers (list, map, etc.) have potentially throwing move constructors."
cpp,3a64no,foonathan,3,Wed Jun 17 20:42:17 2015 UTC,"IIRC one of the motivations to allow throwing move ctors was std::pair<some_legacy_type, some_move_optimized_type> where some_legacy_type only has a possibly throwing copy ctor and some_move_optimized_type comes with a non-throwing move ctor. So, you end up with a possibly throwing move ctor for this pair. But it will be preferable to its copy ctor in the situations where you don't need a move to have the strong exception guarantee.  But yeah, throwing move ctors are making things complicated. In other languages like D and Rust, the move semantics story is much simpler (and a teensy bit less powerful but that's IMHO ok)."
cpp,3a64no,eric_niebler,3,Thu Jun 18 12:36:31 2015 UTC,"You must now sprinkle your code with ASSERTs or conditionals. That's really undesirable.   To actually do something, you need to switch on the type as well. So this argument is invalid, because you already need to have a conditional to check whether the variant has a certain type. And there is absolutely no difference between checking for a certain type or checking for any type. But this type checking is already solved with visitors for variants. They avoid the conditionals and in case of an empty variant, it can simply do nothing. An empty state does not lead to more conditionals than already present.  Otherwise, I completely agree with /u/F-J-W: either you allow an empty state or you don't, i.e. by requiring nothrow move. An invalid state makes it worse."
cpp,3a64no,foonathan,2,Thu Jun 18 13:38:38 2015 UTC,"But this type checking is already solved with visitors for variants. They avoid the conditionals and in case of an empty variant, it can simply do nothing.   Do you really want nothing to happen when you visit a variant that has been made invalid by a failed move? Nothing? Don't you think this would be more likely to hide bugs than avoid them? IMO it would be better to permit the implementation to ASSERT and find your bug for you."
cpp,3a64no,eric_niebler,0,Thu Jun 18 18:07:43 2015 UTC,"Do you really want nothing to happen when you visit a variant that has been made invalid by a failed move? Nothing?    No, I want nothing to happen, when visiting an empty variant. And a variant can get empty after being default constructed, manually reset or as a fallback for a failed move.   And you notice a failed move because an exception is thrown. But with a variant which is allowed to be empty, it is safe to access it after the exception without harm. Because it has a valid, well-defined state: it is empty."
cpp,3a64no,foonathan,3,Thu Jun 18 18:35:21 2015 UTC,This behavior is easily implemented in terms of the variant currently proposed and optional with some trivial forwarding functions.
cpp,3a64no,cdglove,-1,Thu Jun 18 19:20:18 2015 UTC,Of course it is. I was just argueing against your point that an empty state leads to conditionals in user code. This is not the case (idiomatic use taken for granted).
cpp,3a64no,suspiciously_calm,2,Thu Jun 18 19:24:18 2015 UTC,"No, I want nothing to happen, when visiting an empty variant. And a variant can get empty after being default constructed, manually reset or as a fallback for a failed move.    Variant is a value type. Value types should never have a valid empty state. What you're saying applies to reference types and is more akin to Java style null checks. I really don't want that. If you do, however, you can implement it yourself in terms of the current variant by making your own 'none' type. The same is not true for the reverse; if variant is default constructed as empty I am forced to check everywhere because empty has been promoted to a valid state. In my opinion it's generally bad design to force users to use a library is a certain way like this."
cpp,3a64no,eric_niebler,2,Fri Jun 19 11:30:07 2015 UTC,"I don't like that the first typename has a special role. Also I agree with /u/F-J-W that having an empty state that can occurr, but only rarely and we kinda try to avoid and discourage it but not completely, is a bad thing.  I disagrees that it complicates matters. Accessing an empty variant is no different than accessing one which currently holds the wrong type.  Basically, I agree with everything /u/F-J-W says."
cpp,3a64no,suspiciously_calm,4,Wed Jun 17 20:50:38 2015 UTC,"I don't like that the first typename has a special role.   Do you feel the same about built-in unions?   having an empty state that can occurr, but only rarely and we kinda try to avoid and discourage it but not completely, is a bad thing.   I'm sure you would agree that swallowing exceptions and continuing as if nothing went wrong is a bad thing. Should we compromise the design of our vocabulary types -- complicating their use everywhere and for everyone -- to accommodate bad code? No.  There is no empty state. There are invalid variants that can only be encountered in bad code."
cpp,3a64no,david_sankel,1 point,Wed Jun 17 22:12:08 2015 UTC,"Do you feel the same about built-in unions?   Yes.   I'm sure you would agree that swallowing exceptions and continuing as if nothing went wrong is a bad thing. Should we compromise the design of our vocabulary types -- complicating their use everywhere and for everyone -- to accommodate bad code?   It doesn't complicate use, since a variant holding the wrong type is also a real possibility, and it doesn't complicate the design of the type either, since the ""invalid state"" representation has to be there anyway. The only difference is whether the default constructor constructs an empty variant or one of the variant types which is selected by some arbitrary rule."
cpp,3a64no,3453280,10,Thu Jun 18 12:09:04 2015 UTC,"I think the current std variant design is about as close to ideal as we can get with C++. I was also at the meeting where this was discussed and was strongly in favour of the design.  std::tuple is an attempt to mimic the mathematical cross product. In other words, given types A and B, I want a std::tuple<A,B> to have a value of type A and a value of type B. No one would argue that std::tuple<A,B> should also have another state called ""empty"" where it contains neither a value of type A nor a value of type B. The same reasoning works with std::variant when we see what it is attempting to model.  std::variant is an attempt to mimic the mathematical discriminated union. In other words, given types A and B, I want a std::variant<A,B> to have a value of type A or a value of type B. Again, a state called ""empty"" makes little sense given what we are trying to model.  std::variant has an invalid state because of the strange C++-ism of throwing copy-constructors. An invalid state certainly isn't desirable, but it beats all the alternatives. The case where it arises is very rare and, because an exception is thrown, the programmer is already informed that there is a problem and can deal with it. The end result is that we get a std::variant type that we can safely assume is valid when passed as a parameter to a function. We make the same validity assumption when we skip null checks for references passed to functions."
cpp,3a64no,gnzlbg,2,Wed Jun 17 22:18:02 2015 UTC,"you cannot simply construct a variant<T,T> from a T: instead you must use the special constructors that take an emplaced_index_t<I> as the first parameter, to indicate which entry you wish to construct. Similarly, you can now no longer retrieve the value merely by specifying the type to retrieve: you must specify the index, as this is now significant.   Yes, this is exactly the rule that is now in place for get<T>(tuple&): the program is ill-formed unless T uniquely selects a component, and IMO it is a good rule. In all other cases you can use the same type-based indexing that was in v2. If it is indeed a niche application, the number of cases where numeric-indices are used will be similarly small.  I don't expect variant<T,T> to be a common type at API boundaries, but I might want it as intermediate within a function. Its the same as a T and bool basically, so I'm thinking of the case of a ""control"" variable in a loop where I might want the option to rewrite it with a variant.  Also, this wish about visitors."
cpp,3a64no,gnzlbg,3,Fri Jun 19 03:35:52 2015 UTC,"Stack allocated where? In the variant like the author proposes or in the stack of its copy assignment operator?   The only solution that works is the one the author proposes but the variant size won't be the size of the largest type but the sum of the sizes of the two largest types, which means that for a variant<string,vector> you get a variant that is twice as large."
cpp,3a64no,gnzlbg,1 point,Wed Jun 17 15:38:58 2015 UTC,"So suppose I want to assign a new type to the variant:  I copy construct it into a stack buffer. That might throw.  If it throws, the old type remains in the variant. Yay!  If it doesn't throw, I first destroy the type in the variant; this is required not to throw. Then I have to copy/move assign the new type from the stack buffer of the copy constructor into the variant buffer (because the stack buffer of the copy constructor is destroyed at function exit). But this operation can throw, so this just delays the problem.   I thought that move constructor could be required not to throw but as Eric pointed out above, they can for some types (like all the node-based containers in the STL).  By requiring the second buffer to be in the variant, the second copy/move construction is not necessary, so if the first one succeeds, we just change the ""active"" buffer of the variant to be the new one (in a way that cannot throw), and destroy the type in the old one."
cpp,3a64no,bob1000bob,2,Wed Jun 17 17:28:45 2015 UTC,"I don't know of any widely used variant implementation with a double buffer so I doubt anybody wants to standardize one that does.   What is probably going to happen is that if copy construction fails, an exception will be thrown, and the variant will be left in an invalid state. Using an invalid state will be UB, and that can only happen if the programmer explicitly swallows the exception and uses the variant without assigning it a valid state.   All other alternatives are too complicated and have too many downsides."
cpp,3a64no,no1msd,-2,Wed Jun 17 18:54:15 2015 UTC,Stack allocated where?   perhaps a static thread local buffer for every type T?
cpp,3a64no,eric_niebler,1 point,Thu Jun 18 08:52:04 2015 UTC,"Slightly offtopic, but can anyone tell me what do these voting results mean? SF=0 WF=0 N=8 WA=4 SA=2"
cpp,3a64no,Elelegido,3,Thu Jun 18 10:16:45 2015 UTC,"Strongly Favor, Weakly Favor, Neutral, Weakly Against, Strongly Against."
cpp,3a64no,vlovich,1 point,Thu Jun 18 12:45:33 2015 UTC,Maybe returning optionals could be better if emptiness is allowed.
cpp,3a64no,eric_niebler,0,Wed Jun 17 18:35:16 2015 UTC,"I agree that default construction should leave it in an empty state.  Since the empty state is unavoidable, then maybe it's OK for a copy-exception to leave it in the empty state.  The empty state should explicitly be an invalid state where any attempted operation throws including copy, copy-assignment, etc.  I would be interested to know when the destroy after copy-complete state can cause issues.  Is this something that can be detected & unsafe values rejected at compile-time?  I'm also curious why allocating a temporary if the type you are copying is not noexcept copy constructible is such an undesirable behaviour that it's worth it to introduce potentially unwieldy API semantics rather than take the hit of allocating on the heap."
cpp,3a3qq9,aearphen,7,Wed Jun 17 00:11:20 2015 UTC,no-modules    Oh no! Why did you have to remind me?   *gloomdooms around*
cpp,3a3qq9,elperroborrachotoo,7,Wed Jun 17 04:08:37 2015 UTC,"We have to thank Oracle for dropping the ball on Java mobile support, by not providing neither JIT nor AOT compilers, instead trying to push that monstrosity known as Oracle ADF Mobile.  Which leaves C++ as the only free solution that is available in all OS vendor SDK, although those of us that wish to use it on Android have earned our scars, given how the Android team deals with those that dare to touch it."
cpp,3a3qq9,pjmlp,1 point,Wed Jun 17 16:31:29 2015 UTC,You forgot JavaScript.
cpp,3a3qq9,iends,3,Wed Jun 17 07:11:20 2015 UTC,"No I didn't.  It isn't part of Android SDK, hence why I left it out.  Also the point being native apps. JavaScript belongs in the browser."
cpp,3a3qq9,pjmlp,-4,Wed Jun 17 15:51:32 2015 UTC,JavaScript belongs in the browser.    C++ is just a OO Extension on top of C.
cpp,3a3qq9,mgoerlich,4,Wed Jun 17 15:55:24 2015 UTC,That just shows how little C++ you know.
cpp,3a3qq9,pjmlp,2,Thu Jun 18 06:11:27 2015 UTC,And how little you know about Javascript and sarcasm ;)
cpp,3a3qq9,mgoerlich,19,Thu Jun 18 16:48:52 2015 UTC,"I smirk smugly when the kids these days dismiss C++ as some kind of uncool, backwards exotic animal. It means they lack the skills to even be a factor in anything close to the platform or in any way low-level, and I'm ahead of them in this regard, with decades of advantage. And they're not even going to catch up, cause they're not even trying."
cpp,3a3qq9,SushiAndWoW,16,Thu Jun 18 20:29:58 2015 UTC,"Yup. And frankly, low level and systems programming is just more fun anyway!"
cpp,3a3qq9,Speedloaf,4,Wed Jun 17 07:49:25 2015 UTC,This is what I am hoping :)   Everything that interests me is C++ (or C) which is why I have picked it as the language I want to work with most. It will be a long time before I am not-awful but every day I am learning something awesome about C++. It is huge but it seems like there isn't anything I can't do with it!
cpp,3a3qq9,kozukumi,6,Wed Jun 17 13:19:11 2015 UTC,I am just learning C++ as my first native language (after the basics of Python) and I am loving it! The tools are amazing and free! I am learning with MSVC (VS2015 RC) and MinGW (Cheers /u/stl!).
cpp,3a3qq9,kozukumi,6,Wed Jun 17 16:47:01 2015 UTC,Yay! You're lucky to start learning now - stuff was so much more primitive when I started with C++ back in 2002.
cpp,3a3qq9,STL,3,Wed Jun 17 16:45:20 2015 UTC,"Oh cool it is STL! :D   I have been watching all your Core C++ videos on Channel 9. They are great (as are all the videos on Channel 9). I love how you still rock Metapad. That was my goto editor for a long time, I switched to Notepad2-mod now though for slightly nicer text rendering and syntax highlighting.   Thanks so much for your MinGW build, it is great to have a solid and complete MinGW build with all the extras like Boost included."
cpp,3a3qq9,kozukumi,2,Wed Jun 17 17:04:36 2015 UTC,"Yeah, I still use Metapad for the same reason I still use Winamp: learned it in the 2000s, still works, haven't been annoyed enough to change."
cpp,3a3qq9,STL,3,Wed Jun 17 17:12:04 2015 UTC,Shoulda seen it in 1992...   shudder
cpp,3a3qq9,mcmcc,0,Thu Jun 18 03:09:02 2015 UTC,"Not to mention Turbo C++ and the like on DOS. (In a way that was easier though since as a platform DOS is somewhat less complex in some ways than what Win32 was back then, but still. There's just so much that has happened in development tooling the past years it's totally silly.)"
cpp,3a3qq9,excessdenied,2,Wed Jun 17 20:37:55 2015 UTC,"I agree on this. I understand the need for a catchy title, but defining C++ ""wizened"" sounds just wrong to me."
cpp,3a3qq9,duddo,2,Wed Jun 17 17:48:10 2015 UTC,What about Facebook's React Native? Is Facebook trying two different approaches in order to get the best one of the two? Or is Facebook using C++ for the app core/business logic and React Native for the UI logic handling?  Also there is for some time QT Mobile and I do not hear that much about.
cpp,3a3qq9,elviin,3,Wed Jun 17 16:39:03 2015 UTC,"Regarding Qt, it lacks maturity in the mobile space vs alternatives like Xamarin.   They are still catching up with basic UI components (check their bug tracker), require that you write your own glue for most OS services and expect users to replicate native widgets on their own with QML.   Last time I checked Qt didn't even support all material design or basic stuff like application lifecycles. So if one is expected to spend the effort writing extra glue across all desired OS, better take the approach to use the native frameworks for the UI instead of QML.  Apparently they are focused in customers that want to bring existing code into mobile platforms and not as a platform for writing apps across mobile OS like Xamarin."
cpp,3a3qq9,pjmlp,1 point,Wed Jun 17 14:26:49 2015 UTC,"Native widgets look'n feel is already available in QML for Desktop and at least Android, isn't it?"
cpp,3a3qq9,Cyttorak,2,Wed Jun 17 15:51:57 2015 UTC,"Which leaves iOS and Windows Phone out of the picture.  As for Android last time I tried to use it, there was no support for side panel, toasts, notifications.  EDIT: Just search for someone asking about native support on Android without answer https://blog.qt.io /blog/2015/05/15/qt-5-5-beta-released/  EDIT2: Services aren't supported also, https://wiki.qt.io/QtCS2015_AndroidServices"
cpp,3a3qq9,pjmlp,1 point,Wed Jun 17 17:24:57 2015 UTC,Thanks for the info ;)
cpp,3a3qq9,Cyttorak,3,Wed Jun 17 18:18:15 2015 UTC,Facebook currently isn't using React Native internally.
cpp,3a3qq9,Plorkyeran,3,Wed Jun 17 19:44:15 2015 UTC,"Details are scarce in the article, but there can be no magic.  The app can use any languages it wants, and eventually has to interface with the system. Any language is equally viable in app-specific code. For integration with the system, there has to be glue. Both iOS and Android offer a native system interface, but the system is different and the way code interacts with it, too. So there's the difference in the glue there, and this is where any particular application can benefit from a cross-platform (and cross-language, for better reach) integration framework.  Or you can be Facebook and the write app-specific glue yourself; you can even use that effort to later start your own integration framework. :-)"
cpp,3a3qq9,Gotebe,2,Wed Jun 17 15:53:11 2015 UTC,"Actually, I believe -- I cannot back this up, and I would love to be confirmed or corrected by someone who knows better, but sources I've skimmed seem to indicate it is the case -- that iOS, Android, and Windows Phone all expose C APIs. iOS is a given, seeing as Objective-C is still the lingua franca of that platform. Android has the NDK and JNI stuff, but I seem to remember also reading somewhere about Android libraries exposing ""low-level"" interfaces with which you could write an app, compile it for the given platform (not necessarily a trivial task, given how much ""flavor"" there is to phone hardware and how difficult it is to get precise specs for phones nowadays), and load it onto the phone and run it. Revolutionary! Windows Phone also seems to support native apps, though I haven't done much looking into that platform. With the promised platform integration of Windows 10, however, I can only see native code interfaces expanding.  If all my assumptions are correct here, what it boils down to is C++ is the only high-level language that compiles and runs without bridges or bindings on all phone platforms. Well, I guess Objective-C theoretically would as well, but why would you ever subject yourself to that monstrosity?  It doesn't sound like this is the route Facebook is taking, and I don't blame them, having seen firsthand how difficult it is just to get comprehensive documentation on the native APIs for some of these platforms, but I am convinced a cross-platform mobile native library solution is possible."
cpp,3a3qq9,acwaters,18,Wed Jun 17 04:55:09 2015 UTC,"C++ is first class on iOS (via Objective-C++) and Windows Phone (via C++/CX).  Both allow to write pure C++ code and via those language extensions, provide simple integration with the platform APIs.  Android has a castrated support for C++. The NDK provides a very limited subset of Framework APIs (gyroscope, OpenGL, touch screen, sound card), partiall POSIX support and STL.  Everything else on Android requires either JNI, or bring your own libraries, which might have a big impact on the APK size (e.g. Qt is > 30 MB).  So access to the file system, intents, layouts, assets loading, network frameworks..., all require JNI."
cpp,3a3qq9,pjmlp,3,Wed Jun 17 05:16:59 2015 UTC,"iOS, Android, and Windows Phone all expose C APIs   Yes. Eventually, you reach the system (kernel), and since neither kernel is written in some niche language :-), kernel has a C-like interface.  From there on, it's a question of legalese (does the vendor allow usage of these apis, normally yes), support, community, ease of use etc."
cpp,3a3qq9,Gotebe,-8,Wed Jun 17 07:06:13 2015 UTC,but why would you ever subject yourself to that monstrosity?   As opposed to C++?
cpp,3a3qq9,mercurysquad,2,Wed Jun 17 05:43:02 2015 UTC,At least C++ looks clean :P
cpp,3a3qq9,acwaters,-1,Wed Jun 17 05:28:26 2015 UTC,So now C++ looks clean?
cpp,3a3qq9,dgmdavid,0,Wed Jun 17 05:36:10 2015 UTC,"wizened?  consider the source yadda yadda  jes so you know, objective C development started in the early 80's, about the same time ""C with classes"" took the modern name.  I remember people describing the black NeXT boxes from that time.      java:   Gosling, Mike Sheridan, and Patrick Naughton initiated the Java  language project in June 1991   https://en.wikipedia.org/wiki/Java_%28programming_language%29"
cpp,3a6zso,bbmario,4,Wed Jun 17 18:48:00 2015 UTC,I didn't try it (yet) but Nana seems interesting: http://www.nanapro.org/
cpp,3a6zso,mjklaim,2,Wed Jun 17 21:54:58 2015 UTC,Really interesting and good looking project! Anyone did try it?
cpp,3a6zso,Cyttorak,1 point,Thu Jun 18 09:48:30 2015 UTC,"It seems to be a very cool library but it does have build problems with visual studio.  In the latest build the draw rectangle example doesn't work.  It needs to be (rectangle, bool, color) instead of (rectangle, color, bool)  The rounded rectangle has color and bool reversed as arguments.  Also as a side note the msvc++ 2013 will crash on compiling, although it can be corrected by changing the line it crashes on to use () instead of {}.  Also the intel compiler won't compile the latest build at all, there are many errors."
cpp,3a6zso,__Cyber_Dildonics__,5,Thu Jun 18 16:47:23 2015 UTC,FLTK looks to be unmaintained.  Qt is high-quality & I've seen it be extremely high-performing with easy ways to resolve bottlenecks.  I don't really know any other toolkit that approaches anywhere near that level of quality.
cpp,3a6zso,vlovich,6,Wed Jun 17 23:10:27 2015 UTC,I can't say I've ever run into a situation where I had to particularly care about the performance of my widget toolkit.
cpp,3a6zso,Plorkyeran,2,Wed Jun 17 20:34:41 2015 UTC,"how many widgets do you need to display per second, and on which computer ?"
cpp,3a6zso,doom_Oo7,1 point,Wed Jun 17 23:00:42 2015 UTC,I've seen both fltk and qt support massive apps that are probably beyond what 99% of people would do with them.   What are you planning? Fltk would be smaller I would imagine.
cpp,3a2a28,MikGue,2,Tue Jun 16 17:47:39 2015 UTC,It's exciting to see such an easy and upgrade friendly way to add parallelism to existing STL algorithms but I'm curious why concurrent containers aren't being added? Are transactions considered the first step towards possibly adding it in c++2x?
cpp,3a42cq,bbmario,6,Wed Jun 17 01:48:21 2015 UTC,"Why not C++'s SG13 upcoming Proposal to Add 2D Graphics Rendering and Display to C++?  Is based on Cairo but it should be more C++. The reference implementation is under github.  If you have comments / thoughts about SG13's work, use their forum."
cpp,3a42cq,drac667,2,Wed Jun 17 07:57:09 2015 UTC,"I'm building a GUI toolkit on top of NanoVG, which is a hardware-accelerated antialiased vector graphics rendering library. It's nowhere as featured or performant as Skia/Cairo but for simple use cases it can get the job done.  https://github.com/memononen/nanovg"
cpp,3a42cq,diegoalc,2,Wed Jun 17 05:30:02 2015 UTC,"We use both internally in our products. We find that Cairo is better documented and easier to compile and use, while Skia on the other hand is somewhat faster."
cpp,3a42cq,antialize,1 point,Wed Jun 17 07:04:04 2015 UTC,what's wrong with using sdl2 ? pls elaborate.
cpp,3a42cq,bnolsen,2,Wed Jun 17 05:15:07 2015 UTC,Cairo and Skia are for high performance 2D vector graphics. You can check Skia source code and see how big and complex a library offering such features can get: https://github.com/google/skia/tree/master/src
cpp,3a42cq,diegoalc,-1,Wed Jun 17 05:20:45 2015 UTC,sdl2 gives you the drawing context and handles things like events and has apis for other stuffs.  Also there is some vector drawing support.  So you would still use sdl2 for these other things?
cpp,3a42cq,bnolsen,1 point,Wed Jun 17 15:17:59 2015 UTC,It provides a barebone C API. The functionality itself is not bad but programming to a C API in C++ is always undesirable because it either forces you to write your own C++ wrapper or lose many of the advantages that C++ has.
cpp,3a42cq,guepier,1 point,Thu Jun 18 12:17:43 2015 UTC,"I too am interested to know about this; I have been meaning to start work on a small toy widget library as an introduction to 2D graphics programming, but I am hung on what library to use. In particular, cairo's C++ bindings seem to be nothing more than a paper-thin wrapper around the C API, which bothers me in principle and in execution. The C API seems to be very nice compared to some I've used, and it would be easy enough to simply do the module in C, or even to write my own C++ wrappers, but all the same I'd like the opinion of someone more experienced in 2D graphics before I launch into work with a library I know very little about.  EDIT: OP, you might also consider cross-posting this to /r/computergraphics, too; I'm sure they would have something to say on the subject."
cpp,3a42cq,acwaters,1 point,Wed Jun 17 02:58:06 2015 UTC,"if you don't care about hardware acceleration then AGG (http://www.antigrain.com) is a very good pure C++ 2D graphics toolkit.  It does everything in software and has zero dependency (not even STL), which makes it super easy to port to different platforms (especially embedded systems).  AGG's software rasterizer is also significantly faster than Cairo's (about 2 to 3 times faster in my tests)."
cpp,3a42cq,finalpatch,4,Wed Jun 17 05:01:15 2015 UTC,"agg2.5 went gpl so that's a consideration for commercial software, etc."
cpp,3a42cq,bnolsen,2,Wed Jun 17 05:16:48 2015 UTC,AFAIK the 2.5 code is identical to 2.4 so you can just use 2.4.
cpp,3a42cq,finalpatch,-1,Wed Jun 17 05:29:34 2015 UTC,How about OpenGL? That gets you the best hardware support.
cpp,3a3lir,mttd,1 point,Tue Jun 16 23:27:57 2015 UTC,Can you elaborate on the differences between this and etcd?  Is it just another implementation of the same algorithm or is there a reason someone would use this over etcd?  I'm not as familiar with the state-of-the-art in this space so apologies for the silly question.
cpp,3a3lir,vlovich,0,Wed Jun 17 03:45:14 2015 UTC,"Thanks for doing this. It is great to have such an implementation in C++. A couple of comments/questions.   Documentation: While it is nice to have doxygen docs as a reference, are there more high-level and tutorial style docs available?  RamCloud: Right now it seems that RamCloud uses ZooKeeper. Do you have any instructions on how to use LogCabin instead of ZooKeeper? Replicated Log: Log Cabin provides a key-value store abstraction. Is it possible to get access to the underlying distributed log abstraction? One application that I have in mind for this, would rely more on the distributed log abstraction over the key-value abstraction?   Thanks again for your work. C++ unfortunately seems to have a dearth of distributed computing libraries compared to Java and Go. I am happy that LogCabin provides a distributed consensus library."
cpp,3a24xf,mark2891,3,Tue Jun 16 17:13:16 2015 UTC,Completely shit site on mobile. Even forcing desktop changes nothing.
cpp,3a24xf,Xirious,-10,Tue Jun 16 17:51:59 2015 UTC,Fascinating.
cpp,3a24xf,Patrunjelu,5,Tue Jun 16 18:09:04 2015 UTC,"Being able to consume information in whatever form it's viewed on should be a priority. Voicing my frustration about not being able to view a topic I'm interested in certainly shouldn't qualify as fascinating, even in the sarcastic tone you replied with. Thanks for providing not only no help at all but doing so in the most obscure way possible. What's fascinating is that comments such as yours get upvoted while providing absolutely nothing to the discussion. Granted mine doesn't fair better but my comment would have if I could see the full story."
cpp,3a24xf,Xirious,-5,Tue Jun 16 19:02:42 2015 UTC,Even more fascinating.
cpp,3a0lhv,fritzroid,1 point,Tue Jun 16 07:59:38 2015 UTC,bump
cpp,39xk48,wichtounet,2,Mon Jun 15 16:50:00 2015 UTC,"Here are some tips:  (1)  Keep the units common through multiple tests and within a test,  As an example here you have two different time units   simple_a(1000) : mean: 52.7us (52.7us,52.7us) stddev: 48.7ns min: 52.7us max: 53us througput: 19MEs   And overall you have 3 different types of unit for the same test over different sizes. This is not how these things are done as it makes things confusing     (2)  From a latency pov, knowing the 99%, 95%, 75% and 50% tranches are much more important.     Most people would rather know the answer to the following question:  What percentage of runs is less than X units of time?     (3)  The mean/stddev pair hide multi-model distributions. Makes it hard to detect either emergent algorithmic and/or architectural problems."
cpp,39xk48,CPPOldie,1 point,Tue Jun 16 00:54:34 2015 UTC,"Thanks for the tips :)   Keep the units common through multiple tests and within a test,   Internally, I have only one unit, but the most adequate is chosen for display, otherwise it would lead to very large numbers. Do you think it  would still be better to only display microseconds ? Or at least a command-line option ? The web reports uses only microseconds. Do you think I should also change the throughput to an element/microseconds scale ?    From a latency pov, knowing the 99%, 95%, 75% and 50% tranches are much more important.   I'm not sure I understand this. You take the 99% better and make a range, the same with 95% and so on ?    The mean/stddev pair hide multi-model distributions. Makes it hard to detect either emergent algorithmic and/or architectural problems.   What would you advice in place of mean/stddev ?"
cpp,39xk48,mttd,1 point,Tue Jun 16 11:42:26 2015 UTC,"What would you advice in place of mean/stddev ?   Histograms, percentiles... (one of the problems with averages is that they smooth out the spikes out of existence -- and we can't improve what we can't measure). Come to think of it, I recall seeing one of (I think) Martin Thompson's presentations that had some pretty neat performance measurement tips.  Perhaps it was one of these: https://gist.github.com/nellaivijay/7865306  Will edit / update if I ran across it, perhaps some of these will also be potentially useful in the meantime:  // EDIT: found it, update in another comment :-)   Forget averages, it’s all about percentiles http://gotocon.com/dl/goto-aar-2014/slides/MartinThompson_RespondingInATimelyMannerMicrosecondsInHFTOrMillisecondsInWebAppsItsAllTheTheSameDesignPrinciples.pdf Good measurement is NOT about averages http://www.slideshare.net/mgeddes/advanced-network-performance-measurement"
cpp,39xk48,mttd,1 point,Tue Jun 16 14:35:03 2015 UTC,"UPDATE: found it! :-)  It's basically one talk in two versions (or, two very similar talks, if you like ;]).  Slides:   How NOT to Measure Latency: http://www.slideshare.net/howarddgreen/how-not-to-measure-latency-london-oct-2013 Understanding Latency and Response Time Behavior: http://www.slideshare.net/howarddgreen/intelligent-trading-summit-ny-2014-understanding-latency-key-lessons-and-tools   It's worth noting that they also bring up a very nice visualization idea -- High Dynamic Range (HDR) Histogram: http://hdrhistogram.org/  // GitHub: https://github.com/HdrHistogram/HdrHistogram  It looks like this: http://hdrhistogram.github.io/HdrHistogram/PercentileHistogramExample.png  Note how much more informative it is (including how much more one can extract from it) about the profile of the application's performance behavior -- compared to simply looking at the few, select numbers (whether it's mean, std. dev., or a percentile).  For more context, I'd actually recommend watching the talks. Here are the videos:   Understanding Latency and Response Time: Pitfalls and Key Lessons: https://www.youtube.com/watch?v=G5UskyPG9_o How Not to Measure Latency: https://www.youtube.com/watch?v=DxF077s081Q   // Thankfully, there's very little Azul/Zing/platform-specific in the talks -- mostly a minute or two by the end, and all can be safely ignored :-)  Takeaways:   Standard Deviation and application latency should never show up on the same page If you haven’t stated percentiles and a Max, you haven’t specified your requirements Measuring throughput without latency behavior is [usually] meaningless"
cpp,39xk48,CPPOldie,1 point,Tue Jun 16 20:01:02 2015 UTC,+1 excellent set of take-aways.
cpp,39xk48,CPPOldie,1 point,Wed Jun 17 00:26:41 2015 UTC,"Do you think it would still be better to only display microseconds ? Or at least a command-line option ? The web reports uses only microseconds. Do you think I should also change the throughput to an element/microseconds scale ?   The unit itself is not important, the consistency of units is important. From a readability pov 2-3 digit numbers are ok - so you might want to choose the common unit based on some heuristic that will render the most readable numbers (eg: unit where least number of results with fractional parts etc)  That said most of the time people are interested in performance relative to some baseline run.   I'm not sure I understand this. You take the 99% better and make a range, the same with 95% and so on ?   Sort the times of runs. Then return the max of the lowest 99% of runs, max of the lowest 95%, max of the lowest 75% etc. mttd has given some good reads on this topic   What would you advice in place of mean/stddev ?   If you have the above then you really don't need the mean/stddev. Everything you could determine from mean/stddev can be just as easily determined from the various tranches from above, eg: a large stddev (specially something on the order of the mean) means that there's inconsistencies in run.  Remember most of the things you'll time in code are poisson processes and are by nature not normally distributed."
cpp,39xk48,gnzlbg,3,Wed Jun 17 00:24:24 2015 UTC,TIL that blaze is really way faster than eigen in some micro benchmarks:  http://baptiste-wicht.com/cpm/etl_blaze_eigen/
cpp,39xk48,patrikhuber,3,Mon Jun 15 18:58:38 2015 UTC,"Eigen uses OpenMP to parallelise some of it's algorithms. I recently noticed that it parallelises on gcc and VS, but not on clang. For example, Eigen's PartialPivLU uses all cores if you compile with -fopenmp on gcc, but on clang (I tried 3.5 and 3.7-svn) it never uses more than one core. I think clang doesn't have full (or much/any) openmp support yet, but I didn't dig into it - there's a separate clang-omp. Maybe that's what's happening here as well (the benchmark is done using clang).  Also, it would be interesting to benchmark a bit larger matrices as well (4000x4000, 8000x8000), I've had good experience with Eigen so far but I never tried blaze or etl."
cpp,39xk48,gnzlbg,4,Mon Jun 15 22:58:04 2015 UTC,"In these results, Blaze doesn't use threads, I have disabled it. None of the three libraries use any threading in this benchmark. I have enabled BLAS mode in Blaze and ETL trough. It may be that my Eigen configuration is not perfect. This is not to be taken as perfect benchmarking, it is especially made for me to see where is ground for improvement in ETL.   I can improve it to make it more fair to everybody if you have suggestions. I will consider adding bigger matrices, but it already takes quite a bit of time."
cpp,39xk48,patrikhuber,2,Tue Jun 16 11:45:47 2015 UTC,"Clang 3.7 trunk has ""full"" (as in full OpenMP 3.1) support, but one needs to enable it with -fopenmp and provide it an OpenMP runtime (both the llvm openmp runtime and the gcc openmp runtime work).  And IIRC Blaze is also parallelized with OpenMP, so if both libraries were compiled with clang the results should be comparable (either both have OpenMP or they don't).   I thought it might be related to the lack of AVX support in Eigen (Blaze supports AVX), this could be probably tested by just forcing SSE4.1 or similar."
