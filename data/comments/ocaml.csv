ocaml,3e25zu,gallais,3,Tue Jul 21 11:22:30 2015 UTC,Signed up. Looks like a good opportunity.
ocaml,3e25zu,gregdev,2,Tue Jul 21 14:38:46 2015 UTC,"I've signed up too.  It appears quite basic, but I want to make the course look popular so that they're more likely to make follow-ups. Plus, you never know when you might learn something or have the opportunity to help others in the forum (presuming there's a forum)."
ocaml,3e25zu,QueLogico,1 point,Wed Jul 22 02:45:22 2015 UTC,Thanks! :-)
ocaml,3dq4oz,gallais,1 point,Sat Jul 18 10:29:49 2015 UTC,What does int in the CFML snippets stand for?
ocaml,3dq4oz,f2u,2,Sun Jul 19 17:51:04 2015 UTC,"Coq's stdlib Z - i.e. unbounded signed integers. As a consequence, CFML does not currently provide support for proving pre/postconditions talking about integer overflow, or certifying programs perfoming overflows."
ocaml,3dq4oz,leamrA,3,Sun Jul 19 20:14:08 2015 UTC,I find this (and similar examples of the same kind) rather puzzling. Why go to the trouble of formalizing the language when you do not capture the semantics properly? It's not that integer arithmetic is an obscure language feature.
ocaml,3dq4oz,f2u,2,Mon Jul 20 07:03:12 2015 UTC,Rome wasn't built in a day.
ocaml,3dq4oz,yartaa,2,Tue Jul 21 09:08:38 2015 UTC,"I believe OCaml should have unbounded integers by default (with int{31,32,63,64} for the performance-sensitive cases), not the other way around."
ocaml,3dqaba,eatonphil,7,Sat Jul 18 12:07:23 2015 UTC,"This is a nice, clear, standalone implementation of Maybe in OCaml.  But OCaml already has an option type, ready for a monadic interface. Just like the new result type. Why not use it?  It's also nice (IMHO) to express a base Monad module with a Make functor that can take a type, bind, and return... to create a new monad. Something like:  module type SIG = sig   type α t   val bind : α t -> (α -> β t) -> β t   val return : α -> α t end  module Make (M : SIG) = struct   include M   let join mm = bind mm (λ x -> x)   let map f m = bind m (λ x -> return (f x))   let bind2 a b f = bind a (λ x -> bind b (f x))   let ( >>= ) = bind   let ( >>| ) m f = map f m   let ( » ) m f = bind m (λ _ -> f ())   let lift2 f m1 m2 = m1 >>= λ x -> map (f x) m2   let ignore m = map (λ _ -> ()) m end   Then it's fairly easy to add this monadic layer to the existing option and result... extending their feature-set, adding other monads...  module Opt = struct   include Monad.Make (struct     type α t = α option     let bind m f = match m with Some x -> f x | None -> None     let return x = Some x   end)   let get ~default = λ Some x -> x | None -> default   let maybe d = λ Some x -> x | None -> Lazy.force d end   But...maybe I've taken things too far, and missed the point. :)  Edit to note: Sorry, my ""conceal characters"" (greek and other unicode) came through in the code, instead of valid OCaml. :( New machine, and I must have something misconfigured. If anyone actually wants to paste this verbatim, I'll clean this up."
ocaml,3dqaba,glacialthinker,1 point,Sat Jul 18 15:41:20 2015 UTC,"Thanks for pointing out the option type. I am aware of it (and I think I've used it in the past), but this was really just for me to confirm my understanding.  I don't think you've taken it too far or missed the point! I had a Monad module type signature at first but I eventually removed it just for some simplicity in this single example."
ocaml,3dqaba,glacialthinker,1 point,Sat Jul 18 20:30:32 2015 UTC,"Yeah, sorry -- I didn't realize the larger context of what was going on here until I saw your /r/programming post."
ocaml,3dqaba,eniacsparc2xyz,-1,Sat Jul 18 21:09:10 2015 UTC,"I posted them differently because I figured the backstory was less necessary/interesting here. At least, it is definitely a little more necessary on /r/programming. Didn't mean to cause confusion."
ocaml,3dqaba,Drupyog,2,Sat Jul 18 21:11:17 2015 UTC,"There is Maybe monad in the Core Library in the Option module:   https://ocaml.janestreet.com/ocaml-core/111.28.00/doc/core/#Option   The Maybe/ Option types solves the billion dollar mistake of Null objects, Null references and many boilerplate checking of Null return. Null bugs are a real pain when debugging.  Null References: The Billion Dollar Mistake by Tony Hoare  > #require ""core"" ;; > open Core.Std ;;  Option.bind ;; - : 'a option -> ('a -> 'b option) -> 'b option = <fun>   > Option.(>>=) ;; - : 'a option -> ('a -> 'b option) -> 'b option = <fun>   > Option.return ;; - : 'a -> 'a option = <fun>                                                      >    Despite its benefits the Maybe/ Option monad doesn't tell you the error, it only tells you that the computation has failed. If you want to add an error message and know in which point the computation has failed is better to use the Either monad:   10 Error Handling - FP Complete It is in Haskell but it can be easily translated to OCaml."
ocaml,3ckbfu,ThrowawayTartan,3,Wed Jul 8 16:05:54 2015 UTC,Have you loaded the core package?  M-x merlin-use-package core  Or put the following line in a .merlin file:  PKG core  See https://github.com/the-lambda-church/merlin/wiki/emacs-from-scratch#using-libraries
ocaml,3ckbfu,def-lkb,2,Wed Jul 8 18:00:50 2015 UTC,"Hey there! I didn't, because I was looking for a more automated way to do it (I'm pretty lazy....)   So, anyways someone replied to another comment of mine pertaining to this and the person told me to use  this which basically generates a .merlin with all your opam packages listed inside. Not sure if there's any major disadvantage to doing it this way though..."
ocaml,3b3muq,okaml,11,Thu Jun 25 18:20:40 2015 UTC,"Type inference is so you don't have to write types for things inside a module. Programming in Ocaml would be extremely annoying if you had to declare the types of every variable and every function you declare, as well as instantiate all type parameters whenever you use a polymorphic function.  You are correct that on a larger scale its a good idea to have explicit types for your ""top level"" functions, to keep type errors more localized and to act as a form of documentation. In fact, one of the things I miss the most in Ocaml is Haskell-style type declarations, which can go on a separate line from the function."
ocaml,3b3muq,smog_alado,3,Thu Jun 25 18:28:16 2015 UTC,Programming in Ocaml would be extremely annoying if you had to declare the types of every variable and every function you declare   I wonder how languages supporting type theories too strongs to have type inference do.
ocaml,3b3muq,gallais,2,Fri Jun 26 15:05:23 2015 UTC,"they probably have some partial type inference, that is not guaranteed to succeed. It's the case for Coq, of course, but even for OCaml since polymorphic recursion (especially in GADTs) is not type-inferrable."
ocaml,3b3muq,das_kube,1 point,Fri Jul 3 07:56:53 2015 UTC,This plus things like bidirectional typechecking which make it quite possible to do an awful lot with just toplevel annotations.
ocaml,3b3muq,gallais,2,Fri Jul 3 08:45:28 2015 UTC,i feel like writing signature for module serves as abstracting out interface out of internal design. It is often useful when you want to hide implementation from user.
ocaml,3b3muq,overjoyedml,0,Thu Jun 25 22:19:45 2015 UTC,Seems like this may go against the yagni principal
ocaml,3b3muq,Drupyog,3,Fri Jun 26 18:54:30 2015 UTC,"No, it's just called abstraction. If the internal functions and data structures used to implement your algorithm don't matter to the user, there is no point (and it can even be harmful) to expose them."
ocaml,3b3muq,Ubertekk,2,Sat Jun 27 18:36:24 2015 UTC,"It's also worth mentioning that you can actually use some tools from (I think) Core to automatically generate your interfaces for you, presumably using that same type inference."
ocaml,3b3muq,icspmoc,7,Thu Jun 25 23:40:33 2015 UTC,It's a standard OCaml feature. Just invoke ocamlc with option -i.
ocaml,3b3muq,yartaa,1 point,Fri Jun 26 00:29:37 2015 UTC,"2 points:   Functors require a clearly defined interface for their argument(s). You don't have to write the signature of the whole module, only things that need to be exported."
ocaml,3auz2o,Categoria,5,Tue Jun 23 18:45:11 2015 UTC,"As the author put it:   Everybody hates MySQL.   So I'll be first to jump on the bandwagon and say that it should use postgre. :]  There was a plan to convert macaque to ppx, I'll say more later."
ocaml,3auz2o,Drupyog,3,Tue Jun 23 18:50:07 2015 UTC,"Hi, author here. I wrote Sequoia for MySQL because that's what we use at work and what our customers ask for. Also I'm far from being a DBA though and I'm not very picky about databases :)  It would be really nice to have a ""base"" PPX library for standard SQL, and then plugins with the extended syntax for MySQL, Postgres, etc. I suspect this would be possible with a plugin architecture like ppx_deriving, though I haven't tried figuring out that approach yet."
ocaml,3auz2o,nth0,2,Wed Jun 24 17:26:39 2015 UTC,"How well does it compose? Query builder APIs like SQLAlchemy's let you build queries piece by piece, which is extremely useful for complex selects."
ocaml,3auz2o,MercurialAlchemist,1 point,Wed Jun 24 17:43:28 2015 UTC,As of now it doesn't compose at all.
ocaml,3auz2o,nth0,2,Wed Jun 24 18:51:44 2015 UTC,"I don't think ppx_deriving is the solution.  A few years ago, I discussed with gabriel scherer to overall the macaque's syntax extension. His plan was to basically get rid of the special syntax and use the proper sql syntax directly, because really, there is no reason to invent a new one.  Your library has the same issue. Why try to circumvent the ocaml syntax to express SQL things ? The semantic is different, the syntactic conventions are different (the lowercase issue) and the tools aren't even going to be helpful with the made-up syntax.  You could go the other way and do that: {sql|SELECT t.name WHERE age = $x FROM $my_table AS t|sql} where $x references an ocaml identifier. This means you don't need to learn a new syntax, it's just the sql one. You could also have the tooling be aware of the insertion and load the correct coloring for it (there was something like that on the ocaml mailing list, a few month ago).  It means you need an sql parser, someone probably wrote one for ocaml somewhere ..."
ocaml,3auz2o,Drupyog,1 point,Wed Jun 24 17:49:55 2015 UTC,"It means you need an sql parser, someone probably wrote one for ocaml somewhere ...   This is what I didn't find and had no intention to write :)"
ocaml,3auz2o,nth0,1 point,Wed Jun 24 18:50:58 2015 UTC,"Well, you kinda did one, really. You reconstruct an SQL AST using ocaml's parsetree. It's more limited, but it not's really better/simpler."
ocaml,3auz2o,Drupyog,1 point,Wed Jun 24 18:53:43 2015 UTC,"Kinda, but I learned PPX in the process, which was the goal :)  I guess one could port MySQL's parser to Menhir, which I agree would be a better solution. It's just not one I am willing to work on now."
ocaml,3auz2o,nth0,1 point,Wed Jun 24 19:07:58 2015 UTC,"Note that it should really be:  [%sql {| ... |}]   rather than  {sql| ... |sql}   The text within the delimiters is to avoid the need to use escaping, it should not be used to indicate an extension."
ocaml,3auz2o,lpw25,1 point,Wed Jun 24 22:25:23 2015 UTC,"His plan was to basically get rid of the special syntax and use the proper sql syntax directly, because really, there is no reason to invent a new one.   I disagree. SQL is powerful, but in term of composability, it's downright terrible. Not to mention that it sadly comes in different flavours."
ocaml,3auz2o,MercurialAlchemist,1 point,Thu Jun 25 17:32:00 2015 UTC,"+1 to this. I'm now in a position to avoid MySQL, not dealing with Ruby/Rails helps, so now everything is Postgres unless there is a good reason not to."
ocaml,3anw6a,agumonkey,3,Mon Jun 22 01:33:49 2015 UTC,"Too bad the video isn't HD, it's impossible to read the text on the screen."
ocaml,3ag64k,agumonkey,1 point,Fri Jun 19 21:45:47 2015 UTC,"Neat. Jinja2 is really good. There is also a mustache implementation around, but unfortunately it relies on Ezjsonm's data structures (so you'd better like to have your floating numbers and integers represented the same way)."
ocaml,3ag64k,MercurialAlchemist,1 point,Sat Jun 20 19:00:07 2015 UTC,so you'd better like to have your floating numbers and integers represented the same way   This is how JavaScript works though. There are no real integers.
ocaml,3ag64k,Categoria,1 point,Sun Jun 21 07:50:13 2015 UTC,"I'm aware of it. My point is, this limits the interest of this implementation when you want to use templating in another context (Mustache being a general-purpose templating system)."
ocaml,3ag64k,MercurialAlchemist,1 point,Sun Jun 21 09:06:39 2015 UTC,I guess you're right. I've also thought about providing a way for users to input template substitutions without json at all but haven't come up with a way that I really like.  If you have any suggestions then I'm all ears.
ocaml,3ag64k,Categoria,0,Sun Jun 21 16:16:22 2015 UTC,Nice.
ocaml,3ae24l,eatonphil,2,Fri Jun 19 10:47:01 2015 UTC,You should update them. Sources are here: https://github.com/OCamlPro/ocaml-cheat-sheets
ocaml,3ae24l,lefessan,1 point,Fri Jun 19 17:00:32 2015 UTC,Done for the match syntax that I had mentioned. https://github.com/OCamlPro/ocaml-cheat-sheets/pull/2
ocaml,3ae24l,_lindig,1 point,Fri Jun 19 18:57:16 2015 UTC,Looks pretty complete and useful to me. I noticed that the new syntax for matching an exception as part of a regular pattern match is missing.  match expr with | ..          -> | exception e ->
ocaml,3a1c6a,Categoria,2,Tue Jun 16 13:33:33 2015 UTC,"Fascinating. Out of general curiousity I’m looking forward to a discussion of this point:   (Btw, it would be nice to hear how other build systems compete.)"
ocaml,3a1c6a,the_gnarts,2,Wed Jun 17 05:43:21 2015 UTC,"I have never found build times with OCaml to be an issue but found building with Make tedious. OCamlbuild, which I use from a Makefile that takes care of other build targets, is amazingly simple and powerful. For me, it builds most projects with almost no explicit configuration. To be fair, I only build on Unix systems and building on Windows would create a pain point. I am applauding Gasche'e effort to create better documentation for it as its precise inner workings elude me. I have decided to take a look at the source code. https://github.com/gasche/manual-ocamlbuild"
ocaml,3a1c6a,_lindig,1 point,Wed Jun 17 06:37:17 2015 UTC,I have never found build times with OCaml to be an issue   Really? To me this is a major pain point. Although I wouldn't put all the blame on ocamlbuild for this. Camlp4 is equally responsible.
ocaml,3a1c6a,_lindig,2,Wed Jun 17 16:21:49 2015 UTC,"I'm not using Camlp4 so I can't talk about its impact. Compared to other languages and systems I have seen (C, C++, Java, Scala), OCaml in general seems to build extremely fast."
ocaml,3a1c6a,BluddyCurry,1 point,Wed Jun 17 16:42:34 2015 UTC,You can throw haskell in that list as well. Takes forever to build.
ocaml,3a1c6a,gerdstolpmann,2,Wed Jun 17 19:05:08 2015 UTC,In OMake you have the possibility to run the camlp4 preprocessor only for those source files where you need it. I've described in this in an earlier article: http://www.camlcity.org/knowledge/kb_001_omake_recipes.html#deviating-flags This keeps the additional time spent in camlp4 to a minimum.
ocaml,3a1c6a,_lindig,1 point,Thu Jun 18 14:09:53 2015 UTC,"I would be curious about the aspect of planning and execution of a build plan. Make does not analyse the situation, plan, and execute; instead, planning and execution is interleaved: after a build step, Make looks again at the state of the file system. This allows make to deal with rules that don't state correctly all the files a tool creates in a build step. Does anyone know how OCamlbuild and OMake work in this regard?  A build tool that seperates planning and execution would offer the possibility to compile the build plan to a shell script or similar, which could be executed independently. However, I'm not aware of a build tool with such an architecture."
ocaml,3a1c6a,gerdstolpmann,1 point,Thu Jun 18 05:42:20 2015 UTC,"OMake separates planning and execution. This does not mean that there is no interaction with the file system, though: While it is running OMake records changes of file timestamps and even file digests.  This information is not used for the current run, but only for future runs where OMake exploits it to safely skip already built targets.  From the DSL included in OMake you can in deed access the dependency graph, and emit the build plan in a different format. Funnily, this possibility is even used inside the OMake project, because OMake needs to be bootstrapped with a non-OMake build tool. In order to accomplish this, there are some tricky functions that output OMake's own build plan as a normal Makefile. (But note that the authors of OMake consider these functions as quite hackish.)"
ocaml,3a1c6a,_lindig,1 point,Thu Jun 18 14:21:51 2015 UTC,Part two of Make On Steroids is now online. It talks about the cost of fork/exec and how OMake deals with them.
ocaml,39t31h,_lindig,2,Sun Jun 14 14:34:54 2015 UTC,"There are a few libraries out there for this, if I recall correctly:   Camomile ExtLib/Batteries appears to have a thing for this THIS PPX that somebody posted on /r/ocaml about a month ago"
ocaml,39t31h,chrismamo1,6,Mon Jun 15 00:36:13 2015 UTC,"And that ppx is based on dbuenzli's Uutf and Uunf, which are UTF/Unicode tools which can be used on their own."
ocaml,39t31h,glacialthinker,2,Mon Jun 15 01:27:55 2015 UTC,"I don't think Camomile is still maintained, is it ?"
ocaml,39t31h,MercurialAlchemist,1 point,Mon Jun 15 04:53:49 2015 UTC,"I know that it was at one time the most mature option, but it's been almost a year since it was last updated on GitHub. It's still fairly robust from what I've been given to understand, but you are correct in that it no longer appears to be maintained."
ocaml,39t31h,chrismamo1,3,Mon Jun 15 06:11:15 2015 UTC,Camomile is quite complete and robust. It is not something that needs a lot of changes.
ocaml,39t31h,pcham,2,Mon Jun 15 23:00:15 2015 UTC,"I find the PPX for UTF8 strings interesting. But given that it's very easy to pass UTF8 strings into string functions that are not UTF8 aware I'd like to see support from the type system to tell these strings apart. This is similar to immutable strings and mutable bytes, as they were recently introduced into OCaml."
ocaml,39t31h,MercurialAlchemist,2,Mon Jun 15 07:55:43 2015 UTC,Absolutely.
ocaml,39qd6e,fredyr,3,Sat Jun 13 18:58:16 2015 UTC,"Thanks, exactly what I need while learning!"
ocaml,39fjdl,eatonphil,3,Thu Jun 11 11:26:02 2015 UTC,"You can use function to create an anonymous expression. The real difference is that fun can take multiple (curried) arguments, while function can have multi-branch pattern matching: fun a b -> a*(a+b) vs function [] -> 0 | [_] -> 1 | _ -> 2 The thing you call “operator overloading” has not much to do with overloading. It is shadowing: the values (including functions) and types most recently introduced in the scope (for instance with a local open) are taken whenever there is a name collision (except in the case of record disambiguation)"
ocaml,39fjdl,nbraud,0,Thu Jun 11 12:42:30 2015 UTC,Thank you for your corrections!
ocaml,39fjdl,gasche,1 point,Thu Jun 11 12:53:32 2015 UTC,"A very minor fix: ""foo"" S.(+) ""bar"" does not work as S.(...) is not an infix operator, you have to write S.(+) ""foo"" ""bar""."
ocaml,39fjdl,octachron,1 point,Thu Jun 11 13:02:06 2015 UTC,Thanks for that catch!
ocaml,39fjdl,lpw25,2,Thu Jun 11 16:35:39 2015 UTC,"You seem quite confused about the double comma ;; syntax. A way to think about it is that at the top level of a module, the Ocaml parser can be in two modes: either an evaluation mode or a definition mode. When reading the content of a file (or a module), the parser starts in the evaluation mode. Inside this evaluation mode, the parser can read (and evaluate) a sequence of expression  do_thing_1; do_thing_2; ... do_thing_n   At the end of this sequence of expression, the parser switch to the definition mode. Similarly, inside the definition mode, the parser can read a sequence of definitions  let x = something open M type tautology = unit class void = object end   The double comma ;; is then used to close this sequence of definitions and switch to the evaluation mode.   In other words, the double comma ;; is needed only when switching from the definition mode to the evaluation mode. Switching from the evaluation mode to the definition mode does not require any special syntax. (see also this toy example )"
ocaml,39fjdl,gmfawcett,5,Thu Jun 11 13:02:30 2015 UTC,"The confusion around double semi-colons comes from them having two different uses.  The first is in the REPL, where they are a phrase terminator. In other words they indicate that you have finished writing input and the top-level should start evaluating it.  The second is within structures and signatures, where they are best described as an initialising separator for top-level expressions. In other words they indicate the start of a new top-level expression:  type t = T ;; print_string ""Hello"" ;; print_string ""World"" let x = 6   Note that definitions (the type and let constructs above) are not expressions so they do not need the separator. Some additional confusion comes from let ... = ... being a definition whilst let ... = ... in ... is an expression.  Confusion between the two different uses leads people to often write the above snippet as:  type t = T;; print_string ""Hello"";; print_string ""World"" let x = 6   which makes it harder to see where the ;; are actually needed."
ocaml,39fjdl,BluddyCurry,2,Thu Jun 11 16:01:20 2015 UTC,"Great expanation. Still, I'd rather see double-colons in the REPL only:  type t = T let () = print_string ""Hi""   and  let () =    let h = ""hello, "" and w = ""world!"" in     print_string h;     print_string w   Explicit lexical scoping makes for easier local reasoning, and easier refactoring. Double-colons in source code are a ""code smell"" for me."
ocaml,39fjdl,eras,1 point,Thu Jun 11 17:28:04 2015 UTC,Thank you for the excellent explanation.
ocaml,395ubu,das_kube,9,Tue Jun 9 13:49:46 2015 UTC,Increasing the language syntactic surface for minimal benefit?  I'm not convinced.
ocaml,395ubu,cultural_sublimation,1 point,Tue Jun 9 15:58:23 2015 UTC,Also see the issue on mantis. This construct already exists in rust and other languages.  There is also a while let construct that might be useful in imperative code.
ocaml,395ubu,jdh30,1 point,Tue Jun 9 13:50:42 2015 UTC,"Looks like a bad idea to me. Minimal benefit and there are so many other things crying out to be fixed (like operator overloading, support for basic types like int16, float32 and complex64)."
ocaml,395ubu,dalastboss,1 point,Tue Jun 9 22:40:39 2015 UTC,"But then, is that really likely to be fixed any time soon?"
ocaml,395ubu,glacialthinker,3,Wed Jun 10 02:20:46 2015 UTC,"Yes, with modular implicits... not sure if that will meet the criteria of ""any time soon"", but I'm willing to wait."
ocaml,395ubu,logicchains,4,Wed Jun 10 03:50:04 2015 UTC,"I would like a new, modern ML, in fact -- one compiling to llvm, with implicits, effects typing, a cleaner syntax, 1ML (?). Implicits bolted on in OCaml that late will have a hard time integrating intro the stdlib and existing code. And it's a big change that is not guaranteed to make it into the compiler."
ocaml,395ubu,dalastboss,2,Wed Jun 10 06:43:53 2015 UTC,F*?
ocaml,395ubu,dalastboss,2,Wed Jun 10 10:42:57 2015 UTC,"well, why not! It's almost too powerful (refinement + dependent types make it depend on a SMT solvers, which might be painful in practice). With effects you can do a lot of type inference, see Koka for instance."
ocaml,395ubu,jdh30,1 point,Wed Jun 10 16:57:15 2015 UTC,"If you don't mind me asking: What are the benefits of compiling to LLVM? Also, what is 1ML?"
ocaml,395ubu,octachron,2,Fri Jun 12 20:52:02 2015 UTC,"Llvm has a lot of optimization techniques to offer; currently OCaml does almost none of them. 1ML is a recent paper and language in which modules and records are merged, unlike OCaml where values and modules live in two different worlds."
ocaml,395ubu,jdh30,1 point,Fri Jun 12 23:29:07 2015 UTC,Thanks for the reply. Do you know how this might relate to the flambda work? I heard it was essentially a new intermediate representation that enables a lot of optimization/speedup
ocaml,395ubu,octachron,1 point,Sat Jun 13 01:04:23 2015 UTC,"Flambda will bring more optimizations to the compiler, it's a good thing. Still, it will certainly not be as brutal as llvm."
ocaml,395ubu,jdh30,0,Sat Jun 13 07:36:52 2015 UTC,I just want multicore OCaml running on Android.
ocaml,395ubu,octachron,1 point,Wed Jun 10 16:55:15 2015 UTC,"I don't think I have really missed operator overloading since the introduction of local open. For numerical heavy code, I just define a Float (or Ring, or Tensor, or ...) module which redefine the basic arithmetic operators for the type I am using and open it locally (either at the expression or function level).  As a side benefit, it makes relatively easy to functorize the code over the algebraic structure used."
ocaml,38zq6v,eniacsparc2xyz,11,Mon Jun 8 04:56:19 2015 UTC,Just for fun :  # let ( @< ) x f = f x;; val ( @< ) : 'a -> ('a -> 'b) -> 'b = <fun> # let ( >@ ) f x = f x;; val ( >@ ) : ('a -> 'b) -> 'a -> 'b = <fun> # succ @< List.map >@ [1; 2; 3];; - : int list = [2; 3; 4]
ocaml,38zq6v,thizanne,4,Mon Jun 8 11:21:50 2015 UTC,"Haskell lets you surround an identifier with `...` to get infix treatment. (It's not about the way the function is defined.) This is, in fact, pretty nice for some things.  OCaml treats a function as infix if its name is a symbol beginning with one of =, <, >, @, ^, |, &, +, -, *, /, $, %. If the name is an identifier, it is treated as prefix. There are a few predefined special cases:  mod,  land,  lor,  lxor,  lsl,  lsr, asr are treated as infix.  There's no way to add a new special case, i.e., a new function name to be treated as infix.  OCaml has preprocessors that allow you to make arbitrary syntactic extensions. The mainstream one these days is Camlp5."
ocaml,38zq6v,jeffsco,4,Mon Jun 8 05:02:05 2015 UTC,"Haskell lets you define infix operators, as well as their associativity and precedence. In OCaml you can define new infix operators but are you more limited because the symbols you use define associativity and precedence implicitly: http://caml.inria.fr/pub/docs/manual-caml-light/node4.9.html. That's why you can't define $ in OCaml like $ in Haskell because it needs to be right associative but associates to the left in OCaml.  Before it became part of the standard OCaml, people used to define the equivalent of $ like this:  let (@@) f x = f x such that you can write print_endline @@ String.concat "" "" words rather than print_endline (String.concat "" "" words)."
ocaml,38ur1p,Categoria,1 point,Sun Jun 7 00:16:43 2015 UTC,"Nice, but clearly lacks ASCII art bottles."
ocaml,38ur1p,MercurialAlchemist,1 point,Sun Jun 7 07:33:02 2015 UTC,🍶 A Japanese variation.  🍷 A French variation.  Other versions: 🍺 🍸 🍹  There is a symbol for everyone!
ocaml,38ur1p,Drupyog,1 point,Sun Jun 7 14:13:40 2015 UTC,"Had to install ttf-ancient-fonts to see that, but it's nice."
