proceduralgeneration,3dyfmt,makemeunsee,14,Mon Jul 20 15:38:07 2015 UTC,http://www.jollycyb.org/voronoi_scala/  Check out the presets (first menu from the top) once loaded to get a feel of what's possible.
proceduralgeneration,3dyfmt,donwilson,8,Mon Jul 20 15:39:07 2015 UTC,"Love everything about this, especially the downsampling."
proceduralgeneration,3dyfmt,Sleakes,3,Mon Jul 20 17:13:09 2015 UTC,very cool! Thanks for posting this up! If you have time a post about your tech and what you're doing would be awesome for /r/voxelgamedev we're always interested in voxel-related tech stuff especially spherical planetoid generation has been a great topic!
proceduralgeneration,3dyfmt,conmarap,3,Mon Jul 20 17:46:40 2015 UTC,"you'll like this one then: voxels construction  I'll post it to /r/voxelgamedev too, thanks for the input."
proceduralgeneration,3dyfmt,tejon,2,Mon Jul 20 18:02:19 2015 UTC,Sweet! For my project I've been trying this with either a normalized box or a icosahedron. Is the code available anywhere?
proceduralgeneration,3dyfmt,topaz_riles_bird,6,Mon Jul 20 16:24:54 2015 UTC,"It's on github: https://github.com/makemeunsee/voxels, on the branch ""voronoi"".  The code is written in Scala, but the algo for the voronoi tessellation is actually a translation from some older Haskell code of mine. So it's probably not the easiest to read... I'm happy to explain it, though."
proceduralgeneration,3dyfmt,Naxum,1 point,Mon Jul 20 16:56:44 2015 UTC,So... what about translating it back? :D
proceduralgeneration,3dyfmt,Octahedro,3,Tue Jul 21 09:04:59 2015 UTC,the haskell code is on github too: https://github.com/makemeunsee/interpolateme/blob/voronoi_maze/VoronoiCut.hs Purely functional datastructure and algo by the way.
proceduralgeneration,3dyfmt,BeOFF,2,Tue Jul 21 09:10:58 2015 UTC,"It was cool, but when I saw you're using Scala.js it got really interesting.  Cool stuff!"
proceduralgeneration,3dyfmt,wlievens,1 point,Tue Jul 21 04:38:27 2015 UTC,"yes, I was really pleasantly surprised when I started to use it, it just works and the compiler is really efficient too."
proceduralgeneration,3dyfmt,guyanonymous,3,Tue Jul 21 08:25:10 2015 UTC,This is so rad and inspiring! Been thinking about Voronoi worlds for a little bit now :D
proceduralgeneration,3dyfmt,wlievens,2,Mon Jul 20 18:05:17 2015 UTC,"Nice demo. Which tessellation algorithm did you use?  I also wrote a spherical voronoi tessellator. https://www.reddit.com/r/proceduralgeneration/comments/2nwzug/i_made_a_voronoi_tessellation_generator_and_i/  I wrote mine in C++ and put a lot of work into optimizing it, so it's pretty fast. The source code is available here: https://bitbucket.org/aexo/voronoisphere/src"
proceduralgeneration,3dyfmt,Alcyone85,2,Tue Jul 21 04:14:12 2015 UTC,"It's a custom one, of my own design, and its speed is good but nowhere close to yours. I get a 100 000 cells tessellation in around 13 seconds on my desktop (with pure Scala code).  The web version of the algo is quite slower as I had to make it support javascript callbacks, in order to have a nice, user friendly progress bar instead of a black screen and an unresponsive browser."
proceduralgeneration,3dyfmt,wlievens,1 point,Tue Jul 21 08:40:27 2015 UTC,"This is quite, quite lovely. Reminds me of the final level of Mass Effect 2."
proceduralgeneration,3dyfmt,Alcyone85,1 point,Mon Jul 20 17:50:44 2015 UTC,Question for the geometry experts here: are all cells in a Voronoi tesselation convex?
proceduralgeneration,3dyfmt,guyanonymous,5,Mon Jul 20 18:36:22 2015 UTC,"In an euclidian space and on a spherical plane, yes. With more exotic geometries / metrics, not necessarily."
proceduralgeneration,3dyfmt,wlievens,1 point,Mon Jul 20 18:55:38 2015 UTC,"How hard would it be to create an option that used fractal lines instead of straight lines in a final rendering (e.g., from vertex to vertex after maze creation?).    I'm very interested in trying to use these ideas for creating realistic maps and/or at least height maps - the way I'm seeing things, the placement of fault-lines/mountain ranges, etc - is much more realistic than most software.     Have you tried a smoothed greyscale colour-scheme paired to your height parameters (or perhaps with an adjustable transparent ocean level layer)?  Then an  ability to output the sphere mapped in a few planar projections (up to 30000x15000 pixels would rock and can be dealt with in jpg and bmp file-sizes usually, or in vector form), and presto.... :D  I'd love so see some of these ideas integrated into more programs like FTPro and such....great potential!  Thanks for sharing this work of yours!"
proceduralgeneration,3dyfmt,guyanonymous,5,Mon Jul 20 19:25:28 2015 UTC,"Do you mean like this?  https://dl.dropboxusercontent.com/u/17511787/MapStuff/001.png  Doesn't have height maps, though, only ""fractal""-ish contours."
proceduralgeneration,3dyfmt,guyanonymous,1 point,Tue Jul 21 12:33:08 2015 UTC,"The squiggely borders actually makes it look like real country borders, also the ""borders"" to the sea. I like it."
proceduralgeneration,3dyfmt,guyanonymous,2,Tue Jul 21 14:07:04 2015 UTC,"In my game project, nations consider of several of these territories (here all colored distinct) so the total shape is more realistic even.  The algorithm for determining the coastline (vectorizing a thresholded perlin noise heightmap) is not the same as the internal borders though (voronoi tesselation with lots of postprocessing)."
proceduralgeneration,3dyfmt,guyanonymous,1 point,Tue Jul 21 18:17:43 2015 UTC,"Thanks for the reply, love it :)"
proceduralgeneration,3dyfmt,guyanonymous,1 point,Wed Jul 22 07:33:14 2015 UTC,"Yep - that's what I meant re fractal lines (should have called it 'Inkscapes Fractalize' command - http://wiki.inkscape.org/wiki/index.php/Effect_reference#Fractalize) - though I'd love to see that scale properly (e.g., more detailed closer) as you zoom in and out as you repeat etc (i.e., not random function, but still procedural).  Even the output above would be great to export as a planar map - though I always hope for something beyond screen res - e.g., let me output this, all at once, as a huge file.... 30000x15000 being the max in typical windows for bmp and jpg files if memory serves....at least in any programs outside of Photoshop.    But then, I say, go big or go home :D   This is an example of the scale I like to work with... http://img.pixady.com/2015/06/534643_abebelayers.png  (zome 100% crops to the right in this wide image, the main map is vastly scaled down; the basic height maps, terrain shapes were all from FTPro - stitched together as it can't output large files well at all - and could almost be done as an action in photoshop from that point on).  If I could go bigger, too, I would."
proceduralgeneration,3dpkw9,Clayman8000,3,Sat Jul 18 05:27:52 2015 UTC,Is this a technique or a random generator program?
proceduralgeneration,3dpkw9,HWBunton,2,Sat Jul 18 05:58:21 2015 UTC,"Ummm both, I think. I'm a little unsure of your question. The entire thing was written up in processing. But you can compile processing code into a .exe so I guess it's also a program."
proceduralgeneration,3dpkw9,CaptainKraft,2,Sat Jul 18 16:42:20 2015 UTC,Is it possible to generate disconnected continents?
proceduralgeneration,3dpkw9,CaptainKraft,2,Sat Jul 18 16:19:39 2015 UTC,"Of course! You would just have to adjust the inputs to your noise function. You could make it one giant blob or thousands of disconnected islands. The screenshots I show here don't show off the variety very well, but with the same parameters I often get nicely shaped, separated continents."
proceduralgeneration,3dpkw9,RivetSpawn,1 point,Sat Jul 18 16:44:23 2015 UTC,Good stuff. I like it
proceduralgeneration,3dpkw9,rev087,1 point,Sun Jul 19 14:13:58 2015 UTC,"Looks good, organic."
proceduralgeneration,3dpkw9,cleroth,1 point,Sat Jul 18 16:40:37 2015 UTC,Very good results! How far are you planning to take this project? Any plans to generate political borders?
proceduralgeneration,3dpkw9,Bergasms,1 point,Sat Jul 18 19:09:17 2015 UTC,No plans. Its definitely something I may visit in the future. The main purpose behind this project was to get some good experience layering noise in different ways. So generating political boundaries falls outside that realm a bit. Although Worley noise could be fun...
proceduralgeneration,3doj46,waka324,3,Fri Jul 17 23:24:49 2015 UTC,"Remember that you can tweak Perlin noise to get different visual effects. Taking the absolute value of Perlin noise creates a 'puffy' look similar to traditional billowing clouds, while inverting that absolute value gives a sort of 'stringy' look. Personally I've had some success by multiplying smaller-scale puffy Perlin noise with larger-scale regular Perlin noise to get clouds kinda like these."
proceduralgeneration,3doj46,green_meklar,1 point,Fri Jul 17 23:57:20 2015 UTC,You can definitely aggregate dense areas of the noise to get clouds
proceduralgeneration,3doj46,Mawu3n4,1 point,Sat Jul 18 12:20:18 2015 UTC,"I don't agree with the recommendation of Perlin noise versus Simplex noise (or my OpenSimplex noise) due to the directional artifacts, but other than that, yes."
proceduralgeneration,3doj46,KdotJPG,2,Sun Jul 19 22:40:00 2015 UTC,"I've been looking into this for awhile, and I've not seen anything I'm happy with.  One idea I have thought about, but not tried, is to use some sort of cellular automata to modulate the noise.  Another thing which I have tried (and am not completely happy with) is modulating opensimplex noise by a somewhat random sampling of actual cloud cover images (converted to grayscale -- where white == full opacity, black == transparency.  Then run that through a fake fluid dynamics thing.  That gets me this far: sample image which is ok, but not great.  a bit more decription here(use arrow keys to navigate) <-- this probably won't work well on mobile."
proceduralgeneration,3doj46,smcameron,1 point,Sun Jul 19 03:55:22 2015 UTC,"for wisps and fronds you want a fluid simulation.  or, depending on your need, a turbulence based distortion on fBm noise.  see more here: http://www.qarl.com/menu/shaders/"
proceduralgeneration,3doj46,qarl,1 point,Sat Jul 18 10:04:16 2015 UTC,Just linking a related post: https://www.reddit.com/r/Minecraft/comments/e7xol/this_is_how_clouds_should_work_gif_simulation
proceduralgeneration,3di3dx,FrederickGeek8,7,Thu Jul 16 13:25:07 2015 UTC,"If you need something to change over time or some other non-physical axis, it can be useful to have 4d noise."
proceduralgeneration,3di3dx,bobbaluba,3,Thu Jul 16 15:48:21 2015 UTC,Yep. Do some measurements over time and make erupting volcanoes instead of just generating the land once.
proceduralgeneration,3di3dx,mrbaggins,6,Fri Jul 17 07:28:57 2015 UTC,"The reason for adding a fourth dimension is to keep values cohesive over time.  Evaluating noise for (x, y, z, t) will be very similar to (x, y, z, t+1), just as (x, y, z) will be similar to (x+1, y, z) would be similar in 3D noise. (for a small enough scale for 1, of course)  Imagine you had 2D noise for terrain generation, where (x, y) -> height.  You could use 3D noise, where (x, y, 0) -> height, and it would be functionally the same. You could change the 0 to any constant and it would be like picking a different zone. Or, if you wanted to simulate 'geologic activity', you could animate it by changing the height to be (x, y, t) over time, and mountains would rise and fall smoothly.    It would extend to 3D, where the density of a point (x,y,z) would change over time. Here's a gif of an old demo I wrote. It samples from 4D noise, (x,y,z,t), which gets a number between [0,1]. Any point with a density greater than say, .75 gets ""filled in"", by using marching cubes. As we animate through, (x,y,z) stay the same, but t increases."
proceduralgeneration,3di3dx,kernalphage,3,Thu Jul 16 17:56:01 2015 UTC,"It's pretty much what its name indicates. There is another dimension in the noise function, meaning you have four parameters to get a noise value instead of three.  You can have noise up to 3 dimensions where you can have each parameter represent a physical axis. Once you step beyond that, you need something else represent the new parameters. Time is commonly used as the 4th dimension for 4D noise generators in the same way time can be used as the 3rd dimension for something in 2D space.  As for the difference in simplex noise when going up a dimension, I don't know exactly. What I do know is that simplex noise is much more suited for noise functions with many dimensions when compared to perlin noise."
proceduralgeneration,3di3dx,JamiesWhiteShirt,2,Thu Jul 16 16:43:53 2015 UTC,"And the reason for simplex noise being more suited for higher dimensions than classic Perlin noise is because it's faster; simplex noise attempts to generate as few corners as possible, resulting in fewer computations. Other than the use cases mentioned, I imagine that there is no real ""difference"" (in terms of core principles of simplex noise) between 3, 4, n dimensions. I could be wrong though, so feel free to correct me ;)"
proceduralgeneration,3di3dx,Pasty_Swag,2,Thu Jul 16 19:00:28 2015 UTC,"I believe when it comes to computation, the amount of dimensions doesn't mean much when comparing perlin and simplex.  Perlin is just extremely memory intensive when you step up the dimensions. Say the dimensional size of the noise map is A, and the amount of dimensions is n, the sizes of the noise maps are the following:   Perlin: An Simplex: An"
proceduralgeneration,3di3dx,JamiesWhiteShirt,2,Thu Jul 16 19:14:21 2015 UTC,"To compute the Perlin noise value at a position in k dimensions you need to compute 2k dot products. To compute the simplex noise value you need to compute k+1 dot products (and do some linear transformations, which have the cost of your matrix multiplication. Something like O(k2.373 ).)"
proceduralgeneration,3di3dx,redxaxder,2,Fri Jul 17 00:45:09 2015 UTC,"so in Perlin's documentation he mentioned that simplex is O(d2 ) rather than perlin's O(2d ) complexity, this really only makes a difference when you're performing the generation on 4th dimension or larger as complexity wise 23 is actually still better than 32. (speed may vary though depending on exact number of ops of course).  Perlin noise, however, has artifacts that will show up which is why it's not generally recommended for use any longer when there are multiple variations of SimplecticNoise floating around the internet.  The major reason against Simplex though, is that it's patented for use in 3D or above for textured image synthesis.  So OpenSimplex is a good option for library usage as it uses a slightly different algorithm entirely. -> https://en.wikipedia.org/wiki/OpenSimplex_noise"
proceduralgeneration,3di3dx,Sleakes,2,Thu Jul 16 19:24:24 2015 UTC,"There are other trade offs involved than speed.   Perlin noise has a bias that becomes very pronounced if you look at its Fourier transform [paper].  Simplex noise has variable range. Some positions have a range of [-1,1] and some have smaller ones, and this problem becomes more pronounced as you go up in dimension because of wacky high dimensional geometry."
proceduralgeneration,3di3dx,redxaxder,2,Fri Jul 17 00:38:41 2015 UTC,"Interesting... I haven't toyed with any real higher dimension noise of any kind (4D Perlin was the highest, and that was a brief educational/experimental project) so I haven't noticed a bias of the raw noise."
proceduralgeneration,3di3dx,Pasty_Swag,2,Fri Jul 17 00:49:48 2015 UTC,"It's hard to see the bias in Perlin noise if you're not looking for it because it's a bias on the derivative. There is a predisposition for some regions to be steeper than others, and the pattern of these regions is very boxy."
proceduralgeneration,3di3dx,redxaxder,2,Fri Jul 17 01:02:32 2015 UTC,"Ohhhh, nice! Thanks for the information. I'll have to look into that further and do some tests firsthand."
proceduralgeneration,3di3dx,Pasty_Swag,2,Fri Jul 17 01:26:51 2015 UTC,The actual reason why simplex noise is that much faster in higher dimensions has to do with the fact that it doesn't need to interpolation (which gets more expensive with the dimension) in the same way that perlin noise does. A good article about simplex noise and why it's faster can be found here: https://code.google.com/p/fractalterraingeneration/wiki/Simplex_Noise
proceduralgeneration,3deqjv,vinnyvicious,11,Wed Jul 15 18:19:03 2015 UTC,"A professor of mine once said that you should only use neural networks if you don't know the statistical distribution of whatever you are describing (unless you're a tech giant and have so much data and processing power that you just don't care). When people run explicit rules to generate procedural content, really what they're doing is describing an a priori distribution of the statistics of whatever they are generating. If the results are sub par, it is because of bias in their statistical model. Neural networks move that bias from the model to the source data set. If you wish to get satisfactory results with an ANN, you need to make sure that you're data is unbiased. Usually this means that you have to collect a lot of data to get a good sampling of you're target distribution. Also, neural networks are very computationally expensive, at least compared to a lot of other manually constructed physical models.  Anyway, tl;dr is that neural networks are nice in that you don't need to actually understand why terrain (for instance) looks the way it does, but to use them you will have to pay the price in the form of gathering a good unbiased corpus of data as well as a hefty computational cost. Also, like the other commenter said, don't use genetic algorithms. Use SGD or something similar for ANNs. In fact, don't use genetic algorithms for much of anything because they are almost always inferior to other methods."
proceduralgeneration,3deqjv,dandrino,2,Wed Jul 15 21:51:17 2015 UTC,"In fact, don't use genetic algorithms for much of anything because they are almost always inferior to other methods.   I'll (slightly) disagree with this - there are always more optimal methods for optimisation than genetic algorithms, but genetic algorithms are very easily understood and tweaked by a designer, which can make them very useful in some circumstances. Scoring results and picking the best N is simpler than trying to understand the derivative of the cost function (which may not even be well-defined if such a function is not continuous), and the mutation and crossover steps, if implemented properly, help avoid falling into local minima."
proceduralgeneration,3deqjv,kylotan,2,Thu Jul 16 13:07:46 2015 UTC,"I've found that for approximating solutions to NP-hard or other combinatorial problems genetic algorithms underperform other approaches like simulating annealing. Genetic algorithms shoehorn ideas like mutation of a bit string representing the state along with crossover which often times makes no mathematical sense with respect to what it conceptually is trying to accomplish (I.e. Producing a new ""in between"") state, and also add an unnecessary layer of complexity to the solution. Really what crossover tends to do is send the search path off to some crazy new corner of the search space which will help keep it from getting stuck in some local minimum but pays the price by making the overall search take ages to converge to even a decent solution. Simulating annealing converges faster and you can mitigate the issue of getting stuck in a local minimum by running several parallel search paths which are initially evenly distributed across your search space, or every so often give a random ""jolt"" to your search state when you think you've gotten stuck."
proceduralgeneration,3deqjv,dandrino,2,Thu Jul 16 18:31:57 2015 UTC,"Genetic algorithms shoehorn ideas like mutation of a bit string representing the state along with crossover which often times makes no mathematical sense with respect to what it conceptually is trying to accomplish   In my studies on this I basically ignored the idea of using a bit string and simply used the parameters as-is. It means you need to be a bit more thoughtful in how you approach crossover and mutation but it means the search is more effective. In particular, if crossover is treated more as a way of mixing and matching parameter sets, it can work well - far better than the traditional ""genetic code"" approaches that cut a value down the middle or whatever. Just like with neural networks, getting too fixated on the biological metaphor often makes for a less efficient algorithm.   you can mitigate the issue of getting stuck in a local minimum by running several parallel search paths   Sure... but you can see how this is basically the same principle as genetic algorithms maintaining a population of candidate solutions, right? And whereas the parallel simulated annealing searches don't share information in any way, the population in a GA does share information that can potentially lead to faster convergence. This totally depends on having a useful crossover operator that is able to recombine discrete features from 2 candidate solutions, of course."
proceduralgeneration,3deqjv,kylotan,3,Fri Jul 17 08:08:07 2015 UTC,"Instead of your evolution algorithm, why not just use gradient descent?"
proceduralgeneration,3deqjv,tailcalled,2,Wed Jul 15 20:38:57 2015 UTC,What is that? Pardon my ignorance.
proceduralgeneration,3deqjv,tailcalled,2,Wed Jul 15 21:43:00 2015 UTC,The NN essentially computes the terrainness of an image. Gradient descent is essentially taking the derivative of the terrainness with respect to each piece of data in the image and using this information to slightly improve the image until maximum terrainness has been reached.
proceduralgeneration,3deqjv,drake7707,1 point,Wed Jul 15 21:57:21 2015 UTC,"To elaborate a bit more, each input neuron is a dimension (assuming each neuron values are linearly independent of each other), you can see your list of input neurons as a n dimensional vector. Using backpropagation is essentially calculating a n-dimensional error surface (so you know the error in each point of the n-dimensional space) and then nudging the input vector to minimize the error at each point.  A gradient of a surface is the derivative of the function resulting in a vector which points to the direction where the biggest change is, like standing on a hill and you have a vector that nudges you to the steepest slope (in 3D).  You want to minimize the error so in order to reduce the error to as close as zero as possible you follow the steepest slope until you hit the bottom. This is essentially what gradient descend is."
proceduralgeneration,3deqjv,a1studmuffin,4,Thu Jul 16 07:11:02 2015 UTC,"As an onlooker to this discussion I have to chuckle at the unfortunate example of terrain generation for discussing the gradient decent algorithm. Hill climbing, surfaces, gradients etc. Probably the most confusing example I can think of, haha."
proceduralgeneration,3deqjv,cleroth,1 point,Thu Jul 16 10:06:08 2015 UTC,"PCG? I've never heard that before. That just makes me think of the RNG PCG, which is... pretty related to procedural generation."
proceduralgeneration,3ddqpj,igniuss,2,Wed Jul 15 13:55:19 2015 UTC,"Look into some Blender extensions. If you're generating models and brief environments to be used later (like a prefab), I'm sure you could find an open-source extension to help.  Look into the Space Colonization Algorithm as well. It seems like its uses are limited (I just started reading about it last night, so I could be mistaken), but you prolly could take some ideas from it at the least."
proceduralgeneration,3ddqpj,Pasty_Swag,1 point,Wed Jul 15 17:20:22 2015 UTC,"Thanks for the SCA thing, reading up on it now! And I'm more looking into real-time solutions (which is why libnoise might be the wrong deal, I can run it realtime, but not as detailed as I'd like)"
proceduralgeneration,3ddqpj,Pasty_Swag,1 point,Wed Jul 15 18:10:26 2015 UTC,"No problem! Fair enough though. Discard what I said about Blender then. Good luck, and keep us updated on what you make ;)"
proceduralgeneration,3ddqpj,AntonKudin,2,Wed Jul 15 21:01:02 2015 UTC,"I needed something to generate semi-random value based on seed and (2d)position, so here's my script:  http://pastebin.com/SQkySPXu"
proceduralgeneration,3ddqpj,roveboat,1 point,Wed Jul 15 18:39:59 2015 UTC,That's actually pretty handy! Thanks man :D
proceduralgeneration,3ddqpj,roveboat,1 point,Wed Jul 15 22:33:57 2015 UTC,"Mathf.PerlinNoise isn't enough? Since you're looking for realtime solutions, if you need something more complex than good old Perlin then it might be the time to figure out how you could cut down on the number of noise calls you're making."
proceduralgeneration,3ddqpj,kmjn,1 point,Wed Jul 15 18:36:32 2015 UTC,"I tried switching to Mathf.PerlinNoise, but it seemed slower then libnoise (I was probably doing it completely wrong!)"
proceduralgeneration,3dd1pv,evglabs,2,Wed Jul 15 09:00:03 2015 UTC,I don't know of one but looks like an awesome weekend project to me. I remember seeing the original planet accretion code a long time ago and could never remember where it was from.
proceduralgeneration,3dd1pv,IrishWilly,1 point,Wed Jul 15 14:39:12 2015 UTC,"Yeah, but for me it'll probably be more like month-long project. I'm just starting to learn JavaScript and have no familiarity with Java :("
proceduralgeneration,3dd1pv,YouShouldUseProlog,1 point,Wed Jul 15 14:44:20 2015 UTC,"original planet accretion code   I have most of that staked out and commented, along with all the old versions"
proceduralgeneration,3dccc9,vinnyvicious,4,Wed Jul 15 04:02:59 2015 UTC,"Looking at space colonization would be a start  paper reddit post  Then you will need to create meshes, map textures and create leaf quads. Multiple level of details for use in realtime software.  Not really a trivial task."
proceduralgeneration,3dccc9,obidobi,2,Wed Jul 15 04:30:43 2015 UTC,"Space Colonization is a really cool algorithm, but has its limitations.    My guess is that Treemagik and Forester use a specialized L-System.  Definitely a ton of work to create convincing procedural generations of various trees.   You should also check out SpeedTree."
proceduralgeneration,3dccc9,jongallant,4,Wed Jul 15 10:53:47 2015 UTC,"Have you considered L-systems? If you google that term, you'll find plenty of implementations of tree generators using it."
proceduralgeneration,3dccc9,rev087,1 point,Wed Jul 15 05:35:00 2015 UTC,Never heard of it. Thanks for the info!
proceduralgeneration,3d98b6,Geaxle,4,Tue Jul 14 14:19:00 2015 UTC,"Many programming languages let you use seeded random number generation - that is, a generator you initialize with a seed (number, string of text...) which will then always output the same sequence of values.  It usually works like so (approximately) :  seed=""whateverYouWant""; mySeededRandom=new Random(seed); value1=mySeededRandom(0,10); //will always be 3 value2=mySeededRandom(0,10); //will always be 1 value3=mySeededRandom(0,10); //will always be 8   You can reset the sequence by redeclaring the seeded random with the same seed.  Depending on your language, you might have to add the seeded random function yourself (here's one I found for javascript, along with some more information)."
proceduralgeneration,3d98b6,Orteil,1 point,Tue Jul 14 15:05:15 2015 UTC,Ah thanks for the infos. I was actually missing the concept that the seed itself was used to generate random numbers. Much more clear now.
proceduralgeneration,3d98b6,thomar,1 point,Tue Jul 14 16:00:49 2015 UTC,"Yeah, this is how you can keep certain features consistent despite how many times random gets called or changes to the order of content generation. You probably don't want some changes to placement of treasure chests to completely change your terrain heightmaps in your seeds."
proceduralgeneration,3d98b6,zarawesome,2,Tue Jul 14 16:45:23 2015 UTC,"Every major language's random number generator is best called a pseudorandom number generator, since the numbers produced don't fit every requirement expected of random numbers - for example, they're dependent on the initial input, or 'seed', you give to the algorithm. Here is a tutorial for C++:  http://www.learncpp.com/cpp-tutorial/59-random-number-generation/"
proceduralgeneration,3d98b6,Dascandy,2,Tue Jul 14 15:54:02 2015 UTC,"One major trick you can do is to use a hierarchy of randomness. You use the seed to initialize a single Random() object (C# style for reference), and then you use the random numbers from that to decide your top-level generation. Each thing you generate gets a fixed number of random numbers - usually one - and has to generate everything it does from that.   Now the trick is, at that point initialize a new random number generator with that as its seed, and generate the next level below that. So if you start generation with seed 2813795, the first number becoming 1239078, you create a galaxy called ""1239078"" and seed a new generator with that for the suns in that galaxy. First sun is called 42 (... chance) and you generate with 42 as seed the planets around that sun.  Things to keep in mind: - Use the biggest random numbers you can reasonably use. The smaller they are the more likely you get a collision - and a collision in this case would be two completely identical planets, or two completely identical solar systems or such. Because of birthday paradox, using rand() (which on Windows has only 15 bits of randomness) would get you 50% chance of two identical planets or solar systems when you generate your 213th planet. And if you're unlucky that planet will be right next to the other, making it painfully obvious. - Don't store any generated content. As tempting as it can be for awesome looks, you can always regenerate it instantly. Store deltas if you must store something - just store what people change, not what's there by generation. - Store your initial seed somewhere. You need it to regenerate parts of the hierarchy that you don't store. - Use functions that map a uniform random number in range 0-X to a usable number, such as a Poisson distribution or something similar. Use these functions everywhere to generate stuff. Apply randomness liberally, but deterministically. Heck, look around you - everybody you meet has a height and a weight, both of which are quite nice Poisson distributions - you can generate non-identical people easily just by doing those."
proceduralgeneration,3d98b6,green_meklar,1 point,Wed Jul 15 07:19:26 2015 UTC,"Very interesting, thanks a lot for all these info. (I guess 42 is the answer to all my question ;) )  I was thinking on using the coordinate of a star as a seed to generate it's solar system but I didn't think of the layered generator idea. I will definitely tried that.  I have many more question but I guess I should start programming it. Most of my knowledge is with python (though I know some C as well)."
proceduralgeneration,3d5zlp,cycophuk,1 point,Mon Jul 13 20:07:21 2015 UTC,Great of you to share this. I especially like the trees as in http://imgur.com/ZQ1p2UH . I will definitely look through the code on GitHub to get some inspiration.
proceduralgeneration,3d5zlp,droidballoon,1 point,Tue Jul 14 22:07:29 2015 UTC,GDC: Value of Procedural Art
proceduralgeneration,3d5zlp,Lycanther-AI,-6,Wed Jul 15 23:13:31 2015 UTC,"This is quite interesting, but like most procedural generation it is interesting yet meaningless.  For something to be meaningful, we must be able to relate it to our experience. That's the hard part that No Man's Sky has to solve in order to be a game (a pleasurable experience)."
proceduralgeneration,3d5zlp,Creativator,8,Mon Jul 13 23:12:23 2015 UTC,"If it's aesthetically pleasing, isn't that good enough?"
proceduralgeneration,3d5zlp,green_meklar,-3,Tue Jul 14 00:40:26 2015 UTC,"Depends on what purpose it's trying to fulfill by being aesthetically pleasing. I mean, as great as this looks, it doesn't break things down into layers or tile horizontally, leading to being a parallax background or in-game painting at best as far as the things I can immediately think of to do with it.  But perhaps I'm just a weirdo who needs to be able to integrate and do stuff with art in order to appreciate it."
proceduralgeneration,3d5zlp,Muhznit,-4,Tue Jul 14 03:53:53 2015 UTC,Does being aesthetically pleasing make a thing art? Or does it need to have something to say as well?  I don't claim to have an answer to that question.
proceduralgeneration,3d5zlp,Creativator,5,Tue Jul 14 01:07:46 2015 UTC,How can something not say anything?
proceduralgeneration,3d5zlp,moron4hire,0,Tue Jul 14 01:26:06 2015 UTC,"""anything"" even I have said it. It must have been bad i18n||L10n||g11n||L12y."
proceduralgeneration,3d5zlp,Ciphertext008,2,Tue Jul 14 02:40:15 2015 UTC,"While the reference to No Man's Sky may make you consider this generator in an game only context, procedural generation is also used a lot outside the game development field."
proceduralgeneration,3d4us5,vinnyvicious,3,Mon Jul 13 15:17:59 2015 UTC,"Accidental noise library is basically libnoise, but better, more features and dimensions, lua scripting.  I would also like to promote my own tool and library, Noise Modeler, though its primary use case is gpu-based terrain generation."
proceduralgeneration,3d4us5,bobbaluba,2,Mon Jul 13 15:24:43 2015 UTC,That's interesting. What have you used for the nodes/links? Custom-built widget?
proceduralgeneration,3d4us5,bobbaluba,1 point,Mon Jul 13 15:39:17 2015 UTC,"I'm using vanilla qtquick without qtquick controls, but yeah, it's mostly custom-built. Source is available on github, and the license is very permissive (zlib where possible, though other parts are under some gpl) if you're interested.  My tool can easily be modded to be a texture designer btw (in a way it already does this, but black and white only).  edit: I also saw another texture tool with a graph editor recently, that built on top of libnoise. Don't remember the name, though."
proceduralgeneration,3d4us5,whatgeorgemade,2,Mon Jul 13 21:40:06 2015 UTC,"It may not be exactly what you're after but if you are generating any geometry, CGAL may be helpful. I've not used it myself but it's referenced in the computational geometry book I'm reading.   http://www.cgal.org/index.html"
proceduralgeneration,3d4us5,gamepopper,2,Mon Jul 13 19:04:28 2015 UTC,"Seems like a very very useful library, thanks."
proceduralgeneration,3d4us5,gamepopper,2,Mon Jul 13 19:11:47 2015 UTC,Some other libraries i found:   Noise++ SimplexNoise
proceduralgeneration,3d6bok,vinnyvicious,1 point,Mon Jul 13 21:32:30 2015 UTC,Would you mind linking any pieces that helped you in proc gunning nature textures?
proceduralgeneration,3d6bok,Jazzer008,1 point,Mon Jul 13 22:15:13 2015 UTC,Watching artists doing it in Substance Designer and reproducing that in my code. :D
proceduralgeneration,3d6bok,Jazzer008,1 point,Mon Jul 13 22:33:05 2015 UTC,"Oooh, didn't even know about that application. Great, thanks! :)"
proceduralgeneration,3d55ht,vinnyvicious,3,Mon Jul 13 16:36:40 2015 UTC,I had a bunch of bookmarks (long I ago I worked on a strategy game where you could alter water flow to affect the economy and battles) but half of the links are broken. Here's what still works:   http://www.ventrella.com/Ideas/Fluid/fluid.html http://codeflow.org/entries/2011/nov/10/webgl-gpu-landscaping-and-erosion/ http://www.cs.unc.edu/~blloyd/comp259/project/ http://ranmantaru.com/blog/2011/10/08/water-erosion-on-heightmap-terrain/ https://www.reddit.com/r/gamedev/comments/v69nx/ive_been_playing_with_water_erosion/ https://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-1/
proceduralgeneration,3d55ht,redblobgames,1 point,Tue Jul 14 16:34:45 2015 UTC,"Pure gold, dude. Thanks a lot."
proceduralgeneration,3d55ht,need12648430,1 point,Wed Jul 15 04:08:55 2015 UTC,"It's essentially a low-pass filter (see: box blur) using the slopes (Δy/Δx) to seed the weights. There are other variables you can play with, but that's all you need for a simple simulation.  Protip: Condense the problem into 1D first, it'll be a lot clearer what's going on. Generate some basic white noise and simulate erosion on it."
proceduralgeneration,3d4xdt,vinnyvicious,1 point,Mon Jul 13 15:37:40 2015 UTC,Have you looked into marching cubes? That can generate a mesh from a 3d array created by a 3d noise function.
proceduralgeneration,3d4xdt,TheMastahC,1 point,Mon Jul 13 17:38:40 2015 UTC,"Would you use something like Polyvox then, to create rocks?"
proceduralgeneration,3d4xdt,Jazzer008,1 point,Mon Jul 13 19:06:42 2015 UTC,"Marching cubes, specifically, see the density function section.  Edit: Personally however, if this is just for decorative rocks, then it's overkill in my opinion. If it's for large scale terrain boulders or large asteroids, then it's probably worthwhile."
proceduralgeneration,3d4xdt,Jazzer008,1 point,Mon Jul 13 20:29:30 2015 UTC,"Well, i'm planning to generate rocks like these:  http://i.imgur.com/Zd3Xawy.png  http://i59.tinypic.com/n4jyb4.png  http://www11.pic-upload.de/03.05.15/srax4abnunc.png  https://adelphiagaming.files.wordpress.com/2015/04/rocks.png  http://i.imgur.com/DACggqx.jpg  Basically, i'm planning to procedurally generate the geometry, UV'it (i have no idea how), apply a procedural texture (with my procedural texturing lib) and apply a few other maps to the UV'ed mesh, like generate an AO to it and so on.   I'm planning to achieve something basic, first, like just the geometry: http://tools.iamgregamato.com/images/GT_RockGen.gif"
proceduralgeneration,3d4xdt,Jazzer008,1 point,Mon Jul 13 21:18:53 2015 UTC,Wonderful. I saved your thread when I first saw it in hopes that you would come up with an end product similar to your examples.  I was specifically interested in your texture/normal/ao production.
proceduralgeneration,3d4xdt,Jazzer008,1 point,Mon Jul 13 22:00:20 2015 UTC,"I've seen some people use Delaunay meshes and Voronoi diagrams to improve the basic rock geometry, but shouldn't it start with a base mesh? Should this base mesh be a primitive or a procedurally generated one?"
proceduralgeneration,3d1o34,pdunstan,1 point,Sun Jul 12 20:10:39 2015 UTC,"I hated Galaxies.  I've seen better terrain in PoC posts on this subreddit.  ...and the terrain was, honestly, the most impressive example of PCG content in galaxies. The way they did their monster-generators was just pathetic and had almost zero though behind it.  Mobs would just stand there and wait to be killed.  I've seen way more thought towards AI in 7drls than I saw in all of Galaxies over the two years I played it.  I, honestly, have very few good things to say about Galaxies.  I think the one good thing they did was the minerals and crafting."
proceduralgeneration,3cu4vp,drake7707,5,Fri Jul 10 20:11:59 2015 UTC,A fully commented javascript example of creating infinite terrain by stitching chunks together. There are a lot of examples to do diamond square but not a lot to stitch chunks of diamond square generated terrain together (afaik) so I worked on my own implementation.  If you toggle the height map you'll see more easily what's being generated by the DS algorithm.
proceduralgeneration,3cu4vp,semperunum,2,Fri Jul 10 20:18:42 2015 UTC,"Currently, rendering is really slow both incrementally and by drawFull. I would suggest trying to use canvas 2d context methods. You would likely see x3 frame rate improvements."
proceduralgeneration,3cu4vp,semperunum,1 point,Fri Jul 10 21:42:25 2015 UTC,"I'm using context.drawImage and context.clearRect now, can you elaborate what I should use?"
proceduralgeneration,3cu4vp,DontThrowMeYaWeh,1 point,Sat Jul 11 06:18:55 2015 UTC,"My mistake, for some reason I thought you were using image buffers."
proceduralgeneration,3cu4vp,semperunum,1 point,Sat Jul 11 22:35:04 2015 UTC,"Holding down ""R"" on the demo app really slows it down, lol."
proceduralgeneration,3cu4vp,semperunum,2,Fri Jul 10 20:51:21 2015 UTC,"That is because it is redrawing about 30 times/per second which the rendering can't keep up with. OP, you should make it so it will only fully redraw once per keypress. I can submit a pull request if you want."
proceduralgeneration,3cu4vp,green_meklar,1 point,Fri Jul 10 21:29:53 2015 UTC,"You could, not sure if there is any need to do full redrawing if the drawIncrementally results in the same image."
proceduralgeneration,3cu4vp,cleroth,1 point,Sat Jul 11 06:25:42 2015 UTC,"When zooming out, it messes up a lot. Redrawing fully once would then fix it so drawIncremental could work again."
proceduralgeneration,3cnwfx,Peter3571,4,Thu Jul 9 10:59:42 2015 UTC,Very nice! It reminds me of this.
proceduralgeneration,3cnwfx,raizor,2,Thu Jul 9 12:45:07 2015 UTC,"Oh nice, that looks epic, I might try rewrite this and merge it with a few of those ideas :D"
proceduralgeneration,3cnwfx,sparr,3,Thu Jul 9 13:21:57 2015 UTC,You've developed a procedural anthill generator...
proceduralgeneration,3cbu2n,mangolo222,2,Mon Jul 6 18:19:18 2015 UTC,"You need a game object at each of those vertices (or faces, which will be easier in the long run if you switch to hexes and pentagons) with a script on it that handles generating the finer LOD meshes dynamically. A manager object would also be useful."
proceduralgeneration,3cbu2n,thomar,2,Mon Jul 6 20:17:09 2015 UTC,Thank you for your reply. My code for generating the the sphere from the cube is like this:    for (var i=0; i<vertices.Length; i++) {       vertices[i] = vertices[i].normalized*radius;   }     So i have to create a GameObject for each of those vertices? And how do i generate the finer LOD meshes dynamically? Could you provide some examples?
proceduralgeneration,3cbu2n,thomar,3,Mon Jul 6 21:55:39 2015 UTC,"Well, I hate to plug myself, but look at this: http://kobolds-keep.net/?p=33"
proceduralgeneration,3cbu2n,airmanf,1 point,Mon Jul 6 21:56:09 2015 UTC,"Thank you very much. I think the error was using a ""whole"" cube from blender, instead of generating each side of the cube in Unity (with mesh-generation). I will start there :)"
proceduralgeneration,3c7eun,pranavrc,2,Sun Jul 5 16:14:16 2015 UTC,"I like the concept, and the samples were really cool, but something about it sounds just a bit off? Like in an unsettling kind of way. Perhaps less to do with the generator and more with the design of the algorithm that plays the notes?"
proceduralgeneration,3c7eun,airmanf,1 point,Mon Jul 6 06:51:58 2015 UTC,"Thanks, /u/airmanf :)  I'm not really sure; does it have something to do with a specific sample, or every sample? As I mention at the end of the document, the generator can sometimes generate dissonant intervals that sound 'off' like you said, so maybe that's the problem. If you can give me a little more information, I'll try and zero in on the problem. Thanks again!"
proceduralgeneration,3c7eun,the_tubes,2,Mon Jul 6 17:13:15 2015 UTC,Super very awesome cool!  Just skimmed it a bit and listened to the samples but I'll look forward to reading this later tonight at work!
proceduralgeneration,3c0cdz,samsuhh,3,Fri Jul 3 16:46:52 2015 UTC,"Dunno why you had 0 points, but, thank you for this.  A project I've started recently has required dynamic images and I would rather let the server handle the code instead of dumping all the information on constructing the image, to the user.  Webm and .gif support are beyond the scope of my project, but, it's great to see how you've made use of it for your game.  Thanks!"
proceduralgeneration,3c0cdz,DivisionSol,1 point,Sat Jul 4 03:14:28 2015 UTC,Probably because its not procedural generation at all.
proceduralgeneration,3c0cdz,loktar00,1 point,Sat Jul 4 03:45:19 2015 UTC,"I find the implementation neat, and, find the applications of obfuscating rendering code behind a server to be quite useful for many situations.  The serverside rendering of webms is quite a powerful tool. Sure, the blog author isn't the first one to invent it, but, I can image lots of neat toys to make with it."
proceduralgeneration,3c0cdz,DivisionSol,1 point,Sat Jul 4 03:54:54 2015 UTC,"Thanks for your feedback.  Here, the obfuscating was not the problem. The entire code will be on GitHub soon. The server side generation was only a required feature, but i agree with you, it can be quite useful for many situations!  We build this game around the open data idea, with multiple web services working between them. One web service to render images, one web service to handle data.  The project behind this game is to create an educational board game to learn programming and hacking things. Here, this is an online simpler version, but the idea remains the same. This is why opening things is important for us :)."
proceduralgeneration,3buwfj,eis_kalt,8,Thu Jul 2 10:15:19 2015 UTC,I don't quite see what's procedural here.
proceduralgeneration,3buwfj,cleroth,2,Thu Jul 2 10:50:32 2015 UTC,"Actually, everything except worker man (and simple GUI) is procedural generated from OpenStreetMap data. Editor feature allows you to put new objects (buildings, trees, barriers) into scene and modify existing environment (adjust height of terrain, modify building facade) by mouse clicking."
proceduralgeneration,3buwfj,cleroth,7,Thu Jul 2 11:06:48 2015 UTC,"Yea but I mean you're showcasing the editor, which in itself doesn't have anything procedural, it seems."
proceduralgeneration,3bpygu,Zivodor,6,Wed Jul 1 05:18:14 2015 UTC,"The easiest fix is to write your map generator such that there's only ocean on the date line (i.e. the left/right edge) :-)  Unless your oceans also follow regions. Then you're facing another alternative: voronoi tesselation on a sphere, instead of on 2D geometry."
proceduralgeneration,3bpygu,wlievens,3,Wed Jul 1 07:55:32 2015 UTC,"Voronoi is fine, you just have to have the regions on each side sample the points from the other side."
proceduralgeneration,3bpygu,green_meklar,3,Wed Jul 1 07:00:58 2015 UTC,See the problem I have is I am not using my own code for the Voronoi diagram I am using a open source C# implementation I found. Is there a resource that I can use to learn how Fortunes Algorithm works?
proceduralgeneration,3bpygu,green_meklar,3,Wed Jul 1 07:08:38 2015 UTC,"I've never used Fortune's algorithm- indeed, I hadn't heard of it until just now. Wikipedia seems to give a fairly complete description of it, and although I don't know why it's correct, it doesn't look terribly complicated.  That said, I'm not sure if adapting it to a wrapping space (while preserving correctness) is a trivial matter. I'm also not sure if you actually need it. Depending on the format and size of your map, it's probably overkill for what you're trying to do."
proceduralgeneration,3bpygu,autowikibot,3,Wed Jul 1 07:17:37 2015 UTC,"Fortune's algorithm:       Fortune's algorithm is a sweep line algorithm for generating a Voronoi diagram from a set of points in a plane using O(n log n) time and O(n) space.   It was originally published by Steven Fortune in 1986 in his paper ""A sweepline algorithm for Voronoi diagrams.""     Image from article i     Relevant: Sweep line algorithm | Voronoi diagram | Mesh generation | Bowyer–Watson algorithm   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
proceduralgeneration,3bpygu,wlievens,2,Wed Jul 1 07:18:50 2015 UTC,So is there a simpler algorithm for creating a voronoi diagram?
proceduralgeneration,3bpygu,green_meklar,3,Wed Jul 1 07:45:19 2015 UTC,"It depends on whether you use a vector or raster spatial representation. On rasters, you sample each point (pixel) and assign it to the nearest cell.  The upside with the raster representation is that you can do funky things like use alternative distance functions, to warp the shape of the voronoi cells. The downside is that it's hard to manipulate the edge geometry of the cells."
proceduralgeneration,3bpygu,wlievens,3,Wed Jul 1 07:57:52 2015 UTC,"The downside is that it's hard to manipulate the edge geometry of the cells.   Well, you can use a jitter function. However, if you need the cells to remain contiguous, that does make things harder."
proceduralgeneration,3bpygu,maxcreeger,2,Wed Jul 1 16:52:07 2015 UTC,"Adding jitter to a line (i.e. breaking it up and adding some noise to coordinates) is much easier when you have its coordinates, compared to when you have just the pixels that make up either side of the border."
proceduralgeneration,3bpygu,cleroth,1 point,Thu Jul 2 07:41:43 2015 UTC,"Yes there are a few. I implemented a divide and conquer method which worked fine by adding points one at a time to an existing Delaunay graph. Was pretty fun too.  But i was thinking that you don't necessarily need to give up on your implementation of Fortune's. Juste because you think it swipes left to right doesn't make it so. Why don't you turn the problem 90deg and make it swipe north-south? Make your cylindrical map repeat 3 times your tile, side by side left to right. Turn it all 90deg, apply Fortune's and turn it back. The center tile is a perfect repeating Delaunay triangulation, the other two are close approximations because of side (border?) effects. Just drop'em. Job done.  Addmitedly job overdone, because you Delaunay'ed an area 3 times bigger than necessary, but you didn't have to re-write the Delaunay code which can be messy...  Otherwise if I were to recode Fortune's for cylindrical map i would definitely swipe orthogonally to the wraparound direction."
proceduralgeneration,3bpygu,thfuran,1 point,Thu Jul 9 15:47:23 2015 UTC,So would your Delaunay method be faster? ie. not having to sample 3x the amount of points. I'd imagine with some sort of process it should be possible to rule out the majority of duplicated points.
proceduralgeneration,3bpygu,cleroth,1 point,Thu Jul 9 16:25:09 2015 UTC,I ended up cheating a bit and while it's not the quickest it only takes a few seconds anyway. What I ended up doing was creating the Voronoi diagram from my list of points using the open source voronoi algorithm I found. I then used a line draw method to turn the edge into 2d points in an array. Then I shifted every point I made over by 1/2 the map size and redid the voronoi diagram. I did the same line draw thing on a different array then shifted all the points back by 1/2 the map size.Finally I sampled between 0 to 10% of the map width and replaced the values in the first array with  with the values from the second array and did the same from the other side going from map width - 10% of the map width to map width. What it does is make the edges wrap really well without any tearing or visual artifacts.
proceduralgeneration,3bpygu,maxcreeger,2,Thu Jul 9 18:37:34 2015 UTC,I sure don't see any trivial way of adapting an algorithm based on sweeping a line from one side of all the points to the other to a space where no such line can exist.
proceduralgeneration,3bpygu,cleroth,2,Wed Jul 1 13:18:09 2015 UTC,"Why not just sample the square 9 times? You sweep over it, the center square will then be tileable."
proceduralgeneration,3bpygu,maxcreeger,1 point,Wed Jul 1 15:25:03 2015 UTC,"Repeating 9 times is for donught-style geometry. OP has à cylindrical geometry. But you gave me an idea there, see my answer somewhere else in this thread.   Unrelated: How do i point to another answer in the same thread anyway?"
proceduralgeneration,3bpygu,thfuran,1 point,Thu Jul 9 15:52:33 2015 UTC,"By ""give you an idea"" you mean you just dumbed down my method of  tiling both ways to only one way. Of course if you only need to tile horizontally you only need 3 sampled squares.     Unrelated: How do i point to another answer in the same thread anyway?   Right click ""permalink"" and ""Copy link address""."
proceduralgeneration,3bpygu,cleroth,1 point,Thu Jul 9 16:25:07 2015 UTC,"Ah sorry if I gave the wrong impression. Your idea of repeating the pattern several times then applying the algorithm and finally extracting the center section is really good in that it allows to use the algorithm untouched. It however triples the work that has to be done.  My idea was to sweep othogonally to the tiling direction so as to have a well-defined start and end point. If I understood well it is required that the sweep begins outside the cloud point... This would be the benefit. Of course one would still either need to tile three times as you proposed, or to re-develop the sweep line to cope with repeating pattern, which I think would provide performance benefit. But that would be quite some work .  Again sorry I should have given you credit  Also thanks for the tip! I'm new to writing on reddit :-)"
proceduralgeneration,3bpygu,maxcreeger,1 point,Fri Jul 10 14:36:23 2015 UTC,I'm not sure what square you mean.
proceduralgeneration,3bpygu,thfuran,2,Wed Jul 1 16:48:07 2015 UTC,The area you're generating the voronoi tesselation. Duplicate the points in every direction.
proceduralgeneration,3bpygu,SanseminX,1 point,Wed Jul 1 16:59:26 2015 UTC,Yes there is I believe. Wipe north to south. See my other answer somewhere in this thread.
proceduralgeneration,3bpygu,SanseminX,1 point,Thu Jul 9 15:49:02 2015 UTC,"Yeah I was thinking of spheres, not cylinders. But in whichever case, I'm not sure that it wouldn't work to sweep a plane through the volume as long as you make sure to use a geodesic distance rather than Euclidian."
proceduralgeneration,3bpygu,SanseminX,3,Thu Jul 9 21:37:08 2015 UTC,"I didn't quite get how you run the Voronoi. Do you sample to a texture first and do you create a plane of vertices from that or possibly cylinder or what?   Other than rewriting the Voronoi implementation, which is not that bad of a task in ityself if you don't need Fortunes due to speed constraints, the simplest thing I can think is to sample the cylinder noise more than 360 to the direction of the Fortune sweep until the cells settle and patch the stuff after the ""end"" over the stuff in the ""beginning"".   Not sure if I explained that too well..."
proceduralgeneration,3bpygu,SanseminX,2,Wed Jul 1 08:02:58 2015 UTC,Nono its not used to actually generate the map I am using it to divide an already premade map into polygonal regions for countries and such. I just give it a list of random points and create the voronoi regions from those points.
proceduralgeneration,3bpygu,Apathy_Dude,2,Wed Jul 1 17:16:58 2015 UTC,Is the map a texture or some other 2D bitmap or is it a plane of vertices?
proceduralgeneration,3bpygu,Zeustiak,2,Wed Jul 1 17:32:14 2015 UTC,2D bit map.
proceduralgeneration,3bh5v0,Bergasms,12,Mon Jun 29 04:36:02 2015 UTC,"Looks like something weird is happening to form rivers biased to vertical and diagonal directions, but not horizontal, strangely.  Maybe the neighbor selection?  Maybe you need to find the gradient, then proportionally divide the water among neighbors according to the direction of the gradient (ie. water flow is not limited to just 8 directions?, or maybe flow water to all lower neighbors, not just the lowest lower neighbor, but proportionally so as to level the water as it flows? Just a guess, I might be wrong.  Looks cool though, and it looks to be on the right track."
proceduralgeneration,3bh5v0,smcameron,2,Mon Jun 29 06:44:13 2015 UTC,That's midpoint-displacement's artifacts there for you. Diamond-square would do the same.
proceduralgeneration,3bh5v0,Dascandy,5,Mon Jun 29 11:24:58 2015 UTC,"There are definitely still biases from the scan order (vertical is the inner loop I believe?).  A good trick to avoid this is randomization beyond what you are currently doing.  In particular, you can pick a random location on the grid and run your update step on just that one site.  Doing n2 many such random updates is then approximately equivalent to a single ordered scan, but without the artifacts.    Looking great all the same!"
proceduralgeneration,3bh5v0,R4_Unit,3,Mon Jun 29 07:10:31 2015 UTC,Spot on with the loop bias. I'm trying to make it easily transferable to shaders and I believe they tend to work with definite directional bias
proceduralgeneration,3bh5v0,R4_Unit,1 point,Mon Jun 29 07:30:36 2015 UTC,"In that case, there are some other tricks to try, namely only using a sublattice at each step.  In this case if you update only shifts of multiples of three ( so a sub grid like (1,2) , (4,2),...,(1,5),(4,5),...), you will be in good condition since every point on the grid is adjacent to at most one such site.  Thus if you run your update one such a sub grid, you can't get the cascades of dependent updates that lead to the bias.  Additionally, from my (admittedly few) times coding in CUDA, this technique should port to the GPU with little difficulty."
proceduralgeneration,3bh5v0,cleroth,0,Mon Jun 29 07:47:00 2015 UTC,"Doing n2 many such random updates is then approximately equivalent to a single ordered scan, but without the artifacts.   And O(n2) instead of O(n). Sounds painfully long for thousands of iterations."
proceduralgeneration,3bh5v0,R4_Unit,3,Mon Jun 29 07:40:46 2015 UTC,"Sorry, I was unclear.  I was counting as an n by n grid.  The n2 many random updates is the same as the n2 updates for a single ordered scan."
proceduralgeneration,3bh5v0,cleroth,0,Mon Jun 29 07:49:31 2015 UTC,"Yea, probably the best way to do it would be to shuffle a n2 array of positions, then iterate over them. This is still really bad for cache though. I'd imagine there's probably better ways to prevent the bias."
proceduralgeneration,3bh5v0,Zappulon,1 point,Mon Jun 29 07:51:31 2015 UTC,"Hey Bergasms, love this. Have you tested it in minecraft yet? I'm curious as to how much impact it would have on real time generation as a player walks towards new chunks."
proceduralgeneration,3bh5v0,Euphoricus,2,Mon Jun 29 05:07:23 2015 UTC,"I would say it would be possibly very expensive... maybe. There are many optimisations you can do (ignore cells with no water in them) and in minecraft you can stop at sea level, but it would be tricky.     I have yet to approach the idea of realistic drainage in non discrete maps."
proceduralgeneration,3bh5v0,nothke,2,Mon Jun 29 05:09:16 2015 UTC,"That said, you could easily write something to import the heightmaps from this program into a subset of the minecraft world. I might do that as a visualiser actually, that could be cool."
proceduralgeneration,3bh5v0,Dascandy,1 point,Mon Jun 29 05:09:58 2015 UTC,"This would be impossible to implement in MC, because MC requires chunk generation to be independent and repeatable. This erosion algorithm requires whole map to be generated and in memory. Which is why MC doesn't have any erosion algorithm."
proceduralgeneration,3bh5v0,stewsters,1 point,Mon Jun 29 07:57:29 2015 UTC,"Yeah I know, I spent a bunch of time tinkering with minecraft using the MCP. You would have to generate drainage and height information for a large area and then base chunks off of that, which as you say would then produce different results based on chunk generation order. Non discrete is probably a pipe dream for accurate drainage"
proceduralgeneration,3bh5v0,Armeleon,1 point,Mon Jun 29 11:43:00 2015 UTC,"I was so happy to see this post as I am also making an ""on the fly"" procedural tile system in my game.. But then I saw this reply =( I also have the same problem of the tiles having to be independent"
proceduralgeneration,3bh5v0,megabronco,1 point,Tue Jun 30 09:57:53 2015 UTC,"It sure is a tricky problem. One thing you could do is generate 'macro' tiles that cover a NxN number of tiles and ensure that the macro tiles are accurate regarding erosion or rivers, then generate your world tiles based off of that macro tile."
proceduralgeneration,3bh5v0,Sarkos,1 point,Tue Jun 30 23:27:03 2015 UTC,"What happens if you keep running the logic on the 4000-it map? Does it basically stabilize then?  What would happen if you allowed user modification, and kept the algorithm running once in a while? Would you get realistic erosion with respect to user changes? - say somebody dams in a river; you'd get a lake forming, somebody breaks the dam, it floods a valley."
proceduralgeneration,3bh5v0,Sarkos,1 point,Mon Jun 29 11:30:01 2015 UTC,It does stabilise. I have found not a lot change past 3k iterations. If you allowed user editing then yes it should do stuff like that. I have added functionality to allow zooming in and panning around while it is building so I could add a function to edit areas and see.
proceduralgeneration,3bh5v0,cleroth,1 point,Mon Jun 29 12:45:59 2015 UTC,"You know when you are walking through a hilly terrain and it's full of local minima   You should come to southeastern Wisconsin, they are really common. https://en.wikipedia.org/wiki/Kettle_(landform)"
proceduralgeneration,3bfajp,NeroJoe,2,Sun Jun 28 18:32:56 2015 UTC,"I've talked about this subject at length with my brothers, both of whom are also big fans of Skyrim and open world RPGs in general. I started out very much in favor of procedural generation and hating how small worlds were in RPGs, but I've since changed my mind.  For me, the game that first caught me with an immense sense of immersion was World of Warcraft, back in the early days of Burning Crusade. I didn't have any friends who played it, and most of the max level players were off in a distant land that I hadn't heard of before. Seeing another player was somewhat rare, but that was okay. I rolled a Human Paladin and ran through Elwynn forest trying to figure out how to play this new game.  For someone who is new to the genre or is playing their first big RPG, the size of the world that you get in Skyrim or something like WoW is perfect. While it's still a 'theme park' to some degree, when you're new it makes no difference. The sense of wonder expands the world in your mind and makes it seem huge. Because everything is a new experience, you can spend hours doing mundane or pointless things because your brain is engaged and giving those things meaning. I had put my first hundred hours into the game before really taking the time to look at the map and realize how little of it I had explored and was hit with how huge the world really was.  Fast forward to Cataclysm. The world was tiny now- and not just because of flying mounts. I had seen and done it all. New zones were just more creatures to kill with no real danger. Mobs were tuned to not kill you easily, and the stories told in each zone were pale backdrops to the ""kill x"" and ""loot y"" quests. That's when I first started wanting to see the world rendered in full scale.  What if Elwynn forest really was that big? If Goldshire was a small settlement in the middle of the woods flanked by murloc camps to the east and bandits to the west. Patrols would walk the endless roads from Stormwind to Eastvale logging camp and back, hoping to not be caught by roving wolves or bears. Farms were cut out of clearings in the trees, and the whole forest was bordered by mountains on one side and a river on the other. In full scale, Elwynn forest would be incredible. Even at max level you could go there on your steed and ride for a half hour to get from one end to another, stopping to fight all sorts of random creatures along the way.  But here's the problem. And it's one that doesn't exist in FUEL or other open world racing games. It's that procedurally generated terrain (or manually created massive world) is boring. There's no story there. Or if there was, it would also be procedurally generated and clunky. A new player gets lost and confused, not seeing or understanding what they are missing when they have been running on a path for 15 minutes without seeing a questgiver.  Further, it taxes players who want to do quests or make progress in the game, adding hours and hours of meaningless travel. RPGs are supposed to be fun- and adding 5 minutes to each quests just to get to the area and get back isn't fun. You can always solve the problem FUEL style- give everyone a really big mount / race car. But that just makes the world small again.  Personally, I want to see bigger worlds. But I don't see a way of opening up the world without filling it with meaningful content. In the case of MMOs, Player made content doesn't keep with the theme of the game. Just about every minecraft server ever shows how hard people have to work to keep trolls from making obscene objects in the sky or covering everything with lava. In single player RPGs, the problem is even worse. Until we can really create the kind of content that can keep players engaged with large landmasses, I just don't see it happening.  Anyway- I wrote a lot more than I meant to. But there's my thoughts on the subject!"
proceduralgeneration,3bfajp,maxwellbegun,3,Sun Jun 28 19:06:28 2015 UTC,"Thanks for the input.  I have a thought of some of the problems that you mentioned.   But here's the problem. And it's one that doesn't exist in FUEL or other open world racing games. It's that procedurally generated terrain (or manually created massive world) is boring.   One of the ideas that I had was for the game's procedural generation system to account for players wandering around.  I said:  ""Artists could create a few hundred special landmarks (shrines, exterior ruins, interesting geology, dragon burial mounds, standing stones, etc.) and assign each one to a specific region. Then when you go and explore that region you could discover them. The system could decide when and where they appear. Let's say one discovery every 30-60 minutes of on foot playing time.""   Further, it taxes players who want to do quests or make progress in the game, adding hours and hours of meaningless travel.   I addressed this as well.  There would certainly be a fast-travel system to prevent ""hours and hours"" of travel time.  I said:  ""I propose a return to the Daggerfall style Fast Travel, but with even more options, and various types of encounters thrown in the mix. Think of it more like an Elder Scrolls version of Oregon Trail. There would be chance encounters with enemies, traders, NPCs, and randomly placed landmarks including dungeons.""   Personally, I want to see bigger worlds. But I don't see a way of opening up the world without filling it with meaningful content....  Until we can really create the kind of content that can keep players engaged with large landmasses, I just don't see it happening.   I agree 100%, and I feel like I've proposed a lot of ideas to help make the system work.  Anyway, thanks for your input, and let me know if you have any ideas to add.  :-)  Edit:  One last thing.  What I'd envision in a system like the one I proposed is that MOST questing and gameplay would occur in the areas handcrafted by a real game designer.  The procedural generated areas would be for the folks who enjoy wandering and losing themselves in the world.  Some quests of course would require wilderness excursions, but they would be optional side quests."
proceduralgeneration,3bfajp,stewsters,2,Sun Jun 28 19:49:13 2015 UTC,"Oblivion had a mix of procedurally generated terrain and handmade content.  Search for procedural in the wikipedia article.  Skyrim tried some procedural fetch quest generation.  The issue with proc gen is it either too often makes things look too real and not as fantastic as you would expect (many of the forests in oblivion were kind of boring), or too unreal and not believable.  It requires a lot of patience to get the right mixture."
proceduralgeneration,3bfajp,dahlesreb,1 point,Mon Jun 29 19:20:28 2015 UTC,"Great post! I'm working on an MMORPG like this, with the whole game design oriented around the landscape being procedurally generated. While it's not a TES game, I've been playing them for more than a decade and they are certainly one of my influences.   World grows organically. The explorable map is defined by altitude and terrain type at a 1 square kilometer resolution (a Cell). Pre-built content can be placed in unexplored territory, and it isn't announced - it must be discovered. The first time a Cell is entered by a player it is procedurally generated based on its altitude, terrain, any pre-built content in that location, and the content of any already-explored neighboring Cells (so it is seamless). Player actions impact the world. Killing NPCs and harvesting resources will reduce their population in a cell, which determines their spawn rate. If entirely depleted, NPCs or resources of that type will no longer spawn in that cell. Players can establish settlements once the populations of all aggressive NPCs in a cell have been reduced to zero. Unsettled Cells that haven't been entered by a player will eventually revert to unexplored wilderness; they will be freshly generated the next time they are entered. World changes over time. Flora (crafting resources) and fauna (NPCs) populations in Cells grow according to a growth rate up to a maximum capacity. Populations will also migrate over time from Cells with high populations to neighboring Cells that are more sparsely populated, until the populations equalize. Settlements are built over time, and structures will exist in the game world in progressing stages of construction until they are completed. Travel is hard. There is no fast travel in the sense of instant teleportation. The deeper the wilderness the more dangerous the enemies encountered, and death causes the player to respawn in the closest already-visited city. This limits how far players can explore, and therefore the size of the 'known' game world. NPC Quests are procedurally generated. NPC Factions will have strategy game style AIs (think Civ5) which generate quests for players based on the AI's goals and rewards them from the faction's resource stockpile. Completing the quest feels meaningful because you help the faction with a goal (settling new territory, fighting a military conflict) which is how the game's narrative progresses. A variety of different quests (scouting, gathering, hunting, crafting, escort, etc) that all contribute to the goal will be available, so players with different preferences can all have fun participating. Players can also create quests. Individual players and player-controlled factions (guilds/clans) can specify their own quests using the same parameters as the procedural generator. The players and the NPC AIs are all essentially competing for players to complete their quests. NPC dialog is procedurally generated. Rather than always assigning dialog options to specific NPCs, they are placed in a Knowledge Web. Generated NPCs will pull their dialog options from the knowledge web based on their location, faction, class, and other  parameters that are initially procedurally determined. Pre-built 'unique' NPCs can have 'personal' knowledge for traditional human-created content.   There's lots more - I've got solutions addressing almost all the points you enumerate (often along very similar lines), but I don't want to turn this post into a book. Right now I've got the design decently fleshed out and I'm in the early stages of coding it as a MUD to prove the concept. I'd love to make my own (graphical) MMO eventually, but I'm also interested in seeing if I could license the technology to other publishers."
proceduralgeneration,3bezt9,TheCommieDuck,2,Sun Jun 28 16:59:15 2015 UTC,"Would it be possible for you to post the altitude, temperature, and moisture maps as grey scale images, along with the rules that determine which biome is selected?  The ""ring"" behavior looks very similar to what I would expect to see if just one variable was being used to determine the biome, or if one variable had a much stronger influence on the biome selected than the others, or if there was not enough biomes.  Also, in the real world sometimes you will see ""ring biomes""; for example in mountain ranges with peaks higher than the tree line the ""tree biome"" will form a ring around the ""alpine medow""/""mountain peak"" biome... although I assume that is not what is happening here."
proceduralgeneration,3bezt9,neoquietus,2,Sun Jun 28 18:03:50 2015 UTC,"Unfortunately I've fiddled since they were taken but the heightmaps should be the same.  Raw: http://puu.sh/iFYhQ/82fa08fdf7.jpg Biome: http://puu.sh/iFYbo/d2001a89c8.png Temperature: http://puu.sh/iFYcI/7993cd4dec.jpg Moisture: http://puu.sh/iFYdH/447e9dc13e.jpg (Yes, the sea doesn't affect it currently) Altitude: http://puu.sh/iFYiF/eebace5c49.jpg  Bonus: Biomes as regions: http://puu.sh/iFYgU/15358b8649.png  The moisture one does look a bit homogenous.."
proceduralgeneration,3bezt9,R4_Unit,1 point,Sun Jun 28 18:13:40 2015 UTC,"I think /u/neoquietus is right.  From this data it looks like you are taking temperature as a function of altitude, thus rendering the two variables into a single one.  If indeed the moisture map is homogeneous, then it would be the case that the biome would be a function of altitude with a little bit of variation from the moisture which leads to the rings.  To help fix this, you simply need boost the sources of variation.  First, make temperature not simply a function of the altitude.  Add in dependence on latitude, distance from the coast, etc that you see in the real world.  This should already break up the rings.  Also, increasing the variability in moisture should also help."
proceduralgeneration,3bezt9,NooklearToaster,1 point,Sun Jun 28 22:15:16 2015 UTC,"Temperature is a lerp between a fairly smooth, low frequency noisemap and the inverse of the heightmap (about 70% towards the noisemap).   I'll try to fiddle with moisture in a bit :)"
proceduralgeneration,3bezt9,cleroth,1 point,Sun Jun 28 22:26:37 2015 UTC,"I'd correct the sea to impact moisture, then from here what you really need to build a more believable system is wind. Wind currents carry moisture and impact temperature a decent amount, and then mountainous regions will act as a barrier and draw more believable lines between regions."
proceduralgeneration,3bezt9,ZenAnonymous,2,Mon Jun 29 05:08:34 2015 UTC,"Alternatively, I end up with 'rings' of biomes - arctic on mountains, followed by a forest ring a few tiles thick, then a different ring a few tiles thick, etc.   You won't be able to get rid of that with just noise functions. You'll have to do some post-processing. Realistically biome borders are rather vague, so it's usually a good idea to do some kind of large blur over it."
proceduralgeneration,3bezt9,Squishumz,1 point,Mon Jun 29 07:48:49 2015 UTC,"Does latitude have an impact right now?  In a realistic world you'd expect more arctic towards the poles, more desert towards the equator."
proceduralgeneration,3bbsos,DubstepCoder,2,Sat Jun 27 18:41:44 2015 UTC,Your blogs and videos are super helpful. Very easy to read to. Thanks!
proceduralgeneration,3bbsos,naran6142,1 point,Sat Jun 27 22:31:32 2015 UTC,Glad to be of service!
proceduralgeneration,3bbsos,pihesfsk,0,Sat Jun 27 22:42:12 2015 UTC,hello this is very good but I have a number of constructive criticisms : 1 )page too black 2 ) i see only spheres and not other shapes ( cylinder ) i would like to generate two spheres and a cylinder with heightmap ( rivers on the cylinder ) . please advise . thank you !
proceduralgeneration,3bals7,livrem,3,Sat Jun 27 10:53:17 2015 UTC,"I am not following why any RNG can not be used with a supplied initial component (seed). Can you see the outcome of the seeds ""locally"" up front?  Do you know what the stats to max are? If you do, an implementation could be made that ""caps"" the effective values, so as one grows high the ""related"" have a lower chance of growing.  You could still search for tailored seeds, but those you find are standardized somewhat. Depending on the way you calculate and insert the seeds to the effective values (effectively adding computations just like a hash would) the cost associated with it grows (you can go from A to B, but not from B to A), you have the safeguard you are looking for with backward calculations. Most (if not all) RNG would fit that bill still as they are not reversable. You could make it more so if the generation can be setup in a process that can not be reversed either.  e.g. A setup where you colour a chessboard based on the input values are reverseable, and you can search for specific patterns, but a setup where you use something like Langton's Ant's to produce the pattern you could not easily reverse an image to a seed."
proceduralgeneration,3bals7,TaohRihze,1 point,Sat Jun 27 11:29:43 2015 UTC,I am not following why any RNG can not be used with a supplied initial component (seed)   arc4random doesn't support manual seeding. I believe most cryptographically secure RNG don't.
proceduralgeneration,3bals7,cleroth,1 point,Sat Jun 27 11:35:40 2015 UTC,"I might be dense here. If I read this correct you are saying your chosen platform does not support a RNG that takes seeds? If that is the case, is there any library to that language you can import to use?  And per definition cryptographically secure RNG only require the ""adversary"" to not know the selected seed. I am not sure how you plan on handling the seeds, if there is a server/client connection or not, in which case you could provide the seeds and have a similar effect.  I might just not be following the problem you are trying to avoid here. Either you can locally generate the desired outcome, or you can not .:)  If it is locally located, unless you put restrictions onto the seeds that can not be manipulated (Time is one that can easily be manipulated) then any person with enough time, skill and determination can reverse the selection of the seed. By doing so you are back to the process of looking to make it unfeasible to backtrack an outcome to a seed, and/or prevent the bruteforcing and selecting an optimal choice of the outputs."
proceduralgeneration,3bals7,TaohRihze,1 point,Sat Jun 27 11:53:10 2015 UTC,"I am not OP. I was merely stating there there are some PRNGs that do not take seed input. arc4random is one of those on iOS. Of course you can still use rand()/srand() in its place, though that's not cryptographically secure."
proceduralgeneration,3bals7,cleroth,1 point,Sat Jun 27 13:41:55 2015 UTC,"Yes, I have struggled to find a way to reverse even the most simple RNG, but I don't think they are specifically designed to make that difficult, so perhaps there are ways to reverse them (all or some bits of them) that I just don't see because it is not something I am an expert in.  My original idea (that I prototyped and playtested a bit about 18 months ago but then lost interest in for a while) is a procedurally generated game where players ""mine"" (using their computer) for squads that they then use to play a simple tactical game. Like a collectible card game, but distributed, so you don't publish official boosters of random cards players have to buy, but instead they can generate as many units as they want and just keep looking for good ones to use. The tricky thing is just to make sure no one can specify some characteristics of a squad and quickly calculate a good seed, because then everyone would quickly find whatever units they wanted to without having to ""collect"" anything (what fun would that be?)."
proceduralgeneration,3bals7,TaohRihze,1 point,Sat Jun 27 12:03:35 2015 UTC,"As you describe it, providing the seeds from the server (possible allow X reseeds) would be the solution.  As for reversing a RNG, if I recall right, most are based on the same principles as in Hashing meaning data is dropped in the process, making reversing prohibitively expensive. To be ""sure"" that is the case you could add an XOR filter of a hash value from the generated values, but that should be an unnecessary step.  As for my point with the generation setup, what you are saying you want to avoid is the chance of someone keep requesting/trying for the ""perfect"" seed.  Now you are back to how to prevent a such brute force, and you are here looking at reverse engineering an outcome to a seed. This is quite unlikely and brute forcing is the attack of choice. That said that can be done effectively with enough time and determination. (hack or just plenty of times to rerolling) if the mechanisms allow local generation of data.  So the ways I see to prevent it, is either making the rerolls prohibitive in cost (and slow for everyone), make sure the process ""adjusts"" the outcome so there are no ""extreme"" cases, kinda like a point system, and you are kinda back to why not let the players just choose what they want in setup, or provide the seed from a server and put a limit on how many may be requested per account, then make sure the output is peppered (a unique value per account is added to the generation layer, so a player can not request multiple seeds from different accounts to get what they want). A simple such methode is to let each player have a unique RNG seed, and provide a random. Create 2 RNG streams, and add those two and MOD by 1 before continuing with their usage."
proceduralgeneration,3bals7,TaohRihze,1 point,Sat Jun 27 12:16:32 2015 UTC,"I understand that providing good random seeds from a server would be a great solution. But I think it is nice to make a truly distributed solution. Otherwise you can just as well generate all the contents and distribute like in every other collectible online game. The premise here was me thinking if it would be possible to design a collectible game that did not rely on a central authority having to generate all the content, much like bitcoin makes it possible to have money without a bank printing them.  Brute-forcing is fine I think, for the same reason that it works for bitcoins. If the number of possible squads are astronomical, and the seed is a lot of bits, no one will be able to search the entire space anyway. In fact my first prototype even included a way to automatically search for good squads, so you could specify what you were looking for and leave your computer running to find the best it could find. But that is far different from being able to just specify what you want and quickly get a good seed.  I also thought about the points-thing. Part of this is that values are virtually limit-less, so that extreme values are possible, but might not exist at all, and you will never know unless you look through all the squads. And even if you find a squad with one extremely good unit chances are some other units will make it much less good. Which is why in my new iteration I have split the seed, and the squad, into three independent parts, so that you can search for three different good seeds and combine them in ways that you like. That is much more like how collectible games work (you don't usually play with the exact contents of a booster, but you mix the best parts from different boosters that you like and combine them into something (usually a deck) that you like to play with). (EDIT: Actually one possibility I might try is to make each individual unit/card its own seed, so that you can just combine any mix of units/cards you like (just like you would in any normal collectible game). But that makes it even more important that seeds can not be reverse-calculated, because otherwise it will be trivial to find just the best cards you want to use.)  Must admit though that I am not a huge fan of the idea of people wasting energy on mining for good squads for a game, so in the end I might not even try to make this popular or publish it at all. But I still want to solve the problem and see it work. :)  This might all sound very silly, but when testing this (just me and my brother) it actually WAS very fun to just generate random squads and look for good ones. There is something very rewarding about creating something random and finding it to be very good. But I guess readers of /r/proceduralgeneration do not have to be told that. :)"
proceduralgeneration,3bals7,cleroth,1 point,Sat Jun 27 12:29:27 2015 UTC,"Consider the personal account seed/modifier, possible with the timestamp addon, that way everyone must search their own setup  But what you describe is you are back with the bruteforce methode being fine. In which case, how automated would you want to allow it."
proceduralgeneration,3bals7,dnew,1 point,Sat Jun 27 14:01:15 2015 UTC,"My original prototype had a unique id (part of the seed) assigned to each player to make sure squads could not be stolen. I'm not sure that is the method I am going to want to use, but it is definitely a consideration.  The original prototype had built-in brute-force-search, because then at least anyone will be able to automate the search to some extent. Otherwise someone with a tiny bit of programming skills will gain a huge advantage. Someone might still come up with a better search algorithm (or better algorithm to estimate the values of squads), but at least everyone else would not start from nothing, so the advantage would be less."
proceduralgeneration,3bals7,cleroth,1 point,Sat Jun 27 14:49:07 2015 UTC,What you want is a cryptographically secure RNG.
proceduralgeneration,3bals7,AngriestSCV,1 point,Sat Jun 27 11:32:28 2015 UTC,"I know anything safe for cryptography would solve my problem, but it seems like those solutions are a bit overkill and usually quite complex. If there are much simpler RNGs that are difficult to reverse-calculate (but without all the other stuff you need for real security) I would prefer that.  But if I do use something secure, do you have any recommendations? The players will have all the code downloaded in a client, so I can't have anything that relies on hidden keys or anything, it has to just be an algorithm that can not be calculated backwards."
proceduralgeneration,3bals7,cleroth,2,Sat Jun 27 11:54:58 2015 UTC,Use ARC4 (also known as RC4 except that name's trademarked). It's about 5 lines of code and plenty secure for this application.
proceduralgeneration,3bals7,AngriestSCV,1 point,Sat Jun 27 21:23:40 2015 UTC,If nothing else that looks like a fun little algorithm to implement. Thanks for mentioning it!
proceduralgeneration,3bals7,cleroth,1 point,Thu Jul 2 21:17:46 2015 UTC,"Take a look at the PCG family. PCG is really fast and relatively new. It's very unlikely that someone's going to reverse engineer it for your game, but there's a small chance that PCG might be discovered to be predictable, to some degree."
proceduralgeneration,3bals7,AngriestSCV,1 point,Sat Jun 27 13:36:41 2015 UTC,"Asking in public and then spending a few minutes away from the computer might have helped (as it often do). I'm thinking that if seeds also must be valid time-stamps, in the past, then you both get a natural limit on the amount of CPU that can be wasted on brute-forcing (no point finding a squad you are not allowed to use for several years), and also makes it extremely unlikely that a calculated seed will be valid, but still leave a growing limitless (in theory) number of possible squads that can be generated. I like that, at least after thinking about it only for a few minutes. Almost any old RNG would probably be good enough  then, and I might not have to be too concerned about the possibility of calculating a seed after all I guess."
proceduralgeneration,3bals7,dnew,1 point,Sat Jun 27 13:20:58 2015 UTC,"Maybe roll your own? Based on your other replies it seems like you don't want a heavyweight solution. Some are simple.  Easy , but with sever deficiencies you will have to work around https://en.wikipedia.org/wiki/Middle-square_method    Harder, but better https://en.wikipedia.org/wiki/Mersenne_Twister https://en.wikipedia.org/wiki/Multiply-with-carry"
proceduralgeneration,3bals7,TomatoCo,2,Sat Jun 27 13:22:59 2015 UTC,Mersenne Twister is highly predictable.
proceduralgeneration,3bals7,Muhznit,2,Sat Jun 27 13:38:16 2015 UTC,"All pseudorandom number generators are. Maybe I'm missing something, but the OP mentioned ""seed"" and that implies not only a pseudorandom number generator, but also a way to replay last runs of it."
proceduralgeneration,3bals7,Arandmoor,1 point,Sat Jun 27 13:41:31 2015 UTC,That's kind of a bold statement. So far nobody has been able to predict PCG output.
proceduralgeneration,3bals7,green_meklar,1 point,Sat Jun 27 13:47:20 2015 UTC,"I think there has been a miscommunication. I was not referring to the ability to look at this run's data and predict the next number. I was discussing the fact that since it is reproducible running it again will provide the same results, thus allowing you to look up what the next random number will be to ""predict"" it. I was not aware of the usage of predict as it pertains to random number generation until your comment led me to PCG's site"
proceduralgeneration,3bals7,dnew,1 point,Sat Jun 27 14:43:29 2015 UTC,Since the seed is known there really isn't a way to limit predictability. This was more about trying to limit the ability to work backwards and calculate what seeds to use.
proceduralgeneration,3bagdu,UltimaRatioRegumRL,2,Sat Jun 27 09:16:45 2015 UTC,Will any of these be available afterwards for those of us that can't make the live ones?
proceduralgeneration,3bagdu,Siperiea,1 point,Sat Jun 27 17:04:25 2015 UTC,"Yes! We'll be uploading as many of the talks as possible to Youtube (hopefully all of them, but it needs the speakers to email in their slides)"
proceduralgeneration,3bagdu,Siperiea,2,Sat Jun 27 21:22:05 2015 UTC,"Cool - was hoping to get down but couldn't make it. Will keep an eye out for them, thanks!"
proceduralgeneration,3bao35,Insignificant,3,Sat Jun 27 11:31:14 2015 UTC,I think you need to find the distance to the nearest point and make your radius half that.
proceduralgeneration,3bao35,liquidivy,1 point,Sat Jun 27 16:33:24 2015 UTC,"Yes, I think you're right. Thanks. I did wonder weather or not I could avoid the additional nearest neighbour step, but I've had quite a hunt and I can't find anything to suggest that it's possible."
proceduralgeneration,3bao35,redblobgames,2,Sat Jun 27 23:30:34 2015 UTC,"I'm not sure, but I think you might be able to use Delaunay triangulation of your points to find all the nearby points, and then you can take half of the minimum distance to all the neighbors to be the radius."
proceduralgeneration,3bao35,Hax0r778,1 point,Sat Jun 27 16:27:03 2015 UTC,That's definitely the best way to find the nearest neighbor which I think answers OP's question? It's a little vague because you could have non-intersecting circles by making them all radius 0.0001 and if you want the maximum size it depends on if you want the maximum area (which your method does not give) or something else?
proceduralgeneration,3b7sks,shparki,3,Fri Jun 26 17:38:45 2015 UTC,"That depends.  The math isn't hard in PG.  What about CS? Stats? Systems theory?  What about domain knowledge - e.g. what are you generating - architecture / art  / geology / stars /,,,,"
proceduralgeneration,3b7sks,Random,1 point,Fri Jun 26 19:05:28 2015 UTC,"I honestly just find a huge fascination with PG and eventually, when I work on my Masters, would love to focus my research in PG. I want to make games, but I want to try to make new, innovative ways of using PG as well as improving where improvements can be made."
proceduralgeneration,3b7sks,clavalle,5,Sun Jun 28 00:09:14 2015 UTC,"Ohh, it's like a buffet!  In roughly this order of applicability:  Probability  Random Graphs and Stochastic Geometry  Intro to Stochastic Processes  Stochastic Processes II  Matrices and Matrix Calculations  Discrete Mathematics  Applied Regression and Time Series  Applied Statistics  Numerical Methods for Applications  Methods in Applied Mathematics  Mathematics as Problem Solving  Mathematical Modeling in Science and Engineering  Linear Algebra"
proceduralgeneration,3b7sks,clavalle,1 point,Sat Jun 27 02:35:16 2015 UTC,"So I know what most of these courses cover generally, but what do ""Random Graphs and Stochastic Geometry"", ""Intro to Stochastic Processes"", and ""Stochastic Processes II"" cover? I've never really hear of the Stochastic Process."
proceduralgeneration,3b7sks,Squishumz,1 point,Sun Jun 28 00:10:25 2015 UTC,"Stochastic processes are basically techniques with some amount of randomness thrown in.  So, lets say you have a music generator.  You give it a key, which is a starting tone or chord, and it moves to other tones and chords.  It would be extremely boring if it was completely deterministic and moved from one chord to the next the same way every time.  So, for each stage of the song you have certain sub set of chords in the key that sound good if placed next after the particular chord you are on -- usually this is limited to one or two or three good choices out of the seven tones in the key.  One tends to dominate and the other two are for flavor.  So you'd give each one a probability that it will be picked.  You do the same thing with each chord you want to include, which tends to be all of the chords in the key and maybe a couple of more exotic ones.  This collection of states (chords) and probabilistic edges (movement to another chord) is a Markov chain.  With that addition of 'randomness' you've created a stochastic process.  That's just one example, there are a ton of other stochastic techniques but they all boil down to adding some controlled randomness to the process to keep things from being too deterministic and predictable.  It is what makes things interesting."
proceduralgeneration,3b2ov9,WORDSALADSANDWICH,7,Thu Jun 25 14:09:48 2015 UTC,This is the 10th time i see this article. I think it has been reposted to every sub.
proceduralgeneration,3b2ov9,HypnoToad0,2,Thu Jun 25 20:54:23 2015 UTC,I suppose it's relevant in many contexts.
proceduralgeneration,3are8j,Sendatsu_Yoshimitsu,3,Mon Jun 22 22:08:06 2015 UTC,"There is a fair amount of info out there, it's just a case of taking the time and tracking it down/figuring out whats useful/relevant to you. Also how far down the rabbit hole do you want to go?  Here is as good a place as any to start I guess:  http://www.reddit.com/r/proceduralgeneration/search?q=city&restrict_sr=on  http://www.reddit.com/r/proceduralgeneration/comments/2jd9fv/city_generation_techniques/  Also procedural generation techniques for generating buildings/architecture looks fun:  http://www.reddit.com/r/proceduralgeneration/search?q=architecture&restrict_sr=on"
proceduralgeneration,3are8j,scribblenose,3,Tue Jun 23 08:46:41 2015 UTC,"There is a fairly large amount of work/literature in this area, and it much of it falls into these topics:   generating terrain shape generating road networks  dividing urban areas on either sides of roads into parcels/lots of land generating 3D shapes/profiles of buildings generating facade details for buildings generating placement of 'detail' objects, such as street lamps and dustbins   Which of these are you looking for information about?"
proceduralgeneration,3are8j,RedSpaceman,1 point,Tue Jun 23 16:26:23 2015 UTC,"The single most important one for me is generating road networks (as that's going to direct player behavior), but honestly I'm going to need all of them eventually- the basic structure I have in mind is draw roads > gross pass to parcel out land and block buildings out into primitives > refine pass to detail buildings > final pass to sprinkle detail objects in scene.  It might well turn out that what I'm thinking is far too involved to process on the fly, but I'm basically trying to work out a geometrical-based ruleset that can give the player pseudo-infinite urban blocks to explore without looking (obviously) weird."
proceduralgeneration,3are8j,RedSpaceman,1 point,Tue Jun 23 17:46:54 2015 UTC,"Roads:   PDF: ""Algorithms for the Automatic Generation of Urban Streets and Buildings"" PDF: ""Procedural Generation of Parcels in Urban Modeling"" Article of interest, discussing city layout archetypes: ""There are only four types of city says math"" Someone's draft thesis discussing procedural generation of environments, including urban environments: http://twak.blogspot.co.uk/2013/05/unwritten-procedural-modeling-with.html Browser toy performing road generation One of many articles in a procedural generation blog, which discusses urban environments Another browser based road generator (with code) Visualised comparison of road layout types from some major cities   Those are some various bits of information I was able to retrieve from my (apparently quite scattered) notes. There are a lot more out there. Google Scholar may be able to turn up some things of interest."
proceduralgeneration,3are8j,RedSpaceman,1 point,Wed Jun 24 14:53:53 2015 UTC,"Thank you!! This is intensely useful- I've been doing my legwork, and finding that in a lot of ways signal-to-noise ratio is more challenging than finding a dearth of material, especially when game-specific considerations come into play- some of the best stuff I've found has been behavior/agent-based, but that isn't particularly useful unless you're building something like dwarf fortress that can spare 2-3 minutes at worldgen to precompute everything."
proceduralgeneration,3are8j,maxcreeger,1 point,Wed Jun 24 18:28:18 2015 UTC,"You are definitely not the only one dreaming of this, though I suspect that it is likely to be quite challenging. I'm sure we'll get there, but whether we are there yet is a good question.  DF generates a lot of content, including historical content. Perhaps for your game there will be things that can be generated in relatively little time (extra 10s loading isn't too bad) but can act as a rough-form generation. Perhaps the main shape of buildings in your city, particularly the largest/tallest ones. As the character moves between chunks the models etc for the nearby buildings can be further refined, while the rough forms stay in memory.   For finding academic literature on a topic I find it is often very useful to look at the citations for related papers I have found, then find the cited papers (google scholar is good, and you can filter for pdfs to find free copies) and repeat. It certainly tends to help with finding the most vital/seminal papers in a field."
proceduralgeneration,3anl7b,qarl,4,Sun Jun 21 23:50:11 2015 UTC,Thanks!
proceduralgeneration,3anl7b,blcktrngl,4,Mon Jun 22 00:57:13 2015 UTC,my pleasure.  :)
proceduralgeneration,3anl7b,Dany0,0,Mon Jun 22 01:59:58 2015 UTC,"How about this, it's interactive."
proceduralgeneration,3anl7b,determinanten,2,Mon Jun 22 08:59:33 2015 UTC,ah!  that's a great resource.
proceduralgeneration,3ao01n,NeomerArcana,4,Mon Jun 22 02:10:32 2015 UTC,Really nice. I wish you'd write more about how you accomplished all this!
proceduralgeneration,3ao01n,TynanSylvester,9,Mon Jun 22 05:19:49 2015 UTC,"Okay.  So you have a universe. For the purposes of what we're doing, we can say that any ""region"" or ""star cluster"" in the universe has an amount of matter equal to the amount of matter in the universe divided by the size of the universe (measured in star clusters).  So, if our universe has 10000 matters and 10 star clusters, each cluster will have 1000 matters.   Then we can adjust it by a falloff according to the distance from the center of the universe. So clusters toward the center have more mass.  We can now generate galaxies if we want in here, but I won't. You basically just add another level of accretion to this.  So, for each cluster, we orient it according to the plane. The universe probably doesn't have a plane, it's more like sphere, but from a galactic level, there is a sort of plane. In a solar system there's a plane as well.  For a cluster / galaxy in the universe, the plane can simply be a ray that we cast from the center of the universe. The tangent to this, any tangent, can be the plane. So some will be this way and that, but it doesn't matter much.  Next we can generate 2D noise of some large size. Probably Perlin through some fBm function. This represents the amount of matter in this cluster.  Now we can create disks of varying sizes like this. Each disc is a further and further distance from the center of the noise, and they all are around the center. They are more like Xena's disc weapon thing. The width of each is a function of the amount of noise radially around it. We can calculate this by walking out from the center some unit of measurement, and then sampling all around the disk by stepping around the center. This gives each concentric circle of ""unit"" measurement a value of ""total matter in this circle"".  These can then be used to determine the width of the Xena discs. Basically, the discs with the largest values ""suck in"" their neighbours. You can do this x number of times until we have good values.  Each Xena disc will coalesce into a star system. We could create different sized stars based on the amount of matter in each disc. The spacing of these stars would be based on the original noise pattern, so where there's more noise is where each star is more oriented towards (but keeping their orbit around the center). Alternatively, we could do an n-body to scatter these guys a bit, but they'd probably clump up, which might be what you want.  Now, to do planets we do the same thing. But this time we know that bodies toward the center will have rockier elements etc. We could create a different noise pattern for each element type, like helium, rocky materials, icey materials or whatever.  When moving these bodies around the center as they accrete, we could use an n-body simulation to allow them to migrate inwards and outwards.  After we've run it for long enough we could have rocky bodies over here, and some other bodies moved over here etc. The makeup of elements for each body + the size + distance from their ""sun"" will determine what type of planet they are.  Then, you can generate the planets textures etc.  For my terrestrial planet; it was tricky.  First, I created Perlin Noise in fBm, which was then clamped a bit so that values above x are 1 and below it are 0. This gives you a splotchy pattern.  Then a second Perlin+fBm was used to determine the base height. This was scaled down a bit for low and smooth height values.  Then a third Perlin+fBM was used for the mountain ranges. This doesn't use fBm but uses Ridged Multi-Fractal instead. This was then put through a Turbulence pass to wiggle the mountain ranges.  This third pass is then clamped so only the mountainous values are used. This is then dropped on top of the second passes values, replacing them.  Each of the above uses slightly different values of persistence, lacunarity + scale.  The values are re-mapped to make sure they stay within -1 to 1.  A simple colour ramp is then applied. There's about 15 different colour steps in the gradient that I used. You can see this in the striated mountains and the little coastlines.   For the clouds it's the same as above. There's a clamped splotchy pattern to determine the shape of clouds, then a Perlin+fBm put in those places to distribute the cloud. (there's not Ridged lines obviously).  Finally, the clouds are spiralled in 2D by selecting random points and twirling the noise around it depending on the distance from that point. These twirls all sort of mix in together a bit.  All of the noise values are actually cube-mapped so it's sampled from 3D noise. All except the twirl stage of the clouds, these are done in 2D because I've been having trouble with like, conic sections or something to twirl along the face of a sphere.  Oh, and the values from the ground texture are using to do screen-space derivative height mapping. Finally there's actually 4 spheres there, one for the ground, one for the clouds and then one for the Atmospheric Scattering (the circle halo around the edges) and one for the ground-level atmospheric scattering which makes the foggy appearance as the curve of the each happens. Obviously there's lighting on it for the ocean shininess and the shadow of the planet and all that. All of these affects are done via shaders.  Oh and I forgot there's some specular maps made for each texture as well. But they're very simple to base on the noise values."
proceduralgeneration,3ao01n,smcameron,1 point,Mon Jun 22 06:14:06 2015 UTC,"Clouds look nice.  I like the swirling idea.  To do it on a sphere, one way (probably not a fast way) would be to compute the quaternion that would rotate the center of your swirl to ""front and center"", then for each point, rotate it in 3D by that quaternion, then do the swirl in 2D, then undo the quaternion rotation to find it's new swirled spot on the surface of the sphere."
proceduralgeneration,3ao01n,smcameron,0,Tue Jun 23 00:46:49 2015 UTC,"Wouldn't that swirl as a plane on the tangent to a point on the sphere (then project it back down), rather than swirl around the point on the surface of the sphere?"
proceduralgeneration,3ao01n,VoxUmbra,1 point,Tue Jun 23 01:32:18 2015 UTC,"Yes, but as long as your sphere is big enough relative to your swirl, (say, sphere radius is 5 or 10x swirl radius) it'll be fine.  Nobody's going to look at a swirly cloud and say, ""hey, that's not swirled on the surface of a sphere -- it's swirled on a plane tangent the sphere then projected onto the sphere! -- So fake!"""
proceduralgeneration,3ao01n,smcameron,0,Sat Jun 27 06:17:04 2015 UTC,Hahha. Fair point.
proceduralgeneration,3ao01n,Lolologist,0,Sun Jun 28 02:25:04 2015 UTC,"If you're interested in getting a bit more realism for your terrestrial planets, you could look into tectonics.js"
proceduralgeneration,3ao01n,shvelo,1 point,Mon Jun 22 14:42:33 2015 UTC,"Maybe there should be some posting guidelines to explain that you're not meant to just drop a picture in here with no explanation and then run away (not that OP did that... OP delivered, once prompted.)"
proceduralgeneration,3ao01n,YouShouldUseProlog,2,Tue Jun 23 00:50:54 2015 UTC,That's a pretty sweet earth!
proceduralgeneration,3ao01n,YouShouldUseProlog,1 point,Mon Jun 22 03:08:17 2015 UTC,"Looks very impressive from afar, but up close there's too much flat land, is it intentional?"
proceduralgeneration,3ao01n,YouShouldUseProlog,0,Mon Jun 22 11:17:42 2015 UTC,"Not intentional. It's actually undulating, not flat, except the scale of the bump-mapping isn't correct, so it's not coming though correctly.  More tweaking needed."
proceduralgeneration,3ao01n,YouShouldUseProlog,1 point,Mon Jun 22 11:43:27 2015 UTC,question why noise to make the disk?
proceduralgeneration,3ao01n,YouShouldUseProlog,0,Mon Jun 22 15:03:42 2015 UTC,"The noise is to simulate the random distribution of matter in the accretion disk. You can do the falloff from center thing as well to have their be more matter towards the center or whatever as well.  The only other method I can think of is to pick a random number of planets of a random type. Which isn't quite the same as letting matter coalesce and determine the type of celestial body based on it's mass and elements.  You could get unexpected results; so long as you can define the conditions to determine lots of different celestial bodies. For example, if a gas giant forms that's roughly x10 the mass of jupiter, you can make this a brown dwarf because that's the point that mass starts becoming a star."
proceduralgeneration,3amu9a,semperunum,4,Sun Jun 21 19:48:32 2015 UTC,"You can do equirectangular mapping (imagine taking your 2d map, rolling it into a cylinder, then scrunching up the top and bottom of the cylinder to make a sphere.  You can pre-distort the image so that when you scrunch up the top and bottom, it will undistort.  However, it's not perfect, there will generally be artifacts at the poles, and getting rid of the seam where the cylinder is joined up is also problematic, as likely triangles will straddle the seam, so you'll get things like this: http://mft-dev.dk/wp-content/uploads/2014/05/isocahedron_solid_textured_01.gif in which the entire texture gets interpolated over a straddling triangle -- backwards.  But if you want to try anyway, I have a python program to pre-distort images here and another thing which can turn such pre-distorted images into cubemaps which will get rid of the zipper seam problem but not the pinching at the poles.  The correct answer is cube mapping, and making textures with that in mind from the start rather than starting with a 2d map, but this is not so easy (See for example: gas giants and earthlike planets )"
proceduralgeneration,3amu9a,smcameron,5,Sun Jun 21 21:03:33 2015 UTC,"You might be interested in Dymaxion maps, since your low-poly shape is an icosahedron."
proceduralgeneration,3amu9a,switchcasebreak,3,Mon Jun 22 02:05:52 2015 UTC,"Dymaxion map:       The Dymaxion map or Fuller map is a projection of a world map onto the surface of an icosahedron, which can be unfolded and flattened to two dimensions. The flat map is heavily interrupted in order to preserve shapes and sizes.  The map was created by Buckminster Fuller. The March 1, 1943, edition of Life magazine included a photographic essay titled ""Life Presents R. Buckminster Fuller's Dymaxion World"". The article included several examples of its use together with a pull-out section that could be assembled as a ""three-dimensional approximation of a globe or laid out as a flat map, with which the world may be fitted together and rearranged to illuminate special aspects of its geography.""  Fuller applied for a patent in the United States in February 1944, the patent application showing a projection onto a cuboctahedron. The patent was issued in January 1946.   The 1954 version published by Fuller, the Airocean World Map, used a modified but mostly regular icosahedron as the base for the projection, which is the version most commonly referred to today. This version depicts the Earth's continents as ""one island,"" or nearly contiguous land masses.    Image i     Relevant: Bernard J. S. Cahill | World Game | Buckminster Fuller | Dymaxion   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
proceduralgeneration,3amu9a,autowikibot,3,Mon Jun 22 02:06:37 2015 UTC,"If by 2D map you mean rectangle, then no it can't be mapped nicely to sphere without some distortion afaik. I would suggest reading up on ""map projection""."
proceduralgeneration,3amu9a,BlueWolf_SK,2,Sun Jun 21 20:08:07 2015 UTC,"If you're using completely procedurally generated terrain, I've found it useful to generate the planet in its spherical form from the start (there are a number of algorithms for doing this) and then generate a flat map based on the spherical data. It avoids the problem completely."
proceduralgeneration,3amu9a,ksleet,2,Sun Jun 21 23:37:27 2015 UTC,Example?
proceduralgeneration,3amu9a,ksleet,3,Mon Jun 22 02:20:56 2015 UTC,"Well, there's the classic sphere-slicing for starters, as seen on Paul Bourke's page. You could also start with a tetrahedron shape and subdivide the triangles in the same way you'd subdivide triangles on a flat plane. Myself, I've been overlaying 3D noise textures at multiple scales and sampling them at the surface of the sphere, which works really well to generate the surface in a shader. There's probably other ones I haven't mentioned as well."
proceduralgeneration,3amu9a,tombsar,1 point,Mon Jun 22 02:44:04 2015 UTC,Unfortunately there is no way to simply wrap a 2D map around a sphere without having distortion somewhere. I would suggest generating 6 2D maps that you can apply through cube-mapping.
proceduralgeneration,3amu9a,quickpocket,-1,Sun Jun 21 20:13:27 2015 UTC,I was actually planning on coming here and asking the exact same question. Ninja'd.
proceduralgeneration,3ajsgb,anarchy8,10,Sat Jun 20 21:59:29 2015 UTC,"I would think you would need to generate heat first. Not necessarily accurately, but something like energy absorbed by the sun (influenced by altitude, material (water, dirt, grass), latitude, season).   Then you could make wind flow from high temp -> low temp. It may be a slightly inaccurate, but then you could use the wind to recalculate heat and repeat until you have a stable solution.  I'm not sure how well this work; I have never actually made wind maps. However, this would be my plan.  edit: You good bias wind in one direction (ie east) based on latitude to add the Coriolis effect. (which would be cool) edit2: This may also interest you"
proceduralgeneration,3ajsgb,semperunum,3,Sat Jun 20 22:30:40 2015 UTC,"But wind doesn't flow from higher to lower temp, it flows from higher to lower pressure."
proceduralgeneration,3ajsgb,semperunum,13,Sat Jun 20 22:33:00 2015 UTC,"Assuming, there is currently no wind (not a solid assumption), temperature is either directly or inversely proportional (depending if we are talking surface or high-altitude) to pressure. This is due to the equation PV = nRT. n, R and V are roughly proportional.    And thus, it good initial value for making a good pressure map.  For successive iterations, you would likely need to incorporate wind into pressure calculations to compensate for the assumption above.  edit: as a source for temp -> pressure: The Climate Cookbook"
proceduralgeneration,3ajsgb,smcameron,1 point,Sat Jun 20 22:41:33 2015 UTC,That is an amazing source and I think it's exactly what I need. Thanks!
proceduralgeneration,3ajsgb,KdotJPG,3,Sat Jun 20 23:43:30 2015 UTC,"If you look at weather systems you get rotations around high and low pressure areas rather than simply flowing from high to low pressure, I gather this is due to the Coriolis effect.  And it acts kind of like an incompressible fluid, so you might model it as a computational fluid dynamics problem, but that is kind of hard and computationally expensive.  I am going to sound like a broken record for bringing this up again, but if you want that same ""look"" of CFD, but don't mind that it's not physically accurate (and since you're talking about hexagons, I'm thinking physically accurate is not a huge concern) you can use the ideas in curl noise for procedural fluid flow  The idea is you can use perlin or simplex noise to define your pressure field (ie. plug in your coordinates and get back a noise value that you treat as a pressure value at that location) Find the gradient of the noise, then turn that gradient 90 degress (by swapping x and y and negating y, iirc) and that is your wind velocity.  This will get you a divergence free velocity field with wind rotating opposite directions around high and low pressure areas.  You can modify the velocity field (e.g. by adding in to the x-velocity by for example k * sin(lattitute * numbands) to get horizontal bands of opposing flows mixed in with the swirling velocity field.  Extending the same idea to 3d is harder, but possible    previously."
proceduralgeneration,3ajsgb,Bergasms,1 point,Sun Jun 21 05:40:57 2015 UTC,"3D noise. Two instances, A for X offset, B for Y offset. Low frequency. Z is time. Derivatives <dA/dz, dB/dz> determine magnitude and direction.  Downside: doesn't factor your existing variables in. But you can offset your heat, clouds, etc. with the offsets here."
proceduralgeneration,3ajsgb,Bergasms,1 point,Sun Jun 21 15:51:35 2015 UTC,Just sample This   and use real values :P
proceduralgeneration,3ahv0x,quietthomas,8,Sat Jun 20 09:13:16 2015 UTC,Computers are very good at imitating Lovecraftian horror...
proceduralgeneration,3ahv0x,Industrialbonecraft,1 point,Sat Jun 20 10:51:36 2015 UTC,It's uncanny...
proceduralgeneration,3ahv0x,Odditys,4,Sat Jun 20 17:36:17 2015 UTC,"The original document, for those who care: http://googleresearch.blogspot.com/2015/06/inceptionism-going-deeper-into-neural.html"
proceduralgeneration,3ahv0x,dnew,1 point,Sat Jun 20 20:29:41 2015 UTC,And there you find high-res gallery: https://photos.google.com/share/AF1QipPX0SCl7OzWilt9LnuQliattX4OUCj_8EP65_cTVnBmS1jnYgsGQAieQUc1VQWdgQ?key=aVBxWjhwSzg2RjJWLWRuVFBBZEN1d205bUdEMnhB
proceduralgeneration,3ahv0x,nakilon,2,Mon Jun 22 10:49:34 2015 UTC,"The interesting bit to me, are the pictures like this, where the seed is random noise rather than another picture (like the squirrel).  That's probably the closest you can get to this system ""creating,"" and it is crazy how coherent and pretty the noise pictures are relative to the rest."
proceduralgeneration,3ahv0x,D1zz1,1 point,Sat Jun 20 17:22:58 2015 UTC,It would probably create a more interesting picture if it started with something like perlin noise.
proceduralgeneration,3ahv0x,Felicia_Svilling,1 point,Sat Jun 20 20:12:55 2015 UTC,you know I saw this and thought about it being here but then questioned is this procedural.  It's using neural network algorithms making it a learning computer and that makes it nondeterministic right?
proceduralgeneration,3ahv0x,the_tubes,1 point,Sat Jun 20 20:48:03 2015 UTC,"In the context of procedural generation, people don't mean procedural to mean deterministic, they mean stuff was constructed by algorithmic means (deterministic or nondeterministic) and not directly by humans."
proceduralgeneration,3a5fjo,HolyGarbage,3,Wed Jun 17 11:05:48 2015 UTC,looks awesome man! wt kind of simulation will it be?
proceduralgeneration,3a5fjo,maruwan,1 point,Wed Jun 17 17:46:38 2015 UTC,Thanks! Probably like artificial life/evolution.
proceduralgeneration,3a5fjo,hit_bot,1 point,Wed Jun 17 18:24:23 2015 UTC,How do you plan on doing that?  I've been formulating ideas on that front for about two years and haven't really come up with anything concrete.
proceduralgeneration,3a5fjo,hit_bot,1 point,Wed Jun 17 23:03:38 2015 UTC,"I have already done it several times actually. My most sophisticated finished alife simulation is unfortunately not posted to the website. I'll have to get around doing that. It's essentially 2d organisms with a 1d eye with a set amount of receptors which ray casts it's surroundings. It's then fed into a neutral network which is described by its dna and outputs it's actuators, such as a spike weapon and movement. It also has other sensors such as internal health. I might do something similar, albeit less complex as I'd like to be able to simulate populations in the thousands."
proceduralgeneration,3a5fjo,hit_bot,1 point,Thu Jun 18 11:55:07 2015 UTC,"Interesting, that must be insanely complex to simulate.  I was trying to come up with a similar algorithm to simulate life on a planetary scale--with multiple ""species"" and food sources and whatnot and haven't come up with anything really suitable."
proceduralgeneration,3a5fjo,hit_bot,1 point,Fri Jun 19 01:01:44 2015 UTC,"The proplem with the above example is that it's essentially an n-body problem. Complexity scales as O(n2 ). I think a solution would be to divide the terrain up in ""biomes"", or just straight up some quad-tree. So that organisms on the opposite side of the planet don't even have to think about each other. I've uploaded a short description and pics of the simulation above now if interested: http://robin.astedt.com/Projects/#NeuralNetEvolution"
proceduralgeneration,3a5fjo,Portadiam,1 point,Fri Jun 19 08:07:17 2015 UTC,"One could probably reduce the complexity substantially if, instead of simulating individuals, we considered simulating groups.  Wonder how that might work...  Group by species, sort by genome using some fitness function.  If this is a prey species, randomly ""kill"" some subset, weighted towards the less fit members.  Reduce the area's food supply to simulate ""eating"" (if plant-like in nature, regenerate some to simulate ""growing""). Apply some function for birth rate and do cross-over or whatever to generate new members.  Expand or contract territory as a function of group size (and possibly the genomic space requirement).  Any territories that overlap mean the species interact, either as predator/prey or just competing for food in the overlap area.  Something like that seems like it might be less complex than tracking individuals and would still give the richness of a full simulation--as far as a gamer might be concerned.  The key, obviously, would be coming up with suitable functions for each step--though you may be able to short-circuit some of the evaluation.  For example, in the case of sorting by genome for fitness, you could probably reduce this to ""likelihood of dying due to external forces"" and, as such, only consider speed/agility/constitution in the sorting.  You would obviously also get emergent properties such as extinction events for species whose food didn't regenerate fast enough or for species whose birthrate was too low, etc."
proceduralgeneration,3a5fjo,Wiezy_Krwi,1 point,Fri Jun 19 17:43:31 2015 UTC,What you're proposing would beat the entire purpose of what it is that I am doing. This is purely for my own entertainment.
proceduralgeneration,3a5fjo,NeomerArcana,1 point,Fri Jun 19 18:25:59 2015 UTC,"Oh!  I see, I thought you were doing this for a game of some sort."
proceduralgeneration,3a5fjo,NeomerArcana,1 point,Fri Jun 19 18:30:02 2015 UTC,"Nah, it's more personal academia/way to fill the void of an understimulating job. :-P I get anxious when I am bored so novelty is key."
proceduralgeneration,3a5fjo,NeomerArcana,2,Fri Jun 19 19:51:15 2015 UTC,Just a tip: the font on that page is really hard to read; I recommend changing it to a more standard font. (Also dark text on white background is best for readability)
proceduralgeneration,3a6cye,GerMex12,11,Wed Jun 17 16:06:12 2015 UTC,"metadata and distortion maps might be stored locally or on a centralised server. the bulk of the data is re-generated every time a player visits a planet. each planet will have a seed, a short string of data unique to it's co-ordinates/identity, this seed is expanded by the procedural generation functions to generate the same content.   seed1 --> function = planet1  if a player draws a penis on the landscape with his lasers, those changes may be saved locally. although the universe is infinite, the sum of changes to the default state would be easily manageable."
proceduralgeneration,3a6cye,Random,4,Wed Jun 17 16:15:15 2015 UTC,"Just to add to this...  This idea is called using a pseudorandom key.   It is based on the fact that random number generators will, given the same seed value, proceed to generate numbers that are effectively random compared to each other but are deterministic with respect to the seed."
proceduralgeneration,3a6cye,donwilson,1 point,Thu Jun 18 11:25:40 2015 UTC,I like this guy
proceduralgeneration,3a6cye,JackalHeadGod,1 point,Thu Jun 18 13:42:01 2015 UTC,"That exact reason is why minecraft maps each have their own seed. You can take that random string and seed the engine's random number generator, which all of its internal functions use to generate and display the map. Same seed, same output."
proceduralgeneration,3a6cye,cleroth,1 point,Fri Jun 19 05:24:48 2015 UTC,Minecraft generates the map in fixed sizes chunks (3D cube) and then saves that chunk so it doesn't regenerate that chunk when you revisit it.  That lets them get round changes to the algorithm changing your pre-existing world.  It was a common site in Minecraft patch notes to say that to see new world generation you had to explore out past the furthest point you'd previously visited or start a new map.  If you want to keep it just as seed you also need to version your algorithm and store the version with the seed otherwise you can never change the algorithm.
proceduralgeneration,3a6cye,Arandmoor,2,Thu Jun 25 17:13:24 2015 UTC,Thank you very much!
proceduralgeneration,3a1rzb,magicfap,9,Tue Jun 16 15:41:40 2015 UTC,Wow.  The zooming in/out at the end was really impressive.  No lag that I could detect going from Macro to Micro.
proceduralgeneration,3a1rzb,OnasphereGame,9,Tue Jun 16 16:24:20 2015 UTC,The developer showed how the engine works in layers in this video: https://youtu.be/h-kifCYToAU?t=786 (at the current time).  The video is actually well worth watching in its entirety.
proceduralgeneration,3a1rzb,drake7707,2,Tue Jun 16 19:49:51 2015 UTC,"That's great, thanks for the link!"
proceduralgeneration,3a1rzb,OnasphereGame,2,Tue Jun 16 23:10:05 2015 UTC,"While the scale is amazing, I really prefer quality over quantity. That being said, I'm probably insta-buying this game as soon as it comes out. It looks at least decent enough, but that doesn't mean that it'll provide a fun experience for very long. I'd imagine it could get repetitive really quickly, like vanilla Minecraft. Hopefully there's a lot more to it."
proceduralgeneration,3a1rzb,cleroth,5,Wed Jun 17 04:11:30 2015 UTC,"If nothing else, picking this one up will encourage this developer and others to try new and fantastic things!"
proceduralgeneration,3a1rzb,beta_crater,4,Wed Jun 17 04:50:56 2015 UTC,There was some speculation based on earlier videos that things wouldn't be destructible. Very cool to see that induced in this version . Also in the demo they seemed to imply this would be a shared environment as in I could stumble across a planet that's been discovered before by someone else. MMO? That seems super cool!
proceduralgeneration,3a1rzb,PeteMichaud,3,Tue Jun 16 18:39:39 2015 UTC,"Yes, the info we have so far indicates it's a shared universe. Not really an MMO in the usual sense though, because of the scale. Basically, the galaxy is so mind-bogglingly huge that you're unlikely to ever see anyone else. There are something on the order of a quadrillion stars. I don't remember precisely what the game maker said, but it was something to the effect of: if you were to try to travel to every system in the galaxy, the heat death of the (real life) universe would happen first."
proceduralgeneration,3a1rzb,El3k0n,1 point,Tue Jun 16 19:30:24 2015 UTC,It's 18 quintillion stars.
proceduralgeneration,3a1rzb,eupraxo,1 point,Wed Jun 17 14:45:33 2015 UTC,"No physical interaction between players? Have they talked about what the point of the game is? I love procedural stuff to death, but the biggest problem facing games like that are, well, procedural content generation, for lack of a better idea or term.  I haven't been following this game too closely, so maybe I'm not getting the full picture, but basically from the few videos I've seen it's basically just you, wandering the universe alone, fighting random battles or discovering random planets and sending back data. That's it.  Is there more I'm missing?"
proceduralgeneration,3a1rzb,PeteMichaud,2,Thu Jun 18 06:56:24 2015 UTC,"What you just described is actually a huge part of the game loop -- you explore a lot. Also, you have to find things like raw materials and artifacts to upgrade your ship, suit, and weapons, which allows you to travel toward the center of the galaxy. As you approach the center, enemies get tougher and more numerous, planets get more hostile. They also have higher quality materials to find.   Eventually you make it to the center which is a secret, but whatever is there is the ""endgame,"" has been described as a challenge and a reward."
proceduralgeneration,3a1rzb,crilen,-9,Thu Jun 18 19:10:55 2015 UTC,Game? Simulation.
proceduralgeneration,3a5dqv,locke75,7,Wed Jun 17 10:40:52 2015 UTC,"A beginner, doing an MMO, with a procedural generated world. You know where this is going, right?"
proceduralgeneration,3a5dqv,cleroth,3,Thu Jun 18 14:40:17 2015 UTC,"lol, yea I know its pretty much impossible, but I have a few ideas for some games, and unless I win the lottery anytime soon I am not going to be able to make them.   I guess while I will most certainly fail at this project, I may learn a thing or two, be able to hash out idea in my head, and if I can't do those at least I will get even more appreciation for game developers."
proceduralgeneration,3a5dqv,semperunum,2,Thu Jun 18 18:26:12 2015 UTC,I think that is an excellent attitude for a beginner. Trying very difficult projects will help you learn a lot more than a project at your skill level.
proceduralgeneration,3a5dqv,semperunum,1 point,Sun Jun 21 19:36:21 2015 UTC,"Cheers, So far I have managed to create a procedural generated 2D map, with the climate zones, sea and buildings.  As I started with a very basic knowledge of unity and no c# knowledge, I am really happy with it.     My next step a procedural 3d map. Wish me luck :P"
proceduralgeneration,3a5dqv,jongallant,1 point,Sun Jun 21 20:03:33 2015 UTC,Do you mean 2D + altitude?
proceduralgeneration,3a5dqv,jongallant,1 point,Sun Jun 21 22:02:24 2015 UTC,"No not really,   My plan is to try and create a procedual map around the size of the earth with different climate zones etc.  In my head I am thinking of it like this: Stage 1: Create a procedual 2d tile map of the world Stage 2: Create a procedual 1km 3d map. Stage 3: code the 2d map to populate a database of some kind. Stage 4: for each database entry, generate a 3d level."
proceduralgeneration,3a5dqv,Cifram,2,Mon Jun 22 06:55:56 2015 UTC,Whatever engine you are most comfortable with.
proceduralgeneration,3a5dqv,avanak,-1,Wed Jun 17 11:55:09 2015 UTC,"I am a beginner when it comes this stuff, I have played around with unity and unreal but its only really basic stuff.   I was wondering if there is an engine that stands out more for procedurally generated stuff."
proceduralgeneration,3a5dqv,aisaac0009,1 point,Wed Jun 17 12:17:23 2015 UTC,"Considering you are a beginner, Unity is a great place for you to get started, and heck, even build a career off of.    I'd highly recommend Unity, also since you have had experience with it already."
proceduralgeneration,3a5dqv,graspee,1 point,Wed Jun 17 12:25:17 2015 UTC,"OK thank you, I will give it a go."
proceduralgeneration,3a5dqv,aisaac0009,1 point,Wed Jun 17 12:29:17 2015 UTC,"I've used Unity extensively for procedural generation. It makes it super easy to build polygonal meshes on the fly, which is very important for procedural generation work.  I tried out Unreal a bit... It has a much more powerful editor, is graphically more advanced, and provides full source, which is all great. However, it makes it very awkward to generate meshes on the fly, so I found it ill suited for procedural generation. That said, there are titles out there using it for these purposes, such as No Man's Sky, so it's clearly feasible.  As to the other major engines that I know of, Source and CryTek, I haven't experimented with either, but I've been told they both rely very heavily on pre-baked geometry to achieve their performance and fidelity, which isn't promising for procedural generation."
proceduralgeneration,39zbcr,wayspurrchen,2,Tue Jun 16 00:27:57 2015 UTC,"Hey y'all, I posted this over in /r/glitch_art and someone pointed out that I should share it here, too. I'm hoping to gather a lot of resources on all kinds art creating tools and techniques ranging from glitch to generative / procedural art, and I'd love to feature some of the work here, so you'll probably see me around. :)"
proceduralgeneration,39zbcr,maruwan,2,Tue Jun 16 00:29:50 2015 UTC,cool beans !!
proceduralgeneration,39wph4,edkeens,2,Mon Jun 15 12:35:52 2015 UTC,Here is one without L-Systems:  http://www.jgallant.com/images/tree.gif  Education here:   http://www.jgallant.com/procedurally-generating-trees-with-space-colonization-algorithm-in-xna/
proceduralgeneration,39wph4,jongallant,2,Tue Jun 16 10:21:16 2015 UTC,"Looking great, love the different approach. It would be interesting to see it in 3D and how much variety it can produce."
proceduralgeneration,39wph4,jongallant,1 point,Tue Jun 16 10:48:03 2015 UTC,"This guy wrote a 3D renderer for it:  http://www.sea-of-memes.com/LetsCode26/LetsCode26.html  Which wouldn't be that difficult to do, the algorithm supports the 3rd dimension."
proceduralgeneration,39wph4,jongallant,1 point,Tue Jun 16 10:53:54 2015 UTC,Looks much better than I expected. Thanks for bringing that up!
proceduralgeneration,39wph4,jongallant,1 point,Tue Jun 16 12:49:13 2015 UTC,"Hey, I found a paper on this technique: http://algorithmicbotany.org/papers/colonization.egwnp2007.html"
proceduralgeneration,39wph4,honestduane,1 point,Tue Jun 16 16:31:51 2015 UTC,"Yeah, this is listed in my references, and is also mentioned at the very start of my blog post :P"
proceduralgeneration,39wph4,babyjeans,1 point,Tue Jun 16 17:05:26 2015 UTC,"Ah, sorry for ignorance then :)"
proceduralgeneration,39wph4,honestduane,1 point,Tue Jun 16 17:15:51 2015 UTC,"Hahaha, no problem.  Just letting you know that I did in fact list all my references at the bottom of my article, if you are interested in learning more about it."
proceduralgeneration,39wph4,honestduane,2,Tue Jun 16 17:23:23 2015 UTC,And the code is where?
proceduralgeneration,39szqz,Molachii,1 point,Sun Jun 14 13:59:35 2015 UTC,"I've noticed another issue in that I've had 24 downloads and only 7 complete surveys, if you do the survey you need to use the main menu button to send the survey - exiting the game any other way will not send the data. If you played for science but did not exit the game via the quit button in the main menu please complete it again. Apologies and thank you."
proceduralgeneration,39szqz,Bergasms,2,Sun Jun 14 16:01:13 2015 UTC,Do you support all platforms or just windows? That might explain a lot of people downloading but not completing the survey.
proceduralgeneration,39jti0,pixlab-games,2,Fri Jun 12 05:50:49 2015 UTC,Spherical planets seem like a hard task.
proceduralgeneration,39jti0,Epicshark,2,Fri Jun 12 15:55:34 2015 UTC,"Hey Epicshark, it was quite a tricky one at first but once I got the hang of the algorithm it turned out pretty good. Still need to build the smoothing algorithm though - thanks for the comment!"
proceduralgeneration,39jti0,werejew,1 point,Fri Jun 12 16:08:28 2015 UTC,"Have you done any LOD for this? I've been messing around with spherical terrain in OpenGL and the idea of using six quad trees arranged to the face of a cube eludes me. As of right now I'm mainly just using frustum culling to try to get better performance, and its not quite cutting it haha."
proceduralgeneration,39jti0,werejew,1 point,Wed Jun 17 11:43:00 2015 UTC,"Hey werejew, Haha no I'm with you on that one, I havent done any LOD on this. Atleast not yet, However I will be working towards that in the next version. I tried doing some culling but the effect wasnt all that great. I have quite a powerful machine so I havent experienced any lag or struggle generating the mesh. I will be going for the Qued Tree Approach when I get to doing the LOD. I think that if I cut mesh into those 6 pieces, and then use my new algorithm (which uses 3d Noise) I should be able to get seamless results, and then gain the additional subdivision ability.   LOD is quite a concept, and the application is quite tricky to grasp. haha, I will keep you posted on how my implementation goes. I would like to see your work, so dont hesitate sharing it!  Thanks for dropping the comment, Great to get stuck in a conversation. Sorry about the long post"
proceduralgeneration,39jti0,OnasphereGame,1 point,Wed Jun 17 11:59:22 2015 UTC,"Hah, yeah. I considered at one point simply mapping the camera xz yz xy 2d vectors to different quadtrees to represent the axes, but I feel as if that is an extremely naive approach to this. One idea I had was to return from spherized coordinates back to cubic coordinates, some poking around led me here. I feel as if that would work relatively well, would just have to let the quadtrees be aware of their neighboring quadtrees which shouldn't be TOO bad.  And I don't have too much stuff going on with my ""game"" currently, I've been primarily researching and trying to get planetary terrain to work efficiently (it does run pretty well, averaging around 200fps on an AMD A8-4500M APU). Here's a little video; it's going to be a 2.5D game where movement is constrained to two axes and you'll be able to rotate your character to move on a different axis at intersection points. It affords me some other optimizations I didn't mention above, simply because you won't see very much of the sphere at a time (short of a seamless transition from space to planet). The deferred lighting in the video is a bit jittery, was due to how I was reconstructing a pixels worldspace position from the depth buffer.  And no worries, clearly I'm no stranger to long posts myself haha.  Edit - Here's a slightly better video for actually seeing the terrain. Terrain seams are due to me not averaging any surface normals. I'm lazy :P Haven't done too much with actual interesting features in the terrain. I'm currently using one sample of perlin noise, will be switching to simplex here shortly as well as using more than one sample at differing frequencies."
proceduralgeneration,39jti0,OnasphereGame,1 point,Wed Jun 17 12:26:20 2015 UTC,"Yea I think as far as efficient LOD is concerned the quad tree would be best for speed and detail, however from what I have seen in your videos the culling might work best, as you see only a part of the surface once on it - I don't know how you would do the transitions though.. haha and again LOD catches us... I liked the video and subscribed to the channel, will be watching haha   I recently switched from Perlin to Simplex, and I must say the simplex generates much smoother, and because it's generated in 3d space you can really place the heights properly, I struggled a bit with the spherical implementation of perlin - here's a link to a picture of the new planet with simplex http://pixlab-games.tumblr.com/image/121467074622   Your concept sounds pretty cool and looks quite nice - will be keeping myself updated, be sure to also let me know as it goes. Nice to compare problems with other developers!"
proceduralgeneration,39jti0,OnasphereGame,1 point,Wed Jun 17 14:48:06 2015 UTC,Nice work!  Have you tried making mountains with more peaks?  The flat top looks cool but it's not very earth-like.  What about a higher tessellation value to make things smoother?
proceduralgeneration,39jti0,OnasphereGame,1 point,Fri Jun 12 16:09:32 2015 UTC,"Thanks OnasphereGame - I am working on an algorithm to smooth out the mountains, and I'm hoping to incorporate some bump mapping for ridges etc. I did try a higher tesselation, but my algorithm was too unstable to deal with more verts. Will be fixing that aswell, thanks a lot for the support and comment!"
proceduralgeneration,39jti0,Bergasms,1 point,Fri Jun 12 16:18:28 2015 UTC,What instability were you seeing?  I'm also making a planet generation game so we've probably got a lot of the same issues. ;)
proceduralgeneration,39jti0,Bergasms,1 point,Fri Jun 12 17:08:07 2015 UTC,"Well, mainly my algorithm couldnt deal with high level of vertices, it seems to really slow down the generation process, and seeing as I want to have it all live in gameplay, it just wasn't acceptable.   Right now I'm calculating the noise of the mesh based on the vertices inside the mesh. However I think I'm going to try a secondary algorithm, which will use texture mapping to generate a heightmap. This, in theory would create smooth hills, and probably allow me to handle more calculations per frame.  Thats great, great to know there are fellow planet generators out there! Keep me posted on your development?"
proceduralgeneration,392zk4,noble_radon,3,Mon Jun 8 21:52:18 2015 UTC,This is my first real attempt at procedural generation.  I like to write code in my spare time just to learn things.  I did this to learn noise generation.  It's a midpoint random displacement algorithm and an array of predetermined colors is used for the visuals.
proceduralgeneration,392zk4,wolscott,3,Mon Jun 8 21:59:36 2015 UTC,"I love your results, but I don't understand your description of how it works. I am new to procedural generation, but I have a pretty good grasp of the general concepts involved (math and cs student). Could you describe the algorithm a bit more?"
proceduralgeneration,392zk4,Tomacho,2,Tue Jun 9 19:47:31 2015 UTC,"I'm new to it as well.  Here's the page I worked from to figure it out http://www.gameprogrammer.com/fractal.html  Basically it works like this:   Take a square and generate a random value for each of the 4 corners Bisect the square and the midpoint falls between the 4 previous points.  Make that midpoint the average of the 4 corners +/- some variance. this leaves the midpoint of each wall of the square left without values.  They sit at the midpoint of diamond shapes (triangles on your first iteration).  Make them the average of the 4 diamond corners around them. Repeat steps 2 and 3, halving the size of your squares each time, so that the 9 points you've generated so far, become like 4 little squares.  As you iterate shrink your random variance to guarantee that the center points fall closer and closer to true average values and make smooth transitions.   In my implementation, the only real difference is that instead of starting with 1 square, i start with X * Y squares stitched together for step 1."
proceduralgeneration,391cnz,shorefire,3,Mon Jun 8 15:15:00 2015 UTC,"Video here,  The lag spikes are due to really crappy chunk loading, only spent 5 minutes implementing it.  Edit; Spend the last 4 hours fixing up chunk loading, 2fast4u https://youtu.be/9c1o0CdxN70"
proceduralgeneration,391cnz,VicareyG,3,Mon Jun 8 15:16:14 2015 UTC,"You might be interested in /r/VoxelGameDev! Looks cool it just has the appearance of being very flat, almost like an optical illusion."
proceduralgeneration,391cnz,the_tubes,2,Mon Jun 8 20:15:36 2015 UTC,"Yeah, I'm still playing around with the generation, I'm adding a bit more depth to it currently, and then I'll look into adding some water/greenery :)"
proceduralgeneration,391cnz,crilen,1 point,Mon Jun 8 21:18:59 2015 UTC,perlin noise?
proceduralgeneration,391cnz,tehcyx,4,Mon Jun 8 19:46:45 2015 UTC,"libnoise, so whatever that uses :p"
proceduralgeneration,391cnz,tehcyx,5,Mon Jun 8 19:47:27 2015 UTC,"libnoise can generate Perlin noise, ridged multifractal noise, and other types of coherent-noise."
proceduralgeneration,391cnz,tehcyx,1 point,Mon Jun 8 20:34:33 2015 UTC,Looks pretty cool. How long did it take you?
proceduralgeneration,391cnz,tehcyx,1 point,Fri Jun 12 05:53:32 2015 UTC,"Roughly 3 days, it probably shouldn't take that long for someone experienced in 3d, but this was my first 3d project so I was learning the basics at the same time :p"
proceduralgeneration,38brpe,jak6jak1,6,Wed Jun 3 04:54:41 2015 UTC,how did you generate them?
proceduralgeneration,38brpe,atomic2354,17,Wed Jun 3 06:30:28 2015 UTC,Unintentionally.
proceduralgeneration,38brpe,cleroth,1 point,Wed Jun 3 14:03:12 2015 UTC,It's just multiplied perlin noise
proceduralgeneration,38brpe,KdotJPG,1 point,Thu Jun 4 17:44:17 2015 UTC,"Excuse me sir, but do you have a moment to talk about our lord and savior OpenSimplex?  I would recommend taking a look at Simplex and OpenSimplex noise instead. They tend to produce less directionally-aligned patterns. Perlin noise is what you hear about a lot, and it can certainly be used interchangeably with its alternatives to produce some neat effects (your mountains already look cool), but it's not really that good outside of specific cases, compared to its alternatives."
proceduralgeneration,38bvds,Zivodor,6,Wed Jun 3 05:27:56 2015 UTC,"When's it's summer in the northern hemisphere, it'll be winter in the southern one. Your pics show a net loss of temperature across the entire map, which is really weird. Here's an animation of world temperature throughout the year."
proceduralgeneration,38bvds,cleroth,3,Mon Jun 8 15:43:31 2015 UTC,"Can you give more information on how you calculate the wind and rain, or a good run down of how each is step made and how they build together? I've been trying to add decent weather, erosion and rivers to my world builder for a little while now"
proceduralgeneration,38bvds,lexwhitfield,5,Wed Jun 3 06:01:58 2015 UTC,So first I set a line across the map at the following altitude with the following wind directions.    Altitude Direction    0 South   180 North   360 East   540 West   720 East   900 South   1079 North    I interpolated the wind direction between each latitude and then normalized the values to be in 45 degree increments. Next I generated a simplex noise map and sampled the now gradient wind map at each each x and y coordinate with an offset of the simplex noise value at that x and y coordinate so that the gradient becomes all snake-y but still still has distinct bands.   For the moisture I just started at each land tile and moved in the opposite direction of the wind until I reached a sea tile or a mountain tile and set the moisture value to be proportional to the number of steps it took.    This and this website we're pretty helpful for generating the wind and moisture maps.  I haven't done any rivers or lakes yet because I am going to use the moisture map to place them properly and I just finished that stage a few hours ago.
proceduralgeneration,38bvds,lexwhitfield,2,Wed Jun 3 06:29:34 2015 UTC,"awesome! exactly what i was looking for, thanks"
proceduralgeneration,38bvds,ISvengali,2,Wed Jun 3 07:56:58 2015 UTC,"Glorious, a nice simple pragmatic wind map, though I still have some hope that building a simple climate model will be cool.    This gives me some impetus to work on my world generator."
proceduralgeneration,38bvds,HolyGarbage,1 point,Thu Jun 4 00:05:49 2015 UTC,"Hi, what is the benefit/purpose of the fact that you have it in 45 degree increments rather than continuous?"
proceduralgeneration,38bvds,HolyGarbage,1 point,Tue Jun 9 11:37:13 2015 UTC,"Because it's a grid so there are eight tiles that it can go do ie: 0,45,90,135,180,225,270,315 which correspond to the eight tiles around the one I am interrogating."
proceduralgeneration,38bvds,HolyGarbage,1 point,Tue Jun 9 17:33:25 2015 UTC,Couldn't you just go any arbitrary direction with the use of cosine/sine?
proceduralgeneration,38bvds,HolyGarbage,1 point,Tue Jun 9 22:37:56 2015 UTC,I'm sorry I don't follow.
proceduralgeneration,3895ae,Tabski,5,Tue Jun 2 18:35:00 2015 UTC,"I don't know if I'd call that a city, but it's definitely interesting."
proceduralgeneration,3895ae,shawnaroo,4,Tue Jun 2 20:25:33 2015 UTC,"The procedural generation looks good, but I would encourage you add more contrast or lighting.  I realize this is a work in progress, but it's difficult to see what's going on.  The geometry looks fun to explore."
proceduralgeneration,3895ae,xaxisofevil,3,Wed Jun 3 16:05:40 2015 UTC,"Thanks for the feedback. Contrast and lighting are a bit tough considering I am working with a bunch of the same type of objects, but I tried a few things out. First I tinted the layers so they could be distinguished from a color perspective, then I used the depth of the vertexes to have further hexagons appear darker. Here's what it looks like now: http://i.imgur.com/5MdQzSf.jpg  Also some bonus pictures of some hilarious mistakes I made while trying to get the shader to work: http://i.imgur.com/7gpwezs.png and http://i.imgur.com/opDxEgY.png.  EDIT: I guess I should also note that all the screenshots were taken without shadows on. When they are on it looks a bit better too: http://i.imgur.com/mVeJk80.jpg (sorry for the potato quality screenshot)"
proceduralgeneration,3895ae,soundofvictory,2,Wed Jun 3 19:46:20 2015 UTC,"Huh.  I've never seen something like this before.  It's very neat.  What did you build it in/with? (ninja edit: Now i notice the unity origin/orientation thingy).  Is the geometry procedural, or are they pre-made and placed?"
proceduralgeneration,3895ae,dieDoktor,4,Tue Jun 2 21:27:28 2015 UTC,"Glad you like it. I can't say it's super unique as the system I use for generation is nearly identical to this one from minecraft that has popped up on this subreddit before, I just adapted it for hexagons.  As for the geometry it starts with a premade ""hut"" object and deletes pieces of it depending on how it's surrounded (are there more huts around it, are there stairs going up to it, etc.). This picture here shows the different pieces it starts with (and it can delete the frames or doors in any direction)."
proceduralgeneration,3895ae,dnew,2,Tue Jun 2 23:32:56 2015 UTC,"Thats pretty cool. Still, I would not want to live in that city"
proceduralgeneration,3895ae,liquidben,2,Tue Jun 2 22:24:15 2015 UTC,"I like that. Looks cool. A bit dark, color-wise.   If you moved the vertecies around a bit, got rid of the stone edges between cells that don't have a change across the boundary, it would probably look even cooler.  I could imagine something like that growing to turn into a city-builder that could build places like Arcos de Frontera or other Spanish ""white towns"". Entire towns where pretty much every street looks something like this: https://s3.amazonaws.com/darren/Spain2010/Arcos+de+la+Frontera/17-14-02-26Ba.jpg"
proceduralgeneration,382hu1,RiskyTrizkit,6,Mon Jun 1 11:28:00 2015 UTC,Nice! Which tutorials did you find helpful?
proceduralgeneration,382hu1,Pasty_Swag,5,Mon Jun 1 16:21:08 2015 UTC,Very nice!  (Were you expecting something different?)
proceduralgeneration,382hu1,danielpferreira,5,Mon Jun 1 11:51:40 2015 UTC,"Truth be told I did take a couple extra steps in addition to the generative art itself, but most of it was algorithmic.   I made a mask out of one iteration in photoshop and placed another iteration inside that mask, (heres what that looks like)then turned the whole thing into a low ppi bitmap. I thought that made some cool imagery."
proceduralgeneration,382hu1,octalpus,3,Mon Jun 1 12:12:40 2015 UTC,I like this one better.
proceduralgeneration,382hu1,crilen,2,Mon Jun 1 12:18:17 2015 UTC,"I saved it as an alternate, I like it too."
proceduralgeneration,382hu1,crilen,-1,Mon Jun 1 12:22:21 2015 UTC,Why are you using gif for non-animated images?
proceduralgeneration,382hu1,crilen,3,Mon Jun 1 18:42:20 2015 UTC,JPG would create unwanted compression artifacts and pixels that weren't binary. BMP/TIF would be too big a filesize. PNGs killed my father. Is it a concern?
proceduralgeneration,382hu1,Portadiam,1 point,Mon Jun 1 23:39:30 2015 UTC,"I use gfycat to convert links by default, which errored on your image."
proceduralgeneration,37x0hr,frozen_pie_taster,3,Sun May 31 02:41:11 2015 UTC,"Just spitballing here, but here's how I'd do it:   Use some algorithm to fill your maze with closed loops. I don't know of any such algorithms off the top of my head, but I doubt it would be too hard to find one. Choose entrance and exit spaces however you might want to. Pick a path of contiguous loops that will connect your entrance and exit, and join the loops together. You now have your unique solution. Mark all of those loops as 'done'. While there are loops that aren't done, pick a random loop that's not done and...   Connect it to a random adjacent loop. If the loop you connect it to is done, this loop is done now as well. (This ensures that you won't ever accidentally connect twice to the solution track, making a second viable solution) Otherwise, combine these loops in your list of loops as a single loop. (e.g. if you connect loop A and loop B, you remove the references to A and B and you now have a single loop A+B)    So now we end up with a maze filled with loops, with exactly one solution, but which remains well-connected so you can get to anywhere from anywhere."
proceduralgeneration,37x0hr,Asmor,1 point,Sun May 31 05:11:22 2015 UTC,This sounds very good thank you. Keep in mind it doesn't have to look like the one in my photo with closed off loop blocks that are joined together but this sounds like a great idea.
proceduralgeneration,37x0hr,Felicia_Svilling,2,Sun May 31 14:30:39 2015 UTC,One simple method would be to generate a normal maze and replace every dead end with a loop.
proceduralgeneration,37x0hr,Felicia_Svilling,1 point,Sun May 31 10:22:19 2015 UTC,"I tried that the problem is they come out way too easy. The one I posted is a nice challening one but simply ""connecting all the dead ends"" afterwards leaves you with something like this: https://www.youtube.com/watch?v=X6JNaQeGHng  You can see how he adds the loops afterwards and how you can take almost a perfect diagonal"
proceduralgeneration,37x0hr,datta_sid,3,Sun May 31 14:27:23 2015 UTC,"Actually that is not what I meant. I meant that you like if you have grid you can replace every square with say nine smaller squares, and in the dead ends you can make them loop. Something like this:  http://imgur.com/n4ztWVX"
proceduralgeneration,37x0hr,TaohRihze,1 point,Sun May 31 21:10:05 2015 UTC,"Ah, now I see what you mean. This is a very nice approach actually and seems similar to /u/TaohRihze's solution. Thanks!"
proceduralgeneration,37x0hr,TaohRihze,2,Mon Jun 1 00:15:28 2015 UTC,"Apart from what Felicia suggested, may I suggest an alternative?  The problem in joining any dead end to a random neighboring square, is that some of them will connect to the existing solution and may provide a ""shortcut"" solution shorter/simpler than the original solution.  I suggest joining dead ends to any neighboring square, as long as that neighbor is not part of the original solution. If all 3 neighbors of a dead end are part of the solution, then  a. Remove this square as part of the maze. Move to the connected neighbor, which is (probably) now a dead end, and try to connect it to something.  b. In case all squares must be part of the maze, throw away the current maze and start over. You might be able to modify your normal maze generation so that solution does not have any U shapes that may harbor lone dead ends, but that sounds hard to me."
proceduralgeneration,37x0hr,TaohRihze,1 point,Tue Jun 2 19:45:30 2015 UTC,This actually sounds like it would generate the hardest mazes since you only have one path and any deviation will just leave you in endless loops. Definitely gonna try this one thanks
proceduralgeneration,37x0hr,TaohRihze,2,Tue Jun 2 20:12:57 2015 UTC,"Looking at the supplied example, it strikes me, if you take a normal maze and add a wall in all paths leading to a dead end, you will have a braided maze no simpler than before, now you will need to figure out how the braiding at intersections should be handled, but regardless if you leave it open or let them intersect it will not change if the maze is solveable or not, just how many detours are required (bit like left hand on the maze wall is unchanged with this approach regardless of additional shortcuts you allow by not fully closing an intersection).  So my suggestion would be:  1) Generate a normal maze 2) Add a wall in the middle of all paths, except if it would touch a dead end, allow a path around there. (and mark that wall type a different type than the normal maze wall) 3) Remove parts of the new wall at intersections or other spots to allow additional travel, the amount of selected spots decide difficulty, at worst case (nothing removed) you have a put a left hand on the wall and follow it situation."
proceduralgeneration,37x0hr,zarawesome,1 point,Sun May 31 14:42:06 2015 UTC,I don't quite follow what you are saying. What do you mean by add a wall in the middle of all paths and which new walls do you remove?
proceduralgeneration,37x0hr,Plazmatic,2,Sun May 31 14:56:09 2015 UTC,Here is a simplified example with the 3 steps.  http://oi57.tinypic.com/fp44k7.jpg
proceduralgeneration,37x0hr,Plazmatic,1 point,Sun May 31 15:24:01 2015 UTC,"Looking at the solution, the step 2) and possible 3) can be repeated multiple times if you wish to create a further complex set of braids. My initial guess would be to mix the amount of extra doors opened in 3 depending on the iteration you are on, but no clue if you should increase or shrink the doors to generate interesting ones.  My initial guess would be to reduce the amount at each step would provide the most confusion."
proceduralgeneration,37x0hr,Plazmatic,1 point,Sun May 31 15:32:00 2015 UTC,Wow this is actually a very good idea. Thanks!
proceduralgeneration,37ulnf,clockworkmischief,3,Sat May 30 15:05:50 2015 UTC,I would create them with a space colonization algorithm. http://algorithmicbotany.org/papers/colonization.egwnp2007.pdf  Roughly something like this:  Create a poisson distribution with radius r0 Put the points in a structure like a quadtree. Pick a starting point p(0). Loop_start: Query the quadtree to get all points within a radius r1 of point p(n) Remove all returned points within a radius smaller than r2<r1 from quadtree. Use all points within this radius to create a direction vector. Step from p(n) to p(n+1) along this direction. Add some new random starting point on the formed path during the loop to create branching Loop_end:    Tweaked some parameters on some code I played with before got something looking like this. Not there but close.  Imgur
proceduralgeneration,37ulnf,obidobi,2,Sun May 31 04:37:23 2015 UTC,Nice but I was left with a feeling that I had been on a tour that exited through the gift shop.
proceduralgeneration,37ulnf,graspee,2,Sun May 31 03:06:39 2015 UTC,I did some procedural generation of Lichtenberg figures a while ago in Javascript/WebGL:  [demo]  [github]  I've been meaning to go back and do it in 3D.
proceduralgeneration,37sek3,vigridzki,6,Sat May 30 00:32:20 2015 UTC,"This kind of procedural modeling is already being used in the industry today. Sidefx Houdini is probably the best known software package for this, and there are also more targeted solutions like SpeedTree for vegetation specifically.  Tho I'm certainly biased, I honestly believe this is on the verge of becoming a HUGE part of the industry, not only because of the success of indie titles and the skyrocketing AAA budgets, but also because it opens up a world of possibilities.  Our fellow user /u/Wagnerius is working on an awesome implementation of this, and he has plans for Unity integration.  (shameless plug!) I myself have my own pet project in this area, although in early stages and my node graph interface is not implemented yet.  This approach is super powerful because the assets you create can be parameterised, so the level designer (or a random procedural generation/genetic algorithm/AI) can for example reuse a single procedural ""Table"" asset a hundred times, and have each one of them with different shapes, heights, number and orientation of legs etc. Compare this to the classic workflow of having your artists painstakingly creating dozens of individual tables, or simply copy-pasting the same table throughout your game.  Combine these with procedural textures like the ones produced by by the awesome Substance Designer and with a very small team, you can produce varied yet very high quality content much faster and cheaper."
proceduralgeneration,37sek3,rev087,5,Sat May 30 02:13:06 2015 UTC,"( First time, I am mentioned in a comment, I am flattered)  I couldn't have said better. It seems indeed that procgen have reached some kind of maturity. And a lot of wonderful projects are popping up everywhere (like /u/rev087's or noise modeler from /u/bobbaluba). good times !  I'll just add Substance Painter to the list, which use the same tech as Designer in another wonderful way. And the old but so good worldmachine.   Ps : the link on my implementation is wrong : here it is."
proceduralgeneration,37sek3,Wagnerius,1 point,Sat May 30 07:11:01 2015 UTC,"Woops, fixed!"
proceduralgeneration,37sek3,rev087,2,Sat May 30 13:07:19 2015 UTC,"This reminds me of openscad a little bit.  I'm generally not a big fan of the kind of graphical user interface where you have lots of little boxes with text in them connected by lines in a graph.  It's one of those things that feels fine for small things, but when it gets larger, it gets to be a pain, and a plain text format representation might be a better fit.  It looks like there might be a plain text representation underneath all this though, which is cool, as one way of doing procedural generation with tools like this, and openscad, is to write a program that outputs this text representation -- metaprogramming the tool.   I've done this type of thing a little bit with openscad before to produce things like castles and spaceships."
proceduralgeneration,37sek3,smcameron,1 point,Sat May 30 14:57:11 2015 UTC,"As a programmer, my problem with OpenSCAD is I couldn't figure out the syntax and get it to actually output things. Terrible first experience!  With antimony, every node is a small Python script. So you're half-right: Each node has an underlying text representation (code), but the model as a whole does not."
proceduralgeneration,37odwq,rpgGameDev,23,Fri May 29 03:13:42 2015 UTC,"With games it would be awesome! You could have the dynamics, tempo, mood, etc. of the music adjust to what's going on currently.  It could be like having your real-time orchestrator."
proceduralgeneration,37odwq,evglabs,3,Fri May 29 03:37:10 2015 UTC,"It could even open up entire new mechanics, though they're likely to be gimmicky outside of a literal simulation (e.g. Conductor Simulator in the style of Surgeon Simulator but with a baton)."
proceduralgeneration,37odwq,ZeroNihilist,20,Fri May 29 17:34:58 2015 UTC,"One day a new generation might ask: ""You listened to the same music again and again? It never changed? What's the point?"""
proceduralgeneration,37odwq,nonsensicalization,6,Fri May 29 03:48:09 2015 UTC,"""Oh man, you have to listen to this new algorithm by Perlin Noise..."""
proceduralgeneration,37odwq,ZeroNihilist,11,Fri May 29 17:35:39 2015 UTC,"What is the value in human generated music? I don't think the value is different in any sense. If you watch someone programming an algorithm for procedural music, you'll see the process is very similar to a composer composing a piece on piano. Lots of trial, error, and biased selection.  There is no rule that says ""you can only compose one note / chord at a time and scribble your one particular selection to a piece of paper for it to be valuable music"" is there? I can't see how procedural music composition is any different than older methods at all.  I can see how it feels different, but I can't see how it is different."
proceduralgeneration,37odwq,earslap,5,Fri May 29 12:21:01 2015 UTC,Finding out how reality works is interesting. Knowing good recipes for procedural music could also lead to significant insights regarding (human) consciousness.
proceduralgeneration,37odwq,king_of_the_universe,3,Fri May 29 13:18:52 2015 UTC,"For me personally, I enjoy listening through my algorithms looking for inspiration for music composition.  I also like the idea of games and interactive demos that generate compositions that almost simulate improvisation, given some direction.  For instance, maybe I provide some piano lead and ""The Band"" ie: computer software, starts playing with me. That would be amazing!"
proceduralgeneration,37odwq,darkwingdame,6,Fri May 29 03:27:50 2015 UTC,Or it could turn out like this.
proceduralgeneration,37odwq,LordoftheSynth,6,Fri May 29 03:35:58 2015 UTC,That was so beautifully unexpected
proceduralgeneration,37odwq,magicfap,3,Fri May 29 04:40:57 2015 UTC,"it can save a lot of space for a game. Not as much as procedurally generated speech maybe, but thats a whole different ballgame."
proceduralgeneration,37odwq,sound_puppy,2,Fri May 29 18:23:29 2015 UTC,"Good procedurally generated music is good. All else is awful.  I think we're at a point where PG can make for great riffing within a framework that is more explicitly designed by a person. Frankly, the vast majority of what passes for pop music is mostly procedurally generated, there's just a producer guiding the process and applying effects and transitions to give it some flavor.  Brian Eno developed a concept of Generative Music (http://en.wikipedia.org/wiki/Generative_music) and had worked with some developers to create software around it. It's interesting work, but it hasn't had quite the impact I think people expected.  I've done some limited work with using computer systems to perform live music, stuff like ChucK (http://chuck.cs.princeton.edu/) or digital drum machine programs of my own design. There's a lot to be said for the concept that it's just another instrument.  So what's the reason for the research? Why not? It's fun. It helps us understand the world around us. If you can write an algorithm that replicates a certain component of music, then you're probably very close to understanding why the music works. That doesn't mean you're trying to kill music or musicians, just peal back the covers and see how it all ticks."
proceduralgeneration,37odwq,moron4hire,1 point,Fri May 29 14:10:48 2015 UTC,"IMO, it matters what you mean by ""procedurally generated music"" in this case, because there are several levels you could go to.  If you're talking about stem-to-stern procedural generation of music, then I think that's going to be an extremely rocky road. On top of which, you risk losing something in your game from a certain perspective.  I mean, music is art in one of it's most basic forms. The poorest man in the world, can still make music. Take his hands. Take all his worldly possessions. Lock him away and take away even sticks and stones so that he has nothing to bang together, and he can still sing.  Take his tongue, and he can still hum.  There is something intrinsically human about music.  Now, that's just my personal opinion.  OTOH (also my opinion) there is a lot of work that could be done to better score a game. If you look at a movie, the music is cut in such a way to follow the action of the film.  Games can learn a lot from filmic scoring. IMO, the best way for games to spend their time, where music and PGC is concerned, is to work on procedurally scoring a game based on the player's actions.  Some games have tried to do this with varying levels of success. IMO, nobody has taken anything too far yet. Their attempts have, for the most part, been limited to fading pieces in and out based on zone triggers and the occasional game-state.  I'm waiting for, and a bit interested in (I was a music major in college for a bit), procedural scoring from the perspective of a game having a full score to work with (composed by a human with procedural scoring in mind), and then both proactively and pre-actively cutting the music to fit the action based on both player action and AI.  Have the action drive the score down to it's composition with no two play-through hearing the exact same score.  I think there's a lot of value to be had here, both from the software engineering side, and the music composition side."
proceduralgeneration,37odwq,Arandmoor,-4,Fri May 29 20:26:06 2015 UTC,"Because logical thinkers generally aren't good artists (3D Modelling, Digital Art, Traditional Art, Music etc), thus they create a program/library that creates the art for them.  It enables programmers to create an entire game on their own.  Additionally, those (Game developers, film producers, stage producers etc (Anyone who needs music for a project)) that don't have the skills to create such software and can't afford to hire musicians can get affordable music (The only cost being the software license fee (Though there maybe be royalties, even then though, the royalties would be less than conventional/traditional music)).  There's also the fact that, for small teams, or one-man-armies (single person projects), by using software to produce music it means that it is 'their own', something they created. Thus the final product will be more 'their own work'. (Sorry if I'm not phrasing this well, but I mean that music they created through the software is a product of their own efforts (tweaking parameters, notes, time line etc) and thus as a whole they can say the final product is something they made without relying on others)  Aside from that like with any form of procedural content, it enables the developer to deliver unique experiences with every playthrough/viewing (Game, film, etc etc). For example a game in which the player visits procedurally generated worlds, could have unique music for each of those worlds.  Also music is a huge part of human culture, everybody loves it. So software that allows more people to be a part of it/make their own/play with it, is something I'm sure many would be interested in. The Vocaloid software is a prime example (See the countless works put on NicoNico and Youtube), shame it's not procedural though (More so the vaguely robotic tone is unfortunate, hopefully in future we'll have true 'virtual singers').  EDIT: Ah and before I forget, one final point; people do it, because they can. Of coarse motivations vary (research, challenging oneself, for profit etc), but if it can be done someone will do it.  EDIT2: Altered first sentence to avoid unnecessary confusion and in hope of preventing further discussion deviating from the topic of this thread."
proceduralgeneration,37odwq,Dead_Sparrow,5,Fri May 29 03:45:14 2015 UTC,http://m.livescience.com/39373-left-brain-right-brain-myth.html
proceduralgeneration,37odwq,rush68,5,Fri May 29 11:26:41 2015 UTC,"Because logical/left-brain thinkers generally aren't good artists (3D Modelling, Digital Art, Traditional Art, Music etc), thus they create a program/library that creates the art for them.   No idea what part of the brain is responsible for spouting pseudo-science but it seems very well developed in your case."
proceduralgeneration,37odwq,Emnight,4,Fri May 29 11:19:20 2015 UTC,"Ok... though that has no relevance to rpgGameDev questions nor my response.  But I'm sorry that my remark seems to have offended you and others. To clarify I was purely referring to the fact that programmers, who are generally logical thinkers, tend not to excel at art. At least that is the case for myself. Additionally, personally I've always used left-brain thinker as a synonym for a logical thinker, without making any reference to the pseudo-science. As I believed that was how the term had been accepted in society at large. It seems however, I was mistaken and so I will endeavour not to do so again to avoid unnecessary confusion."
proceduralgeneration,37odwq,Dead_Sparrow,4,Fri May 29 12:03:34 2015 UTC,"programmers, who are generally logical thinkers, tend not to excel at art   I disagree, there's is a huge amount of creativity in programming. Just as a structural engineer can create something artistically beautiful, so can a programmer.  Also, you might want to rethink your whole left-brain/right-brain philosophy as the nature in which you describe it is widely regarded as a complete myth:   Despite what you've been told, you aren't 'left-brained' or 'right-brained' Neuromyth 6: The left brain/ right brain myth Left Brain – Right Brain Myth"
proceduralgeneration,37odwq,Fucking_Montezuma,3,Fri May 29 13:11:42 2015 UTC,"Does that really warrant the large amount of downvotes though? His point still kind of stands. People that program generally aren't good artists (by artists I mean music/game art). However, in this sub it's highly likely that there's a higher number of programmers that are artists. Either way, the downvote button is not for disagreement, it's for comments that don't contribute to the discussion. And he's certainly contributed.    Anyway, thanks for the myth links. I didn't know that. However, I've always thought it really weird how our brains supposedly used one side more than the others, considering we keep being told how malleable it is. It makes sense now."
proceduralgeneration,37odwq,cleroth,2,Fri May 29 21:53:54 2015 UTC,"Does that really warrant the large amount of downvotes though?    Probably not, none of them were mine."
proceduralgeneration,37odwq,Fucking_Montezuma,1 point,Sat May 30 08:24:25 2015 UTC,"Because logical/left-brain thinkers generally aren't good artists...   Heresy!  Burn this man at the stake!  Let the procedurally generated flames burn!  Anyhow, since we're digging our graves, I'll add this: good music breaks the rules and defies our expectations... totally PG music is like saying ""Let's procedurally generate a narrative.""  It reeks of ignorance of the subject matter, and likely a dash of hubris.  (Though I suppose that those two qualities are attributable to most writers and musicians these days, anyhow.  Hmm.)  Point is, you're not going to PG the next Strawberry Fields or even something mediocre, dynamic flares certainly aren't exclusive to PG, and I don't see how you'd ever need a volume of music so large that a talentless human couldn't create it and do a better job, so... what's the application?"
proceduralgeneration,37kwoh,labouts,3,Thu May 28 11:19:06 2015 UTC,"This is a article with information and examples that I wish I had seen when I first starting learning to use procedural generation techniques a couple years ago. It covers the main points of producing a tile map with Simplex noise including the use of ""noise layers"", images demonstrating the effects of changing various noise parameters and an Android Studio project designed for easy experimentation.  It won't be useful to people well versed in generation techniques, but I hope some beginners will benefit.  Example Image  Example Video"
proceduralgeneration,37kwoh,Pasty_Swag,2,Thu May 28 11:23:17 2015 UTC,"Omg, I never knew that website existed. Thank you so much."
proceduralgeneration,37kwoh,Arandmoor,1 point,Thu May 28 17:38:08 2015 UTC,"Holy shit, this was obscenely useful. I got it working in libgdx in roughly two hours, most of which was spent figuring out how in god's name libgdx worked (since I have never used it before).  So, question: How much memory does the Joise object take up? I don't use Java that much and it doesn't have a sizeof function. Is it based on the min/max values? Like, would a joise object with a min/max of -100/100 take up more memory than one that goes from 0 to 100? Or are they the same size?  I've been trying to figure out how perlin/simplex/opensimplex noise works, but it's not going very well :("
proceduralgeneration,37k688,Zivodor,3,Thu May 28 05:45:45 2015 UTC,"Basically, you want your noise map to offset your gradient map. For example, where you'd look up [x,y] for your gradient map, you should look up [x+noiseAt[x,y],y+noiseAt[x,y]]. Using two different noises for X and Y is slower, but gives nicer results (using the same for both gives a ""smudged to the lower-right"" feel, which might not be too apparent if your noise offset is very heavy). You can also modulate how much you want that offset to be expressed by multiplying the intensity of that noise."
proceduralgeneration,37k688,Orteil,2,Thu May 28 08:19:39 2015 UTC,"https://imgur.com/EjB1Y0I this is the result I am getting when I do what you say, am I doing it wrong? Are the settings for my noise generation off? The higher the octave the more blob-y it looks and higher persistence does much the same and higher lancuracy just sort of smudges everything to the bottom right corner.   Edit 1* I am dumb and had a dumb piece of dumb code being dumb and now that code isn't dumb and it works great. Thanks!"
proceduralgeneration,37k688,rev087,1 point,Thu May 28 08:52:57 2015 UTC,I think it's safe to bet everyone in this sub has placed his/her Xs and Ys in the wrong place on ocasion :p
proceduralgeneration,37k688,liquidivy,1 point,Thu May 28 12:06:54 2015 UTC,"Oh yes. Or copy-pasted ""x"" code without changing it to ""y""."
proceduralgeneration,37k688,smcameron,1 point,Fri May 29 01:46:09 2015 UTC,Any tips for what octave/persistence/lancuracy to use? I have one that's alright but I feel like maybe there a better one that I can't find.
proceduralgeneration,37gmxr,RedSpaceman,1 point,Wed May 27 14:13:22 2015 UTC,"This also appeared in /r/worldbuilding: ""This game randomly generates planets with terrain""  Developer behind it is /u/Managore"
proceduralgeneration,37gmxr,Managore,1 point,Wed May 27 14:14:47 2015 UTC,"I really like the style this produces.   /u/Managore, do you simulate the planets in 3d (with things like the clouds actually being represented as volumes?) and then do some special rendering to get the pixellated appearance?"
proceduralgeneration,37azql,Zivodor,5,Tue May 26 08:12:40 2015 UTC,I really wanted to explain all the steps involved in this in detail but why bother when someone else has done an excellent job doing exactly that: http://ronvalstar.nl/creating-tileable-noise-maps/
proceduralgeneration,37azql,panokani,2,Tue May 26 09:46:00 2015 UTC,I'm sorry but i am still very confused...
proceduralgeneration,37azql,melodive,1 point,Tue May 26 10:44:43 2015 UTC,"Why go elegant, when you can go fast and simple? Super easy way of doing it:  (x/width)*noise(x,y)+(1-x/width)*noise(x+width,y).   You should increase your amplitude to counter-act the interpolation evening out the noise."
proceduralgeneration,37azql,cleroth,1 point,Tue May 26 14:29:15 2015 UTC,That would be pretty hard to tweak. By pretty hard I mean impossible.
proceduralgeneration,37azql,melodive,1 point,Tue May 26 17:55:08 2015 UTC,"Eh ok, it works for me, so it is clearly not impossible. Care to elaborate your view?"
proceduralgeneration,37azql,KdotJPG,1 point,Tue May 26 18:42:34 2015 UTC,"Use this: https://gist.github.com/KdotJPG/f4db4491b341b8987f4a and ignore the 3rd coordinate.  It's not C# so you'll have to port it (shouldn't be too hard), but it is a tileable implementation I made a while back.  Note that the tileability technique used here is specific to 3D OpenSimplex, because it uses a rational lattice. It doesn't work for 2D or 4D.  This is probably the most ""normal"" way to do this. Just note that it only tiles in multiples of 6, because that's when the lattice lines back up with itself.  EDIT: Slight chance there's a bug that occurs when x, y, and z don't all tile with the same period. I haven't extensively tested this, I just made it as a quick solution once.    Alternatively, you can use this trick with 3D noise:  noise(     y / FEATURE_SIZE,     sin(x * 2pi / WIDTH) / 2pi * WIDTH / FEATURE_SIZE,     cos(x * 2pi / WIDTH) / 2pi * WIDTH / FEATURE_SIZE );   Imagine this as wrapping around a cylinder, where the height equals the circumference.  Note: This results in a different ""character"" as you change in the X coordinate versus the Y coordinate. But depending on your use, that may either be good thing or a bad thing.  EDIT:   FEATURE_SIZE gets bigger as you want things in your terrain to get bigger. Inside sin/cos, we multiply by 2pi and divide by WIDTH so that sin/cos roll over exactly once we've crossed over. outside sin/cos, we divide by 2pi because the circumference is 2pi (we want to deal with multiples of the distance ""one""), then we multiply by (WIDTH / FEATURE_SIZE) which is the number of times you want to go a distance of ""one"" in your noise over the entire width. Also this generalizes straight to the 4D torus wrapping technique if you do the same thing for y.     There is also the interpolation trick mentioned a bit down. That works and it's easy to understand, but I generally recommend against it if you have the choice, because when you linearly interpolate two noise values, the average absolute value of the noise becomes less, and you will more often see taller hills towards the edges where you're predominantly seeing one noise function. You can technically try to come up with a function to equalize these differences, but keep in mind that it's not just the height that's changing, but the probability distribution of different heights."
proceduralgeneration,37azql,tries_to_explain,1 point,Tue May 26 22:29:25 2015 UTC,Thanks! Actually while I was at work today it just hit me how to do it and I an anxious to get home and test. Seeing how you did it is perfect because its exactly what I thought the answer was!
proceduralgeneration,37468u,evglabs,3,Sun May 24 18:39:56 2015 UTC,"I think this this what you are looking for, and just out of curiosity, what are you going to do with that in your game ??"
proceduralgeneration,37468u,TheGoldenRoad,2,Sun May 24 23:34:36 2015 UTC,"Thanks! I'll take a look at it later tonight.  I want to use it in my game for giving planets characteristics, geographical features, animals, festivals and things like that to encourage the player to explore."
proceduralgeneration,37468u,rev087,2,Mon May 25 00:50:38 2015 UTC,"I used to recomend Freebase, but it seems to be retiring in favor of www.wikidata.org  If what you're looking for is lists of ""things"", with structured connections to other ""things"", this is a treasure trove."
proceduralgeneration,36x90s,rev087,3,Fri May 22 21:41:52 2015 UTC,That's awesome. I've been looking into similar stuff in my free time. Getting the mesh right is a pain. Looks like you did an excellent job.
proceduralgeneration,36x90s,ptblduffy,2,Sat May 23 00:36:46 2015 UTC,"The idea is to eventually provide a visual node-based interface to create the assets. As it stands, the API lets me instantiate, set parameters and connect the ""nodes"" via scripting."
proceduralgeneration,36x90s,Enemby,2,Fri May 22 22:17:11 2015 UTC,"Holy crap. This is awesome! I don't see licensing anywhere in the Github page, though. What is it? I'd love to use this in my project."
proceduralgeneration,36x90s,KungFuHamster,2,Fri May 22 22:35:59 2015 UTC,"I'm still trying to figure out the specifics, but I want to have a dual license similar to Unity itself: free for indies, modest license fee for companies making 100k+/year so I can fund more time for development."
proceduralgeneration,36x90s,KungFuHamster,1 point,Fri May 22 22:53:34 2015 UTC,Can't load the gif.
proceduralgeneration,36kbh5,Arandmoor,8,Wed May 20 00:39:29 2015 UTC,"The diamond-square algorithm was declared flawed a while back in a SIGGRAPH paper because it creates creases. Your implementation also has errors that are causing discontinuities, but diamond-square isn't a very good algorithm for this type of thing anyway, because it's always going to create creases.  If you would like to create heatmaps, use Simplex noise or OpenSimplex noise. (There's also Perlin noise, but Perlin has visually-significant directional artifacts that, while aren't as bad as the ones in Diamond-Square, are still present.)"
proceduralgeneration,36kbh5,KdotJPG,2,Wed May 20 02:51:26 2015 UTC,Have you tried ironing it?
proceduralgeneration,36kbh5,Trainzack,5,Wed May 20 23:47:28 2015 UTC,Instructions unclear.  Iron-shaped burn mark on monitor.
proceduralgeneration,36kbh5,Bergasms,1 point,Wed May 20 23:54:32 2015 UTC,"That said, running a gaussian kernel over it would remove the crease."
proceduralgeneration,36kbh5,KdotJPG,1 point,Thu May 21 02:18:43 2015 UTC,I actually managed to almost completely remove them by changing my method of RNG from javascript's Math.random() to an Xorshift implementation.  ...I really don't like Javascript's Math.random()...
proceduralgeneration,36kbh5,frozen_pie_taster,1 point,Thu May 21 02:29:15 2015 UTC,"Interesting enough, if you look at how Simplex noise / OpenSimplex noise work, they can be looked at as running a sort of fade/blur kernel over the lattice points / gradient extrapolations. Commonly they're looked at as placing kernels around each lattice point, but this other way of looking at it is mathematically equivalent.  And they'd be much faster than doing it over diamond-square.  EDIT: Rather they can be looked at as running the kernel over the lattice points' ""values"", where the ""values"" of the lattice points change depending on their gradient and your position relative to them."
