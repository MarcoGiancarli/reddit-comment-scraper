scala,3e2t21,noel,5,Tue Jul 21 14:59:03 2015 UTC,Thank you
scala,3e2t21,kjllkjlkjlkjsdfjkllk,5,Tue Jul 21 16:18:24 2015 UTC,"Rich Hickey did an excellent talk on this http://www.infoq.com/presentations/Simple-Made-Easy  Personally I take it a bit further, and apply the same concept to type hierarchies. Its not a popular concept here in Scala, but I have similar qualms to deep type hierarchies like I do with overuse of subtyping/inheritance (and other examples of trying to be easy)  This approach is somewhat harder/more nuanced in a static language than Scala vs a dynamic one like Lisp, but it helps greatly in regards to keeping the amount of ""magic"" to a minimum."
scala,3e2t21,mdedetrich,2,Wed Jul 22 01:31:55 2015 UTC,"Very sensible sentiment expressed succinctly. I've been trying to find a way to verbalise exactly this, when faced with the argument ""but this way is simpler""."
scala,3e2t21,CircusAct,2,Tue Jul 21 21:06:05 2015 UTC,"While perhaps not scala-specific, an ex-professor of mine has a talk on exactly this.  https://www.youtube.com/watch?v=UfzafIeALW8"
scala,3e2t21,essayelynch,1 point,Wed Jul 22 01:47:14 2015 UTC,"I agree, complex domains become simpler with each unit of effort you put into them.  Eventually it clicks together and all those hours become worth it.  Good post, thanks for sharing."
scala,3e2t21,ghostcyp3r,1 point,Tue Jul 21 21:26:58 2015 UTC,Tunneling through the learning barrier [...]   I smell a physicist.
scala,3e2t21,szabba,1 point,Wed Jul 22 09:07:19 2015 UTC,"52 requests, 2,875.56 KB, 14.86 s   Evidently simple Web design isn't easy."
scala,3dzurl,utgyuru,3,Mon Jul 20 21:38:02 2015 UTC,"This is actually a tricky piece of code, at least trickier than one usually uses for real tasks.  Sometimes useful however, so here's how my brain type checker works:   the return type of iterate is Double hence, the return type of fixedPoint is also a Double averageDump takes two arguments and returns a Double. Using the ""currying"" syntactic sugar, if you only pass one argument, the type will become Double => Double. in the last line in question, averageDump received only one argument and is therefore Double => Double fixedPoint receives two arguments, a Double=>Double and the last Double. It returns a Double. (the sqrt function in this exercise)"
scala,3dzurl,vn971,7,Tue Jul 21 08:01:01 2015 UTC,"I believe the confusion comes from currying and partially applied functions. You have:  def averageDamp(f: Double => Double)(x: Double) = (x + f(x))/2   This is just some syntatic sugar for:  def averageDamp(f: Double => Double): Double => Double = {   (x: Double) => (x + f(x))/2 }   Which is a function that receives a function as an argument and returns a function.  So when you do  averageDamp(y => x / y)   This has the type Double => Double, or in other word a function that receives a Double (the x in the averageDamp declaration) and returns a Double. And it is this function that is passed as the argument f to the fixedPoint function. Since f is only used once inside the fixedPoint body (in the line val next = f(guess)), the value that is passed to the second argument list of the function averageDump (the x) is guess."
scala,3dzurl,Lasering,6,Tue Jul 21 00:42:46 2015 UTC,"Part of the confusion you may have is in this statement:   The first argument (the function) of the fixedPoint function, is the return value of the averageDamp function   The first argument is actually the partially applied averageDamp() function.  Think if it along these lines:  def ad2(x: Double) = ad(y => x/y)(_)            //> ad2: (x: Double)Double => Double fixedPoint(ad2)(1)   this intermediary function is really a Double => Double which is the first argument to fixedPoint. The second argument for for averageDamp() is actually passed in as guess inside the fixedPoint() function."
scala,3djo4h,Ruby-HeeL,5,Thu Jul 16 20:30:52 2015 UTC,"The  ""1 plus 1"" problem should be implemented with a type class like so:  http://scastie.org/10950  This would cause types missing a definition of Plus to fail at compile time instead of runtime:  http://scastie.org/10951"
scala,3djo4h,Milyardo,1 point,Fri Jul 17 02:40:17 2015 UTC,That's a great alternative
scala,3dizr2,mrkaspa,5,Thu Jul 16 17:35:04 2015 UTC,"Does it come back down after indexing is done?  That seems to be the biggest CPU hog, but it's only for a short while."
scala,3dizr2,campbellm,2,Thu Jul 16 21:14:52 2015 UTC,It happens When I change the dependencies in SBT because it reindex
scala,3dizr2,campbellm,1 point,Thu Jul 16 21:32:50 2015 UTC,"Ah, right.  Yes, re-indexing is really a disaster on CPUs in intellij.  I don't know of any way to make it either not do that, or require less CPU.  =("
scala,3dizr2,hyperforce,1 point,Fri Jul 17 01:54:26 2015 UTC,"If you change dependencies frequently, turn off auto-import."
scala,3dizr2,vn971,1 point,Sat Jul 18 22:55:27 2015 UTC,I did it and nothing the funny thing is that the same happens with a java project I think is an IDE problem
scala,3dizr2,breandan,5,Tue Jul 21 20:48:59 2015 UTC,That is expected behavior of this IDE. It works that way.
scala,3dizr2,xkcd_transcriber,3,Thu Jul 16 22:21:33 2015 UTC,Relevant XKCD.
scala,3dizr2,pathikrit,1 point,Thu Jul 16 23:09:17 2015 UTC,"Image  Title: Workflow  Title-text: There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN.  Comic Explanation  Stats: This comic has been referenced 387 times, representing 0.5329% of referenced xkcds.    xkcd.com | xkcd sub | Problems/Bugs? | Statistics | Stop Replying | Delete"
scala,3dizr2,breandan,2,Thu Jul 16 23:09:23 2015 UTC,Intellij 15 EAP is even worse. It reindexes and keeps my laptop quite hot.
scala,3dizr2,alexandr-nikitin,1 point,Fri Jul 17 00:17:23 2015 UTC,Does CPU usage remain high even after indexing has completed? Would you try to reproduce and submit a CPU snapshot? Thanks!
scala,3dizr2,Jacoby6000,2,Fri Jul 17 00:51:40 2015 UTC,"Is ""auto-import"" turned on? Try to turn it off."
scala,3dizr2,amazedballer,2,Fri Jul 17 09:25:44 2015 UTC,"I just increase the allocated ram for Intellij and it works fine. I suspect the CPU shooting up is all of the memory swapping in/out of your drive.   EDIT: Just saw that it was because of re-indexing. That's to be expected. If you re-index constantly from ever-changing dependencies, see what /u/hyperforce said."
scala,3d3cjo,mobby1982,1 point,Mon Jul 13 04:50:07 2015 UTC,"Try also works very well, as opposed to Either, it works better with for comprehensions, and you can use custom Exception classes and recover/recoverWith to translate them to a more appropriate response if needed."
scala,3d3cjo,compmstr,1 point,Mon Jul 13 12:01:59 2015 UTC,"I think Try should only be used if you have to deal with exceptions (like due to some sort of Java API). Otherwise, scalaz's options are strictly better. I think recover/recoverWith were recently added to \/ as well."
scala,3d0c65,ghostcyp3r,6,Sun Jul 12 12:37:04 2015 UTC,"There is no specific way to learn Scala for the enterprise. There is no Scala equivalent of Java EE. Though at the same time, you can use pretty much all of the Java EE technologies from Scala, usually there isn't anything different required from the implementations to use Scala.  So what does Scala in the enterprise actually look like? Not any different from Scala anywhere else, though if I had to name any Scala based technology for being particularly ""enterprisey"", I'd have to mention Akka and Spark as examples."
scala,3d0c65,Milyardo,2,Sun Jul 12 14:50:29 2015 UTC,"the scala docs are improving (links on the right of this sub) Scala School from twitter even though old is still pretty good.. also the ""Asserts"" link is really scala koans is a fun resource..  if you have some funds for books i extremely recommend getting FPiS at some point"
scala,3d0c65,prepromorphism,2,Sun Jul 12 14:06:34 2015 UTC,"After you finish the book, try to imagine a project that you would like to create in your spare time.  Mine was an online personal library for technical ebooks (github link). A small practice with Scala every day will help you to learn the language in the fastest way possible. I'm now working with Scala-Spark project at work and the knowledge I got from doing a side project was very helpful.  Other ways are:   Obviously find a job where the project is written in Scala, your co-workers will be eager to help you with learning of the best practices. Give some Scala lessons to your current co-workers. You will be amazed how the necessity to explain Scala features in an easy-to-understand way will improve your knowledge of the language."
scala,3d0c65,Mironor,2,Sun Jul 12 15:12:30 2015 UTC,"I would recommend Func Programming Scala here. I got started writing enterprise scala a few months ago and this book has helped me grasp the finer things about scala, totally recommend it. EDIT: Make sure you also do the exercises in each chapters."
scala,3d0c65,travelooye,1 point,Sun Jul 12 17:18:56 2015 UTC,P.S. any podcasts you guys would recommend?
scala,3d0c65,prepromorphism,3,Sun Jul 12 12:37:42 2015 UTC,http://www.scalawags.tv/
scala,3cprsw,SciK,5,Thu Jul 9 20:11:21 2015 UTC,"Regarding default methods for traits, it should be noted that JVM 8 allows interfaces to have static methods. Hence, even if you don't use default methods only to compile traits (e.g. because a trait defines an override of a class method, which the JVM does not allow), you still don't need an implementation class; just define the trait's concrete methods as static methods on the interface."
scala,3cprsw,argv_minus_one,2,Thu Jul 9 22:20:44 2015 UTC,"Very happy to see the focus on optimisations at compile time. The reliance on JVM for run-time optimisations always bothered me.  I would like to see one more type of optimisation: when a final class has a val in it, there is no need to generate & call a getter for it. The JVM is probably good at optimising it away eventually, but some help from the compiler can reduce startup times."
scala,3cprsw,hrjet,2,Fri Jul 10 04:03:35 2015 UTC,Would changing a value to lazy then break binary compatibility? Or does it already break compatibility?
scala,3cprsw,ryan_the_leach,2,Fri Jul 10 22:04:10 2015 UTC,"Oh, I meant use of the value within the class. Optimising external access could also be considered, now that they are talking about a library mode v/s application mode. In the application-mode (whole-program optimisation), binary compatibility need not matter."
scala,3cp9gk,petrolhead83,2,Thu Jul 9 17:54:11 2015 UTC,You tell the compiler that there are only two types of Phone by marking it as sealed:  sealed trait Phone{     def version:String }   (And then you must define ApplePhone and AndroidPhone in the same file — you seem to be doing that already.)  Is that enough for the compiler to synthesise the PhoneToJson[Phone]? I don't know. I'd guess not. But it's not hard to write  implicit def phoneToJson = new PhoneToJson[Phone] {     def toJson(a:Phone) = a match {         case apple: ApplePhone => applePhoneToJson.toJson(apple)         case android: AndroidPhone => androidToJson.toJson(android)     } }
scala,3cp9gk,dave4420,1 point,Thu Jul 9 18:17:19 2015 UTC,"Thanks for the reply. The problem is I don't own the Phone type. It comes from an other library and i cannot control new classes deriving from it. But when a new phone phone is added to the library, I want compilation of my code to fail because there is no implicit evidence for the converter available for my the new type."
scala,3cp9gk,Milyardo,1 point,Thu Jul 9 18:56:57 2015 UTC,You can't get compilation for some types of phones to fail if you don't know what types of phones are in the list. What you would need instead of is a well typed heterogeneous list of phones.
scala,3cp9gk,alexd6631,2,Fri Jul 10 16:44:38 2015 UTC,"The type that getAllPhones returns is a List[Phone]. But the convertToJson function has a type parameter of [A <: Phone : PhoneToJson].  A List[Phone] can have mixed implementations of Phone as its elements. Whereas a List[A <: Phone : PhoneToJson] can only have the implementation provided by A. So the types don't match and hence the evidence parameter can't be found.  I think you need a converter that works on a Phone like /u/dave4420 provided. I don't think that not owning the Phone is a problem, just have a case where any other Phone implementation throws an exception."
scala,3cc9ye,stucchio,1 point,Mon Jul 6 20:06:39 2015 UTC,I would characterize this as a use of abstract types (having existential type) rather than dependent types.
scala,3cc9ye,S11001001,1 point,Sat Jul 11 15:18:15 2015 UTC,It uses path dependent types right here   def insertPost(user: UserLike)(post: user.shard.BlogPost)   The type of 'post' is dependent on the choice of 'user'.
scala,3cc9ye,JamesIry,0,Tue Jul 14 15:12:35 2015 UTC,This seems pretty useless in the real world. You don't want to recompile and deploy just to change sharding decisions. Nor can it be used for systems that dynamically reshard when nodes are added or removed.
scala,3cc9ye,KagakuNinja,2,Tue Jul 7 05:19:19 2015 UTC,"I don't understand. All this does is prevents you from writing code like this:  updateBlogpost(user(..., Shard(1)), blogPost(..., Shard(2)))   I have this running in a production system which dynamically reshards. All it does is make sure I don't accidentally mix things up in the resharding process.   Could you give a concrete example of what sort of things you think this prevents?"
scala,3cc9ye,mdedetrich,-1,Tue Jul 7 11:11:53 2015 UTC,"Echoing this, very rarely is sharding done statically. The best (but hardest) solution to this problem is an abstraction layer on the database layer that automatically deals with sharding.  Its not a very easy solution to solve either way though"
scala,3cc9ye,hrjet,0,Tue Jul 7 05:31:01 2015 UTC,"To chain computations together, one must be careful to use type signatures which encode the information that is known about the result set   What happens when one is not careful?"
scala,3cc9ye,ItsNotMineISwear,3,Tue Jul 7 04:16:15 2015 UTC,My guess and hope is it doesn't compile
scala,3caimu,paulblei,5,Mon Jul 6 11:35:24 2015 UTC,Don't forget FPiS!
scala,3caimu,earldouglas,3,Tue Jul 7 01:04:42 2015 UTC,"yeah, totaly agree. in my opinion it's the best mainstream book for an introduction to monads etc.  other people seem to think so too: http://fsharpforfunandprofit.com/rop/#comment-2022140861"
scala,3caimu,RedTuesday,2,Tue Jul 7 12:38:44 2015 UTC,Yea I am reading that book now and it is awesome read.  It also is a big help that the Q&A examples are GitHub gists in the repo and can be updated and hints are given for most questions: https://github.com/fpinscala/fpinscala
scala,3caimu,adramalech707,1 point,Tue Jul 7 22:04:32 2015 UTC,yea really this is probably the single most important book
scala,3c9blu,prettynatty,1 point,Mon Jul 6 02:36:11 2015 UTC,"nice, thanks for sharing"
scala,3c2f38,stevemcd,5,Sat Jul 4 03:19:11 2015 UTC,For a one man (I guess...) project this is really impressive. Especially the concise and readable code is nice.
scala,3c2f38,geggo98,2,Sat Jul 4 10:01:46 2015 UTC,"Yea, at least I am impressed."
scala,3c2f38,nick-linker,2,Sat Jul 4 13:51:28 2015 UTC,"Really well done, there is actually a compelling case for CurioDB due to it leveraging so much of akka (automatic clustering/persistance etc etc)  I have to say, well done for a one man project!"
scala,3c2f38,mdedetrich,2,Sun Jul 5 03:33:30 2015 UTC,nice
scala,3c2f38,prepromorphism,1 point,Sun Jul 5 16:01:07 2015 UTC,"Thanks for the kind feedback, much appreciated!"
scala,3byqxu,japgolly,2,Fri Jul 3 06:34:15 2015 UTC,"So, would it be possible to compile the scala compiler with scalajs to make a client-hosted version? That'd be pretty cool"
scala,3byqxu,teknocide,2,Sun Jul 5 02:14:05 2015 UTC,I guess not: scalaJS does not support file API-s. I don't know who'd be interested to write emulators for those.
scala,3byqxu,vn971,1 point,Sun Jul 5 06:19:11 2015 UTC,"Shouldn't it delegate such calls to whatever Node.js is doing, so you could run Scala on Node?"
scala,3byqxu,vytah,2,Wed Jul 8 12:59:10 2015 UTC,"What's the point of making it run on Node.js instead of the JVM, besides making it 5x slower?"
scala,3bw2mi,alfonsovng,1 point,Thu Jul 2 16:58:04 2015 UTC,"Chrome bugs fixed! There is a demo available at http://scala.shotbingo.com:9000/ (be gentle, it's a small server)"
scala,3bdqyg,chandu0101,2,Sun Jun 28 06:44:32 2015 UTC,I've been using Scalajs with angular on a Play Framework project and it works surprisingly well. I'm kind of blown away by how seamless the integration is.   What's great is I can read the angular docs in Javascript and translate pretty easily to Scala.  The same probably goes for ReactJS.
scala,3bdqyg,Narrator,0,Mon Jun 29 20:25:58 2015 UTC,Nice
scala,3b9fko,CsAnswerTrashAct,7,Sat Jun 27 01:42:11 2015 UTC,"There are a couple different either implementations in Scala. In your case you're specifically looking for what's called a biased either. That is an either who's behaviour assumes you want the right side of the either most of the time.  One such right-biased either in scala is the scalaz's(a library for functional data structures) \/(aka disjunction). Given the following disjunctions:  type Error = String val result: Error \/ Int = 7.right val failure: Error \/ Int = ""An Error occurred"".left   calling the map method on result will evaluate the given function changing the signature of the right side, ie:  def intToFoo(n: Int) = new Foo(n) val result2: Error \/ Foo = result.map(n => intToFoo(n)) //Foo(7).right   however, calling map on failure results in a no-op, returning the error which originally occurred:  val result3: Error \/ Foo = failure.map(n => intoToFoo(n)) //""An Error occurred"".left   Typically instead of calling map(and flatMap) over and over again, a for comprehension is used when working with a large number of disjunctions.  val result4: Error \/ Foo = for {     n <- result     m <- failure } yield { new Foo(n + m) }   The net effect is that if an error occurs anywhere within the for comprehension, any further evaluation is effectively terminated(because calling map or flatmap results in a no-op).  When you want to instead work with the error type, you can either call the leftMap method or swap.  However when it comes to accumulating error values like in the example, an entirely different either-like structure is used. In scalaz, This is called a  Validation[L,R]. Validation comes with the restriction that L must admit a Monoid which allows the left side to accumulate errors. Like disjunction, Validation is right biased. However unlike the example you gave, Validation is disjoint, meaning you will only ever get a Error values or success values, but not both. In the case where you could have both a success and a failure there is the lesser used \&/ in scalaz.  As you can see, there are a lot of either types(more generally known as union types). If error handling with a union doesn't seem right, or is frustrating for some reason, you're probably not using the right kind of union.   My primary frustration, however, is that coworkers have started rejecting code-reviews because I'm not using this pattern in every place a failure might be possible, even in cases where there has never been an exception or null.    This is correct. The signature of your method is a contract. If it's possible to return an error, the signature of your method should reflect that an error is possible, even if you've never seen that error before."
scala,3b9fko,Milyardo,3,Sat Jun 27 03:07:20 2015 UTC,"A few points:  I think you should have Either<List<Failure>>, R>. There are reasons to have List<...> but it shouldn't be the type you usually pass around. Fail-fast error handling is the normal case in most programs. If you want to accumulate errors that's a different case.  Either is less clumsy to use in Scala because we have special syntax to work with it and other monads.  I believe you need to decide which errors you want to model and handle, and which you don't. For example, any code at any point could run out of memory but it would be very unusual to model this error case.  Your coworkers read some blog post to get this pattern. Well, here's some blog post you can use: http://underscore.io/blog/posts/2015/02/23/designing-fail-fast-error-handling.html"
scala,3b9fko,noel,2,Sat Jun 27 07:50:02 2015 UTC,"Here's the code you posted:  public List<Either<Failure,R>> method2(List<T> obj) {     List<Either<Failure,T>> result = method(obj)     List<Either<Failure,T>> result2 = new ...     result.left.forEach(failure -> {results2.add(Either.left(failure))}      try {         result.right(                     item -> {                          results2.addAll(method3(item));                     }     } catch (Exception e) {         results2.add(Either.left(e));     }     return results2; }   The first big problem with it is that you're referencing the field left and the method right on List, even though they don't exist. So there's already some confusion in your code about either you have a List<Either<A,B>> or an Either<List<A>,List<B>>.  The second problem is generally speaking, things have the potential to fail multiple ways (e.g. when trying to read JSON from a file, you might have an IOException if the file doesn't exist, or a JSONParseException if the file is actually a JPEG or an MP3 instead of a JSON file), but they don't actually fail in multiple ways (i.e. you don't get both exceptions happening in a single invocation of the function), so it very rarely makes sense to have multiple failures in the way that you've described. Another aspect of this same problem is that you're implying that method2 can actually do useful work even if method fully failed, implying that method2 doesn't actually need any data from method, in which case why are you bothering to invoke method inside of method2?  You might have to give a more concrete example of what you're doing such that multiple failures are occurring. For example, if your ""multiple failures"" are actually validation, then you probably either want to use the Validation applicative instead of the Either monad, or you want your Failure type to be a monoid so that you can combine multiple failures into one. See http://bugsquash.blogspot.com/2011/08/refactoring-to-monadic-c-applicative.html for more details on that."
scala,3b9fko,Nebu,2,Sat Jun 27 08:07:04 2015 UTC,"In Scala or Java 8 (or any language the uses closures), it is not reasonable to preserve the ""throws"" list for checked exceptions in the closure since composition of functions becomes difficult for the language. That's why in Scala all exceptions are unchecked exceptions.   But this doesn't remove the need for what checked exceptions did previously: checked exceptions reified the ""expected errors"" of a method to callers. To me, an expected error is anything that I can imagine a caller or user  doing wrong when using the abstraction I present to them. Something that they could correct with a proper error message. Some common examples of ""expected errors"" (this is focused on web services since thats mostly what I do -- will vary according to your domain/use):   Bad input from user/caller Unauthorized/forbidden Entity not found    In Scala, typically I reify expected errors in the type signature of the return type (e.g. with Either or \ /). Note: this does have consequences to code style as it implies getting used to monads and for-comprehension syntax. Trying to deal with them explicitly leads to almost unreadable code.  Also, this doesn't mean ""unexpected errors"" still don't occur. Unexpected errors are things the caller/user can do nothing about. To me, the set of unexpected errors is so big that its not time/cost effective to deal with them explicitly in code. If something unexpected happens, the vast majority of the time just letting the unchecked exception bubble up to some top level error handling logic is the most time/cost effective method. Some examples of ""unexpected errors"":   Database is down Bad/buggy return value from called code (e.g. null) Out of memory   Since the caller/user can do nothing about these errors, they can be relieved of the burden of dealing with them. This means they don't need to be reified in the type signature."
scala,3b9fko,lancegatlin,1 point,Sat Jun 27 18:54:06 2015 UTC,"Can't agree with this more, there are definitely a certain class of errors which you don't want to deal with in the typesystem. You can also add other stuff to that list, like - Network is down - Timeout errors (this one is debatable)  I good way of going about it is, if you are working with business logic, you should try to match that in the type system as much as possible. Validation falls into that area, the contract (lets say in the case of a webserver), is that if something is missing from a POST request, you should return an error.  However, dealing with database not working isn't really ""business"" logic (unless you are writing something like a connection pool).  There are also good arguments about whether the type system should (or shouldn't) capture stuff like DI (a lot of people intentionally conflate dependency injection with dependency parameter passing as well, which doesn't help)"
scala,3b9fko,mdedetrich,1 point,Tue Jun 30 05:54:08 2015 UTC,"On another note, given the repetitive pattern of ...  List<Either<Failure, T>>   I created a ""MayFail<T>"" class, which contains 0 to many successes and failures, as well as functional interfaces, but was scolded because ""Why create that when we already have a List of Eithers of Failures and Ts"""
scala,3b9fko,Milyardo,3,Sat Jun 27 01:45:56 2015 UTC,"In Scala, there would be no need for a new class here where a type alias would instead suffice if your only aim is to cut down on the verbosity of the type signature.  type MyFail[T] = Seq[Either[Error,T]] def query[T](q: Query[T]): MyError[T] = ..."
scala,3b9fko,InfectedWithDrew,3,Sat Jun 27 03:16:53 2015 UTC,"Your ""MayFail"" is basically scala.util.Try."
scala,3b9fko,balefrost,1 point,Sat Jun 27 06:15:04 2015 UTC,"I took a look at Try, it appears something similar could work in Java.  If multiple are needed, then a List<Try<T>> might to the trick."
scala,3b9fko,outofkill,1 point,Sat Jun 27 07:22:28 2015 UTC,"Or even a Try<List<T>>, assuming you want to fail-fast."
scala,3b9fko,amazedballer,1 point,Sat Jun 27 13:30:50 2015 UTC,"You're in the same place I was a year ago. It looks alien but you get used to it and soon start to rely upon it. If you're using Scala anyway. I never enjoyed trying to shoehorn FP into Java myself.  However, as an old Java hand myself, I'm more alarmed that you're passing around a Map<String,List<Something>>.  I might actually do that in Scala with a Value class for a key and a type alias for the map but I'd never have dared in Java! An Either looks simple in comparison!"
scala,3b6oog,sschaef_,1 point,Fri Jun 26 12:16:06 2015 UTC,Are the slides posted anywhere by themselves?
scala,3b6oog,kodablah,1 point,Mon Jun 29 20:01:28 2015 UTC,You can download the slides separately from the videos. Under each video there's a Downloads tab with a link to the slides.
scala,3b6oog,richdougherty,1 point,Mon Jun 29 21:27:24 2015 UTC,Thanks for the link! Here are some talks by the Scala team and contributors:   Martin Odersky's keynote Closing Panel discussion with Scala team and contributors
scala,3b24ig,pafciu,3,Thu Jun 25 10:26:59 2015 UTC,"""This is intended to be the last RC—fingers crossed."" https://twitter.com/akkateam/status/614006918013710336"
scala,3b24ig,TweetsInCommentsBot,1 point,Thu Jun 25 10:28:33 2015 UTC,@akkateam   2015-06-25 09:47 UTC  #Akka Streams&HTTP 1.0-RC4 is out: try it out while it is hot! This is intended to be the last RC—fingers crossed.  https://groups.google.com/d/msg/akka-user/-GMxTVpZaDM/HYCMu1jTNG8J     This message was created by a bot  [Contact creator][Source code]
