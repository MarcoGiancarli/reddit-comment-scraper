rust,3e4917,rovar,12,Tue Jul 21 20:59:09 2015 UTC,"Yea, I meant to post this to /r/rust :)  This is Evan Czaplicki discussing the design of a programming language to be friendly towards newcomers.  The subtext being how to avoid the pitfalls that seem to have encumbered existing functional languages.    IMO, Evan has done an excellent job with API design, especially as it relates to naming, in order to appeal to its target audience, which is web devs."
rust,3e4917,Watley,2,Tue Jul 21 21:00:56 2015 UTC,Having played with Elm a bit I'd say that Elm does an amazing job of being friendly to newcomers. Even coming from Haskell I had never encountered FRP before and Elm got me up and running with it in half an hour.
rust,3e4917,fechan,1 point,Tue Jul 21 23:24:03 2015 UTC,"This video got me interested in Elm so I looked it up and I can't find anywhere how getting started works or what Elm actually does / is. So, do I write this functional Elm code and then compile it to index.html? Or does it work like PHP in that it has its own server and I can have an index.elm and an ELM listener serving HTML / CSS / JS? So if it's the first one, it's an alternative for CoffeeScript / TypeScript etc.? What is Elm's role in the bigger picture...  As a total newcomer, I am kinda sad that he emphasizes communication and noob-friendliness but these basic questions are left unanswered."
rust,3e4917,Veedrac,1 point,Wed Jul 22 02:06:54 2015 UTC,"<docs → Make an HTML app> looks like it should get you up and running. This links to Elm Platform which looks like it has all the help pages you'd want. You might also want the READMEs for these packages.  I haven't tried it, though. I agree there's a sparsity of documentation, which is forgivable considering it's all pretty much written by one guy."
rust,3e4917,Veedrac,2,Wed Jul 22 02:25:49 2015 UTC,"This video sold me on Elm. Never used it, but now I want to.  I think Rust actually manages a lot of the same goals, but for C++ programmers. After all, the same joke works  ────────────Assembly─•───────────────────C─•─────────────────C++─•         Maintainability     Memory Management       Maintainability   Rust doesn't go much for gradual learning per se, but does try to build on top of the C++ model. Things like the online playpen help too, as with the ""jump right in"" attitude of Cargo.  On the point of communication, I think Rust sells itself quite well. There have been complaints in this direction (eg. from Jonathan Blow), but this is mostly from people who aren't the target demographic. For the targets Rust aims at, it's selling itself well.  Rust's culture and enthusiasm is outstanding. However, I do want to touch upon the style guide. If you get too much expressivity, you end up writing things like  stroke /= [] ==> validbox box ==> refit box stroke ~~ refit box (refit box stroke)`   Just (p, ns') -> S.insert p $ go (S.filter (\n -> n `mod` p /= 0) ns')   Elm has taken a hard stance against this, which is outright amazing. I don't think Rust needs to (Rust's verbosity and imperative nature helps keep this in check), nor would it jive with the C++ community (which loves complexity), but it has reminded me of how unloved our own style guide is. This is especially bad given the over-the-top complexity of our function declarations.  Rust doesn't really feel like it's ever embraced a ""minimum viable solution"" aesthetic, but I think we have our own charm. The problem there is that it requires really exceptional documentation. As of now, we only have exceptional documentation.  Next up is tooling. We should really steal their semantic diff. Cargo semantic-diff would be a blessing. Do this. Please.  Error messages in Rust are good, but Elm's look gorgeous. I wonder how much of this is allowed by Elm's comparatively much simpler design - I'd expect the lack of typeclasses and such to be heavily in Elm's favour. The conversational style of errors is also lovely, if not something C++ programmers are likely to appreciate. Maybe I think of C++ programmers too much like Bill Rizer..."
rust,3e4tsi,arcnmx,1 point,Tue Jul 21 23:32:34 2015 UTC,"Feedback welcome! I'm hoping to use syntex to bring this entirely to stable, without the use of OIBIT. nue-macrosis quite a mess right now, but does enable some (excessive) cool things.  Also, there's a very interesting related discussion over at this POD pre-RFC, which I only found out about last night thanks to TWiR  P.S. I missed specialization a lot when writing some of this..."
rust,3e3a6x,enjoyscuriosity,17,Tue Jul 21 17:01:10 2015 UTC,"Somewhat relatedly, I really would like to see Hyper and mio ported to kernel space and for people to start writing Rust-based Web apps in the kernel.  Context switches are a runtime defense against a problem that Rust solves at compile time, after all."
rust,3e3a6x,pcwalton,12,Tue Jul 21 18:26:43 2015 UTC,"I don't know if you're being sarcastic or not, but where I work we have a very serious need for security. Type safety is a realistic approach, and I don't know why the kernel programming community refuses to acknowledge it's benefits. You can have all the same of ease of programming, but without the segfaults and being pwned. Why argue with that?  Possibly others don't have familiarity with that, but I've been authoring exploit payloads for years, so possibly I things a different way.   Edit:  Actually, I didn't know exactly what you meant, so now I can see that you're really not being sarcastic"
rust,3e3a6x,staticassert,4,Tue Jul 21 19:39:08 2015 UTC,I hope you don't continue to get downvotes for commenting on an obvious and consistent problem!
rust,3e3a6x,staticassert,3,Tue Jul 21 19:52:12 2015 UTC,"Yeah, that's definitely happened. I suppose you read my comment history.  Thanks :)"
rust,3e3a6x,rovar,1 point,Tue Jul 21 19:56:14 2015 UTC,"Nope, didn't read it. I've just seen it a million times before."
rust,3e3a6x,pcwalton,6,Tue Jul 21 20:38:23 2015 UTC,"I might recommend an alternate approach.  Perhaps we pin processes to cores and shield them from interrupts as a means of avoiding context switching.   Kernels should be getting smaller, not larger :)"
rust,3e3a6x,annodomini,6,Tue Jul 21 19:46:25 2015 UTC,"I might recommend an alternate approach. Perhaps we pin processes to cores and shield them from interrupts as a means of avoiding context switching.    You still have to context switch on I/O syscalls.   Kernels should be getting smaller, not larger :)   See, I question this premise. Why should kernels be getting smaller?  All of the reasons I've heard for that are variants of ""because one malfunctioning piece of the kernel can result in the entire system crashing, or compromise"". The solution to that is to make it so that faults in code don't result in crashing or compromising the system. Address separation and hardware privilege levels are one way to achieve that. But why not try other ways?"
rust,3e3a6x,pcwalton,3,Tue Jul 21 21:04:09 2015 UTC,"Why put the network app in the kernel rather than putting the TCP stack in userspace? That seems to be the modern approach for low-latency networking to avoid context switches. The advantage is that you can still avoid all of the complexities of working within kernel space, have memory protection available so that you can use libraries written in C or which use unsafe, but still get the speed advantage of being able to do networking without context switches.  I mean, I agree that it's interesting to try out different approaches, and the memory safety benefits of Rust make a compelling argument against needing addresss-space protection. But my instinct says that between unsafe, a lack of any kind of formal model showing that Rust (along with all of the unsafe code in whatever parts of the standard library you need to use) are sound, calling into C code, and various complexities of writing kernel code, it would probably be simpler and safer to move TCP into userspace rather than the web server into the kernel."
rust,3e3a6x,lurkinsredditacct,5,Tue Jul 21 21:26:30 2015 UTC,"The reason why not to contort the design of the kernel is so that you can run on stock Linux distributions, with a native TCP stack.  I think that you're setting the bar way too high for wanting formal modeling before you trust that Rust is memory-safe. Formal modeling is primarily going to prove whether a very small subset of Rust is safe, and I'm pretty confident that that small subset is ironclad. Even if memory safety bugs were found, they'd probably be in corner cases that you'd have to intentionally write bad code to exploit (like the Rc overflow). The probability that actual attackers who can't write Rust code of their own but can only interact with a Rust program can exploit such a bug is incredibly small. Golang, for example, has known, wildly unsafe and totally exploitable in the right conditions, use-after-free holes around slices and maps, but Google properly understands that attackers can't practically weaponize these without writing Go code of their own, so they aren't a problem in practice.  And the solution to the unsafe problem is to not use unsafe code. Put the unsafe code into userland and use context switches whenever you want to call it, or just write the unsafe code in safe Rust."
rust,3e3a6x,formode,1 point,Tue Jul 21 22:08:47 2015 UTC,I agree with you for what it's worth.  I think it may be counterproductive to try to force changes to the existing kernel since the politics are probably harder to cope with than the problem we're trying to solve.  If we are really being serious about a total rust kernel we should try to design it in such a way that allows for things like decentralization and inherent encryption.  I don't think we should try to replace today's kernel we should look at what tomorrows kernel will need.  Maybe even hire some mathematicians to produce a 0 knowledge model.
rust,3e3a6x,pcwalton,3,Wed Jul 22 00:38:51 2015 UTC,"This runs contrary to the prevailing wisdom of building secure systems. The analogy I like is this: rather than treat a system as an egg with a shell that, once penetrated, allows access to the gooey insides, treat it as a stale fruitcake which is tough all the way through. Rust helps in this regard but it is not ""the solution"" to the problem. It is a mitigating technique.  Also, context switches are one of the tiniest slivers of the pie that makes up web request latency."
rust,3e3a6x,formode,2,Wed Jul 22 00:39:09 2015 UTC,Sounds like Mirage!
rust,3e3a6x,staticassert,5,Tue Jul 21 18:55:54 2015 UTC,"Yeah, sorta. But I don't think you need a Xen basis or any of that OCaml runtime stuff. Just make the standard Rust runtime library plus Hyper work as a plain old Linux .ko, and that's all you need."
rust,3e3a6x,pcwalton,1 point,Tue Jul 21 19:03:02 2015 UTC,That'd be very interesting to see!
rust,3e3a6x,staticassert,2,Tue Jul 21 19:04:02 2015 UTC,I'm confused. You want to put network applications inside of the kernel?
rust,3e3a6x,desiringmachines,6,Tue Jul 21 19:39:11 2015 UTC,Yes.
rust,3e3a6x,staticassert,1 point,Tue Jul 21 21:04:22 2015 UTC,"That seems really dangerous to me. Why do you want this, just for performance?   Context switching and memory safety seem totally unrelated - rust provides memory protection**, ring separation provides isolation.  ** And not perfect memory protection. It makes promises (not guarantees) about specific types of vulnerability classes."
rust,3e3a6x,desiringmachines,3,Tue Jul 21 21:08:02 2015 UTC,"Memory safety and process isolation are essentially the same thing - keeping a process from accessing resources that don't belong to it. If you know the code won't ever access other process's memory before you run it (which you're right, Rust doesn't actually provide), then other process isolation mechanisms are redundant."
rust,3e3a6x,staticassert,2,Tue Jul 21 21:43:30 2015 UTC,"What I mean to say is that the separation between the kernel and user is not about process isolation, it's about privilege at a hardware level both for security and safety of the devices. That is why we need to change contexts, so that at a hardware level things can happen and that's a lot more than just memory safety.  So, yes, separate address spaces can provide some nice memory isolation and safety, but I'm talking about why we need a separation between kernel and user.  And yeah, it's sort of a moot point because rust security is not infallible and I think it's important to make that really really clear to people who might think that security can be accomplished entirely at the language level.  Which brings me to my original surprise at wanting to put a web server in the kernel - there are better ways to increase performance without putting the entire system's security at the hands of the borrow checker."
rust,3e3a6x,desiringmachines,1 point,Tue Jul 21 22:19:13 2015 UTC,"What could happen at the hardware level if the process can't access resources that don't belong to it?   there are better ways to increase performance without putting the entire system's security at the hands of the borrow checker.   This is where I disagree. A hypothetical provably correct static memory analysis would be inherently better from a performance perspective than runtime checks, because it would be zero cost at runtime. I don't think Rust provides that, but it would be the best solution."
rust,3e3a6x,staticassert,3,Tue Jul 21 22:26:17 2015 UTC,if the process can't access resources that don't belong to it?   What makes you think that a rust process running within the context of the kernel can't access resources that belong to the kernel?
rust,3e3a6x,pcwalton,2,Tue Jul 21 22:28:03 2015 UTC,"if the process can't access resources that don't belong to it?   What makes you think that a rust process running within the context of the kernel can't access resources that belong to the kernel?   I don't think Rust provides a safety model that guarantees this (because of unsafe blocks), I think that its fundamentally possible to provide a safety model like this through static analysis.  I think Rust's model also makes it reasonable to trust yourself to run code you've written in kernel mode if you know enough about what you're doing to have the idea that you could run your code in kernel mode."
rust,3e3a6x,staticassert,4,Tue Jul 21 22:32:01 2015 UTC,"I think Rust's model also makes it reasonable to trust yourself to run code you've written in kernel mode if you know enough about what you're doing to have the idea that you could run your code in kernel mode.   This is, in essence, exactly what I'm trying to discourage - the attitude that you can address security concerns adequately. There are so many reasons why it's far more complex than that. I'll list a few, I guess. To be clear, I love rust.   Rust's memory safety is not a guarantee, it's completely dependent on the implementation of the borrow checker, and to some extent the rest of the build process. A flaw in the borrow checker means 'unsafe' code (kind of an annoying keyword when I think of it, as it implies other code is safe. 'lesssafe' isnt pretty though) could pass as safe. One example of the many things that can go wrong. Rust only attempts to deal with so-many things. Rust won't protect you from making a logical error. The rest of you kernel is not in rust. The rest of your stack is not in rust. You are providing kernel attack surface, and exposing the kernel. Your attack surface is not limited to your webserver.   I can think of other reasons but dinner.  This is not to say no one should put a web server in the kernel. I am just saying don't do it because you think rust will always protect you."
rust,3e3a6x,lurkinsredditacct,3,Tue Jul 21 22:39:16 2015 UTC,"What resources are you talking about, and how would Rust access them? Be specific.   I/O memory mapped registers: Requires unsafe to dereference a raw memory address. Port-mapped I/O: Requires inline assembly, which requires unsafe. Supervisor-privileged instructions: Requires inline assembly. Calling arbitrary kernel symbols: Requires unsafe to call them, and you would whitelist the libraries that you're allowed to link against. Reading arbitrary process memory: Forbidden by memory safety. Performing unprivileged I/O: Protected by library whitelisting.   Rust effectively protects against all of these vectors. Are there any others?"
rust,3e3a6x,pcwalton,1 point,Wed Jul 22 00:52:59 2015 UTC,I was referring to the lack of isolation within the kernel. That's cool that rust can do all of that.
rust,3e3a6x,staticassert,1 point,Wed Jul 22 01:17:32 2015 UTC,"What if instead we absolutely diminish the separation of kernel and user and use encryption schemes to enforce separation/isolation instead.  I think we need to learn that given enough time, humans will find a way.  Instead of putting the eggs in the basket of impenetrable fortress which can only be proven via test of time. We should figure out how to utilize physics itself (rng,crypto) to do these tasks for us."
rust,3e3a6x,pcwalton,3,Wed Jul 22 00:44:10 2015 UTC,"Why is that dangerous?   rust provides memory protection**, ring separation provides isolation.   Is the difference, in your view, that ""memory protection"" means that there's no undefined behavior, and ""isolation"" means that you can't access data of another process and you can't call functions belonging to certain processes?  If so, Rust can effectively provide both by simply restricting which libraries your application is allowed to link to (along with -F unsafe_code of course). You can create a compile-time sandbox in this way.   ** And not perfect memory protection. It makes promises (not guarantees) about specific types of vulnerability classes.   What is the difference between a ""promise"" and a ""guarantee""? Formal modeling? If so, I think your standards are unrealistically high, for reasons outlined in the post above."
rust,3e3a6x,staticassert,2,Tue Jul 21 22:15:55 2015 UTC,"I think I wasn't clear since both you and the other redditor think I'm talking about process isolation, which is a function of the operating system, when I'm talking about isolating the kernel from the user, which is a function of hardware.   What is the difference between a ""promise"" and a ""guarantee""? Formal modeling? If so, I think your standards are unrealistically high, for reasons outlined in the post above.   A promise is, in my mind, weaker. The compiler promises that there are no bugs, but it can only know so much, it's not perfect. Formal standards are not what I'm thinking, I'm not telling you rust isn't good enough, huge improvement, but rust can not guarantee bugless, unexploitable programs. It can make some 'promises' about specific classes of memory corruption vulnerabilities.  As I said to the other user, you're putting the entire system's security all on the borrow checker."
rust,3e3a6x,pcwalton,4,Tue Jul 21 22:26:04 2015 UTC,"As I said to the other user, you're putting the entire system's security all on the borrow checker.   I don't see it that way. I think a more accurate way to phrase it is that we're putting the entire system's security on the likelihood that bugs in the borrow checker will result in programmers accidentally writing applications that are remotely exploitable. That is a much stronger security statement than ""the entire system's security depends on the borrow checker having no bugs"".  Virtually all of the borrow checker bugs (once the system matured) have been found not in real applications but in people explicitly trying to find holes in the borrow checker. To make such a bug dangerous, there are many other steps that have to happen.   The bug in the borrow checker has to be found. The bug has to be shown to be accidentally relied upon in production code. That is, code that should have been rejected was written and deployed. The issue was not a false positive on the part of the borrow checker; it actually constituted memory unsafety. The memory safety issue has to be remotely exploitable.   All four of these steps have to succeed to actually construct an exploit out of a borrow checker bug. Now I'm not saying it's impossible, or that it never will happen. But I think there's a good argument to be made that it's going to be a rare security vulnerability, much less of a problem than security issues arising from straightforward logic errors.  Few people think Golang is insecure due to the Off to the Races use-after-free problem, and that's much worse than almost any of the other borrow check bugs that have been found that I can think of. That's because Google correctly expects that getting the bug through the (2), (3), (4) chain is infeasible in practice."
rust,3e3a6x,staticassert,1 point,Wed Jul 22 01:26:31 2015 UTC,"I don't see it that way. I think a more accurate way to phrase it is that we're putting the entire system's security on the likelihood that bugs in the borrow checker will result in programmers accidentally writing applications that are remotely exploitable. That is a much stronger security statement than ""the entire system's security depends on the borrow checker having no bugs"".   You can break it out into a longer sentence, I don't disagree - it is assuming bugs that allow for vulnerabilities in the borrow checker, libraries, or other areas of the build process.   Virtually all of the borrow checker bugs (once the system matured) have been found not in real applications but in people explicitly trying to find holes in the borrow checker.   Why wouldn't that include a motivated attacker?   To make such a bug dangerous, there are many other steps that have to happen. The bug in the borrow checker has to be found. The bug has to be shown to be accidentally relied upon in production code. That is, code that should have been rejected was written and deployed. The issue was not a false positive on the part of the borrow checker; it actually constituted memory unsafety. The memory safety issue has to be remotely exploitable.   I disagree with 4 - local exploitation is still important. Especially in a kernel service that would give full privileges to a local attacker.  Otherwise, yes, agreed. Those things must be true, never said otherwise. I think I've explicitly stated as much, though perhaps that was another topic or just my imagination.  Of course this is just for attacks involving flaws in the build process. Logical flaws in rust or flaws outside of the scope of its current memory protection won't require bypassing the borrow checker.   All four of these steps have to succeed to actually construct an exploit out of a borrow checker bug. Now I'm not saying it's impossible, or that it never will happen. But I think there's a good argument to be made that it's going to be a rare security vulnerability, and going to be much less of a problem than straightforward logic bugs.   I think it'll be rare until it starts providing an actual barrier for attackers, in which case it'll become less rare. To what degree I am curious, but I don't think we'll ever get there, the borrow checker is  likely not going to be the weak link in the system in my opinion.   Few people think Golang is insecure due to the Off to the Races vulnerability, and that's much worse than almost any of the other borrow check bugs that have been found that I can think of. That's because Google correctly expects that getting the bug through the (2), (3), (4) chain is infeasible in practice.   That's cool. I honestly don't have much interest in Go, I'm not that big of a fan of the language and it's not something I've needed to look into much. I'm a lot more interested in rust.  Rust is cool, I think you're overselling the security benefits, and you're advocating for dangerous architectural choices, using rust as a safety net for otherwise bad behavior. If you want to build that kernel web server though, I think that's great. I just don't think it's going to be as safe as you think. And perhaps we may just have to disagree, at least for tonight.  edit: I've actually wanted to ask for a while but haven't remembered. You've mentioned bugs in the borrow checker, what are they? What is rust's history in terms of potentially dangerous flaws?"
rust,3e3a6x,jkleo1,3,Wed Jul 22 01:32:58 2015 UTC,"I disagree with 4 - local exploitation is still important. Especially in a kernel service that would give full privileges to a local attacker.   Yeah, by ""remote"" I mean ""remote to the kernel""—i.e. local—in this context. Apologies for the imprecise wording :)  I think the part we definitely agree on is that it's not just memory safety that you need. You also need a very careful whitelist of allowed functionality that client applications are allowed to touch and interact with, and this is the hard part. Once you've successfully placed code into a jail, attackers are going to look for holes in the jail. But note that this is the same problem the kernel has to deal with when defending itself against userland applications. We already have such a whitelist that has become reasonably hardened over time—the syscall interface—and that may well be a good place to start."
rust,3e3a6x,desiringmachines,1 point,Wed Jul 22 01:39:55 2015 UTC,"Yeah, by ""remote"" I mean ""remote to the kernel""—i.e. local—in this context. Apologies for the imprecise wording :)   Ah, I see. No problem, and in that case we agree.   You also need a very careful whitelist of allowed functionality that client applications are allowed to touch and interact with, and this is the hard part.   Right, the thing is, I feel like we agree on this, but then you say you want to run with the highest rights possible on the system. You're trying to jail a process that resides within the heart of the system. You're simultaneously assuming that the rust code is safe, while advocating sandboxing it, while advocating building it into the kernel."
rust,3e3a6x,pcwalton,1 point,Wed Jul 22 01:49:43 2015 UTC,"The bug has to be shown to be accidentally relied upon in production code.   In the other place you said that Rust can be used to create a compile-time sandbox but here you are saying that you can't run untrusted code in it, only code which doesn't contain intentional exploits. This is not a sandbox."
rust,3e3a6x,desiringmachines,2,Wed Jul 22 02:05:37 2015 UTC,Unless there's a bug in your unsafe block of course.  But I'm also very optimistic about the potential of different kinds of static analysis to perform process isolation (just that Rust's system isn't enough to trust third party code in Ring 0).
rust,3e3a6x,steveklabnik1,5,Tue Jul 21 21:37:03 2015 UTC,Just forbid unsafe blocks.
rust,3e3a6x,pcwalton,2,Tue Jul 21 22:16:26 2015 UTC,Surely hyper and mio or their dependents make use of unsafe blocks. Do they never allocate a vector?
rust,3e3a6x,dbaupp,7,Tue Jul 21 22:25:01 2015 UTC,"mio at least allocates entirely up front, and then never again. Unsure what they allocate, though."
rust,3e3a6x,valarauk4r,2,Tue Jul 21 22:38:48 2015 UTC,You'd need to whitelist (parts of) the standard library. Basically what core is.
rust,3e3a6x,staticassert,3,Wed Jul 22 01:49:02 2015 UTC,"The standard library is generally assumed to be ""truly safe"" for the purposes of these discussions (i.e. vectors can be allocated), just like the language itself."
rust,3e3a6x,int_index,1 point,Wed Jul 22 00:01:31 2015 UTC,And include overflow checks in release builds ;)
rust,3e5erf,nick29581,1 point,Wed Jul 22 02:24:16 2015 UTC,"No concrete plans yet, but if there is interest, I'd like to have a meetup some time in late August."
rust,3e2y1h,mcguire,3,Tue Jul 21 15:35:58 2015 UTC,"http://doc.rust-lang.org/stable/core/option/enum.Option.html#method.expect isn't unstable, hrm.  Great set of posts! :)"
rust,3e2y1h,steveklabnik1,4,Tue Jul 21 15:57:39 2015 UTC,Result::expect is probably what they were referring to.
rust,3e2y1h,dbaupp,3,Tue Jul 21 16:43:29 2015 UTC,ahh
rust,3e2y1h,steveklabnik1,2,Tue Jul 21 16:47:25 2015 UTC,"Most likely, but I've been using 1.1 stable, which doesn't have Result::expect at all. Maybe I misread the error and then looked at the wrong docs. I dunno."
rust,3e2y1h,Sinistersnare,3,Tue Jul 21 17:08:41 2015 UTC,"Ah, er, what? I swear, it....  I've got nothin'. I'll fix it."
rust,3e2y1h,arthurprs,3,Tue Jul 21 17:06:28 2015 UTC,"On the plus side, Java is pretty close to Rust, raw performance-wise."
rust,3e2y1h,Sinistersnare,4,Tue Jul 21 17:17:25 2015 UTC,"Hotspot is absolutely insane. I wouldn't expect raw performance to be extremely different between the two, but you definitely are correct about RAM usage :)"
rust,3e0drc,brson,4,Tue Jul 21 00:04:46 2015 UTC,I gotta take better care of my git config.
rust,3e0drc,arthurprs,1 point,Tue Jul 21 12:21:30 2015 UTC,More macro freedoms! Baby steps :)
rust,3e2y9i,heyPerseus,6,Tue Jul 21 15:37:32 2015 UTC,You can call Rust applications from Java the same way you can call C/C++ applications from Java - though I guess you would have to still write a small C-Rust adaptor because Rust on its own won't understand the Java-C FFI header files.
rust,3e2y9i,Kimundi,2,Tue Jul 21 15:42:20 2015 UTC,"JNI isn't the only solution. https://github.com/bytedeco/javacpp lists some alternatives, such as https://github.com/twall/jna  With JNA you generally don't need an adaptor, AFAIK."
rust,3e2y9i,Artemciy,1 point,Tue Jul 21 16:19:30 2015 UTC,"Exporting a C compatible interface from a Rust lib and calling it from JNA should be straight forward, it would be my first choice."
rust,3e2y9i,fullouterjoin,1 point,Wed Jul 22 02:30:02 2015 UTC,Java-C FFI   Is this an external library that hooks into C?
rust,3e2y9i,UtherII,1 point,Tue Jul 21 16:04:15 2015 UTC,The official tool to link Java with C code is JNI.  There are libraries (JNA for instance) to do it too without writing wrappers in C code
rust,3e2y9i,mrmonday,3,Tue Jul 21 16:36:17 2015 UTC,"There are several techniques for calling Rust from Java, you should take a look at these as a starting point:   https://en.wikipedia.org/wiki/Java_Native_Interface - This technique involves writing code specifically for interacting with Java from Rust https://en.wikipedia.org/wiki/Java_Native_Access - This enables you to simply expose your Rust functions directly to Java   Both of those specifically talk about C and C++, but the same techniques still apply. Those, in combination with the FFI chapter of the book, should get you most of the way.  The scenarios where you might want to do this include:   Any time you'd want to write C/C++ code to be called from Java, but would rather use Rust If you have some performance critical code which would benefit from being written in Rust rather than Java (note that it may end up slower, due to the overhead of entering/leaving the VM, marshalling/un-marshalling values, the fact the VM can't do any fancy optimisations the second the native code is touched) If there's a cool Rust library you want to interact with, for which there is no Java equivalent If you have an existing Java application which you're gradually migrating to Rust   Hope this helps."
rust,3e2y9i,mrmonday,1 point,Tue Jul 21 16:23:38 2015 UTC,"Yes this totally lays it out. Thank you, this helps me out.  I'm going through the book now, but haven't gotten to the FFI part.  It's a decent guide.  Hypothetically, do you think I would have better performance using Rust from python vs java since it doesn't run on a vm?"
rust,3e2y9i,shepmaster,1 point,Tue Jul 21 16:35:27 2015 UTC,"Python does run on a VM, so would have similar problems. They are likely to be less noticeable though, since the VM is no way near as advanced as the JVM. You'll notice it's very common to write performance critical code for Python in C or C++, whereas it is typically written with Java, for Java (see scipy/numpy, for example). There are actually examples of using Rust from Python in the book, if you're interested in that."
rust,3e2vmz,onemoredawn,5,Tue Jul 21 15:18:20 2015 UTC,"I prefer the former because  1) the patterns are visually clearer.  2) if I change the function to get x as a value, simply removing * from the head expression is sufficient.  I'm not sure of the convention, though."
rust,3e2vmz,barosl,5,Tue Jul 21 15:34:26 2015 UTC,"Afaik thats also the convention, for exactly those reasons."
rust,3e48mk,leemobile,3,Tue Jul 21 20:55:55 2015 UTC,Are you sure a regular expression wouldn't be better? The regex crate documentation shows an example that is similar to what you're doing.
rust,3e48mk,pingveno,2,Tue Jul 21 21:10:49 2015 UTC,That or nom are the Right Answers for sure.
rust,3e48mk,steveklabnik1,1 point,Tue Jul 21 21:19:09 2015 UTC,"Awesome, thanks!"
rust,3e48mk,steveklabnik1,3,Wed Jul 22 00:39:53 2015 UTC,"You can do this already:  &date[0..4]   However, these are byte indexes. It'll panic if the slice doesn't correspond to valid codepoints."
rust,3e48mk,arthurprs,2,Tue Jul 21 21:06:52 2015 UTC,"Use the slicing syntax (don't forget the &)  let date = ""20150721"";  let year = &date[0..4];  you can try it here http://is.gd/WVaYX7"
rust,3e0i5q,kingkilr,4,Tue Jul 21 00:40:50 2015 UTC,"Having come from Haskell, I feel like I take things like cargo for granted when I read articles like this."
rust,3e0i5q,VyseofArcadia,5,Tue Jul 21 15:40:14 2015 UTC,"OMG, Cabal tilts me to no end. Why does it seem like the dependencies are ALWAYS the wrong version? They don't even compile half of the time..."
rust,3e0i5q,iopq,2,Tue Jul 21 16:54:24 2015 UTC,"I had a similar experience with Cabal... Loved Haskell, but I can't stand Cabal."
rust,3e0i5q,formode,2,Tue Jul 21 19:05:12 2015 UTC,I've not had a single issue (other than soul crushing compile times) since moving everything to sandboxes.
rust,3e0i5q,Watley,10,Tue Jul 21 23:26:59 2015 UTC,"While Rust has many amenities, like cargo, racer (+integration), very good compiler diagnostics (that nonetheless get improved with each version, kudos to the responsibles!), lints, etc., there is still much room for improvements and integration.  I have said it before on numerous occasions, a full-featured Rust IDE would make Rust programming both very powerful and very ergonomic. But I trust that it will come in time."
rust,3e0i5q,llogiq,7,Tue Jul 21 08:30:16 2015 UTC,Losing cargo is undoubtedly the hardest thing to me about going back to writing Python when I'm coding for fun.
rust,3e24gl,hoodinie,1 point,Tue Jul 21 11:02:05 2015 UTC,Maybe Hyper is close to what you're looking for. https://github.com/hyperium/hyper  Its a pretty raw HTTP server written in rust. But I'm pretty sure you can use it make decisions and serve JSON with next to no modifications. Likely too low level though.
rust,3e24gl,valarauk4r,2,Tue Jul 21 12:11:38 2015 UTC,"I think go-kit is a bit more high level than that. It provides common interfaces for things like logging, rate limiting, load balancing, tracing, RPC with pluggable transports, metrics, circut breaker, logging.. There's a changelog podcast episode about it here http://5by5.tv/changelog/163  Maybe we should start a rust-kit org, and start porting the go code to rust :)"
rust,3e1xgy,llogiq,8,Tue Jul 21 09:25:58 2015 UTC,"I use https://github.com/huonw/travis-cargo, eg https://github.com/cmr/evdev/blob/master/.travis.yml"
rust,3e1xgy,cmrx64,1 point,Tue Jul 21 11:19:20 2015 UTC,Very cool! I'm going to steal this. :-)
rust,3e1xgy,formode,2,Tue Jul 21 11:25:14 2015 UTC,Travis-cargo is fantastic!
rust,3e1xgy,shepmaster,1 point,Tue Jul 21 19:06:48 2015 UTC,Full ack – I just tested it with great success. Now if only I could get my build to include the unstable features only on nightly...
rust,3e1xgy,KokaKiwi,2,Tue Jul 21 19:12:31 2015 UTC,This is how I do it- with custom features  https://github.com/shepmaster/sxd-document/blob/master/.travis.yml
rust,3e1xgy,stebalien,1 point,Tue Jul 21 19:53:22 2015 UTC,Thanks – that should solve my features problem nicely.
rust,3e1xgy,SirOgeon,4,Tue Jul 21 20:15:37 2015 UTC,"Personally I use a self-made shell-script which basically switch to gh-pages branch, build doc, remove unnecessary folders and commit it (it doesn't automatically upload it because it doesn't necessarily know the remote name).  If you want to see the script: https://gist.github.com/KokaKiwi/13bec50d1f929b1a2e11"
rust,3e1xgy,steveklabnik1,1 point,Tue Jul 21 09:47:49 2015 UTC,Thanks! I think I will do this manually for now until I'm somewhat comfortable with it.
rust,3e0ci8,shepmaster,7,Mon Jul 20 23:54:35 2015 UTC,This looks like it'd be a good example of extremely low level programming in Rust. The source was quite pleasant to read.
rust,3e0ci8,isHavvy,3,Tue Jul 21 03:00:19 2015 UTC,"Thank you, that's very kind! I try hard to maintain readability while keeping DRY, so it's good to know that someone else is able to read the code I wrote and understand it"
rust,3e0ci8,zgerd,5,Tue Jul 21 12:53:12 2015 UTC,"For reference, there's already a crate called cpuid, but it's a wrapper for libcpuid, the C library. There are some other crates that also allow access to the same information. Unfortunately for me, it looks like another crate even sprang into existence between when I surveyed the landscape a few weeks ago and when I got far enough to publish about it... It used to be marked as deprecated, so I wrote my own. I guess that author decided to resurrect the project."
rust,3e0ci8,deadstone,1 point,Tue Jul 21 02:17:57 2015 UTC,"Hi! Aw.. I'm author of raw-cpuid and I just saw this thread.  You're right, I decided to resurrect raw-cpuid a few days ago due to lack of alternatives that are natively written in rust. So that was basically very unfortunate timing on our part :), otherwise we could have shared the effort easily :) (but we still can). My implementation is currently complete at least according to Intel manual but I have not looked at AMD yet."
rust,3e0ci8,kehtnok,4,Tue Jul 21 19:54:17 2015 UTC,"You could mention that it only runs on nightly.  Also, it looks like every method on cupid::Master consumes the struct? Doesn't that make it impossible to run more than one query?  Edit: Yup."
rust,3e0ci8,steveklabnik1,3,Tue Jul 21 08:52:04 2015 UTC,"From someone just beginning to look at Rust, what steps could s/he take to make sure the struct isn't moved?"
rust,3e16ou,dugusword,13,Tue Jul 21 04:07:44 2015 UTC,"Rust can't statically guarantee that src and dest refer to different objects, for two reasons:  1) The arguments for the two get_mut calls might have the same value – not in your minimal example, but in the following, more general function they might:  fn f(from: &str, to: &str) {     let src = nodes.get_mut(from).unwrap();     let dest = nodes.get_mut(to).unwrap();     src.transfer(dest, 50.0); }   2) Rust doesn't know about the semantics of the BTreeMap. For instance, get_mut might return the same reference for ""A"" and for ""B"".  The simplest solution that doesn't involve refactoring the Node::transfer function is probably to use Cell<Node> or RefCell<Node> as element type for the BTreeMap."
rust,3e16ou,rmrfslash,8,Tue Jul 21 04:43:18 2015 UTC,"The simplest solution I've found for cases like this is to replace one of the values in question, make the change, then replace back.  If having dummy values floating around makes you nervous (like it does for me), stick this logic in a function that does all of what I've just described, and invokes a closure with the two &muts.  That way, it's impossible to access the ""dummied-out"" collection accidentally."
rust,3e16ou,Quxxy,1 point,Tue Jul 21 05:04:25 2015 UTC,http://is.gd/hUXCtn  See comments in there.
rust,3e16ou,acdenh,4,Tue Jul 21 13:56:22 2015 UTC,"I would seriously advise against the pointer-based solutions, because you disable the borrow checker. One day you or someone else using your code will forget about the restriction that it might not work if both source and destination are the same element, and Bad Stuff might happen."
rust,3e16ou,rmrfslash,1 point,Tue Jul 21 14:21:56 2015 UTC,"The last method I put in there does not do anything unsafe at all, and that is the only one I was recommending...  But it depends on context, if it can be encapsulated properly then using raw pointers is not an issue.  Just for fun, because I am still learning this language, and I was wondering how hard it is to properly do this encapsulation thing, I have upgraded the UnsafeGetter into one that gives an error whenever a duplicate is requested, and does not compile if there is a external borrowing conflict.  http://is.gd/EbyvPT  I doubt this thing is actually sufficient to actually be totally safe, since if BTreeMap moves any of those pointers around it stops working, although usage of the BTreeMap is blocked so long as the MutGetter is borrowing it..."
rust,3dz7mz,jessypl,4,Mon Jul 20 18:53:31 2015 UTC,"I missed this for the first 4 posts. I've read through the first and 2nd posts so far, I like your style. Perfect amount of explanation without flying through an example."
rust,3e000u,saposcat,9,Mon Jul 20 22:16:58 2015 UTC,"I did make https://github.com/contain-rs/cons-list on a lark. It's as slow as you'd expect.  See also https://github.com/Gankro/collect-rs/issues/14  Part of the problem with persistent collections is you have to answer the question ""why the heck do you want this"". Some totally single-threaded algorithms can be legitimately more efficient (in time and space) because of persistence (I'm pretty sure... It's been so long...). That's a great motivation.  However you might also just want it so you can think immutably or whatever or maybe just share data ""more easily"". That's less great of a motivation in Rust IMHO, because we have ownership and stuff to have really nice safe shared state. Basically, Rust isn't actually very functionally minded. It steals some of the cool ideas, but it's mutable and procedural at heart. Happy to hear arguments otherwise (end of the day and kinda drained so I'm in a bit of a negative mood >:D).  Much like concurrent data structures, lack of ""real"" GC hurts here regardless."
rust,3e000u,Gankro,3,Tue Jul 21 00:35:49 2015 UTC,"Basically I see value in persistent data structures for their avoidance of race conditions under shared-memory parallelism. Unfortunately, without the parallelism scheduling that bolsters functional languages, lots of these benefits may not manifest in rust, other than hand-coded stuff or other libraries being written... or atomicity of some sort built into the methods on the persistent data structures.  I'm currently actually doing my research on using algebraic information to avoid race conditions under write contention, and I'm using lots of ideas from persistent data structures to do it. Basically I'm implementing transients that are performance-tuned for multiple simultaneous write situations. Any stale reads performed by a process due to a data race will be pre-empted or retroactively addressed, depending on the exact ordering of operations. The trick is to ""register"" the operations that are going to performed on the locations storing data that might experience a data race. Properties of those operations (mostly combinations of basic things like transitivity/associativity/commutativity/distributivity intended to address certain kinds of staleness) allow this to happen. You can also do operation regrouping to try to draw out nicer properties -- subgrouping operations cleverly might allow those subgroups to have nice properties, where the individual ones themselves might not. Sometimes things do really have to happen in a prescribed order.  The trick is to avoid wasting space if possible. And knowing how to write code and redesign algorithms to draw out parallelism in the first place. Parallelism isn't easy, not even in 2015."
rust,3e000u,xthecharacter,3,Tue Jul 21 05:26:13 2015 UTC,"I did make https://github.com/contain-rs/cons-list on a lark. It's as slow as you'd expect.   Because you're using the generic allocator for it. Ask any Lisp implementer how they are allocating conses and they will say ""an arena, of course.""   See also https://github.com/Gankro/collect-rs/issues/14   There was a good discussion there. I don't know why you closed it.   Part of the problem with persistent collections is you have to answer the question ""why the heck do you want this"". Some totally single-threaded algorithms can be legitimately more efficient (in time and space) because of persistence (I'm pretty sure... It's been so long...). That's a great motivation.   That is a good question. I don't actually think there are a lot of good reasons for persistent collections, unlike most people who like them. There are a few, however. Shared mutable memory among a lot of threads is easy to do atomically with a persistent data structure. You simply perform some operations on the root node, and do an atomic compare and swap with the pointer you stored before you attempted your transaction. I'd be interested in a global, atomic hash map (as a registry).  Auto-logging state is an excellent idiom in Clojure. You just store pointers to old nodes (no expensive copies necessary). If you have a long running analytics program that you need to run over a large data structure in real time periodically that you're simultaneously modifying... wouldn't you want a persistent data structure?  But mentions of memoization and ""free parallelism"" are not convincing to me.   However you might also just want it so you can think immutably or whatever or maybe just share data ""more easily"". That's less great of a motivation in Rust IMHO, because we have ownership and stuff to have really nice safe shared state. Basically, Rust isn't actually very functionally minded. It steals some of the cool ideas, but it's mutable and procedural at heart. Happy to hear arguments otherwise (end of the day and kinda drained so I'm in a bit of a negative mood >:D).   I would very much disagree with you. Rust is 2 steps away from SML and 100 steps away from C++ in most ways.   Much like concurrent data structures, lack of ""real"" GC hurts here regardless.   We need something in between real garbage collection and atomic reference counting. Namely, a Cons or Node arena with Arc's to internal pointers. But there are no cyclic data structures as Rust is not lazy, so we can get away with reference counting in general and if you combine that with pre allocated object pools, that smells like really fast code. Trees that are potentially faster to create and use and copy than std's collections."
rust,3e000u,Gankro,1 point,Tue Jul 21 08:13:37 2015 UTC,I closed the issue just because the repo is defunct in favour of https://github.com/contain-rs/
rust,3e000u,genneth,3,Tue Jul 21 16:53:36 2015 UTC,Persistent structures without (concurrent) garbage collection seems like something with very niche uses.
rust,3e000u,fullouterjoin,2,Tue Jul 21 10:18:51 2015 UTC,I would add https://github.com/nikomatsakis/dogged
rust,3e0px3,noclaf,3,Tue Jul 21 01:44:20 2015 UTC,"The Rust Programming Language specifically does not assume you know C++. If anything is assumes too much still, please let me know. :)"
rust,3e0px3,steveklabnik1,1 point,Tue Jul 21 03:28:28 2015 UTC,"Not the language, a few tutorials I've attempted to read.   Please note that I'm interested in rust only out of curiosity. Which means I haven't tried very hard to get through the tutorials.  I do realize that pointers, references, copy constructors and the like are freshman level topics. However, freshman year was a LONG time ago. I've simply forgotten the difference between *var and &var. I'm sure there are plenty of others in a similar situation.  I'm sure there are plenty of c++ programmers looking to keep their performance gains, yet take advantage of greater type safety. I'm in the camp where I'm looking to experiment with code much closer to the machine, but have been put off by c and c++ (the languages, not their lowlevelness)."
rust,3e0px3,mbrubeck,8,Tue Jul 21 04:03:55 2015 UTC,"steveklabnik is referring to The Rust Programming Language, the official Rust book (of which he is the main author).  It's very brief, but you might be interested in Rust for Python Programmers."
rust,3e0px3,steveklabnik1,5,Tue Jul 21 04:24:15 2015 UTC,"No, I mean http://doc.rust-lang.org/stable/book/ . You will probably want to go the ""Syntax and Semantics"" route, I'd bet."
rust,3dy7u5,Chaigidel,6,Mon Jul 20 14:39:47 2015 UTC,"See goimports, which does something like this, I think. I think this should be an external tool and not a language feature."
rust,3dy7u5,pcwalton,3,Mon Jul 20 15:42:26 2015 UTC,"Yeah, ""like goimports"" seems to cover what I'm after pretty well. Definitely a separate command line tool, the use case doesn't really fit how you use either cargo or rustc, but it would need to be pretty cozy with the machinery used by both of them."
rust,3dy7u5,steveklabnik1,3,Mon Jul 20 18:06:07 2015 UTC,"You can extend cargo with arbitrary commands, so I'd just make it cargo-imports or whatever."
rust,3dy7u5,Aatch,1 point,Mon Jul 20 20:12:26 2015 UTC,"Yeah, I thought about whether this should be a cargo command, but it feels ergonomically odd when all of the current cargo operations apply to the whole project and I'd want imports (uses?) to always target a single source file because of the potential user interaction required. Might still be worth a shot just adding it to cargo since it would need to do all sorts of cargo-integrated thing like crawling the linked packages anyway."
rust,3dy7u5,staticassert,1 point,Tue Jul 21 04:10:59 2015 UTC,"It wouldn't need any integration with cargo. All the dependent crates are already listed in the source as extern crate lines. Integration with rustc is enough, since it can just search the available names in the current and linked crates."
rust,3dy7u5,awo,1 point,Wed Jul 22 00:12:32 2015 UTC,What other things? Curious because I've been off of IDE's for so long.
rust,3dy7u5,Arrem_,12,Mon Jul 20 14:54:56 2015 UTC,"Big deal features that I use in Java IDEs are things like 'find me all the places this method gets called'.  You can do a poor man's equivalent using grep, but it's nowhere near as good - being able to traverse up the call hierarchy, for example, is wondrous when you're working on a big gnarly codebase."
rust,3dy7u5,grayrest,5,Mon Jul 20 17:30:17 2015 UTC,Or the go to method/field declaration feature. Always saves a lot of time.
rust,3dy7u5,staticassert,1 point,Mon Jul 20 18:17:59 2015 UTC,"There's a ctags module for rust that gets you that, isn't there?"
rust,3dy7u5,llogiq,7,Mon Jul 20 19:35:05 2015 UTC,I would like snippet expansion of impl signatures and struct instantiation (?)  where the compiler knows the names/signatures of what it wants and I shouldn't have to find or remember them.
rust,3dy7u5,dobkeratops,1 point,Tue Jul 21 04:13:43 2015 UTC,"Oh, nice. Yeah, that would be cool."
rust,3dyz9l,steveklabnik1,2,Mon Jul 20 17:56:04 2015 UTC,"Now that I have logged in and toggled the switch for one of my repos, what does this website actually do?"
rust,3dyz9l,tomaka17,3,Mon Jul 20 18:03:18 2015 UTC,"I'm assuming that this is mentioned as a replacement for rust-ci, which would trigger a Travis rebuild every time a new Rust nightly was available. Pre-1.0, this was quite useful to make sure your code still worked on the latest Rust, due to all of the breaking changes, but post 1.0 it looks like rust-ci bitrotted and is no longer triggering builds.  Now, while if you use the stable channel compilers, you should only be using stable features which aren't broken, this is still useful for crates that still only build on nightlies due to using unstable features, as well as being useful for keeping the Rust team honest, by making sure that the nightly doesn't actually break any stable features you are relying on. While Crater is also intended for this purpose, it may be more useful for a crate author to be able to be notified based on their own build infrastructure, maybe due to the crate not building on Crater for some reason, or just for someone with more experience with the crate in general to be able to tell if a failure indicates a compiler regression or just a bug in the crate itself."
rust,3dyz9l,annodomini,1 point,Mon Jul 20 18:35:14 2015 UTC,"Does anyone know what happened to Rust CI? It stopped triggering builds a long time ago indeed.  I think a site like Rust CI would be a great way to increase Crater coverage, because both programs and libraries use CI. Uploading programs to crates.io without any purpose except to increase Crater coverage feels like a hack to me."
rust,3dyz9l,Ruud-v-A,2,Mon Jul 20 22:47:43 2015 UTC,"Every hour, if your project hasn't had a build in the last day it will trigger one."
rust,3dyz9l,coderanger,1 point,Mon Jul 20 18:09:50 2015 UTC,"""Last"" day?"
rust,3dyz9l,Enamex,1 point,Mon Jul 20 19:54:41 2015 UTC,"""Has been >= 23.5 hours since the last build."""
rust,3e09gn,ExPixel,2,Mon Jul 20 23:29:48 2015 UTC,http://doc.rust-lang.org/stable/std/macro.concat_idents!.html ?
rust,3e09gn,steveklabnik1,2,Tue Jul 21 00:39:31 2015 UTC,"Yeah, but concat_idents! is practically useless.  I'm yet to find a practical case where you really need it.  The only one I can think of is something like this:  #![feature(concat_idents)]  macro_rules! call_foo_with_4 {     ($suffix:ident) => {(concat_idents!(foo_, $suffix))(4)}; }  fn main() {     call_foo_with_4!(bar); }  fn foo_bar(v: i32) { println!(""{}"", v); }   But I've never actually needed to be able to do that.  I have needed to generate symbols with constructed names, but concat_idents! can't be used for that.  The ""stuff into a tt* then extract again"" trick doesn't help because you just end up with the original macro expression again.  So far as I know, the solution to this is: (macros have to change to let you expand to idents && (the AST has to change to allow expansions in ident position || we get a way to eagerly expand a macro (maybe double !s?))) || we get a native syntax for concatenating idents."
rust,3e09gn,Quxxy,3,Tue Jul 21 04:50:05 2015 UTC,I remember being all excited about concat_idents! until I tried to use it.  It makes me sad.
rust,3e09gn,bytemr,1 point,Tue Jul 21 14:46:19 2015 UTC,"What I would like is for rustc to allow the invocation of macros in declaration names and impl/attributes lists. This way, we could simulate Ruby's attr_reader/writer/..., between other awesomeness."
rust,3e09gn,jessypl,1 point,Tue Jul 21 05:20:41 2015 UTC,"The problem is that macros aren't a separate pass like they are in C.  They are explicitly represented as nodes in the AST.  Thus, they can only appear in positions that explicitly support them.  When it comes to names of things, those are represented by an Ident which is basically just an interned string; no other variants.  If you changed it so that you could have either an Ident or macro invocation, a huge pile of code that relies on names always just being strings would suddenly break.  I don't know how big the fallout would be, but I certainly wouldn't want to be the poor sod trying to implement it."
rust,3e09gn,Quxxy,2,Tue Jul 21 05:25:38 2015 UTC,"It doesn't seem to work with concatenating identifiers in order to create a function name.   For instance when I try to compile this:  macro_rules! thing(     ($fprefix:ident) => (         pub fn concat_idents!($fprefix, _thing)(n: u32) {             println!(""Did the thing: {}"", n);         }     ) );  thing!(hello);  fn main() {     hello_thing(7); }   I get the following compiler error:  <anon>:3:29: 3:30 error: expected one of `(` or `<`, found `!` <anon>:3         pub fn concat_idents!($fprefix, _thing)(n: u32) {"
rust,3e09gn,Hytosys,1 point,Tue Jul 21 02:02:27 2015 UTC,"I feel like I plug my own work too often, but: iterpolate_idents GitHub/crates.io. Requires nightly (it's a compiler plugin)."
rust,3dvytp,plumshark,9,Mon Jul 20 00:02:37 2015 UTC,Nice!  /u/kibwen has an idea for a way to do this that can work cross-crate (by only generating crate metadata and using it for the next crate).
rust,3dvytp,Manishearth,7,Mon Jul 20 04:22:26 2015 UTC,"Oops, I forgot about it."
rust,3dvytp,eddyb,6,Mon Jul 20 04:29:38 2015 UTC,Nice! mach cargo check -p script takes 59 seconds for Servo on my laptop. Compare with 121 seconds for mach cargo build -p script.
rust,3dvytp,SimonSapin,4,Mon Jul 20 07:05:34 2015 UTC,You know what would make this 10x better?  If it played nice with cargo-watch.  Ie: re-run cargo check automatically when source files are changed.
rust,3dvytp,aiij,3,Mon Jul 20 18:14:27 2015 UTC,"I feel the same about the rust linter for SublimeText... waiting for code generation almost defeats the convenience of the integrated error hilighting.  Brings up questions about how to throw these tools together in an optimized way. Cargo check, for example, is unofficial and could in the future be hypothetically competing with different tools for the same purpose, or perhaps used alongside other tools that cause redundancy. What is a good way to make sure these things work together moving forward? It probably doesn't need to be stated how important good tooling is..."
rust,3dvytp,steveklabnik1,2,Mon Jul 20 19:27:09 2015 UTC,"You'd want cargo-watch to be able to run an arbitrary cargo command on rebuild, rather than hardcoding build."
rust,3dvytp,cmrx64,4,Mon Jul 20 20:11:38 2015 UTC,Now rest_easy can rest easy.
rust,3dvytp,w8cycle,2,Mon Jul 20 13:01:09 2015 UTC,Yes! I have been wanting this for a while!
rust,3dvytp,deadbead0101,1 point,Mon Jul 20 03:54:15 2015 UTC,\o/  Excellent news.
rust,3dxkee,Gustorn,2,Mon Jul 20 10:48:40 2015 UTC,Why don't you use a slice – you can check its length at runtime.
rust,3dxkee,llogiq,2,Mon Jul 20 12:08:58 2015 UTC,"Because I don't necessarily want to construct a slice to pass in. This would handle slices, but also cases where I can get by using only iterators to get the parents I need. If I only accepted slices I'd have to store the parents before passing them in."
rust,3dxkee,chris-morgan,2,Mon Jul 20 12:49:45 2015 UTC,"A tiny bit of feedback on the bits shown (and please show more, it’s hard to judge without it):  T: Borrow<T> is a completely meaningless bound; there exists impl<T> Borrow<T> for T where T: ?Sized, so all types implement Borrow<T>.  Also consider Borrow vs. AsRef; on the code shown, it looks like AsRef may be more appropriate. (If not, you may well want to mesh ToOwned stuff in there instead of Clone for T. Hard to judge without more code.)"
rust,3dxkee,tafia97300,1 point,Mon Jul 20 12:10:53 2015 UTC,"You are absolutely right about T: Borrow<T>, it was a leftover from some earlier experiments. As for Borrow vs AsRef: the goal was to accept either T or &T, and as far as I know Borrow is the right trait for that (but ToOwned might be a better option, I'll look into it).  EDIT: Added a stripped down example to OP."
rust,3dwzq5,BigCheezy,5,Mon Jul 20 05:56:40 2015 UTC,"Just explicitly forward the mutable reference to A into B's method. That's the way of explicitly requiring it to happen.  You tell me the types but not the values. Say that we have a struct type A called a1 and it contains a child reference to a struct type B called b1, and then b1 has a weak reference to another type A struct called a2. Is this possible?  If it isn't then don't make the child be Rc<B> make it just B to make it clear that each B belongs to a specific A.  impl A {     fn first_call(&mut self) {         child.b_call(self)     }     fn second_call(&mut self) {         // bla bla     } }  impl B {     fn b_call(&mut self, parent: &mut A) {         parent.second_call()     } }   Also how did you get a &mut B from an Rc<B>? You can only get a &B from a Rc<B> the only way to get a mutable handle is using make_unique which will copy unless you have a single Rc which only matters when A is the only owner. Notice that altering this value will not affect the other existing ones.  If this wouldn't work please tell me more about what you are trying to do to solve your problem."
rust,3dwzq5,lookmeat,1 point,Mon Jul 20 07:07:50 2015 UTC,"Yes, I was eliding many of the details, thanks for the catch! I was thinking ahead to my second example with RefCell when getting the &mut from the Rc. Forwarding the parent pointer doesn't scale. For instance, if A calls B calls C calls B calls A, we have to plumb the pointers very far down the call stack. Assuming C doesn't even know what an A is, it doesn't make sense for it to take &mut A in its signature.  Would it help if I provided some C++ code of this pattern? It is fairly common in async code."
rust,3dwzq5,lookmeat,1 point,Tue Jul 21 03:11:39 2015 UTC,"Would it help if I provided some C++ code of this pattern? It is fairly common in async code.   Not just the pattern, but also the exact context you want to use it. I can think of a few ways of mapping the pattern, but the best one would depend on what exactly you are trying to use."
rust,3dwzq5,lookmeat,1 point,Tue Jul 21 04:54:48 2015 UTC,"Context: async IO processing. Top level handlers receive events and pass messages to listeners. The listeners may want to immediately pass another message back up the callback chain to update state.  Contrived quick example I threw together ( http://cpp.sh/6kxv ):  #include <memory>  class CodecParent { public:     virtual void codecFinished() = 0;     };  class Codec { public:     Codec(CodecParent& parent): parent(parent) {}     void onIngressBytes(char* buf, size_t len) {         // process bytes, update any listeners, etc.         parent.codecFinished();     }  private:     CodecParent& parent; };  class Reader: public CodecParent { public:     void onBytesRead(char* buf, size_t len) {         numReads++;         codec->onIngressBytes(buf, len);     }     void codecFinished() override {         codec = nullptr; // delete the codec     } private:     size_t numReads{0};     std::unique_ptr<Codec> codec{std::make_unique<Codec>(*this)}; };  int main() {     // Pretend main() is dispatching ala epoll     Reader reader;     reader.onBytesRead(nullptr, 0); }"
rust,3dwzq5,lookmeat,1 point,Tue Jul 21 05:24:48 2015 UTC,"This is a bit more complicated and I'd have to sit down to think on this hard. My instinct (and advice for now) is to look at mio and libraries that use it, since they use the event loop method.  To answer your question. What you propose is very dangerous, and problematic. It makes it hard to reason about code. This doesn't mean that it's impossible to make things efficient, there might be solutions that are being ignored.  To put in your example, you are deleting an object before you exit the method, which leaves a this pointer dangling. The pointer could be used in unpredictable manners (for example a destructor to some object on the stack in the previous lines might depend on this reference). It becomes impossible to be certain that it works without observing it, which makes it a dangerous pattern. At this point we might be mutating data after getting a non mutable reference, since the code is already doing more than is immediately obvious."
rust,3dwzq5,lookmeat,1 point,Tue Jul 21 06:35:28 2015 UTC,"Yup! You've exactly identified the danger! However, this code actually uses the pattern correctly and safely. It is perfectly fine for this to be deleted while its method is on the stack as long as the rest of that function doesn't touch any member variables. This seems right up the alley for Rust's lifetime system, however, I haven't been able to express this with Rust's borrow checker (yet).  I have firsthand experience with C++ programs where immediately calling back enables lower latency and higher throughput in high performance proxies. Originally, the code delayed the update until the next event loop, which was less efficient."
rust,3dwzq5,lookmeat,1 point,Tue Jul 21 07:12:08 2015 UTC,"BTW I just realized that you are the author of mio, sorry I didn't realize before.  This is a harder problem, because it is unsafe, and doubly so in Rust. In C++ everyone expects things to be crazy so there's a lot of limitation in what you can do, in Rust those limitations are changed by the borrowing requests.  I think that the best solution is to use runtime borrow checking, RefCell from the start (or inject it last second). I don't have a lot of time right now, but I will come back with some code later on to show what I think could work."
rust,3dwzq5,nwin_,1 point,Tue Jul 21 16:29:41 2015 UTC,Haha I'm not the author of mio! I have worked extensively in that space however. I'm a rust newcomer with extensive c++ async networking experience.
rust,3dwzq5,nwin_,1 point,Wed Jul 22 02:16:29 2015 UTC,"I think I got a potential solution right here it compiles with a few warnings of unused stuff, but the borrow checks out and it doesn't panic.  The code looks uglish, but it's doing ugly stuff and should feel dangerous and not elegant IMHO.  There's a minor cost and the code could panic if at any time you do something you shouldn't. In the C++ code there's a minor cost of virtual functions which I've repeated here (in an attempt to look as much as the code you gave). I'm still doing the forwarding oneself at call (but I'm willing to later offer a solution that doesn't need this if you still need it) but I've made it now happen by extending the struct itself. The main reason is to avoid potential Rc cycles which would lead to memory leaks. Probably more clever solutions can be built on this, but I hope it's a start."
rust,3dwzq5,sellibitze,1 point,Tue Jul 21 17:38:22 2015 UTC,"Oh one more thing. You are moving self into the adopted_child but you could ""recover"" it by calling adopted_child.parent.into_inner(). Notice that this will return an object of type &ReaderParent while self was originally a &Reader. You can fix this by making CodecWParent use a template argument instead of object (plus you get static dispatch). The whole idea is that you have to ""pull self out"" in order to keep using it."
rust,3dwzq5,nwin_,1 point,Tue Jul 21 21:40:56 2015 UTC,"If A calls B as the very last line of its function body, then it should be safe for B to call back into and modify A.   If that is the case, then all you have to do is to manually drop the Ref to child in A before calling a method of B."
rust,3dwzq5,nwin_,1 point,Mon Jul 20 06:11:00 2015 UTC,"Do you mean dropping the ref to self before calling B from A? Because otherwise, A is still borrowed while B runs, so I'm not sure how B would be able to call into A."
rust,3dwzq5,diwic,1 point,Mon Jul 20 06:29:03 2015 UTC,"No, I meant dropping the Ref you got by borrowing your RefCell. You also cannot afford to borrow A mutable in B.  impl A {     fn call_b(&self) {         // This cannot be `&mut self`. Thus you need to put everything you want to         // change into a RefCell.         let ref = self.other_data.borrow_mut();         // ....         drop(ref);         self.child.do_something() // Do not call self.parent.borrow_mut() in do_something() this will crash. Just use RefCells     } }"
rust,3dw7l0,mauriciolinhares,6,Mon Jul 20 01:21:17 2015 UTC,"Never battle-tested, but I switched to mio in my toy IRC server  a while a go. Not sure if it is a good educational example though (the first doc comment is actually a lie, it is not multi-threaded yet ;) ). On the plus side I should state that almost everything related to mio is limited to that module (just search for mio in the repo)."
rust,3dw7l0,nwin_,1 point,Mon Jul 20 05:18:49 2015 UTC,Thanks!  It's a start at least :D
rust,3dw7l0,sjustinas,3,Mon Jul 20 12:44:39 2015 UTC,"I'm in the process of writing a set of (very simple) servers for the Three Dead Protocols.  The first one (qotd) is based on Rust's native threads, the second one I'm building right now (daytime) is written using MIO. I intend to write the last one (echo) using an abstraction of MIO that provides Futures/Streams on top of it: probably eventual by the same author (scratch that, it's a general Future library, not one built upon MIO).  These will probably be too simple for your needs, but I still wanted to put them out here.  (GitHub)"
rust,3dw7l0,formode,1 point,Mon Jul 20 13:54:37 2015 UTC,You might get some milage out of https://github.com/Hoverbear/raft
rust,3du5ty,IForgetMyself,11,Sun Jul 19 14:32:41 2015 UTC,"I would recommend learning a functional programming language, but I would really recommend learning an ML - either SML or OCaml - over learning Haskell. Rust has a lot of influences, but in many ways its a wedding of ML and C++. Learning an ML will introduce you to functional programming with an expressive type system without a lot of other things that aren't relevant to Rust because it doesn't have language-level laziness or strict purity.  Here is the online material for an undergrad languages class; the first unit is about SML. If you want, it also covers Racket and Ruby, which are both very different languages from either Rust or C/C++.  Also, you should read and work through the wizard book, which is taught in Scheme (basically the same language as Racket from CSE 341). This will change the way you think about programming."
rust,3du5ty,desiringmachines,2,Sun Jul 19 19:24:25 2015 UTC,"Yeah, I mostly see Haskell as an ML that is designed around laziness. It has a similar syntax and type system to SML or OCaml, but most of the ways in which it differs is to deal with laziness.  In a sense, Rust feels like an ML with a more C-like syntax, and designed around avoiding a GC. They do seem to have dropped the module system and taken Haskell's type classes (traits) instead."
rust,3du5ty,aiij,3,Mon Jul 20 01:56:38 2015 UTC,"Yeah, this seems like an accurate description of the etymology of both Haskell and Rust. Haskell originated as a platform for researching lazy language semantics and is heavily based on ML other than that quirk. Rust is mainly C meets ML with a lot of other influences here and there - most notably typeclasses from Haskell and regions from Cyclone and other academic languages.  Anyway, ML, Lisp, and C are the great, important programming language families of the twentieth century, so everyone should understand at least one member of each family, even though probably greater than 90% of programming is done in a C family language."
rust,3du5ty,desiringmachines,2,Mon Jul 20 08:11:33 2015 UTC,"Haskell as an ML that is designed around laziness.   That's pretty much entirely what Haskell is. The strict purity requirements is because of the non-strict semantics, most everything else is there to make working with strict purity manageable. If it hadn't been for non-strict evaluation Haskell would never have developed the way it did."
rust,3du5ty,sigma914,2,Tue Jul 21 08:03:49 2015 UTC,"Source: Wearing the hair shirt: a retrospective on Haskell (2003) Simon Peyton Jones; the links seem to be broken, so [PDF]."
rust,3du5ty,mcguire,1 point,Tue Jul 21 15:44:04 2015 UTC,"Awesome, thanks. Knew it was an SPJ talk, but couldn't remember which!"
rust,3du5ty,sigma914,1 point,Tue Jul 21 15:44:55 2015 UTC,The important part from Haskell that I see is traits.
rust,3du5ty,mcguire,17,Tue Jul 21 15:45:40 2015 UTC,"This might not be the answer you want: I would suggest learning other languages to appreciate Rust's design better.  Some exposure to Haskell would help you understand some of the functional things in Rust: iterators, immutability. And the type system thing -- Haskell's type system is regarded as one of the best! A good introductory (yet not that easy!) book is Learn You A Haskell.  Some exposure to Go might help you understand this composition/inheritance thing, because it forces you to use composition only. Go will also make you think sanely about concurrency: you will value channels and message passing instead of shared state + locks.  As for language-agnostic books, popular recommandations are: ""Code Complete"" and ""Pragmatic Programmer: From Journeyman to Master"".  I would also say that it's not a matter of CS degree because most degrees don't teach you those things anyway. You're on the right track for the real education: be curious and learn by yourself :)"
rust,3du5ty,mdup,4,Sun Jul 19 14:47:26 2015 UTC,"I was fully expecting the first answer to be ""Learn Haskell"" ;) I might give it a go, I remember looking at the book quite some time ago and finding it quite difficult, but looking at the first few chapters I think I should be able to do just fine now (In part from messing with Rust, heh, chicken meet egg).   I also have a long journey coming up soon, I'll see if I can grab one of those books beforehand and read them on the road. Thanks!"
rust,3du5ty,erikano,5,Sun Jul 19 16:50:34 2015 UTC,Buy these books and read them:   SICP Understanding Computation The Design of Design: Essays from a Computer Scientist   Keep in mind that you should not feel bad about not being able to absorb everything in these books. Even only a fraction of the material will make you a better software developer.  A book which I've only just started reading but which I like so far is Expert C Programming.
rust,3du5ty,shmerl,3,Sun Jul 19 23:17:28 2015 UTC,"I agree, some high level explanations and reasoning behind the language would be very useful. For example, something like ""Thinking in C++"" but for Rust.  Currently materials on Rust are mostly reference like, with some high level explanations scattered here and there. Hopefully this gap will be filled soon."
rust,3du5ty,gtani,4,Sun Jul 19 17:44:47 2015 UTC,"Turn the question around, what have you read for C++ and the concurrency course, maybe we could relate it to that material.  ""Concurrency"" courses cover low level mutexes, locks, semaphores OR no-shared memory/green threads environments (erlang/BEAM), OR they should really be called parallel, SIMD strategies for graphics/linear algebra/difeq (MPI, cuda etc).  ( for C++, Scott Meyers last 2, Effective Modern c++ and Effective 3rd ed are alwas recommended for is-a,  has-a,  is implemented in terms of etc.)    For type systems, people generally go with Pierce's TAPL, or Harper's Software Foundations  https://mitpress.mit.edu/books/types-and-programming-languages  http://www.cs.cmu.edu/~rwh/plbook/book.pdf    there's also some good langA vs langB threads you can google, e.g. https://www.reddit.com/r/rust/comments/2mwpie/what_are_the_advantages_of_rust_over_modern_c/  https://www.reddit.com/r/rust/comments/2ifgsx/what_can_c_do_that_rust_cant/  https://www.reddit.com/r/rust/comments/2pi3ju/rust_ruined_c_for_me/    also there are some good design rationale papers for Scala, clojure, d, golang, haskell, ML family and others, i could recommend if you want."
rust,3du5ty,nico159,3,Sun Jul 19 20:06:09 2015 UTC,"If you want to understand a language, you have to understand the theory behind  A path to enlightenment in Programming Language Theory is a great collection of books. If you feel a little lost I would simply start from Practical Foundations for Programming Languages  After writing this, I would just like to add a few personal opinions. Feel free to ignore this part if you don't agree with me  I would take the path of studying about programming language theory only if after reading the initial link of my message made you really curious aside from your current interest into Rust. The topic is pretty vast and it is unclear if the time that you will invest, will actually help in your future  Don't get me wrong, I think that the knowledge of the theory behind something is important  But is that knowledge something that you will put at use? Or something that you will enjoy? If you are interested into concurrency for example, you can invest your time in books like Is Parallel Programming Hard, And, If So, What Can You Do About It? that is for sure a step forward respect to what you studied and from there you can go for years and make yourself an expert. Something that this industry will valuate much more than an undergraduate level background in programming language theory  Another thing for that I hope to not sound a ""jerk""...but if you are interested in learning the foundations behind programming languages learning Haskell will not help. Books like Learn You A Haskell are intended to learn Haskell, nothing more. Simply take a look at both the draft of Practical Foundations for Programming Languages and Learn You A Haskell and take the conclusion yourself"
rust,3du5ty,aiij,3,Mon Jul 20 00:01:47 2015 UTC,"I would read up on Type Driven Development.  It's really useful in languages with strong type systems, like SML, Haskell, OCaml, and Rust.  If you're familiar with the Curry-Howard isomorphism (or read up on it a bit), you'll realize TDD is like deciding what it is you need to prove first, and then working to prove it. (As opposed to writing the proof first and then trying to come up with an explanation for what it is you want to prove.)  In languages with less expressive type systems, you end up having to express what you want as tests, so you end up with Test Driven Development, which doesn't tend to help guide the design as much.  In terms of expressiveness, the type systems for SML, Haskell, and OCaml are medium. They're way more expressive than what you may be used to in C, but not nearly as expressive as the types in Agda or Coq.  It probably helps to understand what the type systems are designed for / around:   In C, the types are little more than what is needed to let the compiler allocate the right number of bits or know which of the instructions to use for comparisons/arithmetic. It's grown a little beyond that, mostly because types are useful to catch errors earlier. SML was designed around type inference. I think their goal was the strongest type system possible as long as it can be inferred. (As a result, you always can annotate types, but you never have to.) Haskell is designed around laziness. That's why the IO monad lets you express that there are side effects, but says nothing about what they are. I think the OCaml designers liked SML but wanted something more practical / less pure. You occasionally need to annotate types, particularly when you're combining polymorphism and subtyping. It's still very much designed around GC though, to the point where ints are 63 or 31 bits, to minimize the overhead while allowing the GC to distinguish between integers and pointers. Rust also seems very much designed for practicality. It seems more designed around low-level concurrency and avoiding a GC. (The ownership system is very relevant to both.)"
rust,3du5ty,mcguire,1 point,Mon Jul 20 01:47:05 2015 UTC,Do you have any good references?
rust,3du5ty,aiij,1 point,Tue Jul 21 15:52:36 2015 UTC,"Not really. I had seen a decent blog post, but now I can't find it.  This might be good, but I've only given it a really quick look http://www.lucacardelli.name/Papers/TypefulProg.pdf  I think this lecture goes over it a little bit too, but I don't have time to watch the whole thing right now: https://vimeo.com/14313378"
rust,3du5ty,vks_,3,Tue Jul 21 20:01:32 2015 UTC,"Are you aware of the list of papers that influenced Rust? It is the last chapter of the book.  I found it helpful to skim through a few of them to understand better where some of Rust's concepts come from. For example I looked at the paper about traits and crash-only software. (The latter motivates why we can only catch panics at the thread boundary in Rust.)  A lot of people here recommend reading books or learning languages, but I think this is overkill if you want to know about the ""why""."
rust,3du5ty,fiedzia,5,Mon Jul 20 08:42:43 2015 UTC,"I'm sure other people will mention some books in this thread, but I'd say none. Rust is useful not because it comes with great ideas (even though it does), but because it addresses common pain points of low-level programming. Knowing what those are, how painful they are and why comes from practice. Write larger piece of software in c, watch it being used and abused, maintain it for couple of years and you'll get an idea. I am not sure if there are  books that would summarize such knowledge better then experience. So in short, rust is more practical then theoretical."
rust,3du5ty,dwchandler,8,Sun Jul 19 15:14:24 2015 UTC,"I disagree with this, as most languages are meant to address pain points and rust takes inspiration from several notable ones. Understanding the idioms in use in those other languages can give insight into how to use them well in Rust.  For instance, once upon a time some languages I used introduced some features from functional programming. I'd heard a little about it and tried the new features out but I didn't see how they made life any better, actually. Or not much better. Why all the fuss? Then I started learning some functional languages (haskell, lisp, scheme, ...) and read some of SICP. I began to ""get it"", and then I'd be reading some code in SICP and go, ""Oh, that's cool. Wait, what? Oh! OH!""  Unless you go off and read books and/or code, it can take a very long time to get that ""OH!"" moment. For some people it may never come at all. Some day that may happen completely inside the Rust ecosystem, but at this point in time I think it's useful for people to bone up on some of the concepts in Rust by learning from Rust's inspirations."
rust,3du5ty,fiedzia,2,Sun Jul 19 16:22:25 2015 UTC,"For me the ""Oh"" moment happens when I'll find theory or tool presenting solution for practical issues in an easily understandable way. So I'm not against learning theory, just pointing that it requires practical context to be fully understood and applied."
rust,3du5ty,dwchandler,1 point,Sun Jul 19 21:04:58 2015 UTC,"That helps me, too. And probably most people. That's one of the reasons I mentioned SICP above. The example programs helped me a lot."
rust,3du5ty,mcguire,1 point,Tue Jul 21 03:23:00 2015 UTC,"Experience is a great teacher, but it's not fast and it's not pleasant. Learning from other people's mistakes, while not as actually useful, is considerably easier and a bigger bang for your time."
rust,3du5ty,PM_ME_UR_OBSIDIAN,3,Tue Jul 21 15:50:13 2015 UTC,"Before Rust I had not heard about Composition vs. Inheritance   This makes me think that you have limited experience? If you've written less than, say, 20k lines of code in your entire life, go write more. Watch the first three minutes of this video; theory is your safety blanket when facing the scary and confusing world of programming. But you need to face that world first, to even understand why theory is useful.  If you have experience, or if you're curious about theory for its own sake, then what you want to be looking into is programming language theory. I then recommend that you take an online class on programming paradigms, such as this one with Peter Van Roy."
rust,3du5ty,sigma914,5,Sun Jul 19 17:54:39 2015 UTC,"I feel like I'm in a weird niche when it comes to experience. If written tons of small programs to help me with my studies (Physics Bsc. so lots of simulations) and done some fun projects with a pretty large scope of subjects.  However, I have never had a formal training, worked in a bussiness setting, or hands on with a huge code-base (my thesis project ended up being 8k lines for the part I handled). So all my knowledge of best-practices comes from reading blog-posts and the likes, and my theoretical knowledge comes from Wikipedia. So far, JIT-ing my knowledge has worked for me, but when studying Rust I figured now is as good a time as any to fill some major gaps in my knowledge.  I agree that in order to appreciate theory you need practical experience, but on the flipside you need theory to properly grasp the practical side as well. Ideally you should study both simultaniously. Or, as I often do: read the theory/best-practices, be stubborn, try to do the opposite, fail, appreciate the theory."
rust,3du5ty,staticassert,1 point,Sun Jul 19 18:55:08 2015 UTC,"So all my knowledge of best-practices comes from reading blog-posts and the likes, and my theoretical knowledge comes from Wikipedia.   This is the pretty much the same for me (I read a lot of PL blogs too) and I've been a professional dev for years. It's not a bad way to be."
rust,3du5ty,llogiq,2,Tue Jul 21 08:08:27 2015 UTC,"Learn Haskell, whether for rust or for anything else, it will make you a better programmer (in my opinion).  Reading about buffer overflows and use after free vulnerabilities may make you a bit more appreciative and interested in what rust can provide you. Especially if you're still a CS student, you probably haven't had to write much concurrent code, so you don't know the horror that is reasoning about multithreaded code, deadlocks, or race conditions in a language that leaves it all to you."
rust,3du5ty,n_ham,2,Sun Jul 19 19:10:14 2015 UTC,"I would not place too much emphasis on the 'why' – it will come to you in time anyway. Rather learn Rust BT writing code, hitting obstacles, asking here or on users.rust-lang or IRC, reading a few blogs about obstacles others have met (and hopefully overcome) and you'll do fine.  If you're still interested in the rationale for certain features, you may want to read up the corresponding RFCs if available."
rust,3du5ty,carols10cents,1 point,Sun Jul 19 23:12:05 2015 UTC,"Others have recommended learning functional programming languages (like Haskell or SML) to get a handle on type systems. This is not bad advice, and learning these languages will be a mind-expanding endeavor, but I feel like it should be emphasized that the ownership/borrowing system is a significant part of Rust's type system and learning Haskell or whatever will probably not help you understand it. For this topic, the best thing to do is probably to just write (and read!) a bunch of Rust code."
rust,3du5ty,thomanski,1 point,Mon Jul 20 03:01:21 2015 UTC,"Safe Rust does not have null pointers/nullable types- the original implementer of null references has talked about them being his billion dollar mistake (video, I can't find a good transcript)."
