lisp,3e2722,vittusormi,4,Tue Jul 21 11:36:26 2015 UTC,"The original function NEIGHBORS is defined on top. Then the modification:  (let ((old-neighbors (symbol-function 'neighbors))       (previous      (make-hash-table)))   (defun neighbors (pos)     (or (gethash pos previous)         (setf (gethash pos previous)               (funcall old-neighbors pos)))))   The next form stores the function object in a variable OLD-NEIGHBORS and stores an empty hash-table in PREVIOUS.  The the original function gets redefined. The new function has access to the two new local variables (above). If there are neighbors stored in the hash-table for the position, then the value is returned. If not, the old function gets called, the result gets stored in the hash-table and the result gets returned."
lisp,3e2722,lispm,1 point,Tue Jul 21 11:48:21 2015 UTC,"I understand how it works, but I can't perceive when and how those optimization functions are called. See the neighbors. It has no call to memoization.   (defun neighbors (pos)   (let ((up (- pos *board-size*))         (down (+ pos *board-size*)))     (loop for p in (append (list up down)                            (unless (zerop (mod pos *board-size*))                              (list (1- up) (1- pos)))                            (unless (zerop (mod (1+ pos) *board-size*))                              (list (1+ pos) (1+ down))))           when (and (>= p 0) (< p *board-hexnum*))           collect p)))   btw, any protips for formatting code easier in reddit?"
lisp,3e2722,lispm,4,Tue Jul 21 12:02:04 2015 UTC,"This function has been replaced. It won't get called directly anymore. NEIGHBORS points now to the other function. Thus the other function gets called. When it gets called, it conditionally calls above function via a variable, where the old function object is stored.  Note that this behavior is not strictly ANSI CL conforming, it usually works when loading code. But not necessarily when a Lisp compiler compiles a whole file in higher optimizing modes."
lisp,3e2722,lispm,1 point,Tue Jul 21 12:07:41 2015 UTC,"Aha! Now I start to understand. So when (attacking-moves) calls (neighbors), it redirects to (symbol-function 'neighbors). Am I on right track here? It's still quite blurry. For example, why is nested symbol-function call higher on priority list than the plain function? Not intuitive at all."
lisp,3e2722,lispm,5,Tue Jul 21 12:21:36 2015 UTC,"Say we have a call:  (neighbors pos)   Conceptually Lisp does this at runtime:   it looks at the first element. It is not a local function, not a macro, not a special form. But there is a function binding for the symbol NEIGHBORS. Thus it knows that this is a function call. it evaluates the arguments from left to right it retrieves the function object from the function binding of the symbol NEIGHBORS it calls the function object with the evaluated arguments   Thus we use late binding. Such a call always goes through the symbol and is looked up at runtime.  Now there are exceptions: if a file compiler sees a whole file, it may assume that the function binding does not change in that file. Thus code that calls a function may no longer go through the symbol's function binding.  But when we just load the source, we can ignore that, because it does not use the file compiler.  Another exception: local function calls also would not (!) go through a symbol's function binding.  (flet ((foo ()         ... (foo) ...))   ...(foo)...)   In above examples the lookup is also not via a function binding. No late binding.   For example, why is nested symbol-function call higher on priority list than the plain function? Not intuitive at all.   You look at the file from to to bottom. It is loaded from top to bottom. First the function binding gets set. Later it gets replaced, but the old one gets remembered in a closure's binding. That works during code loading. Thus it is a side effect during code loading. Just like you were typing the code by hand form by form. Common Lisp function definitions are mutable."
lisp,3e2722,lispm,1 point,Tue Jul 21 12:31:12 2015 UTC,"That went deeper than I thought. Thanks for explanation. I'd very much like to make it so that there is absolutely no ambiguity, meaning practically embedding the memoization as part in the original defuns and so that program order doesn't have any role (I assume that's what you meant with ""loaded later"").   These sudden lets among functions, coming and going seemingly nowhere startled me more than a spooky monster. I have Java background so this whole late binding thingy needs some time to digest. Had never even heard of such thing before."
lisp,3e2722,balkenbrij,5,Tue Jul 21 12:47:56 2015 UTC,"That's why we have symbols in Lisp. They are a name, but actually they are a real data object with value, function, properties, etc. Thus we can refer to things via symbols.  Example:  CL-USER 25 > (bar)  Error: Undefined operator BAR in form (BAR).   1 (continue) Try invoking BAR again.   2 Return some values from the form (BAR).   3 Try invoking something other than BAR with the same arguments.   4 Set the symbol-function of BAR to another function.   5 Set the macro-function of BAR to another function.   6 (abort) Return to level 0.   7 Return to top loop level 0.  Type :b for backtrace or :c <option number> to proceed. Type :bug-form ""<subject>"" for a bug report template or :? for other options.  CL-USER 26 : 1 > :top  CL-USER 27 > (setf (symbol-function 'bar) (lambda () (* pi 2))) #<anonymous interpreted function 406000D594>  CL-USER 28 > (bar) 6.283185307179586D0  CL-USER 29 > (symbol-function 'bar) #<anonymous interpreted function 406000D594>  CL-USER 30 > (setf *stored* (symbol-function 'bar)) #<anonymous interpreted function 406000D594>  CL-USER 31 > (setf (symbol-function 'bar)                    (lambda ()                      (+ 1000 (funcall *stored*)))) #<anonymous interpreted function 406001ACA4>  CL-USER 32 > (bar) 1006.2831853071796D0"
lisp,3dtiox,vittusormi,26,Sun Jul 19 08:38:20 2015 UTC,Maybe it's time for sbcl to move out of sourceforge?
lisp,3dtiox,fmargaine,14,Sun Jul 19 09:07:57 2015 UTC,SBCL mirror on Github:  https://github.com/sbcl/sbcl
lisp,3dtiox,lispm,13,Sun Jul 19 12:41:33 2015 UTC,"Given the B.S. that Sourceforge has been up to, it's high time for a move."
lisp,3dtiox,losthalo7,9,Sun Jul 19 11:49:04 2015 UTC,"Yeah, it's time to make the GitHub org the official place."
lisp,3dtiox,eudoxeea,2,Sun Jul 19 14:23:25 2015 UTC,Perhaps there's a way for us to help make that happen.
lisp,3dtiox,raphaelss,1 point,Mon Jul 20 00:14:20 2015 UTC,I'd love to know it.
lisp,3dtiox,fmargaine,1 point,Mon Jul 20 09:19:59 2015 UTC,Everything should move out of SF at this point. Just tried opening CLISP manual to find specific equivalent to certain socket functionality. It's down for maintenance.  Soo... any kind soul wanna return the favor and give link to CLISP manual pdf?
lisp,3dtiox,cracauer,4,Mon Jul 20 12:35:28 2015 UTC,"""Maintenance"" is putting it mildly. Their entire storage cluster seems to have evaporated."
lisp,3dtfq3,z27,2,Sun Jul 19 07:45:22 2015 UTC,"Next year's ELS (2016) location has been announced and it's Kraków (Cracow), Poland. Exact dates and location are yet to be announced, but in general the ELS is going to be hosted by the AGH University."
lisp,3dtfq3,antoszka,1 point,Sun Jul 19 08:06:06 2015 UTC,"Wonderful, thank you."
lisp,3dtfq3,gngl,2,Sun Jul 19 09:30:55 2015 UTC,"Wow, that's almost close enough for me to seriously consider attending."
lisp,3dj4jc,kragdoc,5,Thu Jul 16 18:09:07 2015 UTC,Will the ECL manual on common-list.net do?
lisp,3dj4jc,JesterSks,1 point,Thu Jul 16 22:34:40 2015 UTC,"Thanks, not sure how I didn't find that in my searching. It looks to be quite old, but I don't think ECL has changed its interfaces significantly in the past decade. It can probably hold me over until sourceforge get their act together."
lisp,3dj4jc,abicidario,3,Fri Jul 17 06:56:44 2015 UTC,"I have a local copy from 2014, it's a 500K zip file (which should be identical to the current one).  What shall we do now? Can you provide a place to upload it?"
lisp,3dj4jc,abicidario,1 point,Thu Jul 16 21:50:04 2015 UTC,"Thanks, it would be quite useful, the only thing I can offer is my email address though, which I can inbox you if you're willing to send it."
lisp,3dj4jc,orthecreedence,4,Fri Jul 17 06:59:39 2015 UTC,"I could send it, but at this point it's maybe easier to just:  wget -r --no-check-certificate http://common-lisp.net/project/ecl/manual/"
lisp,3dcy5o,zodmaner,3,Wed Jul 15 08:08:04 2015 UTC,"This entry was even better than the last one. I use both these techniques all the time, but in other languages and without assistance from a debugger.   Modify a single part at a single point in a program...by hardcoding an assignment in a strategic place while debugging. Examine values in a trace...by adding print statements and running through it.  Having it all pre-made for me would be great. And then running live in addition? Could be amazing. Unfortunately, I don't have any opportunity to build any big lisp system to try these things out."
lisp,3dcy5o,guicho271828,2,Wed Jul 15 13:03:40 2015 UTC,I didn't know that the tracing mechanism was integrated into SLIME. I'm just using system-provided trace and C-c C-t (toggle trace). It would be useful!
lisp,3dcv4u,xenow,1 point,Wed Jul 15 07:27:49 2015 UTC,"I know Xach had some plans for new Quicklisp features as far as tagging/popularity etc. goes, but for now I had an itch to get something in a similar vein going.  It's very early/prototype stages, but if anyone has ideas they'd like to see in it, I'm all ears.  About 75% of the repositories will work when their link is clicked (it checks github for a README.md file).  About 25% are not hosted on github, or don't have the file.  I'll work on adding robustness to cover bitbucket and other miscellaneous sites next."
lisp,3dcv4u,sbenitezb,5,Wed Jul 15 07:29:35 2015 UTC,Why didn't you contribute those features to quicklisp instead?
lisp,3dcv4u,xach,4,Wed Jul 15 14:23:42 2015 UTC,There's no guarantee that I'd accept it.  I am very glad when people do things on their own. They can follow their own vision without worrying about my personal tastes.
lisp,3dcv4u,xach,1 point,Wed Jul 15 14:28:25 2015 UTC,"I see some of what I thought of is already provided by quickdocs (how had I missed that up until now?).  I'll hit the drawing board and continue to think of ideas that can improve the Common Lisp ecosystem without causing yet another redundancy in a provided system.  If any small gems end up in my resultant codebase, it's open source as always, so if someone wants to attempt to merge it into an existing system, they are more than welcome."
lisp,3dcv4u,xach,1 point,Wed Jul 15 14:34:07 2015 UTC,I can't load it. The connection times out.
lisp,3dcv4u,fmargaine,1 point,Wed Jul 15 10:58:44 2015 UTC,It's back up. The woo Web server is crashing on first request on my centos 6 server so I had to use hunchentoot which seemed to die after a certain number of page hits.  Will iron out for good later today
lisp,3d8x0x,paines,3,Tue Jul 14 12:38:28 2015 UTC,Just added a few of mine to the site.
lisp,3d8x0x,xenow,3,Tue Jul 14 19:49:58 2015 UTC,Great. Do you know if they are approving them? I can't seem to find them.
lisp,3d8x0x,xenow,2,Wed Jul 15 06:18:47 2015 UTC,"I didn't get any feedback other than an automated mail saying the site admin personally reads all emails.  I submitted 3 (2 common lisp, 1 other).  You can find them on http://ahungry.com/blog (its just the ones I added to /r/lisp in the last few days)."
lisp,3d8x0x,EpsilonRose,1 point,Wed Jul 15 07:30:30 2015 UTC,"What I really want is a tutorial for setting up an ide in Windows that isn't as cumbersome as emacs and, you know, generally functions like a fully featured ide that could be found for most other languages.   I've tried to learn lisp several times now, but each time the setup has stopped me cold."
lisp,3d8x0x,maufdez,7,Tue Jul 14 16:00:53 2015 UTC,"CormanLisp was open sourced recently and is possible to be build with a modern version of Visual Studio -> https://github.com/sharplispers/cormanlisp.  Besides that, there is Allegro CL and LispWorks, both offering Windows builds with an IDE, and IIRC it is free for personal usage.   What I would suggest is still Emacs + Slime but in a Linux environment, cause it is pretty easy to setup in there. Get VirtualBox and a ready VirtualBox Image(e.g. latest Ubuntu) then do ""apt-get install emacs24 slime sbcl quicklisp"" and you are good to go in about 5-10 minutes ones the VM is up and running.   Or maybe you have an embedded Linux box, like Raspberry PI, and you could use that via SSH e.g...."
lisp,3d8x0x,fmargaine,7,Tue Jul 14 16:28:51 2015 UTC,"I don't know why people think is so difficult to setup things on Windows, I use both operating systems and setting up Windows was not a difficult task. I use Emacs, so I won't be of help setting up a different IDE, but setting up Emacs in windows is reduced to downloading it, it could not be simpler. And setting up slime is just a matter of installing quicklisp first (which is a single file download and load), and then using quicklisp-emacs-helper, then a simple edit to your .emacs to tell it where your CL distro is, is really not that difficult. I've done this in several windows machines in under 10 minutes, with several different CL distros, and never had a problem."
lisp,3d8x0x,EpsilonRose,2,Tue Jul 14 19:38:22 2015 UTC,"No, using emacs and slime is really not a valid option. I had to actually make a custom package to install everything! Emacs, then slime, then a bunch of lines in .emacs, then quicklisp. Granted, quicklisp is not required. But the current state of Lisp IDEs is a sad one. Many people don't like emacs and just want a simple one click install that has everything, e.g. a sublime package."
lisp,3d8x0x,EpsilonRose,0,Tue Jul 14 16:41:45 2015 UTC,"What I would suggest is still Emacs + Slime but in a Linux environment, cause it is pretty easy to setup in there. Get VirtualBox and a ready VirtualBox Image(e.g. latest Ubuntu) then do ""apt-get install emacs24 slime sbcl quicklisp"" and you are good to go in about 5-10 minutes ones the VM is up and running.   I don't like emacs and I'm not going to set up a linux environment just so I can try a programming language. That is an unreasonable level of effort to expect of someone who isn't even sure if it will be worth while.   Or maybe you have an embedded Linux box, like Raspberry PI, and you could use that via SSH e.g....   You can't possibly be serious."
lisp,3d8x0x,mordocai058,2,Tue Jul 14 18:34:36 2015 UTC,"https://ideone.com/  I don't have a clue, why I even bother ....."
lisp,3d8x0x,mordocai058,-3,Tue Jul 14 19:07:02 2015 UTC,"Neither do I, since that's not an actually useful link. I mean, yes, I can write lisp in it, but as someone, unhelpfully, pointed out: I could do that in notepad. That doesn't seem to be a full featured ide. It certainly doesn't have auto-complete, auto-indent, or syntax highlighting."
lisp,3d8x0x,KDallas_Multipass,-2,Tue Jul 14 19:36:34 2015 UTC,"Learn clojure instead and use https://cursiveclojure.com/ or one of the many other clojure IDEs that work on windows.  Windows is a third-class citizen in the common lisp world and emacs is pretty much the only IDE worthwhile. If you don't want to learn emacs and insist on staying on windows, it probably isn't for you."
lisp,3d8x0x,iouwt,1 point,Tue Jul 14 19:46:14 2015 UTC,I was more speaking to the fact that a vast amount of quicklisp libraries have problems on windows and most implementations don't bother fully supporting windows(last I checked).
lisp,3d8x0x,EpsilonRose,1 point,Mon Jul 20 20:00:54 2015 UTC,"after you get the chip off your shoulder, try lispworks or allegro free versions, and if you like the ide enough to stick with the language long enough to find it useful, then go buy one of their offerings.  Getting a lisp environment up and running is only the first step.  all the fun libraries you'll want to use with CL will be no fun to get working on windows, while on linux its usually a package manager call away.  But either way good luck."
lisp,3d8x0x,Shinmera,5,Mon Jul 20 21:09:30 2015 UTC,"Check out Lispworks Personal Edition. It's free, and installs to Windows as easily as Visual Studio."
lisp,3d8x0x,EpsilonRose,2,Mon Jul 20 03:20:09 2015 UTC,That looks like it might be worth checking out. Thank you.
lisp,3d8x0x,mrottenkolber,2,Tue Jul 14 21:03:37 2015 UTC,Have you had a look at lispstick?
lisp,3d8x0x,EpsilonRose,-1,Tue Jul 14 21:23:35 2015 UTC,"It looks to be an improvement, but it's still using emacs. It's far to invested in sequential hotkeys for my taste."
lisp,3d8x0x,brianqx,3,Tue Jul 14 20:03:54 2015 UTC,"You don't need to use sequential hot keys to use emacs. Its works pretty much like Notepad, except M-w / C-w, C-y for copy/cut/paste. You can always M-x to run advanced commands."
lisp,3d8x0x,EpsilonRose,-2,Tue Jul 14 20:06:59 2015 UTC,"Its works pretty much like Notepad   That is not a good thing for an ide.   xcept M-w / C-w, C-y for copy/cut/paste. You can always M-x to run advanced commands.   That is not a good user interface nor does it make sense."
lisp,3d8x0x,brianqx,2,Tue Jul 14 21:01:05 2015 UTC,turn on CUA mode?
lisp,3d8x0x,EpsilonRose,2,Tue Jul 14 21:17:23 2015 UTC,I don't actually know what that is.
lisp,3d8x0x,maufdez,1 point,Wed Jul 15 03:24:44 2015 UTC,"oh it's an option for emacs to use C-x C-v C-p. http://www.emacswiki.org/emacs/CuaMode. But yah emacs, like vim, predate the C-x C-v C-p convention. In emacs world, paste is yank (C-y) and cut is kill (C-k). C-w is kill (w)region, and M-w is copy (w)region.   If you happen to like vim, there's evil-mode for emacs. Emacs is very powerful. If you're interested in some things it can do, http://emacsrocks.com/ has some nifty videos. But the keybindings are definitely underwhelming. You should find what works best for you."
lisp,3d8h31,z27,1 point,Tue Jul 14 09:24:43 2015 UTC,"As an answer says, I think using a swank client is the best option. Slime is just that! Slime from the CLI would be weird though."
lisp,3d8h31,fmargaine,1 point,Tue Jul 14 18:34:42 2015 UTC,I saw this link a while back about writing a simple socket repl: http://sourceforge.net/p/sbcl/mailman/message/20182792/
lisp,3d8h31,spacebat,1 point,Tue Jul 14 23:10:40 2015 UTC,"It should be mentioned that a lot of these solutions are pretty insecure and allow arbitrary code execution from third parties. You can use SSH tunnel to secure the connection. For example you have swank-server running on port 4005 on remote.server, and this port is blocked for external connections by firewall. Then you run this command on local computer:  ssh -L 4007:localhost:4005 user@remote.server   Then you can do slime-connect on localhost:4007 and it will magically connect to remote server through ssh."
lisp,3d8h31,Grue,1 point,Wed Jul 15 16:36:58 2015 UTC,Sometime ago as a response to a similar question I wrote eval-in-swank.sh http://paste.lisp.org/display/138900
lisp,3d408o,vityok,11,Mon Jul 13 10:01:32 2015 UTC,"Simply amazing, and look at all those documentations!  I'm currently looking into building web applications in Common Lisp, so this will be a great addition.   Man, I'm enjoying living in the current Lisp renaissance."
lisp,3d408o,zodmaner,6,Mon Jul 13 12:24:55 2015 UTC,"Man, I'm enjoying living in the current Lisp renaissance   Well said!"
lisp,3d408o,z27,6,Mon Jul 13 13:35:18 2015 UTC,"Fails in various ways on my copies of CCL and SBCL running on OSX.  Following the instructions at the site I find that, in addition to ceramic itself, I need to git clone jonathan and proc-parse (neither is in the June version of quicklisp).  On CCL the download and extraction of electron fails on a seek to an unknown location in a zipfile. On SBCL the download and extraction of electron fails on the inability to delete a nonexistent file if the zipfile is not already extracted, or on the unexpected presence of a file if it is already extracted.  When I do (ceramic:interactive) I get the generic electron shell window. When I do (ceramic:show-window window) after constructing a window as shown, I get nothing--no window.  Haven't tried it yet on a platform other than OSX; it might be OSX-only issues, or something else to do with my specific setup."
lisp,3d408o,mikelevins,5,Mon Jul 13 14:18:11 2015 UTC,"Thanks for your feedback, did you open a ticket for these issues?"
lisp,3d408o,mac,3,Mon Jul 13 15:01:49 2015 UTC,Also fails for me at (ceramic:setup). I just opened a ticket.
lisp,3d408o,moodd,3,Mon Jul 13 15:08:40 2015 UTC,Are you sure your Quicklisp dist isn't outdated? Both jonathan and proc-parse were added in the April dist.
lisp,3d408o,orthecreedence,2,Mon Jul 13 15:18:30 2015 UTC,"Not sure when the last QL dist was released, but jonathan has had some pretty big bugfixes since April."
lisp,3d408o,xach,3,Mon Jul 13 15:24:33 2015 UTC,It was last released three days ago.
lisp,3d408o,mikelevins,1 point,Mon Jul 13 15:48:16 2015 UTC,"No, I'm not sure. I updated quicklisp before trying this, but I've occasionally had an update fail in some mysterious way before, so that could be the culprit. Thanks for suggesting it."
lisp,3d408o,Jedimastert,2,Tue Jul 14 01:12:37 2015 UTC,How the hell have I never heard of Lisp web applications? How does one go about doing this? Is it a CGI kinda thing?
lisp,3d408o,xach,7,Tue Jul 14 00:56:11 2015 UTC,"Lisp is usually a long-running process. A front-end server (like Apache or nginx) can proxy HTTP requests to it, or the Lisp server can take requests directly. It's more like FastCGI than regular CGI."
lisp,3d408o,Jedimastert,1 point,Tue Jul 14 00:57:41 2015 UTC,What's the difference? I'm pretty new to this kinda stuff
lisp,3d408o,Jedimastert,3,Tue Jul 14 02:05:45 2015 UTC,"Difference between what and what?  Here is one tutorial for developing web-apps in CL, here is another using a different framework."
lisp,3d408o,drewc,0,Tue Jul 14 06:58:50 2015 UTC,"Oh, sorry. I meant between FastCGI and CGI"
lisp,3d408o,Jedimastert,3,Tue Jul 14 13:27:30 2015 UTC,https://en.wikipedia.org/wiki/FastCGI vs https://en.wikipedia.org/wiki/Common_Gateway_Interface   And somewhat on-topic : http://cliki.net/fastcgi
lisp,3d408o,drewc,1 point,Tue Jul 14 17:06:27 2015 UTC,"Ooooh. Huh. I've never had to do bigger scale application, so I've never thought about the overhead problems for CGI processes. So is it like one big event loop? Or is there something even more magical going on?"
lisp,3d408o,Jedimastert,1 point,Tue Jul 14 17:39:41 2015 UTC,"So is it like one big event loop?    What do you mean by that?   Or is there something even more magical going on?   Well, first you have to define what you mean by an event loop for stateless HTTP servers. If that is as magical is it sounds, then I'll have some idea how to respond."
lisp,3d408o,eudoxeea,2,Tue Jul 14 22:16:52 2015 UTC,stateless HTTP servers   Had to google. That makes sense.
lisp,3d408o,Grue,3,Wed Jul 15 03:34:39 2015 UTC,Example: http://eudoxia.me/lucerne/docs/example--a-twitter-clone.html
lisp,3d408o,vittusormi,2,Tue Jul 14 02:06:40 2015 UTC,Most things people do with CL these days are web applications (could be true of most other high-level languages though). Lisp has some properties that make it useful for web-applications such as the ability to hot-swap code on the fly (reducing downtime) and the fact that HTML <-> S-expression map to each other pretty well may be of use too.
lisp,3d408o,spacebat,5,Wed Jul 15 05:59:38 2015 UTC,Projects like this is what CL really needs many more. Just look at dem slick production values of that webbypage! Almost like the language wasn't 50 years old at all!
lisp,3d0wb3,defun_,6,Sun Jul 12 16:20:05 2015 UTC,"This was posted less than a month ago, is something new here? (fantastic talk of course but surely this is a bit soon for a repost)"
lisp,3d0wb3,Baggers_,7,Sun Jul 12 20:12:54 2015 UTC,"No, nothing new. I don't visit reddit very often, and I wasn't aware it had already been posted."
lisp,3d0wb3,xenow,9,Sun Jul 12 20:51:11 2015 UTC,I think defmacro_ beat you to it (I kid I kid!)
lisp,3d0ev8,Triclops200,5,Sun Jul 12 13:16:04 2015 UTC,Thank you for sharing.  What does it offer differently from Zach Beane's quickproject + buildapp?  http://www.xach.com/lisp/quickproject/ http://www.xach.com/lisp/buildapp/
lisp,3d0ev8,z27,2,Mon Jul 13 06:12:29 2015 UTC,"I used those tools to make a project the other month and I wanted to make a standalone project, but setting it up so that buildapp would properly load everything from quicklisp was a hassle. This tool just automates creating a project that can use a makefile (using buildapp underneath) to create a standalone executable that integrates libraries from quicklisp."
lisp,3d0ev8,z27,2,Mon Jul 13 11:24:07 2015 UTC,"Thank you, that is very useful indeed!  PS: Just for completeness, let me add here as reference also cl-project: https://github.com/fukamachi/cl-project"
lisp,3d0ev8,redditsuxass,2,Mon Jul 13 11:43:47 2015 UTC,"Hmm, I may have to adopt the modern cl style for my next release."
lisp,3d0axo,z27,3,Sun Jul 12 12:21:26 2015 UTC,"This link has already been submitted about two years ago, but this library is too good not to be reminded of again. I also appreciate a lot the superb documentation.  I came to know about lparallel from pgloader. By the way, the interesting video ('Why did pgloader get so much faster?"") on the home page is about threads and lparallel, too."
lisp,3d09pd,z27,1 point,Sun Jul 12 12:04:20 2015 UTC,"I have been searching for more information on concurrency and threading, that chapter is very instructive and wonderfully clear. I hope very much one day Nick Levine will complete The Lisp Book, he is an excellent writer."
lisp,3d05a7,timdaly,6,Sun Jul 12 10:51:53 2015 UTC,I don't believe anyone has done that but this is an example of a system that does prove statements about a very restrictive lisp http://www.cs.utexas.edu/users/moore/acl2/ your best bet would be to attempt to translate those things into the system.
lisp,3d05a7,zitterbewegung,3,Sun Jul 12 12:34:56 2015 UTC,Thanks for the link.I had no idea something like this existed
lisp,3cw6kb,z27,10,Sat Jul 11 07:45:28 2015 UTC,Cool! It is interesting. I think it is accurate. We indeed have fun with this awesome language and everybody is happy and helpful :-P
lisp,3cw6kb,davazp,6,Sat Jul 11 08:17:42 2015 UTC,Awesome happy cool fun!
lisp,3cw6kb,jinwoo68,6,Sat Jul 11 15:36:50 2015 UTC,Interesting
lisp,3cw6kb,casey12141,6,Sat Jul 11 18:48:26 2015 UTC,"The C guys are too constrained in there language so it makes them grumpy. I don't know if its just me, but it seemed kinda like the more expressive languages (like LISP!) were happier and had more fun talking about their language! The funner languages will have funner people, it seems."
lisp,3cw6kb,butlerccreltub,3,Sun Jul 12 04:14:27 2015 UTC,"I like how C and Lua are at opposite ends for the 'Hardware Issues' one, even though Lua is, very often, embedded in C. Really makes their purposes clear lol."
lisp,3cw6kb,casey12141,8,Sat Jul 11 12:36:20 2015 UTC,It's strange how /r/lisp is just above /r/cpp on that same metric. I didn't see that one coming.
lisp,3cw6kb,redditsuxass,6,Sat Jul 11 13:13:44 2015 UTC,Maybe because Lisp Machine is discussed a lot here?
lisp,3cw6kb,jinwoo68,2,Sat Jul 11 15:36:17 2015 UTC,We also <3 sbcl's performance
lisp,3cvml2,xenow,3,Sat Jul 11 03:46:12 2015 UTC,Shen is a lisp with optional static typing that is highly portable (it's implemented in a small lisp with 46 primitive functions/special forms). Check /r/shenlanguage on the sidebar.  Racket has the typed-racket module if you like racket.
lisp,3cvml2,a_Tick,2,Sat Jul 11 05:34:10 2015 UTC,"Ive never tried shen because it seems going pretty much everything different from CL. I appreciate a language extension built on CL, but in shen, although it is possible to call the background CL, it is not a CL."
lisp,3cvml2,guicho271828,1 point,Sun Jul 12 00:58:55 2015 UTC,"While the reference  implementation is Common Lisp, Shen also runs on top of JavaScript, Chibi Scheme, Clojure, Haskell, Python, and possibly more. Qi, the predecessor to Shen, only ran on top of Common Lisp. Part of the motivation for Shen was to remove the dependence on Common Lisp."
lisp,3cvml2,a_Tick,1 point,Sun Jul 12 08:03:36 2015 UTC,Do either have anything like quicklisp or emacs slime support?
lisp,3cvml2,a_Tick,2,Sat Jul 11 05:44:14 2015 UTC,"The reference  implementation of Shen is in Common Lisp, and you can call out to Common Lisp code directly. I don't know if that means it works with slime. I'm pretty sure it would work with quicklisp, but I haven't tried it. Shen is still something of a fledgling language, and it definitely needs better tooling and library support. However its type system is incredibly sophisticated, so if you're someone who's interested in statically typed lisps, it warrants your attention.  Racket has its own editor, DrRacket. I've toyed with racket very little, so I don't know to what extent it manages libraries automatically. I am given to understand it has excellent library support."
lisp,3cvml2,redditsuxass,2,Sat Jul 11 05:56:32 2015 UTC,"I've toyed with racket very little, so I don't know to what extent it manages libraries automatically.   Racket's development team has deprecated its automatic library system, known as PLaneT, in favor of a new command-line tool called 'pkgs' (installed as a subcommand of the pre-existing raco command-line compiler) that resembles Ruby's gem command-line tool."
lisp,3cvml2,iouwt,1 point,Sat Jul 11 13:43:06 2015 UTC,"shen-mode is up on ELPA, but it's pretty bare bones. I'm thinking of retooling it, one of these days. Supposing I get around to learning Emacs Lisp."
lisp,3cvml2,redditsuxass,2,Fri Jul 17 18:26:53 2015 UTC,"You actually don't need the special defn macro from this article to get the static type warning about mod from SBCL:   CL-USER> (defun call-mod () (mod 8 ""three"")) ; in: LAMBDA NIL ;     (MOD 8 ""three"") ;  ; caught WARNING: ;   Asserted type REAL conflicts with derived type ;   (VALUES (SIMPLE-ARRAY CHARACTER (5)) &OPTIONAL). ;   See also: ;     The SBCL Manual, Node ""Handling of Types"" ;  ; compilation unit finished ;   caught 1 WARNING condition CALL-MOD1    Also, there are no static type warnings to speak of if you use CLISP.   I couldn't get CCL or ECL running on my machine, and I don't have OpenMCL installed, nor any of the proprietary CLs, so they weren't tested."
lisp,3cvml2,fjames86,1 point,Sat Jul 11 13:30:56 2015 UTC,Built in functions will warn.  Using a user defined such as mod! Will not warn
lisp,3cvgyw,michaelrutherford,1 point,Sat Jul 11 02:51:29 2015 UTC,"Installed this quite some time ago, noticed that some stuff doesn't work - ROOM returns NIL, for example. There doesn't seem to be any proper documentation."
lisp,3cvgyw,gngl,1 point,Sun Jul 12 04:24:17 2015 UTC,There's no way to hook up a file to it. :(
lisp,3cvgyw,p_nathan,1 point,Tue Jul 14 23:31:11 2015 UTC,"Yes, but can you write an Android app in it?"
lisp,3crjqg,brianqx,7,Fri Jul 10 05:01:24 2015 UTC,"It looks great. The current PDF can be downloaded from repository.  BTW, is it possible to generate a e-Book (either AZW or EPUB) based on these tex sources?  At least, it must be possible to fine-tune page dimensions in the PDF output to make it suit e-Book readers."
lisp,3crjqg,vityok,2,Fri Jul 10 09:37:02 2015 UTC,"You can definitely tweak the page-sizes. I believe you can also export as html to make an ePUB or similar format. I have never done that, though, so I'm not sure how well it works."
lisp,3crjqg,JimH10,2,Fri Jul 10 12:47:54 2015 UTC,"I hate ebooks and On Lisp seems to only be available in PDF. I like to use Lulu as a printing service in these situations. Paul Graham's own PDF doesn't make it through Lulu's book creation process, but this one does. I did it in B&W, which kind of defeats the purpose, but makes the print copy affordable."
lisp,3crjqg,JimH10,1 point,Fri Jul 10 11:19:26 2015 UTC,"I wonder what   Now to get up to 50 characters.    means?  (Also, I wonder if you have contacted PG about the posting?  Just as a courtesy.)"
lisp,3crjqg,vityok,2,Fri Jul 10 11:41:21 2015 UTC,"I sent him an email once a few years ago when Lulu had problems and never heard anything. But since the PDF is here, I can't imagine he minds if people print it."
lisp,3crjqg,JimH10,2,Fri Jul 10 12:00:38 2015 UTC,"I hear you. But I offer a couple of books as PDF's free for download and in the past I have appreciated an email (for a number of reasons that don't bear elaboration here).    And, just in general, I'll note that imagining anything about other people has often got me in trouble!  Anyway, thanks for the book."
lisp,3crjqg,vityok,2,Fri Jul 10 12:33:31 2015 UTC,"I find it rather depressing that there is almost a total lack of introductory books on Lisp programming that have a modern look-and-feel.  Practical Common Lisp is a great book, but it was published long ago.  There are other great books on Lisp programming, but they were published long ago and are hardly accessible/suitable for modern book-reading gadgets (pads, smartphones, e-Book readers).  Having a book in its .tex form probably will allow to fill the gap a little bit..."
lisp,3crjqg,akrumbach,3,Fri Jul 10 12:29:30 2015 UTC,"a modern look-and-feel   I'm writing a book now, OK?  How do I make it modern?  I'm not being facetious; I honestly don't know.    FWIW, I typically write in LaTeX.  In any event, I'd want my product to be cross-platform, reasonably long-lived, and reasonably Free.  I'd like it if the tools were reasonably Free, too.  I don't want to make a dead fish so I want to include sound, video, interactable-graphics- zoom, pan, etc.- and executables (""enter your own code here and watch it run"").   I want all those things because I think they would help readers understand it quicker, and better.  But that makes PDF an issue.  I write math so typography is absolutely an issue.  That makes HTML an issue.  What is left?    Is there anything?  I don't know of it.  I'm not convinced that these Lisp authors have all that many options.  Love to be proved wrong."
lisp,3crjqg,JimH10,1 point,Fri Jul 10 12:44:34 2015 UTC,I have nothing against PDF. What I mean that older books tend to pop up on book-sharing sites in a scanned form that is indigestible for e-Book readers or in a genuine PDF that has font/page settings that also make it inconvenient to read on e-Book readers.
lisp,3crjqg,z27,3,Fri Jul 10 13:13:41 2015 UTC,"There is Land of Lisp (2010), if you don't mind all of the code examples being game development."
lisp,3crjqg,xenow,1 point,Fri Jul 10 18:47:13 2015 UTC,"If you comment out the `\toggletrue{mint}' line, it will build without syntax highlighting."
lisp,3crjqg,mickbeaver,4,Fri Jul 10 12:50:54 2015 UTC,"Thank you, and PG, for the work.  (There is an unresolved reference on p 16, line -7.)"
lisp,3crjqg,vermiculus,2,Fri Jul 10 10:07:49 2015 UTC,"Thank you for sharing this, it is a wonderful resource. I once assembled the pdf with the missing images, but it was not as good as this one.  I did also email Mr Graham asking permission to publish it on paper, and selling at cost for the benefit of Lisp users, but never heard back. A used book costs more than $100 (check ebay), very hard for students and such."
lisp,3cinpv,PuercoPop,5,Wed Jul 8 05:16:20 2015 UTC,An excellent post. Thanks Michael!
lisp,3cinpv,vityok,5,Wed Jul 8 07:58:43 2015 UTC,"This looks really great. I've been annoyed trying to debug Lisp and I use slime + sbcl, so it's perfect.  That said, one of the annoyances has been that ""insert a statement"" isn't so easy in a big nested sexp. That means a lot of navigation or breaking it apart into more imperative style before I can even start debugging.   A lot of this is learning when to use what style and learning the sexp navigation commands, I guess."
lisp,3cinpv,malisper,4,Wed Jul 8 11:28:37 2015 UTC,"For the inserting a statement problem, you could just use a macro that breaks before evaluating its body:  (defmacro with-break (&body body)   `(progn (break) ,@body))   All you need to do is wrap the expression you want to break before with it."
lisp,3cinpv,AsymptoteToHappiness,4,Wed Jul 8 12:55:11 2015 UTC,"Wow, this is super cool. Thanks for posting it."
lisp,3cinpv,chebertapps,5,Wed Jul 8 08:15:21 2015 UTC,Wow so I never knew you could restart from a frame. Debugging just got WAY better for me. :)
lisp,3cinpv,xenow,3,Wed Jul 8 17:54:25 2015 UTC,What did you use to generate the gifs?
lisp,3cinpv,malisper,3,Thu Jul 9 07:13:10 2015 UTC,I used Open Broadcaster Software to record a video. Then I uploaded it to ezgif.com to change it to a gif.
lisp,3cinpv,paines,3,Thu Jul 9 12:48:58 2015 UTC,"Nice, thanks for the write up. About interaction and handling: shouldn't it be easy to toggle breakpoints, insert a (break) at the specific line with some emacs macros, or what am I missing ?"
lisp,3cinpv,malisper,3,Thu Jul 9 08:56:11 2015 UTC,You're going to have to be more specific. Are you asking whether it is possible to insert a breakpoint just through emacs without using the break function?
lisp,3cinpv,paines,2,Thu Jul 9 12:50:06 2015 UTC,"You are right, that wasn't very specific. Exactly, .... is it possible to insert a breakpoint just through emacs without using the break function?..."
lisp,3cinpv,malisper,2,Fri Jul 10 06:31:58 2015 UTC,"I don't think so. Since Common Lisp provides break, there doesn't seem to be any reason for emacs to implement an equivalent feature where the only difference is that a call to break isn't inserted into the code."
lisp,3cinpv,Odditys,4,Fri Jul 10 16:16:59 2015 UTC,I'm looking forward to part 4
lisp,3cinpv,shortsightedsid,3,Wed Jul 8 08:16:39 2015 UTC,Not all free lisp implementations support step as far as I know. This won't work in CCL or ECL. CCL supports restarts but ECL does not support restarts.
lisp,3cinpv,malisper,3,Wed Jul 8 13:43:00 2015 UTC,Reread the first sentence.
lisp,3c7f56,eudoxeea,6,Sun Jul 5 16:16:56 2015 UTC,How does this differ from caveman2? (the web framework clack's author put together)  It appears to use the same cl-annot for route definitions (although a #'defview call instead of a #'defun call for the code tied to the route).  Both also use djula for the template engine.  Can you give a quick summary/checklist of what is and is not the same as caveman2?
lisp,3c7f56,xenow,8,Sun Jul 5 19:20:42 2015 UTC,"The way I see it is this: When I started working on this, I think Caveman was still Caveman, not Caveman2. And the goal of Caveman was to be the larger framework -- the opposite of Ningle, which is super minimal. Now, Caveman2's pivoted in the direction of being more like a microframework.  I designed Lucerne as a sort of midpoint between the hyper-minimalism of Ningle and the amount of ""magic"" that Caveman2 has. I haven't looked at it in a while, though I recall there was a fairly complex reader macro that decided which application object was the ""current"" one. That's the sort of Django-style ""magic"" I want to avoid: I want all those things on Lucerne to be explicit."
lisp,3c7f56,rhabarba,5,Sun Jul 5 21:40:46 2015 UTC,"Additionally: Caveman originally used cl-emb, and Lucerne used my own template engine, until Djula came along and we both (independently) decided it would be a much better option."
lisp,3c7f56,fisxoj,0,Mon Jul 6 00:55:02 2015 UTC,"I second this question. Seems like ""Yet Another Clack Framework""... :-)"
lisp,3c7f56,fisxoj,6,Sun Jul 5 19:37:57 2015 UTC,This looks neat!  Have you deployed it anywhere and how?  My experience with lisp web stuff was that it was difficult to get running with popular web services like CDN's and different popular hosting services (getting custom lisp running on Heroku was a pain).  Anyone have experience making this do work?
lisp,3c7f56,z27,4,Sun Jul 5 21:36:50 2015 UTC,"I didn't reply to this yesterday since I wanted to get the all-clear from work to post this.  Just a week ago I deployed a small pre-sales demo of MonkeyLearn for Moz. We deployed to AWS using Ansible, and that was a fairly smooth ride. The only problems were getting Supervisor to work (not something Lisp-specific, just a general problem).  The demo does a lot of requests to other servers on the server-side so performance is horrifying, but performance for the landing page (Djula templates rendered through Lucerne, using Woo) is quite good.  I wrote it in CL, in part, for the obvious reason of rapid prototyping. So rapid the first version I pushed to the server used fare-memoization for caching ;)  I also used a Vagrant VM to test the deploying locally. If I can I'll take the Vagrant definition and the Ansible playbooks and add them to the Lucerne project skeleton generator so the problem of server orchestration and infrastructure is solved for you the moment you create the project."
lisp,3c7f56,madmax9186,2,Mon Jul 6 15:47:54 2015 UTC,"Thanks for the awesome reply! I think I'm going to have to cook something up with this, sometime soon. Thanks for your hard work."
lisp,3c7f56,gaigepr,5,Mon Jul 6 16:30:18 2015 UTC,"Wonderful, and with decent documentation too. Thank you!"
lisp,3c7f56,gaigepr,2,Sun Jul 5 18:06:56 2015 UTC,This reminds me a lot of Ring on clojure. See this.
lisp,3c7f56,KDallas_Multipass,4,Sun Jul 5 18:03:29 2015 UTC,"Ring is more like Clack, Lucerne is most like a framework built on Ring."
lisp,3c7f56,nilved,2,Sun Jul 5 18:11:01 2015 UTC,"I'm unable to really grok this right now so can anyone (author) speak to the state of the framework? Beta, alpha, stable?"
lisp,3c7f56,PuercoPop,5,Sun Jul 5 19:08:05 2015 UTC,"From this point, the API will remain fairly stable, changing only if there is some change to Clack underneath."
lisp,3c6ayf,cmh,5,Sun Jul 5 06:17:39 2015 UTC,Time.
lisp,3c6ayf,pkhuong,1 point,Sun Jul 5 15:29:10 2015 UTC,What kind of time? I have a Raspberry Pi2 I could use for nightly builds.
lisp,3c6ayf,p_nathan,1 point,Mon Jul 6 01:27:29 2015 UTC,"I think at least 3 devs (those who worked on bootstrapping the ARM build) have ARM boards, but building and packaging doesn't score very high on interest:personal time."
lisp,3c6ayf,pkhuong,1 point,Mon Jul 6 22:40:03 2015 UTC,"I'd be willing to donate a Raspberry Pi 2 and an Intel Edison[1] if some SBCL developer wants them and would actually package releases and ensure all appropriate tests pass for them. I just can't provide the effort to do that myself.  [1] an Edison is a tiny dual-core x86 32-bit board running Linux; it builds & runs SBCL just fine in my experience, just as with the Raspberry Pi"
lisp,3c6ayf,zitterbewegung,2,Tue Jul 7 00:39:39 2015 UTC,"If it's just a matter of hardware, it wouldn't cost much for someone to donate a Raspberry Pi for Linux ARM hard-float Linux support, or an Intel Edison for 32-bit Intel/AMD Linux support. (Some people can't donate effort without significant red tape, if at all.)"
lisp,3c6ayf,stassats,3,Sun Jul 5 06:19:00 2015 UTC,Its probably a matter of hardware and also interest in porting to ARM. If you want the support the best way to do that would be to attempt to cross compile it yourself and then contribute back.
lisp,3bw3n3,brianqx,5,Thu Jul 2 17:05:36 2015 UTC,"There are several implementations, check this one. The documentation of the compiler is a bit off though.  https://github.com/DalekBaldwin/clometa/"
lisp,3bw3n3,PuercoPop,2,Thu Jul 2 20:09:04 2015 UTC,"It's incomplete, but is there anything wrong/misleading? The tests are probably the best documentation for now.  I'd like to revamp it after I do some more work on check-it. It would be really cool to be able to use a single representation of a grammar both for constructing compilers and for generating fuzz tests."
lisp,3bw3n3,DalekBaldwin,1 point,Fri Jul 3 02:59:14 2015 UTC,It appears misleading is a harsher tearm that I thought. What I meant is that when one uses the interpreter one uses define-ometa while on in the compiler one uses defgrammar and defrule which isn't documented in the readme. Yes the tests are the best documentation but because I found a readme I didn't went for the tests at first.
lisp,3bw3n3,PuercoPop,3,Fri Jul 3 04:48:27 2015 UTC,"I'd like to see a CL implementation of Marpa: https://jeffreykegler.github.io/Marpa-web-site/  Got an ambiguous grammar, get an abstract syntax forest."
lisp,3bw3n3,spacebat,2,Fri Jul 3 00:29:24 2015 UTC,http://subvert-the-dominant-paradigm.net/blog/?p=23 ometa in cl
lisp,3bsyi4,xach,7,Wed Jul 1 22:03:30 2015 UTC,Is there anything we can do to help things move forward?
lisp,3bsyi4,fmargaine,4,Thu Jul 2 06:57:03 2015 UTC,"I'm working on something along these lines, stay tuned."
lisp,3bsyi4,lispm,4,Thu Jul 2 11:48:53 2015 UTC,Great that you are still moving things forward!
lisp,3bsyi4,xenow,2,Wed Jul 1 22:07:44 2015 UTC,"I'm looking forward to #3 - being able to find a package without relying on a combo of googling and hitting old/non-quicklisp libraries.  Since a large portion of the available packages are on github nowadays, maybe the rating system could be tied to #'system-apropos and the data supplied from the github star rating that currently exists?  Using an API call like:  curl 'https://api.github.com/repos/quicklisp/quicklisp-client'   For instance returns a key, 'stargazers_count' of 120 for quicklisp-client."
lisp,3bsyi4,zodmaner,2,Thu Jul 2 02:23:34 2015 UTC,I'm slurping a lot of data from github right now for just that purpose. I'm also using download stats and VCS commit activity. I hope it helps.
lisp,3bsyi4,vittusormi,2,Thu Jul 2 11:35:06 2015 UTC,"Thanks for all of your hard works, xarch.  I've been using Quicklisp, Quickproject, and Buildapp to manage my projects recently, and they have make my life a whole lot easier."
lisp,3bt8e3,IAskAlotOfQuestions2,3,Wed Jul 1 23:21:23 2015 UTC,Check out Planet Lisp.
lisp,3bt8e3,bstamour,3,Thu Jul 2 00:34:51 2015 UTC,Check out http://www.pvk.ca/Blog/archives/
lisp,3bt8e3,bitmadness,2,Thu Jul 2 21:35:50 2015 UTC,"Besides planet lisp, I read language agnostic"
lisp,3bt8e3,PuercoPop,3,Thu Jul 2 15:31:41 2015 UTC,Hello gavino.
lisp,3bt8e3,muuh-gnu,1 point,Thu Jul 2 04:08:39 2015 UTC,at least he can be modded out here
lisp,3bt8e3,KDallas_Multipass,1 point,Mon Jul 6 15:43:51 2015 UTC,"For emacs lisp mmh… I wouldn't say steep because we can easily write useful functions (provided we have good documentation: http://wikemacs.org/wiki/Category:Emacs_Lisp + ergoemacs). But some concepts are really specific to emacs' text editing. Then you should read emacs blogs (see planet emacs, or /r/emacs)."
lisp,3bt8e3,dzecniv,1 point,Thu Jul 2 13:36:11 2015 UTC,"Note that ergoemacs.org is highly opinionated, but I've found valuable info on there in the past.  https://www.masteringemacs.org/all-articles  http://emacsblog.org/  http://planet.emacsen.org/"
lisp,3bt8e3,spacebat,0,Fri Jul 3 01:19:23 2015 UTC,Emacs Lisp Blogs? Maybe this one: http://ergoemacs.org/emacs/blog.html  The page also contains tutorials/documentation: http://ergoemacs.org/emacs/elisp.html  P.S. How do you define the steepness of a learning curve?
lisp,3bt8e3,chuchana,1 point,Thu Jul 2 11:11:56 2015 UTC,"Section 8. ""Steep learning curve"" of article  Learning curve:       The expression steep learning curve is used with opposite meanings. The term is often used in common English with the meaning of a difficult initial learning process.   Nevertheless, the Oxford English Dictionary, The American Heritage Dictionary of the English Language, and Merriam-Webster’s Collegiate Dictionary define a learning curve as the rate at which skill is acquired, so a steep increase would mean a quick increment of skill.    Arguably, the common English use is due to metaphorical interpretation of the curve as a hill to climb. (A steeper hill is initially hard, while a gentle slope is less strainful, though sometimes rather tedious. Accordingly, the shape of the curve (hill) may not indicate the total amount of work required. Instead, it can be understood as a matter of preference related to ambition, personality and learning style.)  The term learning curve with meanings of easy and difficult can be described with adjectives like short and long rather than steep and shallow.  If two products have similar functionality then the one with a ""steep"" curve is probably better, because it can be learned in a shorter time. (Fig 9) On the other hand, if two products have different functionality, then one with a short curve (a short time to learn) and limited functionality may not be as good as one with a long curve (a long time to learn) and greater functionality. (Fig 10)     Relevant: Learning Curve (Star Trek: Voyager) | Learning Curve (Babylon 5) | The Learning Curve   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
lisp,3bsv50,butlerccreltub,2,Wed Jul 1 21:38:21 2015 UTC,"List to cons cells makes sense. That's what you want to do. You need to define a grammar, it'll be something like this:  s-expression: `(` + <s-expression> + `)`  s-expression: <atom> atom: Number | String | Symbol | Character   You can then write a recursive descent parser to ensure that everything is formatted correctly, and then read in the data.    Should I make others have the ability to implement vectors, maps, etc. Or should I implement those myself?   That's entirely up to you! If you want to build those in; do it! You can extend the example grammar above appropriately, or you could just provide functions that make those data types. If you don't, that's alright too!"
lisp,3bsv50,madmax9186,2,Sun Jul 5 14:55:49 2015 UTC,Is there a spec for the full lisp grammar somewhere I looked and couldn't find it?
lisp,3bsv50,_Skuzzzy,1 point,Tue Jul 7 14:33:23 2015 UTC,You could try the hyper spec.
lisp,3bsv50,madmax9186,1 point,Wed Jul 8 01:43:08 2015 UTC,Reader Algorithm
lisp,3bsv50,gosub,2,Thu Jul 9 14:38:25 2015 UTC,"The ""Building Lisp"" series gives a really good walkthrough for creating a complete lisp (including a parser): http://www.lwh.jp/lisp/"
lisp,3bsv50,Sodaware,1 point,Tue Jul 7 16:11:01 2015 UTC,"THIS IS AWESOME, I'm gonna go and build the coolest lisp in the WORRRLLDDDD"
lisp,3bsv50,xach,1 point,Wed Jul 8 00:37:20 2015 UTC,What is it for?
lisp,3bsv50,eskatrem,1 point,Wed Jul 1 22:01:40 2015 UTC,"For creating a lisp, as well as creating a XML replacement with an s-expression like syntax. Basically, anything you would use s-expressions for."
lisp,3bsv50,jinwoo68,1 point,Wed Jul 1 22:13:06 2015 UTC,"Not sure I understand what you want to do.Your parser should convert a string like ""(1 2 3)"" into '(1 2 3)? Then ""(+ 1 (* 2 (- 3 4)))"" becomes '(+ 1 (* 2 (- 3 4)))  ?"
lisp,3bsv50,furych,1 point,Wed Jul 1 22:36:17 2015 UTC,"Maybe this shouldn't be on this subreddit.. I'm writing it in C, not lisp"
lisp,3bsv50,spacebat,1 point,Wed Jul 1 23:26:44 2015 UTC,Why in C when it's free if written in lisp?
lisp,3bsv50,spacebat,1 point,Thu Jul 2 02:56:29 2015 UTC,When I wrote mine I used cons cells to represent lists.  Actually all you other requirements just depends on how do you want to use it. I used it as a parser for the input data for my other libraries(instead of say XML); therefore my requirements probably differ.
lisp,3bsv50,wicked-canid,1 point,Thu Jul 2 07:50:12 2015 UTC,"Lists to cons cells makes sense. As for data types, that depends entirely on what your aim is. If you're just translating to/from xml, strings would do. If you're building a lisp, you'll want numbers at the very least and probably symbols as distinct from strings."
lisp,3bsv50,dastels,1 point,Fri Jul 3 00:34:55 2015 UTC,How are symbols different from strings?
lisp,3bpaxd,sbenitezb,5,Wed Jul 1 01:44:13 2015 UTC,"I'm actually working on a library that will do something similar right now. It's built on Electron, which is what the Atom editor uses to bring the web app to the desktop.  You could use cl-webkit and cl-gtk-cffi to do this with GTK, or use CommonQt (which has QtWebView support), the latter is probably simpler to distribute.  EDIT: You might also want to ask Andrew Lyon who shipped an app using node-webkit and Lisp."
lisp,3bpaxd,eudoxeea,2,Wed Jul 1 02:25:48 2015 UTC,"Great, several choices, thank you :)"
lisp,3bpaxd,orthecreedence,2,Wed Jul 1 02:56:55 2015 UTC,"Hi, Andrew here. I found that it was much, much easier to embed lisp into an existing browser than it was to embed a web engine into lisp.  Your two main choices are firefox and node-webkit. I wrote up some of my adventures embedding ECL into node-webkit. I also ended up doing this with firefox as well, using js-ctypes (basically CFFI for spidermonkey).  You'll want a messaging layer so the browser and the lisp engine can talk to each other, nanomsg worked great for this (and was the inspiration for cl-nanomsg).  It was definitely a learning experience (a long one), but in the end I was able to integrate a large portion of the app into lisp and have the browser and lisp messaging/eventing over nanomsg pretty seamlessly. Fun stuff.  I'd say in the end it was probably much easier using js-ctypes in firefox than it was to build a node module in C++ that plugged into nanomsg/ECL. It might be easier if you're just compiling for nix, but dealing with gyp and the node API on windows is a nightmare.  The repo for the project is here: turtl-core and the desktop app that used it: desktop-ff.  Hope this helps."
lisp,3bpaxd,SpaceCadetJones,1 point,Wed Jul 1 19:50:35 2015 UTC,"Do you have a blog or anything for your project that I can check on? I was thinking of doing something similar, but after doing the research I decided it was a little over my head at this point considering I have no experience with embedding WebKit into a program. I've been trying to find out how to use HTML/JS as a UI for a C++ program since it's cross platform, I'm familiar with it, and I don't care about a native feel. I was looking into Chrome Embedded Framework but it looked like it was more trouble than it's worth and might not be exactly what I'm going for. It seems like my best bet might be to have two processes with the C++ running an HTTP server or maybe communicating between the UI and C++ with WebSockets. That feels like a lot of indirection/overhead though.  Sorry for the rambly noob post, i'm hoping someone might be able to point me in a good direction. If I was doing a typical desktop app I'd probably just go for Electron, but I'm not a fan of JS for larger projects and I'm hoping to do some work with real-time audio."
lisp,3bpaxd,eudoxeea,2,Wed Jul 1 17:18:04 2015 UTC,"I haven't blogged about it since it's not a large enough project (yet, at least) that it deserves its own blog.  Here's a screenshot of it in action. That's the interactive mode, where you can create windows dynamically for prototyping, and there'll be a compiled more where you can bundle an app and ship it as an executable (that's a bit more complicated, and it's what I'm working on now).  Anyways, it will be out, at the latest, in a few weeks. I'll announce it here when it's usable.  I also tried CEF3, but it's very complicated to bind and build. Node-webkit/Electron are ugly since they introduce a completely unnecessary Node layer between the browser and Lisp, but the community produces binaries for every platform, which solves the problem getting the various WebKit parts compiled on every platform. I settled on Electron after taking a look at the documentation, when it became obvious it was perfect for what I wanted.  In any case, my project has a fairly modular design, so if it became necessary you could alter the underlying implementation (e.g., to use Chrome binaries, an approach I considered) without affecting the interface much."
lisp,3bpaxd,orthecreedence,1 point,Wed Jul 1 21:33:35 2015 UTC,"Hey, have you used node-webkit? I'm curious how Electron compares to it. NW has some warts and I'm wondering if Electron is more updated."
lisp,3bpaxd,eudoxeea,2,Wed Jul 1 19:51:39 2015 UTC,"Never actually used NW, but I have used Electron successfully."
lisp,3bpaxd,abicidario,3,Wed Jul 1 21:28:48 2015 UTC,"Maybe not what you seek for (except for stealing some idea), but here are some examples using ECL and WebKit for a GUI.  They use a QtWebkit/Lisp bridge, which is easy to implement using ECL. It also shows how to use Qt plugin widgets.  The Tic-Tac-Toe example doesn't require any Qt knowledge."
lisp,3bpaxd,fmargaine,2,Wed Jul 1 10:35:14 2015 UTC,https://github.com/AeroNotix/lispkit is an example of a browser using cl-webkit.
lisp,3bpaxd,anvilcountry,0,Wed Jul 1 08:31:01 2015 UTC,I think the book ANSI Common Lisp by Paul Graham has you code a html server
lisp,3boq96,lispm,9,Tue Jun 30 22:29:37 2015 UTC,"Let's face it: without the speaker, such slide-sharing is pointless."
lisp,3boq96,cym13,3,Wed Jul 1 11:18:46 2015 UTC,let's hope someone release the talk.
lisp,3boq96,agumonkey,2,Wed Jul 1 17:22:40 2015 UTC,cute
lisp,3boq96,spacebat,2,Wed Jul 1 00:10:22 2015 UTC,"Hi there, I'm the noob who talked about it. I just wrote a small article with a few examples I used during the event (it was not recorded). https://ehret.me/and-keep-calm-hack-lisp/"
lisp,3boq96,SiegfriedEhret,2,Sun Jul 5 17:35:27 2015 UTC,I'd say that reddit cared (past tense) about lisp.  They eventually ended up rewriting it in Python.  Side note:  I wish they'd open source the lisp version of the code.
lisp,3boq96,metaobject,2,Wed Jul 1 16:02:59 2015 UTC,"I don't remember that there was much work in it. I doubt it is worth it. When it happened, there was a sport for a short period of time to reimplement Reddit (or what it was in the early days) in Lisp as quick as possible."
lisp,3boq96,vityok,1 point,Wed Jul 1 22:02:58 2015 UTC,There was also an excellent screencast with an attempt.
lisp,3boq96,WalterGR,1 point,Tue Jul 7 15:52:47 2015 UTC,Link?
lisp,3boq96,vityok,1 point,Fri Jul 10 00:50:10 2015 UTC,For whatever reason I can no longer find it in the Web. The only thing that is left of it is Episode 2 in poor quality and without sound...
lisp,3bo05a,PuercoPop,1 point,Tue Jun 30 19:19:58 2015 UTC,Link to its repo: http://git.cafeobj.org/?p=cafeobj.git;a=summary
lisp,3blviy,lispm,7,Tue Jun 30 07:23:11 2015 UTC,"I use stumpwm on my Linux machine, and it feels really good that I'm in a live lisp environment. Like a WM version of Emacs."
lisp,3blviy,jinwoo68,2,Tue Jun 30 14:48:39 2015 UTC,Is it a robust window manager? Does it generate a lot of load on the CPU and RAM?
lisp,3blviy,vityok,3,Wed Jul 1 10:59:22 2015 UTC,It's pretty robust. Haven't seen any significant issues for several years. There are some minor glitches but I can bear with them. But beware that it's a tiling window manager and it may not be for you.
lisp,3blviy,jinwoo68,2,Wed Jul 1 14:34:12 2015 UTC,"I use it with a single core pentium M (1.6 Ghz) and its super snappy and responsive (my machine also only has 1.5G ram and stumpwm + vimprobable2, the browser I'm posting on, is only using 300M RAM)."
lisp,3bihip,z27,7,Mon Jun 29 14:29:17 2015 UTC,"Great read for defmethod and such - I notice the author used lispbuilder-sdl and cl-opengl.  When I was in #lispgames a few months back, they mentioned lispbuilder-sdl has been more or less replaced by something else, but i can't remember what.  What are the current cl-opengl / lispbuilder-sdl equivalents (that aren't outdated)?  I assume something that uses sdl2 (or whatever current SDL is)?"
lisp,3bihip,xenow,8,Mon Jun 29 15:48:41 2015 UTC,cl-sdl2 https://github.com/lispgames
lisp,3bihip,Baggers_,5,Mon Jun 29 23:43:13 2015 UTC,"This has been posted here on reddit 4 years ago, still a page to keep handy while studying CLOS.  I really liked the ""Theory of Operations"".  Elsewhere its creator says (http://pages.cs.wisc.edu/~psilord/blog/38.html):  ""[...]  The biggest surprise was just how plainly useful multi-methods were. Multi-methods are generic methods which can specialize on more than one parameter. This is usually implemented with the Visitor Pattern in other languages which only support single dispatch. Having multiple dispatch readily in the language (and integrated with the rest of Lisp) prevented a lot of other code from being written that would obfuscate the intent. I appreciated this enormously. I find that I truly enjoy looking at code whose signal to noise ratio is very high.  [...]  I wrote up a Theory of Operations document which is also a postmortem so you can both understand the code and my thought process in writing it. I provide the source so you can see it work for yourself."""
lisp,3bihip,yokhahn,1 point,Mon Jun 29 14:30:53 2015 UTC,"""an interesting page to forgo"" is like ""a face made for radio""."
lisp,3bihip,Baggers_,1 point,Mon Jun 29 15:16:08 2015 UTC,"Thanks for the correction, amusing too."
lisp,3bihip,Baggers_,5,Mon Jun 29 17:17:21 2015 UTC,"I know the author, and he says that immediate mode was just a simple crutch so he could get the logic of the game working, he'll move to a real opengl API soon in the game.  He hangs out in #lispgames on freenode and is happy to talk to people.  No reddit account... "" I don't want another login. :)""  Edit: one more comment from him ""when I finish adding levels, I'll mark the game as 1.0 and write another theory of operations detailing how the new stuff is done and why it changed."""
lisp,3bihip,Baggers_,2,Tue Jun 30 04:51:53 2015 UTC,Neat. I've been wanting to know how to combine lisp and accelerated graphics.
lisp,3bfnym,bitmadness,21,Sun Jun 28 20:24:33 2015 UTC,"Whoever the saints are that continue development on this wonderful piece of engineering, kudos to them!  While I haven't upgraded in about a year, I appreciate their hard work.  I've used SBCL on more than a few medium-sized projects for my personal use and for work and it's always such a delight (especially using it through emacs/slime)."
lisp,3b7aht,xach,2,Fri Jun 26 15:27:30 2015 UTC,How does PSL relate to CL?
lisp,3b7aht,mrottenkolber,2,Fri Jun 26 16:56:53 2015 UTC,Wikipedia has a good overview: https://en.wikipedia.org/wiki/Portable_Standard_Lisp  I didn't know about PSL before today. It was created in 1980 and is apparently still part of some projects. It looks to me like Blake's release makes available a version that has been continuously updated and maintained.
lisp,3b7aht,lispm,1 point,Fri Jun 26 16:59:51 2015 UTC,See also:  http://www.softwarepreservation.org/projects/LISP/standard_lisp_family/
lisp,3b7slw,butlerccreltub,3,Fri Jun 26 17:38:58 2015 UTC,"I believe TinyClojure is unfinished project, so I'd go with TinyScheme. Also, I'm finding Scheme more suitable for embedding due language size, flexibility and maturity in the field (you have a bit implementations for embedding).  You will probably find bold advices to go away from TinyScheme and try something else (e.g. Chibi). Don't listen these as they probably didn't use it correctly. TinyScheme is wonderful small/fast interpreter and you should try both of them and see what suits you better."
lisp,3b2mzt,lispm,1 point,Thu Jun 25 13:53:42 2015 UTC,"I'm getting ""An unexpected error has occurred"" when I follow the link.  Edit:  it's working now"
lisp,3b2mzt,metaobject,2,Thu Jun 25 14:15:42 2015 UTC,"No, it works."
lisp,3b2urd,tankfeeder,2,Thu Jun 25 14:56:23 2015 UTC,"some ignored, testing against built-in functions, a lot of recursions, comments and patches are welcome."
lisp,3anz8t,lispm,5,Mon Jun 22 02:02:46 2015 UTC,Try forth. Look up JonesForth.
lisp,3anz8t,WarWeasle,3,Mon Jun 22 16:46:25 2015 UTC,I second this. I have had a lot of fun in the past with it: http://davazp.net/2012/12/08/eulex-forth-implementation.html
lisp,3anz8t,davazp,1 point,Mon Jun 22 21:13:15 2015 UTC,"How this is lisp-ish: the guy wrote an assembler, then a lisp in assembler, then a vm in lisp, then a language in lisp, then made that language self-compile. It demonstrates lisp as the bridge between bare metal and as high a level language as you'd like to design."
lisp,3anz8t,AgroBacteria,1 point,Wed Jun 24 15:22:06 2015 UTC,Is this lisp-ish?
lisp,3anz8t,JimH10,2,Mon Jun 22 09:52:45 2015 UTC,Says it is.
lisp,3anz8t,JimH10,0,Mon Jun 22 11:43:02 2015 UTC,"OK, I only looked through about half the deck, didn't see that, thought it was misfiled."
lisp,3an3hf,lispm,0,Sun Jun 21 21:09:57 2015 UTC,"Since when is (massively overpriced) Lispworks the Common Lisp of choice on OSX? It didn't even have OS-scheduled native threads up until a few releases ago. SBCL has a superior code generator and CCL offers similar performance + full access to OSX frameworks for free.   CAPI is a joke, the Lispworks IDE is inferior in every way to Emacs+slime so what does Lispworks offer exactly besides commercial support, which one can optionally have for both SBCL and CCL."
lisp,3an3hf,gammafactor6,2,Wed Jun 24 00:40:10 2015 UTC,"The LW IDE has a few features Slime doesn't have such as graphical browsers for systems and classes and a debugger that lets you set breakpoints without editing the code, due no doubt to privileged access to the Lispworks source. Version 7 has a new hobbyist category and adjusted pricing but its still not cheap.  That said, I don't personally own a license - I'm an SBCL user at home, and my use of Lispworks is 99% via Slime."
lisp,3actsc,defun_,25,Fri Jun 19 01:51:39 2015 UTC,I wish it didn't encourage its readers to define special variables without asterisks.
lisp,3actsc,xach,7,Fri Jun 19 12:12:58 2015 UTC,"as a beginner, following this kind of bit me, but then again I learned a valuable lesson from it.  (defvar special) (defun make-closure ()   (let ((special nil))     ;; I assumed special is lexically bound.     (lambda ()       ;; Here I _expected_ special to be bound to the lexically bound special       (setf special t))))  (funcall (make-closure)) ; => T ;; Now I still expected special to be unbound. special ; => T   In my particular example I was using a special named PAUSED?, and was hoping to set a lexical PAUSED? to T, but ended up pausing the whole system :-P."
lisp,3actsc,chebertapps,19,Fri Jun 19 15:12:47 2015 UTC,"It is excellent. From a practical, professional Common Lisp programmer standpoint, you probably never would use every ""trick"" (pattern, macro, etc.) in the book unless your team adopted them as coding standards. Knowing what is in the book is extremely worthwhile.   The author goes, in my opinion, a bit overboard with Lisp evangelism in LoL. I think in Lisp, so it doesn't bother me and can be fun at times. Just make sure you have your grain of salt handy. Consider whether what he presents makes sense for a team, as opposed to a one-person project. Even if you are one person, do you want your project to become a widely-used open source project? Will people have to learn everything in LoL before they can contribute?  LoL can be read after On Lisp and after PAIP. Or before - ymmv."
lisp,3actsc,itoowantone,3,Fri Jun 19 04:40:18 2015 UTC,Which one is PAIP?
lisp,3actsc,warped-coder,2,Fri Jun 19 13:58:07 2015 UTC,http://norvig.com/paip.html presumably.
lisp,3actsc,eleitl,1 point,Fri Jun 19 14:00:18 2015 UTC,"Paradigms of Artificial Intelligence Programming by Peter Norvig. It is classical AI. He has a newer book on the modern, statistical, approach. Also well worth reading, but it isn't in Common Lisp. Python, I think. PAIP still opens the mind to what Lisp can do."
lisp,3actsc,itoowantone,7,Fri Jun 19 21:00:08 2015 UTC,"LOL is a very insightful read.  (let ...) ==> scoping  (lambda (let ...)) ==> functions  (let (lambda (let ...)) (lambda (let ...))) ==> objects  (lambda (let (lambda (let ..))..)) ==> packages  LOL shows the power of composing scope and functions in a disciplined manner. It captures general ideas in a simple manner. LOL is a ""must read"".  Another worthwhile read is Lisp In Small Pieces which, besides being brilliant, is a literate program. You can run the source code from the book and get a running system. We need more lisp programs written like this. Instead of ""just code"" you get a complete, readable, runnable literate document.   Queinnec motivates every portion of code and provides background. It really ""raises the bar"" for lisp programmers. If lispers wrote like this then lisp would be well ahead of the whole programming field.  http://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec-ebook/dp/B00AKE1U6O"
lisp,3actsc,timdaly,6,Fri Jun 19 19:05:37 2015 UTC,"I thought it was one of the best lisp books I've read, on its own terms. Quirky, but worthwhile."
lisp,3actsc,MrWoohoo,5,Fri Jun 19 03:45:08 2015 UTC,"I think most of the bad reviews were from only reading the first few chapters, perhaps because those were on the author's website. However, while the beginning is a bit lackluster, the rest of the book picks up steam quickly and is quite enjoyable.  You should read Let over Lambda after feeling comfortable with On Lisp, maybe earlier if you are brave."
lisp,3actsc,chaoky,5,Fri Jun 19 02:45:30 2015 UTC,"I own it. It's...very advanced. I can tell it's very good, but way beyond where I am in Lisp (I basically dabble periodically). There's stuff near the beginning about anaphoric macros that already blew my mind and that was the appetizers."
lisp,3actsc,OldShoe,5,Fri Jun 19 01:55:23 2015 UTC,"I loved it. I loved the crazy ideas and his writing style and attitude. It's not very thick, but I see that as a big plus."
lisp,3actsc,maufdez,4,Fri Jun 19 09:20:38 2015 UTC,"IMHO this book is very good, if you want to open your mind to what can be done with closures and macros, you need to read it in order, since some things build on previous things (that is the case in many LISP books, like OnLisp or Paradigms of Artificial Intelligence Programming), I love the FORTH chapters at the end, you get to learn a bit of FORTH too. :)"
lisp,3actsc,kmmbvnr,3,Fri Jun 19 14:15:12 2015 UTC,"It's definitely good book, if you are studying lisp and it's not your first lisp book.  I was impressed when found some of solutions from this book in the clojure."
lisp,3actsc,patrickwonders,3,Fri Jun 19 06:39:53 2015 UTC,"I love this book.  It's so unapologetic.  It just picks a direction and runs in it without looking back.  As others have mentioned, you want to be pretty comfortable with macros from books like On Lisp and Practical Common Lisp before diving into this book.  And, you wouldn't want it to be the only Lisp book on your shelf, but it's definitely a fun ride."
lisp,3actsc,ilurkedhere,2,Fri Jun 19 15:08:12 2015 UTC,I loved it. The writing style was really enthusiastic and unapologetic. It rekindled my interest in Lisp.
lisp,3actsc,SkoomaMudcrab,1 point,Fri Jun 19 21:18:37 2015 UTC,"It's excellent, read it right after On Lisp (or before, works too)."
lisp,3actsc,madmax9186,1 point,Fri Jun 19 17:27:01 2015 UTC,"More like ""Lambda over Lambda."" You know that you can express all lets as lambdas? Consider the following example:  (defmacro my-let (bindings &rest exprs)   ""Our own version of let.""   (if (or (not (listp bindings)) (member nil (map 'list #'listp     bindings)))   (format t ""Invalid variable binding(s) inside of \""~A\""~%"" bindings)     `((lambda ,(map 'list #'car bindings) ,@exprs) ,@(map 'list #'cadr bindings))))"
lisp,3actsc,racketnoob,2,Tue Jun 23 21:30:06 2015 UTC,"There are few people (very famous in the lisp and scheme word) who basically think that Let Over Lambda is ""just an overall bad piece of text"". See this discussion.  My opinion is that those people are pretty weird hygienic fanatics who, more than anything, likes to write numerous  useless dull academic papers about shortcomings of stateless web that leads to booking on the wrong flight!"
lisp,3actsc,iouwt,6,Fri Jun 19 16:25:39 2015 UTC,"They do excellent and worthwhile stuff IMO, but it's established that they are not fans of LoL or Common Lisp."
lisp,3actsc,racketnoob,-10,Sun Jun 21 22:45:56 2015 UTC,"Ah, Racket people: worst community ever, full of arrogance and deep shit!"
lisp,3actsc,iouwt,5,Mon Jun 22 21:40:56 2015 UTC,That's some deep and entirely needless hostility there.
lisp,3actsc,cparen,2,Tue Jun 23 17:02:37 2015 UTC,"I'm pretty sure the ""dull academic paper"" you link to is from continuation fanatics, not hygiene fanatics. I admit that there may be some overlap."
lisp,3a5zu5,z27,4,Wed Jun 17 14:27:55 2015 UTC,"I found it useful, since DDG is my default SE now.  If I do not find what I am looking for, I can always use the google bang, !g, ie loop on Google"
lisp,3a5zu5,handle0174,6,Wed Jun 17 14:33:57 2015 UTC,"I remember that referring to a different site so I checked ddg's docs. !l1sp takes you to Xach's very nice redirect service. !clhs takes you to a LispWorks search that I haven't seen before.  Three keywords, that's some pretty nice lisp support:)"
lisp,3a53bj,yynatago,10,Wed Jun 17 08:11:02 2015 UTC,"(reduce #'+ ""two hundred and fifty nine""        :key (lambda (char) (let ((delta (- (char-code char) (1- (char-code #\a))))) (if (<= 1 delta 26) delta 0))))"
lisp,3a53bj,Grue,9,Wed Jun 17 13:15:27 2015 UTC,"FOO 26 > (CL:EVAL           `(CL:LET                ,(CL:LOOP FOR I FROM 1 UPTO 26                          COLLECT (CL:LIST                                   (CL:INTERN                                    (CL:STRING                                     (CL:CODE-CHAR                                      (CL:+ (CL:CHAR-CODE #\A) I -1))))                                   I))              (CL:+ T W O H U N D R E D A N D F I F T Y N I N E))) 259"
lisp,3a53bj,lispm,5,Wed Jun 17 08:42:52 2015 UTC,How many such numbers exist?  That sounds like a Project Euler problem.  It must be a finite set as the written form grows exponentially with length and the sum only grows linearly.
lisp,3a53bj,smithzv,2,Wed Jun 17 13:06:42 2015 UTC,"Fun idea. I guess you could write a bruteforcer. IMHO the most difficult part would be to ""spell"" a number:  1 -> ""one""  2 -> ""two""  ...  259 -> ""two hundred and fifty nine""  I think it's difficult because there are many irregularities: how would your function know if 318 is ""three hundred eighteen"" or ""three hundred and eighteen""?"
lisp,3a53bj,eskatrem,7,Wed Jun 17 14:04:05 2015 UTC,"I think you would have to just scan until you can prove that you will never find another match.  Presumably, since we are in /r/lisp, we would base it on the output of the ~r directive, i.e.  (format nil ""~r"" 1234) ==> ""one thousand two hundred thirty-four"""
lisp,3a53bj,smithzv,1 point,Wed Jun 17 14:53:54 2015 UTC,"Wow, I didn't know about this feature of format. Quite impressive! So now it's straightforward. The challenging part then would be to do the same exercise for languages other than English, so one would have to implement the spelling of numbers from scratch."
lisp,3a53bj,eskatrem,1 point,Thu Jun 18 12:14:57 2015 UTC,You're right about other languages.  My ethnocentrism blinded me to that possibility.
lisp,3a53bj,smithzv,3,Thu Jun 18 15:31:40 2015 UTC,Can't format print long pronunciations of numbers via a certain control string?
lisp,3a53bj,xenow,3,Wed Jun 17 14:30:50 2015 UTC,"The spelling part is easy:   (format nil ""~R"" 259) => ""two hundred fifty nine"")   The irregularities could be handled by adding ""and"" to every number greater than 99 and not evenly divisible by 100."
lisp,3a53bj,bobbane,2,Wed Jun 17 14:40:02 2015 UTC,"how would your function know if 318 is ""three hundred eighteen"" or ""three hundred and eighteen""?   Don't Americans say it as ""three hundred eighteen"" while literally everyone else on the planet that speaks English says the ""and""?"
lisp,3a53bj,milesrout,2,Fri Jun 19 10:17:17 2015 UTC,"...was there something to win here? If yes, who ""won""?"
lisp,3a53bj,abicidario,2,Wed Jun 17 21:44:58 2015 UTC,"(loop for i below 1000       for j = (reduce #'+ (remove-if-not #'alpha-char-p (format nil ""and ~r"" i))                       :key (lambda (c) (- (char-code c) (char-code #\a) -1)))       when (= i j) collect i)  => (251 259)"
lisp,3a53bj,cog2011,1 point,Thu Jun 18 06:21:32 2015 UTC,Thought this was /r/bitcoin for a second...
lisp,3a53bj,Anen-o-me,1 point,Wed Jun 17 21:11:39 2015 UTC,picolisp  https://bitbucket.org/mihailp/tankfeeder/src/d9c33c9fa75980a805a13dc51442b27d9dec5ece/259.l?at=default
lisp,3a53bj,tankfeeder,1 point,Wed Jun 17 14:46:12 2015 UTC,"in Clojure  (reduce #(+ % (- (int %2) 96)) 0 ""twohundredandfiftynine"")"
lisp,39ydyj,lispm,22,Mon Jun 15 20:18:06 2015 UTC,"This is one of the most impressive bodies of work I've ever seen. He wrote his own common lisp dialect that targets the LLVM that allows for C++ libraries to be utilized and designed a framework for creating biological macromolecules in silica that is backed by experimental work. This isn't just some pie-in-the-sky, ""oh jeez isn't that nice"" kind of simulation that comes along once in awhile. It is a simulation that makes accurate predictions in the real world!"
lisp,39ydyj,J_M_B,6,Tue Jun 16 05:24:35 2015 UTC,"I have immense respect for him having talked with him about a few of the llvm-related problems he was working on. Exception handling is hard, and this guy just picks it up after a week or two of fussing with it."
lisp,39ydyj,hotoatmeal,5,Tue Jun 16 14:44:18 2015 UTC,Christian Schafmeister here. Thanks for the nice comments!  Exception handling is hard and without the friendly help of llvm'ers on OFTC#llvm I wouldn't have made it.  Especially Eric Christopher (echristo) at Google - I would have been lost without his help.
lisp,39ydyj,drmeister,15,Wed Jun 17 20:26:27 2015 UTC,Great audio and video quality. Thanks for presenting and sharing!
lisp,39zlis,drudru,11,Tue Jun 16 01:53:31 2015 UTC,"The this UI of Symbolics Genera is called 'Dynamic Windows'. A portable version for Common Lisp is called CLIM (Common Lisp Interface Manager). A open source variant is McCLIM.  Let's say we have a flowchart editor. A flowchart consists of steps/tasks and transition. Steps would be drawn as box with some added infos (icons/text) and transitions would be drawn as arrows.  Now an application window has panes: title, the application drawing area, a menu and a command loop.  The application window and the panes are objects. When we start the application the objects gets created and each application runs its own command loop in a separate thread. The default command loop takes commands and executes them.  Everything you do on an application level in the flowchart editor then is a command: create flowchart, add task, link tasks, move task, delete task, delete link, show task details, ...  Each command is implemented as a Lisp function which takes typed arguments and a bunch of other keyword or optional arguments.  The UI manager can take commands from the mouse, the keyboard (as keypresses) or for example from the command loop as commands like:  'move task task-33 400 500'. If you use the mouse to move the task, the interface manager will actually create that command give it to the command loop.  Now the question is, what is task-33 ? If you interact with the objects on the screen by moving the task with the mouse, then the user interface manager looks up the actual task-33 object (not the name, really the object) and will give it to the command. If you type the command as text, the interface manager needs a way to look up the actual task object from the name - so there needs to be some kind of registry for it.  The command loop in the application window provides a history, search, reuse of commands and input completion.  Does all that create a lot of objects? Yes. Zillions. So typically each command loop has a way to delete the history. Also the Garbage Collector has an option to delete histories of the various command loops to free up references.  So, what you see in the command loop are command objects with their arguments. Not text. They are printed as text, but behind the text there can be actual objects - due to output recording. The user interface by default records all output as the actually objects drawn and where they are drawn with what parameters. The command loop also remembers all the issued commands as objects.  See:   CLIM 2 Specification: Command Processing CLIM User's Guide: Commands McCLIM, McCLIM on Github Symbolics Common Lisp Interface Manager 2.0 PDF   Manuals for Symbolics Dynamic Windows:   Symbolics Programming the User Interface PDF Symbolics User Interface Dictionary PDF"
lisp,39zlis,lispm,3,Tue Jun 16 08:01:27 2015 UTC,"This is really fascinating. I read the intro pdf for McCLIM. I'm always blown away by how these people ""got it right"" in the early 80's. They immediately saw the weakness with the more traditional event based approach. This is so much more advanced than anything I've every used."
lisp,39zlis,old_K,7,Wed Jun 17 06:14:12 2015 UTC,"You should see https://www.youtube.com/watch?v=ZoFX2QYJhbY  In this video, it shows how to use S-Geometry to make and modify 3D objects.  By ""refer"" they use menu to select objects; by ""manipulate"" they right click on the ""refer""-ed object and pops up a context aware menu.  For the part ""associate text output with an object"", they are almost everywhere in Genera's non-image-related subsystems. For example, Symbolics Concordia https://www.youtube.com/watch?v=NOysrxexTXg  And there are many other Genera videos. In Genera, click anything you can click, and you get the associate text output.  About description of this system, it's certainly in Symbolics volumes of manuals somewhere. But of course, the heavy work is done by the underlying system, Dynamic Windows (I think). There is a tutorial on how to build a Game of Life demo: https://archive.org/details/bitsavers_symbolicssamDevelopmentTutorial_473824"
lisp,39xbv2,fmargaine,4,Mon Jun 15 15:48:51 2015 UTC,"When I first saw that music video, I knew I had to buy that book. I am currently reading and loving it."
lisp,39tynj,cheryllium,6,Sun Jun 14 19:19:01 2015 UTC,Nice work!
lisp,39tynj,oberlinbsd,4,Sun Jun 14 20:12:41 2015 UTC,You have a pull request that I made while commuting. I've an unfinished change that writes to streams so you can write to files or strings at your convenience.
lisp,39tynj,spacebat,2,Mon Jun 15 00:09:27 2015 UTC,Just merged. Thank you for contributing :)
lisp,39tynj,spacebat,1 point,Mon Jun 15 00:18:46 2015 UTC,"When I was hacking on the code I ran into something that didn't feel right. Converting example into example-files and example-strings, I wanted to create a variable with the generated DOM once, so the same content could be passed to write-files and write-strings. There wasn't a nice way to do this though, because the functions rows and cols have side-effects on the global variables, particularly running-css. The design decision to make the html content return in a value and the css go out of band into a variable was starting to bite.  I think a better approach would be to have all these functions return (values html css) and you could later add js as the third value. Or encapsulate these 'streams' into objects that are passed as a single but compound value. This way, your API can be relatively functionally pure and without side effects. Coping with the ids is another challenge, but they could be left implicit until resolved to concrete values at the output phase."
lisp,39tynj,spacebat,1 point,Mon Jun 15 23:21:48 2015 UTC,"You bring up a valid point. I chose to have state, instead of keeping the functions stateless (and thus functionally pure, as you put it), and it seems that that design decision is causing problems now. Consider it a lesson learned...  I think it's a good idea to encapsulate the streams as an object that can be passed around (using CLOS). We could perhaps turn each div into an object as well, and have the constructor assign a unique identifier to each div (this is possible with CLOS, yes?)   My other idea was assigning divs values based on list indices, since the nested divs are inside of lists, we could assign each one a value that is based on their location in the list, and this would be guaranteed to be unique... (does that make sense?)"
lisp,39tynj,spacebat,1 point,Mon Jun 15 23:50:47 2015 UTC,"Introducing objects and generic functions will impose a performance cost, but should lead to a more flexible design, should still be faster than PHP and the web is all about caching anyway.  Positional div ids could be a default behaviour that can be overridden by defining methods or setting slots on the object."
lisp,39tynj,spacebat,1 point,Tue Jun 16 01:21:47 2015 UTC,"Just a heads up, you may want to pull at some point because I made a little change (the call to reset-state was a little early, before the program was done with the variables).   Thanks for helping out :)"
lisp,39tynj,fmargaine,1 point,Mon Jun 15 01:31:39 2015 UTC,Good catch. I found time at lunch to implement writing to supplied streams and made another PR.
lisp,39tynj,spacebat,3,Mon Jun 15 03:56:35 2015 UTC,"I forget the name of the project now, but I recall seeing a framework that sat atop hunchentoot and it was based on composing pages from components; each component returned 3 values, some javascript, css and html. Then the framework would take care of putting them together into a coherent web page. Your project reminds me of this."
lisp,39tynj,xenow,1 point,Mon Jun 15 04:21:54 2015 UTC,Weblocks?
lisp,39tynj,wg1024,2,Mon Jun 15 06:57:48 2015 UTC,Found it: hh-web
lisp,39tynj,z27,2,Mon Jun 15 08:18:42 2015 UTC,How does it compare to cl-who? The syntax looks similar
lisp,39k9hp,vityok,5,Fri Jun 12 08:58:35 2015 UTC,"Shinmera, this is outstanding work, keep it up"
lisp,39k9hp,Baggers_,2,Fri Jun 12 13:08:39 2015 UTC,"The site is down now for whatever reason (reddit effect???). However, after posting the link I have found out that Shinmera has a real name: Nicolas Hafner."
lisp,39k9hp,Shinmera,3,Fri Jun 12 13:23:02 2015 UTC,"I'm not sure what could've been the cause of that downtime, the site was up at the day of your post."
lisp,39k9hp,lispm,1 point,Sun Jun 14 17:41:53 2015 UTC,"I was under the impression that there are useful Gtk+ interfaces for Lisp? I haven't used them, but there are some tutorials.  Would one really want to use Qt? Just asking, I have zero practical experience with Qt."
lisp,39k9hp,zodmaner,7,Fri Jun 12 09:59:57 2015 UTC,"QT in general has better APIs and documentations than GTK+, as well as better cross-platform supports.  Not to mention that most GTK+ bindings for Common Lisp seem to have been abandon."
lisp,39k9hp,lispm,1 point,Fri Jun 12 11:33:12 2015 UTC,Here is a relatively recent GTK+ lib for CL: https://github.com/crategus/cl-cffi-gtk  Both LispWorks and Allegro CL use GTK+ for their GUI libs (CAPI and Common Windows) and their IDE on Linux.  http://franz.com/support/documentation/current/doc/cggtk-relnotes.html  http://www.lispworks.com/documentation/lw70/RNIG/html/readme-24.htm#pgfId-892516
lisp,39k9hp,sionescu,5,Fri Jun 12 16:20:24 2015 UTC,"Qt works pretty much as-is on Linux/OSX/Win32, it's a remarkably well done compatibility layer, whereas Gtk+ is only practically useable on Linux. CAPI is more like Qt itself, it has 3 separate implementations."
lisp,39k9hp,itoowantone,3,Fri Jun 12 23:41:02 2015 UTC,"The Qt API is huge and of high quality, not just GUI stuff."
lisp,39k9hp,abicidario,3,Fri Jun 12 16:18:37 2015 UTC,"Qt would like to be seen (and maybe is, to some extent) the ""industry standard cross-platform UI"" for professional desktop GUIs, if you are not exaggeratedly fixated on OS particularities (especially OSX).  But it's particularly hard to make good language bindings for Qt, because of their attitude grown out of the need to avoid C++ ugliness.  In fact, their MOC was (back then) a quite ingenious way to add dynamic behavior to a static language like C++. And this is where the binding problems begin...  Starting with Qt 4.5, a new macro Q_INVOKABLE was introduced, adding easy dynamic calling of any Qt function (by using the string name of the function), but which no language binding seems to want to use (except EQL for ECL)."
lisp,39mngt,htuhola,10,Fri Jun 12 20:36:27 2015 UTC,"I've always seen Lisp as a very low level language. Assembly is a low level concrete language; Lisp is a low level abstract language. Assembly is close to the machine; Lisp is close to the pure computation. Both shouldn't be used directly in most cases, but rather be used to build other languages on top of them.  So far languages are just being built on top of assembly (or bytecode, which is conceptually the same thing in my mind). Languages can absolutely be built on top of Lisp as well. Or both assembly and Lisp; developers would use the implementation built on top of assembly in production, and the implementation built on top of Lisp during development.  The point is, if there were language implementations built on top of Lisp, it would be easy to have something like you're suggesting, where anyone can easily tinker with the grammar or semantics of a language. Or you could just download a couple files off the internet and be ready to go with a new language, or a popular extension to an existing language. You could click a checkbox to enable/disable extensions to a language.  Also, since all languages would have an underlying representation of a Lisp program, it wouldn't be too hard to have interoperability between any two languages. All data structures in any language would have an underlying representation of an M-expression, and could all be printed out as S-expressions. People could write functions that map the M-expression of a std::vector to the M-expression of a Python list. Then you could do things like this:  std::vector<int> numbers = {1,2,3,4,5,6,7,8,9,10};   ...somehow pass symbol ""numbers"" across language boundary lines from C++ to Python  squares = [x*x for x in numbers]   ...somehow pass symbol ""squares"" across language boundary lines from Python to C++  for (int x : squares) {     std::cout << x << ' '; }   Output: 1 4 9 16 25 36 49 64 81 100  That's cute, but the real practical implication is the ability to use any library -- written in any language -- in any other language.  Reference implementations of languages could be described in Lisp. Language standards would include Lisp code from the reference implementation -- inline. A literate programming document. Standards committees would easily be able to prototype tons of new language features. Hell, they could straight up beta test their proposals.  So how can a language be built on top of Lisp? Well, code in any language is parsed into a tree. Lisp programs are trees that can execute. So you basically just specify a grammar, and define a function for the non-terminal symbols, or the attributes, or both.  Each function can either do some end computation or help build a new tree (or graph). An example of end computation is for the ""op_add"" non-terminal symbol of a simple arithmetic grammar: (define (op_add lhs rhs) (+ lhs rhs)). An example of building a new tree is when more complicated languages construct a semantic graph from a syntax tree. For C++, you could have a (define (class_stmt ...) (...)) for the syntax tree. That function would register class metadata somewhere in the semantic graph, as well as the class name in the semantic graph's symbol table.  If your language has a semantic graph, you would also need to define a function for each of its various symbols.  Lastly, the function for the top-level symbol would serve as the language's runtime. In C++ for example, the top level symbol is the translation-unit, and its purpose would be to first build out the entire semantic graph, then locate the function with the name of ""main"" within the graph, and then evaluate it."
lisp,39mngt,jtredact,1 point,Sat Jun 13 08:48:12 2015 UTC,"I am excited about potential near-term advantages for now. How it affects language design and provides the kind of possibility for the language to evolve in ways that used to be exclusive for lisp only. How the parser accepts grammars that can be richer than traditional deterministic grammars yet still unambiguous.  Different languages require different things from their implementation.  For example: Lazy pure functional, logic programming, dataflow or functional reactive, object oriented imperative. The implementations, libraries and interfaces between those all four can vary a lot. Though I agree they should inter-operate much better than they do.  I hate reliance to header files and lack of type annotations in shared libraries. That's the biggest suffering point in interfacing with C libraries today."
lisp,39mngt,JohannWolfgangGoatse,5,Sat Jun 13 13:44:05 2015 UTC,Could you give a concrete example of what you are talking about?
lisp,39mngt,jtredact,2,Fri Jun 12 23:06:47 2015 UTC,"Prior this post I started to prepare my interpreter for the parsing engine. It still takes few days. But I can give an example of how it will work.  Say you've got a context-free grammar with attributes, such as this:  expr -> expr1 expr1 -> :add expr1 '+' expr2 | expr2 expr2 -> :mul expr2 '*' term | term term -> :int number term -> '(' expr ')'   You may make an interpreter that corresponds to it:  (define (post_add env lhs rhs) (+ lhs rhs)) (define (post_mul env lhs rhs) (* lhs rhs)) (define (post_int env digits) (int digits))   Then you have something written in this language eg. 15 * (5 + 2)  Now if you've got a parsing engine, you may feed this grammar and interpreter to get yourself an interpreter for this language. Then you may feed it the input string and request result.  The parser internally determines whether the input it gets is unambiguous against the grammar while it traverses through the parse using your interpreter and finally returns the result.  pyllisp is the interpreter I'm customizing for this kind of use. I intend to push early results into the repository this weekend. The early parser is called from outside the implementation. After I have the parsing engine available from within the language, it will become capable of doing the feat described above."
lisp,39mngt,spacebat,2,Fri Jun 12 23:34:28 2015 UTC,"So basically, grammar spec + one function per attribute => magic box => full interpreter?  I thought things like that already exist, no? What do you mean by mutable grammar? Do you mean - for example - the user of the compiler can provide this override file:  expr2 -> :mul expr2 'x' term | term | expr3    //Override rule expr3 -> :neg '-' term    //New rule  (define (post_neg env term) (* -1 term))   Then instead of 15 * (5 + 2), you can write 15 x (5 + -2)?"
lisp,39mngt,ruricolist,1 point,Sat Jun 13 07:24:36 2015 UTC,That is exactly what I mean by mutable grammar.
lisp,39mngt,combinatorylogic,3,Sat Jun 13 12:01:11 2015 UTC,"Perl6 allows the grammar of the language to be extended. Though this is an old post, its a core aim of the language and the status of perl6 is closer to the fabled version 1.0 than ever: http://perlgeek.de/en/article/mutable-grammar-for-perl-6"
lisp,39mngt,combinatorylogic,2,Sun Jun 14 04:37:49 2015 UTC,"So the idea of letting user to change the grammar is at least or older than perl6. I keep wondering what are the implications. The cost of parsing complex grammars is still there even if the parser would manage to take care of popular deterministic grammars in linear time. It remains to be observed how much this really affects the usability in practice.  I just got myself a bytecode format into the interpreter, so I wouldn't have to bother with low level representations of the parser. The approach allows me to construct the parser and bytecode compiler in another high level language than my own and make it driven by an attribute grammar. When it's sufficiently developed I can implement the parser engine and the compiler in my language. The bootstrap parser remains functioning with less effort because part of the parsing is driven by the grammar, which can be shared by the implementations.  I also made sure the bytecode allows encoding new instructions without needing changes into format. This is feasible because due to JIT compiling the bytecode is no longer very performance critical portion of the implementation."
lisp,39mngt,combinatorylogic,6,Sun Jun 14 13:12:17 2015 UTC,Have you looked at all into Racket?
lisp,39mngt,combinatorylogic,1 point,Sat Jun 13 02:07:32 2015 UTC,"I have, and I am aware this could be done in Racket as well. I wouldn't have to roll my own implementation.  The implementation method I've chosen is quite pleasant to use. Also I've already rolled and experimented with other ideas prior to this. I don't think it competes with Racket. I gladly approve and review it if someone implements this kind of parsing engine in Racket."
lisp,39mngt,xieyuheng,2,Sat Jun 13 12:28:13 2015 UTC,Take a look at https://github.com/combinatorylogic/mbase - a PEG-based layer over Lisp.
lisp,39mngt,geocar,2,Sat Jun 13 08:13:27 2015 UTC,"Your link is cool and potentially useful take on the subject. But its reliance of PEG may make it less useful in practice. Jeffrey Kegler's take on PEG can be aggravating to read, but there's some point to what he says about the subject.  PEG requires more care on how you construct the grammar because the order in which you give the rules affect which language is accepted. When using context-free grammars the parser can inform you on where the language is ambiguous.  The distinction is less severe if you work with PEG as if it you worked with hand-written parsers. That is design the whole language at once and never change it again. But if you allow users to extend or modify the language, then minor changes into the PEG grammar can change the language in unexpected ways.  For example, adding a new rule that uses '+' -mark for something may override other use of '+' and change the meaning of existing programs without a warning if you use PEG. With context free grammars the parser will refuse to parse because it notes the ambiguity, providing more trust to what you can do with them."
lisp,39i6lx,fmargaine,4,Thu Jun 11 21:54:59 2015 UTC,I would strongly rethink using SAFETY 0 in production.
lisp,39i6lx,stassats,1 point,Fri Jun 12 03:50:36 2015 UTC,What is wrong with that?
lisp,39i6lx,-jwo-,3,Fri Jun 12 06:42:24 2015 UTC,At least on SBCL it means type errors can very easily corrupt memory and crash the process or worse.
lisp,39i6lx,lispm,4,Fri Jun 12 08:14:25 2015 UTC,"Zero runtime checks. It also may change semantics. Modify an array beyond it's size? Boom! Add an integer to a string. Boom!  The boom! might come at a later point, for example when the GC sees a memory corruption."
lisp,39i6lx,stassats,2,Fri Jun 12 10:53:40 2015 UTC,"Ah, fun stuff indeed. I'll just keep it to 1 then."
lisp,39i6lx,ruricolist,3,Fri Jun 12 11:41:51 2015 UTC,"What others said. (I had a problem with safety 0 which was actually inside SBCL which caused my bad code to silently corrupt memory, spend many months trying to reproduce and catch it.) If you need to use it, use only locally inside functions which you know are correct, even then the impact is often negligible, so checking that it actually helps is a good idea as well."
lisp,39i6lx,orthecreedence,3,Fri Jun 12 11:54:20 2015 UTC,"You would usually put something like this in the init file for your Lisp implementation: ~/.sbclrc for SBCL, ~/.ccl-init.lisp for Clozure, or so forth.  Bear in mind, though, you may get some nasty surprises by meddling with global defaults. Just for example, with those development settings, libraries that make use of tail recursion may not work properly.  And with those production settings, you'll certainly need some kind of external monitor process in case of a crash."
lisp,39i6lx,ruricolist,1 point,Thu Jun 11 22:14:43 2015 UTC,"Could be wrong (proclaim/declaim/declare have always been somewhat unclear to me) but I think you can use proclaim:   Establishes the declaration specified by declaration-specifier in the global environment.   So as /u/ruricolist said, I think you'd put that in your init file. It would be nice if there was a package-wide version of declaim/proclaim so you could run declarations within an entire package without affecting the rest of the global space. Or maybe there is a way...anyone know more about this?"
lisp,39i6lx,orthecreedence,2,Thu Jun 11 22:29:35 2015 UTC,ASDF's :around-compile would get you at least some of the way there.
lisp,39i6lx,lispm,1 point,Thu Jun 11 22:59:06 2015 UTC,Figured ASDF might have a baked-in solution. Thanks for the pointer.
lisp,39i6lx,stassats,1 point,Thu Jun 11 23:01:27 2015 UTC,Hm it seems to be what I'd want... Thanks!
lisp,39i6lx,lispm,1 point,Fri Jun 12 06:54:51 2015 UTC,A DEFSYSTEM should provide that feature. For example the LispWorks DEFSYSTEM has :optimis^hze options for the system and its members.
lisp,39ftpy,tankfeeder,2,Thu Jun 11 13:00:54 2015 UTC,"I would really like to use any Lisp in these things: esp8266. Lua is already available there and uPython IIRC, is a well advanced WIP."
lisp,39ftpy,sfandino,2,Thu Jun 11 20:49:57 2015 UTC,"I'd really like to see how much a lisp-based development environment would speed up embedded development, a lot of the time I normally spend on embedded hardware is the 2 minute cycle of trying a different value or changing a small thing in the code, recompiling and then reuploading it.  I might experiment a little with this later, looks pretty promising."
lisp,39ftpy,Combinatorilliance,7,Thu Jun 11 21:55:33 2015 UTC,"Ever tried Forth? It's essentially built for that type of thing, available on almost everything, and not that hard to implement a simple version if it's not.   It's also worth learning because stack-based programming is odd."
lisp,394s7o,z27,3,Tue Jun 9 06:48:29 2015 UTC,"In isolation, maybe a few, like double doubles."
lisp,394s7o,xach,2,Tue Jun 9 11:57:11 2015 UTC,"double doubles   Interesting, in my deep ignorance that was the first time I heard about double doubles. I have found some comparison here (http://www.cs.berkeley.edu/~mhoemmen/lisp-matrix/www/floating-point.html), without CMUCL though.  One could wonder why CMUCL developers spend quite a bit of effort on it, when its siblings (like SBCL) could benefit more from their work. Perhaps because they are part of the original team?"
lisp,394s7o,xach,9,Tue Jun 9 12:35:18 2015 UTC,"In my experience, work isn't transferable. People work on what they want to work on, regardless of how much better it would be for others if they worked on something else instead.  In the specific case of CMUCL, I know that Raymond Toy knows CMUCL well, and has used it for many years, so I'm sure his ongoing work on CMUCL has direct personal benefits."
lisp,394s7o,bigsweatyfireman,1 point,Tue Jun 9 12:42:04 2015 UTC,"Thank you, that sounds the wise thing to do."
lisp,394s7o,eskatrem,0,Tue Jun 9 12:43:55 2015 UTC,Hemlock and slightly better Slime-support. Probably more.
lisp,394s7o,chaoky,2,Tue Jun 9 10:56:53 2015 UTC,Is Hemlock actually being used? I tried it once but it felt very incomplete.
lisp,3924m7,cheryllium,13,Mon Jun 8 18:24:45 2015 UTC,"Cool! A few ideas:   Create yourself an ASDF file for the project and load it via ASDF (instead of (load ""cl-mci"")). You'll come to appreciate this method more as you integrate with other libraries. defparameter is generally used on the root of the file (which you did, good job!), not within a function. So you declare global variables with defparameter top-level and then setf them from within functions (eg your set-song function). (= status 0) is generally written (zerop status). Not super important though, just a small style thing =]. In the play function you have an if that has a test, a true form, and a false form but the true/false forms are on the same line (0 (play) vs 0\n(play)) which makes it a bit harder for others to read (I thought at first you only had a true form).   Otherwise, good job! Calling out to C is a fun way to expand your available libraries, and it looks like you have the hang of it already.  To take it further, you're doing a lot of calling mcisendstringa directly with a lot of the same params over and over, maybe you could wrap that in a helper function that even takes an argument list (via &rest) or something to make it easier.  EDIT: forgot to mention...create and use a package. It will keep your functions/variable from bumping into other packages and lets you be more granular about which symbols to import into your project:  (defpackage :mp3-test   (:use :cl)) (in-package :mp3-test) ...   EDIT2: Put your function comments in the function:  (defun my-function   ""This function does something""   ...)"
lisp,3924m7,orthecreedence,2,Mon Jun 8 18:42:08 2015 UTC,"Thank you for your feedback! It was very helpful. I fixed several of the things you mentioned, and I'm looking into ASDF now. I wanted to ask you, do you know what the relationship is between ASDF and Quicklisp?"
lisp,3924m7,Aidenn0,6,Mon Jun 8 19:03:08 2015 UTC,"ASDF is a way of defining your systems (what other languages might call ""packages""); it stands for ""Another System Definition Facility""  Quicklisp is a client, plus a database of systems, that will let you just ask to load a system, and it will download the system, plus any dependencies automatically for you.  It relies on ASDF for all of the system definitions and loading.  If you have an ASDF system that is available under a permissive license, you can ask Zach Beane to add it to the quicklisp database, so that other's can use it."
lisp,3924m7,Baggers_,4,Mon Jun 8 19:21:57 2015 UTC,"Remember that, if you want a easy way to make an asdf compatible project, one of the best solutions is to use quickproject.   (ql:quickload :quickproject) (quickproject:make-project ""the-project-name"")  Done!"
lisp,38ya7j,eudoxeea,6,Sun Jun 7 21:40:41 2015 UTC,"It would be cool if we could persuade Travis to add built-in CL support so we could cut down the start-up time it takes to do a test run. But the CL user base is so small that I don't think they'd bother to add support for some obscure new implementation that might come along, or respond to feature requests nearly as fast as we could implement them ourselves in cl-travis."
lisp,38ya7j,DalekBaldwin,5,Sun Jun 7 23:21:34 2015 UTC,"Fernando, thanks for the awesome writeup. I've never really put in the time to figure out how travis works, but this really makes it simple to understand, especially in the context of CL.  Thanks for putting in the time."
lisp,38ya7j,orthecreedence,4,Mon Jun 8 18:26:29 2015 UTC,"I had to figure out myself how to do this, so I know how helpful this will be for other people. Thanks!"
lisp,38ya7j,davazp,2,Mon Jun 8 18:40:08 2015 UTC,"Very nice, thank you."
lisp,38ya7j,furych,2,Sun Jun 7 22:12:05 2015 UTC,Dim chimes in with another option: https://twitter.com/tapoueh/status/607983204683915264
lisp,38ya7j,xach,1 point,Mon Jun 8 20:38:16 2015 UTC,"@tapoueh   2015-06-08 18:51 UTC  @planet_lisp For another approach (make check), see https://github.com/dimitri/pgloader/blob/master/.travis.yml and https://travis-ci.org/dimitri/pgloader/builds     This message was created by a bot  [Contact creator][Source code]"
lisp,38ya7j,TweetsInCommentsBot,1 point,Mon Jun 8 20:38:22 2015 UTC,"pp-toml uses Travis. A little groady in getting all the Lisp setup to go, but has worked reliably."
lisp,38ya7j,p_nathan,1 point,Sat Jun 13 19:23:27 2015 UTC,"Hey, cool! It's always nice when I find a library with good SW engineering practices demonstrated. This makes that lots easier.  I should hook my QL systems up to this."
lisp,38wwfi,agumonkey,1 point,Sun Jun 7 15:06:16 2015 UTC,"Well, it’s a bit late. Too bad :{"
lisp,38wwfi,Asgeir,1 point,Tue Jun 9 21:35:28 2015 UTC,Someone tweeted this: https://twitter.com/didierverna/status/607889552540364800
lisp,38wwfi,TweetsInCommentsBot,1 point,Tue Jun 9 21:39:32 2015 UTC,@didierverna   2015-06-08 12:38 UTC  Celebrating Christian Queinnec's work at UPMC. #lisp [Attached pic] [Imgur rehost]     This message was created by a bot  [Contact creator][Source code]
lisp,38vie2,malisper,2,Sun Jun 7 04:34:07 2015 UTC,Very nice! Thank you for sharing it.
lisp,38vie2,z27,1 point,Tue Jun 9 07:22:04 2015 UTC,"Clean site, great explanations, very nice"
lisp,38vie2,Baggers_,1 point,Mon Jun 8 05:47:34 2015 UTC,You must be aware of http://letoverlambda.com  . How is your take on macros different? Do you think it is the sine qua non of good lisp style? Or are you more moderate in your affection?
lisp,38vie2,thebhgg,2,Mon Jun 8 07:22:54 2015 UTC,"I would say I have a similar focus as Let Over Lambda. The stuff I write will just be a step or two down from the kind of things in Let Over Lambda.  As for macros, I believe they are one of the most important features of Lisp. They separate Lisp from pretty much every other language by making it easy to add near arbitrary extensions to the core language. The other features I find important are the debugging capabilities (restarts + inspection + redefining functions at runtime), and the ability to use s-expressions for symbolic manipulation (recently I wrote a program which solved constraint satisfaction problems. I found it extremely helpful to represent the constraints as arbitrary Lisp expressions)."
lisp,38xwx6,agumonkey,1 point,Sun Jun 7 19:58:54 2015 UTC,"Erf, sorry, nested links are dead, you may use this archive instead."
lisp,38wedz,random-rob,2,Sun Jun 7 11:50:40 2015 UTC,"I do my OpenGL Lisp experiments on OSX using the CCL native IDE. It seems that the Obj-C bridge can handle the OpenGL and UI calls really effectively, but I've only made toy examples. Has anyone else tried this? I was thinking that if there was interest, maybe it'd be worth the effort to try and make a CCL Cocoa backed for CEPL...  Speaking of, every once in awhile someone will propose trying to port CCL's Obj-C bridge to other CL implementations (or at least SBCL), but it never seems to happen. Is there some sort of fundamental technical obstacle standing in the way?"
lisp,38wedz,lisp4humanists,2,Sun Jun 7 21:56:56 2015 UTC,"Great stuff, I havent played with ccl yet so this will give me a huge head-start when I do. I am using cl-sdl2 rather than lispbuildersdl these days and the excellent rpav helped me get set up on osx. So for those interested I have put up a follow up video showing how to get cepl on osx.  My current technique occasionally doesn't feel as good as the experience on other platforms so am going to trawl this for ideas. Thanks for writing all this up!"
lisp,38wedz,Baggers_,1 point,Mon Jun 8 05:56:51 2015 UTC,"I had a look at cl-sdl2 a while ago, and the fact they were loading glut to get SDL working made me very sad. Have a look at the init function found in cl-sdl2/src/sdl2.lisp.   cl-sdl2 also uses the 'in-main-thread' hack, which stomps all over ccl's housekeeping loop. The housekeeping loop does some gc and signal handling things - not stuff I want to lose. (Strangely, it doesn't do anything on ms-windows).  I'd argue that  cl-sdl2 should look to integrate the code found in the last function of ccl/examples/opengl-ffi.lisp, but I've only just thought of that. Maybe you could give rpav a nudge?"
lisp,38wedz,Baggers_,1 point,Mon Jun 8 07:14:40 2015 UTC,"hmm does sound like it will be possible to minimize the magic on ccl. That sounds nice, I want to get ccl support for cepl so I guess I will need to do that at some point. Thanks again for all the info!"
lisp,38wedz,DalekBaldwin,1 point,Mon Jun 8 11:14:07 2015 UTC,"I recently had to do some hacking on cocoahelper just to get it up and running, but I don't think I modified anything regarding threads. I really wish I kept better notes of how I get finicky things to build.  OSX has always had a quirk where OpenGL stuff will break if OpenGL API calls are made outside the main thread of an application (this happened with an older version of CEPL too -- I haven't tried any of the recent updates in the past year). As a result I've always had to switch between a single-threaded Lisp for REPL-driven OpenGL stuff (using a trick with swank::handle-requests, which is documented somewhere on the web... again, I wish I kept better notes) and a multi-threaded one for things like Hunchentoot (and tweak ASDF to store separate FASLs for single- and multi-threaded builds of the same SBCL release).  I remember some of this stuff being miraculously fixed the last time I tried to do multi-threaded OpenGL stuff, but the one thing I could never get to work was to allow UI events to be triggered from an OpenGL window; I'd always get a spinning pinwheel whenever I hovered over one. Does your hack fix that?"
lisp,38v3qy,Impacatus,5,Sun Jun 7 02:12:58 2015 UTC,You probably didn't learn about CGI earlier because it went out of vogue 15 years ago.
lisp,38v3qy,sgtfoleyistheman,1 point,Sun Jun 7 12:49:14 2015 UTC,"Is there another way to achieve what I want?  IE, to code primarily in one language but have the option to use other languages as needed?  I guess maybe I can call PHP or NodeJS programs with system calls as needed..."
lisp,38v3qy,sgtfoleyistheman,1 point,Sun Jun 7 20:05:23 2015 UTC,"That's exactly what cgi is, starting a new process on every request. You can do something like run two processes and use local sockets or something to communicate between them. Then you're basically running two Web servers. Why do you need both of these environments?"
lisp,38v3qy,xXAggron69Xx,1 point,Mon Jun 8 01:17:59 2015 UTC,"One of my biggest and most recurring frustrations with a major long term personal project I've been working on a LONG time is having to choose between a language that I prefer (Lisp) and one that has good, well-maintained, and well-documented libraries for what I need to do.   I like lisp, but sometimes I can't find a library that does what I need, or I can't get the libraries I find to work.  Anyways, I think I've found a solution in SCGI.  Any thoughts on that?"
lisp,38v3qy,rcoacci,1 point,Mon Jun 8 01:26:18 2015 UTC,"Have a look at FastCGI.  The primary difference between CGI and FastCGI is that the web app process becomes persistent.  Rather than servicing a request and then terminating, the web app keeps running and waits for another request to come in.  I found sb-fastcgi worked quite well for me."
lisp,38v3qy,AsymptoteToHappiness,1 point,Mon Jun 8 01:53:09 2015 UTC,"Yeah, I was looking at SCGI, which is similar from what I understand."
lisp,38v3qy,rcoacci,1 point,Mon Jun 8 01:57:35 2015 UTC,Try Racket. They have a webserver in their library and probably some json lib too. And it's mostly scheme.
lisp,38v3qy,Asgeir,1 point,Sun Jun 7 02:26:59 2015 UTC,Thanks.  Do I need a webserver to use CGI?  I assumed I just put the compiled program in Apache or something.  Maybe I still don't understand how it works.
lisp,38v3qy,Asgeir,2,Sun Jun 7 02:34:04 2015 UTC,"With CGI, you don't need a web server, only an executable, which web server will execute, passing all the request related information via CGI variables, and content body via stdin.  HTH"
lisp,38v3qy,Asgeir,1 point,Sun Jun 7 03:20:49 2015 UTC,"That's what I thought, thanks."
lisp,38v3qy,Asgeir,1 point,Sun Jun 7 03:22:02 2015 UTC,"My point is that with Racket you don't need CGI, as your webserver will be pure lisp. Unless you have some other requirement for Apache, you can go all lisp all the way."
lisp,38v3qy,Asgeir,1 point,Sun Jun 7 10:35:52 2015 UTC,"As I said in my OP, the reason I don't want to go pure lisp is because I sometimes have trouble finding and using the libraries I need.  CGI would give me the option of using other languages as needed."
lisp,38ofr3,BMarkmann,13,Fri Jun 5 15:17:31 2015 UTC,"I HIGHLY recommend caveman2 by Eitaro Fukamachi https://github.com/fukamachi/caveman  It's a full web stack built out of various Common Lisp components for the web stack (most written by Eitaro himself - pretty much everything but the templating system).  Very easy to use, and he is extremely fast to fix any issues I report when I do find an odd edge case/issue.  Currently powering my site http://ahungry.com (in particular, the page http://ahungry.com/eqauctions), which gets a few hundred requests per minute (and 1k to 2k unique visitors a day).  Regarding individual components - I enjoyed using hunchentoot (and still do for small web based things, or a web based interface to a larger system).  Check out my github for a lot of Common Lisp web based things (https://github.com/ahungry).  You can find samples of Hunchentoot, CL-who, a couple different JSON libraries and my site based on caveman2 (I'll have it up tonight under the com.ahungry repository)."
lisp,38ofr3,xenow,3,Fri Jun 5 17:54:15 2015 UTC,"I absolutely second this. I've successfully used the Clack stack for libraries, personal apps and an internal web app at work.  For templates though, I recommend djula."
lisp,38ofr3,eudoxeea,2,Sat Jun 6 00:25:48 2015 UTC,In the latest caveman they use djula by default as well (used to be cl-emb)
lisp,38ofr3,xenow,3,Sat Jun 6 01:33:21 2015 UTC,"Wow, really? I tried caveman a few months ago and thought cl-emb is rather clunky. djula certainly looks much better (but now I need to port my app to it...). I also thought the handling of forms is lacking in caveman as compared to e.g. Django, so I made my own forms library which is quite unfinished at the moment. It's very extensible though..."
lisp,38ofr3,Grue,2,Sat Jun 6 10:06:14 2015 UTC,"One thing I found troublesome with djula, is that render takes a template name and not a path."
lisp,38ofr3,PuercoPop,3,Sat Jun 6 06:39:26 2015 UTC,"You can be specific about the path though:  ;; something like this (defparameter +my-template+ (djula:compile-template* #p""...""))  (djula:render* +my-template+ ...)   Even if the path is not inside Djula's known directories. Still, I see how it might cause problems when you're using libraries that define their own templates and there might be a collision."
lisp,38ofr3,eudoxeea,3,Sat Jun 6 13:24:05 2015 UTC,Thanks!  I hadn't even looked at caveman.   Is there anything different in your fork (https://github.com/ahungry/caveman)?
lisp,38ofr3,xenow,2,Fri Jun 5 20:15:22 2015 UTC,"I just use it to submit pull requests for the few times I contributed back to the original (use the original, not mine, as I sometimes delete and refork it)."
lisp,38ofr3,Grue,4,Fri Jun 5 20:41:29 2015 UTC,"For ichi.moe I'm using bare Hunchentoot for server (behind nginx in production, of course), cl-closure-template for templating, jsown for JSON, Postmodern for database."
lisp,38ofr3,zodmaner,1 point,Sat Jun 6 10:18:46 2015 UTC,"Interesting site you got there!  I'm currently learning Japanese, and your site looks like a nice resource."
lisp,38ofr3,lokedhs,3,Sat Jun 6 16:46:39 2015 UTC,"I'd be careful about using any JSON library that uses keywords for hash keys (like CL-JSON). The reason is that if you are using it to parse unchecked input, it can be used to cause a denial of service attack by sending maps that contain random keys. Every key will be interned into the keyword package, which are never garbage collected, causing an out of memory condition after a while.  I personally use ST-JSON which doesn't suffer from this problem since it uses strings instead of keywords as keys."
lisp,38ofr3,bemrys,1 point,Sat Jun 6 18:42:21 2015 UTC,I thought that was why cl-json had safe-json-intern as a separate function?
lisp,38ofr3,maufdez,3,Sat Jun 6 19:43:28 2015 UTC,"Nobody has mention it, and I think you did not ask about it, but you could add ParenScript,  to use instead of javascript. You can write anything you would write in javascript using ParenScript and it integrates better with the LISP stack."
lisp,38ofr3,drewc,5,Sun Jun 7 03:40:34 2015 UTC,"Hunchentoot / Weblocks for the server / framework / routing / etc., CL-WHO for HTML generation, CL-JSON for handling JSON where necessary, Postmodern for database interaction. Thoughts?   Go for it?  I have used all of those save for weblocks and they all worked great. I have been developing web apps professionally in CL for over 11 years now.   Why are you overwhelmed by choices? Do you know what you want and are not afraid to try things out?"
lisp,38ofr3,xach,8,Fri Jun 5 15:38:31 2015 UTC,"You don't have to be afraid to not want to personally evaluate e.g. seven different json libraries. Fortunately, for json libraries, there's https://sites.google.com/site/sabraonthehill/home/json-libraries. It would be nice if other areas of functionality had similar surveys."
lisp,38ofr3,xenow,5,Fri Jun 5 17:33:25 2015 UTC,"I was thinking the other day it would be nice if quicklisp had vote/comment/tag support (similar to the Arch Linux AUR) so we could rate the sytems we install from there.  It would be cool to search via a ""json"" tag type and see a list of the 15 or so different JSON libraries ordered in descending vote order (so if one had 100 votes and the rest had 2 or 3, people would know which was the dominant/maintained version)."
lisp,38ofr3,xach,10,Fri Jun 5 18:00:09 2015 UTC,I talked about that at ELS - I'd very much like to do it.
lisp,38ofr3,sabrac,5,Fri Jun 5 18:40:57 2015 UTC,Do you have a specific request? I could try to find some time to do another one.
lisp,38ofr3,drewc,1 point,Sat Jun 6 04:17:03 2015 UTC,"See initial request? ;)  Seriously though, that is an amazing bit of legwork you did; kudos for sharing your experience and wisdom."
lisp,38ofr3,Taikal,2,Mon Jun 8 03:08:16 2015 UTC,"Fair enough, and true."
lisp,38pq63,jmprobert,2,Fri Jun 5 20:11:47 2015 UTC,Drop any questions or comments here and I'll respond quickly. Any feedback is greatly appreciated.
lisp,38mwa9,larsbrinkhoff,4,Fri Jun 5 06:26:20 2015 UTC,here's the newest edition   http://users.rcn.com/david-moon/PLOT3/
lisp,38mwa9,g000001,1 point,Fri Jun 5 06:35:12 2015 UTC,"It reminds me more than a bit of Ruby, but many people have made the argument that Ruby is at its core a functional language despite presenting itself as an object-oriented one."
lisp,38mwa9,jhbadger,1 point,Fri Jun 5 13:27:23 2015 UTC,Ruby is at its core a functional language despite presenting itself as an object-oriented one.   I wonder what Common Lisp is?
lisp,38mwa9,drewc,1 point,Fri Jun 5 16:14:09 2015 UTC,Previously
lisp,38mwa9,spacebat,0,Mon Jun 8 13:54:27 2015 UTC,"David Moon is one of my heroes, it's sort of sad watching him waste his valuable time with something like this.  The absence of s-expressions makes PLOT infinitely worse than Lisp, no matter what else it claims to improve on."
lisp,38mwa9,EdwardCoffin,5,Fri Jun 5 19:32:58 2015 UTC,"The conclusion he came to after much of his s-expressions work was that they are a bad idea, so for him to make a language that doesn't have them makes perfect sense.  He wrote up his reasoning in some comments on Arc, from which this is the relevant excerpt: Dave Moon: S-expressions are a bad idea.  Here are all of the comments on Arc, both from him and from others: Arc suggestions.  I believe these were submitted to Paul Graham after his Arc at 3 weeks talk."
lisp,38mwa9,cparen,3,Sat Jun 6 13:44:04 2015 UTC,What's wrong with having a hobby?
lisp,38mwa9,nikki93,1 point,Fri Jun 5 21:48:41 2015 UTC,http://users.rcn.com/david-moon/PLOT3/page-58.html
lisp,38m6ct,butlerccreltub,6,Fri Jun 5 02:57:21 2015 UTC,"The readable library, which works on Common Lisp and Scheme"
lisp,38m6ct,Denommus,3,Fri Jun 5 05:32:47 2015 UTC,Try this if you're not afraid of malvertising: http://readable.sourceforge.net/
lisp,38m6ct,larsbrinkhoff,4,Fri Jun 5 06:20:43 2015 UTC,http://srfi.schemers.org/srfi-49/srfi-49.html
lisp,38m6ct,Baggers_,3,Fri Jun 5 06:50:04 2015 UTC,"To add some context for those not inclined to blindly clicking links, SRFI-49 introduces an alternative, indentation-sensitive syntax for Scheme (called ""I-expressions""). The neat thing about this solution, is that it can be implemented in vanilla Scheme, no alterations to the compiler needed. Yet another great example of the power in the simplicity of Scheme."
lisp,38m6ct,jballanc,3,Fri Jun 5 09:44:52 2015 UTC,"Dylan is the first that comes to mind, and then of course the M-expressions: http://en.wikipedia.org/wiki/M-expression  [edit] And I forgot about Logo"
lisp,38m6ct,Aidenn0,2,Fri Jun 5 04:34:09 2015 UTC,"David Moon claims that his PLOT language is a Lisp, but without s-expressions.  http://users.rcn.com/david-moon/PLOT/"
lisp,38m6ct,larsbrinkhoff,2,Fri Jun 5 06:21:50 2015 UTC,Julia may have some Lisp flavour:  http://p-cos.blogspot.se/2014/07/a-lispers-first-impression-of-julia.html
lisp,38m6ct,larsbrinkhoff,1 point,Fri Jun 5 06:24:11 2015 UTC,You may write a filter or preprocessor to translate from the indented version to parenthesis version.
lisp,38m6ct,hzhou321,1 point,Fri Jun 5 04:47:20 2015 UTC,My toy lisp is quite easy to hack on: http://akkartik.name/post/wart
lisp,38m6ct,akkartik,1 point,Fri Jun 5 05:30:37 2015 UTC,Not sure if it counts but there is Common Lisp reader macro CL-2DSYNTAX which can be used to do something similar to what you are suggesting.  !defun sum-of-all-numbers (n)   * (/ n 2) (+ n 1)   if I am not mistaken.
lisp,38m6ct,maufdez,1 point,Mon Jun 8 00:52:33 2015 UTC,If you want a lisp that looks like python you may want to look into Hy.
lisp,38m6ct,airencracken,0,Fri Jun 5 06:07:55 2015 UTC,C doesn't depend on indentation.
lisp,38m6ct,JASSM-ER,2,Fri Jun 5 03:37:42 2015 UTC,"I know, but I also wonder if there's a lisp with a c like syntax, like:  define (sum-of-all-numbers n) {   * (/ n 2) (+ n 1) }"
lisp,38f902,xach,6,Wed Jun 3 20:43:15 2015 UTC,You might want to look at SICL whose goal is a modular common lisp implementation.  The CLOS module is under active development.
lisp,38f902,arvid,3,Thu Jun 4 03:17:07 2015 UTC,This is an excellent idea and would be a great addition to JSCL.
lisp,38f902,eudoxeea,3,Wed Jun 3 22:24:44 2015 UTC,"Can someone point to the Gerd's optimizations which are missing from SBCL? I don't remember the details all that sharply anymore, but I thought we had ported all of them over -- and added a few of our own on top. :)  (A slot access benchmark that shows the difference would do as well.)"
lisp,38f902,nsiivola,1 point,Thu Jun 4 09:49:06 2015 UTC,20 years overdue!
lisp,38bur8,paullik,9,Wed Jun 3 05:21:47 2015 UTC,Tackle some Project Euler problems.
lisp,38bur8,reply,2,Wed Jun 3 13:25:28 2015 UTC,"First hundred problems or so are fun, but don't blame yourself for not solving most of them, after all: (eql 'math 'programming)  NIL  I solved 166, then gave up)"
lisp,38bur8,vi111,6,Wed Jun 3 16:33:44 2015 UTC,"I'm currently attempting to implement a telnet based pen and paper RPG server.  When finished, it will allow for console chat, dice rolling, personal messaging and a GM console.  I just wish I had the time to take a real good swing at it."
lisp,38bur8,Gravybadger,5,Wed Jun 3 06:16:48 2015 UTC,Protip: it's going to suck ass. Telnet protocol is a steaming heap of ineptitude and hacks.
lisp,38bur8,MikeSeth,5,Wed Jun 3 13:13:28 2015 UTC,Sounds like it'll fit right in with the rest of my shit code then
lisp,38bur8,Gravybadger,2,Wed Jun 3 20:15:49 2015 UTC,"It'd be cool if something like Paramiko (a python SSH client and server implementation) but written in CL. I've done a quick search, but can't find anything comparable."
lisp,38bur8,shassard,7,Wed Jun 3 15:15:08 2015 UTC,"Off the top of my head: a web crawler, load testing framework, a bitcoin price alert system (with moving average tracking), a static site generator (there are millions already, what's one more?!), a game of life implementation (either text based or OpenGL), a database driver...  Hard to suggest things without knowing some of your overall interests."
lisp,38bur8,orthecreedence,3,Wed Jun 3 06:23:11 2015 UTC,"Hmm, a game of life implementation with OpenGL doesn't sound so bad or the bitcoin idea since I know nothing about bitcoin and maybe this way I'll learn something about it."
lisp,38bur8,Baggers_,7,Wed Jun 3 06:25:58 2015 UTC,"the only downside with the opengl idea is that it can feel like you are writing c in lisp. Some of us <cough shameless plug> are working on the issue of making it more lispy but it is wip. Do check out cl-opengl and cl-sdl2 though. One thing that gl coding in lisp can benefit from is macros as you can automate the writing of the ugly stuff (VAOs for example)  If you go for the bitcoin option (or even if you dont) you may be interested in the optima pattern matching library. [EDIT] my bad, I thought it was bittorrent not bitcoin and thought the optima library would be useful for the bencode parser."
lisp,38bur8,orthecreedence,2,Wed Jun 3 08:36:47 2015 UTC,"True wrt ""writing C in lisp"" when doing OpenGL. I built a simple engine a while back and remember trying to abstract (and get out of) the VAO stuff as quickly as possible.  Apparently I starred CEPL a while ago but forgot about it, going to check it out again. That video is really cool."
lisp,38bur8,maufdez,3,Wed Jun 3 18:37:49 2015 UTC,"Maybe some of the projects in the CLIKI, ""Suggested Programming Projects"" will be suitable."
lisp,38bur8,devDorito,3,Wed Jun 3 14:54:28 2015 UTC,"Try to take a simple app you've made and implement its features in LISP. Solving a sudoku puzzle in LISP would be interesting, as there are many ways of approaching the problem."
lisp,38bur8,gensyms,2,Wed Jun 3 05:29:44 2015 UTC,Implement one of the python standard libraries in Lisp.
lisp,38bur8,cym13,1 point,Wed Jun 3 12:48:08 2015 UTC,"SICP is available as a free online book and contains many interesting exercises from basic arithmetic to building whole new languages and even a virtual machine. If you're using Common Lisp, know that it uses scheme so some translation may be necessary. (Also the book in itself is damn good)"
lisp,38bur8,chuchana,1 point,Wed Jun 3 18:37:15 2015 UTC,It is available here as an eBook or PDF with re-rendered formulae and figures: https://sicpebook.wordpress.com
lisp,38bur8,ruggednraw,1 point,Wed Jun 3 20:06:35 2015 UTC,"Thank you everybody for your replies.  I think I'm going to start with the brainfuck interpreter, then move to either an OpenGL project based on CEPL or SICP."
lisp,38bur8,cym13,1 point,Thu Jun 4 09:41:49 2015 UTC,Brainfuck interpreter
lisp,38bur8,nabax,3,Wed Jun 3 16:00:54 2015 UTC,Lisp really is made to build new languages. A brainfuck interpreter can be done in about 40L (no pressure) and is an interesting way to learn. I support this idea.
lisp,38bur8,codercoder,1 point,Wed Jun 3 18:35:16 2015 UTC,"+1! I've written brainfuck interpreters in many langs and it's always a nice way to learn!  The ""downside"" is that bf is so simple you'll get it done in a day or two, so I don't think it fits into the middle-sized project requirement..."
lisp,38g37k,bitmadness,9,Wed Jun 3 23:56:35 2015 UTC,"You know, half the Lisp community's reputation for crotchetyness to newcomers probably stems from the need to fend off newcomers regurgitating the same thoughts bemoaning the state of Common Lisp every few weeks, like clockwork. It wears you down."
lisp,38g37k,iouwt,-1,Thu Jun 4 18:42:02 2015 UTC,"Who you calling a newcomer, newb? :P"
lisp,38g37k,iouwt,3,Thu Jun 4 20:31:11 2015 UTC,"You would have to be to not recognize this as a retread of a conversation that's been had many, many times, here and elsewhere."
lisp,38g37k,defun_,7,Thu Jun 4 20:39:40 2015 UTC,This theme goes back to before the standard even. It's very old.
lisp,38g37k,tuhdo,7,Fri Jun 5 00:20:59 2015 UTC,"Ruby has multiple implementations, and it's doing well. I don't see we have abnormal numbers of CL implementations. Some are unmaintained (CLISP, GCJ). Somet CL implementations serve different purposes i.e. ECL is for embedding to your C/C++ code or compile to executable, ABCL is a CL on JVM."
lisp,38g37k,timdaly,17,Thu Jun 4 03:01:00 2015 UTC,"I have common lisp code from 30 years ago that still runs without change. The fact that common lisp has a standard is vital. I've written python (2.7) that no longer runs. I've written Java that no longer runs. I strongly oppose ""breaking changes"".  It would be useful to have a library of code (quicklisp is the right idea although I really wish it was git-based). For instance, I'd like to use a trie and I can find such code online but it would be nice to be able to search/fetch it. I'd also like to see immutable versions of data structures that can be searched/fetched.   Zach has the right idea. Perhaps Edi Weitz's book could coordinate with Zach to provide a nice (literate?) documentation of a Zach quicklisp ""standard library"".  As for multiple versions of lisp... The beauty of common lisp is that everything I write runs everywhere (modulo extensions, which I try hard to avoid). The various versions have different features that are important for different reasons. CLISP interprets, SBCL always compiles, GCL generates C code, etc. I use them all for different projects and different reasons.  As to the question of ""stays relevant in the 21st century"", a LOT of the current crop of wonderful new languages will die. Scala/Rust/Python/Ruby/etc are all going to be legacy code at some point. I know you don't believe me but I've been around long enough to remember other ""wonderful new languages"". Remember PASCAL? It was hot. You HAD to know it. It was going to take over the world. It was strongly typed. Of course, there was a debate about the non-string (academic) vs the string (industrial) version but everybody knew that PASCAL was the language that was clean, elegant, fast, and nearly error-free to write. Sound familiar? When was the last time you wrote a PASCAL program?  Lisp endures because it lets you think. Every programming language constrains the way you think (try writing functiional code in Java). Lisp is unique in language land. Do you want object-oriented? Use CLOS. Functional? Qi? Don't like the syntax? Reader macros. Don't like the set of special forms? Macros. Want really low-level code banging? Rplaca. Want to try something REALLY new? MOP.   As for becoming ""the next C++""... you'll notice that it is converging on lisp ideas. They recently introduced anonymous lambda expressions. How novel.   I would love to see some ideas standardized, such as the foreign function interface, but I think it should only become standard after it works everywhere and has been ""time tested"". I would love to see common lisp replace javascript in the browser, making the browser into a REPL-based program. There are a lot of ideas that could be suggested but programming will be with us for a long time so there is no hurry to force a new standard."
lisp,38g37k,vityok,2,Thu Jun 4 03:27:21 2015 UTC,"Indeed, Pascal is a beautiful language with an instant compilation times. Now I've got a desktop computer that outperforms any supercomputer of that time, but it takes ages to compile modest C/C++ applications compared to virtually speed-of-light performance of Turbo Pascal on a 20MHz CPU with 4MB RAM...  Life is cruel."
lisp,38g37k,tealeg,4,Thu Jun 4 09:46:32 2015 UTC,Sounds like you need Go in your life!
lisp,38g37k,vityok,4,Thu Jun 4 12:09:46 2015 UTC,"The problem is that the Software Industry somehow manages to adopt tools that make new applications appear sluggish on a much more powerful computers than before.  Web, smartphones, business applications, etc. are somehow circling around, reinventing things that were working and known before but with more computational power consumption.  Wicked cycle."
lisp,38g37k,tealeg,3,Thu Jun 4 13:55:07 2015 UTC,"More layers, more abstraction, more programmers with an ever decreasing understanding of what is happening within those layers and abstractions."
lisp,38g37k,mukt,3,Thu Jun 4 14:37:38 2015 UTC,Almost intentionally. It appears.
lisp,38g37k,ruricolist,2,Thu Jun 4 15:32:41 2015 UTC,"The first time I saw Pascal (after learning CL) I was startled by how familiar parts of it were, from the loop macro -- which is like a bit of Pascal preserved, as it were, in the amber of Lisp."
lisp,38g37k,duncanbayne,4,Thu Jun 4 15:39:51 2015 UTC,"Speaking as a Common Lisp newcomer here (well, I've been hacking a bit on it over several years, but overall it's a small amount of time and I'm still definitely a beginner) ...  1) Competing implementations are good, and a sign of a useful specification.  I've worked as a programmer for over a decade, and I've seen what happens when you don't have competing implementations.  I'd be more worried by a language with a spec that only had one useful implementation.  That would imply one or more of: a) the spec is a sham (think Microsoft's 'open' document formats), b) the spec is incomplete or unhelpful, c) no-one cares.  2) Definitely some cleanup would help, and modernisation of certain conventions too (-p vs ?).  3) Don't focus on making the language easy to learn at the expense of power, succinctness, correctness or flexibility.  There exist many other languages that are easy to learn; Common Lisp isn't one of them, it's for professional programmers.  By analogy: you wouldn't ruin the sound of a Stradivarius in order to make it easier for people who'd never played a violin."
lisp,38g37k,duncanbayne,2,Thu Jun 4 20:30:48 2015 UTC,"I can certainly agree with 2 and 3. Regarding 1, I politely disagree: OCaml does just fine with only one implementation. Other languages usually have only one or two main implementations Haskell (GHC), C/C++ (GCC and Clang), Go (GC and GCCGO), Lua (Lua and LuaJIT). I'm not against multiple implementations - I agree they are a good thing. But I worry that we have too many (see http://en.wikipedia.org/wiki/Common_Lisp#List_of_implementations for a list)"
lisp,38g37k,xieyuheng,3,Thu Jun 4 00:24:24 2015 UTC,"""I politely disagree"" ... have I mentioned that one thing I really appreciate is the quality of discourse surrounding Common Lisp? :)  W.r.t. OCaml, though, it's not a specification-driven language.  Unless I'm mistaken, there is no ""OCaml spec""; the language is essentially defined by the reference implementation in the same way that Ruby is defined as ""what MRI does"".  I'd be very surprised to find more than one or two non-toy implementations of such a language.  C is spec-driven (to an extent) and there are many C implementations - I've used several of varying power, quality and usefulness (PCC, SDCC, GCC, Clang, Microsoft) over the years.  See http://en.wikipedia.org/wiki/List_of_compilers#C_compilers for many (many! I had no idea) more.  Possibly we do have too many CL implementations.  But I still maintain that's less of a worrying sign for the long-term success of CL than if there were only one or two implementations of the specification."
lisp,38g37k,defun_,2,Thu Jun 4 01:00:53 2015 UTC,"a language easy to learn at the expense of power, succinctness, correctness or flexibility.   a language is powerful, succinct and flexible, only when people who understand it well use it in a powerful, succinct and flexible way.  common lisp could be redesigned more easier to learn.  and when common lisp is more easier to learn, common lisp is a better language."
lisp,38g37k,Baggers_,5,Thu Jun 4 01:10:34 2015 UTC,"You say ""competing implementations"" like that's a bad thing. That's exactly what forces people to write standard code and also prevents a monoculture with the attendant problems. Look at all the different C compilers--nobody thinks that's a ""fragmentation"" problem."
lisp,38g37k,spacebat,4,Thu Jun 4 03:03:42 2015 UTC,Low hanging fruit first. The standard can be updated after libraries people want are written.  And I think you're laying it on a little thick. Common Lisp standardized a metaprogramming environment. It's ability to adapt is baked in.  I'd even be fine with just extensive documentation for popular libraries.
lisp,38g37k,eduolmd,10,Thu Jun 4 10:56:09 2015 UTC,"I've only been here a few years but frankly I am amazed at how often this comes up. Especially now that lisps in general are having somewhat of a mini resurgence.  tldr: We don't need to update the standard, things outside the standard can be standardized. Go look at the other times this conversation has come up in the last 40 years, see why they failed. Look at the MOP, extensible sequences & Gray streams, see why they succeeded. The only thing we should ever add to the standard is a new way to extend the language.  Long version: Fragmentation is the price of exploration:  Why do we allow macros when macros can create such incompatible syntax, evaluation model, etc? Because the gains outweigh the cost many times over.  In most languages you are able to package up functionality and ship it to people. They can then evaluate it in their own environment and see if it fits their needs and programming model. No need for governance here.  What lisp can do is allow you to package up syntax (and patterns) in the same way you can package up functionality. This is immensely powerful and means we can, as a group, explore ideas that cant in other places without inventing a new language/preprocessor. We don't need governence and standard to make this happen.  This means if you can 'fix' lisp, do it and ship it. If it doesn't gain popularity then maybe it wasn't what people wanted.  The spec was agonized over for 10 years. It contains a lot of small details that would be too easy to mistake for unneeded complexity and throw out (see the file-path stuff as an example). Many well meaning endeavors (like cl21) make sweeping statements (like lisp should be more object orientated) and think that is a no-brainer. To counter this I suggest reading Kent Pitman's History of common lisp especially section 4.4 Nothing is ever obvious Here is a choice quote.  ""Steele arrived at the Monterey meeting carrying a short list (a page or two) of “obvious” things that needed to be changed in CLTL. It was quickly obvious that these changes would not be made, in part because nothing that seemed obvious really was.""   The one area that I do have a little concern in is whether we could support a way to make type systems. This SHOULD NOT need a change to the standard. I want to see a framework that allows people to plug in their own theorem provers and have those be provided with declarations and optionally any data the compiler can provide, allowing them to check the code.  Again we should not be standardizing on a type system, we should be looking at the next macro stage i.e 'theorem-macro' (or hopefully a good name :D) that is extensible by the community.  If you run into something that is impossible in lisp, extend the compiler in a way that proves what could be gained by having the feature. Implementation are often happy to have not standard modules included in their distributions if they are good enough (See SBCL - (Beyond the ANSI Standard)[http://www.sbcl.org/manual/#Beyond-the-ANSI-Standard])  In all I just don't believe this community is resistant to change, it's just that there is nothing compelling to see  Random things to look at: - The people who thought lisp would be excellent without parens: http://srfi.schemers.org/srfi-119/srfi-119.html   It's easy to write them off but they were looking for radical change   too. So understanding their history is important if you want to succeed   McCarthy quote: The project of defining M-expressions precisely and compiling them or at least translating them into S-expressions was neither finalized nor explicitly abandoned. It just receded into the indefinite future, and a new generation of programmers appeared who preferred internal notation to any FORTRAN-like or ALGOL-like notation that could be devised.  It is important to know why we got here. Decisions that seem odd can be the result of actual testing From CLHS: Metaobject Protocol n. one of many possible descriptions of how a conforming implementation might implement various aspects of the object system. This description is beyond the scope of this document, and no conforming implementation is required to adhere to it except as noted explicitly in this specification. Nevertheless, its existence helps to establish normative practice, and implementors with no reason to diverge from it are encouraged to consider making their implementation adhere to it where possible. It is described in detail in The Art of the Metaobject Protocol.  Note how the MOP is woven into our lisp life but is not standardized!"
lisp,38g37k,pcostanza,3,Thu Jun 4 02:50:13 2015 UTC,"The standard was the result of a long and expensive process. Nobody would say its perfect but most agree it is pragmatic. The risk of going back to the standardisation process seems to be too great when the language is so easily extensible for most practical concerns. If we want sockets, threads, coroutines, contexts etc there are libraries for those.  I'd like to see a growing set of common language extensions added to each implementation. Our community is small and sharing these marginal features makes sense. It would be nice if the CDR was more alive, but its not dead either: https://common-lisp.net/project/cdr/"
lisp,38g37k,xieyuheng,3,Thu Jun 4 08:23:45 2015 UTC,"""I recommend that we make some breaking changes to eliminate cruft and make the language easier to learn.""  So you are, pretty much, recommending Scheme, don't you?"
lisp,38g37k,defun_,3,Thu Jun 4 09:12:24 2015 UTC,"What you are asking for already happened numerous times. How do you think languages like PicoLisp, Arc, or Clojure saw the light of day. They were essentially designed as responses to Common Lisp, because their designers were not happy with it and tried to improve on it. Even R2RS, the first ""real"" Scheme standard, so to speak, had a reference to this effect in its subtitle, calling it an ""Uncommon Lisp."" So it's actually not clear what you are really asking for. Do you have some concrete suggestions?"
lisp,387okx,ReneFroger,18,Tue Jun 2 13:09:31 2015 UTC,"Now make this thought experiment interesting: Imagine adding object orientation to the C and Scheme programming languages. Making Scheme object-oriented is a sophomore homework assignment. On the other hand, adding object orientation to C requires the programming chops of Bjarne Stroustrup.   No, it doesn't. Making C object oriented requires you knowing how to debug preprocessor macros and a little bit of patience.   Consider the case of Scheme, again. Since making Scheme object-oriented is so easy, many Scheme hackers have done so. More to the point, many individual Scheme hackers have done so. In the 1990s, this led to a veritable warehouse inventory list of object-oriented packages for the language. The Paradox of Choice, alone, guaranteed that none of them would become standard. Now that some Scheme implementations have their own object orientation facilities, it's not so bad. Nevertheless, the fact that many of these packages were the work of lone individuals led to problems which Olin Shivers wrote about in documenting the Scheme Shell, scsh.   This is what happens when you use a tiny language for big work. No scheme object system comes close to CLOS for power, except maybe GOOPS. But writing in Guile is like writing in a worse Common Lisp. And CLOS is a standard. So this holds for Scheme, not CL.   Programs written by individual hackers tend to follow the scratch-an-itch model. These programs will solve the problem that the hacker, himself, is having without necessarily handling related parts of the problem which would make the program more useful to others. Furthermore, the program is sure to work on that lone hacker's own setup, but may not be portable to other Scheme implementations or to the same Scheme implementation on other platforms. Documentation may be lacking. Being essentially a project done in the hacker's copious free time, the program is liable to suffer should real-life responsibilities intrude on the hacker. As Olin Shivers noted, this means that these one-man-band projects tend to solve eighty-percent of the problem.   This builds off the previous point, and having addressed that point, I don't feel the need to address this one.   Therefore, those who already know C don't ask ""What object system should I learn?"" Instead, they use C++ or Objective-C depending on what their colleagues are using, then move on to ""How do I use object-oriented feature X?"" Answer: ""Goog it and ye shall find.""   C hackers are incredibly opinonated. Most don't like C++, and they could opt for GObject, structs with function pointers, whatever, instead of C++ or Objective-C.   Real Hackers, of course, have long known that object-oriented programming is not the panacea that its partisans have claimed. Real Hackers have moved on to more advanced concepts such as immutable data structures, type inferencing, lazy evaluation, monads, arrows, pattern matching, constraint-based programming, and so forth. Real Hackers have also known, for a while, that C and C++ are not appropriate for most programs that don't need to do arbitrary bit-fiddling. Nevertheless, the Lisp Curse still holds.   Translation: Real Hackers are trendy automatas that base technical decisions based on what's on the HN front page.  I'm not analyzing any further. This is sloppy work of the sort people can't help themselves to write about Lisp. To any readers out there, waxing philosophically about Lisp doesn't make you cool, and it won't make Yahoo buy your startup. The next time you want to write a blog post lamenting Lisp, write a library instead."
lisp,387okx,defun_,2,Wed Jun 3 02:02:22 2015 UTC,"Translation: Real Hackers are trendy automatas that base technical decisions based on what's on the HN front page.   This is beautiful. There is something odd where people think that being a Real Hacker is somehow principally about an aesthetic approach, and that the way to fame is to be the next Paul Graham talking about how hackers are artists or vice versa.  As opposed to a Real Hacker being someone who, I dunno, developed something that worked and did something useful that you might not have thought possible.  Possessing a sort of crazy audacity in the face of a technical problem to just solve it, not to sit around like an opium-smoking mandarin talking about what a Real Hacker is."
lisp,387okx,sickofthisshit,-1,Wed Jun 3 19:57:15 2015 UTC,Sorr but you cannot have an object system without somehow emulating virtual methods. How do macros do that for in C? I mean can you get the animal to speak correctly without knowing if the animal is a cat or dog?
lisp,387okx,Pet_Ant,2,Wed Jun 3 13:22:01 2015 UTC,"Sorr but you cannot have an object system without somehow emulating virtual methods.    New to programming (and english language spelling) and do not know Common Lisp or CLOS?    How do macros do that for in C?   https://developer.gnome.org/gobject/stable/howto-gobject-methods.html  How does grammar work in English? :)   In all seriousness, you need to learn about other object systems. Not everything is C++ and there are those of us that consider it flawed and not proper OO.  EDIT: : The "":)"" was intended to make sure that it was not ""making fun of your lack of skill at the English Language"" but rather pointing out that not knowing a language, in this case Lisp, is what the comment was referring to.   I was not critiquing your grammar but rather your lack of knowledge about languages you do not know."
lisp,387okx,drewc,1 point,Wed Jun 3 17:53:01 2015 UTC,"I'm going to dissent here and although I agree the commenter you are responding to didn't take the time to research what I'd posted, I'd prefer it if we didn't make fun of someone trying to speak in a different language other than their own. I could understand them just fine, and critiquing grammar, especially of a non-native speaker, is a low blow and beneath the level of good discussion."
lisp,387okx,defun_,0,Fri Jun 5 00:35:54 2015 UTC,"J'étais parler Français-Canadien premièrement, mais j'habite avec les anglophone près ce que tout ma vie. Je ne pas la vocabulaire mais je peux utiliser un dictionnaire si tu préfère.  If you think that was a critique, and you refuse to recognize "":)"" as a smiley face intended to say ""This is not to make fun but to mention that not knowing a language is what we are referring to"", then I have nothing else to say to you beyond : Enjoy!  EDIT: I edited it my response to give folks a clue, and hint, and to stop you from thinking it is about persons and not programming languages."
lisp,387okx,drewc,2,Fri Jun 5 15:13:26 2015 UTC,I misunderstood. My bad.
lisp,387okx,defun_,7,Fri Jun 5 23:30:21 2015 UTC,"I disagree with a lot of these posts. LISP isn't cursed or disadvantaged by its power at all, the majority of programming languages have unique features or rules that can throw off beginners and, if we're being honest, most beginners are focusing on hello world and simple println() statements.  I'd argue that LISP's (or common LISP's) problem is in community and exposure. Essentially LISP has terrible exposure, a lack of tutorials and out of date resources for people wanting to learn the language, when the top hello world tutorial on google is from 1996 it'll put many people off, it doesn't help that much of the documentation and learning material looks like it belongs in 1996 as well.  I think LISP needs to modernise and get away from the image of a solo, super-knowledgeable hacker and move towards a more community driven method of expressing itself if it wants to grow, part of that would come from modernising, because when I compare LISP's methods of presenting itself to new users and Python's, I can see why people don't come to LISP."
lisp,387okx,EmpireOfDust,2,Wed Jun 3 01:24:35 2015 UTC,I've gotten serious about learning lisp lately and a lot of the resources I've checked out look like hammered horseshit.
lisp,387okx,Pharmakoza,4,Sat Jun 6 05:44:18 2015 UTC,This has been posted several times before.
lisp,387okx,iouwt,-13,Tue Jun 2 17:58:09 2015 UTC,Yet it is so valid 4ever. Macros should be controlled and accepted by stiff-jointed Nazi committee only. Unlike regular functions you cannot modify macros -- once it is written it is frozen forever. Sometimes it is just easier to replace macro instances with current macroexpansion and delete the bloody macro.
lisp,387okx,codercoder,9,Tue Jun 2 18:43:27 2015 UTC,Did the WJ bot learn to use Reddit? Should we be concerned?
lisp,387okx,iouwt,5,Tue Jun 2 22:04:07 2015 UTC,Are you speaking in sarcastic voice or do you actually mean it?
lisp,387okx,lolisakirisame,2,Tue Jun 2 19:12:54 2015 UTC,"Why this article keeps popping up every once and then?  Any possible power lisp has compared to other language is definitely not its curse. In the contrary, writing C program for 5 months instead of doing it in a weekend with lisp is ultimate form of waste of time. You should feel bad if you find yourself in this kind of situation because you were a fool.  Author claims that it results in 80% ready products. It's bullshit because the author expects he gets good stuff for not paying for anything and forgets he's paying for products he is comparing it against. Equally you can do good design with good tools. It's just usually paid work because you may expect payment for good work even if you liked to do it. If you can do the same work more efficiently, it means more potential cash for you.  Popularity is driven by prior popularity and marketing. Besides most people do not give a shit for whether a programming language is popular when they pick it up. They pick up the language by how it's marketed, what kind of libraries it has, its implementation availability and by how understandable learning material is. Businesses stick to what they're already using, unless they see a value in opportunity of doing otherwise.  For businesses very lot of things matter. For example, finding the workers in the first place! It's not simple question of employee fungible versus productive. In fact business owners probably prefer some good trade-off as otherwise they could as well hire fungus instead of real workers.  I don't care if there's 17 object implementations if one of them fills all the requirements I set to such thing. Similarly I don't care whether there's 5000 programming languages today as long as one of them at least somehow completes my needs."
lisp,387okx,htuhola,1 point,Fri Jun 12 21:53:40 2015 UTC,"This article makes a good point, there are too many choices for a lot of Lisp problems. Maybe having a community moderated of Standard List Of Lisp Solutions, where each item is ostensibly the Right Thing for it's job, would be able to mitigate that problem a little bit and make Lisp more accessible to newcomers."
lisp,387okx,therabidmachine,0,Tue Jun 2 19:28:55 2015 UTC,"Eh whatever, macroexpand it or read the docs. I think the real problem with lisp was that nobody documented their shit. They just wrote it for themselves and expected anyone else to ""figure it out."" This is changing a lot lately though, people are actually starting to take some pride in their work. I think github (and others like it) are helping by making it really easy to publish a lib and then be accountable for it via issues. And slamming out a README.md is stupid easy too."
lisp,387okx,orthecreedence,-3,Tue Jun 2 21:45:12 2015 UTC,It seems that this author has not/had not yet encountered the Clojure community when he wrote this. It seems to counter all of these points.
lisp,387okx,J_M_B,4,Tue Jun 2 18:20:48 2015 UTC,"Except for the development environment. Yes, I know there's options there, from Emacs, to Eclipse, to environments similar to IPython, but nothing on the level of something like the Lisp Machines, or even better Symbolics."
lisp,387okx,jhbadger,-11,Tue Jun 2 18:55:04 2015 UTC,"Even when user macroes are banned, some builtin macroes are horror. Common Lisp loop contains suddenly flat list of items which are not definitively Lisp (or any other language), just list of symbols which may or may not be valid, it is all in the macromaker's  whim.   This is totally valid loop. As it expresses exactly what I want to:  (loop for x in abba for y from 1 to   do dodo unless I do not if > y 1 do format   t "" ~A x"" else do do do do pili loop). If macro does not want it, they should fix the bloody macro. And of course it is totally my right and duty to fix this faulty product by myself."
lisp,387okx,codercoder,8,Tue Jun 2 15:12:48 2015 UTC,Has the above text been generated by a markov bot?
lisp,387okx,aerique,3,Tue Jun 2 17:53:58 2015 UTC,"https://common-lisp.net/project/iterate/  Or if you prefer functional idioms, mix  https://github.com/m2ym/optima with 'on lisp' style recursive defining macros."
lisp,389anv,chebertapps,3,Tue Jun 2 19:03:44 2015 UTC,Bind that function to a key?
lisp,389anv,AeroNotix,0,Tue Jun 2 20:14:36 2015 UTC,"I mean that slime-arglist makes you type in the function name, and doesn't complete the form. In this case it wouldn't work because it doesn't actually insert the text, it just echos it in the mini-buffer.  Otherwise, yeah I'd just bind and use it."
lisp,389anv,AeroNotix,2,Wed Jun 3 00:13:22 2015 UTC,Seems like you have all the pieces to make it into an Elisp function which does do what you need though?
lisp,384kjz,xach,1 point,Mon Jun 1 20:27:05 2015 UTC,<3
lisp,384kjz,pTymN,1 point,Tue Jun 2 10:05:52 2015 UTC,The console application works under wine too!
lisp,384kjz,sfandino,1 point,Tue Jun 2 10:26:55 2015 UTC,I'd like to try that. How do you run it?
lisp,384kjz,sfandino,1 point,Tue Jun 2 12:26:59 2015 UTC,"Once you have wine installed on your computer, from the directory where you have unpacked the Corman Lisp archive, just run:  wine clconsole   You can try to run any of the .exe files there in this way. For instance, CormanLisp.exe gets to show the UI but then hangs."
lisp,384kjz,dig1,1 point,Wed Jun 3 08:15:10 2015 UTC,Great work guys!
lisp,384kjz,ta56498191,1 point,Tue Jun 2 22:25:44 2015 UTC,"I've filed two bug reports on there, none of which I can see if I'm not logged in. There's an especially bad one involving defpackage, which is surprising considering this thing used to cost money. Are the project's owners able to see my (apparently spam-filtered) bug reports?"
lisp,384kjz,ta56498191,1 point,Sun Jun 7 00:52:47 2015 UTC,"If you don't see the issues on github, they didn't make it into the system. I didn't see them anywhere.  If you like, you can try again here: https://github.com/sharplispers/cormanlisp/issues"
lisp,384kjz,ta56498191,1 point,Tue Jun 9 00:37:40 2015 UTC,"But I do see them, as long as I'm logged in. When I log out, the issues become invisible (and direct links to them such as this become 404s). Perhaps I'm shadowbanned from there or something. That's too bad. I posted patches."
lisp,384kjz,ta56498191,1 point,Tue Jun 9 00:58:06 2015 UTC,Can you log in and give me the URL of one of the issues?
lisp,384kjz,ta56498191,1 point,Tue Jun 9 01:06:22 2015 UTC,https://github.com/sharplispers/cormanlisp/issues/10  https://github.com/sharplispers/cormanlisp/issues/11  https://github.com/sharplispers/cormanlisp/issues/12
lisp,384kjz,ta56498191,1 point,Tue Jun 9 01:18:08 2015 UTC,"I'm going to go ahead and post the bug reports here, since it's obvious that GitHub is blocking me, and Reddit supports markdown. This account is rate-limited, however, so the reports will come slowly.  Title: Output to *standard-output* doesn't work in console executables created with SAVE-APPLICATION  Try this at the REPL (either clconsole.exe or CormanLisp.exe, it doesn't seem to matter):   (defun hello ()      (format t ""Hello, world!~%"")      (lisp-shutdown """"))   (save-application ""hello.exe"" #'hello :console t)   The resulting hello.exe prints nothing when launched. However, the following program works fine (sometimes):  (defun hello ()     ;; Explicitly open the console.     (with-open-file (*standard-output* ""CON"" :direction :output :if-exists :append)         (format t ""Hello, world!~%""))     (lisp-shutdown """"))"
lisp,384kjz,redditsuxass,1 point,Tue Jun 9 01:14:44 2015 UTC,"Title: DEFPACKAGE chokes with obscure compile-time error if :use package doesn't exist.  Reproduction:  (macroexpand-1 '(defpackage #:foobar (:use #:does-not-exist)))   Error:  ;;; An error of type SIMPLE-ERROR was detected in function CHECK-TYPE-BODY: ;;; Error: The value of P, NIL, is not of type PACKAGE ;;; Entering Corman Lisp debug loop.  ;;; Use :C followed by an option to exit. Type :HELP for help. ;;; Restart options: ;;; 1   Abort to top level.   I traced the error to a mapcar call in the defpackage macro that attempts to change a list of packages into strings via package-name. That list is generated from the package-designators in the :use subform, and if an undefined package was in that list, then the corresponding element in the package list will be a string instead of a package.   Fixing that bug (see patch), a further bug exists: The macro does not show which package didn't exist. You end up getting this error:  ;;; An error of type SIMPLE-ERROR was detected in function ADD-USED-PACKAGE: ;;; Error: Not a package: NIL ;;; Entering Corman Lisp debug loop.  ;;; Use :C followed by an option to exit. Type :HELP for help. ;;; Restart options: ;;; 1   Abort to top level.   That happens because defpackage doesn't check if the package exists before or after using find-package. The result is that NIL gets passed to use-package and no further information is available.   This can be fixed by checking if find-package returns NIL before using it, and signalling an error while the name of the package is still known.  Here is a diff patch to fix both problems.   Unfortunately, GitHub doesn't allow patches to be attached, so I'll have to just paste it here:  --- defpackage.lisp     2015-01-06 01:08:14.000000000 -0500 +++ /tmp/defpackage.lisp        2015-06-06 13:16:18.000000000 -0400 @@ -140,7 +140,7 @@                          (remove-duplicates                              (append use                                  (mapcar #'(lambda (pkg) (canonicalize-package-designator pkg nil)) value))))) -                               (:import-from (push value import-from)) +                       (:import-from (push value import-from))                                 (:intern (setq intern (append intern (mapcar #'string value))))                                 (:export (setq export (append export (mapcar #'string value))))                                 (:documentation @@ -156,12 +156,20 @@                          :nicknames ',(remove-duplicates nicknames :test #'string-equal)                          :use nil                          ,@(when size `(:size ,size)))) forms)) -        (setq use (mapcar (lambda (package) (package-name package)) use))   ;; list package names, not packages +        (setq use (mapcar (lambda (package) +                            (if (packagep package) +                                (package-name package) +                                 package)) use))   ;; list package names, not packages                 (when shadow                   (push `(shadow ',shadow ',name) forms))                 (when shadowing-import-from            (push `,(build-import-forms name shadowing-import-from t) forms))                 (when use +          (let ((pkg (gensym))) +                (push +                `(loop for ,pkg in (list ,@use) +                    unless (find-package ,pkg) +                    do (error ""No such package ~a"" ,pkg)) forms))                   (push `(use-package ',use ',name) forms))                 (when import-from            (push `,(build-import-forms name import-from nil) forms)) @@ -174,9 +182,8 @@                 (when documentation                   (push `(setf (documentation ',(intern (string name)) 'package) ,documentation) forms))                 (push `(find-package ',name) forms) -                 `(eval-when (:load-toplevel :compile-toplevel :execute) -                       ,@(nreverse forms)))) +                       ,@(nreverse forms))))   ;; support function for DO-SYMBOLS, etc.  (defun iterate-over-package (package func &optional external-only)"
lisp,383zzy,zxvf,2,Mon Jun 1 18:14:18 2015 UTC,"I tried to install by cloning cepl and varjo into quicklisp/local-projects and doing (ql:quickload :cepl), but I get an error: System ""fn"" not found. Seems to be related to yesterday's commit?"
lisp,383zzy,cliffcrawford,2,Tue Jun 2 02:17:42 2015 UTC,"fn & temporal-functions are both other public repos on my github page. I need to a cleanup of cepl to remove these dependencies but I really like the lambda shorthand from fn so I keep avoiding doing it :D. I have also started the process to get those two & varjo into quicklisp. But that, necessarily, takes time. Thanks for checking it out, I'm looking forward to making the process much easier  [EDIT] I bit the bullet and remove fn so that's one less thing to clone."
lisp,383zzy,Baggers_,1 point,Tue Jun 2 07:19:05 2015 UTC,"Ah ok, didn't think to look there. I'm running into some other problems now (using Clozure CL on Windows, btw) so I think I'll just wait until you get your tutorials up. :)"
lisp,383zzy,cliffcrawford,1 point,Tue Jun 2 21:29:38 2015 UTC,I use sbcl on windows so I can't help there I'm afraid. I'll be uploading the 'getting set up' video in a minute but it's really a glorified version of the readme :). Do comment if anything is unclear as I'm happy to add annotation to the video once it's up
lisp,383zzy,Baggers_,1 point,Tue Jun 2 21:58:53 2015 UTC,"I found that the Quicklisp version of cells claims that it's incompatible with CCL, but there was a checkin a couple weeks ago to fix this in the github repo. I've been using CCL because I got scared off by the ominous warning SBCL prints on startup about it being an experimental port on Windows, heh. :)"
lisp,383zzy,cliffcrawford,1 point,Wed Jun 3 03:03:18 2015 UTC,"I think that warning was much more true a couple of years ago than now. It seems that windows is being kept fairly up to date and the old 'kitten of death' error doesnt seem to be a thing anymore.  Cells is not ccl compatible? bummer. We may need to use something else in the future then, I just really liked the glitch free propagation of data"
lisp,383zzy,Baggers_,1 point,Wed Jun 3 05:19:08 2015 UTC,"I think it is compatible, they just needed to add #+ccl in a few places. (see here)"
lisp,383zzy,cliffcrawford,2,Wed Jun 3 12:18:47 2015 UTC,I'm looking forward to those tutorials promised during the video.
lisp,383zzy,maufdez,2,Tue Jun 2 15:04:02 2015 UTC,Just reorganised the repo to make the 'getting set up tutorial' sane. It's coming :)
lisp,383zzy,Baggers_,3,Tue Jun 2 20:15:35 2015 UTC,Ok here's the first one. Just a quick one today. https://youtu.be/6EN2OVmVz-c
lisp,383zzy,Baggers_,2,Tue Jun 2 22:55:05 2015 UTC,Great stuff.  Keep up the good work!
lisp,383zzy,larsbrinkhoff,1 point,Tue Jun 2 17:31:13 2015 UTC,Thanks!
lisp,383zzy,Baggers_,1 point,Tue Jun 2 20:38:27 2015 UTC,CLinch is also pretty cool
lisp,383zzy,samlamamma,1 point,Mon Jun 1 19:19:00 2015 UTC,"Yeah, It's been nice to see warweasle's recent updates. Is the goal still an editor/universal format for everything or is it more game focused now?"
lisp,383zzy,Baggers_,1 point,Mon Jun 1 20:37:58 2015 UTC,https://www.youtube.com/user/WarWeasle1/videos  I don't know tbh
lisp,37v6te,defun_,17,Sat May 30 17:50:02 2015 UTC,"Sadly, the last minute change before the release broke Slime. Anyone using 1.2.12 should put  (sb-ext:restrict-compiler-policy 'debug) into ~/.sbclrc as a workaround.  EDIT for Google: The error that stops slime C-c C-c from working is ""The value NIL is not of type POLICY."""
lisp,37r9ag,jaykru,2,Fri May 29 19:22:39 2015 UTC,Looks really cool/useful  For the lazy: https://github.com/Shinmera/chirp
lisp,37bxu7,xach,6,Tue May 26 14:29:41 2015 UTC,"It does not seem reasonable to define project metadata in ""private"" systems of the project, such as its testing system or modules of a modular system."
lisp,37bxu7,orivej,3,Tue May 26 16:38:15 2015 UTC,"It's also hard to tell which are private and which are not. It would be easy if every system had metadata anyway, but I understand the reluctance to go to that trouble."
lisp,37bxu7,orivej,3,Tue May 26 18:26:45 2015 UTC,"As far as I know, there's no positive way to identify a system as somehow related to and subordinate to another. In the absence of that, I think having something like ""Test system of foo"" or ""Internal system of foo"" in the :description could be useful."
lisp,37bxu7,DalekBaldwin,2,Tue May 26 18:43:34 2015 UTC,Subordinating systems in a single asd file to the system that shares its name with the asd file and reusing its author and license seems fairly foolproof.
lisp,37bxu7,patrickwonders,1 point,Sun May 31 20:53:22 2015 UTC,"The pattern I always use is to have a file foo.asd which contains defsystem forms for foo and foo-test. System foo can always be loaded with (ql:quickload ""foo""), but (ql:quickload ""foo-test"") won't find foo-test unless foo has already been loaded. Clearly the system that has the same name as the .asd file is already considered special in some sense, so I'd expect we could use this distinction to automatically tag the others as subordinate."
lisp,37bxu7,guicho271828,5,Mon Jun 1 00:02:38 2015 UTC,"It would be excellent if that list had the URLs at the top-level.  I think I've found all of my packages that are on the list, but I'm not sure.  If I could search for 'nklein', that'd rock."
lisp,37bxu7,AeroNotix,3,Tue May 26 15:57:45 2015 UTC,"Good idea, I'll try to update the report with that info."
lisp,37bxu7,raphaelss,1 point,Tue May 26 18:35:33 2015 UTC,http://report.quicklisp.org/2015-05-27/failure-report.html has that info now.
lisp,37bxu7,zxvf,3,Wed May 27 19:27:53 2015 UTC,all systems in my part is fixed.
lisp,37bxu7,eudoxeea,2,Wed May 27 04:11:55 2015 UTC,I will do the ones I have access to now.
lisp,37bxu7,redditsuxass,2,Tue May 26 17:41:44 2015 UTC,I will take a few minutes to submit pull requests to (or open issues on) some of the ones that are hosted on github or bitbucket.
lisp,376m9l,lispm,22,Mon May 25 08:42:39 2015 UTC,they want an IDE that will do as much work as possible for them   I'm ok with computers doing work for me
lisp,376m9l,leftparenrightparen,4,Mon May 25 11:43:56 2015 UTC,"I don't think he was saying that as a bad thing, but as a reason why no one is using LISP in comparison to python, java, etc."
lisp,376m9l,devDorito,12,Mon May 25 23:07:37 2015 UTC,Putting multithreading functionality in the standard for a language is actually a bad idea. Most libraries are very ad hoc. You can't really have a concurrency framework in a standard without a formal memory model. Defining a memory model for a language clashes with both compiler in place and platform you run on. So we stay ad hoc.
lisp,376m9l,cracauer,5,Mon May 25 12:03:50 2015 UTC,"Python has a single definitive implementation with a massive standard library that includes batteries and the kitchen sink. And if you want additional functionality, there is usually at least one clear choice for a 3rd party library. This is tremendously helpful.  I've read a lot about lisp, but this issue of libraries is a major stumbling block in actually writing any code. The first program I tried to write was to make requests for json data from a rest API. So I first started looking for a way to make http requests, and found myself having to research http libraries. You would think sending a simple http request sould be a stupidly simple enough task that I wouldn't need to spend 15 minutes trying to choose a library!  When I finally settled on one, I then started looking for ways to handle the returned json object. Once again, I have to spend 15+ minutes perusing a ridiculous comparison of json libraries, instead of, you know, actually programming.  I eventually gave up, and went back to Python, where I don't have to spend stupid amounts of time trying to figure out how to do insanely basic things. I love the ideas of lisp, which have really changed the way I think about programming. But for writing what would be a very straightforward task in Python is a catastrophic mess in CL."
lisp,376m9l,mooglinux,15,Mon May 25 14:40:13 2015 UTC,And then you just write (jsown:parse (drakma:http-request url)) when you know the bunch of libraries you need.
lisp,376m9l,fmargaine,1 point,Mon May 25 16:27:32 2015 UTC,Vs   requests.get(url).json().   Think it's cheating that requests bundles json parsing?  json.loads(requests.get(url).text)
lisp,376m9l,MachaHack,4,Mon May 25 17:55:18 2015 UTC,And you think the lisp example is worse? I don't see your point.
lisp,376m9l,fmargaine,-2,Tue May 26 12:44:33 2015 UTC,"No, my point is ""Once you find a library, it's really simple"" is not a benefit exclusive to lisp in this example."
lisp,376m9l,MachaHack,7,Tue May 26 15:27:27 2015 UTC,"My point was more that once you know the libs, it's just as easy in lisp than it is in python, which is what OP was complaining about."
lisp,376m9l,fmargaine,13,Tue May 26 15:51:28 2015 UTC,"It's not a mess, you're just comparing something you know with something you don't and complain that it takes time to figure it out."
lisp,376m9l,sionescu,14,Tue May 26 20:27:56 2015 UTC,"Funny you chose http libraries as an example when Python's std library choice, urllib2, sucks so hard people use requests instead. And encodin JSON with the standard library is surprisingly unpythonic. When you want to teach the encoder about a new class, it doesn't work with a __json__ method as one would expect but have to subclass the encoder iirc.  Also you mention the advantages of a blessed single implementation, but not its disadvantages. PyPy has to copy its functionality even when it doesn't make sense at is clearly an implementation detail just for compatibility, ie True being a monkey patched instance of 1, False for 0. Btw having CPython being the de facto standard wouldn't be so bad if it didn't sucked as much."
lisp,376m9l,PuercoPop,2,Mon May 25 23:52:21 2015 UTC,"While you can argue as much as you want about the quality of python's libraries, the simple fact is that the libraries are there, and for somebody new to the language not having to go in a quest to find them really encourages adoption. When learning a new language you usually want to do something simple but somewhat useful, so the http+json example is valid; and we have to recognize that is way easier to do that in python than in CL, sadly.   Once you are engaged enough to find out the flaws searching for something better looks easier."
lisp,376m9l,rarqrp,3,Mon May 25 19:04:07 2015 UTC,"somebody new to the language not having to go in a quest to find them really encourages adoption.    Agree.  That is why if one goes to cliki.net the 4th link is recommended libraries and for HTTP Client and JSON there is only one recommended. And the JSON recommended library makes it super easy to encode a new class through a generic function and some helpers.  Of course if one wants to do a web app, the options quickly multiply.  But as /u/sionescu has point out, due diligence pays off before deciding on a library.  Disagree that when starting out http+json is a good thing to try out. You are just using libraries.   Of course Python has more and better written documentation."
lisp,376m9l,PuercoPop,1 point,Tue May 26 11:37:27 2015 UTC,"That's a fair point about cliki, I actually didn't know about it's recommended libraries list.  I agree with /u/sionescu too, but I'm not sure we could expect somebody ""new"" to have due diligence. Again, I'm assuming we talk about ""new"" people that wants to get a try of this weird language called lisp (not even differentiating between the myriad of lisp dialects) and wants to hack something to get a taste of it. Most of the programmers I know are like that and that's were my http+json reference comes from. To truly appreciate a language you have to use it somewhat regularly and if you don't have a itch to scratch is hard to be motivated by going through a list of exercises from a book. And most day to day task require you to use a library to do some of the work. Devising a clever algorithm for a task  or implementing a data structure is exciting, at least for some of us, but daily tasks usually are just gluing together APIs."
lisp,376m9l,rarqrp,1 point,Tue May 26 15:27:10 2015 UTC,"I agree that using libraries and writing glue code is what most of us do day to day. But I don't think that helps to get the feel of a language. How different would be to an fetch some URL and decode some JSON in Perl, Python, Ruby or JS? I don't very much. I also agree that writing something of use helps motivation. However to get the feel of a language even trivial problems like a tic-tac-toe/game-of-life problem is better."
lisp,376m9l,PuercoPop,1 point,Tue May 26 19:26:37 2015 UTC,"To be fair, we are not talking of exactly just reading data through http. Usually you do that to extract some data and then do something with it, so it's not just gluing those two. I completely agree that those simple tasks are way better for learning the language, but I'm more used to see people trying out language's building a simple Wikipedia browser than game of life.   But you could have better friends than I :)"
lisp,376m9l,rarqrp,4,Tue May 26 20:57:45 2015 UTC,"So ""too many libraries"" is a problem now? I always thought the problem is that there aren't libraries for Lisp...   /s"
lisp,376m9l,mchabez,3,Tue May 26 21:18:28 2015 UTC,"Whether there are no libraries (so you have to write your own domain language) or there are too many libraries (no standard domain language), the problem is the same: you dont know the language (API) other people are using to deal with a specific problem. Today, one of codes most important features is talking to other peoples code. If a language ecosystem makes it hard for your code to do that, it doesnt matter whether it is because of too many or too few libraries."
lisp,376m9l,muuh-gnu,1 point,Mon May 25 16:39:19 2015 UTC,But how can you have a usable language with concurrency and side effects without some sort of memory model?
lisp,376m9l,StrmSrfr,1 point,Mon May 25 17:20:40 2015 UTC,He is saying without an standardized memory model. Different implementations define their own.
lisp,376m9l,PuercoPop,19,Mon May 25 15:18:19 2015 UTC,"The open source versions don’t have everything you really need, e.g. multithreading. [...]  Common Lisp is big, but doesn’t include as a standard libraries that are important for real applications — multithreading, networking, user interface. Commercial Lisp implementations have their own versions of these libraries, but they’re all different.   SBCL, ClozureCL, ECL, and many other open-source implementations have multithreading and networking. Portability libraries also exist for them. Is the author not aware of those?"
lisp,376m9l,mchabez,17,Mon May 25 20:57:06 2015 UTC,"I'd guess he stopped using Lisp twenty five years ago or so. If he worked on TI Explorers, those were cancelled by TI in 1991."
lisp,376m9l,treerex,3,Mon May 25 10:00:26 2015 UTC,My favorite language is Lisp. What happened?   He stopped using it? He can't find a company that will let him use it?
lisp,376m9l,xieyuheng,6,Mon May 25 10:15:23 2015 UTC,"lisp can be better https://github.com/cl21/cl21  but it won't  because of historical reasons    scheme can be better  but it won't  because of there are too many definitions of ""better""."
lisp,376m9l,zem,7,Mon May 25 21:32:52 2015 UTC,"there's always racket, which has a single community and implementation, and is actively working on ways of integrating the ""too many definitions of better"" into a coherent whole"
lisp,376m9l,doomchild,1 point,Mon May 25 11:57:04 2015 UTC,"There hasn't been any movement on CL21 in ages, has there?"
lisp,376m9l,Madsy9,-5,Mon May 25 21:22:06 2015 UTC,Want a lispy language with great multithreading support? Try Clojure :)
lisp,376m9l,fmargaine,14,Mon May 25 21:27:45 2015 UTC,"Or use Common Lisp with bordeaux-threads/lparallel/whatever you want :)  As said earlier in this thread, this post is vastly outdated."
lisp,376m9l,classicalhumanbeing,2,Mon May 25 19:03:00 2015 UTC,"If clojure wasn't tied to JVM/Java (or worse javascript) it might have been worth spending some time with. As it stands right now, it's garbage of the worse sort for anyone that despises the Java ecosystem (which should be anyone sane really).  Common Lisp doesn't compromise in this fashion."
lisp,378l4q,fmargaine,2,Mon May 25 19:32:51 2015 UTC,"Minor nitpick, you could use mixins to reduce code duplication on the slot-definitions.  (defclass resource-standard-slot-definition (closer-mop:standard-slot-definition)   ((is-identifier :initarg :is-identifier :initform nil)    (required :initarg :required :initform nil)    (default :initarg :default :initform nil)    (excluded :initarg :excluded :initform nil)))  (defclass resource-standard-direct-slot-definition (resource-standard-slot-definition                                                     closer-mop:standard-direct-slot-definition))  (defclass resource-standard-effective-slot-definition (resource-standard-slot-definition                                                        closer-mop:standard-effective-slot-definition))"
lisp,378l4q,PuercoPop,1 point,Mon May 25 21:35:23 2015 UTC,"Oh smart, indeed! I was looking for a way to DRY up this bit of code, this is nice. Thanks!"
lisp,378l4q,PuercoPop,1 point,Tue May 26 15:25:52 2015 UTC,There is another idiom I like for when compute-definition-slot just copies the metadata when found.  https://github.com/mmontone/cl-rest-server/blob/05bd35255fee3f54c1a456576fe2543250b9a094/src/decorator-class.lisp#L39
lisp,378l4q,Tordek,1 point,Tue May 26 17:06:29 2015 UTC,Hi!  I made this library because I often get projects where all I need is a CRUD API + custom actions... and rewriting the CRUD part every time is boring.  Feedback appreciated!  Thanks
lisp,378l4q,Tordek,1 point,Mon May 25 19:35:00 2015 UTC,No HATEOAS? No REST.
lisp,3710zq,samlamamma,11,Sat May 23 21:29:51 2015 UTC,"Using the condition system for backtracking is wasteful. All you need is a single special variable and CATCH/THROW: the condition system provides all sorts of bells and whistles related to, you know, handling conditions, which are not needed here.  See:  https://gist.github.com/nikodemus/b461ab9146a3397dd93e  for comparison. It swaps out the guts of the linked backtracking implementation with CATCH/THROW and gets 10 x the performance with less code complexity."
lisp,3710zq,nsiivola,2,Sun May 24 15:47:05 2015 UTC,"This makes me wonder whether there might be a lot of other common usage patterns for the condition system whose performance could be drastically improved with catch/throw.  Right now I'm toying around with building a system where the object-oriented nature of conditions is pretty useful, so that by signaling a condition of a more specific class I can handle it closer to the point where it was signaled, but in principle I can't see any reason why I wouldn't be able to use a few macros to wrap a similar mechanism around catch/throw instead."
lisp,3710zq,DalekBaldwin,2,Mon May 25 06:34:05 2015 UTC,You also need to take into account that using the condition system to effect a transfer of control is a two-step process:   Find and invoke the handler. Handler runs (possibly transferring control.)
lisp,3710zq,nsiivola,2,Mon May 25 09:57:26 2015 UTC,"I took a stab at it and made this version of the same example: https://github.com/DalekBaldwin/backtrack/blob/master/src/wrap.lisp  This ran ten times slower than the condition-based version (that is, a hundred times slower than your throw/catch version), although my only goal was to make the code look absolutely identical (just by making these substitutions: define-condition -> defclass; signal -> wrapped-error; handler-case -> wrapped-handler-case)."
lisp,3710zq,DalekBaldwin,2,Wed May 27 10:29:47 2015 UTC,"when a restart w/o unwinding is required, condition system eases the effort to write such a code, with a cost of speed (which I learned in this thread). Catch/throw does rewind the stack."
lisp,3710zq,guicho271828,1 point,Tue May 26 15:25:16 2015 UTC,oh that's helpful. thanks!
lisp,3710zq,guicho271828,3,Mon May 25 00:26:45 2015 UTC,"I have made a toy sudoku solver using CLOS and condition system some years ago. Search techniques like Arc Consistency and AC-3 were represented as CLOS subclasses of ""searcher"" class, then their methods defines how to explore the search space and how to handle the backtrack & apply backchaining.  Condition system is great, but one thing I was not sure is its performance. I see some dynamic-extent's in the expansion of handler-bind on SBCL, but still not sure how far such optimization goes. In the sudoku solver mentioned above, CLOS was already a large performance bottleneck, so the drawback of condition system was not verified."
lisp,36vm7m,66a4,3,Fri May 22 14:00:16 2015 UTC,Down for maintenance.
lisp,36vm7m,xach,1 point,Fri May 22 14:53:15 2015 UTC,Back up.
lisp,36wbqh,xieyuheng,2,Fri May 22 17:35:01 2015 UTC,"Dylan itself used to be Lisp flavoured.  It's now called ""Prefix Dylan"", but was ditched in favour of the new ""Infix Dylan"" syntax."
lisp,36wbqh,larsbrinkhoff,2,Fri May 22 18:06:10 2015 UTC,"There's a few I can think of; the best documented are probably Marlais (kinda dead), Goo, and RScheme.   Marlais is an original Dylan that kept the S-Expression syntax Goo is an extended Scheme-Dylan hybrid, that has been maintained off & on for some time. Has some interesting stuff. RScheme is firmly in the Scheme camp, but it has ideas from Dylan on the OO side of the house. It's pretty neat.   There are quite a few others, but they probably fail your ""well documented"" test."
lisp,36wbqh,lojikil,1 point,Fri May 22 18:00:15 2015 UTC,"We would entertain someone working on a Lisp-style reader for Dylan, but it is a lot of work to design something that works well and reads well.  So far, we've never had someone follow through."
lisp,36rxft,cnorvell,3,Thu May 21 17:14:28 2015 UTC,AllegroGraph is the only semantic database that can scale to trillions of RDF triples and still perform query in almost real-time.  No one else come even close.
lisp,36rxft,scwatreddit,1 point,Fri May 22 00:39:18 2015 UTC,Really?  A trillion is a lot... of anything!  Where would be a good place to read about that?
lisp,36rxft,WalterGR,4,Fri May 22 01:52:21 2015 UTC,"Other than the advertisement, I made a quick servey.  Some papers use older AllegroGraph 1 or 2 and shows very poor results. Rohloff, Kurt, et al. ""An evaluation of triple-store technologies for large data stores."" On the Move to Meaningful Internet Systems 2007: OTM 2007 Workshops. Springer Berlin Heidelberg, 2007.  Others use AG 3, Maharajan, Shridevika. ""Performance of native SPARQL query processors."" (2012). Out of 4 RDF implementations AG3 and Virtuoso were outstanding. In warm query time AG3 scaled much better than Virtuoso, but the author magically conclude that Virtuoso wins AG3 (why?).  Most papers seem to use the free version, so the true performance would not be exhibited. Also, AG4 seems much more improved compared to the previous version."
lisp,36rxft,guicho271828,1 point,Fri May 22 08:32:37 2015 UTC,"Thanks so much!  I read the press release and the associated rah-rah documents, but they were a little... short on detail:  For example, apparently AllegroGraph can load a trillion triples, but what I found had nothing to say about its ability to query a trillion triples..."
lisp,36rxft,WalterGR,1 point,Fri May 22 10:05:18 2015 UTC,Franz
lisp,36rxft,eldub,2,Fri May 22 04:49:04 2015 UTC,"Right.  The vendor's sales material mentions that AllegroGraph is capable of loading a trillion triples in 14 days.  There are other page(s) that mention using >=200 machines to do some processing.  (My google-foo is failing me at the moment...)  I was more interested in details about its ability to scale to trillions of triples, and being able to query them in almost real-time...  Apologies if my question was vague."
lisp,36kkdc,brianqx,8,Wed May 20 01:46:12 2015 UTC,"I have spoken with Kent Pitman about the TeX sources; I've been interested in making a printed version sometime. In his view, the dpans3 TeX sources are fair game for anyone to create derived works, for free or for pay, without limitation.  I haven't talked to him about the CLHS, but I suspect that the program that produces it will never be freely available and that the license on the output will never be changed.  If you want something prettier, I think the dpans3 sources are the best place to start. I know of at least two three four people currently working on parsing and processing it. https://github.com/robert-strandh/dpANS-parser is one example. https://github.com/lokedhs/parse-lisp-spec is another."
lisp,36kkdc,xach,2,Wed May 20 02:03:46 2015 UTC,Franz has their own HTML version (not based on CLHS) of the ANSI CL standard (probably also the last version before the official standard) included with Allegro CL.
lisp,36kkdc,lispm,1 point,Wed May 20 10:15:46 2015 UTC,Do you think that version is likely to be licensed in a way that allows updates?
lisp,36kkdc,xach,2,Wed May 20 13:19:00 2015 UTC,"Unlikely, but I think that's moot.  HTML is horrible to work with and the original XML source (done by a company called ""Schema"" in Germany) is lost.  At least, when I tried to get it from them they ignored me."
lisp,36kkdc,e40,3,Thu May 21 18:13:24 2015 UTC,Interesting! How did you learn that info about Franz's HTML version of the spec? Is any more info available?
lisp,36kkdc,xach,2,Thu May 21 18:19:56 2015 UTC,I work on Allegro.  You know me as @envoy510.  I wish I knew more.  The person that did the deal (in the 90's) is no longer at the company.
lisp,36kkdc,e40,2,Thu May 21 18:23:45 2015 UTC,It was done at SCHEMA GmbH. They had a Lisp/CLOS-based content management system as a product.  The contact was Marcus Kesseler... he is still in company management at SCHEMA GmbH...  But that is all long ago.
lisp,36kkdc,lispm,1 point,Thu May 21 21:08:17 2015 UTC,"Yes, that license is only applicable to the HyperSpec, which is hosted by LispWorks."
lisp,36kkdc,xach,1 point,Wed May 20 16:50:08 2015 UTC,"Ah, I had assumed the TeX sources weren't ""Hyper"" which I was assuming the OP considered a necessary feature."
lisp,36kkdc,patrickwonders,1 point,Wed May 20 16:51:57 2015 UTC,Maybe we can organize some sort of kickstarter or bountysource to get this work done? To convert dpans3 TeX sources to XML or something else which could be used as a basis to generate the documentation in any form.
lisp,36kkdc,furych,1 point,Thu May 21 03:22:29 2015 UTC,There are several people working on processing the spec right now. I think it's worth waiting a few months to see how it pans out.
lisp,36kkdc,xach,1 point,Thu May 21 22:05:10 2015 UTC,The projects you've mentioned above more dead than alive as it looks...
lisp,36kkdc,furych,1 point,Thu May 21 23:03:47 2015 UTC,To convert dpans3 TeX sources to XML or something else...   Are there existing XML schemas  that would be appropriate for the task?
lisp,36kkdc,WalterGR,1 point,Fri May 22 22:03:07 2015 UTC,"I believe DocBook5 will do the job, but probably something else is around?"
lisp,36kkdc,furych,3,Fri May 22 02:11:01 2015 UTC,"I was told that Digital Press had released the old latex source for CLTL2 and allows anyone to use them as a basis for further work. Since I've worn out my second paper copy of CLTL2 I needed something online.  I did minimal changes to make it Latex2e compatible. I added hyperlinks, most of the index, and lists of functions. I added hyperlinks to the functions in the table of contents.  Try http://daly.axiom-developer.org/clm.pdf  The sources are at http://daly.axiom-developer.org/cltl2_latex2e.tgz See the shell script 'm' for building. There are build comments at the top of the clm.tex"
lisp,36kkdc,timdaly,6,Fri May 22 22:03:46 2015 UTC,"Don't use CLtL2. It has many differences to ANSI CL. Some are hard to find. It's also a very confusing document, since it also includes the full content of CLtL1. It's a great piece of work, but it's more confusing than helpful."
lisp,36kkdc,lispm,1 point,Wed May 20 09:14:11 2015 UTC,"It's also possible to build it without editing the code: download both the TeX sources and the dvi, drop the dvi into the same directory as the sources, and use dvipdfm."
lisp,36kkdc,ruricolist,5,Wed May 20 10:13:53 2015 UTC,"I think it's pretty nicely formatted. It's a motherfucking website, it doesn't need to look fancy."
lisp,36kkdc,Grue,2,Wed May 20 22:21:33 2015 UTC,Oh yeah the formatting is fine. I just wish it would show you more info in one page and was much easier to navigate.
lisp,36kkdc,xenow,1 point,Wed May 20 13:57:11 2015 UTC,Can't someone distribute an alternate CSS stylesheet for it?  Then have the user load it in their browser of choice as an overridding style (custom CSS in firefox for example).
lisp,36kkdc,dr_jumba,1 point,Wed May 20 19:22:43 2015 UTC,The problem is that there is no single copyright holder who can give the permission. People more or less involved give only opinions. E.g. I have contacted PARC a couple of years ago about dpans files on their FTP.  The question is who is the injured party if one produces the derivative work without permission.  The scenario might be following. Make the public derivative work and see who will try to claim the copyright violation and then negotiate. Of course the problem is that their lawers kung fu might be much stronger than of that guy. He should take care of that or be some other country resident for example.
lisp,36kkdc,patrickwonders,1 point,Fri Jun 5 20:49:39 2015 UTC,"All of the copies of the Hyperspec that I have bear this information which expressly forbids modifying anything or replacing images and such and clearly says that Lispworks, Ltd. holds the copyright for the marked-up version of the spec.  http://www.lispworks.com/documentation/HyperSpec/Front/Help.htm#Authorship"
lisp,36kkdc,xach,1 point,Wed May 20 07:44:37 2015 UTC,I suspect dr_jumba is talking about the TeX sources from which the HyperSpec is derived.
lisp,36kkdc,WalterGR,1 point,Wed May 20 16:52:59 2015 UTC,"Make the public derivative work and see who will try to claim the copyright violation...   A ""copyright canary,"" so to speak.  Interesting idea!"
lisp,36f7z8,malisper,1 point,Mon May 18 22:39:51 2015 UTC,http://weitz.de/html-template/#mail lists one option. I'm a little surprised html-template is not on https://github.com/edicl/ though.
lisp,36f7z8,xach,1 point,Mon May 18 23:05:45 2015 UTC,"I see the links to the mailing lists, but they are broken. I tried looking for the mailing lists on common-lisp.net but couldn't find them there either. Am I just missing something painfully obvious?"
lisp,36f7z8,xach,2,Mon May 18 23:32:05 2015 UTC,Probably not. You could try emailing Edi or Hans Hübner about it directly.
lisp,36f7z8,LionTamingAccountant,1 point,Mon May 18 23:47:20 2015 UTC,Archives seem to exist but the 'more information' link there says it doesn't. Gmane mirror
lisp,368k50,TitWinkle,13,Sun May 17 05:19:25 2015 UTC,"Have you read this?  I think it should help. If it doesn't help, feel free to ask.   Other than Emacs, you also need a CL implementation installed as well. There are many of those, like SBCL, CCL, CLISP, ECL etc.. See the sidebar for links. SBCL is my personal favorite.  Another thing you need is Quicklisp, a software manager for CL, and Slime, a plugin for Emacs, installable via Quicklisp."
lisp,368k50,mchabez,3,Sun May 17 07:06:36 2015 UTC,"I started out like you a couple of years ago.  I tried to learn Racket and Emacs at the same time and ended up abandoning Emacs (for the time being) and using Sublime (my usual text editor).  Try learning one thing at a time would be my suggestion.  I second the suggestion by /u/TechnoSingularity to take a look at Racket and read Realm of Racket.  Also take a look at the tutorials on their site: http://racket-lang.org/  Once you've got Racket under your belt, then I'd recommend taking a look at Practical Common Lisp (I'd recommend using whatever text editor you already know).  Finally, I'd say that a Lisp is definitely worth learning.  For me, the biggest insight has been: 1) learning to think functionally 2) and getting into the habit of more/smaller functions  I do mostly do Python for my job and my Python code has gotten much cleaner, more reliable and better tested since learning Racket.  I hope this helps!"
lisp,368k50,Colt85,9,Mon May 18 03:42:07 2015 UTC,"""The gigamonkey book"" has that tutorial. I never followed the ""Lisp on a Box"" thing that it talks about, but that seems to be available.  I think it would probably be easier to  apt-get install sbcl apt-get install slime emacs M-x slime   but maybe that's because I'm used to it."
lisp,368k50,ponkanpinoy,3,Sun May 17 10:13:26 2015 UTC,"I got my start on emacs because it's the best way I found to work with lisp. To add to the above:   M-<key>: M (Meta) is usually bound to <Alt>, so that's Alt+key. C-<key>: Ctrl+key C-M-<key>: Ctrl+Alt+key C-<key> C-<otherkey>: Ctrl+key, then Ctrl+otherkey C-x C-f: Find (open) file. Will prompt for filename (does tab expansion). Will create a new file if needed. C-x C-s: Save the currently-open file C-x 3: Split the buffer left/right C-x b: Change current buffer; use this to change to *slime-repl sbcl* after doing C-x 3 to have both the source file and the REPL visible; this is my preferred layout. C-x o: Switch to other window. C-M-x: Evaluate the expression the point (caret/text cursor) is on. This requires that you're in a .lisp file, and you've already started slime with M-x slime. Useful when you're incrementally working on a source file; I usually do this after every side-effecting s-exp (defun, defparameter, defvar, setf, etc) C-c C-r: Evaluate region (highlighted area, or entire buffer if nothing highlighted). Good for starting up a new session with an existing file.   This is all you need to get started, and it's less than it might seem; I got used to two-thirds of these bindings after a day, and the rest took less than a week."
lisp,368k50,TechnoSingularity,2,Sun May 17 11:15:28 2015 UTC,Thanks a lot. Turns out the M-x slime was the only missing piece of the puzzle.
lisp,368k50,Mizar83,6,Tue May 19 10:01:41 2015 UTC,"Do you in particular want to learn CommonLisp or will any dialect of Lisp work for you? If any try Racket you can view How to Design Programs 2nd Edition: http://www.ccs.neu.edu/home/matthias/HtDP2e/ for a start, and then move onto Realm of Racket: http://realmofracket.com/  Maybe you would prefer Scheme if so try this out: https://mitpress.mit.edu/sicp/ Although I've heard it is difficult.  Or perhaps Clojure is more your thing if so start here: http://www.tryclj.com/"
lisp,368k50,holomorphish,3,Sun May 17 07:19:54 2015 UTC,"I second this, also this course on edX https://www.edx.org/course/systematic-program-design-part-1-core-ubcx-spd1x uses Racket, and it's very good, and follows the Design programs book. It's starting in a couple of weeks."
lisp,368k50,sht,2,Sun May 17 14:40:22 2015 UTC,"I agree with your suggestion of using Racket; that was how I got started with using Lisp at first. DrRacket is really easy to set up and use, and once I got really hooked I then had the gumption to switch to using Emacs with SLIME and Common Lisp."
lisp,368k50,ilurkedhere,8,Sun May 17 18:03:46 2015 UTC,Crawl before you run. I'd suggest you download a CL implementation and just type in the REPL the new functions your learning (note some will need rlwrap in order to be usable). Several are available from apt-get; CLISP is probably the friendliest.
lisp,368k50,aerique,2,Sun May 17 08:11:13 2015 UTC,"I definitely recommend this approach before getting started a more fancy development environment. Here's some basics commands that help:  * (describe 'describe) COMMON-LISP:DESCRIBE   [symbol] DESCRIBE names a compiled function:   Lambda-list: (OBJECT &OPTIONAL (STREAM-DESIGNATOR *STANDARD-OUTPUT*))   Documentation:     Print a description of OBJECT to STREAM-DESIGNATOR.   Known attributes: call, unwind, any   Source file: SYS:SRC;CODE;DESCRIBE.LISP.NEWEST  * (describe 'inspect) COMMON-LISP:INSPECT   [symbol] INSPECT names a compiled function:   Lambda-list: (OBJECT)   Known attributes: call, unwind, any   Source file: SYS:SRC;CODE;INSPECT.LISP.NEWEST  * (describe 'apropos) COMMON-LISP:APROPOS   [symbol] APROPOS names a compiled function:   Lambda-list: (STRING-DESIGNATOR &OPTIONAL PACKAGE EXTERNAL-ONLY)   Documentation:     Briefly describe all symbols which contain the specified STRING.       If PACKAGE is supplied then only describe symbols present in       that package. If EXTERNAL-ONLY then only describe       external symbols in the specified package.   Known attributes: call, unwind, any   Source file: SYS:SRC;CODE;TARGET-PACKAGE.LISP  * (describe 'load) COMMON-LISP:LOAD   [symbol] LOAD names a compiled function:   Lambda-list: (PATHSPEC &KEY (VERBOSE *LOAD-VERBOSE*)                 (PRINT *LOAD-PRINT*) (IF-DOES-NOT-EXIST T)                 (EXTERNAL-FORMAT DEFAULT))   Documentation:     Load the file given by FILESPEC into the Lisp environment, returning        T on success.   Known attributes: call, unwind, any   Source file: SYS:SRC;CODE;TARGET-LOAD.LISP"
lisp,368k50,zetaomegagone,1 point,Sun May 17 14:36:08 2015 UTC,"Yeah, even nowadays I sometimes code CL using Vim (or any other text editor) and reloading the updated files.  It's no Emacs+Slime but you will get a taste of the possibilities."
lisp,368k50,WarWeasle,1 point,Mon May 18 10:57:10 2015 UTC,This.  This is what I'm doing.
lisp,368k50,paines,3,Mon May 18 15:11:53 2015 UTC,"I enjoyed practical common lisp and land of lisp. Understand that a cons cell is a structure of two pointers (car and cdr). Implement McCarthy's original lisp in C. Your understanding will be transformed.   Also, try the little schemer. Scheme is a simpler lisp, more like C in that aspect. Scheme is lisp, but common lisp includes the kitchen sink. But understand, there is no lisp for dummies. It will blow your mind. Like when you learned to compose programs in unix? Or when you read an implemention of Forth. When you read the paradigms of artificial intelligence programming and implement prolog. Land of lisp is worth it just for building a web server in a single chapter.   Strap yourself in and enjoy the ride."
lisp,368k50,WarWeasle,2,Mon May 18 03:00:19 2015 UTC,"Implement McCarthy's original lisp in C. Could you please eleborate on this, why this is beneficial ?"
lisp,368k50,paines,2,Mon May 18 09:13:51 2015 UTC,"Because it's very small. Musicians learn the great pieces. Architects study great buildings. Programmers reimplement great code. It doesn't take long and you might learn something. Is there a better reason than that?  Also, c won't hide any implementation details.  If you want garbage collection, you have to add it. Oh, and you will make mistakes, this is where you learned."
lisp,368k50,leftparenrightparen,1 point,Mon May 18 12:19:38 2015 UTC,:) Thanks!
lisp,368k50,spacebat,1 point,Mon May 18 13:05:31 2015 UTC,http://www.buildyourownlisp.com/
lisp,368k50,cyisfor,3,Mon May 18 17:11:23 2015 UTC,"My first Lisp was Emacs Lisp, and my understanding improved at lot once I discovered the REPL for it: M-x ielm  Because I was using Emacs for programming other languages, I had reason to customize and improve my Emacs configuration, which involved setting variables, checking that files exist, looping over lists, all in a Lisp that, once you (require 'cl) and squint a bit, is quite like CL.  Once I was familiar with that I wanted to go further and started using CL proper. By that stage customizing Slime came easily."
lisp,368k50,eadmund,2,Mon May 18 03:35:42 2015 UTC,CLiki seems like the best place to start.
lisp,368k50,elimik31,2,Sun May 17 08:52:32 2015 UTC,"Lisp is definitely worth learning and using in 2015.  I honestly don't know if there're any good tutorials out there.  Part of the issue is that Lispers tend to customise their environments so much that what applies to me doesn't necessarily apply to you. There's also the issue that some aspects of getting setup can be fractally complex.  For working through Practical Common Lisp, you don't need emacs+SLIME, but it sure helps. If you're using emacs, you might wish to take a look at prelude, which is a nice config setup. But of course that's one more thing to use (remember what I said about fractal complexity?).  Download & install sbcl. Configure SLIME to use sbcl, setup SLIME with all the fancy contribus, then type M-x slime in emacs, and start working at the REPL. You can open files ending in .lisp and use SLIME commands like C-x C-e to evaluate expressions in them, and use other keys to load them into your running SLIME session."
lisp,368k50,forme2you,2,Sun May 17 19:27:33 2015 UTC,"I think that now is quite a good time to learn LISP. The language is getting more popular again and has an active community. With quicklisp, there are many libraries available and installing them is no issue anymore, Common Lisp has become ""batteries included"". Once you have an REPL set up, it's really easy to try things out and if you don't know how to do something, you google it. That's how I did it. It's not something that will get you a job, but it's fun.  I had used emacs before I started learning LISP and had experience with other programming languages (mainly C++ and python). Because of that, installing slime for emacs was pretty easy for me and the introduction in ""Practical Common Lisp"" (the ""gigamonkeys book"") was sufficient for me, but if you are not as experienced with programming and Linux/Unix, you might be baffled at first. The target group of that book are people who have programmed before. But as was already mentioned, there are other ressources in the internet as well.  One option might be Clojure. It's a really new lisp dialect and has grown to be really popular. Because it runs in the Java Virtual Machine (JVM), its code is easily portable and you has access to all Java libraries. As it's so new and popular, there are many great resources for total novices, just google it. It stresses functional programming and uses immutable data structures, you might or might not like this. And it's not for you if you want fast, compiled code."
lisp,368k50,Lolor-arros,1 point,Mon May 18 23:54:01 2015 UTC,"Same problem here: how to write Windows lisp executable that reads string ??? as command line parameter and prints ""Hello ???"". Hate to think that one needs to install CLON for such a simple program."
lisp,368k50,forme2you,2,Sun May 17 12:41:48 2015 UTC,"Hate to think that one needs to install CLON for such a simple program.   Erm, if you want the computer to understand what you're trying to do, in a specific language, you're going to have to install a program for it.  Emacs/Slime is the best program for that purpose.  You can package lisp programs in a way that they are executable on computers that don't have a LISP implementation installed, but doing that requires special programs as well.  Are you sure you're in the right place?  You could to that with a .bat file..."
lisp,368k50,aerique,1 point,Sun May 17 12:59:32 2015 UTC,"Most lisp tutorials assume you are in REPL all the time, but simple command line script examples are missing. Consider this: If I want to distribute my Python script I only have to instruct user to install Python (click NEXT, NEXT, NEXT...), fix PATH and then run python <script.py>. Anyways. DrRacket got this right."
lisp,368k50,fmargaine,2,Sun May 17 13:22:07 2015 UTC,"You do not need CLON if you just want to use a single command line parameter.  It depends on your Lisp implementation how those parameters are available though.  CLON is recommended once you need to parse multiple, different kinds of command line parameters. However needing a library for that is no different in almost any other programming language."
lisp,368k50,malisper,1 point,Mon May 18 10:55:35 2015 UTC,Use buildapp
lisp,368k50,Aidenn0,1 point,Sun May 17 16:57:51 2015 UTC,"If all you need is a REPL, you can use JSCL. I believe it should have everything you need for an introductory lisp book, although it is missing some more advanced features such as CLOS."
lisp,368k50,zetaomegagone,1 point,Sun May 17 14:01:04 2015 UTC,The lack of LOOP makes it a non-starter for me.
lisp,368k50,leonardodag,1 point,Tue May 19 22:35:42 2015 UTC,"This free book is what I'm doing right now. I'm on Linux mint and have CLISP installed. Workflow isn't the best ATM, but I'm concentrating on learning Common Lisp first and setting up/learning an ideal IDE second. I'm new to programming fwiw.  Also, there are many good resources on Common Lisp. A major resource is the Common Lisp Wiki  EDIT: Also, The Little Schemer is good too because it helps you see what is going on ""underneath"" Common Lisp (under the syntactic sugar). PM me if you want.  EDIT EDIT: This subreddit is great. Always feel free to ask."
lisp,368k50,tuhdo,1 point,Mon May 18 15:11:05 2015 UTC,"The gigamonkeys book does the ""download emacs, figure and out, and let's do some lisp"" on chapter 3, but on the next chapters it explains things better. I'd recommend skipping chapter 3 if you prefer - I'd say it's more of a chapter showing lisp's capabilities"
lisp,368k50,oberlinbsd,1 point,Sun May 24 02:03:58 2015 UTC,"I hope this short guide may help you use Emacs and SLIME to play with Common Lisp:   Install Emacs: sudo apt-get install emacs Install SBCL, the compiler: sudo apt-get install sbcl Install gnome-tweak-tool:   sudo apt-get install gnome-tweak-tool    Then swap Caps Lock and Control before using Emacs. Install Spacemacs:  git clone --recursive http://github.com/syl20bnr/spacemacs ~/.emacs.d git checkout develop Start Emacs. Spacemacs will ask you which editing style you want to use; choose Emacs (using the arrow keys) and wait for the packages to install. After every package is downloaded, open the ~/.spacemacs file with Alt-m f e d : it menas, you press Alt and while holding Alt, press m, then press f then e then d sequentially to open the file. Or, alternatively, you can press Alt-m f f and type ~/.spacemacs. From now on, when I say M-m it means Alt-m or C-m, it means Ctrl-m. In Emacs, M- means Alt- and C- means Ctrl-. If you use Vim editing style, you can press SPC instead of M-m. Press C-s to search for this string dotspacemacs-configuration-layers. In there, you see a list of configuration layers. A configuration layer is a collection of packages setup toward a feature. For example, you can see auto-completion layer there; it is a collection of packages related to auto-completion Spacemacs already created for you. You don't have to manually setup all the packages in there to get this features. Originally, dotspacemacs-configuration-layers looks like this:  dotspacemacs-configuration-layers    '(      ;; ----------------------------------------------------------------      ;; Example of useful layers you may want to use right away.      ;; Uncomment some layer names and press <SPC f e R> (Vim style) or      ;; <M-m f e R> (Emacs style) to install them.      ;; ----------------------------------------------------------------      ;; auto-completion      ;; better-defaults      emacs-lisp      ;; (git :variables      ;;      git-gutter-use-fringe t)      ;; markdown      ;; org      ;; syntax-checking      )    Change it to looks like this:    dotspacemacs-configuration-layers   '(     ;; ----------------------------------------------------------------     ;; Example of useful layers you may want to use right away.     ;; Uncomment some layer names and press <SPC f e R> (Vim style) or     ;; <M-m f e R> (Emacs style) to install them.     ;; ----------------------------------------------------------------     auto-completion     better-defaults     emacs-lisp     slime     ;; (git :variables     ;;      git-gutter-use-fringe t)     ;; markdown     ;; org     ;; syntax-checking     )   Adding slime is important. It's your Common Lisp development environment. Then restart Emacs and wait for everything to be installed.  After the installation is finished, you can start playing with Common Lisp. M-m f f and create a new file named test.lisp anywhere; you can use TAB to enter a directory and C-l to get out of a directory. Then press M-x then type slime and press Enter key to create a connection to sbcl. A REPL is opened to the right side of your buffer. Now you can either enter Common Lisp code in the REPL, or in your buffer then:   C-x C-e to evaluate individual expression. That is, you move your cursor to the end of any closing parentheses and press C-x C-e. C-c C-k to compile and reload the whole file in your REPL.   These two key bindings along with the REPL should be enough to give you a nice environment with Common Lisp.  You can switch between buffers with C-x b.  What is Spacemacs? Spacemacs is a user-friendly starter configuration. It includes common packages for writing Lisp. If you have any problem, you can always ask on the Spacemacs chatroom. When you first start Spacemacs, you will see [?] button for the quick help. In there it contains basic key bindings for newbies as well as Evil (Vim) and Emacs tutorial. Pick one according to your style and spend an hour to learn it, then you will feel comfortable with Emacs."
lisp,368k50,tuhdo,1 point,Mon May 18 10:08:30 2015 UTC,"Or just go download http://www.lispworks.com/downloads/ for free, and save yoruself a lot of time to just get down to writing Lisp examples. Avoid #lisp on Freenode as it can be very anti-noob, and will just frustrate you to no end. #emacs is a great resource however if you choose to go that route. This version of lispworks is free, and has a full gui with all the knobs without requiring all of the above to just write code. Then, once you feel you like it, there is always emacs+slime"
lisp,368k50,sickofthisshit,1 point,Tue May 19 16:39:11 2015 UTC,"I don't think it's really appealing since:   There is a time limit of 5 hours for each session, after which LispWorks Personal exits, possibly without saving your work or performing cleanups such as removing temporary files. You are warned after 4 hours of use.   Someone is enjoying Practical Common Lisp and suddenly it prevents you learning instead of helping.   Avoid #lisp on Freenode as it can be very anti-noob   I agree and a newbie should avoid comp.lang.lisp as well."
lisp,3607vw,xieyuheng,3,Fri May 15 00:07:50 2015 UTC,"I think it is Lisp flavoured C++, not C.  See also: L++ | https://bitbucket.org/ktg/l  L++ is a programming language that transcompiles to C++. It uses Lisp-like syntax."
lisp,3607vw,steloflute,1 point,Fri May 15 06:03:14 2015 UTC,"It's also 150 lines of code, including comments."
lisp,35ttyk,mconte737,9,Wed May 13 13:34:53 2015 UTC,I found the Scope and Extent chapter of CLtL2 helped me understand it. It provides definitions and examples.  A lot of practice will help you master it.
lisp,35ttyk,xach,1 point,Wed May 13 19:35:06 2015 UTC,I agree. It was very clarifying for me too when I read it. It is also useful to think about variables in other languages.
lisp,35ttyk,davazp,6,Wed May 13 21:38:47 2015 UTC,"Mostly you want lexicals.  Mutable (changeable) variables are tricky if you don't know their scope - i.e. which bits of the program can update them.  Lexical variables have their scope laid out directly in the program source. You can see where the parens which close their scope is.  The scope of dynamic variables depends on which functions call which other functions. They are therefore, in general, harder to think about.  All that said - dynamic variables have their uses. They are essentially ""context"". Linguistically, you and I might realise that we are in a conversation about the president of the US, so when we say ""he"" we understand who we're talking about. The context is important.  A dynamic variable is like saying ""he"" - the same sentence might mean two different things depending on what the 'current' meaning of 'he' is."
lisp,35ttyk,jbert,3,Wed May 13 21:35:32 2015 UTC,"Here's two very simple examples:  ;; lexical (let ((x 8))   (funcall (let ((x 5)) (lambda () x))))  ; => 5  ;; dynamic (let ((x 8))   (declare (special x))   (funcall (let ((x 5)) (declare (special x)) (lambda () x))))  ; => 8   In the lexical example, the variable x retains the value from the closest enclosing let in its definition (which is 5). Even though x is redefined later on, it is still 5 because the x outside of the function definition is a different x to the compiler.  In the dynamic example, the function returned from the inner let looks for the variable x as it exists in the current call stack.  So lexical scoping takes values from the nearest point from where they're defined, dynamic scoping takes the nearest value from where they are being run. Both have their uses, but lexical is the default (and for good reason). You can do cool things with lexical scoping you can't do with dynamic:  (defun make-counter ()   (let ((x 0))     (lambda () (incf x))))  (let ((my-counter (make-counter)))   (funcall my-counter)  ; => 1   (funcall my-counter)  ; => 2   (funcall my-counter)) ; => 3 ...   So notice that the function returned from make-counter retains its reference to x even after the stack has unwound outside of make-counter and the lambda is returned. Congratulations, you just made a rudimentary class with a private member and a public interface function =]. Only when my-counter is no longer referenced will both it and x be garbage collected.  Hope that helps. As an aside, if you're familiar with Javascript, that is also lexically scoped so you can expect many of the same behaviors when using CL."
lisp,35ttyk,orthecreedence,2,Thu May 14 01:09:29 2015 UTC,http://www.flownet.com/ron/specials.pdf
lisp,35ttyk,lisper,1 point,Sat May 16 17:07:26 2015 UTC,dynamically scoped variables (special variables) in common lisp have global scope. They are available everywhere.    lexically scoped variables (normal variables) in common lisp have lexical scope - they are available locally within the structures that defined them.  The vast majority of variables you will use in lisp are lexically scoped. That's the default.
lisp,35ttyk,Choralone,1 point,Thu May 14 00:51:24 2015 UTC,"If this confuses you more, completely ignore what I'm saying; there's more than one way to reason about dynamic bindings.  Lexical bindings mean that the value is bound for anywhere within that block of code:  (funcall (let ((x 1)) (lambda () x))) => 1   Dynamic bindings could be 100% emulated by global variables and unwind-protect (the standard doesn't mention multi-threading).  It acts as if the value were globally set on entry to the block, and unset on exit from the block:  (defvar *x* 0) (funcall (let ((*x* 1)) (lambda () *x*))) => 0   This is functionally identical to (but probably isn't implemented as):  (defvar *x* 0) (funcall (unwind-protect (let* ((was-bound (boundp *x*))                                 (old-value (and was-bound *x*)))                            (setf *x* 1)                            (lambda () *x*))            (if was-bound              (setf *x* old-value)              (makunbound *x*))))   Note that some implementations do not work this way on multi-threaded; the standard is silent about threads, so each implementation can have dynamic bindings work differently on different implementations.  Note also that this means that dynamic bindings can interfere with tall-call-elimination, since what appears to be a tail-call might actually not be."
lisp,35ttyk,Aidenn0,1 point,Thu May 14 23:07:57 2015 UTC,"They are semi-globals. They can be ""modified"" for downward functions but will be restored to their previous value automatically, so you can tweak a global parameter, without messing up without parent or siblings computations.  I'm not even sure I'm half right, but that's the only way I understand them."
lisp,35ttyk,agumonkey,1 point,Fri May 15 16:35:41 2015 UTC,"You are correct. I wrote my package Srefactor mainly using dynamic variables to avoid passing parameters to help functions, since these functions has only noe purpose that is to serve this main function: srefactor--lisp-format-one-or-multi-lines . For example, this function is the helper for srefactor--lisp-format-one-or-multi-lines that uses the enclosed environment in srefactor--lisp-format-one-or-multi-lines. And this works recursively."
lisp,35ttyk,tuhdo,0,Fri May 15 17:08:10 2015 UTC,"Dynamic variables mean that if the variables are not found in current function stack frame, it searches the upper function stack frame until top level and if none found, error is thrown. For example, if you have a func-a that has let a let with variables and calls func-b, then func-b can happily use all the variables in the let defined by func-a, even if no variable is defined in func-b.  On the other hand, lexical scope does not allow this and simply throws error if it cannot find a variable in its current scope."
lisp,35tskg,rhabarba,1 point,Wed May 13 13:22:22 2015 UTC,I successfully registered yesterday. Have you seen that there are two anti-spambot fields?
lisp,35tskg,chuchana,1 point,Wed May 13 14:21:52 2015 UTC,"Yep, I did. The first one is easy, the second one is copy&paste."
lisp,35tskg,chuchana,2,Wed May 13 14:39:40 2015 UTC,"You pasted the whole tagline, not just the rest of it, right?"
lisp,35j57y,1hackaday,13,Sun May 10 21:52:59 2015 UTC,"Google to the rescue;  https://www.google.com/search?q=generate+tone+common+lisp  First result -   CLM (originally an acronym for Common Lisp Music) is a sound synthesis package in the Music V family. It provides much the same functionality as Stk, Csound, SuperCollider, PD, CMix, cmusic, and Arctic — a collection of functions that create and manipulate sounds   https://ccrma.stanford.edu/software/snd/snd/clm.html  There, eight different things that do what you want.  CLM itself looks pretty simple, it could easily do what you want.    Second Google result - a wiki page listing more  http://www.cliki.net/audio  Also - even if you install something complex, the way you use it can be as simple as you want it to be.  Don't write something off just because it can do a lot!"
lisp,35j57y,Lolor-arros,3,Mon May 11 01:11:56 2015 UTC,"Don't write something off just because it can do a lot!   It's one of the things I appreciate about the Lisp community that we do, in fact, generally benefit from being reminded of this."
lisp,35j57y,Probono_Bonobo,1 point,Mon May 11 08:56:44 2015 UTC,"This does not answer the question: CLM is not part of Quicklisp and, thus, it is not easy to install."
lisp,35j57y,Lolor-arros,1 point,Sun Jun 14 22:09:57 2015 UTC,"So write your own then, if you're not satisfied with any of those.  You might not have noticed the other names in my response - Stk, Csound, SuperCollider, PD, CMix, cmusic, and Arctic.  There are eight of them, eight different choices, including CLM.    Have you tried those yet?  I know you haven't even tried CLM, because you don't want to try installing it.  So give the other seven a shot."
lisp,35j57y,dasuxullebt,2,Mon Jun 15 14:14:15 2015 UTC,https://uxul.wordpress.com/2008/06/02/ein-paar-wege-den-pc-zum-piepen-zu-bringen/
lisp,35j57y,andyhefner,2,Mon May 11 19:24:04 2015 UTC,"Use the MIDI library (http://www.cliki.net/midi) to generate a .mid file, play it with timidity or similar."
lisp,35j57y,WarWeasle,2,Mon May 11 21:19:45 2015 UTC,There's even CL-SDL2 with CL-SDL2 mixer.
lisp,35j57y,Baggers_,2,Mon May 11 04:49:20 2015 UTC,How would that allow 1hackaday to play a single note?
lisp,35i62w,martinkal82,2,Sun May 10 16:46:38 2015 UTC,Does this really require a brand new Lisp interpreter?
lisp,35i62w,redditsuxass,1 point,Tue May 12 02:12:02 2015 UTC,No it doesn't. It's not an easy task and it would be much simpler to redirect requests to an existing interpreter. But I simply like to write one. Maybe I offer to choose beween interpreters in the future.
lisp,35i62w,redditsuxass,1 point,Tue May 12 04:55:17 2015 UTC,I see. Good luck with your project.
lisp,35i62w,Combinatorilliance,1 point,Tue May 12 05:23:25 2015 UTC,The link's dead ;/
lisp,35i62w,guicho271828,2,Mon May 11 16:12:17 2015 UTC,Thanks for the info. It is online again. Someone crashed my server :-/. I like to run a request in a separate process in the future. At the moment it is only a thread. A bit dangerous.
lisp,35i62w,vityok,1 point,Mon May 11 17:37:37 2015 UTC,adujucational = educational?
lisp,35i62w,Choralone,1 point,Mon May 11 16:27:03 2015 UTC,Sorry. I'm not a native speaker. And thanks for the info. Is there a way to correct it?
lisp,35i62w,drewc,1 point,Mon May 11 17:49:36 2015 UTC,"IIRC reddit link titles can not be modified after they are posted. So, no."
lisp,35i62w,drewc,1 point,Tue May 12 12:37:43 2015 UTC,Currently I'm using my old PC as server but it's not working properly. It crashes from time to time. I have to buy a new one.
lisp,35d2ut,xelxebar,9,Sat May 9 03:36:39 2015 UTC,I already commented on /r/haskell here:  http://www.reddit.com/r/haskell/comments/35bybo/lispers_of_haskell_whats_your_experience_using/cr3ez97
lisp,35d2ut,yogsototh,2,Sat May 9 08:02:23 2015 UTC,Thanks!  I forgot to mention the x-post. Edited!
lisp,35d2ut,killerstorm,5,Sun May 10 09:07:21 2015 UTC,"i have ~7 years of CL programming experience, but only ~3 months of Haskell, so this might be not a fair comparison, but still...  What I like about Haskell is its type system and type inference. Compile-time type checking helps one to organize thoughts and to avoid mess; and thanks to type inference, it doesn't get in a way.  Also Haskell's syntax is great for functional programming style, and so I'd prefer it for projects which are complex and can be naturally written in functional style.  But I noticed that when one needs to combine several monads, Haskell code can get ugly, as one needs to sprinkle lift*, do and return all over the code. Also I noticed that there is a plenty of language extensions which are commonly used (which implies that without these extensions core language is kinda deficient) and there is a ""DLL hell"" sort of a problem: to compile a latest version of some app or library you also need recent versions of other libraries, which usually require a recent version of GHC.  E.g. I have Debian 7, which was released only 2 years ago, and it comes with GHC 7.4. That's really old by Haskell's standards, I can't run modern stuff. And the Haskell Platform which haskell.org recommends doesn't run on Debian 7 either. (OK I just checked it and it looks like Haskell Platform recently got out of fashion, good.)  In this respect I'm much more comfortable with Common Lisp which didn't change for the last ~25 years.   So anyway, in my opinion, neither Lisp nor Haskell is perfect. I'd like to see a language which combines their features: static typing, algebraic data types, expressive syntax for functional programming, but also an easier way to do IO and state, and macros."
lisp,35d2ut,killerstorm,1 point,Sun May 10 19:53:55 2015 UTC,Thank you! Very helpful.  What kinds of projects have you worked on in each language?
lisp,35d2ut,nikofeyn,3,Sun May 10 20:55:55 2015 UTC,"I did a lot of different things in CL, ranging from web programming to machine learning and signal processing research.  As for Haskell, my experience is rather limited. The biggest one I did was a strange kind of statistical analysis/prediction, which involved generating huge-ass Excel files.  Currently I'm using Haskell for cryptocurrency research, our goal is to describe non-trivial cryptocurrency logic in Haskell and plug it into an existing wallet implemented in JS, so that it will work on all platforms."
lisp,35d2ut,killerstorm,1 point,Sun May 10 21:43:52 2015 UTC,Thanks. Sounds like you have been around the block a few times with CL.
lisp,35d2ut,nikofeyn,1 point,Mon May 11 03:02:49 2015 UTC,"I'd like to see a language which combines their features: static typing, algebraic data types, expressive syntax for functional programming, but also an easier way to do IO and state, and macros.   how do you think F# holds up to these? to me, it is the most real-world multi-paradigm language available."
lisp,35d2ut,pharpend,1 point,Sun May 17 04:42:14 2015 UTC,"Yea, I guess what I described sounds like ML, but I haven't had a chance to try it out yet... I looked at Caml at one time, but syntax was really off-putting."
lisp,35d2ut,pharpend,1 point,Sun May 17 06:49:44 2015 UTC,"you summarized a lot of what i think about haskell. i tried learning haskell but got frustrated with the lack of beginner-friendly and documented packages and never got to monadic haskell. and i echo your opinion of all these higher-level extensions floating around that cloud what seems to be a very nice, simple, and elegant base language. i think haskell has the best core syntax of any language i've seen. i really like how it does type annotations.  anyway, i have moved to f# for my functional programming needs, and i like it. i am still very much a learner though. it has the flexibility that haskell doesn't. it's syntax is a bit uglier, as there are ""let"" declarations absolutely everywhere. and the type annotation isn't as nice.  as an end note, i just started learning lisp using land of lisp this weekend. are there professional opportunities for lisp still out there? as a mathematician and now a systems/software engineer, i have became more and more interesting in AI and complex systems as of late."
lisp,35d2ut,aerique,17,Sun May 17 07:27:53 2015 UTC,"I'm somewhat experienced in both. I hate to say it, but Haskell is better in pretty much every field.  It is late in America, and I am very tired, so my responses may or may not make sense.  Going through your questions:   Projects: Haskell is a much more well-designed language, so I find myself using it for pretty much everything. Templating: Lisp wins in this department. Haskell doesn't really have anything equivalent to macros. There is TemplateHaskell, but that's not very fun. Debugging: Haskell wins by a long shot. Haskell's strong type system means that most bugs are caught at compile-time. You'll spend much less time hunting down bugs, and more time coding.  Haskell's REPL, GHCi, is pretty nice. There's apparently a nice debugger, although I've never felt the need to use it. Libraries: Not significant. Community: Meh, both are pretty good.  I like the Haskell community a lot. #haskell on FreeNode is one of the highest-quality IRC channels you'll happen upon. Workflow: I spend a lot less time debugging in Haskell, because of the aforementioned ""once it compiles, it probably works"" thing.  Haskell's Emacs support is pretty good, although not as good as Lisp's. There's structured-haskell-mode and hindent, which try to mimic paredit's functionality. Things like [projectile][3] and [Helm][4] will help you more than anything else.  Haskell's packaging tool, cabal, is very poorly written, but supports sandboxing and integration with the REPL. A lot of your Haskell time will be spent fighting with cabal, until someone gets around to writing a replacement. Readability: Haskell is great, provided you stay away from infix operators. Most people use infix operators, so reading other people's code sometimes isn't fun. Lisp wins in this department, but not by much. Collaboration: They are both pretty good.  Haskell intrinsically values ""code correctness"" a lot more than Lisp. This is reflected in collaboration. Lisp programmers seem to rely on common sense, where Haskell programmers rely on math.  For instance, a while ago, I sent a PR to Haskell's time library. As it stood, you couldn't take two ZonedTime objects, and order them. The first PR I sent was rejected because I made a dumb logical error. I fixed that and sent back a second one, and it was rejected.  8:00 Pacific time is 9:00 mountain time. Common sense would indicate that if compare these ZonedTime objects, you'll get back Eq. However, algebra would indicate that you would get back NotEq, because both the time and the time zone are different.  My PR included the common-sense definition of equality, and was rejected in favor of the algebraic definition. A lisper would probably say those are the same time. A Haskeller would not.  Although, in lisp, you would probably get back different answers for all 8 definitions of equality."
lisp,35d2ut,redditsuxass,9,Sat May 9 04:07:37 2015 UTC,"The one big thing about Haskell that puts me off from getting started with it is the syntax. The core language ideas are nice and interesting, but I just have to get over the syntax before I can make progress with the language."
lisp,35d2ut,Someuser77,4,Sat May 9 07:20:27 2015 UTC,The syntax is really tricky at first. I blame it on infix operators.
lisp,35d2ut,Someuser77,4,Sat May 9 15:01:56 2015 UTC,"Agreed, I tried to get into Haskell. Did some tutorials and tried starting my own little project but the syntax seems batshit crazy coming from Lisp. It's like Perl but worse."
lisp,35d2ut,starfox863,-3,Sat May 9 19:33:04 2015 UTC,"This sentiment seems to be non-singular which I find surprising and sort of disappointing.  I thought the lisp community as a whole would consist of more folks able to look deeper and appreciate sharing concepts instead of just reiterating what seems alarmingly akin to religious tokens.  ""I tried traveling to Morocco once, but their fashion was just absolutely atrocious. Can't go there until I get over it."" Seriously, guys??  Lisp has so much more to offer than simply some abstactly beautiful syntax (which it does have)!  Homoiconicity is really a big deal and changes how we code. Let's discuss these kinds of issues in a way that really relates to Getting Things DoneTM.  How does working in a homoiconic language really affect your day to day work flow? When everything is an sexp, how is long term maintainability of code affected? Et hoc genus omne.  Please, for the sake of the community as a whole, let's engage in discussion of real issues?"
lisp,35d2ut,starfox863,5,Sun May 10 20:49:20 2015 UTC,"I fear you're being a bit idealistic. Sure, as an academic, the points that you have listed out make perfect sense. Most of us who are keen to try out new languages are working in the industry with whatever brand of poison we are lucky enough to be banded with. And learning a new language with the aim of applying it at work is quite a big undertaking. The smallest barrier to picking up a new language is the syntax, not the actual paradigms of the language. That's how we move forward and become competent in the core concepts of the language - a process that takes years.  Syntax does matter in my opinion. A few years back when I was evaluating dynamic languages, I found Python much easier for me to pick up instantly than Ruby (even though they're both very similar). It just made things easier for me. So we shouldn't not discuss syntax just because the language has so much more to offer. It's definitely subjective, and I merely listed out what works and doesn't work for me!   I think you should step down a bit from your slightly disturbing harangue, and realise that for a lot of people, practicality does trump idealism."
lisp,35d2ut,samlamamma,1 point,Mon May 11 04:04:59 2015 UTC,"Great. If you have developed ideas about how CL/Scheme/some othet lisp syntax affects productivity, code maintainability, etc. please share!  Apologies if my response came off as disparaging. Can we try our best to skirt opinion and share potentially transferable ideas and experience?"
lisp,35d2ut,cbrachyrhynchos,5,Mon May 11 09:26:14 2015 UTC,"My PR included the common-sense definition of equality, and was rejected in favor of the algebraic definition. A lisper would probably say those are the same time. A Haskeller would not.   That's silly. If times in different time zones have nothing to do with each other, how do Haskellers in different time zones manage to be in #haskell at the same time as each other? It doesn't sound like their time library is anything other than completely useless."
lisp,35d2ut,cbrachyrhynchos,2,Tue May 12 04:48:39 2015 UTC,"I learned Scheme, CL and Haskell all around the same time (1990-94). I love all three and have never used any of them in any production situation. I am teaching my son Racket, but I turn to Haskell for personal projects which aren't web-based. As far as I am concerned I would not really use a Lisp for any production project, although Clojure might be a reasonable possibility. I think I would prefer the more Haskell-esque Scala though (and indeed I do use Play in production but primarily with Java).  The bottom line is that there is (mostly) one Haskell and GHC is it. That makes things a bit more cohesive and the enhancements more direct. The big huge failing compared to Lisp is TemplateHaskell which is an atrocious mess, IMO. If only Haskell had s expressions. :)"
lisp,3579m8,xach,11,Thu May 7 18:16:18 2015 UTC,"Not a full solution, but having a ""transitional maintainer"" just to move the project to a GitHub, create a GitHub organization, clean up the old website a little, would help future contributors a lot."
lisp,3579m8,eudoxeea,5,Thu May 7 23:23:03 2015 UTC,A github repo would make it easier for potential contributors.
lisp,3579m8,alex_muscar,2,Fri May 8 07:19:10 2015 UTC,I strongly agree. Could xach do it?
lisp,3579m8,bitmadness,11,Wed Jun 3 00:54:57 2015 UTC,"I hope that someone is up to the task.  Clisp is the one implementation that's installed/installable everywhere (usually by default) and is also probably the easiest to pick up using from the command line. It's not particularly fast but for many scripting or learning purposes, that doesn't matter at all.  That's not to say it can't do real work as well. I've successfully run a lot of projects in clisp quite well that were built in CCL/SBCL. Yes, it's a bit slower, but if you can say ""This app runs in clisp"" then you've expanded your potential user base quite a bit instantly.  It's important this implementation sees progress because it's Common Lisp's hook into almost everybody's machine. From a strategic grow-the-community standpoint, it's a great trojan horse that we're just not leveraging."
lisp,3579m8,orthecreedence,9,Thu May 7 19:25:21 2015 UTC,"I just tried building clisp 2.49 on Debian 7, and it died on libsigsegv, libffcall, libreadline, and libncurses, respectively, without any warnings from ./configure about potential issues. clisp might have been easy to build at one time, but that reputation doesn't match up to reality for me much of the time."
lisp,3579m8,jakub_h,7,Thu May 7 19:55:49 2015 UTC,"Actually, it looks like Debian 7 has a clisp package that includes 2.49, and it doesn't pull in extra stuff like it once did. So that seems like a good option now."
lisp,3579m8,eudoxeea,5,Thu May 7 20:07:38 2015 UTC,"Too few people share your view of how it should be done, apparently, because no Common Lisp that I know of has taken that approach. CLISP is somewhat unusual by doing a large part in a C-like language and linking to a bunch of shared libraries for certain features. It's more common to provide GC, FFI, and some other stuff via a smallish C runtime, and to provide almost everything else (like the debugger, compiler, standard library, etc) via Common Lisp code."
lisp,3579m8,PuercoPop,1 point,Thu May 7 22:50:42 2015 UTC,"I'm wondering if it wouldn't be better to port CLISP's extra features into ECL, or at least their equivalents. The result ought to be largely the same, portability-wise. But I'm not sure right now what extra features CLISP actually has, besides the arbitrary precision floats which made me feel all warm and fuzzy about potentially doing sciencey code in it. ;)"
lisp,3579m8,eudoxeea,2,Fri May 8 00:27:54 2015 UTC,"The KEYBOARD module seems like it has potential, but I've never used it myself."
lisp,3579m8,eudoxeea,3,Fri May 8 23:02:12 2015 UTC,"libffi is how most programming language implementations define FFIs. I think libffcall is a CLISP-specific alternative written around the same time. An effort to move CLISP away from libffcal and towards libffi would be useful.  libreadline is ho w the REPL lets you move around your input with the cursor (And, curiously, why CLISP was GPL-licensed). You could take the SBCL approach, since most people use Lisp behind SLIME, rather than on the shell. As for ncurses, I'm not sure why that's needed."
lisp,3579m8,notakgboperative,4,Fri May 8 23:39:58 2015 UTC,interpreted languages    There is no such thing and most Common Lisp Implementations are compiled. Don't know about CLISP though.
lisp,3579m8,jakub_h,3,Thu May 7 22:59:45 2015 UTC,"I agree that readline et cetera should not be hard dependencies, but libffi is more than reasonable. If CFFI doesn't work on your implementation, a good chunk of the ecosystem doesn't work."
lisp,3579m8,Grue,2,Thu May 7 23:06:18 2015 UTC,"I think vendoring in a copy of the library would be reasonable, however, since it's used by so many other languages, chances are the user already has a copy (on Linux or OS X) and it can be dynamically linked.  I guess it's a question of how large the library is."
lisp,3579m8,vi111,7,Thu May 7 23:15:42 2015 UTC,"I've got a bit of LISP and decent C chops, but I'm mostly a JS dev. How can I get involved with maintenance?"
lisp,3579m8,losthalo7,2,Thu May 7 23:07:49 2015 UTC,"I looked at CLISP's source code once, and it was in this crazy weird preprocessed version of C that I'm not sure was even documented.  I'm wondering if, in today's world, an implementation efficiently compiling to JavaScript wouldn't be actually more suitable for the ""runs everywhere"" approach."
lisp,3579m8,vi111,2,Thu May 7 23:28:57 2015 UTC,"One of the biggest strengths of CLISP is its small executables. Not as important now as it used to be, but it's a pretty useful property."
lisp,357aiz,lisper,17,Thu May 7 18:23:01 2015 UTC,"I read Ron's blog post as being about how the classic Lisp style is about an interactive style of coding in which the programmer communicates in real time with a running program, teaching it how to do new things. His remarks about s-expressions explain that they've survived because they have some useful properties for that style of coding.  It seems like most commenters here have missed or glossed over the central point--the one about the interactive style of programming--and fixated on the same peripheral discussion of syntax that talk about Lisp so often seems to degenerate into.  Yes, it's true that s-expressions were never intended to be Lisp's actual surface syntax. It's also true that, once someone implemented them, they proved to be sticky because they are actually handy. They work well in a language designed for interactive programming. Partly that's because of the points Ron made in his post. Partly it's because of related points mmontone raised here--that s-expressions are conveniently self-delimiting chunks of meaning that are easy to work with in text editors.  These are peripheral matters, though. The central point is that traditional Lisp (and Smalltalk) coding is livecoding. The programmer is in a real-time conversation with the program, teaching it new skills and watching it perform them immediately, instantly.  Although there are vastly more programming languages to choose from than ever before, and although many of them are exploring interesting new ground in lots of areas, it seems like languages that embody that livecoding spirit are a smaller and smaller fraction of languages in use. That's too bad for those of us who prefer live conversation with our programs. I can't help but feel we're in danger of losing something valuable.  It's a spirit that I feel like is missing or attenuated even in some newer Lisps, and it seems like a crying shame that even Lisp itself would begin to lose this essential Lispiness.   I have a friend who is an accomplished programmer who has recently become interested in learning Lisp. He reports that what really switched on the light bulb for him was when I was describing the standard Common Lisp functions that enable you to change the definition of a class while a program is running, and have the reasonable expectation that the program--including all the existing instances of the class--will continue to work.   More specifically, the lightbulb moment was when I said to him: of course the programmer will sometimes want to change the class definitions; and of course he or she won't want to have to kill the program and restart it just because of that; and of course everything should be able to just keep working. Well, and of course Common Lisp recognizes that and is designed to handle all of it gracefully, because it's a language for people who want to work that way.  I really like a bunch of other languages, but I keep coming back to Lisp and Smalltalk because of this."
lisp,357aiz,mikelevins,2,Fri May 8 06:34:46 2015 UTC,"I liked this quote from the article:  It is worth noting that the reason the parens stick out so much in Lisp is not that Lisp has more parens than other programming languages, it's that Lisp as only one block delimiter (parens) and so the parens tend to stick out because there is nothing else.  Other languages have different block delimiters depending on the kind of block being delimited.  The C family, for example, has () for argument lists and sub-expressions, [] for arrays, {} for code blocks and dictionaries.  It also uses commas and semicolons as block delimiters.  If you compare apples and apples, Lisp usually has fewer block delimiters than C-like languages."
lisp,357aiz,lolhaibai,2,Sat May 9 20:56:08 2015 UTC,"... and then it becomes a cognitive burden on the programmer to figure out the right delimiter to put in depending on the context.   I kind of agree that s-expr is kind of minimal elements to represent hierarchy structures. However, having a pile of elements does not make comprehension easy. For typical lisp programers, they call upon indentations to help sort the elements. The reason I emphasize indentation is because they are important. Lisp programs without indentations are impossible to work with. Now if you use indentation, yet you still insist on parentheses, then you end up with duplicated functions and (typical) lisp is no longer so minimal any more, right? How about let programmer skip a couple level of parentheses where indentation are used? Of course, if we allow that, indentation become another set of delimiters and lisp is no longer so elementary anymore.  Back to OP's quote, try assess the real cognitive burden by removing all your indentations.  What I point out is the fact that lisp is workable purely due to the fact of employing multiple set of delimiters (paren and indentation), indentation not being in the official syntax just make that not obvious.  To assess cognitive burden, we should differentiate between short range and long range. For short range, when all the relative items fits in our working memory -- 7 +/- 2 items -- it is often easier to work with multiple delimiters, such as  3 + 5 * x + 6 * x^2   Turn it into s-expr equivalents, the parentheses become noises and add into cognitive burden and over-flow our work memory capacity. So at short range, syntax reduces cognitive burden. Currently the way we design programming language always insist global context free syntax. So all short range syntax spread to long range, that gives lisper the argument that lisp is easier to track. I think in principle, short range syntax should be always limited to short range (7+/-2) items, and beyond that, uniform indentation;  which will allow unlimited DSLs in a single program (yet with uniform simplistic long range syntax). At long range, we don't see syntaxes, all we see are semantic elements organized by containers.  EDIT: e.g. the quotation example in OP's post, if we limit the syntax to short range, then we can safely omit quotes in most situations where sorting out the semantic meaning is easy (even at compiler point of view). But if we insist on global syntax, then we need different quotation marks to ensure global safety, which forces the syntax onto long range cognition burden.   For long range cognitive tasks, we can't track all items any way, so we need hierarchy containers. But we still need track the delimiters at all time so the minimal the delimiter syntax, the better. So either uniform parentheses/braces or indentation. I prefer indentation, which is one element to track. All brackets/parentheses/braces have two elements to track and at long range is impossible for human to track. Even lispers agree which is why they rely on indentation to reduce long range cognitive burden.   [ oh the OP's quote is also misleading, even in Java, there is only one set of long range delimiters, curly braces. I don't remember any other. EDIT: but if we consider syntax beyond symbols, Java has classes and methods which can be argued as two sets of long range syntax (, which I agree are absolute cognitive burden). ]  EDIT: I am not arguing against lisp, but I am arguing against OP's view that it is the uniform syntax made lisp. I think it is the ability to create macro made lisp. If we think syntax beyond symbols but semantic meanings between words, then macros are essentially local syntax that user creates. So I think it is the ability for user to create proliferation of localized syntax made lisp."
lisp,357aiz,hzhou321,6,Thu May 7 18:53:50 2015 UTC,"Something about lisp that I think has to do with the parenthesis and I haven't experienced with any other language is that expressions between parenthesis are like self contained building blocks that I can compose, move around, refactor and evaluate. It is very easy to compose those building blocks because everything is an expression, and also lisp supports particularly well the concept of locality, both for variables (lexical variables), macros and functions (local functions) (let, flet, macrolet, ...). That helps with the ""self containment"" part. I imagine that without the parenthesis it would not be as easy as it is not obvious where an expression ends; with the parenthesis, that is explicit.  Also, I agree with the author of the article that having parenthesis and only parenthesis reduces the cognitive burden. At least, it works like that for me."
lisp,357aiz,mmontone,5,Fri May 8 04:41:40 2015 UTC,"It's why lisp + structural edition (even in a simple form like paredit) is such a bliss. That said, lisp forms aren't totally self-contained  (let ((x 1))      (+ x x))   You can't evaluate (+ x x) in isolation naively, you'd need a bit of free-variable aware logic to turn it into a lambda or walk the lexical scope to find bindings."
lisp,357aiz,agumonkey,8,Fri May 8 19:42:51 2015 UTC,"Without the regular syntax provided by s-exps, writing macro is insane complex and error prone. Consider the mathematical statement you provided: 3 + 5 * x + 6 * x2. As an s-exp, that would be (+ 3 (* 5 x) (* 6 (^ x 2))). Lets say we want to write a macro replaces the x with another expression. Using the text replacement macros offered in most non-lisp languages, the expression ""y + z"" will cause problems, transforming the infix version into 3 + 5 * y + z + 6 * y + z2 which is semantically different than what is intended. The s-exp of ""y + z"" is ""(+ y z)"", which can be inserted in place of x in the s-exp without causing any problems. Parenthesizing ""y+z"" does fix the problem in this case, but this is the simple possible example of the problem. Non-s-exp based syntax hide so much of their semantically burden in our previously learn natural languages skills that we don't see the problems it causes. Imagine writing a macro to extend C's switch statement to handle strings, without causing any side effects or leaking any internal details. I've written a macro do that in common lisp and it's only about 20 lines."
lisp,357aiz,arcangleous,1 point,Thu May 7 22:08:58 2015 UTC,See David Moon's Plot work for an example of how you could do a macro system with conventional syntax.
lisp,357aiz,xach,1 point,Fri May 8 01:23:30 2015 UTC,Plot look interesting and I will take a serious look at it.
lisp,357aiz,arcangleous,1 point,Fri May 8 01:45:37 2015 UTC,What about doing a macro system with something that looks like conventional syntax but isn't? Like a graphical presentation of the syntax tree?
lisp,357aiz,jakub_h,-4,Fri May 8 20:32:26 2015 UTC,"Precedence based expression parser is not particularly difficult. Imagine in the macro facility you have a function   ast = parse_expression(op_precedence_table, expr)   then you just had the ast type of macro power without s-expr.  In practice, I rarely create DSL syntax that require many precedence, often only need observe brackets and quotes, which I have   tlist = proper_split(line_of_code)   Even more practical, for most macros, regular expression is sufficient. If I need syntax spread over entire program, that is difficult to design. But for DSLs that lead by functor-like keyword (not much different from s-expr), arbitrary syntax with regex, proper_split, parse_expression covers all my needs."
lisp,357aiz,hzhou321,5,Thu May 7 22:39:29 2015 UTC,"Regular Expressions are useful for a certain subset of linguistic needs, but once you need to nest anything, you're kind of screwed because regular expressions cannot handle nested expressions.  The key idea that makes lisp macros a fundamentally different and powerful tool is that there is a one-to-one equivalence between the s-expression and the abstract syntax tree. Since the s-exp is just regular list, you don't need parse_expression or proper_split. The whole language's library is available for you to work with. A macro becomes just another function whose output is sent to the compiler instead of to your program directly."
lisp,357209,aol-zombie,3,Thu May 7 17:18:55 2015 UTC,"Who is the person and what is the product?  edit Oh, I think you're complaining because lispm uses and enjoys LispWorks. I do too. I also enjoy SBCL, Clozure CL, and other Common Lisp implementations.  Rainer Joswig has used all kinds of Lisp implementations for many, many years. I don't always agree with his opinions but I think he is a good moderator for /r/lisp. I think it's a little silly for an anonymous, one-day user to attack him for exercising moderation power."
lisp,357209,xach,9,Thu May 7 17:45:53 2015 UTC,"He is unhappy because I've deleted two of his messages (not to me).  The first: 'It's a pointless conversation. You aren't going to see the other side, and I'm too old, too tired, and too busy to argue with know-it-all 25-year-olds.'  The second: 'Surely you jest, kid.'  Then:   I'm sure this comment doesn't carry any weight, and will get deleted by the almighty ""lispm"": with  this level of ability to apply logic you have no business being in business. Please PM me your info so I make sure to never hire you in the future. E: lispm who clearly has a chip on his/hers shoulders: https://news.ycombinator.com/threads?id=lispm and who obviously works for LispWorks. What's your agenda, son? I'm going back to work on my boat and to enjoy my retirement — you go fight your inexistent fights.   I've asked him to stay friendly and polite. Response:   '""Polite and friendly"" isn't the same as ""someone who agrees with me and the product I'm peddling"", hon.'   'aol-zombie' is an account active for one day.  Personally I have enough of trolls, spammers, ... and I prefer not to see this turned into another comp.lang.lisp ."
lisp,357209,lispm,5,Thu May 7 17:51:06 2015 UTC,What a maroon.
lisp,350b6x,agumonkey,3,Wed May 6 01:14:04 2015 UTC,I'm familiar with lilypond. How would you compare the two?
lisp,350b6x,bemrys,1 point,Wed May 6 19:15:32 2015 UTC,not as pretty but smaller learning curve
lisp,350b6x,DanielFGray,1 point,Thu May 7 07:38:09 2015 UTC,""" Although I put a lot of effort into making the output legible, it really isn't aimed at producing publishable scores. If you need beautiful output, use Lilypond, Score or Finale.""  -- https://ccrma.stanford.edu/software/cmn/cmn/cmn.html"
lisp,350b6x,drewc,1 point,Fri May 8 18:21:54 2015 UTC,"Yes, I did read that line about the final output. I was thinking about any other comparisons - ease of use, learning curve, was there something that the author was trying to achieve that caused him to recreate the wheel and was that achieved?"
lisp,350b6x,bemrys,1 point,Fri May 8 20:27:42 2015 UTC,"this is /r/lisp .... ""cmn is intended as an adjunct to Heinrich Taube's Common Music and my CLM"".  ""Common Lisp Music is a music synthesis and signal processing package in the Music V family. "" -- https://ccrma.stanford.edu/software/clm/  In other words, syntax."
lisp,350b6x,drewc,3,Fri May 8 21:59:38 2015 UTC,I wrote it more than 20 years ago.  At that time there weren't any decent free music notation programs.
lisp,350b6x,schottstaedt,2,Sat May 9 17:12:38 2015 UTC,Is it still relevant today ? are you still working in this field ?
lisp,350b6x,schottstaedt,3,Sat May 9 17:52:06 2015 UTC,"maybe; somewhere in my infinite TODO list is the line ""translate cmn to scheme""; another is ""make it possible to select a section and move it, with everything else adjusting at the same time"".  When I wrote it, we had 68040-based NeXT's with ACL (which came for free on that machine); a batch-process was about all you could hope for.  I made one big mistake (I realize in retrospect): heavy use of CLOS."
lisp,350b6x,PuercoPop,1 point,Sat May 9 18:28:33 2015 UTC,Could you expand on why do you consider heavy use of CLOS a mistake?
lisp,350b6x,schottstaedt,2,Sun May 10 01:54:07 2015 UTC,"I hesitate to say anything; it was years ago, and the CL community has become much less collegial.  I'd say that CLOS is over-engineered; it has a medieval obsession with heirarchy and names that leads to rigid, opaque code; whenever I look at that code, my heart sinks. I'm trying a slightly different approach in s7, and translating cmn would be a great test ot it. If only I had two lives."
lisp,350b6x,PuercoPop,1 point,Sun May 10 15:15:37 2015 UTC,"""We can have as many lives as we want, as long as we can""   Anyhow thanks for your honest response."
lisp,350b6x,bemrys,1 point,Mon May 11 00:01:39 2015 UTC,Sorry that you feel the community has become much less collegial. Maybe due to the ossification of the standard.
lisp,3508kn,eudoxeea,5,Wed May 6 00:52:01 2015 UTC,Very cool. I was faced with rolling my own and putting off a project because of it. Thanks for saving me the trouble!
lisp,34y7z9,xach,7,Tue May 5 15:31:38 2015 UTC,I'm intrigued by the Hobbyist editions.
lisp,34y7z9,orpheanjmp,3,Tue May 5 15:31:53 2015 UTC,"Very happy they did this.  I've been hoping they would do this for years and the response I always got on various forii (and on here) that thousands of dollars was just your typical hobby purchase and gut up.  Well perhaps for Moneybags McCarthy Jr, Hobby Lisper Extraordinaire, but certainly not for me.  $750 isn't cheap but its within the realm of reason for me at least."
lisp,34y7z9,furych,2,Tue May 5 23:19:36 2015 UTC,"The price for Hobbyist edition comparable with Wolfram Mathematica Home Edition, MATLAB Home or IntelliJ IDEA Personal; however it doesn't deliver even a fraction of goodies of these systems. So it looks like it is really for the List enthusiasts."
lisp,34y7z9,lispm,6,Tue May 5 18:49:56 2015 UTC,"With LispWorks you can implement something like Mathematica completely in Lisp. With Mathematica you can't implement LispWorks. Mathematica is a relatively specialized high-level language for math related stuff with an environment for that. The implementation technology of its language is relatively primitive. Thus much of the Mathematica environment is implemented in C++.  if you look at the manuals of LispWorks, you will detect that it has an extremely wide range of capabilities. It's IMHO the best implementation of a dynamic language. As such you can implement a lot of things directly in Lisp, where one usually would need C++ or maybe Java."
lisp,34y7z9,mikeivanov,1 point,Tue May 5 19:18:02 2015 UTC,"But is that what a typical ""hobbyist"" needs? How many hobbyists are there that buy Mathematica or MATLAB?"
lisp,34y7z9,lispm,2,Tue May 5 19:41:43 2015 UTC,I have no idea what a typical Lisp hobbyist needs. Mathematica or Matlab are in a very different market.
lisp,34y7z9,mikeivanov,1 point,Tue May 5 19:50:43 2015 UTC,"Then why call it ""Hobbyist Edition""?"
lisp,34y7z9,lispm,3,Tue May 5 20:18:02 2015 UTC,Because it is for hobbyists?
lisp,34y7z9,mikeivanov,2,Tue May 5 20:28:55 2015 UTC,"I consider myself a hobbyist, and I can't afford it. Neither can any of my fellow hobbyist I could remember. That is not a LispWorks problem, of course, but I'm not sure who is the market for this product.  Look, if I owned a startup or say my employer needed a lisp this price tag would not be a problem. But when you say ""hobbyist"", it all of a sudden turns into an obstacle. It's not justifiable. Not to me, at least, sorry :-)"
lisp,34y7z9,lispm,6,Tue May 5 20:37:47 2015 UTC,"There are lots of people who can afford that. An iPhone costs more. There are more expensive sneakers. Many bicycles cost more.  There will always be people who can afford it (or will be able save money for it) and some who don't.  But, hey, Common Lisp has other implementations which don't cost anything."
lisp,34y7z9,PuercoPop,2,Tue May 5 20:44:35 2015 UTC,It is for non-academic non-commercial use. Hobbyist seems a fitting description. Maybe amateur would be better :D
lisp,34y7z9,furych,0,Tue May 5 22:52:23 2015 UTC,"I bought both MATLAB Home and Mathematica Home. Matlab I used to implement any prototyping around my fields of interests in numeric methods (I don't publish anything so it is hobby usage), which I later rewrite in C, while Mathematica I use for anything else - drawing graphs, experimenting with formulas, exploring weird ideas (since I have an access to anything from Mathematica - from SQL to Wikipedia), personal finances, etc. All with nice interface and tons of documentation. However trying to find an idea how could could I justify to spent 400Euro for a LispWorks Hobbyist, just to get rid of 5-hours limitation of the Personal edition.."
lisp,34y7z9,lispm,2,Tue May 5 21:13:52 2015 UTC,"The hobbyist edition also has no heap size limit, it can save and start images of the Lisp state, can load patches and loads init files upon start.  None of that above is in the Personal Edition, which also only runs for five our sessions."
lisp,34y7z9,cbrachyrhynchos,1 point,Tue May 5 21:25:43 2015 UTC,"Also, Hobbyist comes in 64 bit, and Personal is a version behind."
lisp,34y7z9,lispm,1 point,Tue May 5 22:45:31 2015 UTC,a newer Personal Version usually appears a bit later.
lisp,34y7z9,furych,1 point,Wed May 6 03:39:33 2015 UTC,64bit Hobbyist costs 1.5 times the 32bit...
lisp,34y7z9,Someuser77,2,Wed May 6 19:33:01 2015 UTC,"I was going to make the same exact comment.  $3000 for the commercial version (64-bit Mac) vs $750 for hobbyist. Hm. As I recall, Mathematica was about $2,000 commercial and $200 home user. I never bought Mathematica and only play with it, but I did buy the academic version and later the home version and always keep it upgraded (usually $100 for the upgrade).  I would definitely pay $100-200 for this hobbyist version, but not $750. In the end, I won't even bother to look at their free personal version as the price for any unrestricted version of LispWorks is beyond me. Also, the lack of SQL support seems like a silly omission. What application doesn't use SQL these days? The CLIM omission is also a little strange.   I also use IntelliJ for my ""real work"" and that pricing is not offensive."
lisp,34y7z9,lispm,1 point,Sat May 9 19:46:50 2015 UTC,"The standard version of Mathematica costs $2495 or $995 per year. 8 core. 'Enterprise' $6995. 16 core.   Can I develop an application with it and ship that?   'Wolfram products are usually licensed to be installed on a specific machine—moving the software to a new computer requires an update to your license.'  'undertake a System Transfer only if Your Mathematica service level permits the transfer; You contact WRI Customer Service and, at its direction, complete and submit a System Transfer Form; and You pay any license cost difference or applicable transfer fee;'   Oh oh... I have to transfer the license, if I want to use it on another machine...  LispWorks is a pretty good deal compared to that. Not licensed for a particular machine. No core limit. Free application delivery with the HobbyistDV, Professional and Enterprise version... That means you can develop an application with LispWorks and use it everywhere without paying royalties. With the Professional and Enterprise version you can sell LispWorks applications - again without paying royalties and without the need for a LispWorks license for the users.  Royalty-free application delivery is not possible with Mathematica.  LispWorks is cheaper for commercial users than Mathematica and has better licensing terms."
lisp,34y7z9,furych,2,Sat May 9 22:18:22 2015 UTC,"Just to not produce misinformation: I didn't have any problems transferring Mathematica Home license between 3 of my laptops. First time I did it 4 years ago and I asked to transfer the license in support, they helped me out. The old one was still working unless I ran 2 instances on 2 laptops simultaneously. Next time I did it few weeks ago and the matter was just to login to my account on their page and download/install the app. Again the old version is still working. So it is not true what the transfer of Mathematica to another machine is a pain. In contrast, I can't see the customer portal or something like this on LispWorks site. What if I loose my downloaded and paid version?  Also I would like to compare home/hobbyist licenses, the enterprise could cost whatever they want since it is not an ordinary people paying for them the hard-earned buck out of their pocket.   The Hobbyist version has 4 different price tags:   1) Hobbyist 32bit without application delivery - 400EUR.   2) Hobbyist 64bit without application delivery - 600EUR.  3) HobbyistDV 32bit with application delivery - 800EUR(!!!)  4) HobbyistDV 64bit with application delivery - 1200EUR(!!!)  The direct comparison could be made only between Hobbyist without application delivery and Mathematica Home, since it doesn't have application delivery as well. And therefore the advantage you are talking about the application delivery is vanished at this price level. For anything with the possibility to make a stand-alone executable and give it to your friends(which is the decisive advantage over Mathematica Home) you obliged to pay at least 800EUR  P.S. I'm not trying to be against this product, in contrast I'm thinking about making it my primary platform for hobby projects, but for me the ability to make stand-alone apps with UI is one of the decisive factors, and I need to justify the spending to the family, which is hard :)  P.S. Edit: corrected price for 64bit DV version, see original in the quotation below."
lisp,34y7z9,lispm,1 point,Sun May 10 11:21:36 2015 UTC,"I didn't have any problems transferring Mathematica Home license between 3 of my laptops   I didn't say you have problems. I did say that with LispWorks it is unnecessary. Completely.   First time I did it 4 years ago and I asked to transfer the license in support, they helped me out.   I don't want to talk to customer support, because I want to install it somewhere else. Not really.   In contrast, I can't see the customer portal or something like this on LispWorks site. What if I loose my downloaded and paid version?   Just download it again. You'll get a link with buying LispWorks.   The direct comparison could be made only between Hobbyist without application delivery and Mathematica Home, since it doesn't have application delivery as well  4) HobbyistDV 32bit with application delivery - 1200EUR(!!!)   4) HobbyistDV 64bit with application delivery - 1200EUR  With Mathematica I have no choice... Mathematica has no equivalent of a HobbyistDV version. It also has no equivalent of the Professional Version and the Enterprise version. I don't find it strange that someone wants to give an application she wrote to her friends.  Mathematica can't generate freely distributable applications.  Mathematica has some 'Player' license option, which costs almost $1000 for 5 instances... For a 'Player' for Mathematica Notebooks."
lisp,34y7z9,furych,2,Sun May 10 11:26:25 2015 UTC,You forgot to add 25% of VAT to these prices :(  However I think I'll give a Hobbyist edition a try anyway. Pay once cry once...
lisp,34y7z9,z27,1 point,Tue May 12 19:12:52 2015 UTC,Interesting. They are a little cheaper: http://www.lispworks.com/buy/prices-1h.html
lisp,34y7z9,mikeivanov,2,Tue May 5 17:38:05 2015 UTC,"Yes, but each platform is licensed separately. For a three-platform app that would amount to $1.5K+, which is.. not for messing around, for sure."
lisp,34y7z9,WalterGR,2,Tue May 5 19:36:19 2015 UTC,(n.b. Each platform is licensed separately for any edition: the hobbyist editions as well as the non-hobbyist editions.  (Which is not incompatible with what you wrote - I offer this simply in case anyone misinterprets.))
lisp,34y7z9,wicked-canid,1 point,Wed May 6 07:54:39 2015 UTC,Those are interesting prices indeed. Does anyone know why there is so much difference between the 32 bit and the 64 bit editions?
lisp,34y7z9,tarballs_are_good,4,Wed May 6 03:34:17 2015 UTC,32-bit ARM is big news.
lisp,34y7z9,cbrachyrhynchos,6,Tue May 5 17:57:47 2015 UTC,The feature-comparison table.
lisp,34y7z9,mikeivanov,9,Tue May 5 22:25:15 2015 UTC,"Hey LispWorks, $100 is what I'd pay right away. I know other people who feel the same. $500 is a bit too much."
lisp,34y7z9,lispm,6,Tue May 5 19:38:44 2015 UTC,"That there is no company offering such a product should give you a hint. A few have tried, but they are no longer with us..."
lisp,34y7z9,lispon,5,Tue May 5 19:52:48 2015 UTC,sbcl ftw
lisp,34y7z9,mikeivanov,2,Tue May 5 23:22:05 2015 UTC,"Well, mocl is still alive. 4 platforms, $200 flat price."
lisp,34y7z9,mikeivanov,7,Tue May 5 20:17:34 2015 UTC,"They are both Common Lisp, but they are very, very different in almost every other respect."
lisp,34y7z9,lispm,1 point,Tue May 5 20:23:11 2015 UTC,Touché.
lisp,34y7z9,aol-zombie,4,Tue May 5 20:38:49 2015 UTC,"mocl is basically a delivery tool for a CL subset, creating C code plus a runtime. Great for what it does, but very different from LispWorks."
lisp,34y7z9,v3m,1 point,Tue May 5 20:38:11 2015 UTC,A hint at what exactly? That charging an arm and a leg for something that is used by a fraction of a percent of the market isn't a good business model?
lisp,34y7z9,aol-zombie,4,Wed May 6 00:26:57 2015 UTC,Charging an arm and a leg for something that is used by a fraction of a percent of the market is the only possible sustainable business model for it.
lisp,34y7z9,v3m,-1,Wed May 6 05:14:50 2015 UTC,"No, it is not."
lisp,34y7z9,aol-zombie,1 point,Thu May 7 00:36:38 2015 UTC,How would you propose that they fund continued development of their product?
lisp,34y7z9,v3m,1 point,Thu May 7 01:07:28 2015 UTC,"Dropping the price and expanding the user base, for instance. Never occurred to you that there is more than one way to do business?"
lisp,34y7z9,v3m,1 point,Thu May 7 01:49:21 2015 UTC,"Look at Jetbrains - they charge $200-$500 for a license of a product that has a far, far higher potential userbase than is likely to be possible on a Lisp these days. If LispWorks was able to expand their userbase just by dropping the price, wouldn't you think you'd see a lot more usage of SBCL, say, or the other free CL distributions than there currently is?"
lisp,34y7z9,jakub_h,2,Thu May 7 02:20:19 2015 UTC,"Okay, sure. Feel free to point out the successful sustainable dev tools that require that much dev work for that small of a potential market that, y'know, exist if you want, though."
lisp,34y7z9,devslashnull,1 point,Thu May 7 02:26:45 2015 UTC,Today? That train has already left the station... Smalltalk and Lisp companies have killed their respective market prospects a loooong time ago. But that's entirely their fault.
lisp,34y7z9,WalterGR,4,Thu May 7 03:13:26 2015 UTC,"Enhanced unicode, ARM support, Android and IOS targets.  Sounds like a pretty substantial move forward.  Nice to see that the mobile targets are at no additional cost."
lisp,34y7z9,devslashnull,3,Fri May 8 23:16:28 2015 UTC,"Nice to see that the mobile targets are at no additional cost.   Well, LispWorks doesn't charge extra for each user of software developed with their tools, but targeting Android and iOS are $1,000 each - in addition to the price of the core IDE.  (Or in other words, they don't charge for runtime licenses but you have to pay for each mobile runtime license. Clear as mud.)  http://www.lispworks.com/buy/prices-lw4mr-1c.html: ""You also need to have a license for LispWorks 7.0.""  EDIT: It also looks like the mobile runtime licenses are annual, whereas I don't think the non-mobile licenses expire."
lisp,34y7z9,jakub_h,2,Tue May 5 23:51:36 2015 UTC,"Ahh you are right, I missed that one when I read the release notes.  Well thats a little disappointing."
lisp,34y7z9,eudoxeea,1 point,Wed May 6 07:50:57 2015 UTC,"It sounds like something that will be of great use to software companies selling Lisp-based business solutions so that they could generate mobile clients for their apps with the same codebase, but otherwise..."
lisp,34y7z9,lispm,2,Wed May 6 23:53:01 2015 UTC,I wonder if adding Japanese support to the editor was prompted by consumer demand.
lisp,34y7z9,fjames86,0,Fri May 8 23:21:39 2015 UTC,"The editor already supported Japanese, IIRC. It's just that they now support a wider range of Unicode than before."
lisp,34y7z9,TheSmoke,1 point,Tue May 5 19:08:44 2015 UTC,"I'm interested in seeing how the new UDP socket support is. My experience of UDP networking with LispWorks on Windows has not been great, but I guess that's partly because the usocket devs have had to roll their own LispWorks backend."
lisp,34y7z9,shizzy0,1 point,Tue May 5 19:28:01 2015 UTC,hi all. why would i choose lispworks over racket? what are the advantages and disadvantages of this and racket? i'd appreciate it if anyone would help.
lisp,34y7z9,cbrachyrhynchos,11,Wed May 6 18:06:50 2015 UTC,One reason: you know and like Common Lisp.
lisp,34xm7z,lispm,2,Tue May 5 12:18:40 2015 UTC,"Cool idea, although the animations a bit too fast for me. Also, shift + 0 is not unambiguously ), (for example, I have ( and ] swapped).  Does anyone use all these? For the record, 7 commands are not in my current roster. I see a use for 4-6 of them."
lisp,34xm7z,mega,1 point,Tue May 5 13:15:28 2015 UTC,Emacsrocks also have a pretty good demo of this  http://emacsrocks.com/e14.html
lisp,34xm7z,davazp,1 point,Tue May 5 17:18:47 2015 UTC,I recently had some weirdness with slurping forward: it never seemed to want to do it. This confirms that I was doing it right. :/
lisp,34xm7z,ChiefEmann,1 point,Wed May 6 08:59:36 2015 UTC,"If your window manager supports a Super modifier, I find it very useful to bind the Paredit keys (and other sexp-editing keys) with an s- prefix:   (global-set-key (kbd ""s-u"") 'paredit-backward-up) (global-set-key (kbd ""s-k"") 'kill-sexp)   And so forth. It's more ergonomic, it can't conflict with any window manager keybindings, and you can take advantage of Paredit anywhere."
lisp,34y8p0,self,9,Tue May 5 15:37:15 2015 UTC,"Go with ClozureCL - it has native threads support on RPi, and SBCL currently does not. The speed difference is noticeable.  I wrote a blog post recently on my experiences with setting up CL on RPi2."
lisp,34y8p0,TeMPOraL_PL,3,Tue May 5 19:36:51 2015 UTC,Clozure CL
lisp,34y8p0,tarballs_are_good,1 point,Tue May 5 17:59:20 2015 UTC,"For folks who have done this -- what kind of performance / speed have you seen from the RPi running SBCL / CCL / etc?  In other words, not thinking about handling a huge load, but if you're say, running Hunchentoot and a DB (ie. postgresql) on it, do you get reasonable response times?"
lisp,34y8p0,BMarkmann,1 point,Thu May 7 18:46:45 2015 UTC,"I was able to compile both SBCL and Clozure CL, both worked just fine, both consumed all available memory (Model A, 256G) right after loading Swank and Quicklisp. ECL is next to try."
lisp,34y8p0,mikeivanov,3,Fri May 8 21:38:22 2015 UTC,The Pi 2 probably won't run into that -- 1 GB of RAM. I might find the time to try ccl today; will report back.
lisp,34y8p0,mikeivanov,2,Sat May 9 04:50:40 2015 UTC,"Please do, I'm very interested."
lisp,34y8p0,maufdez,3,Sat May 9 05:49:13 2015 UTC,"I followed /u/TeMPOraL_PL's instructions for CCL, and it was a breeze.  I had to rebuild the kernel for the Pi 2, but with a make -j 4, it only took about 30 seconds.  (I'd never done it before, so I was dreading that it would take forever, like sbcl does.)  I installed quicklisp, and I noticed that it slowed down CCL's startup time by a large amount -- something I hadn't noticed on other platforms.  Doing ccl -e '(quit)' takes 0.07 seconds without quicklisp, and 14 seconds with.  Apart from that, no real worries.  It used no more than 30 MB RAM (res) to do (ql:quickload ""swank"") to install it."
lisp,34y8p0,combinatorylogic,1 point,Sat May 9 19:19:06 2015 UTC,"Have you tried creating a bundle, with only what you need, it might be better than loading Quicklisp, I think, if I understand well how bundles work."
lisp,34y8p0,lispm,1 point,Sun May 10 01:15:49 2015 UTC,sbcl works ok
lisp,34urnn,lispm,9,Mon May 4 19:00:22 2015 UTC,"lang users    php 36k   js 60k   python 90k   perl 9k    Not bad, let's keep growing."
lisp,34urnn,agumonkey,2,Tue May 5 00:46:45 2015 UTC,"I'm really surprised perl has so few subs.  And it's not like perl users don't need help.  I know I did when I used it.  However, perhaps there are enough resources out there that many don't seek out a subreddit."
lisp,34urnn,e40,7,Tue May 5 02:02:39 2015 UTC,"I would put money on perl users tending to be older, and reddit users tending to be younger, so the cross-section of perl users who also use reddit being pretty small."
lisp,34urnn,zck,3,Tue May 5 03:39:31 2015 UTC,"I think so, old mailing lists and boards are full of quality help, reddit seems unnecessary for perlists. It's not surprising, to my understanding, Perl was always off the mainstream, they had everything set up their own way (packages, OOP, etc, etc) but noone knew."
lisp,34urnn,agumonkey,6,Tue May 5 02:08:47 2015 UTC,Here's to the next 10K!
lisp,34urnn,orthecreedence,4,Mon May 4 19:10:55 2015 UTC,Woo!
lisp,34urnn,ZandalarZandali,8,Mon May 4 20:56:48 2015 UTC,Woo?
lisp,34urnn,eudoxeea,1 point,Mon May 4 22:15:14 2015 UTC,"Funny, I just joined a few days ago! I don't really know anything about lisp (I use Python almost exclusively, though I've also used Java) but I am really intrigued by the idea of macros."
lisp,34urnn,CATHOLIC_EXTREMIST,2,Tue May 5 07:10:32 2015 UTC,"The example I like to give when talking about the power of lisp macros to non-lisp programmers is as follows:  Imagine for a moment a program using functions returning numeric (integer) values to drive core logic, where which branch executes depends on the return value being positive, negative, or zero. This is easily done with two if-else statements (curly braces indicate code clauses not important to the example, syntax is in my personal pseudo-code format):  x = somefunction(); if x > 0:     {positive-things} else if x < 0:     {negative-things} else     {was-zero-things};   However, the program would perhaps be easier to read (using fewer temporary variables, at least) in a language which supported a ""sign conditional"" instead:  signof somefunction():     positive:         {positive-things}     negative:         {negative-things}     zero:         {was-zero-things};   If you were to implement this yourself, not only must only the required clause be executed, you would like to try and have your new statement's grammar match the rest of the language's general syntax. Also, each of the clauses are optional (as long as there are at least one). Can it be done with a single macro? (Yes, with lisp macros. No, for most other languages.)"
lisp,34urnn,akrumbach,1 point,Tue May 5 12:37:40 2015 UTC,Have you seen macropy?
lisp,34urnn,PuercoPop,1 point,Tue May 5 14:04:45 2015 UTC,"No, see Hy, the lispy python (or pythonic lisp) ! http://docs.hylang.org/en/latest/"
lisp,34vsyo,yogthos,5,Mon May 4 23:44:59 2015 UTC,"Some of this reminds me of my thesis, on Boxer, a visual programming language.  http://klotz.me/thesis.pdf"
lisp,34vsyo,klotz,3,Tue May 5 05:36:05 2015 UTC,"Slightly more info is helpful to let people know whether to click through.   Boxer is an integrated computing environment for naïve computer users. It supports “what you see is what. you have” both in the editor and in the semantics of the language: objects behave as if they are their screen representations. This constraint and related guiding principles place strong demands on the implementation.  This thesis describes the design and implementation of the programming language for Boxer, with particular emphasis on the efficient solutions to problems imposed by the design constraints.  It also discusses the principles underlying the programming language, the resulting programming model, and its evolution.  Boxer has been implemented in Common Lisp on Symbolics 3600, Sun, and Hewlett-Packard computers.   I used to be a huge fan of visual programming languages, back when they were rare. Once I found that they do not give programmers a huge productivity boost, my enthusiasm dropped down to regarding them as useful in niches -- like the Lego Mindstorm Robotics language, or pedagogical in general like MIT's Scratch.  During the same period of time the digital hardware side of the industry largely switched from graphical schematics to text based Hardware Description Languages like Verilog and VHDL, which many deplored but was an indispensible move for reasons of dealing with complexity."
lisp,34vsyo,wildeye,1 point,Tue May 5 17:59:54 2015 UTC,"I'm not sure what you mean by ""visual"" but a structured editor for ""strongly typed documents"" as a source code editor might work great for smartphones and tablets, simply on the basis of not forcing the user to hunt for pixels to position the cursor and by allowing the use of a ""contextual keyboard"". Every editing operation would preserve correct ""syntax"" by nature.  Some of the things I've been recently thinking about was 1) how to model the language structure abstractly (strong typing of the AST basically replaces the language syntax/grammar, but requires some kind of type system as a metagrammar to describe how to describe the languages themselves, plus visual presentation is an additional thing to describe), 2) how to express the language typing rules (a Shen-like programmable type checker, perhaps?), 3) how to express the translation/compilation process, 4) how to generalize the lower layers over all possible programs (what kind of lowest possible code representation is desirable?), 5) how the make the whole thing maximally modular to minimize the amount of ""source code"" (which would be a data structure, since the system, naturally, deserves to be circular)."
lisp,34v0k2,eejp,1 point,Mon May 4 20:06:38 2015 UTC,Good beginning. What are the main benefits? And what about tail recursion?
lisp,34v0k2,66a4,3,Tue May 5 05:13:35 2015 UTC,"Main benefits:  Simplicity  Lux follows the Haskell school of simplicity rather than the Clojure school of simplicty.  That means an emphasis on simple, single-purpose functions that are composable, rather than huge libraries with funky APIs that don't interoperate well and try to do too much.  Portability  Lux is meant to target many platforms and one goal I have is to make code-sharing trivial between platforms. In comparison, in most other languages sharing involves much copy-paste and tweaks to suit the differences in platforms (I'm looking at you, ClojureScript). Lux will make code-sharing a piece of cake.  Extensibility  Lux goes farther than most lisps by allowing direct access to the compiler state. There is already a macro (using), that implements ML's open by reading typing data from the compiler state and generating custom pattern-matching for you to extract all the members of the struct.    And what about tail recursion?    v0.1 generates unoptimized code, so no tail recursion.  However, you'll have tail call optimization and many more optimizations in the upcoming releases. Lux will be fast!"
lisp,34w8zo,TrendingBot,1 point,Tue May 5 02:00:32 2015 UTC,So what caused the exceptional growth on the 7th of january 2014
lisp,34nh2f,mmontone,3,Sat May 2 19:45:21 2015 UTC,"It's great that interactive development is still possible with erudite.   What I fail to see the benefit of, and this is a general comment about LP, is generating a separate document containing internals. It's easier to make the case for user documentation that it needs to be presented as a pdf or web page. Still, even for user docs I find that docstrings coupled with M-. in Slime are great and I aim at one thing only make the library explorable by adding docstrings/mgl-pax:defsection forms. I found that by making the source read well as a user manual the design is improved. Documentation can be generated too, but it's an afterthought."
lisp,34nh2f,mega,1 point,Sun May 3 08:02:59 2015 UTC,"The purpose of LP is documenting the internals. If you want an user manual, or a development manual which does not contain code, I guess you don't want LP, and write the thing in a separate file using the documentation tool you choose (LaTeX, Makeinfo, HTML,...)"
lisp,34nh2f,mega,1 point,Sun May 3 14:49:15 2015 UTC,"My point is that in the LP documents I've seen, most of the code wasn't an integral part of the text. Presenting internals or the ""externals"" as a document forces clarity of implementation and  the API, respectively. I think the latter is more important, entails the former to a good degree and gives more bang for the buck."
lisp,34nh2f,xenow,1 point,Mon May 4 13:15:49 2015 UTC,"I see your point, and that's what a friend of mine told me when I showed him an LP document. In Erudite, it is possible to disable automatic code output, and make explicit which fragments of code you want to export to the LP document, if any."
lisp,34nh2f,akkartik,2,Mon May 4 15:41:17 2015 UTC,"I looked at the linked page, the link to ""erudite"" in the page, and at the github. Couldn't find an example of the erudite syntax."
lisp,34nh2f,ritperson,3,Sun May 3 02:44:09 2015 UTC,From the last line of the article: https://github.com/mmontone/erudite/blob/master/erudite.lisp
lisp,34nh2f,xieyuheng,2,Sun May 3 06:22:53 2015 UTC,Does anybody use mgl-pax ?
lisp,34ihp5,xach,1 point,Fri May 1 13:07:37 2015 UTC,"could you also post your actual ssl certificate, signed with your pgp release key?  afaiu one of the next goals is to provide a robust validation mechanism based on gpg. if that's the case, my two cent request is to allow, for cases where there's already gpg on the system with your distribution key in trustdb, to still interact with quicklisp hosts over plain http.  ssl has a lot of well documented problems, while it makes some handy hacking activities needlessly complicated. right now it's pretty easy to change http.lisp and network.lisp to tunnel connections over ssh. it's also easy to debug problems using wireshark. ones you have ssl everywhere that goes out of the window."
lisp,34ihr5,xach,1 point,Fri May 1 13:08:23 2015 UTC,Very nice idea! We clearly miss Common Lisp fanzines!
lisp,34iae8,lispon,2,Fri May 1 11:50:48 2015 UTC,http://stackoverflow.com/questions/29984948/eliminate-eval-in-macro-using-correct-combination-of-commas-and-backquotes
lisp,34iae8,lispm,1 point,Sat May 2 09:16:54 2015 UTC,"Describe the goal, not the step   If you are trying to find out how to do something (as opposed to reporting a bug), begin by describing the goal. Only then describe the particular step towards it that you are blocked on.  Often, people who need technical help have a high-level goal in mind and get stuck on what they think is one particular path towards the goal. They come for help with the step, but don't realize that the path is wrong. It can take substantial effort to get past this.  Stupid:  How do I get the color-picker on the FooDraw program to take a hexadecimal RGB value?   Smart:  I'm trying to replace the color table on an image with values of my choosing. Right now the only way I can see to do this is by editing each table slot, but I can't get FooDraw's color picker to take a hexadecimal RGB value.   The second version of the question is smart. It allows an answer that suggests a tool better suited to the task."
lisp,34iae8,samlamamma,1 point,Sat May 2 19:48:04 2015 UTC,"I'm confused about your use case, but two thoughts here: first, EVAL may be evil but it's sometimes it's still the best option. The reason it's bad form to write explicit EVALs is because the designers of Lisp knew when EVAL is usually necessary and made it automatic. One important difference between DEFUN and DEFMACRO is that DEFUN evaluates its arguments and returns its results unevaluated, while DEFMACRO doesn't evaluate its arguments  but evaluates its results. EVAL is there for the (tiny minority) of cases that don't fit this pattern.   This leads into the second thought: you know the cliche advice about ""don't use a macro when a function will do""? It applies to compile-time source transforms as well. Since lisp forms are the same is data, if you need input arguments evaluated you can write functions that return the desired lisp forms. Since ""myothermacro"" seemingly needs to evaluate x somehow, maybe it should be written as a function that returns code--code that ""mymacro"" will EVAL once it's done expanding."
lisp,34e7md,xach,7,Thu Apr 30 12:47:35 2015 UTC,"Reminds me of wise Erik's words about achieving anything in C++ demanded so much effort that you cherished it and wanted to reuse as much code as possible as opposed to CL.  From another perspective, too many libraries seems like a nice to have problem. Much better than no libraries. Lets hope the next problem that arises is ""the documentation is too long"" ^_^  Also kudos to Mark, it appears he really did a proper survey of the field before starting to write his own."
lisp,34e7md,PuercoPop,5,Thu Apr 30 16:01:16 2015 UTC,I think too many half-baked incompatible libraries can make an ecosystem worse than none at all.
lisp,34e7md,tarballs_are_good,2,Thu Apr 30 16:37:28 2015 UTC,"True. If all the libraries are half baked it would be an illusion of solutions.  (Not that that is the case, at least with yason)"
lisp,34e7md,PuercoPop,6,Thu Apr 30 16:48:47 2015 UTC,"Sorry I spelled ""redundant"" wrong in the title."
lisp,34e7md,pxpxy,4,Thu Apr 30 12:55:55 2015 UTC,"How to deal with redundant ""d""s in titles?"
lisp,34e7md,shizzy0,5,Thu Apr 30 19:29:22 2015 UTC,With deep shame.
lisp,34e7md,kiwipete,4,Thu Apr 30 21:01:39 2015 UTC,Hurts dudn't?
lisp,34e7md,guicho271828,3,Thu Apr 30 18:22:35 2015 UTC,"I actually assumed you had done so intentionally, and were being clever."
lisp,34e7md,muuh-gnu,3,Thu Apr 30 21:43:51 2015 UTC,Redundancy is also a result of inaccessibility. I hope your quicklisp fulltext search system improves this!
lisp,34bubw,fmargaine,1 point,Wed Apr 29 22:14:26 2015 UTC,"I don't understand the approach taken. If you would like to run a specific lisp application under Docker, why not go for creating a lisp image and running it inside the Docker container? This way you're Docker image could be even smaller."
lisp,34bubw,schaueho,2,Sun May 17 12:28:03 2015 UTC,"This is what it does, using buildapp. Buildapp has to be installed in the container though."
lisp,349i7b,xach,9,Wed Apr 29 11:09:02 2015 UTC,pre-order done! :) - his web-framework TBNL (later Hunchentoot) got me into using Common Lisp in realworld commercial projects. Not to mention all the other libraries he contributed. Thank you Edi!
lisp,349i7b,okflo,5,Wed Apr 29 16:12:32 2015 UTC,Great news. I'm quite sure it will be worth reading.
lisp,349i7b,zxvf,2,Wed Apr 29 18:26:43 2015 UTC,"""Common LISP Recipes: A Problem-Solution Approach"", nice. I put in my pre-order."
lisp,349i7b,z27,2,Wed Apr 29 13:45:19 2015 UTC,preorderd.
lisp,349i7b,KDallas_Multipass,2,Wed Apr 29 22:20:19 2015 UTC,"I am avidly awaiting this, and hoping it will not be all web-based."
lisp,349i7b,iouwt,4,Thu Apr 30 18:05:29 2015 UTC,I hope it will be available in the PDF format.
lisp,349i7b,ilowry,-3,Wed Apr 29 14:23:50 2015 UTC,"BTW, every single really valuable thing in our Life is PDF (Pretty Daring Free)."
lisp,349i7b,wrong_assumption,2,Wed Apr 29 21:00:34 2015 UTC,In our life?
lisp,346cl9,bitmadness,2,Tue Apr 28 17:33:05 2015 UTC,"So, on OS X 10.10.3:  $ sh make.sh --prefix=/q/cl/sbcl --fancy   and I got:  Finished running tests. Status:  Unexpected success: threads.pure.lisp / (SEMAPHORE-NOTIFICATION WAIT-ON-SEMAPHORE LP-1038034)  Skipped (broken):   debug.impure.lisp / (TRACE ENCAPSULATE NIL)  Skipped (broken):   debug.impure.lisp / (TRACE-RECURSIVE ENCAPSULATE NIL)  Expected failure:   packages.impure.lisp / USE-PACKAGE-CONFLICT-SET Expected failure:   packages.impure.lisp / IMPORT-SINGLE-CONFLICT Failure:            threads.impure.lisp / FP-MODE-INHERITANCE-THREADS (4 tests skipped for this combination of platform and features)  test failed, expected 104 return code, got 1"
lisp,346cl9,crash_overdump,2,Tue Apr 28 23:27:40 2015 UTC,"sbcl.org seems down - surely not the reddit effect, we're too small a community for that"
lisp,346cl9,spacebat,1 point,Wed Apr 29 00:09:34 2015 UTC,Was up about an hour ago.
lisp,346cl9,crash_overdump,1 point,Wed Apr 29 01:37:53 2015 UTC,it is up now.
lisp,344m77,lispm,2,Tue Apr 28 06:53:12 2015 UTC,I just love it if every one who was there would post an account of their experience.
lisp,344m77,DavidNcl,1 point,Tue Apr 28 16:10:37 2015 UTC,Great write up!
