C_Programming,3e3tdq,policetattoo,13,Tue Jul 21 19:10:59 2015 UTC,"You've got your parameters backwards a bit there; the signature of main is int (int, char**), or equivalently, int (int, char*[]).  The first parameter, conventionally argc (argument count), is the number of arguments passed to the application (e.g., on the command line).  The second parameter, conventionally argv (argument vector), is a pointer to an array of null-terminated strings (character array pointers), which IIRC is itself null-terminated? That might not be right; I can't remember.  Anyway, the first is a count of arguments; the second is an array containing the arguments, the first of which (argv[0]) is the invocation of the program itself, i.e. the executable name.  int main (int argc, char **argv) {     for (int i = 0; i < argc; ++i)         printf (""argv[%d]: %s\n"", i, argv[i]); }   This snippet ought to give you an idea of how it works."
C_Programming,3e3tdq,acwaters,10,Tue Jul 21 19:24:05 2015 UTC,"which IIRC is itself null-terminated? That might not be right; I can't remember.   You are correct. From the C99 spec:   5.1.2.2.1 Program startup  [...]   argv[argc] shall be a null pointer.    So, technically, you don't even need to know argc."
C_Programming,3e3tdq,skeeto,1 point,Tue Jul 21 19:58:25 2015 UTC,"argument value(s)   huh TIL, I always thought it was ""argument vector""  It might also be helpful to mention that arrays decay to pointers when passed as arguments to a function  i.e.  char array[];   -->   char* array;  char *argv[];   -->   char** argv;"
C_Programming,3e3tdq,PhyterJet,1 point,Wed Jul 22 10:02:17 2015 UTC,"Eh, ""values"" is how I mentally interpreted it; ""vector"" makes a bit more sense, though, doesn't it?  Edit: Actually looked it up and you're right. How have I never bothered to learn what that stands for?"
C_Programming,3e3tdq,acwaters,1 point,Wed Jul 22 12:31:45 2015 UTC,"conventionally argv (argument vector), is a pointer to an array of null-terminated strings    char *argv[] means array of char pointers(null terminated strings in this case).  A pointer to an array would be char (*argv)[], and a pointer to an array of null terminated strings would be char *(*argv)[].  For those that don't know, cdecl.org is a great site to convert C declarations to English."
C_Programming,3e3tdq,Pastrami,1 point,Wed Jul 22 13:44:27 2015 UTC,"If this were a local variable declaration, you would be correct. But this is a function parameter declaration, where there are no arrays; only pointers masquerading as arrays."
C_Programming,3e3tdq,acwaters,1 point,Wed Jul 22 14:33:42 2015 UTC,"True, but if you replace ""null-terminated string"", ""pointer"", and ""array"" with ""*"", your sentence ""a pointer to an array of null-terminated strings"" would be written as char ***argv. One too many. It's really just ""array of null-terminated strings""."
C_Programming,3e3tdq,Pastrami,1 point,Wed Jul 22 14:49:31 2015 UTC,"I wasn't speaking in terms of C types; the OP can look at the declaration and see what the type is. I was speaking of the value that was actually being passed, which is a different thing altogether.  int foo (int *f) {} int bar (int(*b)[]) {}  int x[10]; foo(x); bar(&x);   foo and bar above will receive the exact same value when they're called, despite the fact that the nominal parameter types are separated by a level of indirection. They both get a pointer-to-array; the only difference is the type's stride, which for foo is sizeof(int) and for bar is sizeof(int*). Cast b to int* in bar, and the two are exactly equivalent."
C_Programming,3e3tdq,acwaters,6,Wed Jul 22 15:10:59 2015 UTC,"Are you sure you understand the concept of pointers? And how they interact with arrays?  Well firstly, you have the types of the parameters the wrong way round. The main function signature should actually be:  int main (int argc, char *argv[]); // how argv is presented is up for debate  The first parameter, argc, is the number of arguments passed into the executable when it is run and argv is an array of those arguments as strings. In C strings are represented as an array of chars, so argv is an array of array of chars.  So why isn't the second parameter declared as an array of array of chars e.g. char argv[][]? Well... It can. But it also can be represented as char *argv[] or 'char **argv.   In C an array is actually a pointer to the first element in an array and the syntax arr[1] is actually just syntactic sugar for *(arr + 1), which is a pointer to the memory location one after the one pointed to by arr (the pointer to the first pointer in the array);  So really you can represent an array as a pointer, or an array of array of something as a pointer to pointer of something. Hence argv[][], *argv[] and **argv are equivalent.  As to why you don't use a pointer for the first argument is because there is no point as it is an int."
C_Programming,3e3tdq,dillinger__88,12,Tue Jul 21 19:30:09 2015 UTC,"So why isn't the second parameter declared as an array of array of chars e.g. char argv[][]? Well... It can. But it also can be represented as char *argv[] or 'char **argv.   No. char argv[][] is illegal as the type of an argument to a function! Pointer decay goes only ""one level deep,"" so that is not the same as char **argv or char *argv[].  http://c-faq.com/aryptr/pass2dary.html  You cannot use char argv[][] as the type of an argument to a function—you need to specify the size of the second dimension of the array. You could specify char argv[][3], for example, which is equivalent (in a function declaration) to char (*argv)[3], which means ""pointer-to-array-of-3-chars."" But that is not the same type as ""pointer-to-pointer-to-char.""   In C an array is actually a pointer to the first element in an array   No. Arrays and pointers are not the same. When the name of an array is used as a value, then it decays to a pointer, but the array itself is not a pointer.  https://www.reddit.com/r/learnprogramming/wiki/faq_c#wiki_is_there_a_difference_between_arrays_and_pointers.3F  http://c-faq.com/aryptr/index.html   So really you can represent an array as a pointer, or an array of array of something as a pointer to pointer of something. Hence argv[][], *argv[] and **argv are equivalent.   Again, this is not true. Pointer decay goes only ""one level deep."""
C_Programming,3e3tdq,zifyoip,2,Tue Jul 21 23:02:43 2015 UTC,TIL. Thanks for posting that.
C_Programming,3e3tdq,inhuman4,6,Wed Jul 22 03:04:49 2015 UTC,"e.g. char argv[][]?   That is not a valid type in C, not even an incomplete one.  You can have an incomplete type like char argv[][2] though, but the size must be fixed.   In C an array is actually a pointer to the first element in an array   No, arrays are a distinct type from pointers, although under many situations they are implicitly converted to pointers of their first element, which is the primary source of confusion.  You can tell the difference in certain cases, e.g. inside a sizeof:  const char  array[] = ""hello""; const char *pointer = ""hello""; assert(sizeof(array)   == strlen(""hello"") + 1); assert(sizeof(array)   != sizeof(char *)); assert(sizeof(pointer) == sizeof(char *));   A function parameter can never be of an array type.  If you declare one as such, it will always adjusted to a pointer type (C11§6.7.6.3), regardless of whether a length is provided:  char *argv[]  ⇒  char **argv char buf[32]  ⇒  char *buf   You can tell this is the case because you can declare the same function multiple times and the compiler won't complain, because they are adjusted to the same type:  void foo(char *argv[]); void foo(char *argv[32]); void foo(char **argv);   (There are other adjustment rules too for things like function types and const-qualifiers.)  As a side-note: it is possible to have array types as function parameter as long as it's not a top-level array, e.g. char (*x)[2], which is a pointer to an array of two chars and is distinct from char **x, which is a pointer to a pointer to a char.  See for yourself:  /* this will result in a compile error */ void bar(char (*x)[2]); void bar(char **x);"
C_Programming,3e3tdq,Fylwind,2,Tue Jul 21 23:06:44 2015 UTC,"Perfect explaination.  I failed to connect the idea that each argument was in itself an array, rather than just the array of arguments being the only array. Like I understood both the concepts, I guess having *argv[] is confusing (if you are going to list one array as a pointer, why not list the other).  Is this the same reason why scanf() requires pointers?"
C_Programming,3e3tdq,BadWolfiie,3,Tue Jul 21 19:41:03 2015 UTC,"scanf() requires pointers because you're modifying the value of a variable that is external to the function (the one you're passing as an argument), have you heard or read about passing parameters by reference?"
C_Programming,3e3tdq,Leandros99,1 point,Tue Jul 21 19:53:50 2015 UTC,"That makes sense.  Passing paramaters by reference refers to '&', correct?"
C_Programming,3e3tdq,dumsubfilter,3,Tue Jul 21 20:08:27 2015 UTC,"No, well, yes. References, like int&, are a C++ feature. With & you get the pointer (to the memory) of a variable. By reference is passing a pointer, by value is passing the dereferenced pointer."
C_Programming,3e3tdq,Leandros99,1 point,Tue Jul 21 21:50:07 2015 UTC,"Technically, everything in C is a value pass."
C_Programming,3e3tdq,bunkoRtist,1 point,Wed Jul 22 06:11:23 2015 UTC,"Yes, a pointer is nothing else."
C_Programming,3e2fr0,rex32,10,Tue Jul 21 13:06:21 2015 UTC,"By .txt I guess you mean writing ASCII data with fprint and then parsing with fscanf. But I don't know what you mean by .dat versus .bin.  Usually, you'll want to save files as pure text. It's easier and safer to work with because you don't need to worry about architecture specificities. For instance, if you write an (int) to a file, the writing application could be working with integers of, say, four bytes while the reading architecture could be working with integers of eight bytes. Endeanness is also an issue.  You'll want to work with ""binary"" data when you are savings lots of native stuff. Imagine a .zip file encoded as sequence of ASCII numbers. It would lose the point of the compression. Also you might not want your data to be easily editable, like you're writing a game and you don't want to make it so easier for the player to edit the character file and chat.  You might be interested him checking something called marshalling. It's simply saving native data types to a file in standardized ways. I can't recall of any right now as I'm on mobile, but there are libraries for that in many languages, including C and C++."
C_Programming,3e2fr0,nextnextfinish,5,Tue Jul 21 13:21:56 2015 UTC,"Data marshalling can actually be done without libraries in C, although the minimum assumption you need to make is usually CHAR_BIT==8. The following program writes a 24-bit sign and magnitude value in the big-endian byte order to an array, which can be written to a file with fwrite.  #include <stdio.h>  unsigned char *put_i24(unsigned char buf[3], long x) {     unsigned long y;      y = (x < 0) ? 0x800000 | -x : x;     buf[0] = y >> 16;       buf[1] = y >> 8;        buf[2] = y;             return buf; }  int main(void) {     long test[] = { -1, 1, 0, 0x123456, -0x123456, 0x7fffff, -0x7fffff };     unsigned char a[3];     int i;      for (i = 0; i < sizeof test/sizeof test[0]; i++) {         put_i24(a, test[i]);         printf(""%8ld: %02x %02x %02x\n"", test[i], a[0], a[1], a[2]);     }     return 0; }   This program should produce the following output regardless of the host's byte order or signed integer representation.            -1: 80 00 01            1: 00 00 01            0: 00 00 00      1193046: 12 34 56     -1193046: 92 34 56      8388607: 7f ff ff     -8388607: ff ff ff"
C_Programming,3e2fr0,danielcamiel,0,Tue Jul 21 14:54:59 2015 UTC,"Data marshalling can actually be done without libraries in C   Well, you can do anything without libraries in C... but since there's already an estabelished and tested library for that, why not give it a try?"
C_Programming,3e2fr0,nextnextfinish,4,Tue Jul 21 18:55:06 2015 UTC,"Neither endianess, nor size of int is a big issue. You can simply use uint32_t (assuming you have access to a C99 compiler), it's always 4 bytes. Most newer architectures (AMD64, x86) have native instructions to convert endianess, you could just always save it in little endian (which is very prominent on todays desktop, due to Intel), and convert big endian to little endian.  Keep in mind, while binary data isn't human readable, a clever human can still read your binary data. It's not encryption, if you want your files to be unreadable, you have to use other techniques to make sure they're not tempered.  There are a few libraries, which make it a lot easier to save binary data on disk (for example, flatbuffers, capnproto, protobuff)."
C_Programming,3e2fr0,Leandros99,0,Tue Jul 21 14:30:26 2015 UTC,I've never been sure about stuff like uint32_t. Is that standard?  How do you ensure data will be saved/read in the same endianess in C without resorting to manually implementing a BOM signature?
C_Programming,3e2fr0,nextnextfinish,3,Tue Jul 21 18:57:10 2015 UTC,"Point 2 of 7.18.1.1 Exact-width integer types in the ISO/IEC 9899 (also known as the C99 standard):   The typedef name uintN_t designates an unsigned integer type with width N. Thus, uint24_t denotes an unsigned integer type with a width of exactly 24 bits   In short, yes, it's standardized since C99.    You don't. You have either some sort of BOM signature, or always use the same (like, for example, flatbuffers do, they always write it to disk in little endian, but are still able to run completely fine on big endian machines)."
C_Programming,3e2fr0,Leandros99,8,Tue Jul 21 21:24:18 2015 UTC,"File extension doesn't matter. It's just a convention to tell whoever looks over the file names what the file might contain. You can write text in a .jpg file or music in a .doc file, nobody stops you. Now for actually writing data, I suggest you to use plain text if possible because that's the easiest form of data to process further."
C_Programming,3e2fr0,FUZxxl,4,Tue Jul 21 15:18:25 2015 UTC,"txt is text bin is binary dat is more often than not also binary  The extension should indicate what type of information it contains and that's it. You could as well save binary data in a txt but someone will probably get mad at you for that.  Edit: also, the extension is merely in the name, means a file doesn't need an extension. You could also rename the file to another extension or omit it - that doesn't change the contents."
C_Programming,3e2fr0,nath_schwarz,4,Tue Jul 21 13:22:01 2015 UTC,"All three of them are just file extensions that don't really tell you anything about the format (except that a txt file would probably be human-readable).  What you need to do is think of a format to save your data in the file. Should it be human-readable? Is it just for output or input as well?  If it's just for output it's probably enough to just use fprintf() to write your data in an arbitrary human-readable fashion, interpretation and fault-tolerance is handled by the (human) reader.  If your format is for input and output, your application has to be fault-tolerant as well, especially if your file format is human-readable (e.g. dealing with syntax errors, white spaces and all that stuff). This is probably what you think of when you say txt file.  If you don't need human-readability and you only have a limited number of types to save to the file (e.g. one kind of struct) it's probably enough to just write a 4-byte value indicating the number of structs in the file and then writing the structs using something like fwrite(). To parse this file, simply use fread() to first get the number of structs and then read the structs from the file. You can call this a bin or dat file, but the truth is those extensions just mean the file is in a binary format. There is no formal definition for the format of the data inside of a bin/dat file."
C_Programming,3e2fr0,thefeistelnetwork,3,Tue Jul 21 13:31:03 2015 UTC,"bin, txt, or dat file   You are talking about extensions of the files, not their contents. .txt files are generally used to store human-readable text, while .bin and .dat files are used to store binary data.  The topic you'll want to look into first is file IO. I found this tutorial with a quick search, just search for ""C file IO"" or ""C writing to a file"" and you should be able to find more.  The second topic you might want to look into is serialization. You can write stuff into a file, but what format are you going to use? You can either use a human readable format, such as JSON or XML, or you can use binary files. Binary files should be a bit faster and more flexible in what you can save, file human readable formats have the bonus of being editable by hand.  I'm personally not experienced enough to suggest a library or a format, but feel free to search for ""C serialization"" if you are interested, it seems that there are lots of options available."
C_Programming,3e2fr0,SeriousBug,1 point,Tue Jul 21 13:29:40 2015 UTC,"For a long-term solution, binary formats are more complex than you'd think. Personally, I would only do a binary file format if you had some problem that only a binary solution would solve.   One example: you tried a text format and after weeks of optimizing it, opening/closing files was still too slow. Or, the text file format created files too large for a specific hardware configuration. Or, modeling a complex data structure was too difficult to do efficiently in text format.   As a newbie C programmer, you're probably better off sticking to text file formats. If you're willing to use 3rd party serialization/marshalling libraries, that can save you a lot of the headaches of a binary file format, but be sure the library handles all the environments you need to handle."
C_Programming,3e3tdn,acwaters,3,Tue Jul 21 19:10:58 2015 UTC,It sounds like what you actually want is Python
C_Programming,3e3tdn,acwaters,1 point,Tue Jul 21 19:29:03 2015 UTC,I wanted to try python but my boss wanted me to use C because he wanted to link it up with some other libraries
C_Programming,3e3tdn,meegowat,7,Tue Jul 21 19:31:49 2015 UTC,"I'll be blunt: What you want to do is completely possible in C. Anything is possible in C. But trying to write networking code in C when you've (presumably) never used the language before? You're gonna have a bad time, my friend. Libraries abound, but due chiefly to the peculiarities of the language, none of them are particularly easy to use. And on top of all that, the language itself is ruthless to beginners. I'm not trying to turn you off from learning, but there are absolutely better, faster, easier ways to do what you want to do. I urge you to urge your boss to reconsider."
C_Programming,3e3tdn,pfp-disciple,1 point,Tue Jul 21 19:38:34 2015 UTC,"logging network network traffic through SNMP   So what is it you are needing to do? Is this running locally or are you using this to poll other devices via snmp over the network? Either way, net-snmp is where I would start. Best I can think of if this must be done in C, though net-snmp is kind of rough to work with."
C_Programming,3e3tdn,cunttard,2,Wed Jul 22 07:21:59 2015 UTC,"I second what /u/acwaters said.   I'll add on to this: C is ""code"", not ""scripts"". This sounds pedantic, but it's a fundamental difference: scripts tend to be ""write it then run it"", loose typing, higher-level abstraction for thinking about the problem. ""Code"" tends to be ""write it, compile it, run it"". I'm being kind of loose with ""script"" vs ""code"", but that's my take on it.  In all fairness, you will want a decent understanding of C before tackling this. You could possibly short-cut the end game by using popen() to run command line utilities for SNMP. It's uglier and less proper than using C libraries for the job, but it may be more intuitive for you the developer. Just realize that this will likely be trowaway code.   If your boss' goal is for you to learn C by tackling a big task, then by all means go for it. You'll have to progress through a few levels (beginning with newbie) before you have a good final product.   If your boss' goal is to have the job done, then picking another language is likely your best bet. Even if you're on Windows, there are still decent scripting languages."
C_Programming,3e3tdn,spc476,3,Tue Jul 21 21:18:56 2015 UTC,"As someone that's spent some time with Net-SNMP C libaries; you don't want to go down this route. Use python.  If you really need to write SNMP metrics collection in C, I would suggest looking at the client applications for Net-SNMP such as snmpget."
C_Programming,3dvzn1,derrickcope,23,Mon Jul 20 00:09:36 2015 UTC,"First of all, please understand that in C, capitalization and punctuation matter. I assume the two examples actually look like this:  main() {     return 0; }   and  int main() {     return 0; }   Now to your questions: The second of these two is what you should use. int is the return type of main(), there is a rule that you can leave out the return type if it is int which the first variant uses. This rule however is deprecated and was removed in the newest revision of the C language.  make is a program that helps you compile projects. You can specify compilation options and how to compile the project in a Makefile and make will automatically invoke the compiler for you. For simple tasks, it is sufficient to use cc, the C compiler (gcc is an implementation of cc). Don't try to write Makefiles until you have understood the process of compiling a C program, it's just distracting."
C_Programming,3dvzn1,FUZxxl,5,Mon Jul 20 00:15:35 2015 UTC,"OK thanks for that. I see that there are recommended books on the sidebar. Is "" let us C"" a good book? How about "" learn C the hard way"" ? Are there any more big differences between 88/90 and the most recent version 99 ??"
C_Programming,3dvzn1,IceDragon13,7,Mon Jul 20 00:49:59 2015 UTC,"Just an FYI, C11 is the latest."
C_Programming,3dvzn1,FUZxxl,2,Mon Jul 20 03:36:14 2015 UTC,thanks
C_Programming,3dvzn1,SantaCruzDad,2,Mon Jul 20 03:37:07 2015 UTC,"I haven't read many books about C programming and I haven't read “let us C” in particular. Learn C the hard way is okay, but as you are a total beginner, this might be a bit too hard for you, but try it out if you want."
C_Programming,3dvzn1,benwaffle,2,Mon Jul 20 09:28:01 2015 UTC,"""Let Us C"" is a terrible and very out-of-date book by Y Kanetkar, who has also written equally terrible and out-of-date books on C++. Unfortunately these books are still widely used in colleges in India. Avoid at all costs.  For a list of decent C books see here: http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list"
C_Programming,3dvzn1,Rhomboid,1 point,Mon Jul 20 16:46:40 2015 UTC,"Thanks, I got the ""modern approach"" book."
C_Programming,3dvzn1,skush97,2,Mon Jul 20 23:37:30 2015 UTC,I recommend C Programming: A Modern Approach.
C_Programming,3dvzn1,Wiggledan,8,Mon Jul 20 17:29:19 2015 UTC,"In C99, there's a special rule for main() that if control reaches the end of the function without an explicit return statement, it's as if return 0 had been written.  That doesn't apply in general; if a function returns non-void, it needs to have a return statement.  Falling off the end of the function in such a case is undefined behavior.  (Technically I think the standard requires that it's UB if the caller actually attempts to use that value, but that's a distinction not worth fretting about — it's bad either way.)  But this rule didn't exist in C90, so it depends on which language standard you're using.  By default gcc uses C90 (with GNU extensions), but I suggest using at least C99 if not C11.  You can do that with -std=c99 or -std=c11.  (The default was finally changed from -std=gnu90 to -std=gnu11 in gcc 5.x, but you should still disable non-standard extensions.)  The other, completely unrelated issue is that in very old versions of C, if you didn't state a return type for a function, int was assumed.  You should not rely on that.  In summary, there are two valid signatures for main():  int main(void) {     ... }   or  int main(int argc, char **argv) {     ... }   Any learning resource that doesn't use one of these two should be flushed down the toilet.  Returning zero is optional if you're using C99 or C11, but not if you're using C90."
C_Programming,3dvzn1,Rhomboid,4,Mon Jul 20 00:49:30 2015 UTC,"K and R uses the old main signature.  I wouldn't say it should be flushed down the toilet, just used with caution due to its age."
C_Programming,3dvzn1,Wiggledan,1 point,Mon Jul 20 02:47:16 2015 UTC,Isn't what you're referring to as C90 usually referred to as C89?
C_Programming,3dvzn1,Leandros99,1 point,Mon Jul 20 23:44:17 2015 UTC,"The ANSI standard was ratified in 1989, the ISO international standard was ratified in 1990.  If you're referring to ISO standard C, then C90 is correct.  They are pretty much synonyms, but C90 is what the gcc documentation uses so it's what I'm using for consistency."
C_Programming,3dvzn1,darkfall110,1 point,Tue Jul 21 00:19:30 2015 UTC,"Huh, good to know."
C_Programming,3dvzn1,Wiggledan,1 point,Tue Jul 21 02:52:49 2015 UTC,"As far as compiler flags of gcc are concerned, -std=c90, -std=c89 and -ansi all have the same outcome.  Where does it say, gcc's documentation is using C90? I've never seen it, they always referred to it as either C89 or ANSI C."
C_Programming,3dvzn1,net_goblin,4,Wed Jul 22 14:15:32 2015 UTC,"I would recommend C Programming A Modern Approach. It is expensive but the content its very good, covers from basic to intermediate level. At the end of each chapter there are questions with answers, similar to your question, exercices and ideas of projects to practice. If you can find it with a friend or in a library I personally find it better than Learn C the Hard Way."
C_Programming,3dvzn1,benwaffle,2,Mon Jul 20 03:22:20 2015 UTC,I found this book. It is the 2nd edition and answers many or my questions. Thanks.
C_Programming,3dvzn1,net_goblin,1 point,Mon Jul 20 08:19:19 2015 UTC,"Been working through this book from beginning to end (kind of slowly, not even every day) for the last 8 months or so, and I'm almost through it (I'm on chapter 21 atm). It goes into the perfect level of detail without being too boring, and all the exercises/projects are really good practice. You should really take your time with each chapter and absorb as much as you can. It's even a pretty good reference manual.  Also, you should check out /r/dailyprogrammer if you have some spare time and just wanna practice with some simple challenges. They have an easy, intermediate, and hard challenge come out every week. I started out doing only the easy challenges, but I've been able to do more and more intermediates as time goes on, and hopefully I can do a hard one by the end of the year. :P"
C_Programming,3dvzn1,Enlightenment777,1 point,Mon Jul 20 23:50:49 2015 UTC,"Edit: Obviously I can't read... While I agree with /u/FUZxxl that it might be distracting at the beginning, I'd recommend you to familiarize yourself with the compilation process soon and use make thereafter.  I haven't seen an answer to your question about make vs. gcc yet, so I'll tackle that.  Make is a build automation tool, which in turn calls the c compiler, which in your case seems to be gcc. It automates all the boring stuff, like checking if a file was modified since the last build and therefore has to be compiled again. This might not be useful for you yet, as I guess you don't have that many source files for a single program at the beginning, but the use of make may also make the compiler call more convenient. For example:  make   vs  gcc -std=c11 -Wall -Wextra -Wpedantic -o test test.c   given a Makefile with contens like  test: test.c         gcc -std=c11 -Wall -Wextra -Wpedantic -o test test.c   Please be aware that this is an extremely simplistic Makefile and doesn't follow any of the best practices for using make."
C_Programming,3dvzn1,-AcodeX,2,Mon Jul 20 07:45:04 2015 UTC,"I think beginners should be taught to use the built-in rules, so they just write  test: test.c   and make knows to compile it. Then, you introduce variables:  CFLAGS = -std=c11 -Wall test: test.c"
C_Programming,3dvzn1,-AcodeX,1 point,Mon Jul 20 17:32:00 2015 UTC,Good Point
C_Programming,3dvzn1,-AcodeX,1 point,Mon Jul 20 18:06:13 2015 UTC,"Choose one of the following:  int main(void)  int main(int argc, char **argv)  The 2 different styles either give doesn't give you access to the ""command line"" arguments.  for example, ""myprogram 1 2 3"", you need the longer main to get access to the ""1 2 3"".    if your program doesn't accept command line arguments then choose the shorter ""int main(void)"".    the return ""int"" part of the main() function allow your program to return an error code to the operating system.  0 (zero) means no error, thus is why you see it so often."
C_Programming,3dvzn1,Chooquaeno,1 point,Mon Jul 20 08:10:01 2015 UTC,"Others have answered your question thoroughly, so I just wanted to ask if you have looked into CS50 on edx? It's an awesome introduction to C."
C_Programming,3dwgzj,Aakash23,1 point,Mon Jul 20 02:46:19 2015 UTC,Which part are you stuck on? Can you write an infinite loop?
C_Programming,3dwgzj,wgunther,1 point,Mon Jul 20 02:48:00 2015 UTC,while(1) is the start of an infinite loop and //infinite loop shows he knows that.
C_Programming,3dwgzj,HaltAndThrowFire,1 point,Tue Jul 21 21:03:30 2015 UTC,The star next to the post time indicates that the post was edited after it was posted.
C_Programming,3dwgzj,wgunther,3,Tue Jul 21 22:19:06 2015 UTC,"Simple problem; imple solution:  char input[20] = """";  while (!input[0]) {     ... }   I'm assuming you want to be able to accept muli-character input. (If not, this still works. This code only depends on the first character variable.) Initialize the first character of your input to a null character (i.e. 0). As soon as input of any sort is put into the variable (a return character, the first letter of a string), !input[0] will no longer evaluate as true.  Edit: I'm also assuming you know how to take input and put it in variables. Let me know if I'm wrong."
C_Programming,3dwgzj,HaltAndThrowFire,0,Tue Jul 21 21:01:00 2015 UTC,"Well, assuming stdin is your keyboard, you could have a global stream in which you save the value of stdin. Then, compare it with the stdio.h stdin... if it's not equal, you can assume a key has been pressed.  Note that this may not work and is really just a bad idea in general."
C_Programming,3dwgzj,nsandman09,0,Mon Jul 20 05:02:09 2015 UTC,"Do you know about the I/O functions of the standard library? If not, you may want to read the documentation."
C_Programming,3dwgzj,net_goblin,2,Mon Jul 20 08:31:57 2015 UTC,There isn't a standard library function that checks for a hit key or pending input on a stream without blocking.  They're all going to block if nothing has been hit.
C_Programming,3dwgzj,dumsubfilter,0,Mon Jul 20 16:25:26 2015 UTC,"My advice, don't use an infinite loop. Your while should be conditional. That's what it's there for. The while evaluates on each iteration anyway, so why introduce a second evaluation? Your way is bad practice . BTW blocking code sucks. Better to test periodically and do something useful in the interim.."
C_Programming,3dwgzj,playaspec,1 point,Mon Jul 20 13:30:26 2015 UTC,"You may be able to use fork() to accomplish this. Instead of starting with a while loop, maybe start;     int returnval = fork();     if(returnval == 0) { //This is your child         scanf(""%s"", yourString);     } else { //This is your parent         while(yourString != NULL) {             //This is your infinite while loop         }     } Maybe?"
C_Programming,3dwgzj,1alex1131,-3,Mon Jul 20 18:11:30 2015 UTC,"Maybe something like:  while(true) {   // your code  printf(""Press any key to break the loop\n""); scanf(""%s"", &str1);   if (&str1 ==! NULL)   {  break;     } }"
C_Programming,3dwgzj,Totally_not_a_spider,2,Mon Jul 20 11:49:41 2015 UTC,"The concept is fine, the actual code isn't.  Assuming str1 is a character pointer, the scanf is incorrect.  scanf( ""%s"", str1 );   This is still going to block the loop, and it will sit there waiting for you to hit enter.  Assuming str1 is a character pointer, this will never  be NULL, so this test would never work, even if the correct test was used:  if( &str1 ==! NULL )   It would be:  if( str1 != NULL )   However, str1 will never be NULL.  Or maybe you were trying to dereference it to check the first character for nul."
C_Programming,3dtlsy,Araneidae,3,Sun Jul 19 09:36:20 2015 UTC,"Why do you think it is bad that a += b; gives a warning?  The warning seems correct to me. The result of the addition may be out of range for char, causing implementation-defined behaviour.  I'd argue that adding plain chars is bad style, they're meant to represent actual characters. There would be a better data type for whatever you are trying to do (perhaps uint8_t)."
C_Programming,3dtlsy,OldWolf2,3,Sun Jul 19 12:46:04 2015 UTC,"Do you really imagine that uint8_t behaves differently?  Think about it.  In fact, my original code used uint8_t, I just simplified the presentation to get to the core of the issue.   The result of the addition may be out of range ...   Yeah.  That was the point of the last line of my original posting: let's have warnings about arithmetic out of range, then we can put warnings on every single line of code.  Essentially this -Wconversion behaviour means that none of the <op>= operations can be used on data types smaller than int without generating an error.  I don't consider that either useful or sensible."
C_Programming,3dtlsy,OldWolf2,1 point,Sun Jul 19 13:03:43 2015 UTC,"Yes, uint8_t behaves differently. It is well-defined to assign an out-of-range value to uint8_t, unlike char."
C_Programming,3dtlsy,OldWolf2,1 point,Sun Jul 19 21:54:47 2015 UTC,"Ah well:  $ cat test.c #include <stdint.h> uint8_t a;  void test(uint8_t b) {     a += b; }  $ gcc -Wconversion -c test.c test.c: In function ‘test’: test.c:6:7: warning: conversion to ‘uint8_t’ from ‘int’ may alter its value [-Wconversion]      a += b;        ^ $ gcc --version gcc (GCC) 4.8.3 20140911 (Red Hat 4.8.3-7) Copyright (C) 2013 Free Software Foundation, Inc. This is free software; see the source for copying conditions.  There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   As I said, turns out I was behind the times with my complaint, in fact I'm now struggling to find a compiler which doesn't produces this error!"
C_Programming,3dtlsy,HaltAndThrowFire,0,Mon Jul 20 08:27:10 2015 UTC,OK. In the uint8_t example that's a dumb warning and should probably be considered a bug.
C_Programming,3dtlsy,HaltAndThrowFire,1 point,Mon Jul 20 09:19:24 2015 UTC,stdint.h defints uint8_t as an unsigned char. A warning/error for one is the same for both.
C_Programming,3dtlsy,OldWolf2,0,Tue Jul 21 22:53:25 2015 UTC,You should read stdint.h. uint8_t is nothing more than a typedef for a char.   typedef unsigned char           uint8_t;
C_Programming,3dtlsy,FUZxxl,1 point,Tue Jul 21 22:49:55 2015 UTC,Actually it is a typedef for unsigned char - as you have posted evidence for ...  BTW you should read the C standard.  Reading any particular stdint.h only gives information about that one compiler for that one system you are working on.
C_Programming,3dsq8g,partialdub,11,Sun Jul 19 02:23:56 2015 UTC,"sizeof(numbers) is the size of a pointer (i.e. a constant, generally either 4 or 8 for 32 bit and 64 bit system respectively), because numbers is a pointer.  It is not the size of the block of memory pointed to by numbers.  sizeof() only works like that for actual arrays, not malloc().  When using malloc(), if you will need the size later you have to keep track of that yourself.  There is no way to get the size of a block of dynamic memory given only a pointer to it."
C_Programming,3dsq8g,Rhomboid,14,Sun Jul 19 02:50:20 2015 UTC,"int* numbers = malloc(sizeof(int));   You only allocate enough space for one int.  Try  int *numbers = malloc(elements * sizeof(int));   Of course, elements must be declared before this.  Edit:  And always make sure to check the return value of malloc.  if (numbers == NULL) {         fprintf(stderr, ""Malloc failed\n"");         return 1; }"
C_Programming,3dsq8g,Choo5ool,4,Sun Jul 19 02:38:23 2015 UTC,"sizeof(numbers) is 8: what is numbers? It is a pointer to ints.  A pointer itself is an int.  The size of the numbers pointer, is 8.  That's why you get that. Unfortunately, you can't simply get the size of your array. The way I go about it, is I keep element zero, numbers[0] to be the size of the array. And whenever I add or remove something to the array I will update numbers[0] to reflect that. But there is no simple .size() that you can use in C. Sorry! (Also, sorry for this terrible formatting, I'm new to reddit!)"
C_Programming,3dsq8g,1alex1131,3,Sun Jul 19 02:37:09 2015 UTC,Thanks for the info guys!  So how would I go about keeping track of the size? Should I just use a struct and increment an associated counter variable every time an element is added to the array?
C_Programming,3dsq8g,seanrowens,5,Sun Jul 19 03:15:09 2015 UTC,That's pretty much your only option.
C_Programming,3dt4qx,nickstricks,4,Sun Jul 19 05:04:33 2015 UTC,"Don't try to learn C quickly; try to learn it throughly. C is a language with many subtle aspects, learning it quickly is not going to get you anywhere."
C_Programming,3dt4qx,FUZxxl,4,Sun Jul 19 10:37:54 2015 UTC,"I wouldn't recommend learning either of the two ""quickly"". A few weeks or months after and you'll probably forget how to do either if you try to learn them quickly. Vim requires a lot of practice and has a steep learning curve. Assuming your wife is now learning how to program, C can be a steep curve when it comes to learning as well. I would suggest that uses ""the c programming language"" as a resource or the Harvard online course: CS50. Its on edX and its free. As for Vim, you can find vim online tutorials all over as well as vim cheat sheets. She'll get better at it with daily practice."
C_Programming,3dt4qx,Ajpennster,1 point,Sun Jul 19 11:26:12 2015 UTC,"I understand retention can be a issue when learning certain programming languages quickly. I have no need to retain this information, I am simply trying to do this so I can help the wife. Her professor does not teach very well, and I am trying to help by being able to give her a different perspective and understanding, as limited as it may be.  But thank you for the suggestions. I will check them out as soon as I can get to my laptop."
C_Programming,3dt4qx,Ajpennster,1 point,Sun Jul 19 14:00:03 2015 UTC,No problem. All the best
C_Programming,3dt4qx,takaci,3,Sun Jul 19 18:56:25 2015 UTC,"K&R's The C Programming Language (linked in the sidebar) is a pretty short book (only a couple hundred pages, and a lot is reference and about the standard library) which is quite information dense. It's hard but if you have any other programming experience you'll probably be able to do it. You could probably read it and complete the exercises and know more than most people about C in a couple of weeks with that book."
C_Programming,3dt4qx,zifyoip,1 point,Mon Jul 20 15:03:02 2015 UTC,Thanks man. I saw that once someone mentioned a function of the app I'm using for reddit to see the side bar. Gonna give it a go and see if i can't breeze through it in a couple of weeks.
C_Programming,3dt4qx,zifyoip,2,Tue Jul 21 02:34:52 2015 UTC,"Well, first of all, C and Vim are two completely different, independent things. Neither one of them requires or relies on the other, and you aren't going to find anything about ""learning C using Vim.""  Now, have you read the list of resources in the sidebar?"
C_Programming,3dt4qx,zifyoip,0,Sun Jul 19 05:07:15 2015 UTC,"I mentioned not having access to a pc at this time, so no, I have not had the chance to look at the side bar. I know vim and c are not reliant on each other. One being the ide, the other the language."
C_Programming,3dt4qx,angdev,3,Sun Jul 19 13:52:59 2015 UTC,"I mentioned not having access to a pc at this time, so no, I have not had the chance to look at the side bar.   What does that have to do with reading the sidebar? All mobile apps have the option to show the sidebar. Learn how to use your app or use a real browser.  https://imgur.com/a/kgwuy#4"
C_Programming,3dt4qx,Pronouns,-1,Sun Jul 19 13:56:14 2015 UTC,"Well, that's new to me haha. I just got this phone today. The reddit is fun app didn't have that in 4.2."
C_Programming,3dt4qx,FUZxxl,3,Sun Jul 19 14:03:57 2015 UTC,Baloney. The image I linked is 2 years old.
C_Programming,3dt4qx,Pronouns,0,Sun Jul 19 14:07:17 2015 UTC,"Well then, if thats the case, I've never seen that."
C_Programming,3dt4qx,angdev,3,Sun Jul 19 15:20:37 2015 UTC,If you know c++ how do you not know C enough to help someone with entry level C classes?
C_Programming,3dmuoc,suttoni,2,Fri Jul 17 15:37:49 2015 UTC,"Why are you using the PC as an index for the register file? You should extract the rs, rt, and rd bitfields from the instruction and use those.   The IF stage is the only one that reads from instruction memory. ID reads the instruction from the IF/ID register and generates the appropriate control signals. Every stage after that simply reads the control signals from the preceding pipeline register. In general, you should be passing data through the pipeline registers, not around them with statements like  newState.EXMEM.PCPlus4 = state.PC + 12;   This may be a nitpick, but if I were you I would probably make the instruction memory an array of const uint32 and keep it separate from state and newState, since you should not modify it."
C_Programming,3dmuoc,odougs,-1,Fri Jul 17 22:17:30 2015 UTC,You may find this helpful: http://courses.missouristate.edu/KenVollmar/MARS/
C_Programming,3dm7bk,Aakash23,4,Fri Jul 17 12:04:36 2015 UTC,"Because in a two-dimensional array s[i] is itself an array, whose elements are s[i][0] and s[i][1]. And in a context like this, an array will decay to a pointer to the first element."
C_Programming,3dm7bk,zifyoip,2,Fri Jul 17 12:07:21 2015 UTC,"Consider this...  typedef int intarray[4];   This will make a type called 'intarray' which is an array of 4 integers.  So you can now change   int s[4][2];   to   intarray s[2];   From here, it's a bit more broken down, and a bit clearer what you're doing. So you've made an array of intarrays of length 2. If you do s[0], you're going to get the first intarray from s.  What is an intarray? Well we decided its int[4]. If this is passed to a function for example, it will get demoted to a pointer: int*. So here it's clear that s[0] can be seen as a pointer to the first int of that intarray, and therefore to get the value, you need to dereference it, or index it:  s[0] // pointer (if demoted) to first element of first intarray *s[0] // the first int from the first intarray s[0][0] // same thing"
C_Programming,3dm7bk,Pronouns,3,Fri Jul 17 15:46:59 2015 UTC,"Not quite. The declaration int s[4][2]; is not the same as the declaration intarray s[2]; because in the first declaration s[0] has type array-of-2-ints, whereas in the second declaration s[0] has type array-of-4-ints. The dimensions are switched.  To use a typedef for an equivalent declaration to int s[4][2];, you need to use it like this:  typedef int intarray[2]; intarray s[4];"
C_Programming,3dm7bk,zifyoip,2,Fri Jul 17 16:19:17 2015 UTC,"Well, s[i] means ""the i'th element of s"", which is an array, and the way it's used here, the array is converted as described by zifyoip.  But you want a pointer to that element and not the element itself, so you might write &s[i], ""a pointer to the i'th element of s"".  As these pointers may have varying representations and sizes, you'll want to cast &s[i] to void *, i.e. (void *) &s[i], and match that value with the %p format specifier for printf."
C_Programming,3dm7bk,danielcamiel,0,Sat Jul 18 09:26:43 2015 UTC,"Your array is initialized incorrectly.  Valid:  int s[4][2] = {     { 1, 2 },     { 3, 4 },     { 5, 6 },     { 7, 8 } };"
C_Programming,3dm7bk,dumsubfilter,2,Fri Jul 17 16:20:57 2015 UTC,There's nothing incorrect about the initialization.  You can initialize nested aggregates with a flat list.  See C11 §6.7.9/20.
C_Programming,3dkfmc,Kuaira,7,Fri Jul 17 00:04:12 2015 UTC,"The point of specifying the types is so you can display the same type in different ways. Knowing the type is an integer does not tell you if they want the number printed in decimal form, scientific notation, hexadecimal, binary, etc."
C_Programming,3dkfmc,angdev,2,Fri Jul 17 01:00:05 2015 UTC,"While it is a part of what printf uses type specifiers for, it's hardly a necessity. Consider formatting according to C#:  Console.WriteLine(""{0} {0:E}"", 65535); // prints ""65535 6.553500E+004""   Note that the format string doesn't care that 65535 is an int. It works the same way if you put, say, a ulong or a double there.  Like I said, it's a proof of concept. It's not complete by any means. It blindly assumes decimal, but it can be extended to allow for specifiers like, for example, %x0 or %E0 that change the format."
C_Programming,3dkfmc,5HT-2a,5,Fri Jul 17 01:20:09 2015 UTC,"If you're looking for dynamic type safety, C is not the language for you I'm afraid. Part of what makes C C is that variables do not carry information about their type; only the compiler knows what they are. Thus, it is up to the developer (with the help of the compiler) to make sane choices as to handling their contents."
C_Programming,3dkfmc,angdev,3,Fri Jul 17 04:07:01 2015 UTC,"The same can be done in C but you're really only gaining the ability to re-use variables rather than have to re-push them onto the stack when using printf. The performance savings are negligable and pointless. But don't let these reasons stop you from having some fun learning macros & diferent C techniques. :)  Edit- I replied to the wrong comment, stupid touchscreen tablet."
C_Programming,3dkmpc,1alex1131,8,Fri Jul 17 01:06:10 2015 UTC,"I'm guessing you're on a 64-bit platform. Because x is a pointer (and not an array), sizeof(x) is the size of a pointer. On a 64-bit platform, sizeof(x) should be 8, regardless of how short or long the string is that x is pointing at.  You probably want to use strlen(x) (the length of the string pointer to by x) instead of sizeof(x) (the size of the pointer)."
C_Programming,3dkmpc,OlderThanGif,2,Fri Jul 17 01:15:10 2015 UTC,"Yep that's gotta be what it is!  In my notes, the only example we get is: buf[500]; write(fd, buf, sizeof(buf)); In this case buf is the size of the entire char array? And not just the size of a pointer to the first element? Why would buf[500] be different than buf = ""500charactersofstuff...."" ?"
C_Programming,3dkmpc,zifyoip,5,Fri Jul 17 01:48:01 2015 UTC,"The type of buf is array-of-500-chars. Therefore, sizeof(buf) is 500*sizeof(char).  The type of x in your code is pointer-to-char. That is not the same as array-of-char. Pointers and arrays are not the same thing."
C_Programming,3dkmpc,OlderThanGif,3,Fri Jul 17 01:59:40 2015 UTC,Look at the type of the variable itself.  char buf[500];   buf here is an array (not a pointer)  char *x;   x here is a pointer (not an array)  What the sizeof operator gives you depends on the type of the variable you're using as the operand.
C_Programming,3dkmpc,ezrik1414,1 point,Fri Jul 17 13:55:50 2015 UTC,"It should also be noted that if you declare x like char x [] = ""Hello""; then sizeof (x) will return 6."
C_Programming,3dkmpc,irgs,1 point,Mon Jul 20 16:48:07 2015 UTC,"You're treating write like fprintf. If you pipe that thing through hd(1), I bet there'll be a nul (\0) between Hello and Go.  Plus, char *x is different from char x[], like the other guy said."
C_Programming,3dk20f,Dijkstra112358,1 point,Thu Jul 16 22:14:13 2015 UTC,So far the macros I am using (which are very similar to the one's in my link.) work. I will continue to experiment and possibly update if something breaks
C_Programming,3dg0rt,elbingmiss,8,Wed Jul 15 23:53:46 2015 UTC,I don't understand what this project aims to do and why they think their goal is sensible.
C_Programming,3dg0rt,FUZxxl,5,Thu Jul 16 01:03:34 2015 UTC,Their site isn't exactly clear but it seems like it is supposed to be an operating system with built in support for distributed computing.  As in you would have 5 computers running it but they would behave as if they were one computer with multiple cores.  If you later needed more scaling you would just add another computer.
C_Programming,3dg0rt,Ceryn,12,Thu Jul 16 05:59:50 2015 UTC,The aim seems to be a modernization of plan9.
C_Programming,3dg0rt,dMenche,5,Thu Jul 16 07:47:09 2015 UTC,Yes. Just look at the shadow the Harvey OS mascot is casting. That's the shadow of Glenda the Plan 9 bunny mascot. Glenda for comparison: http://plan9.bell-labs.com/plan9/glenda.html
C_Programming,3dg0rt,cu_t,3,Thu Jul 16 08:30:58 2015 UTC,From the website   Harvey is an effort to get the Plan 9 code working with gcc and clang.
C_Programming,3dg0rt,xooxies,3,Thu Jul 16 15:52:11 2015 UTC,I don't see how that's useful in any way. Part of the Plan 9 concept is to keep the compilers simple and dumb; introducing a monolith like clang sounds like a bad idea in my opinion.
C_Programming,3dg0rt,FUZxxl,1 point,Fri Jul 17 05:04:59 2015 UTC,"Someone on the mailing list was ""amazed"" that you would say that.  I can see why someone might want to be able to compile C++ and (say) Qt on Plan 9; I can't say I comprehend their total obsession with having bash, though. It's harder to use than rc, and doesn't really make up for that by doing more for you than rc does."
C_Programming,3dg0rt,irgs,1 point,Sat Jul 18 14:32:47 2015 UTC,"Someone on the mailing list was ""amazed"" that you would say that.   Oh! Popcorn time! Can you send me a link to the corresponding mailing list archive?"
C_Programming,3dg0rt,FUZxxl,1 point,Sat Jul 18 14:56:31 2015 UTC,"eh, there's not much said other than what I said: https://groups.google.com/d/msg/harvey/tZ0jLPgBQyE/1kbqx_01hNoJ"
C_Programming,3dg0rt,irgs,1 point,Sat Jul 18 16:13:48 2015 UTC,Oh wow. I didn't know Ron Minnich is involved in this project. I met him in Berlin at a coreboot workshop two years ago. Super nice guy.
C_Programming,3dg0rt,FUZxxl,2,Sat Jul 18 16:17:34 2015 UTC,"Pretty clever name, really. In addition to being a Plan 9 reference, ""Harvey"" refers to the play/film Harvey where the main character has an invisible rabbit friend."
C_Programming,3dg0rt,skeeto,3,Thu Jul 16 23:49:15 2015 UTC,"As I've played with Plan 9 in the past, I'd absolutely love to see its concept in fresh code! My biggest problem was that the Plan 9 ecosystem was its own little world, that kind of hampered its usability for me.  Perhaps this could change now?"
C_Programming,3dg0rt,net_goblin,3,Thu Jul 16 16:22:25 2015 UTC,"Yes. We are working for that. One of the targets is to have a full posix compliance environment, implementing ape and a friendly and well known user interface. With native toolchain (for now compile in linux, run in harvey), bash and a multiplexed version of X11 through a new ttyfs in user space. I did a port of gcc 4.8 for plan9 so won't be difficult to have c++ and gtk, etc. Always keeping file server arch of the system. At this moment we are working in Go and local ahci disk. We need help and people. There are many things to do. For classic stuff lovers, it's there now as well. Except rio, not fully working for now. We focusing in bugs derived from porting entire system to a new architecture with callee model as is gcc."
C_Programming,3di2g4,EniasCailliau,1 point,Thu Jul 16 13:16:24 2015 UTC,"Sounds interesting! I'm a c programmer, but for embedded systems (currently in the IoT world) so I'm not sure if that is something you want to cover or not"
C_Programming,3di2g4,Heavyweight87,1 point,Thu Jul 16 22:33:55 2015 UTC,"That's great! IoT is up and rising and a lot of people are looking into it, searching for articles on how to start, opinions, platform questions etc. Drop me and email and we'll look into it."
C_Programming,3dh2q1,itonlyadds,8,Thu Jul 16 05:32:57 2015 UTC,"Let the implementors of malloc(), realloc() and free() worry about heap fragmentation. Heap allocator design is an enormous topic that you can waste years into. People have. And they came up with these standard library functions. While it's true that you could potentially manage your own in a way that's optimized for linked list, this is a substantial undertaking. Having written a general heap allocator in C, I can tell you now that it is near impossible to write a thread-safe allocator that is comparable in throughput and memory usage to stdlib functions.   You have to understand that malloc isn't a dumb function, neither is it trivial. It requests memory in pages from the kernel using sbrk(). It constructs lists of free contiguous memory ordered by size and stores this list inside the free blocks themselves. Realloc() and free() have memory coalescing built into them, they would be useless without it.   Allocating nodes in batches means you can't free a block until all nodes in that block are popped off, i.e. lots of dead memory. Moreso, there might not be a free block in the heap big enough for your node batch while there may be many small node sized free blocks. This will lead to the allocator requesting a whole new page of memory from the kernel.  TL;DR realloc() and free() are state of the art functions built to provide hyper-optimized throughput and memory usage. They already combat heap fragmentation internally much better than you can. You shouldn't request more memory than you need."
C_Programming,3dh2q1,lolzfeminism,2,Thu Jul 16 07:20:11 2015 UTC,"Alright. It looks like I have some reading to do on free, malloc, etc. and how they work. It looks like I should ditch that idea. Thank you for the helpful comment!"
C_Programming,3dh2q1,bunkoRtist,1 point,Thu Jul 16 17:09:10 2015 UTC,"If you're writing for a target running a desktop or enterprise-grade OS then what you've said is true. I used to code for VxWorks 5 and trusting the supplied malloc() would have been insane for our stacks (and an utter failure). It's not safe to assume that everyone always has a sophisticated kernel available to do the dirty work. Moreover, specialized heaps can be much more efficient both in speed and space due to the assumptions they're allowed to make."
C_Programming,3dh2q1,jedwardsol,5,Sat Jul 18 14:02:08 2015 UTC,"Step back and ask why are you worried about heap fragmentation?  Are you really worried? If so, do you have any evidence it is causing problems?  Or is this an academic exercise?  To answer your questions though .. The first cast is okay.  The list setup in the loop is wrong. By doing out+1+I you're working with list_head sized arithmetic but you want list_body.  I'd add another variable of type list_body* for doing that walk."
C_Programming,3dh2q1,net_goblin,1 point,Thu Jul 16 06:28:44 2015 UTC,"Ahh good catch, thank you. I was basically just spitballing here, so I don't remember if I used out in the actual function.    And yeah, I was doing the heap fragmentation thing mostly because I was curious if I could, but I am slowly realizing the details are far over my head. I think I will just ditch that idea.       Thank you for the helpful comments!"
C_Programming,3dh2q1,ruertar,5,Thu Jul 16 17:03:59 2015 UTC,"IMO you shouldn't worry about heap fragmentation.  I've you really have to worry about it, then it might be a hint that a linked list might be not the best data structure."
C_Programming,3dh2q1,GBGamer117,1 point,Thu Jul 16 16:27:45 2015 UTC,Yeah I'm starting to realize this. I'll try something else. Thank you!
C_Programming,3dh2q1,dumsubfilter,3,Thu Jul 16 17:10:59 2015 UTC,One place to start would be to use zero length arrays for the data portion of the node like:  struct node {   struct node *next;   char data[0]; };   Then allocate the node and data in one contiguous block.  But if you're really worried about fragmentation then you should choose another way of storing the data.  Try allocating contiguous blocks and reallocating them as it needs to grow.
C_Programming,3dh2q1,danielcamiel,2,Thu Jul 16 10:36:25 2015 UTC,"Yeah, it seems like a vector would be the best way to store this, and they're fairly simple to implement."
C_Programming,3ddci9,bart2019,15,Wed Jul 15 11:28:55 2015 UTC,"My impression is that all that #include does, is read the contents of the specified file and insert it into the source stream while compiling, instead of the #include line. Thus: pure macro expansion, where the macro is the contents of the whole file.   This impression is right. This is exactly what happens. Notice that the connection between header files and libraries exists only by convention. In fact, before C was standardized, many libraries didn't have header files at all! You were supposed to know what functions the library provides and you had to manually declare the functions you need.   How can the linker know what functions to include in the final program? Or perhaps, you may have to manually provide that info, for example in a make file? And if that's the case, are there any common automatic tools that do that ""paperwork"" for you?   The linker is a bit dumb. It looks for functions in all the files you tell it to look into. There are no files the linker implicitly looks at. When you call the C compiler to link your program like this:  cc -o program foo.o bar.o baz.o   The compiler invokes the linker ld like this:  ld -o program foo.o bar.o baz.o crt0.o -lc   Notice that the linker adds to further operands: The file crt0.o contains the startup code for the C runtime. This is the code that counts the number of arguments, initializes whatever needs to be initialized and then calls main. The second operand, -lc tells the linker to also look into the C library libc for functions. This is usually the only library that is implicitly searched.   Or perhaps, you may have to manually provide that info, for example in a make file?   If your program uses further libraries, you need to link them in explicitly as well. For instance, if your program uses certain mathematical functions, you need to link in the libm like this:  cc -o program foo.o bar.o baz.o -lm   This tells the linker to also look for functions in the libm.   And if that's the case, are there any common automatic tools that do that ""paperwork"" for you?   In general there isn't much automation that can be done. For the tedious task of finding out what options to specify to link a certain library (these can be different depending on platform), tools like libtool exist. For the tedious task of finding out if a library is installed and what version it has, tools like the autotools exist.  Plan 9 tried to improve the situation by adding a directive to header files that tells the compiler what library the header file corresponds to, but this extension never found its way into standard C."
C_Programming,3ddci9,FUZxxl,3,Wed Jul 15 11:46:21 2015 UTC,"Plan 9 tried to improve the situation by adding a directive to header files that tells the compiler what library the header file corresponds to, but this extension never found its way into standard C.   The C++ folks are working on a module system."
C_Programming,3ddci9,looneysquash,2,Wed Jul 15 23:00:19 2015 UTC,That's interesting. That's going to be tricky to get right without breaking existing code / libraries.
C_Programming,3ddci9,FUZxxl,5,Wed Jul 15 23:25:59 2015 UTC,Raymond Chen has had a long series on linking. It's a pretty good read.
C_Programming,3ddci9,Meefims,3,Wed Jul 15 11:45:08 2015 UTC,"The short answer: the linker processes all of the functions. When processing a function, it can see which other functions are called by that function.  It will find the other function (purely on a name-based search of the function name) and link the first function's call to end up on the second function.  The purpose of a function prototype is to ensure that the code emitted to do the function call is correct . By the time link-time rolls around, that is all done and dusted ."
C_Programming,3ddci9,OldWolf2,2,Wed Jul 15 14:40:18 2015 UTC,"My impression is that all that #include does, is read the contents of the specified file and insert it into the source stream while compiling, instead of the #include line.   Exactly. Basically, you're telling the compiler: ""Well, this function: blah(foo, bar) exists. And this fuction: baz(qux, xyzzy) exists. And this function: ..."" all in advance, before you use any of those functions. You have to tell the compiler about functions in advance (except main()), or the compiler will bitch and whine that you didn't tell it. :P   How can the linker know what functions to include in the final program?    Each .o file (which is what the compiler makes from each of your .c files (even if you don't see them being made, because it's happening behind the scenes)) has a ""symbol table"", which is basically a table full of the names of things that are in that file. Or at least, the externally visible things. (A variable inside a function can't be seen outside the function, so that doesn't make it into the symbol table.)   How can the linker know what functions to include in the final program?   It reads all the symbol tables from all the .o files (and the .lib files, and .so files, and etc, etc, etc.)"
C_Programming,3ddci9,ModernRonin,3,Wed Jul 15 19:51:31 2015 UTC,"You have to tell the compiler about functions in advance (except main()), or the compiler will bitch and whine that you didn't tell it. :P   Correction: You have to tell the compiler about functions before you use them and that only since C99. main() is no exception: By defining main(), you tell the compiler about main(). The same is valid for any other function, too. If you were to use main() before defining it, you had to declare it too.  In C89, the situation is different. If the function returns an int and all its arguments obey K&R-rules (i.e. no argument smaller than int and no arguments of type float), then you don't need to declare the function because the compiler assumes an undeclared function returns an int. If the function returns something else but its arguments obey K&R-rules, an old-style definition (i.e. without a prototype, like int main();) suffices but no type checking on the arguments can be done. Only in the case that the argument list is not K&R-compliant you need to specify a proper prototype.   (A variable inside a function can't be seen outside the function, so that doesn't make it into the symbol table.)   Not necessarily. For instance, clang generates symbols for variables with static storage duration even if they are local."
C_Programming,3ddci9,FUZxxl,2,Wed Jul 15 22:44:13 2015 UTC,"main() is no exception: By defining main(), you tell the compiler about main().   Fair point. I guess I should have said that you don't need a forward declartion of a function prototype for main(), because the definition alone suffices.   clang generates symbols for variables with static storage duration even if they are local.   That's odd. Why does it do that?"
C_Programming,3ddci9,ModernRonin,3,Thu Jul 16 02:39:27 2015 UTC,"That's odd. Why does it do that?   A static variable occupies space. By generating a symbol for this variable, the compiler makes it possible for you to observe how much space is consumed by the variable with the nm command."
C_Programming,3ddci9,FUZxxl,-5,Thu Jul 16 09:19:43 2015 UTC,I'm not sure you can explain c programming to a 5 year old.
C_Programming,3dfu5w,ThePantsThief,1 point,Wed Jul 15 23:00:49 2015 UTC,"I don't think there's any way to do this with __VA_ARGS__.  The way this is usually done is with a set of macros, one of which starts the struct, one that ends it, and one that defines each element."
C_Programming,3dfu5w,boredcircuits,1 point,Wed Jul 15 23:13:22 2015 UTC,"I can see using two macros, but that means wrapping each argument in a macro… which isn't much less work that just typing it out myself. Hmmm.  Thanks anyway!"
C_Programming,3dfu5w,boredcircuits,0,Wed Jul 15 23:15:25 2015 UTC,"If you can use C++ instead of C, there's some metaprogramming techniques that might do what you want.  You might even be able to just use a std::tuple, depending on what you need."
C_Programming,3dfu5w,FUZxxl,1 point,Wed Jul 15 23:48:26 2015 UTC,Can you show an actually working example? I'm fairly certain the phrase generated isn't valid C.
C_Programming,3dfu5w,FUZxxl,1 point,Wed Jul 15 23:17:27 2015 UTC,"It might not be (I'm not super familiar with C) but what I really want is to just figure out how to prepend or postfix something to each argument of a macro, such that BAR(foo, x, y, z); expands to  some_keyword foo {     _something_else x;     _something_else y;     _something_else z; }"
C_Programming,3dfu5w,FUZxxl,1 point,Wed Jul 15 23:22:17 2015 UTC,"Ah, I see. I don't think this is possible, but alas I'm not an expert in cpp voodoo so please take my opinion with a grain of salt."
C_Programming,3dfu5w,Rhomboid,1 point,Wed Jul 15 23:24:57 2015 UTC,I'm starting to think not either. Thanks anyway!
C_Programming,3dfu5w,Rhomboid,1 point,Wed Jul 15 23:25:19 2015 UTC,"If you need a more powerful preprocessor, use m4; this preprocessor is available on all Unix systems."
C_Programming,3dfu5w,jotux,1 point,Wed Jul 15 23:27:06 2015 UTC,Will do!
C_Programming,3dbwy9,anonymousperson28,2,Wed Jul 15 01:56:10 2015 UTC,"I'm not too familiar with Cython, but it seems like you should be doing something like this.  cdef blah():     cdef:         double **A         ...         double *p      A = <double **> malloc(sizeof(double *) * N)     p = <double *> malloc(sizeof(double) * N * N)     if A == NULL or p == NULL:         free(A)         free(p)         ...     for i in range(N):         A[i] = &p[i * N]     ...      dgesvd(A, N, N, ...)      free(A[0])     free(A)     ..."
C_Programming,3dbwy9,danielcamiel,2,Wed Jul 15 11:51:54 2015 UTC,"The address of a double * is of type double **:  double a = 5.0; double * a_ptr = &a; double ** a_dptr = &a_ptr;      A_p = <double *> malloc(sizeof(double) * N)     U_p = <double *> malloc(sizeof(double) * N)     VT_p = <double *> malloc(sizeof(double) * N)    A_p , U_p and VT_p are all pointers. You can use:  malloc(sizeof(double*))      free(A_p)     free(U_p)     free(VT_p)    You may want to consider using the stack."
C_Programming,3dbwy9,f5f5f5f5f5f5f5f5f5f5,2,Wed Jul 15 17:14:41 2015 UTC,"The problem is that numpy arrays and Cython memory views are one big contiguous block of memory, whereas dgesvd requires you to pass you a pointer-to-pointer.  You have the correct idea that you need to access the double * value corresponding to each row, and save it as the corresponding value in A_p, U_p, and VT_p, but you are not doing it right.  For example, after A_p = <double *> malloc... line, you assign A_p N times in the loop.  All of that is equivalent to just one statement: A_p = &A[N-1, 0].  You discard previous assignments and also have a memory leak because the pointers returned by malloc are not accessible to you anymore.  Instead, you should do the following:  cdef blah():     cdef:         double[:] S         double[:,:] A, U, VT         double **A_p, **U_p, **VT_p      U = np.zeros((N,N))     VT = np.zeros((N,N))     A = np.zeros((N,N))     S = np.zeros(N)      # You can also use ""sizeof(double *)"" below.     A_p = <double **> malloc(sizeof(A_p[0]) * N)     U_p = <double **> malloc(sizeof(U_p[0]) * N)     VT_p = <double **> malloc(sizeof(VT_p[0]) * N)      for i in range(N):         A_p[i] = <double *>&A[i, 0]         U_p[i] = <double *>&U[i, 0]         VT_p[i] = <double *>&VT[i, 0]      dgesvd(A_p, N, N, &S[0], U_p, VT_p)      free(A_p)     free(U_p)     free(VT_p)   Note that I changed the type of A_p etc., changed the assignments in the loop, and the way dgesvd is called.  I did not test the above code, but did test it using a simpler, equivalent code that calls an external C function (that I wrote) that takes a double **."
C_Programming,3dcicl,Aakash23,7,Wed Jul 15 04:58:16 2015 UTC,"You can't allocate large arrays on the stack.  The stack is for small, temporary allocations, not bulk storage.  Trying to allocate a million longs on the stack is causing a stack overflow.  Either allocate that memory dynamically (with malloc() or calloc()) or give the variable static storage duration (either by declaring it at global scope or at function scope with the static storage class specifier.)"
C_Programming,3dcicl,Rhomboid,1 point,Wed Jul 15 06:09:30 2015 UTC,"Thank you, it worked. I just declared all the variables static. Would you explain what did static variables made the difference in the code?"
C_Programming,3dcicl,psu72,1 point,Wed Jul 15 11:15:09 2015 UTC,"Variables which are declared as static are not stored on the stack.  They're stored in a different place in your program that accommodates ""bulk storage"".  They also have a different lifetime, but that's not really relevant to your program"
C_Programming,3dcicl,Poddster,2,Mon Jul 20 13:11:54 2015 UTC,"I've reformatted your progam for you, as your old one was completely unreadable. I hope this version is only how you mangled it onto reddit, and not how it appears when you edit it normally.  http://pastebin.com/3zmdttWc"
C_Programming,3dcicl,raevnos,1 point,Wed Jul 15 07:33:23 2015 UTC,Your program doesn't print any error messages. So what error are you seeing?
C_Programming,3dcicl,jedwardsol,1 point,Wed Jul 15 05:10:03 2015 UTC,"I have saved this program under the filename ""program.exe"". So when I build and run this program in IDE, an error message pops up showing program.exe has stopped working."
C_Programming,3d9nkh,altorelievo,3,Tue Jul 14 16:12:47 2015 UTC,Nitpick: You could use __FILE__ instead of manually specifying the file name everywhere.
C_Programming,3d9nkh,FUZxxl,1 point,Tue Jul 14 22:52:51 2015 UTC,I don't think that's a nitpick at all.  Those will be much better than how I have it now.
C_Programming,3d9nkh,FUZxxl,2,Wed Jul 15 00:33:05 2015 UTC,"Otherwise your code looks fine. Why are you setting the umask though? Is there a specific reason why you don't want to respect the user's umask? You should also do more and better error checking. For instance, you don't check the write calls (these may fail) and you don't give useful error messages (e.g. when getenv fails)."
C_Programming,3d9nkh,FUZxxl,1 point,Wed Jul 15 00:37:50 2015 UTC,"The error handling can be much improved.  I did think that logging the line, call, function, and file were going in the right direction for something of a traceback.  The errno with the matching description will be better.  The umask  was intentional to set the file mode.  I had picked up setting the daemon by researching around, here specifically line 13 is just one place I've seen it recommended to set the file mode.  Is there a reason to leave the parents file permissions?  Update:  In further reading of whether it is best to set permissions, this stackoverflow  post is agreeing with your view on this matter."
C_Programming,3d9nkh,jotux,1 point,Wed Jul 15 01:35:56 2015 UTC,"The error handling can be much improved. I did think that logging the line, call, function, and file were going in the right direction for something of a traceback. The errno with the matching description will be better.   Notice that you don't want to log any single error (some errors that may occur are unimportant), but it's hard to say which errors you don't want to log."
C_Programming,3d9nkh,Leandros99,3,Wed Jul 15 10:10:47 2015 UTC,"You should read about the FILE, LINE, and FUNCTION macros."
C_Programming,3d9nkh,maep,1 point,Tue Jul 14 23:27:12 2015 UTC,Will do and I think you and @FUZxxl posted at about the same time.
C_Programming,3d9nkh,MartenBE,6,Wed Jul 15 00:34:18 2015 UTC,Here are a few:  0x04d5f238 0x29af5b4c 0x00ac5dff  Hope they're helpful.
C_Programming,3d9nkh,Asmx86CCpp,0,Tue Jul 14 22:15:41 2015 UTC,"For a second I thought these might have been pointers to functions in your symbol table that you were recommending to use and thought ""well, how is this going to be helpful..."" ;)"
C_Programming,3d7c6p,poolec4,7,Tue Jul 14 02:15:37 2015 UTC,"I am wondering if the variable must be locked before reading it even if the second thread is not writing to the variable in any way?   No, but you have to be absolutely, positively sure that the other thread isn't actually writing to the variable at the same time. Unless you use a mutex, you likely aren't.  Also, it's totally possible for the compiler to optimize away the variable read since it assumes the value hasn't changed. The 'volatile' keyword makes the program take into account that the data can change between accesses."
C_Programming,3d7c6p,Aransentin,5,Tue Jul 14 02:24:37 2015 UTC,Relevant...  https://www.reddit.com/r/programming/comments/2z9iza/volatile_almost_useless_for_multithreaded/
C_Programming,3d7c6p,RumbuncTheRadiant,2,Tue Jul 14 05:00:19 2015 UTC,"It really depends on the platform. As an embedded developer, I use volatile a lot. I also don't use CPUs that have a concept of threads..... so there's that.  Volatile has its uses. It's not sufficient in and of itself, but it often helps."
C_Programming,3d7c6p,dmc_2930,2,Tue Jul 14 13:55:40 2015 UTC,Also: https://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt
C_Programming,3d7c6p,skeeto,2,Tue Jul 14 15:55:36 2015 UTC,Put code in paste bin or ideone. Maybe we can identify what's going wrong.
C_Programming,3d7c6p,maddoc74,1 point,Tue Jul 14 02:26:27 2015 UTC,"Ok, here it is. The variable in question is del_t_IMU which is written to on line 451. It is read on line 668 when it is printed to a file. I place a printf directly above that while I was debugging."
C_Programming,3d7c6p,jedwardsol,1 point,Tue Jul 14 02:38:43 2015 UTC,What value does it print? And what do you think it should be?
C_Programming,3d7c6p,jedwardsol,1 point,Tue Jul 14 03:25:59 2015 UTC,"It always prints 0.000002 when the expected value is changing and somewhere between 0.000080 and 0.000120. The value is time in milliseconds between loops.  If you print this value inside of the thread that it is written to inside of, it does print the correct value."
C_Programming,3d7c6p,jedwardsol,2,Tue Jul 14 03:29:52 2015 UTC,"I expect you're suffering from the low resolution of the hardware timer then.  Gettimeofday may claim to give microsecond resolution but PC hardware ticks less frequently. If this is PC hardware, and you need this resolution then you'll need to look at the timestamp counter (rdtsc instruction) If it isn't PC hardware then it may have a higher resolution clock."
C_Programming,3d7c6p,bigbassdaddy,1 point,Tue Jul 14 03:33:56 2015 UTC,"I think I understand what your saying, but why would the value inside of thread 1 be correct while the same variable outside of that thread is wrong?"
C_Programming,3cy2b0,sepehrhm,8,Sat Jul 11 20:31:15 2015 UTC,"I'd probably start out with something easily parallelizable, where you're running through lots of for loops and arrays. Like image generation/processing. You could do fractal generators, image blurrers, etc."
C_Programming,3cy2b0,casey12141,1 point,Sat Jul 11 21:59:26 2015 UTC,"That is a good idea, I am thinking about video encoding from my webcam."
C_Programming,3cy2b0,fredmorcos,2,Sun Jul 12 05:13:45 2015 UTC,"Hey! I've done something with the mandelbrot fractal a few years ago, I have an archive on Github of old stuff:  https://github.com/fredmorcos/archive/tree/master/Projects  Look for ""mandelbrot"", there are a few versions of it and one of them is using pthreads.  Also, if you're interested as well, look for parallel_matrix_ops and you can find a multi-process matrix multiplication using shared memory."
C_Programming,3cy2b0,asaprocky1,6,Sun Jul 12 09:17:09 2015 UTC,Make a queue framework where one thread adds tasks at a different rate than the worker thread processes them
C_Programming,3cy2b0,GenTiradentes,1 point,Sun Jul 12 01:06:44 2015 UTC,Something like tbb?  https://www.threadingbuildingblocks.org/
C_Programming,3cy2b0,squidgyhead,3,Sun Jul 12 05:14:23 2015 UTC,"I've done a few projects using pthreads, including a flocking simulation (video), and an OpenCL benchmark.  Games, demos, and simulations are especially fun for me, obviously. Write a raytracer, a hash cracker, or a 2d physics engine. All of these are embarrassingly parallel, and accessible for intermediately skilled programmers."
C_Programming,3cy2b0,GenTiradentes,1 point,Sun Jul 12 04:07:51 2015 UTC,I have no idea what any of those mean.  Is a hash cracker a hash table cracker?  And what is the use for OpenCL?  Sorry I am still a beginner in all this.
C_Programming,3cy2b0,squidgyhead,2,Sun Jul 12 05:15:36 2015 UTC,OpenCL is a programming language which allows one to use CPUs and GPUs in your code.  It uses a different model than pthreads.
C_Programming,3cy2b0,GenTiradentes,2,Sun Jul 12 07:13:57 2015 UTC,A hash cracker for reversing hashes. The type commonly used for storing passwords.
C_Programming,3cy2b0,squidgyhead,1 point,Sun Jul 12 08:15:23 2015 UTC,"Can you tell me about your OpenCL benchmark?  I've been using clFFT to bench things (and then compare with FFTW on the CPU), but that's just one perspective."
C_Programming,3cy2b0,dvhh,2,Sun Jul 12 07:15:32 2015 UTC,"It's a program that calculates the fused multiply accumulate single-precision floating-point performance of CL devices. It generates a couple of random matrices on the CPU that are used as the inputs for the kernel, then it runs and times the CPU kernel, the CL kernel, and compares the outputs from both. It lets you know the maximum real-world performance of your hardware and CL implementation combined.  I'm still working on it, it's nowhere near being ready to show off, but it does adequately show the difference between running code on the CPU using threads, and running it on CL devices.  Among other things, it shows how to initialize and use CL platforms and devices, how to load a kernel from a file, compile it, and link it into a CL program. All of the interesting boilerplate is in cl_common.c.  I'm still working on a clean, object oriented way of creating multiple benchmarks that can be added to a list and executed at runtime. I'd like to be able to benchmark integer and double FP performance as well."
C_Programming,3cy2b0,Asmx86CCpp,3,Sun Jul 12 08:12:04 2015 UTC,"If you're interested in pthreads, you might also like OpenMP, which adds ""#pragma""s to parallelize loops and other stuff.  It also works on Windows, unlike pthreads.  OpenMP is also (IMHO) simpler to program, and really allows for some interesting features."
C_Programming,3cy2b0,Asmx86CCpp,2,Sun Jul 12 11:46:59 2015 UTC,To be fair there is a pthread lib for windows.  But OpenMP is probably the easiest way to do as it requires way less code to parallelize it.
C_Programming,3cy2b0,jijijijim,2,Thu Jul 16 03:03:47 2015 UTC,"You can make a program to sort a large array of numbers or strings. Create a array of random numbers by using rand(). Create a new thread if array is larger than a predefined number and split the numbers between them. You want to recall the sort method in the current thread with the half of the numbers (recursive). Start sorting if the array in this thread is smaller than the predefined number, if not continue creating new threads and splitting. When the thread you created has finished sorting and and the current thread is also done with sorting, merge these results using threads. In the end the main thread will have the result of the array fully sorted.  Note: i did this in C++11 using std::thread, std::vector, std::sort and std::inplace_merge, but it can be done using pure C and pthreads."
C_Programming,3cy2b0,k0t0n0,1 point,Sun Jul 12 03:02:52 2015 UTC,Thanks for the idea!  Is it true that STL's thread library is built based on pthreads?
C_Programming,3cy2b0,c-jm,1 point,Sun Jul 12 05:16:19 2015 UTC,"I am not sure, but found StackOverflow question about it.  so if your compiling with g++ you can see this information from:  g++ -v   Look for Thread model, if it's posix, then yes."
C_Programming,3cuq51,shadwblade2652,10,Fri Jul 10 22:53:40 2015 UTC,"It's good to get basic things working, then start tuning it to handle more specific things, like arbitrary line grouping. But focus on getting a CSV reader working first, then start looking into interpreting the fields.   for (i=0;i<strlen(clist);i++)  for (i=0;i<strlen(str);i++)  m=strlen(str); for (i=0;i<m;i++)   In C, the idiom you would want to use for accessing each character in a string is  for (i = 0; str[i] != '\0'; i++)     ...;   This avoids the call strlen, which could be called as many as strlen(str)+1 times in the first two instances.  Aim to write as little as possible. The in function can be replaced with strchr, strsp could be implemented in terms of strtok or a combination of strspn/strcspn.  main needs a rewrite. You should check the return values of malloc, fopen, and fgets and report useful diagnostics when they fail. In the case of fgets, checking feof isn't enough, it will return 0 if something goes wrong with the input device. Better to compare the return value of fgets against NULL. Assuming you have a limit on the maximum valid line, the following would be a good way to drive the main loop.  while (fgets(line, MAX_LINE + 1, fin) != NULL)     ...;   You can then handle each line in the file in that way, and if a line doesn't contain the '\n' character, then the maximum line constraint was violated. One test I would do first, is read the CSV into an internal format, then see if you can produce the exact same file. Try it on a bunch of different CSV files to test the robustness of your reader."
C_Programming,3cuq51,danielcamiel,1 point,Sat Jul 11 01:00:15 2015 UTC,"The first half of your post is just micro-optimization which , IMHO, is not relevant to a C beginner. Focus on writing clear code which works, and worry about minutiae later.   You seem to be unaware that non-antique compilers will optimize this code along the lines that you suggest anyway."
C_Programming,3cuq51,OldWolf2,3,Sat Jul 11 05:35:28 2015 UTC,string.h includes a function for splitting strings called strtok(). You can use it to replace some of the code in your split function.
C_Programming,3cuq51,f5f5f5f5f5f5f5f5f5f5,2,Sat Jul 11 01:28:35 2015 UTC,The combination of fgets and sscanf seems like a much better choice here.
C_Programming,3cuq51,dumsubfilter,-4,Sat Jul 11 17:43:57 2015 UTC,"rewrite it in perl or python?  Any reason it needs to be in C? This is solvable in C, of course, just, you could do it much easier on a higher level language."
C_Programming,3cuq51,matjam,1 point,Sat Jul 11 00:01:12 2015 UTC,I'm not too familiar with how the code works so I'm not sure I could rewrite it.
C_Programming,3cuq51,seanrowens,1 point,Sat Jul 11 00:29:35 2015 UTC,"How big are your csv files?  I mean hour many lines? Thousands? Hundreds of thousands? Millions?  If they are in the large side, how often do you need to run this program and how quickly do you really need it to run?"
C_Programming,3cuq51,seanrowens,3,Sat Jul 11 04:36:25 2015 UTC,approximately 100k lines per csv.
C_Programming,3cuq51,seanrowens,2,Sat Jul 11 06:15:52 2015 UTC,"In that case you really are better off rewriting it in a higher level language unless there are other reasons to leave it in C, like integration or something."
C_Programming,3cuq51,seanrowens,1 point,Sat Jul 11 22:44:44 2015 UTC,Or if you really need it to run very fast because you run it every minute or something like that.
C_Programming,3cuq51,seanrowens,1 point,Sat Jul 11 22:45:53 2015 UTC,"The C program seems pretty short, I'm on my phone right now, if I get a chance I'll try to review it and see if I can explain what it's doing more clearly."
C_Programming,3cuq51,matjam,1 point,Sat Jul 11 22:48:27 2015 UTC,"OK; most of that code is for the parsing of the commas, etc, i.e. splitting the lines up into fields.  Then it repeatedly read five lines (into the buffers allocated into the buff5 array) and then repeats the same set of code five times, looking for a different field/line from the five lines, each time.  Below is the first set of code, looking for the line with ""Top"" in it, commented to explain what it is doing;      // find the line (of the five) containing the string ""Top""     for (i=0;i<5;i++) if (strstr(buff5[i],""Top"")) break;      // Note that at this point i contains the index of the line of     // the string containing the word ""Top"" - or if it wasn't found, the variable i will     // be set to 5.  The buff5 array only has 5 things in it, and     // they are indexed from 0 to 4.  If i is 5, bad things will     // happen so we better hope we found it.  This code isn't not very well     // written.      // split the line into items     n=strspl(buff5[i],delim,item);      // The code assumes that there were 10 items, hence the last     // item will be number 9 and will have the last item and the     // newline, this gets rid of the newline.       cp=strchr(item[9],'\n');     *cp='\0';      // copy the 9th/last item to vtop     strcpy(vtop,item[9]);   Once it has found all five of the things it needs it just prints them to the output file.  It repeats the sequence of ""read 5 lines, look for Top, look for Late, look for Window, look for Correct, look for Time, print out one line"" until it can't read another set of five lines."
C_Programming,3co44r,Aakash23,61,Thu Jul 9 12:28:38 2015 UTC,"Subtracting two pointers makes sense: it returns an integer that represents the distance between them, measured in units of the type pointed to.  This dovetails with the fact that you can add an integer to a pointer to advance it by that many units, or subtract an integer from a pointer to move it backwards by that many units.  But adding two pointers?  Nonsense.  What would that even mean?  The sum of the two memory addresses?  That value is meaningless.  Therefore adding two pointers is not a valid operation.  Think about it like addresses on a street.  What's the difference between 109 Meadow Ave and 105 Meadow Ave?  The former is two houses down the street from the latter, so the result is the integer 2.  Now what's 105 Meadow Ave plus 107 Meadow Ave?  ....  Nothing."
C_Programming,3co44r,Rhomboid,18,Thu Jul 9 12:35:49 2015 UTC,"A useful analogy is dates, e.g. it makes sense to subtract two dates: July 4th - July 1st = 3 days, but adding two dates does not make sense, e.g. what would July 4th + July 1st mean ?"
C_Programming,3co44r,SantaCruzDad,18,Thu Jul 9 14:56:47 2015 UTC,"Duodecember 5th, obviously."
C_Programming,3co44r,rabidcow,3,Thu Jul 9 16:16:01 2015 UTC,"Addresses are Torsors. I know that doesn't help you learn C, but you've seen the essence of the problem before, wearing a different disguise, so there is something deep here to chew on."
C_Programming,3co44r,AlanCrowe,7,Thu Jul 9 19:23:41 2015 UTC,If you are thinking of pointers as some sort of glorified integer... stop doing that right now. It will only lead you to misconceptions.
C_Programming,3co44r,OldWolf2,3,Thu Jul 9 12:46:15 2015 UTC,"ok, i have a question:  using simple integer numbers to represent pointer addresses:  pointer 1 address:  9907 pointer 2 address:  9913  if you subtract pointer1 from pointer2, you get 6  if you add them, you get 18000 and something...most certainly a dodgy area of memory to play with.   BUT, what happens if you subtract pointer 2 from pointer 1?"
C_Programming,3co44r,cehmu,5,Thu Jul 9 13:06:05 2015 UTC,"Then you get a ptrdiff_t with value -6, and I'd assume you could add it to other pointers to go back 6 elements."
C_Programming,3co44r,Pronouns,-3,Thu Jul 9 13:34:03 2015 UTC,"Other people have answered your question, so I'm just going to tell you that subtracting pointers is something that you usually should not be doing."
C_Programming,3co44r,nevinera,1 point,Thu Jul 9 15:49:34 2015 UTC,"Why the downvote? It's on every style guide I've read - the problem is that subtracting pointers has undefined behavior in the case that the pointers aren't pointers into the same. I've never seen any piece of code where that style is clearer than using offsets, and it gets optimized into the same machine code by the compiler anyway."
C_Programming,3co44r,nevinera,2,Fri Jul 10 15:46:25 2015 UTC,"So don't subtract pointers unless they point to elements of the same array object.  There's no good reason to extend that to a rule that you should avoid subtracting pointers in general.  A concrete example: I've had cases where I have a pointer to an object, I know the object is an element of a particular array, and I need the index. Subtracting the address of the 0th element of the array from the pointer gives me the index.  The alternative would be a loop that compares the pointer for equality to the address of each element of the array (something I've done when I'm not 100% sure it's an element of the array)."
C_Programming,3co44r,_kst_,1 point,Sun Jul 12 19:46:43 2015 UTC,"No, the typical alternative is to pass the array alongside offsets into it."
C_Programming,3co44r,nevinera,1 point,Sun Jul 12 23:09:32 2015 UTC,"Changing the code in that way was not an option.  The pointer was to one of a collection of objects, corresponding to devices. The code that works with the devices doesn't, and shouldn't, care what the index is -- but I needed to know it for debugging purposes.  Sure, any time you subtract pointers, there's likely to be an alternative that doesn't require subtracting pointers. But it's a feature of the language, and it's reliable when used correctly."
C_Programming,3co44r,_kst_,1 point,Sun Jul 12 23:43:27 2015 UTC,"If you can't change code to make it clearer, then you can't. I'm not getting on your case here, I was conveying information from the style guides on something that should usually be avoided as confusing style. There are a lot of features of C that should be used only when necessary, because they tend to produce unclear code.  My personal policy is that if a function can't be understood by someone that doesn't know C, you should fix it."
C_Programming,3co44r,nevinera,1 point,Mon Jul 13 15:42:04 2015 UTC,"I disagree. The audience for C code is not (or at least should not be) people who don't know C.  Certainly there's a cost in using obscure features, but one can go too far in ""dumbing down"" code."
C_Programming,3co44r,_kst_,2,Mon Jul 13 17:22:06 2015 UTC,"If you're going to do such a thing, at least use intptr_t or uintptr_t instead."
C_Programming,3co44r,maep,1 point,Thu Jul 9 12:42:20 2015 UTC,"Why, so you can get a meaningless number as the result?"
C_Programming,3co44r,_kst_,1 point,Thu Jul 9 12:49:02 2015 UTC,There are other operations you can't do on pointers which may be useful. xor linked lists for example.
C_Programming,3co44r,maep,1 point,Sun Jul 12 19:45:43 2015 UTC,"Then you are adding two integers, not two pointers"
C_Programming,3clmfb,hacatu,3,Wed Jul 8 21:30:55 2015 UTC,The only way is to use macro and to actually declare a whole new type that you will be able to use.  Not really practical. Why not void* anyway ?
C_Programming,3clmfb,GODZILLAFLAMETHROWER,2,Thu Jul 9 08:16:37 2015 UTC,"The typedef macros (eg HAC_VEC_T_NEW) are unfortunately needed because the types struct {int a;} and struct {int a;} are not compatible.  As for void pointers, they create space and time overhead and lose type information, and taking the data size into account adds complexity.  In most cases I would agree these disadvantages are outweighed by debugging and encapsulation benefits."
C_Programming,3clmfb,GODZILLAFLAMETHROWER,1 point,Thu Jul 9 16:00:17 2015 UTC,"Uh oh, didn't see it was a link to your code actually, I thought you were asking a question.  OK, then we agree, it's either void pointers or macro. I will look into your solution, it's always interesting to see how someone managed to write this kind of stuff, even if extremely frequent."
C_Programming,3clmfb,DSMan195276,2,Thu Jul 9 17:51:46 2015 UTC,"I've written a few setups like this, though it wasn't designed exactly the same. They definitely can be fairly convenient, though I much prefer using container_of intrusive setups when I can (Though, these are generally cases where you can't).  Generally speaking, you implement your code by using statement-expressions in macros, where as my implementation I use static inline functions in the headers. IMO, it's a bit cleaner because it doesn't use any extensions and everything doesn't have to be in a macro on the same line (or extended line). static functions won't be exported, so it's safe to put them in headers even if it's not always ideal. Of course, like your code, it does result in code duplication. Generally this doesn't matter for the simple types being created though, because you'd want to inline their code anyway because it's generally short and inlining can really allow the compiler to improve the code.  Also worth pointing out, you can really improve your WITH and similar statements using a bit of complex macro's to essentially define new statements like WITH and FOREACH. You can get a good overview of the idea here, which is where I first learned about it. Personally I do like the use of it as long as it's use is fairly self-explanatory and not everywhere. My hobby OS includes a using statement, which is essentially your 'WITH' statement, but allows a statement block (And an 'else' block in the event the statements fails. For each, an 'else' block to run if a file can't be opened). Here's a simple spinlock 'using' statement being used - Note that spinlocks can't fail, so it doesn't have the 'else' block.  For 'foreach', you can make them act like actual 'for' loops, which is what I do (And a technique used a lot in the Linux kernel code, among others). This is how I defined a foreach for my generic intrusive 'list' setup (Almost identical to the Linux Kernel's intrusive list setup), and here is it being used to iterate over all the items in a list. More complex foreach statements can be achieved using the macro statement stuff from above to allow declaring variables within the scope of the for loop. The advantage that they offer to just using, say, two nested 'for' loops is that you can make 'break' and 'continue' work as expected. The disadvantage is obviously complexity."
C_Programming,3clmfb,DSMan195276,1 point,Thu Jul 9 14:46:24 2015 UTC,"I really like that idea for with statements.  Mwahaha.  And debugging code using this can be bad because of the one line problem, but if I format the expanded code it's easier.  I would of course prefer functions, but they aren't flexible enough unfortunately."
C_Programming,3clmfb,DSMan195276,1 point,Thu Jul 9 15:37:11 2015 UTC,"The one-line problem is going to make these things not work with your macros sadly, because it makes use of the line-number. When your macros crunch into one line from the pre-processor, if you use, say, two FOREACH in a single macro, then you're just going to get duplicate labels and it won't compile.  Generally speaking, I was able to achieve what you did by using some macros that lead into some static inline functions to do the actual work. Even with vectors and such, a lot of it can be done generically in static inline functions by using a void * and passing a few sizes, and then handling the non-generic stuff back in the macro. Resizing, for example, is a case where doing it generically with void * makes no difference then doing it with some other type of pointer. You don't lose any of the type-safety that you gain from having the vector not use void *, by casting it into a void * to do the resize.  And, of course, container_of fixes the problem entirely when you can use it because you don't define your data-structure with the data it's going to holding, so all the functions are generic to your data-structure, and you can just write static inline functions to take those struct's, and then use container_of to get your original struct back after you call those static inline functions. The Linux Kernel's Red-Black tree implementation does this, and I have my own implementations of both RB and AVL which does it using container_of, but they're not completed as of yet (And probably won't because I don't have a use for them ATM)."
C_Programming,3clmfb,Drainedsoul,1 point,Thu Jul 9 17:13:29 2015 UTC,Could the use of container_of also be obtained by casting a struct {node node; data data;} to a struct {node node;}?
C_Programming,3cm0fi,TheRedPepper,3,Wed Jul 8 23:19:05 2015 UTC,"It all depends on what you are trying to accomplish.  Any more details on what you will be using this linked list for?  In general, linked lists shouldn't require you to be copying object data around though."
C_Programming,3cm0fi,rafleury,2,Wed Jul 8 23:22:23 2015 UTC,It is going to be the basis of a simple JSON library. It will be replaced for something faster or will be modified to be faster. The concept remains. Is it a good idea to make copies of data to be stored in a data structure and return a copy of the copy when accessed.   Sending and receiving copies of data might be only useful in a very primitive database like data structure.
C_Programming,3cm0fi,studioidefix,2,Wed Jul 8 23:41:49 2015 UTC,"set by passing and assigning a pointer to a memory location. I am wondering whether I should copy the object the pointer being passed to be used in the new node into a new location.    This wording is confusing as to what you're trying to do, but you might want to take a look at the FreeBSD implementations or how the linux kernel does this."
C_Programming,3cm0fi,studioidefix,1 point,Thu Jul 9 00:22:17 2015 UTC,Should I post the code?
C_Programming,3cm0fi,studioidefix,1 point,Thu Jul 9 01:07:56 2015 UTC,"Yes ! There is no ""correct way"", but it might help flag any errors you have"
C_Programming,3cm0fi,studioidefix,2,Thu Jul 9 01:15:51 2015 UTC,no hating please   https://github.com/TheRedPepper/DeltaLib
C_Programming,3cm0fi,net_goblin,1 point,Thu Jul 9 01:30:26 2015 UTC,"So I can think of optimizations. You can optimize  prevEnd = list->end; prevEnd->next = tempNode; list->end = tempNode;   by doing   list->end->next = tempNode list->end = tempNode;   Your begin & end pointers are only used in the head, so it's kinda a waste to allocate that for every node. Just have a structure that has list head, & end, you don't need anything else. Most people also use a hollow head with head->next = head implying an empty list. List size is rarely used with linked lists. You can turn this into a doubly linked list, so that head->prev gives you last node, with head->prev == head->next == head implying empty list. You can also skip the hollow head and use (!head) to imply empty list.  Your code is not wrong per se, just more complicated than it has to be"
C_Programming,3cm0fi,maep,1 point,Thu Jul 9 01:37:37 2015 UTC,I thank you for your help. I believed a single linked list was the best at the time to minimize memory overhead. I am going to do a rewrite for double link by this weekend. Thank you again
C_Programming,3cm0fi,net_goblin,1 point,Thu Jul 9 02:22:32 2015 UTC,"Don't go for the doubly linked if you don't have to, but try and reduce the complexity of your code. I can probably give some samples of you like.   Think of it this way though, a doubly linked list node would have a prev, next & data pointer, or 24 bytes on a 64 bit machine. Your singly linked list has a being, end & data pointer so you're using the same amount of space as a doubly linked list node while implementing a singly linked list."
C_Programming,3cm0fi,studioidefix,2,Thu Jul 9 02:24:34 2015 UTC,"I don't think you should copy the value data into your list data structures, but rather let the user of your library control what happens with the memory.  If you think this is too inflexible, have a look at the way OpenBSD solved it for red-black trees (I'm linking the tmux compat layer here, because it is simpler to point out the relevant parts, it is the same as in the OpenBSD source tree): in tree.h:  #define RB_HEAD(name, type)    \ struct name {    \     struct type *rbh_root; /* root of the tree */    \ }  #define RB_ENTRY(type)    \ struct {    \     struct type    *rbe_left;    /* left element */    \     struct type    *rbe_right;    /* right element */    \     struct type    *rbe_parent;    /* parent element */    \     int     rbe_color;    /* node color */    \ }   and in tmux.h:  struct environ_entry {     char    *name;     char    *value;      RB_ENTRY(environ_entry) entry; }; RB_HEAD(environ, environ_entry);   As you see, the macros are inserted into a user supplied data structure and therefore let the user have full control about the usage. The data could now be stored inline:  #define DELTA_STRING_LIST_CHUNK_SIZE    1024 struct DeltaStringList {     size_t    length;     char    value[DELTA_STRING_LIST_CHUNK_SIZE];      DELTA_LIST_ENTRY(DeltaStringList) entry; };   or in a separate string table or the likes somewhere else:  struct DeltaStringList {     char *value;     DELTA_LIST_ENTRY(DeltaStringList) entry; };"
C_Programming,3ch5o2,metraon,3,Tue Jul 7 21:41:47 2015 UTC,"I don't think your List_append function works correctly. I think it overwrites the data in the last node that's already in the list (possibly causing a memory leak as you lose the pointer to the previous data), and then creates a new node at the end of the list whose data is """"."
C_Programming,3ch5o2,zifyoip,3,Tue Jul 7 22:33:00 2015 UTC,"Your bubbleSort function will never do anything at all, because you initialize ptr1 to 0 and then immediately test whether ptr1 == NULL (which will always be true, of course) and then return."
C_Programming,3ch5o2,zifyoip,1 point,Tue Jul 7 22:36:38 2015 UTC,Yeah I edited that and solved it in another thread. Thanks for pointing that out !
C_Programming,3ch5o2,zifyoip,2,Tue Jul 7 23:25:28 2015 UTC,"No, you didn't fix it. You made it worse. Now it has undefined behavior—you are attempting to read the value of ptr1 without it ever having been assigned a value. You're attempting to read the value of an uninitialized variable, which results in undefined behavior, which means you have absolutely no guarantees about the behavior of any part of your program."
C_Programming,3ch5o2,OldWolf2,1 point,Wed Jul 8 16:22:00 2015 UTC,"Yeah. I slept on that and completely redid the list, inspected it with valgrind and everything is OK now! Thanks anyway!"
C_Programming,3cfemy,tehcyx,5,Tue Jul 7 14:15:41 2015 UTC,"blk is an automatic variable. That means, it is a variable that is created when create_blocks begins and is destroyed when create_blocks ends. Returning a pointer to an automatic variable is not a good idea as the variable is already destroyed by the time you access it. Consider doing one of the following things:   Create blk in the function that calls count_blocks and pass a pointer to blk as an argument to count_blocks. Allocate blk with malloc just as K&R says."
C_Programming,3cfemy,FUZxxl,1 point,Tue Jul 7 14:27:08 2015 UTC,"Oh I see. So I'll rewrite it to  void create_blocks(block* blk)   do a   malloc(sizeof(block) * CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);   and then go from there, right?"
C_Programming,3cfemy,net_goblin,2,Tue Jul 7 14:33:16 2015 UTC,"I think the original function signature was just fine, it's a widely used convention to simply return NULL if something went wrong. The other possibility is to use a signature like     enum error create_blocks(block **blk); where create_blocks returns an error code which indicates the kind of error which occured.  But this seems overkill to me, just stick with the signature you already use. Also note that my second example uses a double pointer, because in C arguments are passed by value, which means the input is copied into the function. The result is you can't access the value you assigned in create_blocks from the outside.   But if you pass in a pointer to a pointer, then the location of a pointer is passed in, which you can modify to store your own pointer. Maybe a short example might help your understanding:  block *blocks;  create_blocks(&blocks); /* the address of `blocks` is passed */   and then  void create_blocks(block **blkp) {     *blkp = malloc(/* required size */); /* store the result of malloc at the location pointed to by blkp */     /* remaining code */ }   I hope this helps your understanding of pointers. Again, just stick with the signature you already use and return the pointer you get from malloc."
C_Programming,3cfemy,net_goblin,2,Tue Jul 7 15:34:02 2015 UTC,"Thank you, that helps explaining the pointers more. I think I have to rework my way through K&R again to maybe understand the pointers better.  But with your example (trying it) the code won't work as I try to get it working (or I have a wrong idea again).      *blk = malloc(sizeof(block) * CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);      for (int i = 0; i < CHUNK_SIZE; i++) {             for (int j = 0; j < CHUNK_SIZE; j++) {                     for (int k = 0; k < CHUNK_SIZE; k++) {                             block blockPosition;                             blockPosition.x = i;                             blockPosition.y = j;                             blockPosition.z = k;                             blockPosition.renderSize = 1.0;                              blk[i][j][k] = blockPosition;                     }             }     }   The error I get is this:  error: subscripted value is not an array, pointer, or vector                             blk[i][j][k] = blockPosition;   With that above code I should be able to access the pointer as a 3D array, right? Casting it like (*blk)[i][j][k] = blockPosition won't help either.  Also with the original signature I had, I would slow things down. The approach everyone is suggesting would make it faster by just modifying a pointer, right?"
C_Programming,3cfemy,net_goblin,1 point,Tue Jul 7 16:08:22 2015 UTC,"I managed to improve the code a little but still don't have the pointer reference correct:  *blk = malloc(sizeof(block) * CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE);  for (int i = 0; i < CHUNK_SIZE; i++) {     for (int j = 0; j < CHUNK_SIZE; j++) {         for (int k = 0; k < CHUNK_SIZE; k++) {             *blk[i][j][k] = (block) { .x = i, .y = j, .z = k, .renderSize = 1.0 };         }     } }   The error is still:  error: subscripted value is not an array, pointer, or vector                             *blk[i][j][k] = (block) { .x = i, .y = j, .z = k, .renderSize = 1.0 };                              ~~~~~~~~~^~   No idea why I wouldn't be able to access at this point as an array."
C_Programming,3cfemy,wgunther,1 point,Tue Jul 7 21:12:20 2015 UTC,"Oh, I'm terribly sorry I didn't notice that issue before.  Out of habit I adviced you to use a simple pointer and to allocate a continuous memory segment.  What I failed to mention is, that you can't address your structs in the blk[i][j][k] way anymore, but you rather have to calculate the offset in the continuous segment.  The calculation is quite straightforward in two dimensions, you just imagine all your stacked blocks:  |00|01|02| |10|11|12|   and put them in a row:  |00|01|02|10|11|12|   In three dimensions, its essentially the same, only the row is much longer. I leave the index calculation to you as an exercise ;)  The other way, using the naïve indexing scheme like you do in your loop, you have to use a multidimensional array. The drawback of this approach is a) a much more complicated pointer type (this may be why you might want to avoid it) and b) memory efficiency (the cause everyone else might avoid it).  In three dimensions, you'd have a block ***blk, allocated by the likes of:  size_t i, j;  if ((blk = malloc(CHUNK_SIZE * sizeof(block **)) == NULL)     return NULL for (i = 0; i < CHUNK_SIZE; i++) {     if ((blk[i] = malloc(CHUNK_SIZE * sizeof(block *)) == NULL) {         /* free all already allocated blocks here */         return NULL;     }     for (j = 0; j < CHUNK_SIZE; j++) {         if ((blk[i][j] == malloc(CHUNK_SIZE * sizeof(block)) == NULL) {             /* free all already allocated blocks here */             return NULL;         }     } }   Please don't crucify me, if I have errors in the code above, I did not test this.  As you see, memory management becomes quite a bit more complicated, as you have to do a similar dance if you free the memory.  Edit: formatting"
C_Programming,3cfemy,jijijijim,1 point,Wed Jul 8 08:22:25 2015 UTC,What did I get into here. Ok at least I learn more about pointers now.  I'll see what I can do here. Thank you.
C_Programming,3cfemy,wgunther,1 point,Wed Jul 8 17:16:03 2015 UTC,"You got yourself into multidimensional arrays in a low-level language. Like u/danielcamiel I'd recommend keeping the array flat, and read through K&R. My copy has actually a post-it at the address arithmetic section, I read it quite a lot."
C_Programming,3cfemy,wgunther,1 point,Wed Jul 8 21:51:13 2015 UTC,That worked out pretty good for me. The code looks very clean now and very understandable.
C_Programming,3cfemy,danielcamiel,1 point,Wed Jul 8 21:54:06 2015 UTC,"You can't access a point blk like that. blk is a pointer to block. blk[i] is already dereferenced then, i.e. it is a block.  You need to cast blk if you want to access it like that (as I said in my post), which is doable since you know the size at compile time. So you can say  block (*blkArray)[CHUCK_SIZE][CHUCK_SIZE] = (block(*))[CHUCK_SIZE][CHUNK_SIZE] blk  Then you can access blkArray like a three dimensional array.  Alternatively, you could just collect this pointer from malloc (it returns a void* so it'll convert without a cast)   block (*blk)[CHUNK_SIZE][CHUNK_SIZE] = malloc(...)  if you just return a block* you'll have to do the cast on the calling code.  Anyway, I think it's probably best to take a more object oriented approach to this, and just have your initialize return an opaque pointer to a struct, and control all accesses with functions (e.g. block_getCord(x,y,z)). At the very least typedef this type typedef struct block (*block)[CHUNK_SIZE][CHUNK_SIZE]. Then you can do stuff like a reasonable human.   #include <stdlib.h> typedef int (*tdint)[10][10];  int (*function1())[10][10] { // this is pretty terrible     int (*blah)[10][10] = malloc(10*10*10*sizeof(int));     return blah; }  tdint function2() {     tdint blah = malloc(10*10*10*sizeof(int));     return blah; }  int main() {     int (*array1)[10][10] = function1();     tdint array2 = function2();  }"
C_Programming,3cfemy,danielcamiel,1 point,Wed Jul 8 10:57:22 2015 UTC,Noted and hopefully learned my lesson about pointers in this case. Thank you.
C_Programming,3cfemy,danielcamiel,3,Wed Jul 8 17:16:35 2015 UTC,You need to Malloc blk as well.  Write a destroy function to free. (Ibelieve blk will be block **blk)
C_Programming,3cfemy,concacid,1 point,Tue Jul 7 14:29:10 2015 UTC,Have the destroy function on my list already. That's what I plan to do right after that pointer is working.
C_Programming,3ce48v,irwin08,10,Tue Jul 7 05:04:00 2015 UTC,"It's possible for a ti-84, and I've done it before. This post explains how to use sdcc to compile a c program for the ti-84. You could also use z88dk."
C_Programming,3ce48v,namesarenotimportant,-2,Tue Jul 7 07:46:47 2015 UTC,"No, it's not possible. There is no compiler.  There is a c compiler for the HP 50g however.   Edit: I stand corrected: http://sourceforge.net/projects/tisdcc/  Edit 2: never mind, the project has no files."
C_Programming,3ce48v,skush97,1 point,Tue Jul 7 06:27:37 2015 UTC,"I can't look now,  but surely the is a z80 gcc variant"
C_Programming,3ce48v,EkriirkE,-5,Tue Jul 7 06:32:45 2015 UTC,"Probably has a toolbar, though"
C_Programming,3ce48v,synthead,-3,Tue Jul 7 06:33:10 2015 UTC,"You must be out of the loop, down voter"
C_Programming,3cd9px,mttd,1 point,Tue Jul 7 00:35:30 2015 UTC,"It's clever, but with C you know the type of an object as well as you know its identifier because you wrote the declaration. It's almost like CHECKED_NAME(""identifier"", identifier). ;-)"
C_Programming,3cd9px,danielcamiel,1 point,Tue Jul 7 14:00:31 2015 UTC,"This is why, of the original context for the conditional expression (which strictly speaking is the subject of the post), I kept the macro definition and the cast.  The macro introduces distance: when it is used latter, the programmer that calls it (which may be a different person than the one who wrote it) may very well know the type of the expression passed to it, but not know that the macro is only safe if the expression is a certain type.  The cast means that the type information is about to be lost, and that it will be impossible for another macro to make the check latter."
C_Programming,3cd9px,pascal_cuoq,1 point,Wed Jul 8 09:42:32 2015 UTC,"In real software, this idiom is found in OpenSSL’s source code.   And the quality of the OpenSSL source code is regarded rather… controversial."
C_Programming,3cd9px,net_goblin,2,Tue Jul 7 15:39:25 2015 UTC,"This is an easy lapidary comment to make on Reddit, but OpenSSL's source code is not “regarded rather… controversial” because of this construct or because of constructs such as this one.  It is regarded as controversial because of a number of concrete, definite issues, many of which have already been solved either in OpenSSL itself or in forks such as LibreSSL or BoringSSL.  The issues are idiosyncratic and inconsistent indentation, preservation of support for obsolete compilation platforms that developers do not in fact have access to for testing, inconsistency in the encoding of error indicators in function results, and absence of checks for success at the call sites for functions that can fail. Some of the remaining failings of OpenSSL in this respect are illustrated in the patches that fix them here: https://mta.openssl.org/pipermail/openssl-bugs-mod/2015-June/000000.html  One clever use of the C language, wrapped into a macro as it should be, for the laudable purpose of checking the code's consistency at compile-time, does not make OpenSSL's source code controversial, quite the contrary. The only reproach that can be made is that a comment would have been useful (but on the other hand, “1?e:(type)0” is a C idiom, albeit an advanced one, and the reader could be expected to know about it)."
C_Programming,3cd9px,pascal_cuoq,1 point,Wed Jul 8 09:56:26 2015 UTC,"Well, my point was, there might be “better” usage examples than OpenSSL, whose source code has a particular bad reputation.  One thing that I can't get my head around is, why would I want to stuff those things into void pointers? If I have control over the API, I can use the correct type, I don't its probably going to be used in another compilation unit, where the extra information is not available.  Further, I've never seen this “clever use” out in the wild, which does not necessarily mean anything by itself, but keeps adding to my scepticism."
C_Programming,3cd9px,net_goblin,1 point,Wed Jul 8 21:29:10 2015 UTC,"void pointers is the idiomatic way to implement genericity in C. For instance, from the standard library:  void *memcpy(void *dest, const void *src, size_t n);  void qsort(void base, size_t nmemb, size_t size, int (compar)(const void *, const void *));  There functions do not use void* because the type is unavailable. They use void* because they are intended to work with several different types of values without being duplicated for each possible type. In OpenSSL, where the macro CHECKED_PTR_OF is used, generic functionality is being implemented that would have to be otherwise duplicated for tens of different types even if the types are known and come from other parts of OpenSSL.  Also yes, incidentally, the generic functionality is in a different compilation unit than its uses. OpenSSL's source code would be much worse organized than it has the reputation to be if it wasn't."
C_Programming,3cd9px,pascal_cuoq,1 point,Thu Jul 9 08:11:36 2015 UTC,"I know about void * and genericity in C. My point was, I see little use in  int i[8]; const int j[] = { 0, 1, 2, 3, 4, 5, 6, 7 };  memcpy(CHECKED_PTR_OF(int, i), CHECKED_PTR_OF(int, j), 8);   because I have already full control over the declarations. Of course this could be messed up by using different types for the source and target pointers, but it is equally simple to misuse the type in the macro, since the types are not coupled together.  const float j[] = { /* ... */ };  memset(i, CHECKED_PTR_OF(float, j));   As u/danielcamiel put it, I wrote the declaration myself, I know it, and if I used a wrong type in the first place, chances are good I put the wrong type into the CHECKED_PTR_OF macro, too. C isn't bothered at all, as casts from pointers to (void *) aren't needed.  But I now can see the macro being useful in other wrapper macros, which can ensure consistency and retain a single point of truth for the wrapped function instead for the type declaration:  #define TYPED_MEMCPY(t, a, b, n) memcpy(CHECKED_PTR_OF(t, (a)), CHECKED_PTR_OF(t, (b)), (n))"
C_Programming,3cea7k,minhduy223,2,Tue Jul 7 06:08:30 2015 UTC,"printf(""\nEnter name: ""); scanf_s(""%s"", EmployeeInfoList[n].Name, TextLength); fflush(stdin); printf(""Enter Hourly rate: ""); scanf_s(""%lf"", &EmployeeInfoList[n].rate); printf(""Enter Hourly worked: ""); scanf_s(""%lf"", &EmployeeInfoList[n].hour);   Should work for you. The format specifer for double is wrong, should be %lf.  Note that EmployeeInfoList[n].Name is already a pointer, you should not pass the address here (this is the compiler helping you out, trying compiling it with -Wformat to see it complain)"
C_Programming,3cea7k,studioidefix,1 point,Tue Jul 7 06:42:31 2015 UTC,"Thanks, It works!"
C_Programming,3cciv2,Ajpennster,4,Mon Jul 6 21:08:50 2015 UTC,You aren't allocating enough memory for sorted (missing sizeof) and it looks like your bracketing is messed up on line 36.
C_Programming,3cciv2,kdub0,1 point,Mon Jul 6 21:17:30 2015 UTC,fixed that. Still ran into problems. Got a seg fault. Gonna check where with GDB
C_Programming,3cciv2,studioidefix,1 point,Mon Jul 6 22:34:41 2015 UTC,"Would help if you posted the full code, errors may not be in the block you pasted."
C_Programming,3cciv2,studioidefix,1 point,Mon Jul 6 22:38:24 2015 UTC,I posted the entire function. Wouldn't that be enough?
C_Programming,3cciv2,studioidefix,2,Mon Jul 6 22:39:42 2015 UTC,"Not necessarily, you could just be allocating/declaring/passing the ""sorted"" array wrong. for eg sorted is not large enough to hold left + right together (i.e. length < rightlen + leftlen), which can also cause a segfault."
C_Programming,3cciv2,jacksonwanderlust,1 point,Mon Jul 6 22:53:05 2015 UTC,Sorted wasn't passed into the function. It was created in the function. I will post the entire thing though
C_Programming,3cciv2,jacksonwanderlust,1 point,Mon Jul 6 23:08:47 2015 UTC,"No, but length is. Size of sorted depends on what you pass in to length, sorted isn't guaranteed to be the correct size just because you allocate it in the function."
C_Programming,3cciv2,studioidefix,1 point,Mon Jul 6 23:20:37 2015 UTC,fair enough. i understand
C_Programming,3cciv2,DownloadReddit,1 point,Mon Jul 6 23:23:51 2015 UTC,2 Things:   Check your parens on line 36. That should solve your segfault. I think +1 on 29 and 36 is unnecessary? It makes the memcpy skip the last element in the array.
C_Programming,3c9zq1,ThePantsThief,12,Mon Jul 6 07:00:14 2015 UTC,"Only in a very limited way:  enum valid_types { TYPE_INT, TYPE_DOUBLE /*, ... more */ };  struct node {     int type;     void *ptr; };  void use(struct node *n) {     if(n->type == TYPE_INT) {         int i = *((int *)n->ptr);          // ... do something with i ...      } else if(n->type == TYPE_DOUBLE) {         double d = *((double *)n->ptr);          // ... do something with d ...             } }   This can only cope with a fixed set of types that is defined beforehand."
C_Programming,3c9zq1,Rhomboid,14,Mon Jul 6 07:21:06 2015 UTC,"Some notes for improvements: if you use a switch-case instead of if-else, you can get the compiler to give you a warning if you ever add new types to the enum, but forget to handle the case in the use function.  Also, instead of a void pointer, you can use a union:  struct node {     valid_types type;     union {         int i;         double d;     } value; };  void use(struct node* n) {     switch (n->type) {         case TYPE_INT: {             int i = n->value.i;         } break;         case TYPE_DOUBLE: {             double d = n->value.d;         } break;     } }   If your compiler supports anonymous unions (MSVC does by default, gcc with -fms-extensions), you can even omit the value name:  struct node {     valid_types type;     union {         int i;         double d;     }; }; // ... int i = n->i; double d = n->d;   By the way, packing a value's runtime type with the data itself is also known as a variant or (rather descriptively) tagged union."
C_Programming,3c9zq1,Nimbal,6,Mon Jul 6 07:36:09 2015 UTC,"If you want it to handle more types dynamically, you can add a function pointer to a ""use"" function instead of using use() directly.  struct node {     /* ... */     void (*use)(struct node*); };   and then use it like  struct node *n;  n = foo_node_alloc(); /* allocate something that ""extends"" node */ n->use(n);   Here's a more detailed example:  #include <stdio.h> #include <stdlib.h> #include <string.h> #include <assert.h>  #define NODE_INT   1 #define NODE_FLOAT 2  struct node {     int type;     void (*use)(struct node*);     void (*set)(struct node*, void*); };  struct int_node {     struct node _parent_;     int value; };  struct float_node {     struct node _parent_;     float value; };  void int_node_use(struct node *n) {     assert(n->type == NODE_INT);     printf(""int_node [%p]: %d\n"", n, ((struct int_node*)n)->value);     return; }  void int_node_set(struct node *n, void *value) {     assert(n->type == NODE_INT);     ((struct int_node*)n)->value = *(int*)value;     return; }  struct node* int_node_alloc(void) {     struct node *n;      n = malloc(sizeof(struct int_node));     memset(n, 0, sizeof(struct int_node));     n->type = NODE_INT;     n->use = int_node_use;     n->set = int_node_set;     return(n); }  void float_node_use(struct node *n) {     assert(n->type == NODE_FLOAT);     printf(""float_node [%p]: %.3f\n"", n, ((struct float_node*)n)->value);     return; }  void float_node_set(struct node *n, void *value) {     assert(n->type == NODE_FLOAT);     ((struct float_node*)n)->value = *(float*)value;     return; }  struct node* float_node_alloc(void) {     struct node *n;      n = malloc(sizeof(struct float_node));     memset(n, 0, sizeof(struct float_node));     n->type = NODE_FLOAT;     n->use = float_node_use;     n->set = float_node_set;     return(n); }  int main(int argc, char *argv[]) {     struct node *n[2];     int i;     float f;      i = 2;     f = 3.14;     n[0] = int_node_alloc();     n[0]->set(n[0], &i);     n[1] = float_node_alloc();     n[1]->set(n[1], &f);      for(i = 0; i < (sizeof(n) / sizeof(n[0])); i++) {         n[i]->use(n[i]);     }      /* free memory */     return(0); }   This way you can extend a node to fit arbitrary data types, you just need to follow the example."
C_Programming,3c9zq1,thefeistelnetwork,7,Mon Jul 6 09:15:32 2015 UTC,"Oh, neat idea! A data structure that uses indirect functions like this could have some kind of table for them. Then we can dynamically change the table, even build hierarchies where the upper levels use functions the lower levels provided.  Maybe I can use this to control that bread-heating device I invented last week.  (Disclaimer: the above is intended as friendly humor, not dripping sarcasm.)"
C_Programming,3c9zq1,Nimbal,6,Mon Jul 6 09:27:38 2015 UTC,"Right, this is basically what happens when you use classes in C++.  I'm glad you found it to be useful :)"
C_Programming,3c9zq1,thefeistelnetwork,2,Mon Jul 6 09:38:24 2015 UTC,"It's actually kind of interesting because you can see how C++ ""evolved"" out of C by playing around with this sort of thing. I think the first ""C++"" compiler (called ""C with Classes"" at the time) was essentially a very fancy preprocessor that took C++ code, converted it to C, then compiled that."
C_Programming,3c9zq1,Steve_the_Scout,2,Mon Jul 6 16:09:33 2015 UTC,you can use a union   I figured that an answer to a question about casting should probably contain at least one cast.
C_Programming,3c9zq1,Rhomboid,1 point,Mon Jul 6 10:16:13 2015 UTC,:/ Gotcha
C_Programming,3c9zq1,devacoen,1 point,Mon Jul 6 13:11:18 2015 UTC,"Since standard was never mentioned, I will just put here this article about generic selections in C11. It might de-clutter the code a bit in the long run."
C_Programming,3c9zq1,devacoen,2,Mon Jul 6 10:26:52 2015 UTC,Thanks!
C_Programming,3c9zq1,FUZxxl,1 point,Mon Jul 6 13:12:12 2015 UTC,"Don't mention it. I wouldn't even remember about it if one of my colleagues didn't come to me to ask about ""this weird code from students that looks like C++ templates in C"" few weeks ago."
C_Programming,3c9zq1,DSMan195276,1 point,Mon Jul 6 13:42:00 2015 UTC,"Notice that generic selections only work when the type is known at compile time. They cannot infer the actual type of an object pointed to by a void* not can they distinguish equal types that only differ in their name, e.g. if you typedef int myint, generic selections cannot distinguish int from myint. They can also not give you the type of a variable, you need to list all types you want to handle manually."
C_Programming,3c9zq1,FUZxxl,1 point,Mon Jul 6 13:42:42 2015 UTC,"You might be interested in the container_of macro, it serves a similar purpose, so it is noticeably not the same thing. Regardless, I use it regularly, and I find it to be extremely useful for providing extendable types cleanly. It's similar (though, IMO better) to inheritance provided by C++ or Java. Essentially, the container_of macro allows you to take a pointer to an internal member of a struct, and get a pointer to the containing structure. So, then your code can simple provide a structure for types to 'implement' (Which probably includes a few callbacks for handing some things), and then structures can directly embed that structure into there's, and then use container_of in the call backs to access the rest of the structure. Kinda like this:  struct type_interface {     int (*value) (struct type_interface *); };  struct type1 {     int k;     struct type_interface iface; };  int type1_value(struct type_interface *t_iface) {     struct type1 *t = container_of(t_iface, struct type1, iface);      t->k++; /* Just some random statement to do in this callback */      return t->k; }  /* Takes two generic 'type_interface' objects, and uses the callback to get their value */ int add_types(struct type_interface *t1, struct type_interface *t2) {     int v1 = t1->value(t1), v2 = t2->value(t2);     return v1 + v2; }  int main() {     struct type1 t, t2;      t.iface.value = type1_value;     t.k = 20;     t2.iface.value = type1_value;     t2.k = 30;      int i;     for (i = 0; i < 10; i++)         printf(""add %d: %d\n"", i, add_types(&t.iface, &t2.iface));      return 0; }   It's a pretty long example, but it shows the basic idea. You create your generic structure which implements everything you need for using that object (In this case, just a 'value' callback. But you can put anything you want into this structure). Structures that want to make use of this functionality simply include one more more copies of the generic structure, filled-in with any extra information necessary (Like, supplying functions for callbacks, etc.). Then, you just pass a pointer to the generic structure to all of the relevant functions, and they use the object's information. In the callbacks, you can use container_of to get the original object back and then make-use of it's contents."
C_Programming,3c9zq1,FUZxxl,1 point,Mon Jul 6 14:38:40 2015 UTC,"Macros! Macros are the solution. :)  I probably won't use container_of specifically but thanks for reminding me about 'em, haha"
C_Programming,3c9zq1,FUZxxl,1 point,Mon Jul 6 16:40:12 2015 UTC,"Can you elaborate? Your question is very vague as-is.  C does not store type information at runtime. If you need to do any kind of dynamic conversion, you have to manually pass type information. This can be done via a tag in the first member of a structure."
C_Programming,3c9zq1,FUZxxl,1 point,Mon Jul 6 10:25:55 2015 UTC,"Here's more details. Basically I'm dereferencing a function that returns  void * and returning that, but the value returned is always 0 unless I explicitly cast it."
C_Programming,3c9zq1,FUZxxl,1 point,Mon Jul 6 13:10:30 2015 UTC,You can't dereference a void*. The type void is an incomplete type that cannot be completed. You cannot dereference an incomplete type as the compiler doesn't know what to do. Some compilers may allow you to dereference a void* with unspecified results although that is not portable.
C_Programming,3c51ng,newLifeinTown,3,Sat Jul 4 21:22:14 2015 UTC,Have you tried reordering the link flags? When linking the position of the -l flags is important.
C_Programming,3c51ng,maep,2,Sat Jul 4 22:39:32 2015 UTC,"Yup, that was it. '-lrt' needed to go at the end. Thanks!"
C_Programming,3btugn,Colobravo,9,Thu Jul 2 02:37:46 2015 UTC,"Normally, I have npp open plus a command prompt. When I want to compile and run, I do it all from the command line. Same with debugging."
C_Programming,3btugn,f5f5f5f5f5f5f5f5f5f5,4,Thu Jul 2 10:35:32 2015 UTC,"First you need to install a compiler. Here is a link to MinGW: http://www.mingw.org/category/wiki/download   Once you have written and saved the program, open command prompt, and navigate to the folder where you saved it. Here is a link that explains how to use command prompt: http://www.computerhope.com/issues/chusedos.htm  The basic thing to know is type dir to list the files in the directory, and type cd FolderName to navigate to that folder. cd .. will take you back to the parent folder. (cd stands for Change Directory) Once you navigate to where the program is saved, type:  gcc myProgram.c -o myProgram.exe  This will compile the program, and create an executable called myProgram. If there are any errors, then you will see them in the command line, if there are no errors, then type myProgram, and it will run. (of course substitute myProgram with whatever your program is called)"
C_Programming,3btugn,new--USER,1 point,Thu Jul 2 23:50:53 2015 UTC,DevC++ automatically installs MinGW. You just have to add the compiler path to your environmental variables.
C_Programming,3btugn,coolirisme,2,Fri Jul 3 06:08:36 2015 UTC,"You want to install MinGW (or you might already have it installed). Add the binary to your PATH system variable.   Now you can compile stuff by entering gcc -Wall -o yourprogram yourinputfile1.c yourinputfile2.c in the command prompt, it will create yourprogram.exe in the same directory. This is all assuming you're running windows. -Wall just enables some useful errors and warnings."
C_Programming,3btugn,_teslaTrooper,1 point,Thu Jul 2 23:58:13 2015 UTC,I'm assuming they're using C instead of C++ (Or they're on the wrong subreddit) so surely they'd use gcc.
C_Programming,3btugn,sprite3,2,Fri Jul 3 02:01:17 2015 UTC,"True, not sure why I was thinking cpp, fixed."
C_Programming,3btugn,_teslaTrooper,5,Fri Jul 3 02:11:26 2015 UTC,http://codingfox.com/1-9-how-to-configure-gcc-in-notepad-for-c11/
C_Programming,3btugn,pxck,5,Thu Jul 2 03:22:31 2015 UTC,"When you are a beginner, you should consider not using these features as they hide what's going on when you compile the program. Try to invoke the compiler manually."
C_Programming,3btugn,FUZxxl,10,Thu Jul 2 08:42:29 2015 UTC,Try to invoke the compiler manually.   That's literally what they're asking how to do.
C_Programming,3btugn,AngusMcBurger,1 point,Thu Jul 2 08:57:14 2015 UTC,"I want to add that Devc++ is a terrible IDE. At least get something like Qtcreator (no need to use the qt stuff) when you want to use an ide. Invoking the compiler manually when learning is often good, but a lot easier if you use linux or another unix system"
C_Programming,3btugn,DownloadReddit,2,Wed Jul 15 11:55:52 2015 UTC,Notepad++ is just a text editor. To run your program you'll need to run it through a separate compiler. Something like MinGW. IDEs like Devc++ have their own compiler built it.
C_Programming,3btugn,alienith,7,Thu Jul 2 17:53:51 2015 UTC,"IDEs like Devc++ have their own compiler built it.   That's usually wrong. All IDEs I know call a separate compiler when you want to compile something, the compiler is never builtin."
C_Programming,3btugn,FUZxxl,2,Thu Jul 2 18:17:51 2015 UTC,The IDE can ship with a compiler however
C_Programming,3btugn,sprite3,-2,Fri Jul 3 01:58:01 2015 UTC,"I actually have never used a compiler for C or C++ (except for visual studio). I've only used ones for Python and Java, so its very possible that I'm just flat out wrong"
C_Programming,3btugn,alienith,4,Thu Jul 2 18:21:17 2015 UTC,"Python is an interpreted language although there are projects that try to compile Python to C code. You usually don't have a Python compiler. For Java, the compiler is called javac and it's not part of the IDE either."
C_Programming,3bsb41,c-jm,12,Wed Jul 1 19:14:35 2015 UTC,"Ahhh, readdir(), how I've missed you (not).  Basically, you're attempting to print a directory entry that doesn't exit, one past the end.  This is because your call to printf comes before your check that directoryInfo isn't NULL."
C_Programming,3bsb41,boredcircuits,3,Wed Jul 1 19:30:39 2015 UTC,You printf directoryInfo->d_name before you check if directoryInfo is NULL.
C_Programming,3bsb41,BasedHunter,4,Wed Jul 1 19:27:25 2015 UTC,"Your problem is already solved but I'd like to add that learning how to use a debugger is very useful. Assuming you use gcc or clang, here's a gdb tutorial:  http://www.unknownroad.com/rtfm/gdbtut/"
C_Programming,3bsb41,boarhog,2,Thu Jul 2 07:10:04 2015 UTC,Thanks. I have been looking for a good gdb tutorial :).
C_Programming,3bsb41,_teslaTrooper,1 point,Thu Jul 2 12:25:55 2015 UTC,In my experience the best tutorial for gdb was just to run it and learn as you go. I had used some IDE debuggers before though.
C_Programming,3bsb41,noname-_-,3,Fri Jul 3 00:03:58 2015 UTC,"I know you've gotten help solving your problem, but in the future you  could just use valgrind to help you with memory issues.  $gcc -g -o test gistfile1.c  $ valgrind ./test . ... ==21580== Invalid read of size 1 ==21580==    at 0x4C2F122: strlen (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==21580==    by 0x4EA8A3B: puts (ioputs.c:36) ==21580==    by 0x400868: main (gistfile1.c:57) ==21580==  Address 0x13 is not stack'd, malloc'd or (recently) free'd ...   It tells you straight away that the issue is with line 57 in your code, after that it's much easier to figure out that you use directoryInfo before checking if it's NULL."
C_Programming,3bsb41,disclosure5,2,Thu Jul 2 14:16:23 2015 UTC,"Aside from using GDB, you can compile with clang's santizer:   clang -Wall -Wextra -fsanitize=undefined -g gistfile.c   To get this output when running:  gistfile1.c:57:47: runtime error: member access within null pointer of type 'struct dirent'   Which points you in a good direction."
C_Programming,3bsb41,boarhog,1 point,Fri Jul 3 06:41:16 2015 UTC,Thanks for all your help everybody. :)
C_Programming,3bsb41,moocat,1 point,Wed Jul 1 20:02:39 2015 UTC,That certainly would be more unixy ls
C_Programming,3bpqxh,sindisil,1 point,Wed Jul 1 04:05:14 2015 UTC,how long does it take to understand something like this?  cos that goes WAY over my head.
C_Programming,3bpqxh,cehmu,2,Wed Jul 1 13:43:11 2015 UTC,"I've been using C for about 4 years but probably would have got this a year and a half ago as well (haven't been actively learning a whole lot lately). I don't know much x86 asm by heart so googled and got this. So the operation causes an exception, which when not handled by the program will cause it to crash.  But the real lesson here is don't do unnecessary stuff and just return v->a + v->b; if v->valid. Or even better, return true if v->valid and use a pointer to return the actual value."
C_Programming,3bs0x3,Juan-Nieve,11,Wed Jul 1 18:02:37 2015 UTC,"We (the Internet) can probably help with specific questions, but we don't really know anything about you, your skill level, or why you're in this situation, but to use an analogy, it's not clear if you're asking how to program or how to program.  Updating/changing programs can mean many changes.   Some changes involve changing constants to increase limits Some changes involve changing an algorithm for performance or correctness reasons, Some changes involve adding features.   You should probably ask people you work with for guidance, or you should find a mentor who lives nearby perhaps by joining a meetup or a similar group. A mentor can really help you articulate yourself.  Good luck!"
C_Programming,3bs0x3,geocar,1 point,Wed Jul 1 19:10:15 2015 UTC,"I just mean the last option, adding features. My question was more focus how to create an environment in c language to work. Im coming from python and is the first time I work on C, so i dont know from where to start hehe"
C_Programming,3bs0x3,geocar,1 point,Thu Jul 2 08:45:45 2015 UTC,Why are you working in C?
C_Programming,3bs0x3,geocar,1 point,Thu Jul 2 11:54:52 2015 UTC,The original code is in C.
C_Programming,3bs0x3,_teslaTrooper,2,Thu Jul 2 15:09:14 2015 UTC,"Okay, but is someone paying you to do this? Why are they paying someone who doesn't know C to do it?"
C_Programming,3bs0x3,taylorha,1 point,Thu Jul 2 20:40:47 2015 UTC,Noone said i would be payed.
C_Programming,3bs0x3,IskaneOnReddit,3,Thu Jul 2 23:26:14 2015 UTC,"So is it a hobby thing?  Anyway, start by figuring out how the program works. How it does the things it does. Then figure out which parts will need to be changed to add your feature and learn the working of those parts in more detail. Also write a small program which has just the feature you're adding.   Make sure the part you're adding works correctly by itself, then add it to the rest of the program, and see if everything still works.   This is all aswsuming you know how to program in C. If you don't you should probably learn that first.   Also, use a versioning system if you weren't already, so you can undo the inevitable mistakes and get a better overview of changes overall."
C_Programming,3bs0x3,n3xg3n,4,Fri Jul 3 00:07:55 2015 UTC,"Having at least a vague idea of what you are supposed to do is a good start.  Telling us ""I need to update a program"" could mean literally anything.  Look through the requirements you were presumably given, evaluate potential distinct steps for the/each goal, develop an order to then implement those steps. Basic problem solving process."
C_Programming,3bpf1g,blkpingu,2,Wed Jul 1 02:18:21 2015 UTC,"double scanfNUMBER(char* szLU, void* av) ... iErg=scanf(szLU,av);   You can't scan into a void pointer because it has no idea what type you are trying to make it be.  Compile with warnings on.   Also, scanf doesn't return a double, so why are you assigning its return value to a double?  I mean I guess you can, but why would you?   Why are you recursively calling scanfNUMBER?"
C_Programming,3bpf1g,dumsubfilter,-1,Wed Jul 1 06:43:25 2015 UTC,"to restart it. bad idea for several reasons, how would you do it? code example pls"
C_Programming,3bpf1g,sgthoppy,1 point,Wed Jul 1 19:06:08 2015 UTC,"I know this is a few days late, but to build on what /I/dumsubfilter said, always build with -Wall -Werror. It will tell you exactly what you're doing wrong, except in some odd circumstances."
C_Programming,3bpf1g,sgthoppy,1 point,Sun Jul 5 00:57:17 2015 UTC,"scanf doesn't read the newline at the end. Anywhere you compare to '\n', try just ''."
C_Programming,3bllsy,NLKNguyen,9,Tue Jun 30 05:26:05 2015 UTC,"If you want to learn multi-threaded programming, the native threading system for your platform is the best place to start. Threads, like processes and file handles, are part of your operating system, and that's the best way to learn them. This is the beauty of using C -- you can interact with your OS and hardware without adulteration.  So learn pthreads if your on a POSIX operating system like Linux.   Learn the Windows threading APIs if you're on windows.  Then after you understand what threads are and how they affect your system, then you can worry about introducing abstractions like OpenMP and libuv."
C_Programming,3bllsy,againstmethod,3,Tue Jun 30 13:13:42 2015 UTC,"pthread (and C11 thread) are different things from libuv. While libuv supports using threads too, that isn't what it is about.  However, for standard C threads, you can read some here."
C_Programming,3bllsy,necrophcodr,2,Tue Jun 30 06:50:25 2015 UTC,"Pthreads for concurrency, OpenMP for parallelism."
C_Programming,3bllsy,tsahyt,2,Tue Jun 30 07:03:42 2015 UTC,Why would pthreads not be for parallelism?  OpenMP creates and uses pthreads for you.
C_Programming,3bllsy,againstmethod,3,Tue Jun 30 13:14:54 2015 UTC,"Because it's nice to have a higher level interface for it. For some (embarrassingly parallel) problems, OpenMP can create parallel code with literally just a pragma on a for loop. Why write more complicated code than necessary? You can absolutely use pthreads for it, but it makes your code less readable, harder to maintain, and it potentially gives rise to bugs.  For real concurrent applications, you can't really get around that, but for simple parallelism, OpenMP is fantastic."
C_Programming,3bllsy,tsahyt,3,Tue Jun 30 13:27:17 2015 UTC,"But as the OP was asking -- its not suitable for ""learning multithreading"".   I agree, its a fine shortcut if you are just striding through arrays."
C_Programming,3bllsy,againstmethod,3,Tue Jun 30 13:39:07 2015 UTC,"PThreads is for parallelism.  They are to openMP what assembly is to C.  They form the base of most threading implementations.  I would personally recommend you learn both, like everything abstracted, the base will give you better control, the abstraction will be easier to write."
C_Programming,3bllsy,Thaerious,1 point,Tue Jun 30 13:22:06 2015 UTC,"Using pthreads for concurrency is like using a tank as a bulldozer. It doesn't scale well either. Libuv gives you concurrency, albeit a spaghetti interface."
C_Programming,3bllsy,anacrolix,1 point,Tue Jun 30 15:39:54 2015 UTC,"..What's the difference? Aren't both about doing multiple 'tasks' at once, instead of one at a time?"
C_Programming,3bllsy,Wiggledan,1 point,Tue Jun 30 22:08:04 2015 UTC,I thought OpenMP was mainly for SIMD programming on SMP's?  Pthreads is more lower level.
C_Programming,3bllsy,mythicalmammoth,1 point,Tue Jun 30 23:57:45 2015 UTC,"This is the best explanation I found so far for how those concepts are different:   In many fields, the words parallel and concurrent are synonyms; not so in programming, where they are used to describe fundamentally different concepts.  A parallel program is one that uses a multiplicity of computational hardware (e.g., several processor cores) to perform a computation more quickly. The aim is to arrive at the answer earlier, by delegating different parts of the computation to different processors that execute at the same time.  By contrast, concurrency is a program-structuring technique in which there are multiple threads of control. Conceptually, the threads of control execute “at the same time”; that is, the user sees their effects interleaved. Whether they actually execute at the same time or not is an implementation detail; a concurrent program can execute on a single processor through interleaved execution or on multiple physical processors.   from the introduction of Simon Marlow, Parallel and Concurrent Programming in Haskell"
C_Programming,3bllsy,tsahyt,1 point,Wed Jul 1 10:37:18 2015 UTC,"Wow, thanks for going out of your way to find that.   So, in overly simple terms: Concurrent is at least seemingly doing multiple tasks at once, and parallel refers to using multiple cores (in parallel) on a single task."
C_Programming,3bllsy,Wiggledan,-19,Wed Jul 1 14:05:51 2015 UTC,Go with C++. Threading in C is going to have very little real life use.
C_Programming,3bllsy,lolzfeminism,8,Tue Jun 30 06:05:53 2015 UTC,http://kernel.org
C_Programming,3bllsy,GenTiradentes,-5,Tue Jun 30 06:26:33 2015 UTC,I guess except writing OS's.
C_Programming,3bllsy,lolzfeminism,2,Tue Jun 30 06:29:19 2015 UTC,"Except, you know, everything that C++ does ..."
C_Programming,3bk9ww,EnvIXI,30,Mon Jun 29 22:25:39 2015 UTC,"C..   is a small language, you can understand nearly its entire syntax in a short period of time it generates small, efficient executables it's the measuring stick for application performance it's portable, you can compile standard C code on nearly any platform the code generated from it is predictable and easy to optimize  it has one of the most canonical ABIs, and many higher level languages include it as part of their foreign function interface   So basically, for embedded projects it makes a lot of sense.   If you need absolute speed, it's a good choice.  And if you want to write code, compile it once, and use it in Python, Java, D, C++, Rust, Haskell, Erlang, Ruby, Crystal, Matlab, etc, etc etc... then it's your only choice."
C_Programming,3bk9ww,againstmethod,4,Tue Jun 30 00:02:39 2015 UTC,"For a second there I read Crystal, Matlab as Crystal Methlab.  Isn't C the only thing they use in low-level kernel stuff for linux?"
C_Programming,3bk9ww,Tb0n3,1 point,Tue Jun 30 12:36:30 2015 UTC,"That may be true, though there could be a bit of C++ in there now -- dunno I dont follow kernel development."
C_Programming,3bk9ww,againstmethod,7,Tue Jun 30 12:45:42 2015 UTC,No serious kernel ever used C++. Linux doesn't either—Linux specifically said that he won't accept C++ code for the kernel.
C_Programming,3bk9ww,FUZxxl,5,Tue Jun 30 12:57:51 2015 UTC,Linus being subtle whilst offering his personal views on C++.  Why don't we rewrite the Linux kernel in C++?
C_Programming,3bk9ww,grabberfish,2,Tue Jun 30 15:03:39 2015 UTC,To be fair that was 8 years ago
C_Programming,3bk9ww,arabjuice,1 point,Tue Jun 30 21:36:55 2015 UTC,And C++ has... improved for this sort or purpose in the meantime?
C_Programming,3bk9ww,paulrpotts,1 point,Fri Jul 3 22:43:39 2015 UTC,Fine by me.
C_Programming,3bk9ww,againstmethod,1 point,Tue Jun 30 13:37:20 2015 UTC,How about IOKit for device drivers in OSX. It is a subset of C++ but still it is C++. I think there is a small portion of C++ in the OSX kernel. When I had to work with it I found it hard to use at the time. I mostly had a C background at the time.
C_Programming,3bk9ww,aninteger,1 point,Tue Jun 30 14:52:29 2015 UTC,"Minor nits to pick:    it generates small, efficient executables    Efficient perhaps, but no longer small on modern compilers targeting non-embedded systems.  Statically linked ""Hello world"" is around 400k.    it's portable, you can compile standard C code on nearly any platform    Syntax, yes.  Library, only if you exclude Windows from ""any platform""."
C_Programming,3bk9ww,againstmethod,1 point,Tue Jun 30 17:54:32 2015 UTC,"On non-embedded systems, why would you statically link such an executable?  I think the portability issue comes down to what compiler you use, I gave up on using Visual Studio for C code a long time ago, so i could be out of date."
C_Programming,3bk9ww,FUZxxl,1 point,Tue Jun 30 19:13:31 2015 UTC,"On non-embedded systems, why would you statically link such an executable?   Dynamic linking is tricky to set up and comes with a whole bunch of problems (DLL-hell is a real place). You want to avoid them when doing so comes with little disadvantages."
C_Programming,3bk9ww,FUZxxl,1 point,Tue Jun 30 20:11:09 2015 UTC,"Efficient perhaps, but no longer small on modern compilers targeting non-embedded systems. Statically linked ""Hello world"" is around 400k.   With the glibc, which is probably the most bloated libc you can find out there. For instance, on 386 Plan 9 (which doesn't know static linking), a “hello, world” compiled is 36 kB. On MIPS ULTRIX a compiled hello-world is 24 kB.   Syntax, yes. Library, only if you exclude Windows from ""any platform"".   Even Windows provides a feature complete C95 implementation, including standard library. They don't implement any later standard though."
C_Programming,3bk9ww,FUZxxl,1 point,Tue Jun 30 18:24:54 2015 UTC,"on 386 Plan 9 (which doesn't know static linking)   Hang on, I thought Plan 9 didn't know dynamic linking."
C_Programming,3bk9ww,synthead,1 point,Tue Jun 30 18:33:15 2015 UTC,"yeah sorry, yes, they only know static linking."
C_Programming,3bk9ww,airuike,1 point,Tue Jun 30 19:00:35 2015 UTC,The Linux kernel is a good example
C_Programming,3bk9ww,FUZxxl,17,Tue Jun 30 19:41:16 2015 UTC,All of the other languages just bind to C libraries haha :)
C_Programming,3bk9ww,hokaloskagathos,75,Mon Jun 29 22:58:45 2015 UTC,"I haven't found the language that lets me write programs in a better way then I can do in C. Sure, other languages have advantages but most other language's advantages were quickly nullified by one the following weaknesses:   lack of portability enforcement of invariants that I cannot guarantee while the program is still in development (mostly Rust, Go to some extend) lack of interoperability with libraries written in other languages standard library does not provide access to the UNIX system interface (many “portable” languages) code performance depends too much on unstable optimizations (mostly a problem with Haskell) code is harder to debug than it should be (Haskell, C++) specification too complex to understand (C++) no specification (many languages) lack of language stability (many languages) lack of standard library stability no or useless standard library no control over data layout in memory (many high-level languages, all scripting languages I know, Java) lack of execution speed   There are some features one could add to C that would really be helpful but all languages that did so also added a bunch of features (e.g. garbage collection or stricter enforcement of program “correctness”) that made the language unsuitable for the purpose people use C for. Some purposes are:   embedded software for resource constrainted devices highly portable software real-time software kernel development low-level programming   Lastly, I enjoy programming in C. C allows me to simply implement an algorithm without having to think about abstractions or suitability to the prescribed paradigm (e.g. object orientation; fuck languages where every module is a class). C code does exactly what I write, there is no magic leading to unintuitive results involved, like in C++ where a simple statement like a = b + c can invoke arbitrarily complex code without you knowing on first sight. C also gives you a high amount of control over data layout in memory, which is highly useful when writing well-performing software."
C_Programming,3bk9ww,Alyte,17,Mon Jun 29 22:40:05 2015 UTC,"Damn, now I just want to and program in C all night."
C_Programming,3bk9ww,FUZxxl,12,Mon Jun 29 22:48:35 2015 UTC,"[Sorry for long post!]  A good argument. However, a list against C would, too, list quite a lot of valid points. I have one foot here with C and another foot with Haskell. Why! How?  Neither is perfect.  I find C a lot easier to use. The language itself is pretty simple, and I just find it a joy to write in. If I need good performance, I almost always already have good performance, and if I need even better performance, it usually isn't hard to work something out. Knowing C feels good, because C is so big.  However, it has its down sides. And there are a lot of them. The lack of this annoying ""safeness"" thing you talk about can bite back, hard. You can have a bug go hiding in the deepest darkest corners of your program, or a dependency, and then all of a sudden one day, your stuff doesn't work and it's a nightmare to figure out why. It won't help that C isn't particularly friendly to the eyes. Or perhaps you wrote some code that doesn't perform some checks or does some arithmetic wrong which puts you in big trouble because it turns out it's a serious security flaw.  Haskell is also great. It's hard to master (I haven't got there myself yet) but it pays off. The benefits are invaluable. Yeah, programming with such complex abstractions can be difficult at first, but your code ends up being beautiful, readable, reusable. Separation of pure from IO must have been given to us by God. Some of these 'safety' things really do pay off, in terms of both program stability, and when debugging. Another point which isn't really mentioned much but stood out to me quite a lot is that Haskell's ecosystem is brilliant. I can almost always quickly find a reliable little package to do something I don't want to spend time to implement myself. And that's if the standard library, which is amazing, doesn't have anything to offer.  On the flip side, performance does take a hit. Old news, I won't go on about that. But I will say that optimization to pretty decent speed IS possible, it's just freaking horrible. Stuff ends up breaking into bits. It IS rather unpredictable. etc. And yeah, Haskell is difficult to learn (or rather, functional styles when you come from imperative, especially lower level, is hard). I also often find myself looking for the right abstraction for very long periods of time. Nobody said you always do have to use the perfect abstraction, though."
C_Programming,3bk9ww,cunttard,7,Tue Jun 30 00:33:29 2015 UTC,"Haskell is also great. It's hard to master (I haven't got there myself yet) but it pays off. The benefits are invaluable. Yeah, programming with such complex abstractions can be difficult at first, but your code ends up being beautiful, readable, reusable. Separation of pure from IO must have been given to us by God. Some of these 'safety' things really do pay off, in terms of both program stability, and when debugging. Another point which isn't really mentioned much but stood out to me quite a lot is that Haskell's ecosystem is brilliant. I can almost always quickly find a reliable little package to do something I don't want to spend time to implement myself. And that's if the standard library, which is amazing, doesn't have anything to offer.   I actually programmed primarily in Haskell before I started to use C. Have a look at my Stack Overflow profile, I have a golden tag badge for Haskell. The reasons why I stopped using Haskell are these:   It's hard to predict how fast your code is going to run. Haskell is not slow per se, but performance depends on how much the optimizer is able to analyse your code. This, coupled with the fact that the optimizer is constantly changing, caused me a lot of grief. I've seen code go from O(n²) to O(n) run time or O(n) to O(1) memory consumption depending on optimizer flags. Yes, it's usually possible to throw in some strictness annotations and some seq calls to give the optimizer a couple of hints, but I really don't want to fight against the language when writing programs. The Haskell standard library is not organized around how it's used by programmers but rather around mathematical concepts. Every program starts with a dozen or so imports just to get all the combinators you need. After writing Haskell for a week you don't admire their careful organization of standard routines, you start to detest it because it's so tedious to write down. The Haskell ecosystem frequently breaks when vital components are upgrades. I don't know who had the brilliant idea to recommend upper version limits on core components, but that's really a bad idea. Cabal hell is a real place in which you are going to end up soon. Other package systems manage to get around these problems, why is Haskell so badly struck by this? The standard library looks in large parts like an amalgamation of PhD theses, each abandoned after being developed far enough to get the PhD. There is no governing naming convention, no central concepts about how to do error handling, no conventions about argument order, etc. etc. The Haskell eco system has around five string implementations the last time I counted and there is little agreement about which to use. I hate having to convert basic data types just to get different libraries to interact. Many libraries of the Haskell eco system are written by unexperienced people who don't know how to write maintainable software. The result is frequent API breakage in many useful peripheral libraries. A library stops being useful when you constantly have to update your code to keep using it.   If someone made a Haskell-like language designed by an engineer instead of scientists in their ivory towers, than I am going to use it and love it."
C_Programming,3bk9ww,RowYourUpboat,1 point,Tue Jun 30 10:14:49 2015 UTC,"I'm a fairly heavy Python user having written C extensions. Was thinking of diving into Haskell (for the 3rd time), but I just can't think of why I would ever want to write production software in it.  Don't get me wrong, I've coded in esoteric languages such as Ada because I wanted to ensure robust, resilient software, but I just find myself gravitating back to C, Python. I just haven't found that middle ground because C++ makes me want to vomit."
C_Programming,3bk9ww,FUZxxl,5,Wed Jul 1 11:16:46 2015 UTC,"Nice in-depth comment!   enforcement of invariants that I cannot guarantee while the program is still in development (mostly Rust, Go to some extend)   I'm not sure exactly what you mean. Can you elaborate/give an example?"
C_Programming,3bk9ww,RowYourUpboat,5,Tue Jun 30 03:17:13 2015 UTC,"While writing a C program, I often want to compile a half-way finished program. I see that this program contains things that are not supposed to happen, like function stubs that don't return something even though they should or variables I forgot. I might also have code that is unsound and doesn't do anything meaningful, just because I haven't programmed the meaningful behaviour yet. A language that enforces that every compiled program is meaningful and clean, like Go which refuses to compile a program with unused imports, is tedious to use during development when the program isn't the shining gem it's going to be yet."
C_Programming,3bk9ww,FUZxxl,1 point,Tue Jun 30 09:48:00 2015 UTC,"Thanks for the reply. I think the essence of what you're talking about is languages treating warnings like errors (because you're an idiot, and can't be trusted with your own code).  On the flip side, I wouldn't be the first to point out that C's attitude is more ""here's a loaded gun, I'm sure you know how to handle it"", but finding a happy medium is tricky."
C_Programming,3bk9ww,memoryspaceglitch,3,Tue Jun 30 19:56:16 2015 UTC,"Many languages come with training wheels permanently attached so programmers don't fall over. C comes with an optional set of training wheels, called the linter. Why don't other languages follow C's example? Maybe it's because if you try to design a language without training wheels people come and shoot you down because you encourage “unsafe” programing and because you “ignore the progress language design has made” or because your language “doesn't follow insert paradigm here.” I can understand that you want to make a language with training wheels permanently attached because mediocre programmers tend to be confused by training wheels and never equip them (hurting themselves) and there are many mediocre programmers. But remember, you can't fix stupidity with fascistic requirements. You can't fix stupidity at all."
C_Programming,3bk9ww,Vikaton,0,Tue Jun 30 20:03:34 2015 UTC,"Rust has breaking changes literally a few times a week if you use the latest version. That is quite good really, since Rust is very much in development, but it's also bad for the adoption of Rust, as a stable language/api should avoid deprecating even quirks and non-critical bugs more often than a few times a decade (and preferably allow for the ""old"" standard to be used, with quirks and all)"
C_Programming,3bk9ww,FUZxxl,0,Tue Jun 30 08:03:19 2015 UTC,I don't think that will be happening any more
C_Programming,3bk9ww,Vikaton,1 point,Tue Jun 30 08:30:21 2015 UTC,How guarantees this? Is there a specification? A stability promise? A development plan for the future?
C_Programming,3bk9ww,FUZxxl,1 point,Tue Jun 30 20:09:52 2015 UTC,"Well yes, Rust 1.1 is out and everything is now stabilizing, so breaking changes will become a minimum."
C_Programming,3bk9ww,Fylwind,1 point,Wed Jul 1 18:44:12 2015 UTC,Can you give less vague answers to my questions? This statement is too vague to be useful for me.
C_Programming,3bk9ww,koffiezet,6,Wed Jul 1 18:57:54 2015 UTC,"lack of portability    Truly portable programs are (1) hard to write (2) quite rare in practice because most programs require OS-dependent features.  Thus writing in C often entails some sort of feature detection system like Autoconf.    lack of interoperability with libraries written in other languages    I think this is a problem with the abundance of languages nowadays.  There are just too many languages and everyone ends up reimplementing the same things over and over.  Even if it's not rewritten from scratch, writing bindings to an existing C library is often quite a tedious process.    For me, the main reason to code in C is due to (a) stability and simplicity of the C API and (b) performance and low-level concerns."
C_Programming,3bk9ww,chasesan,5,Tue Jun 30 00:30:20 2015 UTC,"Truly portable apps are not hard to write at all given that your target platforms are well-defined so you can define a hardware/os abstraction layer. Planning and knowledge about your target platform is absolutely critical, but hard? Not really.  I've written embedded software this way for a number of years, which ran on m86k, ARM (various versions), 386 embedded, MIPS on a number of different proprietary OS's - or even bare-metal. We were also able to run this software on Linux and Windows too which made debugging a LOT easier, and added the ability to mock various peripherals like magstripe and chipcard readers, thermal printers, serial communication, modems, ... Porting to a new platform could in best case scenario's (read: stable, capable and well documented platform) be done in a week, in a state that it could be sent off to our tester. Worst case we had was 7 months, mostly due to buggy libraries, incorrect or missing documentation, buggy hardware and a buggy C compiler.  For stuff like that, C is a clear winner. C++ would have been impossible to use, since a lot of these platforms didn't even have a C++ compiler - and the ones who did were pretty horrible."
C_Programming,3bk9ww,Monkey-Maker,2,Tue Jun 30 12:51:20 2015 UTC,You hit the nail so squarely on the head my friend.
C_Programming,3bk9ww,nevinera,9,Tue Jun 30 03:04:12 2015 UTC,"Anything that needs performance. When youre developing something which is performance critical (such as anything to do with an OS or embedded system), ease of development almost goes out the window. It becomes all about performance, and C is the closest you can realistically get to assembly language.  Look at literally anything which is performance critical, and you will probably see C doing most of the work.  However, for application programming, I dont think you should pick C."
C_Programming,3bk9ww,Monkey-Maker,2,Mon Jun 29 22:47:58 2015 UTC,"However, for application programming, I dont think you should pick C.   Agreed - FFI interfaces are awesome!"
C_Programming,3bk9ww,hutcho66,1 point,Mon Jun 29 23:46:03 2015 UTC,Why isnt C useful for application programming?
C_Programming,3bk9ww,FUZxxl,7,Tue Jun 30 00:14:03 2015 UTC,"C is kind of a ""Do it yourself"" language. It does not have a library the size of Java's, or C#'s or really any modern language. It does not abstract you from the innards like higher languages do, so you'll find that you often have to reinvent the wheel to do simple things which is natively supported in newer languages. This is extremely tedious when all you want to do is create a simple, performance uncritical app quickly.  Using C it may take months, whereas using a language like Java, it may take just a couple of weeks.  Just a quick example, in C there is no String class. Imagine trying to write all your code using character arrays, it will get annoying quickly if all you want to do is quickly push out some mobile app."
C_Programming,3bk9ww,hutcho66,2,Tue Jun 30 01:25:43 2015 UTC,"Many features which aren't in C (object orientation, good, easy to use GUI libraries, inheritance etc.) are invaluable for application programming."
C_Programming,3bk9ww,FUZxxl,6,Tue Jun 30 01:15:03 2015 UTC,You can do object orientation in C.  C just degrades object orientation to what it's supposed to be: a design pattern.
C_Programming,3bk9ww,hutcho66,1 point,Tue Jun 30 09:48:49 2015 UTC,"Yeah but its not easy. Trying to write an application like Microsoft Excel in C instead of C++ would take triple the time.  I'm with you that languages like Java can be overkill, I'm not the biggest fan of them. But I do like working in Python - yes everything is an object, but it isn't forced down your throat."
C_Programming,3bk9ww,FUZxxl,1 point,Tue Jun 30 09:54:08 2015 UTC,"Python is a fine language for many applications, it just can't give you some basic safety you really need, like the ability to find typos in variable names.  On the other hand, I can't see any place where C++ might be useful. It's a horrible language in every regard. Not as broken as PHP but somewhat close."
C_Programming,3bk9ww,jti107,-1,Tue Jun 30 10:16:53 2015 UTC,Yeah I've never learnt C++ and I don't intend to. But if you're working in the applications field (especially on the Microsoft ecosystem) I can imagine it would be unavoidable.
C_Programming,3bk9ww,nevinera,1 point,Tue Jun 30 10:21:49 2015 UTC,Just as PHP is unavoidable when you are developing web services.
C_Programming,3bk9ww,EkriirkE,6,Tue Jun 30 10:28:45 2015 UTC,I write C code for embedded hardware. For everything else it's matlab or Python
C_Programming,3bk9ww,jaccovanschaik,3,Mon Jun 29 23:20:43 2015 UTC,"Our company's product has at its core a huge amount of scientific code to do graph analyses of various types - that code is implemented as C modules to build and access purpose-made data structures, and exposed via ruby ffi for testing purposes."
C_Programming,3bk9ww,dmc_2930,3,Mon Jun 29 23:44:09 2015 UTC,Everything
C_Programming,3bk9ww,playaspec,3,Tue Jun 30 02:52:09 2015 UTC,It's excellent for writing the compilers and interpreters for all those higher level languages :-)
C_Programming,3bk9ww,dmc_2930,4,Tue Jun 30 07:12:50 2015 UTC,"Actually, most compilers are ""bootstrapped"" and written in their own languages these days."
C_Programming,3bk9ww,PoetheProgrammer,1 point,Tue Jun 30 11:55:48 2015 UTC,"Actually, most compilers are ""bootstrapped"" and written in their own languages these days.   Citation?"
C_Programming,3bk9ww,FUZxxl,1 point,Tue Jun 30 14:41:07 2015 UTC,https://en.wikipedia.org/wiki/Bootstrapping_(compilers)
C_Programming,3bk9ww,PoetheProgrammer,1 point,Tue Jun 30 16:18:56 2015 UTC,"Most first versions are still written in C.  Also interpreters tend to be written in C. Look at Perl, PHP, BASH or MySQL or J. Assemblers also tend to be written in C."
C_Programming,3bk9ww,necrophcodr,1 point,Fri Jul 3 00:33:02 2015 UTC,The J interpreter specifically is an interesting piece of code to look at.
C_Programming,3bk9ww,dmc_2930,1 point,Fri Jul 3 09:03:07 2015 UTC,"Yes indeed inspired me to write a simple interpreter.  Perl as well, some places have super optimizations."
C_Programming,3bk9ww,illjustcheckthis,6,Fri Jul 3 11:09:20 2015 UTC,C is just as useful now as it was before. The more important question to ask probably is when C is profitable to use.
C_Programming,3bk9ww,dmc_2930,6,Mon Jun 29 22:32:30 2015 UTC,"Ok, where do you think C is more profitable for use?"
C_Programming,3bk9ww,illjustcheckthis,11,Mon Jun 29 22:34:30 2015 UTC,"Embedded. ( Source: My day job for the last >10 years, and C is still VERY strong in that industry)"
C_Programming,3bk9ww,dmc_2930,4,Tue Jun 30 02:42:51 2015 UTC,"Hello there, fellow embedded programmer. How do you think the market prospects look for the next couple of years?"
C_Programming,3bk9ww,roccod,6,Tue Jun 30 06:24:55 2015 UTC,"Never better.  Sign up for Jack Ganssle's ""The Embedded Muse"" - http://www.ganssle.com/tem-subunsub.html  He is always expounding on the state of the industry.  I think embedded will continue to grow. The eight bit CPU is slowly going away, but it's being replaced by Cortex CPUs that are crazy powerful and equally interesting to work on."
C_Programming,3bk9ww,koffiezet,1 point,Tue Jun 30 11:36:49 2015 UTC,"Sign up for Jack Ganssle's ""The Embedded Muse"" - http://www.ganssle.com/tem-subunsub.html   Already subbed. :) I enjoy it very much.    It's just that lately more layers of abstraction seem to be added and I'm not yet bored with working with barebones systems. :P"
C_Programming,3bk9ww,memoryspaceglitch,2,Tue Jun 30 12:48:52 2015 UTC,There's plenty of low level work to be done.  Someone has to write all those drivers for Arduinos...haha.
C_Programming,3bk9ww,_java_csharp_cpp_c,3,Tue Jun 30 13:25:17 2015 UTC,"Jobs will be plenty. However I see languages used change. When I started we did 8051 and assembly. Then c,c++. Now I see embedded products using javascript in embedded browsers. However, i'm now in the high-spec embedded marked, think of dual core 1Ghz MIPS with 512+MB RAM."
C_Programming,3bk9ww,dmc_2930,3,Tue Jun 30 12:42:44 2015 UTC,"Valid point. My embedded days are behind me, but the last 'embedded' system they asked me to write software on was a 433Mhz ARM with 64Mb RAM and 1Gb of flash running Linux - which didn't really feel embedded anymore. They even considered writing it in Python... But these days, you would be stupid not to pick some dirt-cheap ARM on which you can run a full-blown modern OS instead of proprietary unstable crap - performance is cheap these days. The contrast with even only 10 years ago however is amazing. No more having to hand-optimize a CRC32 algorithm in M86k ASM without using tables, making sure it all fits in 128kb for code+data+ram."
C_Programming,3bk9ww,illjustcheckthis,2,Tue Jun 30 13:29:04 2015 UTC,"With Botnet of Toasters coming up, I'm fairly sure you embedded programmers have (metric) tons of work ahead of you :D"
C_Programming,3bk9ww,dmc_2930,1 point,Tue Jun 30 08:05:59 2015 UTC,Internet of Things is a lot of full computers and less microcontrollers tho. Things like the raspberry pi that can run python or mono or java.
C_Programming,3bk9ww,playaspec,4,Tue Jun 30 10:16:06 2015 UTC,"The raspberry pi is what, 50 bucks?  I can get an embedded CPU for less than a dollar. There's no comparison between the two.  Everything you own has tons of CPUs in it. How many do you think are in your phone? Your car? Your iWatchAMaThingy? How many CPUs do you think are in your shoes, blinking the lights in just the right way?  The truth is embedded is everywhere. Not every product needs a raspberry pi.   Some things need a CPU that can sleep 99.99% of the time while sipping energy. We're down to the nano amp range. That's insane. Try that with your Pi! :)  I see connected devices growing. There will be gateways. Those will be the Pis or equivalent. The devices themselves will be much lower power, sipping energy and just waking up when they need to, doing what needs to be done, and going right back to sleep."
C_Programming,3bk9ww,Skyfoot,2,Tue Jun 30 11:49:48 2015 UTC,"It's more like $30 but yeah, your point still stands."
C_Programming,3bk9ww,sindisil,1 point,Tue Jun 30 12:48:10 2015 UTC,I disagree. Someone has to write and maintain all of those 802.15.4 radio stacks and TCP/IP stacks.
C_Programming,3bk9ww,pseudo_shell,1 point,Tue Jun 30 11:34:47 2015 UTC,The majority of IoT devices will be microcontrollers. Few will use processors as large as those on the Pi or cell phone.
C_Programming,3bk9ww,chasesan,7,Tue Jun 30 14:37:16 2015 UTC,"Anything embedded, driver, firmware, or robotics based. Basically, when you're down at the hardware-software interface, it's still the only game in town (except assembly)."
C_Programming,3bk9ww,chalk46,2,Mon Jun 29 22:37:22 2015 UTC,"It's still useful for everything it was when it was first standardized in 1989.  It is, however, particularly useful for low level coding, resource constrained environments, performance critical applications, and the like."
C_Programming,3bk9ww,bunkoRtist,2,Mon Jun 29 22:42:13 2015 UTC,"It's also great for wrapping shellcode, if you are into security at all."
C_Programming,3bk9ww,DeleteYourLife,2,Mon Jun 29 23:00:58 2015 UTC,"The same thing it was useful 10-20 years ago honestly, almost anything you need it for."
C_Programming,3bk9ww,allpartsofthebuffalo,2,Tue Jun 30 02:56:54 2015 UTC,The same thing it's always been useful for: OS development.
C_Programming,3bk9ww,lolzfeminism,2,Tue Jun 30 13:59:13 2015 UTC,"C is a fine language for code that you plan to keep and have stable for a long time such as driver libraries and operating systems. It's also the go-to for anything where memory footprint or performance are key. If performance and memory constraints aren't paramount and/or the code will undergo significant modification (or is throw-away code), a higher level language probably has a better cost/benefit tradeoff."
C_Programming,3bk9ww,playaspec,1 point,Tue Jun 30 04:17:47 2015 UTC,"Speed, it's another language(look at BrainFuck), and learning(I learned more about the computer in my limited time of learning C than any other higher level language.)"
C_Programming,3bk9ww,Vogtinator,1 point,Mon Jun 29 22:33:59 2015 UTC,microcontrollers
C_Programming,3bk9ww,dmc_2930,0,Tue Jun 30 00:27:47 2015 UTC,"There was a very good article in /r/cpp about why C++ isn't ""back"" just as it was never gone. Essentially, due to leaps in hardware, computation has evolved much beyond the world C was invented in, necessitating higher level languages. However, there are still applications that use hardware as constrained as those of 60s and 70s i.e. embedded systems. C is still the go to choice for it.  C++ is blazing fast and much more enterprise friendly than C, but C++ makes it impossible to write small software, because of the C++ standard libraries that must be included to be able to run code. It should be noted, that there is a certain allowed application size below which you will have to code in assembly for your specific system, because the C standard will also add a certain amount of bulk."
C_Programming,3bk9ww,lolzfeminism,3,Tue Jun 30 06:03:02 2015 UTC,"due to leaps in hardware, computation has evolved much beyond the world C was invented in,    This kind of ""just throw a bigger processor/system at the problem"" thinking need to die in a fire."
C_Programming,3bk9ww,dmc_2930,2,Tue Jun 30 14:45:50 2015 UTC,"because of the C++ standard libraries that must be included to be able to run code.   If you don't use it it's free, that's one of the design principles of C++. Same for C, a function that your program doesn't use isn't included in the final binary. (Assuming static linking, of course)"
C_Programming,3bk9ww,lolzfeminism,2,Tue Jun 30 11:53:28 2015 UTC,"C++ is blazing fast and much more enterprise friendly than C, but C++ makes it impossible to write small software, because of the C++ standard libraries that must be included to be able to run code. It should be noted, that there is a certain allowed application size below which you will have to code in assembly for your specific system, because the C standard will also add a certain amount of bulk.   There are a few points worth addressing here. ""Blazing fast"", compared to what?  C++ still has a ton of overhead that isn't present in C. That overhead comes with tradeoffs that make it very useful for some tasks, but speed is not one of them.  It's also quite possible to write small programs in C++. There's nothing that says you have to use all of the complicated functionality.  In C, you can write code with no standard library whatsoever, and it's quite compact. The only time to drop down to assembly is when you need 100% bang on accurate timing. Almost anything else can be done quite readily in C as it can in assembly. Unless you're working on an 8051. If you're working on an 8051, I'm sorry for you."
C_Programming,3bk9ww,dmc_2930,1 point,Tue Jun 30 11:55:16 2015 UTC,It's also quite possible to write small programs in C++. There's nothing that says you have to use all of the complicated functionality.   It's not try compiling this with g++ int main() { return 42; } and tell me the size of the executable. Do the same with C. I haven't tested the program with C++ but the C executable is >2000 bytes.
C_Programming,3bk9ww,lolzfeminism,1 point,Tue Jun 30 17:15:07 2015 UTC,"That doesn't really say much. You can tweak all kinds of settings to affect the size of the output.  C++ was originally just a preprocessor / wrapper trick around C, after all."
C_Programming,3bk9ww,dmc_2930,1 point,Tue Jun 30 17:30:11 2015 UTC,Please do try. It is not easy to make small executables in C++. Screencap the size of an executable smaller than a kilobyte and i'll concede.
C_Programming,3bl4bf,CameronNemo,7,Tue Jun 30 02:40:55 2015 UTC,Some BSD functions like strlcpy or the err family of functions would be nice. A way to access the argument vector outside of main would be nice. A set of functions that can do arithmetic with overflow detection would be quite useful.
C_Programming,3bl4bf,FUZxxl,3,Tue Jun 30 10:27:27 2015 UTC,strlcpy   Why is this not already?
C_Programming,3bl4bf,Chooquaeno,3,Tue Jun 30 19:19:38 2015 UTC,"It's not in the glibc because drepper thinks it's a bad function (namely, because it “encourages” sloppy programming). I don't know enough about the standard comitee to know what their reason is."
C_Programming,3bl4bf,FUZxxl,1 point,Tue Jun 30 19:21:29 2015 UTC,"Ah yes, Drepper."
C_Programming,3bl4bf,Chooquaeno,3,Tue Jun 30 19:33:48 2015 UTC,"It can be emulated with sprintf, sprintf(dest, ""%.*s"", n - 1, src).  Also snprintf, snprintf(dest, n, ""%s"", src)."
C_Programming,3bl4bf,danielcamiel,5,Wed Jul 1 14:59:24 2015 UTC,"Assuming I could change it without breaking things:   Eliminate the abomination that is errno. Eliminate unnecessary global state by replacing those functions that have it (strtok vs strtok_r, localtime vs localtime_r, etc). Add a void * context argument to functions that take function pointers (e.g. qsort_r), since these often otherwise require global state. Add a function for getting a small quantity of high-quality entropy from the system for seeding purposes. This would probably be optional since some platforms (freestanding, embedded) couldn't support it. Rename FILE to something more appropriate, like stream_t. Add Glibc's x (exclusive) extension to fopen() Semaphores in stdatomic.h. Add a countof() macro."
C_Programming,3bl4bf,skeeto,2,Tue Jun 30 19:03:56 2015 UTC,"What would you use in place of errno?  The stateful functions are a tricky beast but I think thread local storage makes it possible to both have thread-safety and the simpler interface of a stateful function.   Add a void * context argument to functions that take function pointers (e.g. qsort_r), since these often otherwise require global state.   Use thread local storage.   Add a function for getting a small quantity of high-quality entropy from the system for seeding purposes. This would probably be optional since some platforms (freestanding, embedded) couldn't support it.   This shouldn't be part of the libc but rather of POSIX.   Rename FILE to something more appropriate, like stream_t.   That would break a lot of things.   Add Glibc's x (exclusive) extension to fopen()   I think this is already part of POSIX. It should not be part of the libc because it can't be implemented on many platforms.   Add a countof() macro.   For what? There are few cases where such a macro is useful."
C_Programming,3bl4bf,FUZxxl,1 point,Tue Jul 7 13:58:29 2015 UTC,"What would you use in place of errno?   Explicit return codes, and attaching error information to objects (e.g. FILE's ferror()) when there is one. errno was designed in a time before multi-threading, and some acrobatics had to be done to preserve it, such as it typically being implemented as macro+function to fetch and dereference a thread-local value.   Use thread local storage.   Occasional TLS lookup isn't a big deal, but TLS is costly in this situation because it's being accessed again and again for each individual comparison.   This shouldn't be part of the libc but rather of POSIX.   That's fair. It's annoying at the moment not having a standardized, portable interface for doing this. It's already lead to security vulnerabilities.   For what? There are few cases where such a macro is useful.   I've literally written this from scratch 30-40 times at this point because it's so handy.  #define countof(a) (sizeof(a) / sizeof(0[a]))   And later,  float data[] = { /* ... */ }; // ... for (int i = 0; i < countof(data); i++) {     // ... }"
C_Programming,3bl4bf,skeeto,1 point,Tue Jul 7 14:28:48 2015 UTC,"Explicit return codes, and attaching error information to objects (e.g. FILE's ferror()) when there is one. errno was designed in a time before multi-threading, and some acrobatics had to be done to preserve it, such as it typically being implemented as macro+function to fetch and dereference a thread-local value.   So a function that may fail cannot have a return value at the same time? That sucks a lot. The POSIX solution of having a single return value for an errorneous result is just barely acceptable, but as you can't make many assumptions about the range of possible error codes, this would be very hard to get right for many functions.   Occasional TLS lookup isn't a big deal, but TLS is costly in this situation because it's being accessed again and again for each individual comparison.   TLS lookup is extremely cheap on modern architectures. On x86, the fs segment is used for this purpose. On SPARC, a global register contains the tls pointer, on ARM a similar mechanism is used."
C_Programming,3bl4bf,FUZxxl,2,Tue Jul 7 14:39:07 2015 UTC,Provide a chunked buffer interface for string building functions.
C_Programming,3bl4bf,Chooquaeno,2,Tue Jun 30 19:16:34 2015 UTC,strncpy which guarantees a null at the end.
C_Programming,3bl4bf,thrakkerzog,1 point,Wed Jul 1 00:40:14 2015 UTC,"You want something other than strncpy, then -- it works exactly as designed. It's really unfortunate that they chose to name it that, since it's really not intended to be a general purpose string copy function at all, rather it's for copying a sequence of characters into a fixed size buffer."
C_Programming,3bl4bf,sindisil,1 point,Wed Jul 1 01:57:48 2015 UTC,"Yes. Just put it in the standard c library, the name isn't terribly important."
C_Programming,3bl4bf,thrakkerzog,1 point,Wed Jul 1 02:32:27 2015 UTC,"This exists, it's called strlcpy but it's only available on BSD due to Drepper being an asshole."
C_Programming,3bl4bf,FUZxxl,4,Tue Jul 7 14:02:52 2015 UTC,What would strtonum do that strtol/strtoul/strtoll/strtod/strtof/strtold don't already do?
C_Programming,3bl4bf,sindisil,0,Tue Jun 30 04:00:15 2015 UTC,Not require a full page of code to get correct error handling.
C_Programming,3bl4bf,spc476,1 point,Tue Jun 30 04:02:17 2015 UTC,"errno = 0; value = strtol(p,&p,0); if (errno != 0) {   /* error */ }   That's half a page?"
C_Programming,3bl4bf,FUZxxl,4,Tue Jun 30 06:32:22 2015 UTC,"That's not enough. You usually want to use a sequence like this:  long value; int errno_backup; char *endptr;  errno_backup = errno; errno = 0; value = strtol(ptr, &endptr, 10); if (errno || *ptr == '\0' || *endptr != '\0')     /* error condition here */  errno = errno_backup;"
C_Programming,3bl4bf,sindisil,1 point,Tue Jun 30 10:24:24 2015 UTC,"If you don't care if there are additional non-numeric characters after the parsed integer, then you can pass NULL as the endptr. Of course, you typically will want to check, since this is also how you can find out if parsing stopped earlier than you expected.  Also, you often don't give a rip what errno used to be, so you can also skip saving the old value.  I'm not clear on why you're treating *ptr == '\0' as an error, either. If you're checking for ""no digits found"" I'd use ptr == endptr. Of course, that's often not an error, per se. Your code apears to expect the whole string is just a decimal integer to parse (with possible leading spaces).  Finally, if you really wanted to make it look bad, you could have also specifically checked for underflow & overflow."
C_Programming,3bl4bf,FUZxxl,1 point,Tue Jun 30 15:06:52 2015 UTC,"Also, you often don't give a rip what errno used to be, so you can also skip saving the old value.   When you write a library function, it should usually behave as if it didn't modify errno unless it should set errno to a specific value. Not leaving errno untouched leads users to rely on you accidentally leaving errno set to a certain value. I'm not joking, that happens more often than you think.   I'm not clear on why you're treating *ptr == '\0' as an error, either. If you're checking for ""no digits found"" I'd use ptr == endptr. Of course, that's often not an error, per se. Your code apears to expect the whole string is just a decimal integer to parse (with possible leading spaces).   I'm checking for string is empty because that's the only case in which no number could be found but endptr points to a \0 byte. I'm actually not sure which of the two variants are more efficient, I'd have to benchmark that; it probably doesn't matter too much.   Finally, if you really wanted to make it look bad, you could have also specifically checked for underflow & overflow.   True! That's something you should do when you expect the value to be in a certain range which I didn't for the sake of simplicity."
C_Programming,3bl4bf,sindisil,1 point,Tue Jun 30 16:36:10 2015 UTC,"When you write a library function ...    Sure. There are lots of things I do different in library code than in application code. Clean errno handling is one of them (though I have a legacy library I'm currently maintaining where errno is used much more like in application code; I've no budget -- in either time or risk -- to audit and correct it right now).   I'm checking for string is empty ...   Ah, of course.  I always just compare the pointers to avoid the extra deref. In real code compiled with a modern C compiler running on reasonably mainstream hardware it's doubtful that there would be any real performance benefit -- it's just a habit; I'd argue a good habit, but a habit none the less."
C_Programming,3bl4bf,spc476,1 point,Tue Jun 30 17:10:32 2015 UTC,"I don't consider non-numeric characters after a number an error in some cases (and you're doing it wrong, it should be ""**endptr != '\0'"").  For instance, I might allow suffixes to modify the value of the number, like ""34d"" for 34 days, or ""8k"" for 8,192.    Again for the case of the empty string---not all cases are in error and it really depends upon the program.    About the saving of errno---eh.  I personally haven't come across code that relies upon functions leaving errno as 0 and in some cases, I liberally set errno to 0 with no problem."
C_Programming,3bl4bf,BigPeteB,1 point,Wed Jul 1 00:16:26 2015 UTC,"I don't consider non-numeric characters after a number an error in some cases. For instance, I might allow suffixes to modify the value of the number, like ""34d"" for 34 days, or ""8k"" for 8,192.   Well, it depends on what you're parsing. If you're parsing a network protocol, you probably want to insist that numbers consist of only numbers like the protocol says they should, so that you can raise a parse error otherwise. But since strtol is so basic, you have to write your own checks for this, which amounts to partially re-parsing the string yourself every time. It's only a marginal improvement over atoi.   and you're doing it wrong, it should be **endptr != '\0'   Check again. In this scope, it's declared as char *endptr, and was passed to strtol as &endptr."
C_Programming,3bl4bf,OlderThanGif,3,Wed Jul 1 13:58:18 2015 UTC,You've now missed:   the integer was not within the desired range the string did not consist solely of digits
C_Programming,3bl4bf,BigPeteB,1 point,Tue Jun 30 10:41:20 2015 UTC,the integer was not within the desired range   ERANGE
C_Programming,3bl4bf,spc476,5,Tue Jun 30 16:23:41 2015 UTC,"The desired range. If you're looking for a value between 0-100, you might get back 183 which is certainly within range of strtol's ability to convert, but not within the range you wanted to accept.  ERANGE only indicates that the number was outside the range of what you're converting to... in the case of strtol, a long."
C_Programming,3bl4bf,sindisil,1 point,Tue Jun 30 19:08:55 2015 UTC,Checking for the range is another line of code.  Still not a page.  The string not consisting of digits is really dependent upon the use.  8K anyone?  Or how about 34h?
C_Programming,3bl4bf,BigPeteB,1 point,Wed Jul 1 00:29:42 2015 UTC,"Err you need &p to not point to the string you are reading from.  This is more complete:  char *end; errno = 0; value = strtol(p, &end, 0); if (errno != 0 || *end != '\0' || end == str) {     /* error */ }   However it gets more complicated if you actually want to say what went wrong in logs or error messages.  Edit: also much more annoying if the implementation does not return error in the case that no digits were seen and 0 was returned, which is allowed.  Edit2: lets not forget this golden piece of shit for strtoul(l):   Negative values are considered valid input and are silently converted to the equivalent unsigned long int value."
C_Programming,3bl4bf,sindisil,1 point,Tue Jun 30 16:12:28 2015 UTC,"What's wrong with strtoul's behavior? It's no different than any other case of interpreting a signed int as an unsigned int.  If you want that to be an error, you can just check for the leading '-'. If it were treated as an error by strtoul, then you'd have to deal with that case every time, not just when it matters -- ignoring that specific error when the conversion is OK (which is often)."
C_Programming,3bl4bf,FUZxxl,2,Tue Jun 30 16:38:12 2015 UTC,"If you want that to be an error, you can just check for the leading '-'.   So I have to partially re-parse the string myself in order to know whether it was valid? No thanks."
C_Programming,3bl4bf,danielcamiel,0,Tue Jun 30 19:10:08 2015 UTC,"Dramatic much?  Sure, worst case it can be 10-12 lines of error checking, but a) it's seldom worst case, and b) that's still at most 1/2 page, assuming you define ""page"" as 80x24.  If I need to do a crapton of simple numeric parsing, and the error handling is going to be the same for most or all of it, and I need more than just the simplest error checking,  I'll typically encapsulate that logic in a function.  I'm not sure if there's a version of that function that would be both simpler than the current functions while still being worth standardizing. Maybe. If so, I'm still not sure the added convenience would be worth the cost of expanding the surface area of the standard library with overlapping functionality."
C_Programming,3bl4bf,moonrocks,1 point,Tue Jun 30 15:13:46 2015 UTC,"I don't like strtonum. I don't like that this function returns an error string which is useless for further processing and is useless if you need an error message in a different language. Yes, they could use POSIX message catalogues, but the interface doesn't look like it and doesn't make the restrictions (e.g. “this string becomes invalid after the next call to strtonum” or such)"
C_Programming,3bl4bf,FUZxxl,1 point,Tue Jun 30 16:39:07 2015 UTC,"Assuming backward-compatibility is not an issue,   I'd remove vprintf, vscanf, memcpy, atoi, atof, calloc, ... These functions are just limited forms of vfprintf (arbitrary stream), vfscanf (same as vfprintf), memmove (copies overlapping data), strtol (wider range, arbitrary base, error detection, copies end pointer), strtod (error detection, copies end pointer), and malloc+memset (arbitrary fill). I'd keep functions like malloc and printf though, which do the same thing as realloc with NULL and fprintf with stdout, because they're very commonly used. I think the strto* functions could be removed if the *scanf family were improved. A FILE-building function that accepts call-backs, something like FILE *fbuild(void *cookie, int read(void *cookie, void *data, int size), int write(void *cookie, const void *data, int size), int close(void *cookie));, fopen could be implemented in terms of it. Remove snprintf and provide nprintf or sprintf(NULL, ...) (which copies nothing and only counts the input). A precision can be given to the 's' specifier for truncating copies. I guess, remove the character-oriented stuff like ctype, wide characters, uchar, and deal with byte sequences instead? I live in my own little world where UTF-8's the only character encoding, would be great to avoid the locale-specific complications that arise from different character encodings and sets.   The following ideas rely on changes to the language as well.   Some unification of va_list and argc+argv would be interesting. Maybe get rid of va_list altogether and provide a function like char/void **args(int *argcp)? There's a lot of aliasing for integer types that could be cleaned up. size_t and ptrdiff_t could be removed, and unsigned long could be the type that sizeof resolves to. So unsigned long should at least be able to represent the size of the largest object. Type names could be shortened to one word, too. Like ""ulong"" instead of ""unsigned long"" and ""quad"" instead of ""long double"".   Okay, enough fantasizing, I should go back to programming. :-P"
C_Programming,3bl4bf,danielcamiel,1 point,Wed Jul 1 14:44:33 2015 UTC,"size_t is too axiomatic to drop. There are 16-bit machines and 64-bit Windows uses 32-bit longs.   The following ideas rely on changes to the language as well... Oh. Hmm, food for thought. Kinda tastes funny though."
C_Programming,3bl4bf,hroptatyr,0,Thu Jul 2 10:26:35 2015 UTC,Good thing you don't make the C standard.
C_Programming,3bl4bf,sindisil,1 point,Tue Jul 7 14:04:28 2015 UTC,"On the topic of strtonum, I think it targets a rigid use case. Namely, when you want to convert exactly one decimal value from input.  If you're trying to process a string that has loads of numbers in the same format, it's very difficult to do that with strtonum, but it's possible with strtol.      char *process(const char *s)     {             char *endp;             long n;              for (endp = NULL; n = strtol(s, &endp, 10), (s != endp); s = endp) {                     if (n < -32767 || n > 32767)  /* desired range */                             return (char *) s;                     handle(n);             }             s += strspn(s, "" \f\n\r\t\v"");  /* skip standard whitespace chars */             return (*s == '\0') ? NULL : (char *) s;     }   I guess the main shortcoming with strtol is the error handling, it modifies errno when the converted value is out of long's range and that's the only way to check for that error if the desired range isn't limited.  I think if that were fixed, perhaps through a *scanf modifier like %{min,max}d which could be used as easily as sscanf(s, ""%{0,*}d"", 10, &n), and a short item count were returned if the value is out of the range, it would solve a few problems. In its current state, if you use just a plain ""%d"" with the *scanf family and the converted value is out of int's range, it's registered as a successful conversion and the behaviour is undefined. So *scanf is quite a hassle for checking if a value's out of range, in that regard.  I reckon improving *scanf is a good way to deal with this sort of thing, because if you want to do something really specific, you just add to the format string. If you want something very simple, you just use ""%d"". If you want a value in the range [0,300] and you want to access the end of the converted sequence, you do something like ""%{0,300}d%n"". It's just a shame that it wasn't designed as well as it could have been; strtol and strtonum wouldn't really be necessary."
C_Programming,3bl4bf,mad_poet_navarth,1 point,Thu Jul 2 02:06:55 2015 UTC,What's the signature of strtonum()?
C_Programming,3bl4bf,dmc_2930,1 point,Tue Jun 30 05:35:48 2015 UTC,http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man3/strtonum.3  http://www.tedunangst.com/flak/post/the-design-of-strtonum
C_Programming,3bl4bf,mad_poet_navarth,1 point,Tue Jun 30 16:15:28 2015 UTC,"It's nicer for the specific case of ""this whole string is supposed to be a number ... please parse it"", but it makes parsing a line that happens to contain one or more numeric fields more of a PITA, and isn't that much shorter than typical use of strtoul. Not sure if it is enough of a win to be worth adding to the stdlib.  I'll have to give that second link a read, though -- maybe I'm underestimating the utility. Thanks for that!"
C_Programming,3bl4bf,FUZxxl,1 point,Tue Jun 30 16:45:29 2015 UTC,An snprintf that returns something logical. Returning how long the string would be if it hadn't been truncated is rarely helpful.
C_Programming,3bl4bf,mad_poet_navarth,5,Tue Jun 30 11:45:08 2015 UTC,It's helpful if you're about to allocate the buffer.....
C_Programming,3bl4bf,sindisil,1 point,Tue Jun 30 12:22:14 2015 UTC,"That hadn't occurred to me, I sez sheepishly. That's a good answer."
C_Programming,3bl4bf,mad_poet_navarth,5,Tue Jun 30 13:34:53 2015 UTC,I don't know anything that would be more useful. That information tells you when your buffer was too short which is the only error condition that could happen.
C_Programming,3bl4bf,sindisil,1 point,Tue Jun 30 12:33:23 2015 UTC,"in the ""olden days"" when you were supposed to do the buffer size checking up front the pattern was something like  p = buff; p += sprintf(blah...); p += sprintf(blah2...); etc.  Now that sprintf is bad, using snprintf is a lot more clunky."
C_Programming,3bmfjq,blkpingu,2,Tue Jun 30 12:03:17 2015 UTC,A bit more context on what you want to accomplish? What type of input are you trying to parse?
C_Programming,3bmfjq,lmlight77,1 point,Tue Jun 30 12:29:20 2015 UTC,"I want to input a double, but if the input given by the user is for example 13,4ABC i should be false and ""wrong input, only numbers allowed. re-enter"" should be returned."
C_Programming,3bmfjq,mythicalmammoth,1 point,Tue Jun 30 12:42:16 2015 UTC,"Is your problem that you need to know if the user entered some junk at the end of the string, after the number?  If so, you can tell scanf to read a string after your double by giving it %2s in the same format string, and then examine the return value and contents of the string buffer afterwards."
C_Programming,3bmfjq,mythicalmammoth,1 point,Tue Jun 30 20:30:44 2015 UTC,"Why is it important what exactly he enters? Like I said. I want to blacklist or whitelist a certain range of inputs.  In this particular case i thought of numbers as  allowed, and anything like 1b24,8cTs123 as bad input.  For example:  type the float of your choice: ""1234,56789"" accepted input.  type the float of your choice: ""123c,56tba%%&%&"" input denied. please repeat with a correct input: ""..."""
C_Programming,3bmfjq,FUZxxl,1 point,Tue Jun 30 22:24:44 2015 UTC,"The way scanf() works, if the user entered ""123c,456"", scanf() will stick 123 in your double. So you need to be able to figure out if there was junk at the end past the ""123""."
C_Programming,3bmfjq,FUZxxl,1 point,Tue Jun 30 22:39:01 2015 UTC,"thanks, a user pointed me to     strchr and this is kind of what i was looking for, but thank you for all the asking."
C_Programming,3bmfjq,FUZxxl,1 point,Tue Jun 30 22:55:58 2015 UTC,Can you please post the problematic code? It's hard to find errors without looking at the code and my crystal ball is currently broken. Please put the code in a paste bin or put it in your question. Put four blanks in front of every line of code so the code comes out in a mono-space font.
C_Programming,3bmfjq,FUZxxl,1 point,Tue Jun 30 13:15:45 2015 UTC,there is no code. I just have an idea of what it should do.
C_Programming,3bk2rn,meith1,10,Mon Jun 29 21:31:54 2015 UTC,Try debugging your program
C_Programming,3bk2rn,OldWolf2,4,Mon Jun 29 22:36:03 2015 UTC,"Use gdb to get a backtrace, at the very least."
C_Programming,3bk2rn,Chooquaeno,6,Mon Jun 29 23:37:24 2015 UTC,"In mat4_mul, you stack allocate a mat4 struct, but you don't initialize its value_ptr; then, you assign a copy of that struct through transform.c:99 giving test_trans->value_ptr an undefined value! Because value_ptr has an undefined value, it may not have a value of NULL and it may not have a value that points to a valid of memory. When the assert comes around it checks if the value_ptr is NULL, but it's undefined, so it may pass or fail, I dunno. When it passes, again, test_trans->value_ptr points to an undefined part of memory, you go on to dereference it at vector.c:88 and BAM segfault"
C_Programming,3bk2rn,noodelhl,1 point,Tue Jun 30 16:18:28 2015 UTC,thank you. I solved the problem by doing what OldWolf2 advised but it's good to know what I was doing wrong.
C_Programming,3bk2rn,OldWolf2,3,Tue Jun 30 21:20:41 2015 UTC,"In quite a few places, you malloc a struct then malloc an array of 16 variables inside it;  if this is going to always be 16 then you could simplify your code by making the struct contain an array of 16.  All of these global pointers and local arrays make me nervous..."
C_Programming,3bk2rn,ModernRonin,1 point,Mon Jun 29 22:46:17 2015 UTC,Thank you. now that i think of it that's really stupid of me
C_Programming,3bk2rn,angdev,3,Mon Jun 29 22:53:26 2015 UTC,"A pointer can point to a region of memory that is read-only. This will allow you to read the pointer and null-check it, but when you try and write to it... bam!  I have no idea how this is happening to you, but if you can null-check it and then get a segfault when writing, it's in read-only memory somehow.  If you can run the program under gdb, you might be able to use gdb's ""info address"" command to see what segment the variable is in. You want it to be in .data or .bss, if it's in .text that's read-only memory."
C_Programming,3bk2rn,looneysquash,2,Mon Jun 29 23:22:22 2015 UTC,Try changing vector.c:86 assert(m->value_ptr != NULL); to:  assert(m != NULL); assert(m->value_ptr != NULL);
C_Programming,3bk2rn,OldWolf2,1 point,Mon Jun 29 21:50:13 2015 UTC,Thanks for replying. Same error. Assert does not fail.
C_Programming,3bhh0d,FKaria,19,Mon Jun 29 06:46:44 2015 UTC,"Don't try and bring C++ concepts to C code, look at how well written code in C is implemented, and use those constructs. Or at least, look at how C is usually implemented (bad style and all) and follow the convention.  A good source is, shock and horror, the C Standard Library. Look at how errors are returned in the C StdLib, and do something similar. Look at how pointers to structs are handled. Etc.  The C Standard Library IS the boost equivalent. If you want something more, like hashmaps and dynamic lists, and network code handlers, look at the Apache Portable Runtime. It has some handy stuff, but honestly a lot of that could be heavy to get into. I'd get used to just straight idiomatic C first."
C_Programming,3bhh0d,matjam,7,Mon Jun 29 07:02:56 2015 UTC,"A good source is, shock and horror, the C Standard Library. Look at how errors are returned in the C StdLib, and do something similar.    See, I feel the opposite.  I find the idea of an errno global variable abhorrent, and I think it's widely acknowledged that this design was a mistake.  At the very least, it should be a function to retrieve and/or reset the error code and not a variable.  errno being a global variable has caused countless headaches in the past because a global variable becomes completely useless the moment you start writing a program with multiple threads.  Implementations had to eventually ditch the idea of errno being a variable and turn it into a macro that resolves to a function call that returns a pointer to a thread-local variable.  The macro expansion dereferences that pointer, since errno also has to be an lvalue that can be assigned to.  (POSIX now requires this behavior, but it's optional under the C standard.)  Anyway, forget all that.  If a function that could fail needs to return a value, it should take a pointer to where to write the value and it should return an error code.  In certain circumstances you can combine the value and the error code, for example a write()-like function could return a positive number for the number of bytes written, or if there was an error, a negative number indicating the error code.  This is how the actual write() syscall works (and all other Unix kernel syscalls.)  The libc turns that nice interface into the errno garbage in user-space.  Again, the legacy of the C standard library is not necessarily something to emulate."
C_Programming,3bhh0d,Rhomboid,3,Mon Jun 29 10:45:59 2015 UTC,"I can buy this.  Truth is there are several different API styles under libc, e.g. fopen() and malloc() returning NULL with errno set rather than returning the errno and using an output pointer like mbstowcs().  Abstracting some of the libc IO can also be handy when one wants portability between POSIX and Win32 too."
C_Programming,3bhh0d,cptaffe,1 point,Mon Jun 29 12:28:01 2015 UTC,"See, the problem is many system calls return negative results, and the std lib abstracts the syscall's range shift (e.g. -20 is 0). IIRC there is also a negative limit to error codes where the system call returns results, not errors. Also, errno is thread-local, so you'll not have any problems with threading.  Edit: apparently errno has to be thread safe and is specified as such by POSIX."
C_Programming,3bhh0d,matjam,1 point,Mon Jun 29 20:05:42 2015 UTC,"If you're going to write C, you should at least understand WHY the errno stuff is such a shitbag of fail, rather than trying to emulate C++, which was my point."
C_Programming,3bhh0d,maep,1 point,Mon Jun 29 15:59:29 2015 UTC,Thanks for the advice. I guess that I have some learning and unlearning to do.
C_Programming,3bhh0d,noname-_-,12,Mon Jun 29 09:59:04 2015 UTC,"The biggest mental change for me was to stop generalizing and thinking in objects. In hindsight that was counterproductive for C++ as well, but with a smaller penalty. Write your code in such a way that it only does what you need it to do, and nothing more. Don't try to be clever, anticipate different types or future change. Good old KISS principle.  The Book that gets most recommended here after K&R is 21st Century C."
C_Programming,3bhh0d,Rhomboid,1 point,Mon Jun 29 08:04:50 2015 UTC,Thanks! 21st century C looks like what I was looking for.
C_Programming,3bhh0d,theseoafs,4,Mon Jun 29 09:59:44 2015 UTC,"I usually use this pattern:  disclaimer: I haven't tried compiling this, so it probably contains some typos.  --- header ---  #ifndef MYLIB_H #define MYLIB_H  #ifdef __cplusplus extern ""C"" { #endif  /*     This hideous part is only really important if you want to be portable to windows using eg. MinGW.     It's even more hideous if you want to be portable to Visual C.     See eg. the OpenHMD header if you want an example of how that's done:        https://github.com/OpenHMD/OpenHMD/blob/master/include/openhmd.h      When compiling as a shared lib for windows, pass -DMYLIB_DLL_EXPORT to the compiler.     Pass -DMYLIB_STATIC when compiling AND using as a static library.     Just use the header as is if using the header when using the shared library.      You can avoid some of this nonsense by creating a map file for windows instead.     Best keep the explicit calling convention, __cdecl (or __stdcall if you prefer the microsoft way) though.     Otherwise different compilers will produce different results. */  #ifdef _WIN32     #ifdef MYLIB_DLL_EXPORT         #define MYLIB_APIENTRY __cdecl __declspec( dllexport )     #else         #ifdef MYLIB_STATIC             #define MYLIB_APIENTRY __cdecl         #else             #define MYLIB_APIENTRY __cdecl __declspec( dllimport )         #endif     #endif #else     #define MYLIB_APIENTRY #endif  /* status codes */ typedef enum {     MYLIB_S_OK,     MYLIB_S_UNKNOWN,     MYLIB_S_ALLOC,     /* etc. */ } mylib_status;  /* Opaque struct as a context, holding the library state in private code.     Define the struct in mylib.c if it's a single file or in an internal header      (mylibi.h) if the lib consists of multiple files. Which you don't ship      with the library.      struct mylib_context { /* private vars */ };  */  typedef struct mylib_context mylib_context;  /* creates a context and ""returns"" it in out_ctx */ MYLIB_APIENTRY mylib_status mylib_create_context(mylib_context** out_ctx);  /* destroys the context and sets it to NULL */ MYLIB_APIENTRY mylib_status mylib_destroy_context(mylib_context** out_ctx);  MYLIB_APIENTRY mylib_status mylib_do_stuff(mylib_context* ctx); MYLIB_APIENTRY mylib_status mylib_get_stuff(mylib_context* ctx, int* out_val);  #ifdef __cplusplus } #endif  #endif  -- example code --  #define ASSERT_MSG(_val, ...) if(!(_val)) { fprintf(stderr, __VA_ARGS__); exit(1); }   #include <mylib.h>  int main(int argc, char** argv) {     mylib_context* ctx;     mylib_status s;      s = mylib_create_context(&ctx);     ASSERT_MSG(s == MYLIB_S_OK, ""could not create context (%d)\n"", s);      s = mylib_do_stuff(ctx);     ASSERT_MSG(s == MYLIB_S_OK, ""error doing stuff (%d)\n"", s);      int value = 0;     s = mylib_get_stuff(ctx, &value);     ASSERT_MSG(s == MYLIB_S_OK, ""error getting stuff (%d)\n"", s);      printf(""got value: %d\n"", value);      s = mylib_destroy_context(&ctx);     ASSERT_MSG(s == MYLIB_S_OK, ""could not destroy context (%d)\n"", s);      return 0; }   Things I try to keep in mind with the public interface.   Keep all structs opaque because:   It provides for a stable ABI as long as you don't modify the functions. Changing private members doesn't concern the user. It's easy to wrap in other languages.  Always return a status: ""best practice"" in C and can it can easily be mapped to exceptions in other languages. Try to make the header as compatible as possible, try to avoid C99 if possible. (stdint.h is a necessity sometimes though). Avoid suffixes such as somestruct_t, they are reserved by POSIX. Keep everything inside contexts. Nothing global. This allows for the user to instantiate the library multiple times, in multiple threads (as long as they protect the session with a mutex/semaphore) without worrying about a global state. Your public interface is the most important part of the library!   As I mentioned, these are restrictions for the public interface. Don't bother with this internally, inside the library. It might be written in C++ for all I (as a user) care."
C_Programming,3bhh0d,wild-pointer,3,Mon Jun 29 16:58:27 2015 UTC,"You might want to review the APIs of some popular C libraries to pick up on common idioms:   zlib libjpeg libpng libcurl   These might not necessarily represent the height of good design, but they do represent the height of success, in that they have all been adopted very widely and are used by thousands of projects."
C_Programming,3bhh0d,Pastrami,0,Mon Jun 29 10:28:41 2015 UTC,"So I will have to check first for null, and if the pointer is zero, throw an exception...   This isn't typically how we do it.  If a pointer argument to a function can't be NULL, then document that and make that a contract for the function, so you just let it segfault if the caller messes up.  There's no reason to give ""error code"" return values to every single function that takes a pointer as an argument, which will probably be most of your functions anyway."
C_Programming,3bhh0d,OlderThanGif,3,Mon Jun 29 07:46:26 2015 UTC,And why not fail early (in case the pointer is only copied into a data-structure) and assert that your input parameters are correct.
C_Programming,3bhh0d,BigPeteB,2,Mon Jun 29 09:41:50 2015 UTC,"If a pointer argument to a function can't be NULL, then document that and make that a contract for the function, so you just let it segfault if the caller messes up.   Dereferencing a NULL pointer is Undefined Behavior, and is not guaranteed to crash the program."
C_Programming,3bhh0d,theseoafs,2,Mon Jun 29 14:03:16 2015 UTC,"Yes, definitely. I never understood the mentality of throwing an exception for invalid arguments. If you have invalid arguments to a function/method call, the only sensible solution to that is for the program to quit immediately and alert the programmer to where they need to change the code to fix their function/method call. Putting an assert at the top of the function makes more sense to me than throwing an exception."
C_Programming,3bhh0d,BigPeteB,1 point,Mon Jun 29 15:43:27 2015 UTC,"What's wrong with error-checking? It's good defensive programming. It avoids future headaches and lets your program keep running in the face of mistakes or faults or runtime out-of-memory conditions. There's already a standard error value, EINVAL, for invalid parameters."
C_Programming,3bevrk,isalith,22,Sun Jun 28 16:21:13 2015 UTC,"In C, this is largely a question about naming conventions, and not much else. Naming conventions can make or break an API. The more consistent and easier to remember/use a naming convention is, the better the API.  I take strong influence from Olin Shiver's praise of Scheme: ""they chose a standard set of lexemes and a regular way of assembling them into the names of the standard procedures, so that you could easily remember or reconstruct names when you were coding. (I have followed this example in the development of the SRFIs I've done for the Scheme community. It is not an easy task.)""  In C, you'd never have a function called just getData(). For one, it's not namespaced, so as part of a library that I'm making use of, there's nothing to prevent it from overlapping with one of my own functions. Let's say we're making a library for, oh, MP3s. In that case, it should be called mp3GetData().  Next problem: should it be verb-noun, or noun-verb? My company's software has a bunch of separate components, and although each one is internally consistent, they follow opposite patterns depending on who first implemented it. So this has given me pretty wide experience with both.  So I feel qualified to say: verb-noun sucks. Why? Because it's not searchable. When I'm looking for an API, it's pretty much always because I have a piece of something (say, an MP3 ID3 tag) and I want to do something with it. So if you call your functions mp3Id3TitleGet() and mp3Id3TitleSet() and so on, I can easily search the source or headers for mp3Id3Title and find what I'm looking for. If you follow the verb-noun convention, you'd have either mp3Id3GetTitle() or mp3GetId3Title(). Now I can't easily search it without constructing a regex, which most IDEs don't support in their search functions.  Note that this is opposite of Java and a lot of other languages. They want it to ""read like English"", and ""object.getNoun"" sounds more like English than ""object.nounGet"". Well, too bad! Who cares if it sounds like natural English or not? I don't think that's a big enough selling point compared to being easily able to locate the function you want without knowing the verb, since it could be any number of things other than ""get"" and ""set"".   Now, what is the best way to tell other components the nature of the data (like its range, resolution, units, etc.)?   As far as types, hopefully whatever you're working with has a natural representation. In C, that means strings would be C-style null-terminated strings. (Where they're allocated is its own question.) I work with audio stuff, so volumes/gains are always in decibels. I try to make that explicit by calling the parameter gainDb instead of just gain, and I also put in the function's comment block/documentation ""gain, in decibels"".  On rare occasion, I've had to use a different unit, like centibels (1/10th of a decibel, so I can have fractional decibels without using floating point). In that case, I explicitly put it in the function's name: xyzGainSetInCentibels(int gainInCentibels). Notice that it's really in there twice: once in the function name, and once in the parameter (and I spelled it out because ""centibel"" is not commonly used and wouldn't be immediately comprehended, unlike ""dB""). Similarly, you might have nameGetAsArray() for a non-null-terminated string, or other such things.  If there is no natural representation, you need to pick one, and hopefully be consistent about it. In my case with audio, we could represent volumes and gains a bunch of different ways, but we picked decibels and stuck with it. Even so, I try to be explicit when naming APIs/parameters and when writing documentation.  But if there really is no single representation that you can use everywhere, then you really need to be explicit. Definitely name your parameters appropriately, definitely put it in the documentation where it's easy to see, and consider putting it explicitly in the name of every function. (This is common, e.g., when doing fixed-point math, where it's critical to pay attention to the format of numbers at every single step.)   Is there a good comment template?   Any comment template is good! Some are better than others, though. It ought to explain   what the function does (and I don't mean getData (or mp3DataGet) should say ""Gets the data"". What data? Writing descriptions for getters and setters is hard because they are pretty simple, but try to be more descriptive. What is the data? What format is it in? If it's variable-sized, how do I know how big is it? Do I have to allocate storage for it? Are you allocating storage for it? How do I free it later? Do I own this object and can modify it?) what parameters it takes (again, don't restate the obvious, and do state the implicit. If it's supposed to be in a particular unit or format, state that.) what the function returns (both what it returns (e.g. ""a pointer to the data"") and how it returns it (""null-terminated"", or ""as if allocated with malloc()"").)    Should I use strong types?   I'm not sure what you mean by this.   Maybe the getData() name should be more relevant?   Yes! ""Data"" is a pretty useless name. If you need a generic name for the primary data contained in something, like an MP3, how about ""contents""? But there's almost always a better name. For example, the ""data"" of an HTTP request/response is a ""body"".  No matter what, avoid using the same name in different ways. For example, if you have MP3s with ""data"", don't also refer to the ID3's ""data"". Sometimes you can bend this rule when it makes sense, though. For example, in HTTP you have headers, which have ""names"" and ""values"". But some headers' values are themselves name-value pairs of some kind. The best solution depends on what data/objects you're working with."
C_Programming,3bevrk,BigPeteB,3,Sun Jun 28 17:09:34 2015 UTC,"Note that this is opposite of Java and a lot of other languages. They want it to ""read like English"", and ""object.getNoun"" sounds more like English than ""object.nounGet"".   I think the ""verb-noun"" convention works better with a language with object-oriented constructs, like C++ or Java. In an object-oriented language, the methods will always apply to an object, so your code read more like ""noun-verb-noun"". You're saying ""Thing, do something with arguments and return some other thing.""  Starting with a noun makes more sense in C, where it's smart to start your function names with the ""Thing""."
C_Programming,3bevrk,loderunnr,1 point,Sun Jun 28 19:43:03 2015 UTC,"I can see both sides of the argument.  In C, you could use the same logic to insist on verb-noun. In order to keep a large API sensible, you wouldn't have a function like apiMoveLeg; you'd have apiPersonMoveLeg, since a Leg belongs to a Person, and you're operating on the Person object rather than the Leg itself. So with the noun-verb convention, it gets kind of messy because all of your nouns get stacked together at the front: apiPersonLegMove. (And I admit, that can be a downside, especially if your nouns nest very deeply.)  But I stand by my original argument. I really don't care how it sounds if I read it aloud as English. When I'm coding, whether it's C or C++ or Java, I'm using an IDE with autocompletion. If I start typing apiPerson (maybe followed by a . in C++ or Java), I'll get a list of autocompletions that start with leg or arm. Since I know I want to operate on a Leg, I type leg and then I get autocompletions that I can look through for an appropriate verb.  With the verb-noun strategy, I have to know the verb I need. ""Hmm, I know it's not get... is it move, or lift, or step? Maybe it's move. Oh geez, there are a hundred possible things I could move on a Person! I still have to scroll through this whole list to find out if this was the right verb."" It's ludicrous, right?"
C_Programming,3bevrk,BigPeteB,1 point,Sun Jun 28 23:18:50 2015 UTC,"Remember C convention is snake_case, not camelCase."
C_Programming,3bevrk,Kristler,2,Sun Jun 28 21:05:01 2015 UTC,"No, not really. The ""C convention"" is to remove as many letters as possible from names, giving us atoi, strcpy, and tmpnam, as well as Unix system calls like creat and fcntl.  Now, you're probably right that many pieces of software written in C use snake case as their naming convention. But others don't. (X11, OpenGL, MS Windows, just to name a few off the top of my head)  Moreover, I don't care. You will never hear me say, ""This naming convention is total crap, but thank goodness they used snake case instead of camel case [or vice versa]."" It's just not an important issue."
C_Programming,3bevrk,BigPeteB,3,Sun Jun 28 23:09:18 2015 UTC,As long as it's consistent!
C_Programming,3bevrk,leanrum,2,Mon Jun 29 00:35:45 2015 UTC,"No, not really. The ""C convention"" is to remove as many letters as possible from names, giving us atoi, strcpy, and tmpnam, as well as Unix system calls like creat and fcntl.   That was the original convention back from the days when linkers could only distinguish six significant characters in external identifiers. You see it in a lot of Fortran code as well (just have a look at LAPACK). Once that was resolved, the naming convention went to underscores_between_names, still abbreviating identifiers where that make sense and saves typing effort. This is the naming convention that is employed today by system interfaces in UNIX-like operating systems and almost all libraries that usually come with a UNIX system, a prominent exception being X11. POSIX uses it for all new interfaces, too."
C_Programming,3bevrk,FUZxxl,3,Mon Jun 29 11:01:05 2015 UTC,"I think commenting in the best way to do it. You can set up type aliases (like typedef double percentage; so that any function which returns a percentage gives the hint that it returns a number between 0 and 100), but because of C's weak typing, you can't get any enforcement from the compiler, so type aliases are really just another form of documentation.  If you want a strictly specified way to document functions, you can use Doxygen (similar to Javadocs, but multi-language), but most C programmers intend for their comments to be only human-readable, not machine-readable, and thus wouldn't bother with something like Doxygen."
C_Programming,3bevrk,OlderThanGif,3,Sun Jun 28 16:41:14 2015 UTC,"most C programmers intend for their comments to be only human-readable, not machine-readable, and thus wouldn't bother with something like Doxygen   I find Doxygen-style comments to be perfectly human-readable.  /* Gets the data of an MP3.  * @param data Pointer to storage for the data.  * @param[in,out] pLength Pointer to the length of the data storage. On successful completion, this will be set to the size of the data stored in `data`, in bytes.  * @return true if the data was successfully stored in `data`. `pLength` will be set to the size of the data.  * @return false if the data couldn't be stored. */"
C_Programming,3bevrk,BigPeteB,2,Sun Jun 28 17:13:13 2015 UTC,"Sorry, I didn't mean to suggest that Doxygen comments aren't human-readable. I meant that since many C programmers are only interested in having their comments read by humans, they don't bother formatting them against a machine-readable specification like Doxygen."
C_Programming,3bevrk,OlderThanGif,1 point,Sun Jun 28 17:16:22 2015 UTC,"If you're interested in getting stronger type checking from C, you can always wrap your types in single-member structs. It's implementation-defined whether this will add any padding to the end of the type's representation, but the standard guarantees that you can cast a pointer to a struct to a pointer to its first member, so there will never be padding at the front.  It's definitely a bit more syntax-heavy to deal with structs instead of plain scalar values, but it shouldn't add any computational overhead aside from possibly padding."
C_Programming,3bevrk,pinealservo,1 point,Mon Jun 29 03:22:24 2015 UTC,"Be careful with this. Definitely seen some compilers (older versions of MSVC, possibly current ones too) generate god awful code if you do this. Avoiding registers and shitting out movs everywhere  If you really must do this, I'd make it change to only using primitives in ndebug builds (this is not abi safe though, so be warned)"
C_Programming,3bf68y,kozukumi,2,Sun Jun 28 17:56:44 2015 UTC,5.1 has been available for a while.  Did TDM just get around to building it?
C_Programming,3bf68y,PrintStar,2,Mon Jun 29 02:51:17 2015 UTC,This is a big update to GCC and the first release of GCC 5 (although named 5.1 it is what would have been called 5.0 however they have adopted a new numbering scheme)
C_Programming,3bdpnm,glory_df,19,Sun Jun 28 06:24:34 2015 UTC,"C11, of course. Though the changes aren't huge compared to 89, there's some very useful new stuff."
C_Programming,3bdpnm,raevnos,3,Sun Jun 28 06:35:25 2015 UTC,"Do you have any book recommendations for that? I have prior C++ experience so I'll be fine even if it's not an 'absolute' beginner's book.  Also, just how many of today's open source projects are in C11 compared to the other previous standards? Will learning C11 make me unable to understand older code?"
C_Programming,3bdpnm,adamnemecek,1 point,Sun Jun 28 06:47:12 2015 UTC,this book is pretty good but it's work in progress http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf
C_Programming,3bdpnm,imaami,8,Sun Jun 28 23:02:38 2015 UTC,C11.
C_Programming,3bdpnm,ruertar,6,Sun Jun 28 07:48:52 2015 UTC,Dive head first into C99/C11.
C_Programming,3bdpnm,FUZxxl,4,Sun Jun 28 11:26:29 2015 UTC,"I recommend you to start learning C, any version of the language. After you have a solid grasp of how to write C programs you can go into what is different between the various standards and implementations. It is important to understand these differences if you want to write portable software as some vendors (like Microsoft) ship outdated compilers and standard libraries, but this information is just confusing when you are still learning."
C_Programming,3bdpnm,raccjoe,3,Sun Jun 28 14:07:55 2015 UTC,I recommend C Primer Plus. It gives a overview of ANSI C/C99/C11 and its differences.  Sometimes a bit wordy but at the end you will have enough working knowledge to work through any C code. If you're on windows don't use the MSVC as its support for C is severly lacking. Use Pelles C instead (most C11 compatible compiler afaik but haven't had any problems with the gcc port so far either). C11 doesn't fundamentally change the language so don't worry about it. Although I'm a bit sad that we won't see threads.h in glibc supported for another 10 years probably (guess because it's optional..).    Also C A reference Manual(C99) is a great book after you got the basics down but not necessary.
C_Programming,3bdpnm,PriceZombie,1 point,Sun Jun 28 13:12:58 2015 UTC,C Primer Plus (6th Edition) (Developer's Library)           Current $44.61 Amazon (New)   High $46.34 Amazon (New)   Low $38.44 Amazon (New)    $44.79 (30 Day Average)    Price History Chart and Sales Rank  C: A Reference Manual (5th Edition)           Current $44.96 Amazon (New)   High $48.92 Amazon (New)   Low $35.48 Amazon (New)    $45.38 (30 Day Average)    Price History Chart and Sales Rank | FAQ
C_Programming,3bdpnm,autowikibot,1 point,Sun Jun 28 13:13:15 2015 UTC,"C11 (C standard revision):       C11 (formerly C1X) is an informal name for ISO/IEC 9899:2011,  the current standard for the C programming language. It replaces the previous C standard, informally known as C99. This new version mainly standardizes features that have already been supported by common contemporary compilers, and includes a detailed memory model to better support multiple threads of execution. Due to delayed availability of conforming C99 implementations, C11 makes certain features optional, to make it easier to comply with the core language standard.       Relevant: C (programming language) | C++ Technical Report 1 | ANSI C   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
C_Programming,3bdpnm,Spudd86,1 point,Sun Jun 28 13:13:42 2015 UTC,Check out tinycthread it implements most of thread.h in terms of pthreads/windows threads
C_Programming,3bdpnm,raviqqe,1 point,Sun Jun 28 16:48:05 2015 UTC,I guess n1570.pdf ends up next to you.  just kidding. :)
C_Programming,3bdpnm,Wiggledan,2,Mon Jun 29 00:10:11 2015 UTC,"8-month C beginner here.  There are less differences between standards than you would think. C99 mostly added some conveniences, and C11 added some more advanced modern things for multi-threading.  Just learn any version of C (K&R was written before C89, and tons of people learned/are learning from it), and be sure to be aware of the differences later on. You can easily list all the differences on a single piece of paper, so it isn't a big deal which you learn from."
C_Programming,3bdpnm,cunttard,2,Sun Jun 28 20:03:34 2015 UTC,"For those that work on embedded systems such as PIC, Arduino, AVR, etc. Can you get away with doing C99? I know for 8051 the Kiel C compiler remains restricted to C89/ANSI.  For some reason Visual C++ will never support C99 fully, so the safest choice still seems to be C89."
C_Programming,3bdpnm,angdev,1 point,Mon Jun 29 05:25:22 2015 UTC,"IAR Workbench supports C89, C99, C11, some awesome C-extensions, and Embedded C++. If I had to do embedded programming in any other environment than IAR's software I'd quit my job and work elsewhere."
C_Programming,3bdpnm,colonelflounders,3,Mon Jun 29 19:26:07 2015 UTC,"You will want to learn all of them, but I would put less priority on C11 for now as it is still being implemented. There may be some compilers that you will have to work with that only support C89, and others may support C99. Honestly, you should learn whatever you need to for the toolset that you use, so see what your compiler supports."
C_Programming,3bdpnm,GenTiradentes,26,Sun Jun 28 07:13:07 2015 UTC,"I'll add to this by saying that the oldest standard is invariably the most widely used and supported. Learn C89, then learn C99 and C11. C isn't an overly expansive language, and the standard library is relatively simple. You'll benefit from being able to write C that's compatible with every compiler, as well as taking advantage of newer features when they're available."
C_Programming,3bdpnm,BasedHunter,3,Sun Jun 28 09:14:16 2015 UTC,"Concur.  It depends on your programming environment, but in my case, doing C programming for the U.S. Navy, the code I maintain has to work on HP-UX, Solaris, Linux, Windows, and (on thankfully, thankfully rare occasions, and for a loose meaning of ""work"") VMS (curses be upon it).  Old versions of the operating systems, running old versions of the compilers.  I look upon the cool new C features and weep, then go back to coding to C89 and finding out the hard way what features are supported in common as compiler extensions."
C_Programming,3bdpnm,BigPeteB,1 point,Sun Jun 28 20:16:27 2015 UTC,"and (on thankfully, thankfully rare occasions, and for a loose meaning of ""work"") VMS (curses be upon it)   Interesting. I love computing history but don't know much about VMS, other than it's very ""love it or hate it"". I previously got someone who'd worked with it to explain what was so good about VMS. Would you care to offer your opinion for contrast?"
C_Programming,3bdpnm,BasedHunter,1 point,Mon Jun 29 15:51:37 2015 UTC,"I don't have nearly as much experience as that (with VMS or in general), so I'm not in much position to criticize.  VMS is totally unfamiliar to me (down to the basic commands and file system), and its C environment (at least with the one I've had to work with) is the most restrictive by far.  My only experience with it are the rare occasions we needed to get the tools to work on VMS for the sake of 9 tracks (our only use for VMS, I think), in which case I'd have to revise the code added since last time so that it would compile and run on the VMS (after re-remembering how to recompile it).  Too much code written to specially handle tasks on the VMS, or disabled because we can't figure out (or be troubled to figure out) how to make it work on VMS, or untested, etc..."
C_Programming,3bdpnm,TraylaParks,6,Mon Jun 29 23:05:28 2015 UTC,Wtf? Who downvoted you?  This advice is exactly correct
C_Programming,3bdpnm,existentialrobot,2,Sun Jun 28 11:18:44 2015 UTC,"Not OP, but I appreciate this advice. I'm going to save this post for reference, just in case I forget."
C_Programming,3bdpnm,flamesflight,-1,Sun Jun 28 11:28:12 2015 UTC,"Google ""Learn C the Hard Way"" by Zed Shaw. It's is available now as a free web book."
C_Programming,3bdpnm,gryftir,-7,Mon Jun 29 05:45:27 2015 UTC,I'd check out Learn C the Hard Way and 21st Century C.
C_Programming,3bdvay,pragm,7,Sun Jun 28 07:55:26 2015 UTC,No.  It's complete garbage.  I gave up after finding a half dozen or so false or misleading statements after a few minutes of reading.
C_Programming,3bbmhs,Ajpennster,5,Sat Jun 27 17:48:07 2015 UTC,"Your code doesn't create a copy of the string. The pointer scopy just points to each character of source in turn. Line 11 is exactly equivalent to just source[i] = source[i]; because scopy is pointing to source[i], and obviously that doesn't do anything."
C_Programming,3bbmhs,zifyoip,11,Sat Jun 27 18:07:54 2015 UTC,"I love when you try to help someone out and they get pissy at you for ""not understanding their approach""."
C_Programming,3bbmhs,nevinera,0,Sat Jun 27 22:07:42 2015 UTC,"I never got ""pissy"" at you. I just asked if you understood the approach I was taking."
C_Programming,3bbmhs,nevinera,2,Sun Jun 28 19:40:24 2015 UTC,"Wasn't me. But if you didn't mean to come across that way, you should probably work on your tone - clearly other people got that sense from you as well."
C_Programming,3bbmhs,zifyoip,1 point,Mon Jun 29 00:33:36 2015 UTC,"Ah, my bad"
C_Programming,3bbmhs,shinmai_rookie,-12,Mon Jun 29 00:58:12 2015 UTC,"thats the point. I'm modifying the string, not making a copy of it."
C_Programming,3bbmhs,ruertar,4,Sat Jun 27 18:13:59 2015 UTC,"Well, you're not modifying anything, either. How can source[i] = source[i]; possibly modify anything?"
C_Programming,3bbmhs,baudvine,-15,Sat Jun 27 18:14:47 2015 UTC,Do you understand the approach I'm taking for this problem?
C_Programming,3bbmhs,F54280,5,Sat Jun 27 18:28:46 2015 UTC,You should change *scopy=source[i]; to *scopy=source[i+1];.
C_Programming,3bbmhs,doodlebro,-18,Sat Jun 27 18:35:57 2015 UTC,I dont have source[i]=source[i] in my code buddy.
C_Programming,3bbmhs,shinmai_rookie,10,Sat Jun 27 18:38:39 2015 UTC,You effectively do.  You should spend less time calling people buddy and being argumentative and listen more carefully.
C_Programming,3bbmhs,zifyoip,2,Sat Jun 27 22:37:09 2015 UTC,"I think I'm going to hold on to ""calling people buddy"" as a saying - I didn't notice he'd actually used that word and yet your remark fit perfectly."
C_Programming,3bbmhs,dumsubfilter,9,Sun Jun 28 06:12:57 2015 UTC,Your capacity to listen and your certainty are going to be two huge drag for your computing career...
C_Programming,3bbmhs,dumsubfilter,5,Sat Jun 27 23:15:58 2015 UTC,I'm surprised we have this much patience for him.
C_Programming,3bbmhs,dumsubfilter,4,Sun Jun 28 06:01:25 2015 UTC,"Fixed. And in the if condition, change i != index to i > index, because you don't need to copy a string into itself when it's exactly the same (and before index it's exactly the same)."
C_Programming,3bbmhs,dumsubfilter,4,Sat Jun 27 18:44:30 2015 UTC,"No, but in your code *scopy is always equivalent to source[i], and you do have *scopy = source[i], which is equivalent to source[i] = source[i], which clearly doesn't do anything."
C_Programming,3bbmhs,nevinera,2,Sat Jun 27 22:11:01 2015 UTC,"char* scopy = &source[0];   Just do this:  char *scopy = source;   Note that this doesn't actually copy anything.  It just makes this pointer point to the same memory address as that pointer.     // loops through the string, keeping its contents until index is found. for (int i =0; i< strlen(source); i++) {   Better might be:  for(int i =0; source[ i ] != '\0'; i++) {   Realistically your compiler is going to optimize that, and not actually call strlen every pass of the loop.  Theoretically, it should be, because that's what you're asking it to do.  Instead you can just check to see that you have not reached the end of the string by testing it against the nul character.     Looking back at that, you should see that you have two actual problems:    You don't actually make a copy of the string.  You don't actually return that copy (not just because it doesn't exist, but because of how pass by value actually works).      Fixing problem one:  void fun( char *s, int i ) {     if( s == NULL )         return;     else     {         int len = strlen( s );         char *copy = malloc( len + 1 );         ... do stuff ...     } }   If you assume that the index will always be present in the string, you could get away without adding the + 1 in your malloc.  Even if you didn't assume that, you could always just test:  if( i <= len ) // continue, else return and don't do anything      Fixing problem two involves changing your function definition:  void removeChar(char* source, int index) {   You either need to return the new string:  char *removeChar( char *source, int index ) {     ... do stuff ...     return copy; }   Or you need to pass a pointer to a pointer, and update that way:  void removeChar( char **psource, int index ) {     ... do stuff ...     *psource = copy; }"
C_Programming,3bbmhs,ddboline,-2,Sat Jun 27 18:12:44 2015 UTC,"why do i need to pass a pointer to a pointer? I dont plan on using a copy, just modifying the string itself.   EDIT: the approach is to iterate over the string, and copying the contents. When it reaches the index, it will skip and fill the index with the next character."
C_Programming,3bbmhs,ruertar,1 point,Sat Jun 27 18:26:43 2015 UTC,"If you are modifying the original you will have to make sure not to use string literals as arguments:  removeChar( ""Hello World!"", 3 );      You don't even need a ""copy"" pointer, and you don't even need to start ""copying"" until you are at the index:  if( len < index )     return;  for( i = index; source[ i ] != '\0'; i++ )     source[ i ] = source[ i + 1 ];"
C_Programming,3b6yz0,blkpingu,11,Fri Jun 26 13:56:59 2015 UTC,Unless you're trying to teach someone to code I'd argue that using a version control system like git would be infinitely more valuable.
C_Programming,3b6yz0,Drainedsoul,5,Fri Jun 26 16:06:12 2015 UTC,"Yes, its called git"
C_Programming,3b6yz0,Heavyweight87,3,Fri Jun 26 18:54:28 2015 UTC,Floobits will do just the job!
C_Programming,3b6yz0,anonbrah,2,Fri Jun 26 22:34:51 2015 UTC,"How bout VNC + voice chat? Probably want to set up a clean, non admin account or a VM for this. Unless you're the type of coding buddy who likes to have people hang out among your dirty laundry."
C_Programming,3b6yz0,afonso360,2,Fri Jun 26 14:32:19 2015 UTC,You might be looking for this  https://codepad.remoteinterview.io/  Beware if you have an infinite loop it will not compile the code :(
C_Programming,3b6yz0,Theighty,1 point,Fri Jun 26 19:31:52 2015 UTC,"This is a pretty handy tool, thanks for sharing :)"
C_Programming,3b6yz0,aninteger,2,Fri Jun 26 23:57:30 2015 UTC,You can do pair programming using tmux.   http://pivotallabs.com/how-we-use-tmux-for-remote-pair-programming/  Google for tmux and pair programming. It's pretty awesome
C_Programming,3b6yz0,luladjiev,1 point,Sat Jun 27 04:36:55 2015 UTC,Probably something like Koding might work for you but I think it's not free if you want to team up with someone
C_Programming,3b6yz0,noroot,1 point,Fri Jun 26 14:33:05 2015 UTC,"I've been coding together with an (mostly) online buddy of mine the last few weeks. We are using voice chat (Tox, Mumble, Skype, Teamspeak, some SIP, voice plugin for xmpp, whatever you like) for communication.  For the code share, we are using a 5$ digital ocean VPS and share a tmux session :). Ssh works fine, but I love to use mosh. In the tmux session we have some windows with an editor (vim), one for compiling and running/testing and some more for random scribbles.  It does require good communication, because you can both issue commands at the same time and insert stuff. For us it works out really great!"
C_Programming,3b6yz0,sgthoppy,1 point,Fri Jun 26 16:09:08 2015 UTC,How did you setup tmux? Could you share your config/startup script for it? I'd really like to get that setup for my friend and I.
C_Programming,3b6yz0,noroot,1 point,Sat Jun 27 22:26:45 2015 UTC,"I'm sorry for the somewhat late reply. We use the default configuration that comes with the latest ubuntu LTS. We both just fire up tmux attach (or -d if we want to irritate the other guy :D) and are ready to go. For us it works fine out-of-the-box like that.  One thing I want to look into is setting up a config that will start with a few windows and give them proper names, but given that downtime is a very rare thing on this VPS and I'm lazy... ;)."
C_Programming,3b6yz0,FUZxxl,1 point,Mon Jun 29 20:56:55 2015 UTC,You could use a tmux session both of you attach to.
C_Programming,3b5sam,mysleepyself,2,Fri Jun 26 05:04:08 2015 UTC,"In your callback you're always mixing the first 512 samples of buffer with the output.  I'm assuming that's not what you want to do, and that you want to mix each corresponding sample in buffer with the corresponding input sample.  To do that you'd need to keep some state that tells what the last position in buffer that you read from was, so that you can start there on the next callback instead of starting over at zero each time.  You could do that with a global variable, but it's a little icky.  Instead, consider creating a struct that contains a pointer to the buffer as well as the current index, and pass a pointer to that around as your userdata.  And of course you'll need to add some checks to ensure that you don't walk past the end of the buffer if your input is longer than the buffer, so you should add the buffer length as a parameter to that struct so that you can either stop the stream or loop the index back to zero when that happens."
C_Programming,3b5sam,Rhomboid,1 point,Fri Jun 26 05:23:09 2015 UTC,You're talking about how the integer i in the callback will always start from 0 making it really poor for iterating thru my buffer right? That makes sense I feel pretty dumb now for not realizing that. Thank you for helping. :]
C_Programming,3b5sam,Rhomboid,1 point,Fri Jun 26 05:58:57 2015 UTC,"Also, depending on the magnitude of the samples, you might get clipping and distortion by directly adding them.  Usually there's a divide by 2 in there, i.e. mixing is averaging."
C_Programming,3b5sam,Aransentin,1 point,Fri Jun 26 06:04:15 2015 UTC,Ah cool won't hurt to do that.
C_Programming,3b5sam,Aransentin,1 point,Fri Jun 26 06:14:50 2015 UTC,"In addition to what Rhomboid is saying, you have a buffer overflow in  items_written = fread( buffer, sizeof(float), bufsize, fileptr);   You are reading sizeof(float)*bufsize bytes, which is four times larger than your buffer size."
C_Programming,3b5sam,OldWolf2,2,Fri Jun 26 05:32:58 2015 UTC,"I'm a bit confused I may have just misread when I did man fread or one of the other functions I used. The file ""recorded.raw"" is 882kb when I run my compiled code it prints out items written being 220500 which I took as 220500 elements which I multiply by the size of a float giving me 882000 meaning 882kb in the buffer? Could it be that I allocated my memory wrong as opposed to reading data into the buffer wrong? Either way a buffer overflow is no good so I'll start looking into it right now. Thank you for the help! :]"
C_Programming,3b66w3,blkpingu,2,Fri Jun 26 08:12:33 2015 UTC,it made the code blow up because you always need to wrap around %DELTA t in this fashion:   I don't get it.  What's wrong with the code snippet?   starts a clock from 0 to x and activates the switch case function with the certain states of the traffic light.   I don't understand what you're trying to do.
C_Programming,3b66w3,mythicalmammoth,2,Fri Jun 26 08:52:07 2015 UTC,"Actually, does anyone know what the point of difftime() is?  What's wrong with just doing t1 - t2?"
C_Programming,3b66w3,mythicalmammoth,2,Fri Jun 26 08:54:25 2015 UTC,Argh.  I suppose it's in case time_t is a struct or something.
C_Programming,3b66w3,mythicalmammoth,1 point,Fri Jun 26 08:56:14 2015 UTC,"okay, sorry guys. i think i explained it too complicated.  no, but i need more then y-x because I have 4 states. So basically i need to monitor the clock somehow and when a certain clock time is true, the state switches.  so like   0-20 seconds = red 21-23 seconds = red/yellow 24-34 seconds = green 35-37 seconds = yellow time back to 0; repeat.  so: I'm trying a switch case for this function, but i look for a simpler solution then difftime(). or a way to implement difftime() in a neat way."
C_Programming,3b66w3,mythicalmammoth,2,Fri Jun 26 09:17:40 2015 UTC,"Well, if you wanted to control a real traffic light, you couldn't do it with a userspace program.  At the very least you'd need a real time kernel with bounded scheduling latencies, and control over when/if your thread gets preempted.  But I don't suppose that's what you're asking."
C_Programming,3b66w3,mythicalmammoth,1 point,Fri Jun 26 09:45:59 2015 UTC,"It's perfectly possible to program this in C, the question is how."
C_Programming,3b66w3,mythicalmammoth,1 point,Fri Jun 26 10:17:23 2015 UTC,"Well, if this is a homework assignment, then I'd like a word with your professor. :-)"
C_Programming,3b66w3,mythicalmammoth,1 point,Fri Jun 26 10:28:24 2015 UTC,traitor! :c
C_Programming,3axx79,childofprophecy,4,Wed Jun 24 11:39:57 2015 UTC,"Surprisingly, these are truly well done! Recommended."
C_Programming,3axx79,cabbageturnip,3,Wed Jun 24 22:35:44 2015 UTC,Love it - thanks.
C_Programming,3axx79,zenCbot,2,Thu Jun 25 03:31:55 2015 UTC,"Really fun puzzles , thanks for sharing!"
C_Programming,3axx79,TimeFlies89,1 point,Thu Jun 25 07:46:47 2015 UTC,"d is converted to a size_t in the expression d <= (TOTAL_ELEMENTS-2), and the expression evaluates falsely when d == -1.  Two issues here. The - in OS_HP-UX_print is not a valid character for an identifier, and there is an execution path where num is referenced when it is uninitialised (in such a scenario the return value of scanf is less than 1).  If <stdio.h> were included, it would be 1. continue jumps to the tail of the do statement.  stdout is probably fully-buffered or line-buffered.  #a takes a literally, g(a) expands g and a.  default is mis-spelled, if it were spelled correctly, either of the three cases could be triggered depending upon the charset. With ASCII, it should print NONE.  If <stdlib.h> were included, it may fail if malloc returns a null pointer.  Might skip this one.  Might be 1.0, might not be 1.0. Should compare within an interval.  , is used as a separator for initialiser values in that context.  Yes. 4321  It's Duff's vibrator\b\b\b\b\b\b\b\bdevice and it's trying to accomplish premature ejaculation\b\b\b\b\b\b\b\b\b\b\boptimisation! ;-)  I'd just test it like this.      #include <assert.h>      ...      unsigned i;      for (i = 0; i < UINT_MAX-1; i++)             assert(count_bits_correct(i) == CountBits(i));     assert(count_bits_correct(UINT_MAX) == CountBits(UINT_MAX));   The first function has zero parameters and the second has an unspecified number of parameters.  Both calls to printf have undefined behaviour. Any output or no output, will do.  There's no attempt to produce output and an int * isn't an int[80].  b's uninitalised.  This has the same problem as the first call to printf three questions ago. Instead of printf pretending a double is an int, it pretends a size_t is an int. In any case, sizeof arr == sizeof (int *).    Might try more later.  There's some good puzzles, but I'm sure I'm seeing more issues with the code than the author. I've liked the first one the most so far, it took me a while to think of the answer.  Here's one I thought of:      unsigned short a = 5;     unsigned long c = 8;   What is the type of a << c?  There's two possibilities. :-)"
C_Programming,3b3z6s,tmtwd,13,Thu Jun 25 19:50:59 2015 UTC,"Well, yes, of course; it's just an array. There's nothing special about the value '\0' in an array that prevents you from incrementing past that element. That value is exactly the same as the value 0, and of course there's nothing preventing you from incrementing past an element of an array that happens to have the value 0."
C_Programming,3b3z6s,zifyoip,1 point,Thu Jun 25 19:57:50 2015 UTC,"what's the difference between '\0' in an array, and the one that terminates it?  Why is =='\0' a viable flag for the end of a string then?"
C_Programming,3b3z6s,sepehrhm,12,Thu Jun 25 20:11:54 2015 UTC,"Nulls don't terminate arrays.  An array's size is fixed and doesn't depend on its contents.  A string can occupy all of an array, or a portion of an array; the length of the string and the length of the array are unrelated except for the fact that the string can't be longer than the array (when accounting for the terminator, and ignoring the flexible array member technique.)  That's why it's necessary to keep track of the length of the string, either explicitly in some size variable, or by using a terminator of some sort.  The null character is traditionally the one used, but that's just convention."
C_Programming,3b3z6s,Rhomboid,2,Thu Jun 25 20:30:16 2015 UTC,Just to add:  The nul character is by definition what makes a string a string.  An array of char does not necessarily mean you have or want a string.  Neither does having one of those be 0.
C_Programming,3b3z6s,dumsubfilter,1 point,Fri Jun 26 03:31:20 2015 UTC,"In communications, you can run into zero padding between blocks of data. Even though you can be working with character arrays, you have to be careful. I've seen situations where two ascii words were unexpectedly separated by /0."
C_Programming,3b3z6s,f5f5f5f5f5f5f5f5f5f5,3,Fri Jun 26 02:35:26 2015 UTC,"what's the difference between '\0' in an array, and the one that terminates it?   There isn't. I think you've misunderstood the code. bubb holds to the valid string ""a"". If we did printf(""%s"", bubb) it will produce ""a"" on the console output.  Usually   while (*bubb++); *bubb   would be referencing invalid memory. But here we've hidden a 'd' character after the string, so it's ""ok"".  char *bubb = ""hello there my dear""; while (*bubb++); *bubb   is ""invalid"" code. (I say ""invalid"" rather than ""invalid"" because you probably won't hit a problem with it on windows/x86 linux, but it's undefined behaviour)"
C_Programming,3b3z6s,Poddster,3,Thu Jun 25 20:22:59 2015 UTC,"what's the difference between '\0' in an array, and the one that terminates it?   There is none.   Why is =='\0' a viable flag for the end of a string then?   It works because (and only when) people follow the convention to use null termination when populating char arrays with data.  If you want to know why '\0' is used as opposed to something else if there's nothing special about '\0', the answer is: '\0' represents a character that doesn't get used for anything else. In ASCII '\0' is a control character named ""NUL"". In Unicode there a character U+0000 which is named ""NULL"", that also doesn't get used for anything else.  One can (almost) as easily use 'e' to terminate strings, except that people often want to use 'e' for other things.  The one thing that does make '\0' somewhat special compared to other characters is that if evaluated as a boolean it happens to evaluate as 'false', whereas everything else evaluates as 'true', but this is merely a convenience.    I've written a little library so you can use 'e' terminated strings instead: http://pastebin.com/kEBQaDEb  char buf[65]; e_strcpy(buf, ""If you want to put \0 in a string, you might find E-strings work.e""); assert(e_strlen(buf) == 64); e_puts(buf, stdout);"
C_Programming,3b3z6s,bames53,1 point,Thu Jun 25 21:35:13 2015 UTC,"\0 is a just a place holder byte for many string functions to ""utilise up-to"".  Other systems may use other conventions, such as classic MacOS use pascal strings instead of null strings, where the first byte(s) designated the length of the string instead of doing a search for a 0 to figure out the length.  BASIC strings store the length separately from the content, so you can have whatever you like inside the string as the length is known.  Outside of some null-string-related functions it means absolutely nothing."
C_Programming,3b3z6s,EkriirkE,1 point,Thu Jun 25 23:36:28 2015 UTC,\0 is just a byte with value zero. That's all.
C_Programming,3b3z6s,neutralinostar,9,Sun Jun 28 19:33:56 2015 UTC,"Yeah, the ++ changes the pointer after the while is false."
C_Programming,3b3z6s,Spanone1,6,Thu Jun 25 19:57:36 2015 UTC,"Maybe it's appropriate to point out that in C (and C++) that it's perfectly ok to have a pointer to one past the end of an array. However, it's not ok to dereference it."
C_Programming,3b3z6s,mad_poet_navarth,3,Thu Jun 25 23:10:34 2015 UTC,"Christ, there's so much misinformation here. The reason the assert passes is because after the while loop cue points to 'd' (the value of the expression in the while test is the one before the increment happened). If you dont get it, look up post increment, the C precedence table, and put a printf of *cue in the while loop body."
C_Programming,3b3z6s,kitchen_patio,7,Fri Jun 26 05:09:46 2015 UTC,"The while(*cue++) is checking the value then incrementing. You're not passing the value, you're just incrementing after the check.  If you want to walk the array until you hit a null you should increment before checking: while(*++cue)"
C_Programming,3b3z6s,jotux,2,Thu Jun 25 20:09:51 2015 UTC,"Consider the traditional implementation of strcpy:  char *strcpy(char *dest, const char *src) {    char *save = dest;    while(*dest++ = *src++);    return save; }"
C_Programming,3b3z6s,bames53,5,Thu Jun 25 21:46:07 2015 UTC,"Because you want to copy the first null and then quit, not just quit at the null."
C_Programming,3b3z6s,mattstreet,2,Thu Jun 25 23:06:15 2015 UTC,postincrement.
C_Programming,3b02nz,pragm,2,Wed Jun 24 21:56:49 2015 UTC,"C is an awesome language. If there had been no C, there wouldn't have existed C++, Java, C# and all other ""MODERN"" languages..   As for what can be created in C, there is a simple example like this http://www.wincodebits.in/2015/04/library-management-system.html"
C_Programming,3b02nz,Crazy_Coder,-7,Sun Jun 28 06:11:38 2015 UTC,"A legitimate question. What the author was really asking was ""What is C well suited for?""  C is not well suited for: * GUI programming (GTK for a modern UI? really?) * Mobile programming (I double dare you to call the native APIs) * Web back-end programming   Namely, not for greenfield programming of anything that's not close to the metal."
C_Programming,3b02nz,wrong_assumption,9,Wed Jun 24 22:35:19 2015 UTC,"I know C is not as simple as other languages but maybe some papers/data to back up your claims?   PHP is much easier than C, that I know, but still there are libs that can make it simple(er) to make web applications.   A few years ago I did some GUI Win32 applications all in C and that didn't seem so hard.  Haven't done any mobile programming so can't really comment on that."
C_Programming,3b02nz,antoniocs,0,Thu Jun 25 08:59:37 2015 UTC,What would be for modern UI then?
C_Programming,3avm39,z0mz0m,1 point,Tue Jun 23 21:25:09 2015 UTC,"There's a page on the MSDN explaining how to do it, or you could just use this tool and it does it all for you. I've used it for years, it works great."
C_Programming,3avm39,angdev,1 point,Tue Jun 23 21:37:27 2015 UTC,"Thanks, do you have a link to the msdn article?"
C_Programming,3avm39,dream_in_code,1 point,Tue Jun 23 22:45:43 2015 UTC,"Here is the MSDN article that tells you know to embed a manifest file in an exe. I'm not sure how easy it is in Visual Studio as I've only ever needed to do it from gcc, but hopefully you can make it work for your needs/environment."
C_Programming,3avmin,Lurricane,4,Tue Jun 23 21:28:18 2015 UTC,"There's lots of things wrong here.  Firstly, structure[0].pointer is already a pointer, i.e. it has type int *.  Taking its address results in a value of type int **, which is not what the function takes and should have generated a diagnostic.  Secondly, inside do_something(), no line that begins with pointer = ... can ever have any effect on the caller.  The argument pointer is passed by value, like everything in C always.  Assigning to it changes the local copy of the pointer, but when the function finishes, that copy evaporates.  The only way to affect a caller's value is to dereference the pointer and assign to that.  I don't understand why you declared your struct as containing a pointer to int, but you never actually set it to point to a valid int anywhere.  structure[0].pointer = 0 assigns it to point to the null pointer.  The null pointer may not be dereferenced, so it's not going to work at all with what you're trying to do here.  The basic template for having a function modify a variable of the caller look like this:  #include <stdio.h>  void do_something(int *ptr) {     *ptr *= 2; }  int main(void) {     int somevar = 42;      do_something(&somevar);     printf(""%d\n"", somevar);    // => 84     return 0; }   If the variable is a member of a struct, then it looks like this:  #include <stdio.h>  typedef struct {     int someint; } mystruct;  void do_something(mystruct *ptr) {     ptr->someint *= 2; }  int main(void) {     mystruct ms = { 42 };      do_something(&ms);     printf(""%d\n"", ms.someint);     // => 84     return 0; }   Here a pointer to the struct is being passed to the function, which dereferences the pointer and assigns to the someint field.  Remember that ptr->someint is the same as (*ptr).someint.  In both cases, the caller's value is affected because the pointer is dereferenced.  Writing anything with ptr = ... would not have an effect, because that's changing what the local copy of the pointer points to, not dereferencing it to get to the caller's variable.  Edit: I forgot to add that if it's important that the function being called not know about the struct (i.e. you want to use the first version of do_something()) then you can also do that, i.e.  #include <stdio.h>  typedef struct {     int someint; } mystruct;  void do_something(int *ptr) {     *ptr *= 2; }  int main(void) {     mystruct ms = { 42 };      do_something(&ms.someint);     printf(""%d\n"", ms.someint);     // => 84     return 0; }   This is essentially the same as the first version except with ms.someint replaced for somevar.  But be sure you understand why it's wrong for the struct to contain a pointer to an int.  The original program declared somevar as an int, and so too must the struct.  (It is of course possible to create a struct with a pointer to int, but that's overcomplicating things unless you have a specific need for that.)"
C_Programming,3as5uz,johnmudd,10,Tue Jun 23 02:03:03 2015 UTC,"Just because Valgrind can't detect it doesn't mean doesn't mean other tools can't.  The Address Sanitizer (available in clang and gcc >= 4.9) can:  $ cat testcase.c  int main() {     char x[10];     x[11] = 'a'; }  $ gcc -fsanitize=address testcase.c   $ ./a.out ================================================================= ==4379==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff51fe702b at pc 0x400830 bp 0x7fff51fe6ff0 sp 0x7fff51fe6fe8 WRITE of size 1 at 0x7fff51fe702b thread T0     #0 0x40082f in main (/tmp/work.kgEm/a.out+0x40082f)     #1 0x7f16da6e5b44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)     #2 0x4006b8 (/tmp/work.kgEm/a.out+0x4006b8)  Address 0x7fff51fe702b is located in stack of thread T0 at offset 43 in frame     #0 0x400795 in main (/tmp/work.kgEm/a.out+0x400795)    This frame has 1 object(s):     [32, 42) 'x' <== Memory access at offset 43 overflows this variable HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext       (longjmp and C++ exceptions *are* supported) SUMMARY: AddressSanitizer: stack-buffer-overflow ??:0 main Shadow bytes around the buggy address:   0x10006a3f4db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4dc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4dd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4de0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4df0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 =>0x10006a3f4e00: f1 f1 f1 f1 00[02]f4 f4 f3 f3 f3 f3 00 00 00 00   0x10006a3f4e10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4e20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4e30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4e40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   0x10006a3f4e50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Shadow byte legend (one shadow byte represents 8 application bytes):   Addressable:           00   Partially addressable: 01 02 03 04 05 06 07    Heap left redzone:       fa   Heap right redzone:      fb   Freed heap region:       fd   Stack left redzone:      f1   Stack mid redzone:       f2   Stack right redzone:     f3   Stack partial redzone:   f4   Stack after return:      f5   Stack use after scope:   f8   Global redzone:          f9   Global init order:       f6   Poisoned by user:        f7   Contiguous container OOB:fc   ASan internal:           fe ==4379==ABORTING   Note: If you actually enable optimization then the whole program is optimized away since x isn't used, and the error goes away, so in a real world situation you'd have to come up with a better testcase."
C_Programming,3as5uz,Rhomboid,1 point,Tue Jun 23 02:25:15 2015 UTC,"Thanks, just what I need.  Here's a nice comparison chart."
C_Programming,3am68o,Wiggledan,4,Sun Jun 21 16:14:39 2015 UTC,"In remove_task() you aren't updating p->next->prev. Similarly in insert_task() you don't always initialize the prev field. This is the source of your problems. Really, there's no reason to maintain this as a doubly-linked list since you're never traversing it backwards except to peek backwards as you're freeing it. But since you don't maintain the prev pointers correctly, you end up crashing (double-free, etc.). You have an off-by-one error in read_input(). It should be i >= max_len and the realloc should include a + 1. Otherwise you'll write a NUL past the end of the buffer at the end. In change_category() you copy a new category into the old allocation without checking its size."
C_Programming,3am68o,skeeto,2,Sun Jun 21 19:46:15 2015 UTC,"Thanks for your very informative feedback, as usual! It looks like I looked over some small things as this program grew. I'm starting to see why C can be so sneaky with its errors.  I also noticed that I was only using prev in remove_task() and free_list(). I figured it would save lines and be more expandable for the future, but I guess it ended up adding more complexity than I thought in the end."
C_Programming,3am68o,bunkoRtist,2,Sun Jun 21 23:43:59 2015 UTC,"It's not that sneaky, but the trick is to not re-invent link-list implementations every time. Encapsulate as much as possible. Write functions like list_push_front(), list_push_back(), list_pop_front(), list_pop_back() etc etc... you can inline them and lose zero performance, at the same time avoiding silly mistakes."
C_Programming,3am68o,uncathartic,1 point,Mon Jun 22 04:49:28 2015 UTC,"free_list frees the prev pointer, which is going to be undefined on the second iteration of the loop. That's why it crashes most likely. I'd recommend freeing the current element on each iteration instead, saving it's next pointer to a temporary variable for further traversal. Also, you might want to set the elements to NULL after freeing them."
C_Programming,3am68o,holoscenic,1 point,Sun Jun 21 16:34:05 2015 UTC,"You start at the first position in the list and try to free the position before the first, which is probably where the majority of the issue is coming from.  Basically, ""p"" is first and you try to go and free ""p->prev"" which is undefined and might not have a NULL value."
C_Programming,3altx5,Asolmanx,3,Sun Jun 21 14:11:29 2015 UTC,"This isn't C programming related.  What you're looking for is a unix domain socket however like the name suggests: It's for unix (and unix-like) systems only.  On Windows, you can use TCP sockets on localhost with the SIO_LOOPBACK_FAST_PATH ioctl for achieve much of the same effects (but notably: not the existence of a node in the file-namespace)."
C_Programming,3altx5,geocar,2,Sun Jun 21 19:26:21 2015 UTC,"You have to use UNIX domain sockets, via socketpair() (like pipe()), or in the filesystem via bind()/listen()/accept()/connect()/etc. They act very much like internet sockets and use the same API."
C_Programming,3altx5,raevnos,1 point,Sun Jun 21 19:33:16 2015 UTC,A couple of answers on StackOverflow   http://stackoverflow.com/questions/15055065/o-rdwr-on-named-pipes-with-poll http://stackoverflow.com/questions/6247300/named-pipe-creation
C_Programming,3altx5,Nirenjan,0,Sun Jun 21 16:44:34 2015 UTC,"I'm sorry but I do not understand. The answer to the first link states that it is normal pratice to use O_NONBLOCK . At the same time, it says that when the writer closes the pipe, data cannot be read anymore by readers.  So how can the writer know when it is time to close the pipe? Is there a way to block until the other process reads from the pipe?"
C_Programming,3altx5,angdev,1 point,Sun Jun 21 18:41:45 2015 UTC,You might want to look into using sockets to accomplish what you want.
C_Programming,3aj49z,TheAvengingKnee,2,Sat Jun 20 18:16:10 2015 UTC,"A bit late on this, but it seems to me that you need a shuffle algorithm, rather than the current approach you have. Create an array with the numbers you want (say 0 to 4), and randomly shuffle the elements, that is, pick a random element index from 0 to 4, swap that with the last element. Then pick a random element index from 0 to 3, swap that with the last but one element, and so on, until you have only 1 element left (index 0)."
C_Programming,3aj49z,Nirenjan,1 point,Sun Jun 21 06:30:00 2015 UTC,Normally I would but for the c class I am taking the teacher was specific that it must be done the other way.
C_Programming,3aj49z,shinmai_rookie,1 point,Sun Jun 21 14:13:36 2015 UTC,"I'm seeing a problem here, but I don't know if it's the problem: when guaranteeing that the new number isn't already in the array, you should go with j from 0 to i, not to 5. Otherwise, you will always change the new number (because it's always equals to itself)."
C_Programming,3aj49z,shinmai_rookie,1 point,Sat Jun 20 18:45:23 2015 UTC,are you talking about  if (random == a[i]) {  a[i] = rand() % 5; }   it prints out:  2  0  2  3  1
C_Programming,3aj49z,shinmai_rookie,1 point,Sat Jun 20 18:49:48 2015 UTC,"I'm talking about for (j=0; j < 5;); there, 5 should be changed to i."
C_Programming,3aj49z,Kristler,1 point,Sat Jun 20 18:51:54 2015 UTC,now I have:  for (j=0; j < i;) {  if (random == a[j]) {  a[j] = rand() % 5; }   When it runs it still is not correcting for duplicates.  sample:  1  1  1  2  3
C_Programming,3aii01,MSBugge,7,Sat Jun 20 14:44:46 2015 UTC,"Operator precedence. You're decrementing the pointer, not the character. Try (*lives)--:"
C_Programming,3aii01,acwaters,1 point,Sat Jun 20 14:54:34 2015 UTC,This. I would never have thought of precedence in this matter. This is beautiful. Thank you very much!
C_Programming,3aii01,acwaters,1 point,Sat Jun 20 15:03:32 2015 UTC,No problem!
C_Programming,3aii01,Fylwind,3,Sat Jun 20 15:20:45 2015 UTC,"parse a variable as a pointer in a function.   It should be: ""pass a pointer to a variable to a function"".  The word ""parse"" means something entirely different: to convert strings into structured data.  Also, it's often helpful to turn the warnings on when compiling (e.g. -Wall flag in gcc or clang).  Here's what clang has to say about your code:  warning: format specifies type 'int' but the argument has type 'char *' [-Wformat]     printf(""%i"", lives);             ~~   ^~~~~             %s warning: expression result unused [-Wunused-value]     *lives--;     ^~~~~~~~"
C_Programming,3aii01,Fylwind,1 point,Sat Jun 20 23:43:18 2015 UTC,"Point noted about the parse/pass definition, I didn't know that.  I am aware that I am printing the char as an int, but unaware of any better way of presenting the actual value of the char with printf.  I am not familiar with the compiler we are using. I've no former C experience, so I just used the IDE recommended for the course. It's the ZDS II IDE, which as far as I know has its own compiler. I am almost certain warnings are turned on by default, since I have received warnings before due to code, but never anything when printing a char as an int.  Except for the use of chars as character values, is there any reason to avoid using chars just for value storage?"
C_Programming,3aii01,wgunther,1 point,Sun Jun 21 17:06:47 2015 UTC,"ZDS appears to be a vendor compiler for a specific embedded platform, which unfortunately means you may not get all the fancy features that the general purpose compilers get due to their popularity.  The error is telling you that you should not print a char pointer using %i. You should be printing *lives instead!"
C_Programming,3aii01,Rhomboid,1 point,Sun Jun 21 20:01:52 2015 UTC,"Oooh, yes. I know what you mean. Inside the gameloop(). Yes, I am already doing that in the actual code. I forgot to add the dereference when writing it here on Reddit. Thanks for pointing it out, though. I thought you meant printing the value of the char inside the main function.  Yes, the IDE itself isn't that worthwile, in my vague opinion. For some reason, the ""watchlist"" of variables is broken, and the editing seems pretty much like a text editor. We are using an old version, but still."
C_Programming,3aii01,MachinShin2006,3,Mon Jun 22 12:28:26 2015 UTC,"preface this with I didn't look closely at all the code, but *lives--; is bad to do since it assumes you know which has higher precedence, * or --. As it turns out, -- has higher precedence. This means lives is decremented (i.e. pointer arithmetic) and then accessed. That's probably not what you want. You probably want (*lives)--. It's very likely that you are doing some undefined behavior because of this one thing since, if lives is just pointing to some byte and not part of an array, accessing lives-1 is undefined behavior."
C_Programming,3aii01,GBGamer117,1 point,Sat Jun 20 14:54:38 2015 UTC,"Yes, I tested it, and it worked now due to the precedence. Thank you very much!"
C_Programming,3aii01,OldWolf2,1 point,Sat Jun 20 15:05:42 2015 UTC,"You could also write it as --*lives since the dereference operator and the prefix decrement operator have the same precedence and right-to-left associativity.  Or stated differently, prefer the prefix versions of increment/decrement over the postfix versions, unless you actually need the additional special behavior of postfix.  However if you have to think about it even a little, it's probably best to use parentheses."
C_Programming,3aii01,GBGamer117,1 point,Sat Jun 20 17:57:29 2015 UTC,"Good to know. I've always wondered when the prefix vs. postfix mattered when it comes to the order of incrementing. But apparently, now it does. Though the parentheses are the most clear way of expressing it - At least to a beginner like me."
C_Programming,3aioui,one_big_mistake,1 point,Sat Jun 20 15:52:51 2015 UTC,I was trying to set iRandom1 to always be 1 just for testing purposes. Once I have everything working correctly I will change it to be random between 0 and 10.
C_Programming,3aioui,atreayou,1 point,Sat Jun 20 16:12:31 2015 UTC,I think this will fix your issue!
C_Programming,3aioui,shinmai_rookie,5,Sat Jun 20 22:26:30 2015 UTC,"Assuming everything else is correct, you can transform a number character into an actual number by subtracting '0' (subtracting the zero character, not the number 0).  guess = guess - '0';"
C_Programming,3aioui,arabjuice,3,Mon Jun 22 17:13:45 2015 UTC,or atoi();
C_Programming,3ai5p0,Kassio89,1 point,Sat Jun 20 12:13:56 2015 UTC,"You're reading strings in a wrong way: you pass &StudentName[50] to scanf; you should pass StudentName, which is a pointer to the first character (equivalently, you can pass &StudentName[0]). As you're doing it now, you put the string starting beyond the end of the variable, not in the beginning.  That's not the cause of the error you're reporting, however. For what you want to do, you should perform the sum (Sum=Sum+Grade or whatever) after doing the check to see if it is a valid number."
C_Programming,3ai5p0,shinmai_rookie,1 point,Sat Jun 20 12:26:30 2015 UTC,I would rather eliminate numbers when it is time to enter the grade if possible and use letter grades instead. How would I go about doing that?
C_Programming,3ai5p0,shinmai_rookie,1 point,Sat Jun 20 12:45:53 2015 UTC,"You could read a character and use a switch structure (you need break because otherwise the instructions in the following cases would also be run):  char c;  scanf(""%c"", &c);  switch(c)  {  case 'A': GradeValue = 4;  break;  case 'B': GradeValue = 3;  break;  case 'C': GradeValue = 2;  break;  case 'D': GradeValue = 1;  break;  case 'F': GradeValue = 0;  break;  default: // What you do when another character is introduced"
C_Programming,3ai5p0,shinmai_rookie,1 point,Sat Jun 20 12:57:52 2015 UTC,But if I need the number to be a float how can it be a char at the same time?
C_Programming,3ai5p0,shinmai_rookie,2,Sat Jun 20 13:38:22 2015 UTC,"You use two different variables: char c to read the char, and float Average to get the average value."
C_Programming,3ai5p0,pwil10,1 point,Sat Jun 20 13:56:49 2015 UTC,"So what is the point of writing StudentName[50] as opposed to StudentName? If i did the sum=sum+grade that wouldnt get the average. The problem I am having is when a number greater than 4 is entered, it's still being calculated with the average. When a number larger than 4 is entered I need that number to NOT be included in my equation."
C_Programming,3ai5p0,THRAKERZ0D,1 point,Sat Jun 20 12:43:47 2015 UTC,"It's true that that's not what causes the problem with the average, but if you read the student's name like that it will be read incorrectly, because you're telling scanf to start storing the characters at the address of the byte just after the last character in StudentName, instead of the address of the first character of StudentName."
C_Programming,3ai5p0,thrakkerzog,1 point,Sat Jun 20 13:01:19 2015 UTC,"I heard that it is a good practice to leave one space before the percent  sign ""%"" inside the scanf crap."
C_Programming,3ai5p0,THRAKERZ0D,0,Tue Jun 23 03:30:07 2015 UTC,I know this has nothing to do with the question but what is with the ridiculous amount of white space? And why do you take argc and argv if you don't even use them?
C_Programming,3ai5p0,anonography,1 point,Sat Jun 20 13:16:08 2015 UTC,"Well, that is the signature for main."
C_Programming,3afve5,OldWolf2,5,Fri Jun 19 20:19:32 2015 UTC,"You seem to not understand what null termination is.  The null terminator is used to mark where the end of a string is that is stored in memory.    There are no null terminators in an input stream.  Instead, when inputting a string, the characters are stored in memory, and then after input has finished, a null terminator is stored in memory so that future accesses to that memory can see where the end is.  Your real question appears to be:   How do I prompt the user for text and be able to detect if nothing was entered?   To answer that: use the fgets function. This inputs a line. The definition of a line is: some number of characters (possibly zero) followed by an end-of-line character (also known as new-line).  Note that scanf with %s is not suitable, because that only reads a word  (a non-zero amount of characters followed by whitespace).  The fgets function (unlike most input functions) stores the newline character at the end of the stored string. This is so you can distinguish between the end of line being read, and the line being too long for the buffer.  Here is an example with exception handling:  char line[100]; if ( !fgets(line, sizeof line, stdin) )     printf(""The input stream was closed\n""); else if ( line[0] == '\n' )     printf(""They entered a blank line\n""); else if ( line[strlen(line)-1] == '\n' )     printf(""They entered a line of length %zu\n"", strlen(line)-1); else     printf(""They entered more than 99 characters - remainder of line remains in the input stream to be read next time"");"
C_Programming,3afve5,angdev,5,Sat Jun 20 04:25:10 2015 UTC,"After they press Enter, print out the full string to your console, it may shed some light on what is happening! :)  printf(""This is the string >>>%s<<<\n\n"", my_cool_string);   You can also call strlen() and see what number is returned on what you think is an empty string!  If you're still confused as to what is happening, you can also print out each character as a decimal number (since some characters do not have graphical representations but are also not NULL):  printf(""Character 1: %u\n"", text[0]); printf(""Character 2: %u\n"", text[1]); printf(""Character 3: %u\n"", text[2]); printf(""Character 4: %u\n"", text[3]);   Or you can print out the hex representation of the string too! So many options! :P  printf(""The string is: 0x""); uint8_t p* = (uint8_t*)text; while (*p) {     printf(""%02X"", *p);     p++; } printf(""\n"");"
C_Programming,3afve5,OldWolf2,1 point,Fri Jun 19 20:54:18 2015 UTC,"I see, Im not familiar, with uint8_t      bool lock = true; char text[100]; char fulltext[1000];    do{       printf(""Please enter text\n"");       scanf("" %100[0-9a-zA-Z %&@#!+:_-$^*=><\""]"",&text);         strcat(fulltext, text);         if(strlen(text) == 0 ){ lock = false; }    }while(lock == true);     printf("" Here is what you entered \n "");    printf("" %s "",fulltext);   Is there a reason my if statement doesn't fire?"
C_Programming,3afve5,angdev,2,Fri Jun 19 21:36:29 2015 UTC,"You are using scanf incorrectly:   scanf("" %100[0-9a-zA-Z %&@#!+:_-$*=><\""]"",&text);   Firstly, the leading space means skip any amount of whitespace. So if the person presses Enter then scanf keeps reading. It doesn't stop reading until at least one non-whitespace character is entered. You should have noticed this while testing your code.  Next using - inside %[ is implementation-defined.  Standard C only requires that characters and ^ for inversion be supported. This isn't a regular expression.  The argument should be text, not &text: it needs to have type char *.   Finally, you never check the return value of scanf.  The %[ specifier will fail if it does not match something. When scanf fails, nothing is stored in the output buffer; so you will go on to call strcat and strlen with whatever was left over in the buffer from the previous time.  You should always check the return value of scanf and take action if it was not what you expected.   In this case I would recommend not using the complicated %[ expression. Instead, read a line with fgets and then check to see if the line contains any unwanted characters."
C_Programming,3afve5,jesterret,1 point,Sat Jun 20 04:33:38 2015 UTC,"Remember to always initialize variables to 0 when you create them, it'll help you from making some common mistakes. For example char fulltext[1000]; is not initialized, so when you later call strcat(fulltext, text); we will get undefined behavior. After scanf("" %100[0-9a-zA-Z %&@#!+:_-$^*=><\""]"",&text); try placing a printf(""length=%u\n"", strlen(text)); and this might give you a clue as to what is happening with your code."
C_Programming,3afve5,FUZxxl,1 point,Fri Jun 19 21:50:55 2015 UTC,"So, upon doing this, spaces, or complete blank entries return nothing, entering any sort of text gives me the length of what was entered."
C_Programming,3afve5,OldWolf2,1 point,Fri Jun 19 21:59:01 2015 UTC,"Actually, I think the issue is with my scanf statement."
C_Programming,3afve5,FUZxxl,1 point,Fri Jun 19 22:05:52 2015 UTC,"You definitelly don't need & before test variable but I don't think that's the problem there. Also, by typing spaces ony you still get 0 lenght? Since you do have them in input specifier"
C_Programming,3afve5,OldWolf2,1 point,Sat Jun 20 02:58:20 2015 UTC,Why do you cast the string to uint8_t? Use unsigned char as the size of a char might be larger than 8 bit.
C_Programming,3afve5,FUZxxl,1 point,Fri Jun 19 22:46:44 2015 UTC,uint8_t must be a typedef for unsigned char if it exists. (And if it doesn't exist then I think we're rather out of OP's depth)
C_Programming,3afve5,angdev,0,Sat Jun 20 04:18:11 2015 UTC,"That's not correct. For instance, on a machine with a 12 bit char, uint8_t is a special type with size 1, 8 value bits and 4 padding bits and a total range of values that is less than that of an unsigned char."
C_Programming,3afve5,sprite3,3,Sat Jun 20 08:06:49 2015 UTC,"For instance, on a machine with a 12 bit char, uint8_t is a special type with size 1, 8 value bits and 4 padding bits    C11 7.20.1.1/2: The typedef name uintN_t designates an unsigned integer type with width N and no padding bits [...]"
C_Programming,3aeqsn,Asolmanx,7,Fri Jun 19 15:04:50 2015 UTC,"The buffer ""dies"" at the end of the outer loop.  But that doesn't mean that its contents are zeroed out. Similarly, when the buffer array in declared its contents are not initialized to zero.  Basically, the buffer array is allocated at the same position in the stack each time around the outer loop.  It just so happens this way. The C standard doesn't guarantee that it will get allocated at the same place.   The first time around it gets filled with your string. The subsequent times around the loop, you're basically getting the contents from the first loop."
C_Programming,3aeqsn,mythicalmammoth,1 point,Fri Jun 19 15:40:16 2015 UTC,"Ohh, ok, now I understand.  So what would be the best practice to avoid this? Initializing the buffer at the start of the loop like     char buffer[40] = """"; won't work. So I'm guessing the best way to handle this is with malloc and free? Also, if so, should I use calloc instead of malloc?  EDIT: It wasn't working because of me forgetting the \n at the end of the printf. It actually does work"
C_Programming,3aeqsn,bames53,2,Fri Jun 19 16:48:12 2015 UTC,"Ohh, ok, now I understand. So what would be the best practice to avoid this?   The second time around the outer loop read() doesn't read anything. One way to address the issue is to check whether or not read() actually reads anything, and you should also avoid printing any part of the array that read() doesn't use. Something like:  while(1){     char buffer[40];     char* ptrbuffer = buffer;     int n = 0;      do{         n = read(clientSocketFD, ptrbuffer, 1);     } while( n>0 && *(ptrbuffer++) != '\0');      if (ptrbuffer > buffer) {         *(++ptrbuffer) = '\0';         printf(""%s\n"", buffer);     } }   Another way is to initialize the buffer each time:  while(1){     char buffer[40] = {'\0'};"
C_Programming,3aeqsn,sprite3,1 point,Fri Jun 19 18:30:10 2015 UTC,Since we're incrementing ptrbuffer in the check of the do-while loop wouldn't that mean that (ptrbuffer > buffer) is always true since we always increment it at least once?
C_Programming,3aeqsn,maep,3,Sat Jun 20 06:09:48 2015 UTC,"nope, && cheks the left condition first, n>0 fails, ptrbuffer is not incremented"
C_Programming,3aeqsn,maep,1 point,Sat Jun 20 10:26:20 2015 UTC,"C99+ allows you to be lazy and initizlize things like this: char buffer[40] = {};. It also works for structs, which is nice because it mutes compiler warnings about wrong nesting."
C_Programming,3aeqsn,bames53,1 point,Sat Jun 20 06:53:59 2015 UTC,Does that inizialization set all of the array's values to 0?
C_Programming,3aeqsn,maep,1 point,Sat Jun 20 10:27:17 2015 UTC,yes
C_Programming,3aeqsn,FUZxxl,1 point,Sat Jun 20 11:43:36 2015 UTC,"I don't believe even C11 has that feature yet. It's standard C++, and a GNU extension to C."
C_Programming,3aeqsn,mythicalmammoth,1 point,Sat Jun 20 17:23:00 2015 UTC,"Oh, then I'll have to read into it. I got it from 21st century C where it wasn't declared as an extension."
C_Programming,3aeqsn,gandalf013,1 point,Sat Jun 20 18:23:56 2015 UTC,The standard way to initialize an object to all zero is still foo = { 0 }; but the stupid gcc authors think they need to warn me in this case.
C_Programming,3aeqsn,sprite3,2,Sat Jun 27 09:56:46 2015 UTC,"Initializing the buffer to the empty string will set the first element to 0 but leave the subsequent elements with their existing state.  If you read in a new character into the first element, the zero will be overwritten and now your string may not be null terminated.  You also have the possibility of overflowing your array because you're not bounds checking.  Will your buffer be null terminated once it's read in the entire string?  It depends on whether the sender sent the null terminator. From the discussions so far, it sounds like you are.  But relying on the sender to null terminate your string is bad practice. This is the way security holes are born.   Edit: everything  Edit again:  Ohh, I'm wrong. Initializing the array to the empty string will set all elements to 0."
C_Programming,3aeqsn,GBGamer117,1 point,Fri Jun 19 19:35:14 2015 UTC,"Ohh, I'm wrong. Initializing the array to the empty string will set all elements to 0.   In particular, if an array doesn't have all of its elements in the initialization list, the rest of the elements are initialized to 0.  int a[5] = {1};   will set a[1] through a[4] to 0."
C_Programming,3aeqsn,McMalloc,2,Fri Jun 19 22:53:37 2015 UTC,"I'd just set the first element to the null terminator '\0'. Also, as mentioned previously you should make sure you don't read past the end of your array.  Edit: In case I wasn't clear: buffer[0] = '\0';  Edit2: I'd avoid dynamic memory (malloc, calloc, free, etc) unless you were hoping to read in an unlimited number of characters. Also, char buffer[40] = """"; will actually work by doing the same thing as my first edit.  Edit3: Also remember to null terminate after the read loop"
C_Programming,3aeqsn,f5f5f5f5f5f5f5f5f5f5,1 point,Sat Jun 20 06:15:13 2015 UTC,"I'm interested in the malloc part. Let's say I were hoping to read an unknown and probably big number of characters. What would the course of action be then? Using a malloc at the beginning to initialize the array with an arbitrary number, then checking the array length in the do while and using realloc if I get close to max?"
C_Programming,3aeqsn,f5f5f5f5f5f5f5f5f5f5,2,Sat Jun 20 10:37:02 2015 UTC,"That's how I would do it, personally. That's basically doing what a higher-level language's String type does, anyway.  size_t buffer_capacity = 40; char *buffer = malloc(buffer_capacity); while(1) {     ssize_t n = 0; /* read() returns an ssize_t, not an int */     size_t i = 0;      for(;;++i) {         n = read(clientSocketFD, buffer + i, 1);         if (n == 0) break;         if (buffer[i] == '\0') break;         if (i == buffer_capacity) {             size_t new_capacity = buffer_capacity * 3 / 2;             char *tmp = realloc(buffer, new_capacity);             if (tmp == NULL) {                 perror(NULL);                 exit(EXIT_FAILURE);             } else {                  buffer = tmp;                  buffer_capacity = new_capacity;             }         }     }      buffer[i] = '\0';     printf(""%s\n"", buffer); }"
C_Programming,3abz20,odaymichaelk,3,Thu Jun 18 21:28:25 2015 UTC,"Probably best to code up something.  Try this :  https://en.m.wikipedia.org/wiki/Conway's_Soldiers  Write a program that takes a target row and column as command line arguments, then works out a move set for reaching it.  When it has found a correct series of moves, print them out."
C_Programming,3abz20,benjiathome,3,Thu Jun 18 21:57:47 2015 UTC,I'm not sure if this will help you but may be you should have a look at this: http://coderbyte.com/CodingArea/Challenges/
C_Programming,3abz20,ELECTROPHIL,3,Fri Jun 19 07:45:45 2015 UTC,"cs50.harvard.edu    Start with PSET 1    Go up to PSET 6 (last C assignment)  PSETS 1,2,3 are really beginner level, but they also introduce valgrind and gdb"
C_Programming,3abz20,gordonv,1 point,Fri Jun 19 15:18:51 2015 UTC,Awesome Resource!
C_Programming,3abz20,atreayou,2,Mon Jun 22 17:10:54 2015 UTC,Do some pointer arithmetic and the figure out the strangeness that can happen when you start tossing in parenthesis.
C_Programming,3abz20,Lobreeze,2,Thu Jun 18 21:32:59 2015 UTC,Then make some function pointers!
C_Programming,3abz20,dumsubfilter,1 point,Fri Jun 19 04:54:48 2015 UTC,Then do some n-star pointers. Where n is any value greater than 1.
C_Programming,3abz20,chasesan,2,Fri Jun 19 14:20:43 2015 UTC,What does the position do?
C_Programming,3abz20,Vungtauno,1 point,Thu Jun 18 22:13:32 2015 UTC,"I believe it creates software that interfaces with third party hardware and bridges it with GUIs. I wish I knew more about it, but I work in a different, non-software, group within the same company. We are in the semiconductor equipment manufacturing business."
C_Programming,3abz20,rafleury,1 point,Thu Jun 18 22:28:29 2015 UTC,"Does it run on the hardware, or on a pc OS?"
C_Programming,3abz20,rafleury,1 point,Fri Jun 19 17:14:33 2015 UTC,"I believe both. Some are embedded, some are on a PC."
C_Programming,3abz20,flamesflight,1 point,Sat Jun 20 15:25:24 2015 UTC,"Well if it's embedded you have a good amount of studying to do, its practically a new world of programming.  I'm hesitant to just list a bunch of things to study here, but definitly look into interrupts, if you know what micro they are using d/l the datasheet and start reading."
C_Programming,3abz20,livrem,1 point,Sat Jun 20 19:15:27 2015 UTC,Zed Shaw has a webbook that's free called Learn C the Hard Way. It's worth a look but it may be too basic for your needs.
C_Programming,3abz20,spicymaki,1 point,Fri Jun 19 22:46:21 2015 UTC,I think the C Pocket Reference was a great way to get back into C.
C_Programming,3a9d14,be_polite,12,Thu Jun 18 07:01:36 2015 UTC,"Rather than allocating multiple blocks of memory, it can often be more advantageous to allocate a single contiguous block.  Instead of accessing matrix[i][j], you would access matrix[i * row_size + j]. This has two main benefits:   Memory management is much simpler Fragmented memory = more cache misses, read more here   An API that terminates your app for invalid input is a bit harsh as well, and it outputs the error to stdout rather than stderr. I think it is more typical of an API such as this to return an error code rather than terminate the process.  It may be more useful for functions to read from FILE * streams so that the programmer can choose whether to read the matrix from their own file or from stdin (remember that stdin is a FILE * too). The same goes for output. Perhaps there could be functions that follow the standard C formatted I/O functions, e.g. matrix_print which prints to stdout and matrix_fprint which accepts a FILE *, like this:  void matrix_print(const Matrix *matrix) {     matrix_fprint(stdout, matrix); }  void matrix_fprint(FILE *file, const Matrix *matrix) {     ... omitted ...         fprintf(file, ""\t\t%9.2f"", matrix->matrix_entry[i][j]);     ... omitted ... }   Also, I think it should really be up to the caller of the function to display a message to the user (in the case of matrix_fill). In some situations, a message may not be necessary, or it may need to be in another language, etc.  malloc.h is not a standard C header. To use malloc, it is declared in stdlib.h. There are also no include guards in the  matrix.h header. This header also includes standard headers but does not use any definitions from those headers, so they should be included in matrix.c rather than matrix.h (although, with a matrix_fprint function, stdio.h will need to be included).  Any function that does not modify (or should not modify) a Matrix object should accept a const Matrix *. Some functions are already doing this, but not matrix_print, matrix_copy (first argument), and matrix_pow, etc."
C_Programming,3a9d14,dreamlax,1 point,Thu Jun 18 13:47:53 2015 UTC,Thanks for your comment. Its really helpful :)
C_Programming,3a9d14,MartenBE,1 point,Thu Jun 18 16:11:57 2015 UTC,I thought that multidimensional arrays were always continguous in memory in C++ and matrix[i][j] is the same as matrix[i * row_size + j]. Doesn't using matrix[i][j] also allows the compiler to perform optimalizations?
C_Programming,3a9d14,dreamlax,3,Fri Jun 19 07:52:01 2015 UTC,"Multi-dimensional arrays are, but if you look at the actual code, you'll see that each row of the matrix is allocated separately, so there is no guarantee of contiguity."
C_Programming,3a9d14,angdev,-2,Fri Jun 19 08:31:30 2015 UTC,"Rather than allocating multiple blocks of memory, it can often be more advantageous to allocate a single contiguous block. Instead of accessing matrix[i][j], you would access matrix[i * row_size + j]. This has two main benefits...   You never need to use matrix[i * row_size + j] for any reason, nor do pointer math inside []. Always create the proper pointer and use the pointer as nature intended:  float (*m)[row_size] = matrix; m[2][4] = 12.34f;"
C_Programming,3a9d14,dreamlax,1 point,Thu Jun 18 21:55:02 2015 UTC,float * and float (*)[row_size] are incompatible pointer types.
C_Programming,3a9d14,angdev,-1,Thu Jun 18 23:48:28 2015 UTC,There is no such thing as an incompatible pointer type. Pointers are just memory addresses.
C_Programming,3a9d14,dreamlax,1 point,Fri Jun 19 02:29:31 2015 UTC,"§6.7.6.1/2   For two pointer types to be compatible, both shall be identically qualified and both shall be pointers to compatible types.   float and float[row_size] are not compatible types, so float * and float (*)[row_size] are not compatible either.  You can't always convert a pointer from one type to another type willy-nilly. For example, casting a char * to a float * and trying to access the float pointed to by that pointer may not work if the pointer is not properly aligned."
C_Programming,3a9d14,BigPeteB,1 point,Fri Jun 19 02:53:19 2015 UTC,"http://www.reddit.com/r/programming/comments/2nqrsr/cc_tip_how_to_loop_through_multidimensional/  tl;dr: If you're optimizing for a hot loop, you'll get different performance whether you use a 2-dimensional array or a 1-dimensional array, even though they conceptually are the same, and you can further optimize by doing your own invariant hoisting."
C_Programming,3a9d14,BigPeteB,1 point,Fri Jun 19 00:15:01 2015 UTC,"You never need to use matrix[i * row_size + j] for any reason, nor do pointer math inside []. Always create the proper pointer and use the pointer as nature intended   You can't dynamically allocate a linear pointerless multidimensional array in C. (Unless you know something I don't.)"
C_Programming,3a9d14,angdev,-1,Fri Jun 19 00:20:17 2015 UTC,I do not understand what you are saying. But you can dynamically allocate multidimensional arrays in C with a single call to *alloc.
C_Programming,3a9d14,BigPeteB,2,Fri Jun 19 02:31:38 2015 UTC,"So kind of you to explain how. I had to figure it out for myself.  #include <stdlib.h> #include <stdio.h>  int main(void) {   srand(0);   size_t row_size = rand() % 100;   size_t col_size = rand() % 100;   int (*matrix)[row_size];   printf(""Row size is %zu\n"", row_size);   printf(""Col size is %zu\n"", col_size);   matrix = malloc(row_size * col_size * sizeof(int));   printf(""Matrix is at %p\n"", matrix);   printf(""Matrix[1] is at %p\n"", matrix[1]);   printf(""Matrix[1][1] is %d\n"", matrix[1][1]);   return 0; }   I'm shocked to see that that compiles. Shocked! I was sure that C doesn't allow dynamically-sized arrays like that, and certainly not multidimensional ones.  Hang on, compile with -ansi -pedantic:  warning: ISO C90 forbids variable length array 'matrix' [-Wvla]   Right, it's actually using a GCC extension (even when I compile with -std=c89). So no, C doesn't let you do this kind of thing... not if you want to be portable."
C_Programming,3a9d14,Tardigra,2,Fri Jun 19 03:56:02 2015 UTC,But when compiling with -pedantic -std=c99 it works. Variable length arrays (VLA) are part of the language since the C99 standard.
C_Programming,3a9d14,BigPeteB,2,Fri Jun 19 10:17:24 2015 UTC,"Sadly, C has not seen the same adoption of newer standards that C++ and other languages have. Sure, if you use GCC like many people do it works fine. But a lot of compilers for embedded and other less common platforms still don't support C99 fully, or at all.  That's partly what makes C so popular and enduring. If you're creating a new processor, it's fairly simple to write a compiler that compiles C89/90. It's a bit harder to support C99, and a lot harder to support C++.  But we need to be fair here and recognize that in the lowest common denominator, C does not have features like this. If you intend to write truly portable, reusable code, such as this matrix library, you can't rely on newer features like VLAs."
C_Programming,3a9d14,FUZxxl,8,Fri Jun 19 13:09:49 2015 UTC,Hint: Don't use identifiers that begin with an underscore. Such identifiers are reserved for internal use by the C standard library.
C_Programming,3a9d14,FUZxxl,1 point,Thu Jun 18 10:19:34 2015 UTC,Thanks for the insight :)
C_Programming,3a9d14,BigPeteB,2,Thu Jun 18 10:29:42 2015 UTC,You might also want to have a look into the LAPACK routines for how to do this matrix stuff efficiently.
C_Programming,3a9d14,BigPeteB,1 point,Thu Jun 18 11:02:34 2015 UTC,"This only works with floats. That's not described in the documentation anywhere, nor indicated in the naming. What if someone wants doubles, or some type of int? At the least it would be nice to support doubles, and have functions for working with each, with the name of the typedef/function indicating which it is.  I don't see much point to the intro.h file. Why not just put that information in the matrix.h file?  As mentioned, your header file needs to be protected against multiple inclusion with #ifndef __MATRIX_H__ / #define __MATRIX_H__ / #endif. It should be protected against use in C++ code with #ifdef __cplusplus / extern ""C"" { / #endif and #ifdef __cplusplus / } / #endif. It shouldn't have any #includes except those that are required to use the header correctly (which appears to be none of them).  There's nothing wrong with separating the definition of the struct and the typedef of the struct, but I see no advantage in it if you're never going to use the struct without the typedef.  Your function names are inconsistent. Half of them start with matrix_, half of them don't. This is the only form of namespacing that C has: manually naming things consistently. The inconsistent names make it harder to integrate into other code; you have a higher risk of having the same name as someone else's unrelated function. At least if it's consistently matrix_, I could do a find/replace to rename yours.  Instead of calling function parameters matrix1 and matrix2, call them to/from or dest/src, especially in matrix_copy.  I don't get why it's matrix_callalloc instead of matrix_calloc. Or better yet, matrix_alloc_identity or matrix_ialloc.  Your row and column sizes are always ints. Since a matrix with negative sizes is nonsensical (at least as far as I know) you should be using an unsigned type. size_t would be best for correctness, since that's the appropriate type for indexing into arrays without doing manual pointer math. Failing that, use unsigned int (or maybe be explicit and use uint32_t).  matrix_multiply allocates a new matrix. What if I already have an allocated matrix I want to put the result into, to avoid deallocating and allocating a new one? It would be nice to have a 3-operand version that takes a parameter for the output matrix and doesn't allocate it.  As pointed out, terminating the program upon error is inappropriate for a library. How do you know what's an appropriate way to handle errors? If I'm writing high-reliability software such as an emergency telephone (which is what my company does, among other things), I don't want the system to halt or reboot just because of a mistake. Much better is to return a success-or-failure code and let the user figure out what to do.  matrix_pow refers to multiplying a matrix by itself ""n"" times, but there's no parameter n. The parameter is index, which is badly named; call it exp or exponent instead. And as before, this should be an unsigned parameter.  Again, the automatic allocation of result matrixes is frustrating. What if I wanted to do matrix_pow and not keep the original matrix? What if I do matrix_pow with an exponent of 1? I shouldn't have to allocate a new matrix if I don't want to, nor copy the results if the source and destination are the same.  Wait, matrix_add and matrix_subtract do take out-parameters for the destination? And matrix_invert operates in-place without giving me a choice whether or not to invert the matrix? The lack of flexibility and the inconsistency is frustrating.  Ah, I just realized, are row_divide and row_operation supposed to be for internal use only, rather than public APIs? In that case, their names are fine, but remove them from the header file, and declare them static.  In error_zeros you return from the middle of your loop. I'm pretty sure you meant to break instead. (Assuming what you're checking for is ""make sure that for each row, there aren't more than N zeroes before the first non-zero value"". If you meant ""make sure that for each row, there aren't more than N zeroes in the entire row"", then the whole else needs to be removed, because you must check the entire row.)  In several places you break a line with \ (lines 40, 321, 339, 394). This is unnecessary since it's not in a macro. C doesn't care how much or what kind of whitespace you use; just keep going on the next line without doing anything special.  I'd prefer that the public include file be in a separate directory. This makes it easier to integrate into other projects where I might be distributing a compiled library plus header. It's especially needed for large projects where you want to distinguish between public and private headers.  I love that you documented all of the functions, and that you did it in the header file (because if I had a compiled library plus header, I obviously wouldn't have the source file and would miss any documentation that's in there). But the descriptions could be better. Imagine that I have only your header file to go off of. Now read the description for matrix_callalloc.  /**  * Creates an identity matrix that is all the diagonal entries are   * initialised to 1 and all other entries to zero).  *    * @param matrix_size    The number of rows and columns in the  *                                        identity matrix.  * @return                        A pointer to the new identity matrix just   *                                        created  */   What does ""creates"" mean? In fact it allocates it, but that's not explicitly stated. I own the matrix and must free it later using matrix_free, but this also isn't stated. There are some grammar problems, although otherwise the description is okay, but in general the descriptions everywhere could be more thorough. Assume I know almost nothing about matrix stuff (just like you explained what an identity matrix is), and assume I don't know anything about the internals of your code.  The utility functions to print a matrix seem useful, but too specialized. You specify a format of ""%9.2f"", but what if I were using values that are always between 0-1? Limiting it to 2 decimal places isn't a helpful limitation."
C_Programming,3a9d14,BigPeteB,1 point,Fri Jun 19 18:04:53 2015 UTC,Wow thanks for such insight. I worked on this project about a 2 years ago in my freshman year in college while I was studying Linear Algebra. My English was quite rusty then. I'll update the documentation soon :)
C_Programming,3a9d14,autowikibot,1 point,Fri Jun 19 19:48:49 2015 UTC,"Oh, and the biggest mistake, which I didn't look for the first time: you don't check for NULL when allocating anything! If malloc or matrix_alloc ever return NULL, you immediately dereference it, which will crash the process/system.  This is very important. If you're making a reusable library, you can't assume what systems I might want to run this on, or what matrix sizes I want. It's entirely plausible that I have a 1000000x1 matrix and a 1x1000000 matrix (which take up 8MB total), but if I try to multiply them I end up with a 1000000x1000000 matrix that requires 4 TERABYTES. Clearly, that allocation is going to fail, and your library needs to be prepared for that. Crashing is not an acceptable response.  (For that matter, you should check for overflow when multiplying the row and column sizes together, before you even bother calling malloc. 10000002 is 1 trillion, which overflows on a 32-bit machine, so there's no point even calling malloc. But if you don't check for overflow, you'll just get a result of 3567587328, which is a valid 32-bit number, and on some machine might actually allocate successfully even though it's too small to hold the matrix.)"
C_Programming,3a9d14,angdev,1 point,Fri Jun 19 20:26:50 2015 UTC,"Ah, one more thing... matrix_pow doesn't handle an exponent of 0 correctly. According to https://en.wikipedia.org/wiki/Matrix_multiplication#Powers_of_matrices the 0th power of a matrix is the identity matrix, but this isn't what matrix_pow will return."
C_Programming,3ac6st,mttd,1 point,Thu Jun 18 22:28:21 2015 UTC,"From the article, probly not, right?  But still, I'd like to see some BCPL code and take an objective look for similarity."
C_Programming,3aachu,xenonx,2,Thu Jun 18 14:13:01 2015 UTC,http://www.scs.ryerson.ca/~ikokkari/CforJava.pdf
C_Programming,3aachu,tmtwd,1 point,Thu Jun 18 17:36:37 2015 UTC,"wow, that's really interesting to know about such things. I'm java developer myself. I was checking http://www.cprogramming.com/tutorial/c-tutorial.html  it's really basic stuff. Install Code blocks - it's free.  Though, I'd like to learn C + assembly. But it appears that assembly is of no use nowadays with modern sophisticated compilers."
C_Programming,3aachu,gas3872,1 point,Thu Jun 18 20:46:37 2015 UTC,What kind of projects is it possible to do in assembly? Could you suggest any ideas?
C_Programming,3aachu,gas3872,1 point,Fri Jun 19 11:36:32 2015 UTC,"I mean I like it and even wanted to make some kind of 'hello world' project on it. But I researched it, and all suggestions are to pass assembly as using it would be meaningless like in most of the cases."
C_Programming,3aachu,gas3872,0,Fri Jun 19 12:43:11 2015 UTC,There was a thread a few days ago about this exact topic. You might want to try and use the search function.
C_Programming,3a5vye,phrackattack,7,Wed Jun 17 13:57:21 2015 UTC,"Do you know on which line your code hangs?  Furthermore, it seems like you never #include the header pthread.h. Why?  Note about your code: Don't use the suffix _t for your own types, it's reserved by POSIX for types defined by the standard libraries."
C_Programming,3a5vye,FUZxxl,2,Wed Jun 17 14:20:21 2015 UTC,"I'm not the OP, but thanks for that reminder. I keep forgetting that."
C_Programming,3a5vye,pfp-disciple,1 point,Wed Jun 17 16:03:44 2015 UTC,See here for the full list of all reserved names.
C_Programming,3a5vye,FUZxxl,1 point,Wed Jun 17 16:06:07 2015 UTC,"After pushing some changes, I'm now segfaulting because in get_mime_type on line 144:   for (int i=0; mime_types[i][0] != NULL; i++) {   It doesn't appear to have anything in the variable mime_types even though it was loaded with data successfully in load_mime_types."
C_Programming,3a5vye,FUZxxl,3,Wed Jun 17 16:58:46 2015 UTC,Your function get_mime_type can't work the way you wrote it: You tokenize the line array and overwrite it right afterwards!
C_Programming,3a5vye,Aransentin,1 point,Wed Jun 17 17:03:17 2015 UTC,"You mean load_mime_types I think. And that function works. If you print out the contents of mime_types right after you can see everything was loaded correctly.  The problem is that for some reason, mime_types isn't accessible from a thread, which I can't figure out..."
C_Programming,3a5vye,pfp-disciple,5,Wed Jun 17 17:12:22 2015 UTC,"You seem to misunderstand how TCP sockets work. Reading from a socket can totally just return a single byte, even if the client sent more than that - you need to continue reading from the socket in a loop until you have all the data you expect (for a HTTP request, that would be a double \r\n)."
C_Programming,3a5vye,zomgreddit0r,2,Wed Jun 17 14:21:58 2015 UTC,"It took me a long time to learn that TCP sockets are streams, and the reader can be faster (or slower!) than the writer, so it can read too much or too little data. When dealing with streams, you pretty much have to implement some kind of parser, even if it's ""split on \r\n""."
C_Programming,3a5vye,zomgreddit0r,2,Wed Jun 17 16:05:19 2015 UTC,"You are correct, I believe I have fixed that (see branch develop). I'm still getting a segfault but I think thats from reading the mime types."
C_Programming,3a5vye,zomgreddit0r,2,Wed Jun 17 16:24:18 2015 UTC,You should always compile with warnings enabled. Add -Wall -Wextra to your CFLAGS in the Makefile. Doing this should cause the compiler to point out the fact that mime_types declaration is wrong.
C_Programming,3a4l0y,HyperCoffeePanda,13,Wed Jun 17 04:32:06 2015 UTC,"As a side track, all the C you really need to get started in the field is taught in The Art of Exploitation.  If you haven't heard of it, it's a security/hacking book that is brilliant.   C is a really small language and quite easy to learn. So you don't really need a lot more than an introduction and some Googling skills.  Edit: I misspelled the title."
C_Programming,3a4l0y,flaccidicus,6,Wed Jun 17 06:35:27 2015 UTC,"The art of exploitation is an absolutely fantastic book. The C introduction it gives, blended with the low level dissemination in order to understand the exploitation portion makes it such a great learning tool. I read the book thoroughly a while back, but it wasn't until two years later that I actually had to write some C, and I realized I could pick it up as if I knew it fluently already. It was pretty whacky."
C_Programming,3a4l0y,Kristler,1 point,Wed Jun 17 08:17:11 2015 UTC,"Take the C introduction of that book with a grain of salt. It offers a basic overview of the most essential aspects of C but doesn't get into details about the ""gotchas"" of the language such as undefined or implementation-defined behavior.  K&R is probably a better recommendation."
C_Programming,3a4l0y,Emperiz,2,Sun Jun 21 08:16:33 2015 UTC,"I've several years of experience in C now, but thanks."
C_Programming,3a4l0y,Kristler,2,Sun Jun 21 08:33:26 2015 UTC,It was directed more towards the OP.
C_Programming,3a4l0y,Emperiz,3,Sun Jun 21 08:50:07 2015 UTC,http://www.amazon.com/Hacking-Art-Exploitation-Jon-Erickson/dp/1593271441/ref=sr_1_3?ie=UTF8&qid=1434541992&sr=8-3
C_Programming,3a4l0y,-AcodeX,2,Wed Jun 17 11:54:46 2015 UTC,"Hacking: The Art of Exploitation, 2nd Edition           Current $28.97 Amazon (New)   High $34.54 Amazon (New)   Low $28.97 Amazon (New)    $29.21 (30 Day Average)    Price History Chart and Sales Rank | FAQ"
C_Programming,3a4l0y,PriceZombie,2,Wed Jun 17 11:54:59 2015 UTC,Thanks for this intro - love the book!
C_Programming,3a4l0y,zenkibudo,17,Sat Jun 20 20:47:41 2015 UTC,"I think it's an awful book.   I like the idea behind it that you should explore certain things yourself, rather than have a book tell you everything you need to know. The idea is that if the book tells you exactly what to do, you won't remember it, but if you do it yourself, you are more likely to.  However, the problem is that the book is written by someone who doesn't understand how to teach people. The general theory behind good teaching is to teach you the basics and core fundamentals behind a concept, and then let you explore the possibilities. For example when learning an instrument, you learn musical theory so that you understand what is going on and with the skills you have from musical theory you can quite easily advance in your studies for ANY instrument.  This book however, just shows you what you should be able to understand and expects you to find the answer, rather than giving you the tools to find the answer. It's an extremely tedious process, because essentially you don't really need the book at all.   It's a shame, because the first few chapters are exactly what they should be and rely on teaching you the actual basics of programming. But as soon as it get's a little advanced.... well it's just shit. I really wanted to like this book, and have tried reading it a couple of times. Unfortunately, I wouldn't recommend it though unless you already have quite a lot of experience, and even then... I still probably wouldn't recommend it."
C_Programming,3a4l0y,Pungyeon,1 point,Wed Jun 17 10:38:32 2015 UTC,Do you think that The C Book (publications.gbdirect.co.uk/c_book/) would be good enough for picking up C?
C_Programming,3a4l0y,Pungyeon,2,Wed Jun 17 14:05:01 2015 UTC,"To be honest, I don't really have any authority to say. I just thought I'd give my opinion on LCTHW. To be fair, I've heard this book is fairly decent, and if it's just to pick up C I don't see any reason not to.  As shadowmint has recommended below K & R C (The Programming Language C) is THE C book. It's written by the authors of the language, so you can't really go wrong with it :)"
C_Programming,3a4l0y,zenkibudo,1 point,Wed Jun 17 14:30:23 2015 UTC,"I got the book (see my EDIT) based on /u/flaccidicus ' remarkably strong recommendation.   I really like it.    But now I understand your sentiment.    1st off, this is NOT a book I would recommend for learning C.  The book has plenty of C, and C-look-alike-psuedo code, but this is all merely applied to his overall topic of the book, and not presented for the purpose of learning C, no way.    2nd - he moves quickly into computer architecture and then assembly language and whew!  Although a rich source of information on the topic - this is not gonna help you learn C too much.     I could say more -- but simply, now I get your thoughts on it.     EDIT:  I'm a buffoon.  All this (above) text applies to 'Hacking: The Art of Exploitation, 2nd Edition'  and Not to the OP's book ""Learn C the Hard Way"" that you are addressing, too.    But I'll leave the text here for those that might be considering getting  'Hacking: The Art of Exploitation, 2nd Edition', and to reveal my buffoonery.     EDIT2:  I didn't think Learn C the Hard Way was too hot either, but at least it's free.  ""An IDE, or ""Integrated Development Environment"" will turn you stupid.""  ... yea, OK.  Hey, wait -- perhaps my years of IDE usage was root cause of my mispost?.... aww snap!"
C_Programming,3a4l0y,wiki_wild,7,Sat Jun 20 20:44:27 2015 UTC,"I did C in one module in college, so I didn't come at LCTHW with a complete blank slate, but suffice it to say my C was as rusty as the handrails on the Titanic.  However, I personally found LCTHW jumps around quite a lot - I found it hard to establish a rhythm to the lessons, and felt like I had to learn something and put a pin in it for the next couple of chapters until it became relevant again. I didn't get a real sense of progression.  Contrasting this to the K&R C book (I had the ANSI C edition), the lessons build up well and you're using most of the previous aspects that you've learned in subsequent chapters. It even goes through some of the C standard library functions and shows you how to code them (sometimes in a simplified fashion). I would personally recommend this over LCTHW."
C_Programming,3a4l0y,daemon_hunter,5,Wed Jun 17 08:16:10 2015 UTC,http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504 fantastic book
C_Programming,3a4l0y,shadowmint,6,Wed Jun 17 21:10:11 2015 UTC,"http://www.amazon.com/The-Programming-Language-Brian-Kernighan/dp/0131103628 is still the 'go to' book.  If you want some deep understanding, I also strongly recommend http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298 for digging into exactly what is defined and undefined behaviour, and how things work.  ...if, you have your heart set on C.  It's a great language, but it's not really terribly practical these days. Relatively few people use it for any significant purpose (and to be fair; those purposes are very significant, but they are few).  C++ security and exploit techniques are similar, and very much more applicable.   (see, for example https://code.facebook.com/posts/498597036962415/under-the-hood-building-moments/)  You may well be better off with a copy of http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996, which is an excellent C++ book that covers both the new modern features, and what to/not to use them for and http://www.amazon.com/Mastering-CMake-Ken-Martin/dp/1930934319, which is a book about how to use a proper cross platform build system.  I continue to recommend people not bother with LCTHW.   Its extremely opinionated, and the opinions in it are not ones you want to have. Unfortunately."
C_Programming,3a4l0y,zenkibudo,1 point,Wed Jun 17 13:17:47 2015 UTC,"Its extremely opinionated, and the opinions in it are not ones you want to have.      Nailed it.    EDIT: Also, i must chime in on your recommendation of The C Programming Language.  I spent $500 - $1000 (double that in 'today' money) on soo many learn C books, attracted by their colorful covers, promises and 700+ pages and bonus CD ROMS.    ""The C Programming Language"" could have saved me so much money, and I love it intensely to this day,  20+ years later.     *Even the 1978 1st edition -- which I'm keeping."
C_Programming,3a4l0y,smorrow,1 point,Sat Jun 20 21:18:11 2015 UTC,"Understanding C Pointers has a chapter on security, which can pretty much be read without having looked at any of the other chapters.  If you're just ""picking up"" C, then the whole book is pretty much worth looking at."
C_Programming,3a4l0y,peopledeservebetter,-1,Wed Jun 17 14:51:14 2015 UTC,"It's free, so you'll loose nothing by trying it. If you get through a couple of chapters and decide it's not for you, no one's gonna ram it down your throat and you can just move on. C is a great language in my opinion, and the main reason I learned was through simple enjoyment. If you have a passion, you'll accrue knowledge without even realizing.  As for your cyber security aspirations, I would view that as a separate topic. There's no one language that's best for it. Again, start looking at different stuff and see if you enjoy it, if not, reconsider your options. Check out Christof Paar's Introduction to Cryptography on YouTube first, that's as good a starting point as any in my opinion."
C_Programming,3a4l0y,lobocode,-2,Wed Jun 17 06:09:09 2015 UTC,"When thinking about security, think of another programming language. Not in C"
C_Programming,3a4l0y,zenkibudo,1 point,Wed Jun 17 14:37:34 2015 UTC,"Ok, i'm intrigued.  Why you say that?"
C_Programming,3a4l0y,Emperiz,3,Sat Jun 20 21:11:51 2015 UTC,"He's probably talking about that it's easy to shoot yourself in the foot with C (i.e. critical mistakes such as buffer overflows).  In my opinion, there is some truth in it. In C, the programmer has the responsibility to write secure code and the language doesn't protect you from your own stupidity. While this can be seen as a security risk, the relatively low abstraction of C could be seen as a security advantage."
C_Programming,3a4l0y,lobocode,2,Sun Jun 21 08:26:19 2015 UTC,"C’s standard type system does not rule out programs that the standard (and common practice) considers meaningless, e.g., programs that write off the end of a buffer."
C_Programming,3a6a2x,tmtwd,4,Wed Jun 17 15:45:46 2015 UTC,"You never print the address of b, you only print the value of b, which you do change from &a to the result of malloc. To print the address of b, use code like this:  printf(""%p\n"", &b);"
C_Programming,3a6a2x,FUZxxl,2,Wed Jun 17 16:08:02 2015 UTC,"The value of b starts as undefined; however, b has an address on the stack. &b points to the address of b. You can show the value of b (ignoring optimization). That is, you can see the data in memory at an address that it knows.   Then you assign to b the address of a.  b is a pointer that has an address on the stack, whose value is the address of an integer on the stack.  Then you assign to b an address on the heap.  b is a pointer that has an address on the stack, whose value is the address of an integer on the heap.  Edit: some clarification."
C_Programming,39xqoa,Enlightenment777,11,Mon Jun 15 17:35:41 2015 UTC,"To be honest, this result shouldn't be surprising to anyone. Competent developers as a rule know what they are doing and proceed with due caution when writing dangerous code.  That said, 400 files is no sample at all. I would very much like to see this study expanded to a much larger code base."
C_Programming,39xqoa,acwaters,17,Mon Jun 15 18:14:26 2015 UTC,"This paper is frankly pointless, since it's based on a misunderstanding of Dijkstra's original paper.  Dijkstra was arguing in favor of ""structured programming"", meaning programming using functions and high-level blocks (for and while loops), as opposed to implementing programs without using functions and high-level blocks.  In his monograph, he describes ""[a goto that] points to the interior of a procedure body"". But in C, no such thing is possible with a plain goto! You have to use something exotic like setjmp/longjmp.  So, in their conclusion where they state:   Overall, our qualitative study tells us that only a minority of goto usages are really exemplary of the 'disastrous effects' Dijkstra warned us about. We have no evidence that goto statements were used differently prior to Dijkstra's famous article than now.   they have clearly not done their research. Their conclusion that ""goto does not appear to be harmful in practice"" is correct, but for the wrong reason. It's not because Dijkstra was wrong and goto isn't harmful; it's because the goto statement in C is considerably more limited than the kind of goto that Dijkstra was criticizing at the time."
C_Programming,39xqoa,BigPeteB,12,Mon Jun 15 20:49:44 2015 UTC,"""We conclude that developers limit themselves to using goto appropriately in most cases, thus suggesting that goto does not appear to be harmful in practice."""
C_Programming,39xqoa,kynde,2,Mon Jun 15 17:36:36 2015 UTC,"Our qualitative study of a sample of files and functions using goto shed light on why goto statements are in use: far from being maintenance nightmares, most usages of goto follow disciplined, well-designed usage patterns, that are handled by specific constructs in more modern languages.   I've seen (and written) a lot of C code over the years. I've seen (and written) a lot horrible things, maintenance nightmares and subtle flaws with virtually every other construct except goto."
C_Programming,39xqoa,wolfman1911,2,Mon Jun 15 20:40:25 2015 UTC,"My intro to computer science teacher flat out told us that it's a bad practice, don't do it."
C_Programming,39xqoa,kynde,2,Tue Jun 16 02:10:28 2015 UTC,"He didn't know what he was talking about then. Or he was intentionally misleading noobs. It is the wrong tool for fresh programmers.  This is a good paper here. There are a number of really good uses for goto, error paths and fail case clean up being the most prominent example. Real world examples can be found from the linux kernel source tree."
C_Programming,39xqoa,BigPeteB,3,Tue Jun 16 06:17:57 2015 UTC,"He didn't know what he was talking about then. Or he was intentionally misleading noobs. [goto] is the wrong tool for fresh programmers.   Did I misunderstand this? It sounds like you're contradicting yourself. If you meant that goto is the wrong tool for fresh programmers, then how is an intro CS teacher saying not to use it bad?"
C_Programming,39xqoa,manvscode,1 point,Tue Jun 16 14:04:02 2015 UTC,Your computer science teacher must be a parrot.
C_Programming,39ygmc,nebuchadnezzar277,2,Mon Jun 15 20:35:23 2015 UTC,I would be careful. I don't know much about ooc but it's a small porject that may die in the near future. I wouldn't want my project depend on a project that small for no good reason.
C_Programming,39ygmc,FUZxxl,4,Mon Jun 15 22:21:04 2015 UTC,"Yes; there's even a language constructed specifically to shoot yourself in the foot, it's called PHP."
C_Programming,39ygmc,FUZxxl,3,Tue Jun 16 07:28:48 2015 UTC,"Yes; there's even a language constructed specifically to shoot yourself in the foot, it's called PHP.   That the old PHP (4.x). The new PHP shoots your foot for you."
C_Programming,39ygmc,playaspec,2,Tue Jun 16 09:56:59 2015 UTC,"There is also Cello, while not a full new language, adds essentially a new ""OOP"" syntax on top of C through abuse of the preprocessor."
C_Programming,39ygmc,k3q3,18,Tue Jun 16 09:59:54 2015 UTC,"C is C, don't try to make it object oriented.  Also, you plan to start this project in a year? No way, start today. A year from now you'll have already learned all the good stuff you're going to learn from it and moved on to better ideas with those new skills in your pocket.  I wrote a 3d engine for a game in the early 90s when I was about 15. The basics are incredibly simple and you absolutely can start them today. Day one stuff:   Make a struct that represents a 2d point. Make another. Make a function that draws a line between them. Make a third point. Use your line function to connect all three points. You just drew your first poly. Expand your line drawing function into a triangle drawing function. Teach it to fill in the triangle. Add a color value to your point struct now you can have your triangle function shade as it fills."
C_Programming,39ygmc,FUZxxl,9,Tue Jun 16 22:54:09 2015 UTC,"C is C, don't try to make it object oriented.   Ehem, many of the things we have in C++ (classes, inheritance, virtual functions started out as design patterns in C. It's absolutely possible to write C code in an object-oriented fashion and many large projects like the Linux kernel prove that it can be done without much headache."
C_Programming,39ygmc,VyseofArcadia,1 point,Tue Jun 16 15:02:00 2015 UTC,"It's absolutely possible to write C code in an object-oriented fashion   Point to where I said it wasn't possible? That's not even under discussion, his question says he's reading a chapter about it so already knows it's possible. He asked if we feel it's worth it for him in this project. My vote is it's not necessary."
C_Programming,39ygmc,angdev,2,Mon Jun 15 22:34:54 2015 UTC,"When OP says 3D game engine, what they probably mean is a set of convenience structs and functions using OpenGL/DirectX to make writing a game easier, not a from-scratch 3D engine for a game."
C_Programming,39ygmc,acwaters,4,Tue Jun 16 07:27:31 2015 UTC,"Quake 3 was written in C and is freely available. You should also look into COM, it's a pretty cool way of implementing objects regardless of the underlying language."
C_Programming,39ygmc,skeeto,5,Tue Jun 16 08:16:27 2015 UTC,"For a large project like this, I strongly advise you to learn C++. Object-oriented programming is a paradigm designed to produce modular, extensible codebases for complex solutions, and C++'s flavor of OOP is particularly suited to game development, since you get both high-level and low-level tools, and most of the high-level tools are practically (or literally) free. C++ can also do some neat things that even plain old C can't, like running algorithms or generating data structures at compile time when the input is known and constant. And especially for a project like this, you'll find polymorphism in all its forms to be an invaluable tool.  Of course, object-oriented programming is completely doable in C. It's a lot more code, because you have to deal with boilerplate, initialization, and finalization at every single instance site, but people have been doing it for a long time. If you want a really nice well-made example of an object-oriented C interface to see how it's typically done, have a look at cairo. Basically, it's a lot of passing pointers around, but the interface is functionally equivalent to a language like C++ or Java, where the pointer is simply passed implicitly at the method call site.  To rip an example directly from the tutorial there, initializing a surface and a context in C look like this:  cairo_surface_t *my_surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 500, 500); cairo_t *rect = cairo_create (my_surface);  cairo_set_line_width (rect, 1); cairo_set_source_rgb (rect, 0, 0, 0); cairo_rectangle (rect, 0, 0, 1, 1); cairo_fill (rect);   The real C++ cairo API is just a thin wrapper around the C, but if it weren't, it might look something like this:  cairo_t rect ({CAIRO_FORMAT_ARGB32, 500, 500});  rect.set_line_width(1); rect.set_source_rgb (0, 0, 0); rect.rectangle (0, 0, 1, 1); rect.fill();   In object-oriented language, constructors assume a lot of the work initializing objects; all you have to do is declare the object with the properties you want, and it is created, no need to manually initialize anything. Likewise, in languages like C++ that have destructors, you don't have to worry about cleaning up after your code; finalization takes place as soon as the object goes out of scope. This is an idiom called RAII in C++, whereby any resources (buffers, files, sockets, etc.) that the object needs should be allocated in the constructor and deallocated in the destructor. This gives you the speed and flexibility of manual memory management (e.g.) without the headache of having to keep tabs on all your pointers.  The benefit of C++ in this case is that, coming from C, you can learn as you go; because C++ is (almost) a superset of C, you can use your favorite programming style and ease yourself into the higher-level features. The thing you need to understand is C++ is enormous. Nobody uses everything C++ has to offer; you'll find the subset of features that are useful to you, and you won't ever have to worry about the rest, but it'll be there if ever you need it."
C_Programming,39ygmc,antoniocs,2,Tue Jun 16 17:27:11 2015 UTC,"Judicious use of function pointers on structs can get you the important parts of OOP, like polymorphism. That's been proven viable enough to build huge, complex operating system kernels. I wouldn't want build a whole project around a homebrew OOP system in C -- especially when lot of complex macros are involved, as often seems to be the case for these things. I don't remember how 21st Century C approaches it."
C_Programming,39ygmc,pfp-disciple,2,Mon Jun 15 21:34:47 2015 UTC,The Quake 3 engine has already been said but this guy did a Graphics engine in C and it might be easier to follow: https://github.com/orangeduck/Corange  If you want to do it in C then do it. You will never know until you try it. Some people will say its a good idea some say it will be a bad idea. There is nothing like doing it and actually finding out.  Best of luck!
C_Programming,39ygmc,looneysquash,2,Mon Jun 15 21:05:48 2015 UTC,"Possible? Sure. Glib is a very common example. Others have mentioned some game engines as well.  worth it/viable? That depends on your use case(s). OO programming is a tool, and whether it's the right tool depends on where it will be used, by whom, and how.   I wrote a very rudimentary OO system in C, which used not-very-complicated macros and some discipline. It provided polymorphism and single inheritance. It was purely a ""can I do this?"" activity, so I didn't do any timing analysis or anything. If I wanted to do C (for, say, inter-language compatibility) I'd consider using OO constructs in moderation.   I've not written a game engine, so I can't say if it's feasible/viable for you. I can say that it can be feasible/viable for certain sets of use cases."
C_Programming,39ygmc,BigPeteB,1 point,Mon Jun 15 21:09:31 2015 UTC,"I'm surprised that no one has mentioned GObject yet. It's what GTK uses for objects.  It's viable in the sense that lots of people have done it, all of GTK is built on top of it, etc.  The basic idea is you have a struct named my_struct, and a bunch of functions named my_struct_foo() that take a my_struct* as their first argument.  If you need inheritance, you make the first field of the struct be whatever it is you're inheriting from.  If you need virtual dispatch, well look at GObject does for that, that gets more complicated.  Is it a good idea? I'm not convinced.  You have C++, which is looking a lot nicer nowadays now that C++11 and C++14 are out.  One thing from C++ that I really miss in C is RAII. That removes a lot of ""goto""s for me. And then you use that with smart pointers, that removes a lot of manual memory allocation.  You also have Rust, which looks very interesting to me. And there's other things like Go, that look less interesting to me, but are popular right now.  If C++ looks too complicated, then just don't use what you don't need. Lots of projects, for example, compile with the option to disable exceptions. You don't have to write any templates if you don't want to. You don't have to set up complicated multiple-inheritance class hierarchies."
C_Programming,39vbb6,TheAvengingKnee,6,Mon Jun 15 02:32:56 2015 UTC,"from a legibility perspective, your variable names are unintuitive."
C_Programming,39vbb6,vedicvoyager,1 point,Mon Jun 15 02:51:55 2015 UTC,"They are a bit, they all mean something but you are right I could definitely improve."
C_Programming,39vbb6,vedicvoyager,6,Mon Jun 15 03:27:59 2015 UTC,"if this is for school, a teacher will appreciate descriptive variable names and functions, ie:  int numDuplicates; int numTotalCount; int doSomethingJustBecause(char * theThingToDo) etc...  depending on the school of thought your teacher comes from, you might get docked for using generic names.  from the unix philosophy: ""The Unix philosophy emphasizes building short, simple, clear, modular, and extensible code that can be easily maintained and repurposed by developers other than its creators."" more at: http://www.linfo.org/unix_philosophy.html  also:  ""Naming The careful selection of names is very important to understanding. Cryptic names of components, modules, classes, functions, arguments, exceptions and variables can lead to confusion about the role that these components play. Good naming is fundamental to good design, because source code represents the most detailed version of our design. Compare and contrast the ease with which the following statements can be understood:  out(p(f(v), 2) + 1); print(power(fibonacci(argument), 2) + 1);  There are common naming recommendations. Modules, components and classes are typically nouns (e.g. Molecule, BlackHole, DNASequence). Functions and methods are typically verbs (e.g. spliceGeneSequence, calculateOrbit). Boolean functions and methods are typically expressed as questions about properties (e.g. isStable, running, containsAtom).  Naming also relates to the use of capitalisation and delimiters, which can help a reader to quickly determine if something is a function, variable or class. Common guidelines for C and Java include:  Constants should be capitalised: PI, MAXIMUM_VALUE.  Class names should start with an initial capital with the first letter of subsequent words capitalised (this is called Camel Case): Molecule, BlackHole, DNASequence.  Functions should start with a lower-case letter with the first letter of subsequent words capitalised: spliceGeneSequence, calculateOrbit.""  more at: http://software.ac.uk/resources/guides/writing-readable-source-code  pedantic for sure, but all easily explainable code is :)"
C_Programming,39vbb6,SirSourdough,3,Mon Jun 15 03:59:26 2015 UTC,"Honestly, if they only mean something to you and anyone else will ever read the code then they effectively mean nothing.  Especially in a situation like this where you are asking for people to help you identify errors, it will only hinder you from getting the feedback you want because just understanding what the program is doing requires wading through and figuring out a bunch of single character variable names."
C_Programming,39vbb6,lmlight77,2,Mon Jun 15 14:12:35 2015 UTC,"Hi. There are a bunch of issues.  1. You should check the return value of fscanf. 2. You don't initialize or increment 'i' yet use it, but you do increment 'c'.  3. You should fclose the file after the read loop. 4. Why don't you want to add numbers from the file if the numbers are between l and h? 5. Consider using a ""while (1)"" loop to read and break if EOF returned from fscanf. 6. Your loop to count duplicates is going to way over count potentially. But, because you only save numbers now when the bounds l and h are extended, there will be no duplicates. Assume you fix that problem. The for example, assume the number 3 is repeated 4 times (3 3 3 3). The last 3 will not match anything. The third 3 will match the last. The second 3 will match the third and fourth. Finally the first 3 will match the next set of 3s. Total count will be 1+2+3=6, but there are only 3 duplicates.   What you should do is read all the numbers into an array. Then sort the array (quick sort or bubble sort or...). The loop through the array once more to find the lowest number, highest number, and while you are at it, duplicates. Duplicates are easy to detect, as if the current number matches the prior one, it's a duplicate. Sorted makes it easy."
C_Programming,39vbb6,lmlight77,1 point,Mon Jun 15 02:54:12 2015 UTC,For the last paragraph I haven't done that because I haven't been taught how to in the class so far.   1.) not 100% sure what you mean  2.) think I fixed that  3.) think I fixed that  4.) think I fixed that  5.)  I am not sure what you mean  6.)For the duplicates on this program I only care that there is at least one past that I don't need to care.   New: http://pastebin.com/xmWFzRBY
C_Programming,39vbb6,SirSourdough,1 point,Mon Jun 15 03:05:44 2015 UTC,"1.) not 100% sure what you mean   Something like:  while (1) {     int err = fscanf(...     if (err == EOF)         break;    5.)  I am not sure what you mean   See above.  I also think you have a typo (""++1""?)? Did the program compile?"
C_Programming,39vbb6,dmc_2930,1 point,Mon Jun 15 04:44:27 2015 UTC,"Not doing something because you haven't been taught it in class will not, unfortunately, get you very far as a programmer. Unless you've been expressly forbidden from using skills that haven't been taught in class, you should use this opportunity to do a little googling and figure out how to do a simple sort of an array. There are many possible methods including the ones mentioned above."
C_Programming,39vbb6,_RPM,1 point,Mon Jun 15 14:14:07 2015 UTC,"Rename your variables.  Don't use while( i=0;........). Do a while(1) as others have said above.  fscanf() has a return value. It will not set x to EOF, it will return eof:  if( fscanf( ........) == EOF ) {     /* fscanf returned EOF. */     break; }   That should get you started at least. Make all of these changes and I'll happily give you more advice. If you're still very confused, talk to your classmates/TA/professor and get some one-on-one help."
C_Programming,39vbb6,FUZxxl,2,Mon Jun 15 14:47:30 2015 UTC,"As a TA, if this was for a school assignment, I'd fail you for your choice of variable names."
C_Programming,39vbb6,waspentalive,1 point,Mon Jun 15 05:02:34 2015 UTC,"You use %n as a formatting specifier when printing the numbers. This is incorrect and probably causes your program to crash. Use %d or %i instead:  printf(""There are %d numbers in the file.\n"", c); printf(""The highest number in the file is: %d \n"", h); printf(""The lowest number in the file is: %d \n"", l);"
C_Programming,39vbb6,crookedkr,1 point,Mon Jun 15 08:37:53 2015 UTC,perhaps do an insert sort as you are reading numbers?
C_Programming,39vbb6,atreayou,1 point,Mon Jun 15 08:55:16 2015 UTC,"Do you know how many numbers there will be beforehand? If so, you can skip the sort and do min, max, dup in a single pass."
C_Programming,39vbb6,Spudd86,1 point,Mon Jun 15 11:44:45 2015 UTC,I am not seeing i incremented. That could be the immediate problem if its just not printing.
C_Programming,39x5h5,legandrery,5,Mon Jun 15 15:00:41 2015 UTC,"Do you have any programming experience / prior courses ? If not, I would suggest picking a book about it. If yes, translating the equations to code shoule be pretty easy, what is your problem more precisely ?"
C_Programming,39x5h5,MrGeekAlive,1 point,Mon Jun 15 15:08:52 2015 UTC,"I did have a quick course on c, but i can basically only do for´s. Besides, it was over 2 years ago, i dont really remember. Thanks for your help, but i think i ll just skip this..."
C_Programming,39x5h5,MartenBE,4,Mon Jun 15 19:13:56 2015 UTC,"You would best learn to use python. It has many math capabilities and it is one of the easier languages to dive in:  http://www.learnpython.org/ will teach the basics  https://www.python.org/ provides a windows installer to install python  After python is installed, use any editor to create a python file (mostly those files are given a name ending on "".py"") and then you can run it on the commandline using ""python <filename>""."
C_Programming,39x5h5,FUZxxl,5,Mon Jun 15 16:08:33 2015 UTC,"There are no urgent question on this subreddit. If your question is urgent, you should have asked when there was still enough time. Your emergency is not our problem."
C_Programming,39x5h5,FUZxxl,1 point,Mon Jun 15 15:39:33 2015 UTC,"You didnt have to be this mean, but i understand"
C_Programming,39qcpl,SgtCheesepuffs,25,Sat Jun 13 18:53:53 2015 UTC,"If you're looking to take the plunge into the C family, I strongly recommend learning C first. Okay, that was the tldr, you can skip the rest of this if you don't care about language details.  So they're not all completely different. C++ is almost a superset of C, meaning it's basically C with a bunch of high-level features bolted on. Objective-C is another close relative. Whereas C++ has a few tricky differences, Objective-C is a proper superset, meaning any valid C program is guaranteed to do the same thing when compiled in Objective-C.  C++ and Objective-C were developed independently at the same time, interestingly enough, and both were designed to add language-level object-oriented features, but they went about it in different ways, with very different syntax and using different object models.  C++ was influenced heavily by Simula, and therefore extended the semantics of C's struct to that of an object class, adding method functions, function overloading and overriding, access modifiers, and polymorphic inheritance. Later versions would include parametric polymorphism in the form of templates, operator overloading for most symbolic operations as well as implicit conversions between types, anonymous lambda functions, the constexpr keyword, allowing functions with constant static operands to be evaluated at compile-time, and various other shiny features that someone thought would be fun to have. Perhaps most importantly, it adopted a syntax that flows very naturally from C, making basic C++ fairly easy to read for a C programmer who's never seen it before.  Objective-C, on the other hand, took its semantic and syntactic cues from SmallTalk, meaning that instead of invoking a method function on an instance of a class, you pass the instance a message, which is basically a fancy string. One consequence of this is that, rather than being directly bound in code like normal functions, methods in Objective-C are resolved dynamically at runtime. This means you get polymorphism in the form of method dispatch without the added space and complexity of C++'s virtual tables, but all your invokations are dispatched and are slower as a result. Message passing has a powerful advantage, however, in that you can pass a class or instance a message that it doesn't actually handle, and it can either drop it silently or forward it to another object to be handled. Another feature of Objective-C that is missing from C++ and modern OO languages is the concept of a category, which is an ad-hoc implementation that can add to or modify a class' methods, both public and private, at run-time, allowing you to extend or alter certain functionality even if you don't have access to the source code. Objective-C uses SmallTalk syntax for messaging, which fits around the C grammar without disturbing it but looks very alien to programmers coming from C-style languages, which has stymied its adoption outside of Apple and their products.  C# as a language is very unlike C -- don't confuse it with the two above just because its name looks similar. It was most heavily influenced by Java, but it is altogether more modern, incorporating several extra features from C++ and elsewhere that make it not so painful to use (multiple inheritance, lambdas, pointers, object value semantics, pass-by-reference, operator overloading, extension methods, a generic system that is actually useful, etc.). It is a very good language, and I encourage you to try it out, but it is only distantly related to C. Just don't get caught up in the political arguments that often surround it due to its association with Microsoft -- there are several free (as in speech and/or beer) implementations out there."
C_Programming,39qcpl,acwaters,3,Sat Jun 13 21:13:03 2015 UTC,I just wanted to say that this was a refreshingly (mostly) unbiased summary of these languages. Nice job!
C_Programming,39qcpl,url00,2,Sun Jun 14 17:42:39 2015 UTC,Thank you!
C_Programming,39qcpl,acwaters,1 point,Sun Jun 14 19:03:15 2015 UTC,Spot on descriptions!
C_Programming,39qcpl,atreayou,5,Mon Jun 22 18:34:51 2015 UTC,"What languages do you already know?  What OSes do you primarily use?  If you don't know any OO languages yet, then learn C.first so you don't have to deal with learning both OO concepts and the language at the same time.  If you only run and intend to only run Microsoft OSes, go for C#.  Otherwise, pick one of the other languages that'll useful on other platforms."
C_Programming,39qcpl,EmbeddedEntropy,1 point,Sat Jun 13 20:23:38 2015 UTC,I am familiar with Java and Python. I primarily use Windows.  What are OO languages?
C_Programming,39qcpl,panderingPenguin,4,Sat Jun 13 20:26:26 2015 UTC,"Java is a very OO (object oriented) language and Python also supports OO programming.  Not trying to sound harsh, but if you are unfamiliar with this term, I'm somewhat suspicious that you don't know these languages very well yet and perhaps your time would be better spent going more in depth with them rather than adding yet another language."
C_Programming,39qcpl,lemonfresh33,5,Sun Jun 14 11:51:02 2015 UTC,"If you know Java, C# will be very straightforward for you, they are very similar languages."
C_Programming,39qcpl,FUZxxl,4,Sat Jun 13 20:50:48 2015 UTC,"If you want to start with C programming, don't do so on Windows as the C environment on Windows is horribly outdated and tricky to set up."
C_Programming,39qcpl,FUZxxl,1 point,Sat Jun 13 20:44:50 2015 UTC,"Btw, wasn't Windows created with C?"
C_Programming,39qcpl,FUZxxl,3,Sun Jun 14 03:13:10 2015 UTC,Yes; most operating systems were. Doesn't mean that it's the most convenient system to program on.
C_Programming,39qcpl,zomgreddit0r,1 point,Sun Jun 14 07:25:40 2015 UTC,"Are you referring to visual studio? You just run the installer and you're hello world'ing in C two minutes later, there's no further setup required. It is c99 if that's what you're referring to as ""horribly dated"", but that's not any kind of hinderance to learning the basics of C.  OP I suggest you learn the normal tools for your normal OS, whatever that is. They all work fine. Then when you do learn to make something it will be useful to you on the computer you and your friends actually use. That is the goal after all, to make something you want to use."
C_Programming,39qcpl,FUZxxl,2,Sun Jun 14 00:18:38 2015 UTC,"It is c99   Huch? When did Microsoft implement C99? The last thing I read was that they finally implemented stdint.h last year, but there are still many features from C99 missing, like variable length arrays, struct literals, and struct declarators.  And when did they start providing a C99 compliant standard library? I remember various functions missing."
C_Programming,39qcpl,FUZxxl,3,Sun Jun 14 00:20:30 2015 UTC,"While Visual Studio 2013 still doesn't support VLAs, it now supports designated initializers, compound literals, mixed code and declarations, and a good portion of the standard headers."
C_Programming,39qcpl,FUZxxl,1 point,Sun Jun 14 03:06:15 2015 UTC,"Yeah that's true, I guess it would be more accurate to say it's a subset of c99, but it seems more than good enough for a beginner get started with C. Nobody wants VLAs anyways right? Out of curiosity do even gcc or clang support every part of c99? I kind of doubt it, although I'm sure they're a lot closer."
C_Programming,39qcpl,Jack126Guy,2,Sun Jun 14 01:17:54 2015 UTC,"So, it's not a C99 compliant environment. gcc and clang support c99 completely since ages and if I recall correctly they achieved c11 compatibility just recently.  And yes, you do want VLAs because they solve a problem and they do that much better than alloca() does."
C_Programming,39qcpl,FUZxxl,3,Sun Jun 14 07:24:25 2015 UTC,"VLAs are widely considered to have been a mistake and were demoted to an optional feature in later releases. I have no interest in a holy war about them, I think it's sufficient to say they're in no way an essential requirement of a beginner learning c.  I did a quick google, neither gcc or clang support 100% of the c99 spec. Wiki describes gcc as ""mostly"" supporting c99 and gnu themselves describe it as ""substantially complete""."
C_Programming,39qcpl,Jack126Guy,2,Sun Jun 14 16:39:42 2015 UTC,"The only thing gcc is missing right now are the pragmas to control the floating pointer environment. This is okay, they are only needed when you need to have very fine control over when floating point operations generate a signal.  Microsoft's C compiler OTOH is missing almost all features, the standard library is in a similar state. It doesn't even claim to understand C99.  VLAs are useful when you need to quickly allocate a dynamic amount of memory on the stack as they are much faster than calling malloc."
C_Programming,39qcpl,FUZxxl,0,Sun Jun 14 16:54:31 2015 UTC,Then what should I do it on?
C_Programming,39qcpl,Jack126Guy,5,Sat Jun 13 21:00:50 2015 UTC,Use Linux. The compiler is preinstalled and the environment is much nicer to work in.
C_Programming,39qcpl,playaspec,-1,Sat Jun 13 21:06:48 2015 UTC,"None of my Linux installations came with a compiler preinstalled. Still, I do agree that programming is easier on Linux."
C_Programming,39qcpl,zifyoip,5,Sat Jun 13 22:24:36 2015 UTC,That's weird. What distribution did you use? The program cc (the C compiler) in the implementation gcc (the GNU C compiler) is pre-installed on all distributions I know.
C_Programming,39qcpl,playaspec,-1,Sat Jun 13 22:35:17 2015 UTC,"I've used Ubuntu and Debian. I think it may actually be just G++ that wasn't preinstalled, since I work with C++.  EDIT: Ubuntu Forums thread in which it is implied GCC is not installed by default or maybe it is"
C_Programming,39qcpl,zifyoip,3,Sat Jun 13 22:43:43 2015 UTC,"Well, g++ is not a C compiler. Again, C and C++ are different languages. A C compiler should come preinstalled with each UNIX-like operating system as it's a fundamental part of such a system. Almost all Linux distributions I know follow this, exceptions being distributions that focus on distribution size or distributions were having a compiler may be a security problem."
C_Programming,39qcpl,FUZxxl,1 point,Sat Jun 13 22:57:53 2015 UTC,"I understand that G++ is not a C compiler. I concede that I may not have followed which was preinstalled and which was not. As G++ depends on GCC, once I install G++ it's impossible to tell if GCC was actually preinstalled."
C_Programming,39qcpl,iDinduMuffin,2,Sat Jun 13 23:01:26 2015 UTC,What are OO languages?   Object Oriented.
C_Programming,39qcpl,FUZxxl,-1,Sun Jun 14 15:57:47 2015 UTC,"1) Which C programming language would be better to learn first? C, C#, or C++?   They are completely different languages.  https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_what_is_the_difference_between_c.2C_c.2B.2B.2C_objective-c.2C_and_c.23.3F   2) What are some good sites or books to learn C?   Read the sidebar."
C_Programming,39qcpl,pinealservo,2,Sat Jun 13 19:00:59 2015 UTC,They are completely different languages.   This is flatly WRONG. They are closely related. Both C++ and Objective C are direct descendants of C.
C_Programming,39qcpl,iDinduMuffin,0,Sun Jun 14 16:02:10 2015 UTC,"They are completely different languages in the sense that none of them is prerequisite knowledge for any other. I was answering OP's question, which was asking which one is best to learn first."
C_Programming,39qcpl,FUZxxl,2,Sun Jun 14 16:40:20 2015 UTC,"Oh, I assumed they were similar since they start with C thought they were varient types.   And I did read the sidebar, but I meant to ask if there are any more."
C_Programming,39qcpl,iDinduMuffin,0,Sat Jun 13 19:06:04 2015 UTC,"C++ is mostly an extension to C, as is Objective C. C# is an entirely different language."
C_Programming,39qcpl,FUZxxl,1 point,Sat Jun 13 20:44:21 2015 UTC,"They are at least cousins. Much of the syntax is similar. Compare to something like BASIC, FORTRAN, or COBOL."
C_Programming,39qcpl,iDinduMuffin,3,Sun Jun 14 02:37:44 2015 UTC,I would say that Fortran is closed to C than C# is. Just because C# uses the syntactical ideas from BCPL (which C later adopted) doesn't make it a cousin.
C_Programming,39qcpl,THRAKERZ0D,1 point,Sun Jun 14 07:27:01 2015 UTC,"I'm not sure what you're trying to say about the relationship of C, C#, and BCPL; but taken as you've written it, you've got some serious temporal anomalies in your attribution chain.  BCPL is a really old language from the late 60s, basically a cut-down or 'bootstrap' version of CPL (a joint language effort between Universities of Cambridge and London based roughly on Algol 60, but with a wide enough scope that it proved difficult to implement) so they could have something to write compilers with.  BCPL served as inspiration for B, which is the immediate predecessor to C, and B did indeed look a lot like C. But BCPL doesn't look like either C or C#; I don't think you could say C# borrowed syntactical ideas from BCPL in any meaningful way, but it did definitely borrow from C's syntax, which it got largely from B but not BCPL.  C is probably closer semantically to Fortran than to C#, but mostly because C# has a lot of extra stuff that C doesn't. The things C has in common with Fortran C# mostly has in common as well; i.e. the basic mathematical expression syntax, which was most of the point of Fortran in the first place. This is in contrast to APL, for example, which has a very different way of dealing with mathematical expressions."
C_Programming,39qcpl,playaspec,1 point,Mon Jun 15 06:41:08 2015 UTC,No.
C_Programming,39qcpl,BowserKoopa,3,Sun Jun 14 15:34:49 2015 UTC,"explain, please."
C_Programming,39qcpl,pinealservo,2,Sun Jun 14 15:51:41 2015 UTC,"Wikipedia:   The core syntax of C# language is similar to that of other C-style languages such as C, C++ and Java. In particular:  Semicolons are used to denote the end of a statement.  Curly brackets are used to group statements. Statements are commonly grouped into methods (functions), methods into classes, and classes into namespaces.  Variables are assigned using an equals sign, but compared using two consecutive equals signs.  Square brackets are used with arrays, both to declare them and to get a value at a given index in one of them.   Sample FORTRAN code:   C AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION  C INPUT - TAPE READER UNIT 5, INTEGER INPUT  C OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT  C INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING   READ INPUT TAPE 5, 501, IA, IB, IC   501 FORMAT (3I5)  C IA, IB, AND IC MAY NOT BE NEGATIVE  C FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE  C IS GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO  IF (IA) 777, 777, 701  701 IF (IB) 777, 777, 702  702 IF (IC) 777, 777, 703  703 IF (IA+IB-IC) 777,777,704  704 IF (IA+IC-IB) 777,777,705  705 IF (IB+IC-IA) 777,777,799  777 STOP 1  C USING HERON'S FORMULA WE CALCULATE THE  C AREA OF THE TRIANGLE  799 S = FLOATF (IA + IB + IC) / 2.0  AREA = SQRT( S * (S - FLOATF(IA)) * (S - FLOATF(IB)) *  +     (S - FLOATF(IC)))   WRITE OUTPUT TAPE 6, 601, IA, IB, IC, AREA   601 FORMAT (4H A= ,I5,5H  B= ,I5,5H  C= ,I5,8H  AREA= ,F10.2,  +        13H SQUARE UNITS)   STOP  END    If that honestly looks more like C than C# does to you, we're never going to agree about much  else."
C_Programming,39qcpl,iDinduMuffin,3,Sun Jun 14 15:56:51 2015 UTC,"Syntax is moot when comparing similarities between languages. The interesting point is paradigm and language features; C has much more concepts in common with FORTRAN than with C#. FORTRAN is not equal to C either, it's different in quite a few ways (mostly in regards to array indexing and argument passing semantics). Yet these two are much closer to one-another than C# is to any of these two.  In a similar way, Estonian is not a cousin of German even though both use the same alphabet, the same diacritics and similar spelling."
C_Programming,39qcpl,OldWolf2,1 point,Sun Jun 14 16:29:29 2015 UTC,"Syntax is moot.   Whatever. You're not going to let this go, so it's a pointless argument. If you'd like to share all of your criteria for what makes a language similar to you before I bother replying again, I might try.   Paradigm   So, because I can use lambdas in C++14 its more like Haskell than C++03?"
C_Programming,39qcpl,Sj660,2,Sun Jun 14 17:10:04 2015 UTC,there are like ~100 languages that borrow from C in a lot of ways.
C_Programming,39qcpl,iDinduMuffin,1 point,Sun Jun 14 03:04:42 2015 UTC,"Oh, I assumed they were similar since they start with C thought they were varient types.    They are. /u/zifyiop doesn't know what the hell he is talking about."
C_Programming,39qcpl,OldWolf2,1 point,Sun Jun 14 16:04:07 2015 UTC,"Not C#  C# is a bad Java knockoff from Microsoft, and is pretty stuck to Windows."
C_Programming,39qcpl,solvorn,1 point,Mon Jun 15 01:15:30 2015 UTC,"C# may have started as a Java knockoff, but it pretty quickly advanced to being its own language with some pretty nice ideas in it. Without the constraints of backward-compatibility that Java had, it was able to evolve a lot faster. It's also not stuck to Windows, and is getting less tied to Windows all the time."
C_Programming,39qcpl,OldWolf2,0,Mon Jun 15 06:47:07 2015 UTC,"C++ style C. In other words, use basic C with the constraints of the C++ compiler but without the OOP stuff or the C++ STL. At first. If you can make this work, you'll understand why other langauges try to abstract away most of what they do."
C_Programming,39qcpl,iDinduMuffin,2,Sun Jun 14 02:36:44 2015 UTC,"use basic C with the constraints of the C++ compiler   ????  Use a C compiler to compile C, and use a C++ compiler to compile C++."
C_Programming,39qcpl,OldWolf2,2,Sun Jun 14 09:15:03 2015 UTC,He doesn't know that you can compile C++ in C
C_Programming,39qcpl,iDinduMuffin,-2,Sun Jun 14 17:05:16 2015 UTC,"""No.""  You don't understand what im saying. A c++ compiler makes more exacting demands about pointers, etc. but you can write your code calling the standard C lib and virtually all C syntax and semantics and then compile it with a C++ compiler.  It's great for learning. Then you can build on that.  Congrats. It's 8am and you've already won the ignoramus who thinks he knows everything of the day award.  Edit: from wikipedia:   One commonly encountered difference is that C is more weakly-typed when it comes to pointers. For example, C allows a void* pointer to be assigned to any pointer type without a cast, whereas C++ does not.   This is good practice for learning."
C_Programming,39qcpl,OldWolf2,2,Sun Jun 14 15:28:35 2015 UTC,"This is a terrible idea for learning as you learn neither C nor C++ this way.  The C++ compiler follows different language rules because the languages are different.  Your post shows great ignorance about C, C++, and how to use compilers.  There might have been a grain of truth 20 years ago when some C compilers allowed illegal C code with no comment, but those days are long gone."
C_Programming,39qcpl,solvorn,2,Sun Jun 14 15:39:34 2015 UTC,There are books that say to do exactly that. I'm not sure why you think this is wrong.
C_Programming,39qcpl,Sj660,1 point,Sun Jun 14 17:02:03 2015 UTC,There are a lot of bad C and C++ books out there.
C_Programming,39qcpl,OldWolf2,-1,Mon Jun 15 09:42:49 2015 UTC,"No.  You are doubling down on wrong.  You learn C this way. Most C code is valid C++. You can compile C style C++ easily. You are literally wrong about everything.  In fact, the differences yiu are going to bring up about divergences dont matter to a learner. Youre doing the typical braggart thing where you pull some obscure feature no one in the early cycles of learning like OP is will never encounter to ""prove"" this distinction–when you're really just trying to show off instead of helping a learner. Casting pointers and avoiding C++ keywords and otherwise writing C is great for understanding and used in many curricula.  Edit:  /*this is perfectly valid c++*/  #include <stdio.h>  int main ( void )  {  printf(""hello, idiot.\n"");  return(0);  }"
C_Programming,39qcpl,pinealservo,2,Sun Jun 14 15:44:18 2015 UTC,"Most C code is valid C++.    All C code is valid C. You can compile C easily with a C compiler.   Nothing is learned about C by using the wrong compiler. You might learn about the differences between C and C++, however if you don't know what correct C and C++ are in the first place then you won't  know whether you're seeing a difference between C and C++, or a mistake in your code.  Adding to all this, trial-and-error via a compiler is the worst possible way to learn C or C++. This is because you don't know if you are seeing undefined behaviour or not.    Re your edit: so what do you gain by compiling that with a C++ compiler?"
C_Programming,39qcpl,OldWolf2,0,Sun Jun 14 15:49:06 2015 UTC,"Re your edit: so what do you gain by compiling that with a C++ compiler?   See, you just are doubling down. You aren't reading what I'm suggesting. You don't gain anything in terms of performance or anything like that. In terms of learning, that simple code, nothing. But as you go through the usual textbooks a little, you start to get into things where some of the extra restrictions of the C++ compiler remind you of what's going on a little more. That's all. It's not a long term solution. It's a start. For a learner. You just want to argue pedantic points. I want to help OP get his brain around the basic concepts first before arguing whether C99 is a perfect subset of C++11 or whatever."
C_Programming,39qcpl,pinealservo,1 point,Sun Jun 14 16:05:47 2015 UTC,you start to get into things where some of the extra restrictions of the C++ compiler remind you of what's going on a little more.   No you don't.   Show some code that is actually of pedagogical value to compile with the two different compilers .
C_Programming,39qihk,Pants__Magee,6,Sat Jun 13 19:45:14 2015 UTC,"SDL is a C library, there are no ""C++ concepts"" in the library. And if you decide you want to beyond SDL's 2D api and use OpenGL, that too is C library with no ""C++ concepts"". SDL provides you with a set of functions and a couple C structures (or pointers to internal library structures) to work with, how you use them is up to you."
C_Programming,39qihk,TehJohnny,3,Sat Jun 13 19:58:09 2015 UTC,"I know there are no C++ concepts in the library; I must've chosen my words incorrectly. But the majority of how people use the library is with C++. So I'm just curious if there are problems in the future that I might run in to when programming in C, rather than C++. Thanks for your response."
C_Programming,39qihk,TehJohnny,5,Sat Jun 13 20:09:07 2015 UTC,"Well, I can't really think of any problems you would have with C over C++ while using SDL and C, you might end up reinventing the wheel a bit for some C++ features, but that really isn't a ""problem"" with C. Games were mostly written in C until some time in the 2000s when C++ was 'good enough' for games, stuff like the Quake 3 engine were written in C (they ported the engine code to C++ with Doom 3)."
C_Programming,39qihk,FUZxxl,3,Sat Jun 13 22:56:12 2015 UTC,"As I've never seriously worked with C++, my answer might be a bit biased, but I didn't ever have problems working in C. You might want to tackle some problems differently from the way you would approach them in C++ though."
C_Programming,39qihk,YandereStudios,2,Sat Jun 13 20:35:55 2015 UTC,I was always intrigued by this as well. SDL is written in C. OpenGL is written in C. Why not write your games in C?
C_Programming,39qihk,Hellenas,2,Sun Jun 14 11:46:31 2015 UTC,"I'm going to say probably for organization.  While C is more than capable for writing a game using SDL, the classes in C++ make it pretty well suited for games.  It would be nice for animations to be able to just say hero.next_step() or hero.init_laughing() and in and RPG hero.poison_damage().  However, it still can be done by elaborating these kinds of things and just doing poison_damage(hero) where hero is a pointer to a struct or something."
C_Programming,39qihk,MisterMeeseeks47,2,Mon Jun 15 16:21:52 2015 UTC,"You can have a hero struct that contains function pointers for next_step() and other functions.  It's not as elegant as c++ classes, but it works"
C_Programming,39qihk,Hellenas,2,Thu Jun 18 15:10:24 2015 UTC,"I would debate putting the function pointers in the struct at all.  I think a lot of that is my programming methodology personally.    That said, I could function pointers in the struct being useful because it would let you in a way imitate virtual functions.  For example, we have an actor struct, which is used to represent characters on screen.  The movement function it points to could be things like move_user(), move_random(), move_follow(), move_pattern(), move_still(), et alia.  This would be nice I guess since when it comes time to move the actors you wouldn't need a switch-case deal, but could just invoke the member.  I guess you could do this as well by declaring the functions, storing pointers to them in an array, having an int or something in the struct for which to choose, and then indexing to invoke it or something.  This is a fun thought exercize, and there are definitely ups and downs to any solution (that arrays one could get really messy really fast).  EDIT: Sorry for rambling."
C_Programming,39qihk,Hellenas,1 point,Thu Jun 18 15:41:43 2015 UTC,Don't be sorry! I find it really cool that there are many ways of doing the same thing. I have never ever coded function pointers before so I might play around with that and see if things fit nicely. I remember my professor would always say that loose-coupling and high-cohesion are essential for a successful project. It seems to me that function pointers would be able to help out with any coupling problems!
C_Programming,39qihk,Hellenas,1 point,Sun Jun 21 02:27:33 2015 UTC,"If you've never used them, you might as well take the time to do it for this!  No better way to learn than to crash and burn a few times!"
C_Programming,39qihk,Hellenas,2,Sun Jun 21 17:24:47 2015 UTC,"You're trying to move to fast.  You need to slow yourself down a bit, write some small code, encounter some bugs, and learn from that.  If you think you're going to somehow write perfect code from the get go, you're in for a bad time.  Get in the mud.   I've already bumped into an episode where he uses classes to define some sprites.   Then you know how to invoke the relevant points of SDL.  Instead of looking at the C++ codes and classes, look at what you want to design and use what is available to you.  For animation and sprites, you probably can pull this off with a no frills struct and a couple auxiliary functions in a dedicated file that you include.  Just don't try to make a mime of a class or you'll make a mess.   Is this all I have to be concerned about? Or are there other C++ concepts that I'd have to try to mess around with to get working in C.    The biggest thing you have to be concerned about is that you're fretting.  Start small, then slowly build on that scaffolding.  Build in a manner that is natural for the tool you have, and you will make a solution that is clean and easy to follow."
C_Programming,39qihk,antoniocs,1 point,Mon Jun 15 16:18:01 2015 UTC,"First of all, I think you're right. I find myself in a frustrating pattern where I always bite more than I can chew. Small steps is a very important thing, and I will work hard to focus on the little things one at a time.   Instead of looking at the C++ codes and classes, look at what you want to design and use what is available to you.   I see the advice you're giving me, but I'm unsure what I want to design. Do you mean for every tutorial I do, spend some time trying to figure out how I would implement the new concept in my own project and see if I can make something work without creating some class that ends up being a disaster?  Thanks for your response."
C_Programming,39qihk,SECAUCUS_JUNCTION,2,Thu Jun 18 02:57:16 2015 UTC,"I see the advice you're giving me, but I'm unsure what I want to design. Do you mean for every tutorial I do, spend some time trying to figure out how I would implement the new concept in my own project and see if I can make something work without creating some class that ends up being a disaster?   Being unsure of what you want to design is probably the biggest hurdle here.  Might I suggest just doing something simple like an animation from a single file?  Don't even worry about where you display it on the screen; hardcode it to 0,0 for now.  This is the point where I'll probably start getting a little shaky since it has been long enough for me to be not so sharp with things SDL.  So we have all our sprites in a single file with known clipping rects in it.  This means we can define rects for our frames, and using the surface we load create a struct like so:  typedef struct{     SDL_Surface* source;     int          num_frames;     int          current_frame;     SDL_Rect     frames[];  //may wan this as SDL_Rect*                                       //Give it a test, my gut says pointers for some reason } anim;   With that, you can set a function to load and malloc everything up, then set up a different function that will increment the current frame when needed, and a final one to blit it which should contain something like  SDL_BlitSurface(my_anim -> source, my_anim->frames[my_anim -> current_frame],  DESTINATION, &offset)   where DESTINATION is whatever we blit to, and offset is some x,y pair in an SDL_Rect saying where to print it.  Again, some of this is probably a little rusty, so play around with it."
C_Programming,39qihk,balkenbrij,2,Thu Jun 18 11:54:51 2015 UTC,"This is a great idea! And thanks for the head start, too. I'll tackle this problem and see if I can mess around with other situations I might run into in the future. Thanks, /u/Hellenas !"
C_Programming,39qihk,FUZxxl,1 point,Sun Jun 21 02:29:47 2015 UTC,"Hey I am also doing the SDL2 Lazyfoo tutorials (currently redoing some lessons because I stopped following the lessons) in C and taking my first steps in game programming.  You can take a look at my progress here.  I also plan on doing everything in C. Maybe because of the added challenges and maybe because I can relearn some common data structures in the process, but I think beyond a bit more verbose and thinking a bit differently, doing games in C is very plausible.  You can take a look at the guy from Hand Made Hero, he is doing a game in C (currently going on lesson 135) and he is not using any libraries.  If he can do it, we can certainly at least try :) Good luck!!"
C_Programming,39qihk,balkenbrij,1 point,Sun Jun 14 09:00:21 2015 UTC,"Re: memory management, you're better off pre-allocating for performance anyway. If you use an entity-based system, just allocate a large number of entities up front, and then free it when the program closes. Ideally just one malloc, one free -- extremely simple."
C_Programming,39qihk,FUZxxl,0,Sun Jun 14 18:12:56 2015 UTC,"you can write c++ in c but it's not pretty, certainly if you want to add more advanced things. You can however use function pointers in a struct to have somewhat similar thing as methods. I'm not sure if that will be more friendly then just using a struct for your data and functions which operate on that seperatly. There's lot's of information on writing c++ in c so if you really want that you could use http://www.cs.rit.edu/~ats/books/ooc.pdf I wouldn't do it that way though. Also, i have only limited sdl experience."
C_Programming,39qihk,balkenbrij,5,Sat Jun 13 20:03:18 2015 UTC,"you can write c++ in c but it's not pretty, certainly if you want to add more advanced things.   How did you come to that impression?"
C_Programming,39qihk,BowserKoopa,3,Sat Jun 13 20:36:16 2015 UTC,"well, virtual functions/inheretance came to mind for instance. I think it's weird to do these kind of things in c and i think it makes things needlessly complex but that's just me."
C_Programming,39qihk,FUZxxl,5,Sat Jun 13 20:43:41 2015 UTC,"I've never seen a reason to use inheritance. All situations were you could use inheritance can be resolved by composing interfaces just as well and with less problems when you try to refactor the code. I actually think that classic inheritance is a bad pattern as it interlocks components that could be independent and makes refactoring code really hard. Virtual functions can be constructed manually with function pointers. You can even use the object.method() syntax with this approach!  I rarely need these two for C programs, although they come in really handy in the kind of programs you use SDL for (namely, games and simulations)."
C_Programming,39qihk,BowserKoopa,3,Sat Jun 13 20:48:33 2015 UTC,"yes i can see why they come in handy, it's just that using c for these things is imho just too complicated to justify it's use. Function pointers in a struct are way easier to use/implement/grasp and are used very much in some generic structs (say a compressor struct which implements several compression algorithms which has function pointers for open, write, read and close). I think however people should not make things harder then they should, the kiss principle works out pretty fine mostly. So if you really need all the c++ things, just use c++. If not, it's best to not think about a c++ way to much while doing c."
C_Programming,39qihk,FUZxxl,2,Sat Jun 13 20:58:36 2015 UTC,"Inheritance can be ""forced"" in to C by ways of absolutely nasty hacks like structure aliasing, where you have multiple structures that have a common fingerprint, where each inheritor adds new fields following the common fields. This means that as long as each is aligned the same way, you can ""downcast"" them and use them where a superclass is expected.  This is a terrible, terrible thing, and you should never do it."
C_Programming,39qihk,wiktor_b,1 point,Sun Jun 14 18:51:27 2015 UTC,It's not even undefined behaviour. The C standard guarantees that you can cast a pointer to the first member of a struct to a pointer to the surrounding structure and vice versa. This rules makes this pattern staightforward and well-defined.
C_Programming,39qihk,balkenbrij,2,Sun Jun 14 19:09:09 2015 UTC,"I never said it was undefined behaviour, I just said it's something that you should avoid doing.  There are times I have used it, like when writing a linked list, the implementation of which was entirely hidden from the client code."
C_Programming,39q2lf,cunttard,6,Sat Jun 13 17:26:08 2015 UTC,"ISO 9899:1990§2.2.4.2 says that ULONG_MAX is at least 4294967295, so your assumption is correct."
C_Programming,39q2lf,FUZxxl,7,Sat Jun 13 20:18:54 2015 UTC,"The C standard does not guarantee that all bits in the representation of a type are used in the representation of values; ""padding bits"" are allowed.  https://stackoverflow.com/questions/14120197/are-there-any-existing-c-implementations-having-padding-bit-in-unsigned-intege  https://stackoverflow.com/questions/4475540/c-question-padding-bits-in-unsigned-integers-and-bitwise-operations-c89"
C_Programming,39q2lf,zifyoip,6,Sat Jun 13 17:46:53 2015 UTC,"while this is true, the standard specifies that an unsigned long int can at least stores integers in the range from 0 to 232-1."
C_Programming,39q2lf,FUZxxl,2,Sat Jun 13 20:19:49 2015 UTC,Thanks. This was the answer I was trying to elicit. Tossing a coin now if I'm really married to C89 and instead simply use C99 stdint integral types. Sigh.
C_Programming,39q2lf,FUZxxl,3,Sun Jun 14 01:47:01 2015 UTC,"Ehem, actually C89 guarantees the assumptions you make. While /u/zifyoip is right in what he says, the rule about the range of an unsigned long int being at least from 0 to 4294967295 is true as well."
C_Programming,39q2lf,FUZxxl,2,Sun Jun 14 07:40:39 2015 UTC,"That's true, only it isn't portable. That is specific to my system by way of concrete example. Apologies that I wasn't explicit about that.  Had sizeof(unsigned long) == 8, I would be asking if it was guaranteed to accept values 0 to 264 - 1."
C_Programming,39q2lf,BigPeteB,3,Sun Jun 14 11:18:38 2015 UTC,"Had sizeof(unsigned long) == 8, I would be asking if it was guaranteed to accept values 0 to 264 - 1.   Yeah, that assumption is wrong. In general, the only assumptions about primitive types you can make are those specified by the standard."
C_Programming,39q2lf,Aransentin,1 point,Sun Jun 14 12:01:11 2015 UTC,Why would you not want to use the C99 int32_t types? They're much easier to work with and guarantee exactly the portability you want.
C_Programming,39q2lf,dumsubfilter,3,Mon Jun 15 21:02:32 2015 UTC,"Am I guaranteed that I can assign the values 0 to (232 -1) to x?   No. The C89 standard states that UINT_MAX must be equal or larger than 65535, nothing more.  For example, the Burroughs BLS architecture from the sixties had 6-byte integers of 8-bits each, but UINT_MAX was 239 as some bits were used for padding and internal flags. You won't realistically run into such a system today, though."
C_Programming,39q2lf,Rhomboid,1 point,Sat Jun 13 17:48:19 2015 UTC,No one bothers to point him at limits.h?  randomlink https://en.wikibooks.org/wiki/C_Programming/C_Reference/limits.h
C_Programming,39q2lf,dumsubfilter,2,Sun Jun 14 02:23:21 2015 UTC,"That page is very misleading, in particular the ""typical values"" column should not be presented in the same table as the standard requirements, as if it was authoritative.  For example 64 bit Windows, which uses the LLP64 memory model, has 32 bit longs and LONG_MAX is 232-1, not the value suggested there of a ""typical"" 64 bit compiler."
C_Programming,39q2lf,sindisil,1 point,Sun Jun 14 10:56:21 2015 UTC,"That random page might be misleading, but the standard isn't.  My point was that there is a header file that covers everything he's looking for."
C_Programming,39jqev,kayamon,7,Fri Jun 12 05:19:45 2015 UTC,I do wish the judges of the Underhanded C contest would actually publish the source code for the whole entries.  It seems really stupid to have a contest and then not properly show off the winners and runners up.
C_Programming,39jqev,dream_in_code,6,Fri Jun 12 06:35:43 2015 UTC,This was a great read. I'm glad the author mentioned how running this in debug vs release would make a difference. I've seen so many little bugs creep up in release that are not able to be reproduced in debug due to this type of oversight.
C_Programming,39jqev,sepehrhm,3,Fri Jun 12 16:14:16 2015 UTC,"Can someone elaborate this trick a bit more?  I didn't get why the timestamp of filter_data would be corrupted, if it contains a re-used memory location."
C_Programming,39jqev,sepehrhm,3,Fri Jun 12 14:39:52 2015 UTC,"Because the size of filter_data.buffer is too small, when the code that fills it copies data into it, it copies one more byte than it should have.  The bytes it's copying in happen to come from reused memory, so what happens is we get one extra byte copied from that reused memory and splatted over the time stamp."
C_Programming,39lkdj,tmtwd,8,Fri Jun 12 16:11:10 2015 UTC,"You are printing the address of the pointer itself, not the thing it points to, which is what stays the same.  The pointer itself is passed by value, so a copy is always made.  C does NOT have any form pass-by-reference semantics.  Every argument is always passed by value, including pointers."
C_Programming,39lkdj,Rhomboid,1 point,Fri Jun 12 16:16:59 2015 UTC,"so, the pointer is copied to a new pointer, but the value to which it is pointing stays the same?  but when we have:  int a = 21; int * b = &a; int * c = b;   b and c share the same address I believe"
C_Programming,39lkdj,Rhomboid,10,Fri Jun 12 16:33:27 2015 UTC,"No, they point to the same thing but they are two separate variables that have different addresses."
C_Programming,39lkdj,Wiggledan,1 point,Fri Jun 12 16:40:58 2015 UTC,"oh, wow, I did not know that, thank you :)"
C_Programming,39lkdj,bames53,2,Fri Jun 12 16:51:48 2015 UTC,"Every variable has a location in memory, and that location is a simple number. Pointers are just variables which hold memory addresses (as simple numbers) of other variables.  Idk if you already wrapped your head around pointers or not, but it helped me a lot to think of them as ""memory address variables"""
C_Programming,39iyd7,optionallycrazy,3,Fri Jun 12 01:19:23 2015 UTC,Is it Compressed Image File Formats by John Milano?
C_Programming,39iyd7,jhaluska,2,Fri Jun 12 02:51:27 2015 UTC,Oh nice but I think it was a little earlier than that. Like 93 time early. Let me look more into it tonight to see if there was an early edition. Thanks.
C_Programming,39iyd7,jhaluska,1 point,Fri Jun 12 11:03:58 2015 UTC,"I realized the year probably didn't match up, but sometimes we misremember details."
C_Programming,39iyd7,zenkibudo,3,Fri Jun 12 15:39:46 2015 UTC,Yep probably so. However I'd imagine a 99 book wouldn't have windows 3.1 as the platform. I'm still looking. I could probably locate it if I can somehow get similar books.  Thanks again for looking into this.
C_Programming,39iyd7,zenkibudo,2,Fri Jun 12 22:35:37 2015 UTC,"Oh man, I think i know this one!   Author was Steve Rimmer or something like that....  let me do a search ...back soon...  EDIT: Yea, (based on 1. fun read and 2. covers many formats) I think you may mean Steve Rimmer's 'Bitmapped Graphics'     That's not the cover I remember, but that's the book -- covers Gif, BMP... all the main ones known in that era.  I used to have it, and from it I 1st learned Gif encoding/decoding.   He had a kinda bizarre and fun writing style that not everyone liked -- ""the code doesn't fit the text"" my friend complained(lol).  But we both agreed it was an outstanding code source in its day.     EDIT2:  I think this was the version I had.     But this one may be better."
C_Programming,39iyd7,zenkibudo,2,Mon Jun 15 23:19:36 2015 UTC,"Yep, yep, yep! You got it, man. Did the cover look like this: http://s.ecrater.com/stores/9409/4d8bba36aad2e_9409f.jpg ?? I did a google search for that cover and that is exactly what I remembered. Unfortunately I can't read the cover. But is that the cover you remember too?"
C_Programming,39iyd7,zenkibudo,1 point,Mon Jun 15 23:37:26 2015 UTC,"I blew up that Gif and it says ""Windows BitMapped Graphics"".     Steve Rimmer definitely had a book by that name, but I have been unable to confirm that the cover in your image matches any version (after a short net search)"
C_Programming,39iyd7,zenkibudo,2,Mon Jun 15 23:48:44 2015 UTC,Yep just ordered it from Amazon! I'm pretty sure this is it though I can't find a more detailed cover of it like the one I shown above. Thanks a lot for your help! I knew someone had to know! I can't believe I picked this up at a bargain bookstore and somehow it got lost. I think I threw it away by accident.
C_Programming,39iyd7,OldWolf2,1 point,Mon Jun 15 23:45:25 2015 UTC,"Quick -- cancel that and order his Windows BitMapped Graphics.  lol -- well it's cheap, you could get both i reckon  EDIT -- thanks for the gold!!!!!! you are too kind!!!"
C_Programming,39hi2u,iwanttowatchyoupoop,23,Thu Jun 11 19:19:38 2015 UTC,"No. Its a bad idea. Uninitialized memory is not random, just unknown.  There are much better ways of getting memory that is closer to random."
C_Programming,39hi2u,haplo_and_dogs,18,Thu Jun 11 19:31:37 2015 UTC,"Sure, it's quite a bad idea, but it happens. Debian OpenSSL, for example, reads uninitialized memory for extra entropy. It caused a pretty well-known security bug back in 2008, too: link."
C_Programming,39hi2u,Aransentin,13,Thu Jun 11 19:27:15 2015 UTC,"Despite people commonly saying that uninitialized variables contain random values, they aren't actually all that random.  All pages that you get from the operating system are always zeroed, so it's not like you're going to be seeing bytes from some past run or from some other program.  If your program is deterministic then the uninitialized data will also be deterministic (modulo things like address space layout randomization.)  That said, the technique was used in OpenSSL at one point.  There was a famous case in Debian about seven years ago where someone commented out a line that referenced uninitialized memory to shut up a static analysis tool without understanding the purpose of the code, leading to OpenSSL on Debian generating very weak and guessable keys for a period of approximately two years until it was discovered.  It was a very embarrassing situation.  In any case, you should absolutely not do this in any code you write.  Use a quality PRNG seeded from /dev/urandom (Unix) or CryptGenRandom() (Windows).  Don't try to make up some scheme on your own."
C_Programming,39hi2u,Rhomboid,5,Thu Jun 11 19:40:59 2015 UTC,That depends on the platform.  In post-16bit windows or unix-like this may be true.  In embedded (no os) this is not necessarily true.
C_Programming,39hi2u,EkriirkE,2,Thu Jun 11 20:57:31 2015 UTC,"Agreed.  Back in the Windows 3.1 era, uninitialized memory in DOS provided a pretty interesting way to get 'somewhat' random variable, for mild amuzement only.    Drawbacks included always getting the same number in a session, but a new variable the next day, whathaveyou."
C_Programming,39hi2u,zenkibudo,2,Fri Jun 12 05:47:00 2015 UTC,OpenSSL did that but they made a huge effort to make it at least pseudo-random by using many other non-deterministic sources when using that memory.
C_Programming,39hi2u,StenSoft,6,Thu Jun 11 22:52:53 2015 UTC,"It's not a good source, because often uninitialized memory often has predictable values. It could work as an additional source of entropy, where it's mixed with some other sources in such a way that it doesn't hurt the entropy and might help. However, this is bad idea for two reasons:   Attackers may be able to control the uninitialized memory and set it such that it eliminates the randomness from the other sources. In most languages, accessing uninitialized memory is not safe or well defined. Doing so can produce strange results. There have been serious bugs in production code caused by doing exactly this.    In short, just don’t use uninitialized memory for more randomness."
C_Programming,39hi2u,bames53,5,Thu Jun 11 20:16:30 2015 UTC,"...would it work for non-security-related random number generation?   Yup, it would. But there are better, faster, and more reliable ways of getting random numbers than having to read in large swaths of uninitialized memory, which is why you don't see it used!"
C_Programming,39hi2u,angdev,1 point,Thu Jun 11 23:03:08 2015 UTC,Great link -- didn't know about that  Xorshift  - thanks!!!!
C_Programming,39hi2u,zenkibudo,3,Fri Jun 12 06:37:56 2015 UTC,"Here's the two fastest one's, I created both myself using George Marsaglia's original paper. These one's use his triples that have the least amount of bit shifts:  Period 232-1  static uint32_t y; void init_xorshift32(uint32_t seed) {     y = 2463534242;     if (seed) y ^= seed; } uint32_t xorshift32(void) {     y ^= (y << 1);     y ^= (y >> 3);     y ^= (y << 10);     return y; }   Period 264-1  static uint64_t y; void init_xorshift64(uint64_t seed) {     y = 0x139408DCBBF7A44;     if (seed) y ^= seed; } uint64_t xorshift64(void) {     y ^= (y << 3);     y ^= (y >> 1);     y ^= (y << 11);     return y; }   And the largest one he provides an example for has period 2160-1. It takes a 32-bit seed and returns a 32-bit value, but you can easily make it use 64-bit values instead. Although it returns v it could return any of those variables to the exact same effect, plus any amount of them can be combined in a function to return a random number (say return a 64-bit number of period 2160-1).  static uint32_t x, y, z, w, v; void init_xorshift160(uint32_t seed) {     x = 123456789;     y = 362436069;     z = 521288629;     w = 88675123;     v = 5783321;     if (seed) x ^= seed; } uint32_t xorshift160(void) {     uint32_t t;     t = x ^ (x >> 2);     x = y;     y = z;     z = w;     w = v;     v = (v ^ (v >> 4)) ^ (t ^ (t >> 1));     return v; }"
C_Programming,39hi2u,angdev,2,Fri Jun 12 20:30:29 2015 UTC,"Very cool!!  Thanks again man -- I can't wait to try this out... there goes the weekend, lol"
C_Programming,39hi2u,zenkibudo,2,Sat Jun 13 04:31:06 2015 UTC,No.  From what I've seen in uninitialized memory it seems to be somewhat predictable for each execution.
C_Programming,39hi2u,thrakkerzog,2,Thu Jun 11 19:23:23 2015 UTC,"As others have noted, it's very bad idea in general.  Is it ever OK to do it?  The question to ask is this: What bad things will happen to your application if you got the same ""random"" number every time?  Edit: clarity"
C_Programming,39hi2u,mythicalmammoth,2,Fri Jun 12 02:34:48 2015 UTC,"Time to share my mostly complete port of Oracle-Java-random-number-generation-library-to-C code with you guys.  Oracle was kind enough to make its Java random number generation logic public.  Hence, the port to C was a short walk.    Why it's nice: you can generate some really big random numbers with this lib.  C standard library has historically been limited to 15 bits.   I don't pretend to know all about testing for quality of randomness, but I do know how to test for even distribution, and results were sweet in that department; no anomalies found yet.    Usage:  Just call setSeed() first ... kind of like you would using C standard library srand() - I do this:  setSeed(time(NULL));      .. and then call whatever function suits your need -- ie:    myRandInt = nextInt();    Been waiting for the next post on random number generation in /r/C_Programming/ to share this -- please enjoy and thank Oracle.  (:"
C_Programming,39hi2u,zenkibudo,2,Fri Jun 12 06:04:59 2015 UTC,"No, it's not random at all. Sometimes it will be 0 (many programs 0 out memory) and sometimes you'll get a number that's something like 3.8e38, which is the maximum number a float takes. That's what I get almost every time I forget to initialize variables."
C_Programming,39hi2u,McMalloc,2,Sat Jun 13 06:32:31 2015 UTC,No.  It's a stunningly bad idea.  Many CRTs and some CPUs zero that memory for you.  The distribution is bad.  It can be periodic.  It can be the same every boot.  Et cetera.
C_Programming,39imy7,Davidecan,4,Thu Jun 11 23:49:21 2015 UTC,"In printf, try x,y,answer instead of &x,&y,&answer"
C_Programming,39imy7,ponyoink,1 point,Fri Jun 12 00:03:19 2015 UTC,"It didn't work, it looks like its something wrong with the values declared"
C_Programming,39imy7,ponyoink,2,Fri Jun 12 00:13:57 2015 UTC,Post your input [and output].  Also format the code in your post properly.
C_Programming,39imy7,squiresuzuki,3,Fri Jun 12 00:16:36 2015 UTC,"First of all, please edit your post so that the formatting isn't all messed up. It's hard to read.  You're supplying pointers to givemepower, but your parameters are just doubles. Also, result is a double, so givemepower has to return a double. Either change your givemepower function to something like this:  double givemepower(double *base, double *power) {     return pow(*base, *power); }   Or preferably, just use this printf instead (and just change the return type of givemepower):  printf(""The result of %f^%f is %f"", x, y, answer);"
C_Programming,39imy7,jijijijim,2,Fri Jun 12 00:33:44 2015 UTC,"Sorry for the unorganized post, I edited it. I made the changes and it didn't give me the right value, but I found the problem to be the %f in the scanf command (it is supposed to be %lf, silly me)  Thanks for your help!"
C_Programming,39imy7,mythicalmammoth,1 point,Fri Jun 12 04:16:55 2015 UTC,"This is the sort of question that makes me crazy.  Put a printf after scanf are x and y ok? Are they ok in in the function. Printf is free. Add a few and figure out what is wrong.  How do you think we learned to program before the Internet?  Oh yeah, and hey kids get off my lawn..."
C_Programming,39imy7,-lowrez-,1 point,Fri Jun 12 00:26:46 2015 UTC,"Also, the return value of givemepower() should be double, not int. Otherwise, the result will be truncated to INT_MAX (I think?) and the fractional part lost.  Actually, I'm not sure what happens when you try to convert a double > INT_MAX to an int.  Also, what compiler are you using and with what flags?  I'm surprised that it doesn't spit out a warning about the printf specifier not matching the argument types.  If you're using any kind of Unix, you should always give -Wall to your compiler!"
C_Programming,39imy7,FUZxxl,1 point,Fri Jun 12 02:51:34 2015 UTC,"Sorry for the unorganized post, I edited it. My compiler is Dev-C++ running on a windows. I found the problem to be the %f in the scanf command (it is supposed to be %lf, silly me)  Thanks for your help!"
C_Programming,39eq5d,duelistgamer,3,Thu Jun 11 06:04:11 2015 UTC,"Why are you even bothering with fp?  Just use stdin  sizeof( char ) will always equal one.  stdin is line buffered, you shouldn't really be using fread on it."
C_Programming,39eq5d,dumsubfilter,1 point,Thu Jun 11 06:42:39 2015 UTC,"Because directly using stdin wasn't working, so I just tried that.   Skipping the file pointer declaration *fp and directly freading stdin didn't work."
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 13:04:06 2015 UTC,Do you #include the header stdio.h?
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 16:55:06 2015 UTC,"No I mean the program worked exactly the same way. Of course I included stdio.h (lol).  Also, http://www.reddit.com/r/C_Programming/comments/39eq5d/fread_problems/cs32zov"
C_Programming,39eq5d,irve,-4,Thu Jun 11 17:14:59 2015 UTC,"stdin is line buffered, you shouldn't really be using fread on it.   That's not the reason. The reason why you shouldn't use fread on stdin is that stdin is a text stream and fread is for binary streams.  EDIT: It appears I'm wrong. fread and fwrite map to fgetc and fputc, there is no reason why these should not work on a byte-oriented stream. They don't work (behaviour is undefined) on wide-character streams. Notice that the C standard does not guarantee that textual streams represent arbitrary data without loss of information, so you should really use binary streams for binary data."
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 07:43:22 2015 UTC,"And could you explain how on earth is a text stream different from a binary one? It's just numbers all the way down.  There's some weirdness with Windows and binary streams if you open files without the binary option, but the OP seems to be using some *nix."
C_Programming,39eq5d,irve,3,Thu Jun 11 08:59:41 2015 UTC,"On UNIX there is no difference between these two. On other plarforms, there might be. Examples are Windows where text streams have \r\n translated into \n or some ancient platforms were text streams are line-orientef instead of character oriented."
C_Programming,39eq5d,dijumx,2,Thu Jun 11 09:33:46 2015 UTC,I am confused since your code worked for me. What are the system specifics?
C_Programming,39eq5d,dijumx,1 point,Thu Jun 11 09:16:56 2015 UTC,I'm SSH'ing to a x64 Ubuntu system.
C_Programming,39eq5d,BigPeteB,1 point,Thu Jun 11 13:04:12 2015 UTC,"It looks like you are trying to pipe the output from the program into a file.  Have you checked this file for the output you are expecting?  Also, the operator for piping stdout to a file is > not >|. This might be why you are not seeing what you expect. Does your program work without the piping? (i.e. a.out -wlc arg1 arg2 arg3 on it's own)"
C_Programming,39eq5d,SlayterDev,1 point,Thu Jun 11 09:53:49 2015 UTC,"Sorry, I'm using >| not |"
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 13:03:06 2015 UTC,"Yes I realised that. You should use > to write stdout to a file, and | to pass stdout of one program to stdin of another program.  What happens if you do not use the piping? Do you get an output?"
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 14:22:44 2015 UTC,I get the same output as I would to the file except this time it would be in the terminal console instead of the piped output text file.
C_Programming,39eq5d,mythicalmammoth,1 point,Thu Jun 11 15:07:41 2015 UTC,"Nevermind, I'm an idiot. I realized that when I'm running the program, the pointer to stdin is expecting fresh input. What I wanted to do was get the same string that gets passed to argv as arguments."
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 15:08:05 2015 UTC,"Also, >| is actually the same as > except it forces the shell to overwrite the existing text file which > cannot."
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 15:10:07 2015 UTC,"Had to look this up, since I've never seen it. They're only different if the noclobber option is set, which it isn't by default. So for most people, > does the same thing as >|.  http://www.gnu.org/software/bash/manual/html_node/Redirections.html#Redirecting-Output"
C_Programming,39eq5d,FUZxxl,1 point,Thu Jun 11 19:21:05 2015 UTC,It's probably because of how my university has set up our accounts. I haven't really configured the scripts to suit my preferences.
C_Programming,39eli5,DuhYerrowBatman,7,Thu Jun 11 05:24:50 2015 UTC,"Similar to the concept in Javascript, functions are used to define invokable units of code. main is an example of a function, and others are declared in a similar fashion:  void forward(int msecs) {     motor[motorB] = msecs;     motor[motorC] = msecs;     wait1Msec(msecs); }   Unlike Javascript, a function must declare its return type (in this case, void, meaning no return value), and arguments (in this case, one argument of type int). Also unlike Javascript, a function must be defined before it is called. The following is invalid, for example:  int main() {     forward(100); } void forward(int msecs) {     ... }   Of course, there are a lot more options (and rules) beyond this intro, but hopefully this will help get you started."
C_Programming,39eli5,5HT-2a,4,Thu Jun 11 05:40:56 2015 UTC,"Wow. Thank you so much! However, being the nuisance I am, I will continue to bombard you with questions. 1. How do you write in code like that on reddit? 2.What if I want to have 2 variable-integers in the function? would it go like: void forward(int msecs, power1, power2) {     motor[motorB] = power1;     motor[motorC] = power2;     wait1Msec(msecs); } ? Finally, I would simply call on the command as:forward(100, 75, 75); or something of the like? Again, thank you so much for putting up with me!"
C_Programming,39eli5,5HT-2a,5,Thu Jun 11 06:01:41 2015 UTC,"On reddit, indent each line in a block of code with an extra four spaces. Enclose inline keywords with backticks `like this`.  One thing you will need to get used to in C is that typing is very strict, and must be defined for every value you work with. Your example would need to be modified to define the power1 and power2 parameters as int types:  void forward(int msecs, int power1, int power2)   You would then be able to call it as you describe."
C_Programming,39eli5,dmc_2930,3,Thu Jun 11 06:13:58 2015 UTC,Thank you so much!
C_Programming,39eli5,dmc_2930,7,Thu Jun 11 07:31:32 2015 UTC,"OP, I think you need to get a good book on C that will explain all this, or at least take some free online courses.  It's a very basic question that you shouldn't need to ask - it indicates that you haven't done enough learning just yet.  There are several online C courses that are free and tailored for beginners."
C_Programming,39eli5,dumsubfilter,2,Thu Jun 11 14:21:47 2015 UTC,"I definitely agree that it was probably wrong to post here, and that I have yet to do much learning. Apologies for that. However, I simply need a quick fix for a problem that I have been unable to troubleshoot by simply googling(namely because I didn't know the name of what I was looking for). I plan on dedicating more time to C as soon as Finals are done. Thank you for your tolerance!"
C_Programming,39eli5,Steve_the_Scout,4,Thu Jun 11 14:54:48 2015 UTC,"We were all beginners once, and there's nothing wrong with that.  I just wanted to suggest that a book might make it easier for you than stumbling around not knowing how to get started.  Just about any introductory book on C would be helpful for you. Good luck!"
C_Programming,39eli5,dumsubfilter,1 point,Thu Jun 11 14:58:23 2015 UTC,"Yes, I am definitely planning on getting one after I get through the free resources. Thank you!"
C_Programming,39eli5,FUZxxl,2,Thu Jun 11 15:03:01 2015 UTC,"Since the correct answer is already given (just call the function), here are some other fun ideas?     Make a finite state machine.  switch( state ) {     case foo:     {     }     ... }   Then just change the state each time you want to do something.  Optionally store 'previous state' and after you jump, switch back.     More entertainingly, liberal use of goto should do the trick.        edit: user = use"
C_Programming,39eli5,Steve_the_Scout,-1,Thu Jun 11 16:40:36 2015 UTC,"More entertainingly, liberal user of goto should do the trick   GAH. Don't actually use goto liberally, it's something to use very infrequently. It messes up the code flow unless you know exactly what you're doing and only have more complicated ways to achieve the same thing (do { ... if(cond) break; ... } while(0);, for example)."
C_Programming,39eli5,EkriirkE,2,Thu Jun 11 16:49:09 2015 UTC,"When the correct answer has already been given, the only things that remain are the answers for the sake of entertainment.  It's the whole reason ioccc exists."
C_Programming,39eli5,haagch,1 point,Thu Jun 11 16:59:51 2015 UTC,goto can be used to enhance program structure. Some times it's just the right tool for the job.
C_Programming,39eli5,dmc_2930,1 point,Thu Jun 18 13:14:57 2015 UTC,"Oh I definitely agree 100%, but liberal use of goto implies using it where it doesn't fit best just because it could work there. I could definitely see it being used e.g. to ""escape"" code only run once if you can't return at that point, the alternative being to write a unique function just for that little block of code so you can avoid goto or a bunch of nested if-elses, or a do { ... if(cond) break; ... } while(0); block which makes no logical sense. But using goto for what the OP was looking for would be insane, essentially re-inventing function calls if that would even be possible for C."
C_Programming,39eli5,haagch,1 point,Thu Jun 18 15:24:45 2015 UTC,"Since this appears it may be timing sensitive, why not use a macro?  It'll put the code inline as if you pasted it each time thus minimising function overhead at the expense of code size:  #define forward100ms do{motor[motorB] = 100; motor[motorC] = 100; wait1Msec(100);}while(0)   And call a s you mentioned   //code //code forward100ms; //code   If you want to use parameters, you can do that, too  #define forward(ms) do{motor[motorB] = 100; motor[motorC] = 100; wait1Msec(ms);}while(0)   And call as forward(100); The parameter names are treated like search and replace, not variables, so if you did forward(1+2+3); since we named parameter 1 ms , the compiler is actually replacing all instances of ms with literally 1+2+3 for that #definition"
C_Programming,39eli5,jotux,2,Thu Jun 11 07:20:38 2015 UTC,"Why not simply inline it?  inline int f(int n){n = n + 2; return n;}   Or if you really want to be sure,   __attribute__((always_inline)) void foo() { //some code }"
C_Programming,39eli5,EkriirkE,2,Thu Jun 11 09:08:15 2015 UTC,"Or let the compiler decide what to do with the function.  There's no need to even inline something like this. Just define it as a normal function.  Pro tip: Lots of compilers completely ignore the 'inline' keyword. It's just a hint and not required to do anything. Similar to the 'register' keyword, which is also often ignored by the compiler."
C_Programming,39eli5,dmc_2930,4,Thu Jun 11 14:20:14 2015 UTC,"But my premature optimization!?!   By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function's code into the code for its callers. This makes execution faster by eliminating the function-call overhead;   Even if it is ignored, it looks like it can be useful for diagnostic output as to whether it was inlined:   Using -Winline warns when a function marked inline could not be substituted, and gives the reason for the failure.   It's fun, because there are so many different hints and attributes. How about force_inline? That one broke xf86-video-intel on gcc 5.1  https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65873  http://cgit.freedesktop.org/xorg/driver/xf86-video-intel/commit/?id=9b9643171359194478ab9f7126012b659d2ae7a1"
C_Programming,39eli5,MartenBE,1 point,Thu Jun 11 14:43:15 2015 UTC,"Method considered. However, the function seems easier. This may be more useful in another case than the one I am currently looking at. Thank you regardless!"
C_Programming,39eli5,EkriirkE,2,Thu Jun 11 14:52:24 2015 UTC,Don't do this.  Abusing the preprocessor is not a good suggestion to new programmers and even if this was timing sensitive an inline function would be the most correct answer.
C_Programming,39eli5,MartenBE,1 point,Thu Jun 11 16:49:03 2015 UTC,"Okay, thank you! But may I ask what the 'while(0)' for is in the first code?"
C_Programming,39eli5,EkriirkE,3,Thu Jun 11 07:33:04 2015 UTC,"This only pertains to macros (#define), not functions... Since its multiple statements you need to group them together for some instances, such as    If (true) forward(100); else something();   If foward was simply curly braces if would translate to   If (true) {motor[motorB] = 100; motor[motorC] = 100; wait1Msec(100);}; else something();   See that semicolon after the close curly? That breaks the if/else statement, so we do a hack, a dummy do loop which technically is wrapping multiple statements in a single statement block that if sees as 1 statement thus an end semicolon is harmless to an else  Without brackets its even worse:   If (true) motor[motorB] = 100; motor[motorC] = 100; wait1Msec(100); else something();   Only the first motor[... Bit is evaluated with if, and the rest always run with else completely detached from the if."
C_Programming,39eli5,dmc_2930,1 point,Thu Jun 11 07:50:31 2015 UTC,"OK, I understand now. Thank you for taking the time to explain to me!"
C_Programming,39eli5,EkriirkE,3,Thu Jun 11 14:46:47 2015 UTC,"Don't define it as a macro. Use a function, as others have said. There's absolutely nothing gained in this case by doing it the wrong way.  Make it simple. Make it easy to read. Use a function."
C_Programming,39eli5,MartenBE,1 point,Thu Jun 11 14:18:41 2015 UTC,"It does seem easier to read, I'll give you that."
C_Programming,39d2tc,arsh231,13,Wed Jun 10 23:18:14 2015 UTC,Why use two arrays? It sounds like one array of structures would work better for you.
C_Programming,39d2tc,Wetbung,2,Thu Jun 11 00:48:23 2015 UTC,I agree
C_Programming,39d2tc,atreayou,1 point,Thu Jun 11 04:06:45 2015 UTC,Definitely. This should help http://www.cprogramming.com/tutorial/c/lesson7.html
C_Programming,39d2tc,Dihydrogen_Oxide,6,Thu Jun 11 23:34:53 2015 UTC,You could just move both things whenever you move one.
C_Programming,397mwd,stymiee,5,Tue Jun 9 21:02:50 2015 UTC,GCC 4.9.2 is a bit more descriptive:   a label can only be part of a statement and a declaration is not a statement
C_Programming,397mwd,Jack126Guy,2,Tue Jun 9 22:39:39 2015 UTC,"Ha, post your SO thread to reddit for a bunch of free karma on SO"
C_Programming,397mwd,OldWolf2,1 point,Tue Jun 9 23:52:18 2015 UTC,TIL
C_Programming,397mwd,ibraim_gm,1 point,Wed Jun 10 10:41:49 2015 UTC,I rarely see it done but I wrap all of my case bodies in braces.  switch(stuff) {     case 1:     {         code...         break;     }     case 2:     {         code...         break;     } }   I think it's more visually consistent and makes scope easier to determine when you're skimming code.
C_Programming,397bnx,mekhai,8,Tue Jun 9 19:50:21 2015 UTC,What should people talk about in a C conference? It's not that there's cutting-edge research done in C. What you do find are UNIX or POSIX conferences; there they talk about the new APIs they designed and the new concepts they developed.
C_Programming,397bnx,FUZxxl,3,Tue Jun 9 21:02:12 2015 UTC,What should people talk about in a C conference?   The same shit they talk about at any conference? Cool shit they've done recently with C and workshops for less experienced coders.
C_Programming,397bnx,johnnybgoode,9,Tue Jun 9 21:51:51 2015 UTC,"I don't think the social coding movement has reached the kind of people who program in C for a living yet. Most people who work in C work in the industry, they do make neat software but it's not cool or hip in any imaginable way.  Remember, as opposed to C++, C is just a tool, not a religion. People tend to overestimate how little C programmers care about their language as opposed to programmers of languages that do conferences. There's just not really anything cool you can do in C you can't do in other languages as C has no peculiar features except for its stability and simplicity that set it off from other languages.  TL;DR: When C programmers make cool stuff, the last thing they attribute their cool stuff to is their language."
C_Programming,397bnx,FUZxxl,2,Tue Jun 9 21:55:43 2015 UTC,"I didn't downvote, but I will voice disagreement. I think in particular, there are cool applications of C that don't lend themselves well to other languages. It would be very interesting to see a presentation or attend a workshop on something like JPL's code for a space system, and I think most of the people that work in modern roles like that are just as aware of what's happening in the software world as the guy writing Angular code for Google up the coast."
C_Programming,397bnx,johnnybgoode,4,Tue Jun 9 22:47:13 2015 UTC,"It would be very interesting to see a presentation or attend a workshop on something like JPL's code for a space system,   These people usually do talk about their code and its design, but they don't talk about it from the perspective of the language, they talk about software design and the language is not really in the focus. Or have you ever seen a mason discuss the peculiarities of his trowel when he talks about a house he built?"
C_Programming,397bnx,FUZxxl,4,Tue Jun 9 22:55:38 2015 UTC,I actually think the analogy of a programming language being a building material makes more sense.
C_Programming,397bnx,astnbomb,5,Wed Jun 10 00:39:42 2015 UTC,"Other languages are either poorly designed, new, and/or used by people who are designers and not developers. These conferences are typically circle-jerks of ""new"" patterns of code people have ""invented"" to make their code look ""cooler"". I always viewed conferences as a way for the ""elites"" in the computer science industry to preach to us how we should all code their way since it's ""best"".  C is an incredibly small and simple language that has existed for an extremely long time. There is really nothing to talk about."
C_Programming,397bnx,angdev,11,Tue Jun 9 23:21:02 2015 UTC,"So basically ""C is the one true god, and anything that adds additional features is poorly designed because it isn't explained in K&R.""  Intel syntax master race."
C_Programming,397bnx,johnnybgoode,1 point,Tue Jun 9 23:54:01 2015 UTC,"Intel syntax master race.   Actually, I like AT&T-syntax more. Yes, we exist."
C_Programming,397bnx,FUZxxl,1 point,Wed Jun 10 08:36:59 2015 UTC,I downvoted your comment for supporting Satan's Syntax! :p
C_Programming,397bnx,angdev,0,Wed Jun 10 21:20:09 2015 UTC,"So basically ""C is the one true god, and anything that adds additional features is poorly designed because it isn't explained in K&R.""   There are lots of cool languages out there, but yes, most are poorly designed. Take JavaScript for example. It's own creators know it was poorly designed. That's why there are 6 versions of it with more planned. Java is the same as well. C has had almost no changes since it's invention, mostly small syntaxual ones. Sure the standard library has had some updates over the decades and what have you, but those are not language changes."
C_Programming,397bnx,angdev,3,Wed Jun 10 00:10:37 2015 UTC,"have ""invented"" to make their code look ""cooler"". I always viewed conferences as a way for the ""elites"" in the computer science industry to preach to us how we should all code their way since it's ""best"". C is an incredibly small and simple language that has existed for an extremely long time. There is really nothing to talk about.   Dude C is used in most hardware platforms and new hardware is developed everyday, how would there be nothing to talk about? Especially with the new IoT trend going on right now. You're not going to put fucking Java or Python on a dedicated controller for real time data processing of sensors or to control some motors."
C_Programming,397bnx,kurozaki31,1 point,Wed Jun 10 09:27:13 2015 UTC,"Then those would be Hardware Conferences wouldn't they? C has nothing to do with hardware, it's a software language. I know what C is used for, I have been programming C and assembler daily since around 1995."
C_Programming,397bnx,angdev,1 point,Wed Jun 10 21:26:08 2015 UTC,C has nothing to do with hardware   Major facepalm.
C_Programming,397bnx,kurozaki31,1 point,Wed Jun 10 22:20:09 2015 UTC,Explain.
C_Programming,397bnx,angdev,1 point,Wed Jun 10 22:24:51 2015 UTC,"C is the language of choice to write device drivers and stuff like that. It's very useful for direct interaction with hardware and firmware programming, too."
C_Programming,397bnx,FUZxxl,1 point,Wed Jun 10 22:53:32 2015 UTC,Sure. So how does that translate into a software conference about the C language?
C_Programming,397bnx,angdev,2,Wed Jun 10 22:58:40 2015 UTC,That was not the question; the question was “explain (/u/kurozaki31's comment).”
C_Programming,397bnx,FUZxxl,-1,Wed Jun 10 23:04:56 2015 UTC,"""Simple"" ... lol"
C_Programming,397bnx,Lobreeze,1 point,Wed Jun 10 00:39:38 2015 UTC,The only complex thing about C is figuring out what is undefined behaviour and what is allowed.
C_Programming,397bnx,FUZxxl,1 point,Wed Jun 10 11:31:50 2015 UTC,"Getting a rough grasp of what is undefined is easy, but there are many details most people (including me some times) get wrong."
C_Programming,397bnx,FUZxxl,1 point,Wed Jun 10 22:54:15 2015 UTC,Eh?
C_Programming,397bnx,wiktor_b,8,Thu Jun 11 13:48:46 2015 UTC,"As a long time C programmer who is now stuck programming in Python, I find the entire mentality of having a language conference appalling: it's destined to be an echo-chamber of fanboys. Programming languages are serious business; their design and usage should be the subject of thoughtful and thorough research. Their modifications should be the output of contemplative and rigorous standards-body work. It's not sexy or fast, but the results speak for themselves. If you want an example of the narcissistic shit that these conferences lend themselves to, here's the author of Python summarily rejecting the inclusion of a switch statement in his language based on a straw poll during his keynote at the annual python conference. It makes me vomit in my mouth when I think about it.    tl;dr: you don't need a conference; you need a reference manual. If the language needs a conference, it's a negative reflection on the language."
C_Programming,397bnx,bunkoRtist,1 point,Thu Jun 11 13:52:44 2015 UTC,What is your preferred C reference manual?  Googling it gave a few different choices. I've always seen good reviews of Harbison and Steele.
C_Programming,397bnx,spaz_naz,2,Wed Jun 10 06:26:02 2015 UTC,"I'm sorry to say I don't have a great answer to this. Oddly, I learned C++ in HS and later C in college, so I went backwards and didn't really learn from a book. My biggest problems are usually with GCC/target-specific stuff, which means I go to the GCC reference manual or library manpages (there are actually manpages for most of the stdlib/posix functions... type ""man pthread_create"" or ""man printf"", it works!)."
C_Programming,397bnx,bunkoRtist,1 point,Wed Jun 10 05:42:13 2015 UTC,"If you want to work in a portable manner, consider installing the POSIX man pages which contain documentation about what the functions should do, as opposed to what they actually do."
C_Programming,397bnx,FUZxxl,1 point,Wed Jun 10 05:53:10 2015 UTC,"Kernighan & Ritchie is the preferred C reference manual. It's a little outdated; they should really add some of the C99 and C11 stuff, but it's not that important either."
C_Programming,397bnx,FUZxxl,8,Wed Jun 10 06:02:35 2015 UTC,"yes i understand that the language is mature and that its a small language. but saying only poorly designed programming languages have conferences and all the people there are narcissists, its just ridiculous.  why im interested in conferences is because even though you might have 1-2 narcissists you still have 10-20 other speakers that showcase a new way of thinking of a problem or just a set of tools that might help you. take the sanitizers in clang as an example. i would never have found them(or at least very late) if it wasnt for a conference.  either way, saying we dont need to share because we are a small and mature language its like saying that skateboarding was perfected in the 80s. we have always been defined by the same set of rules but its sparks of genius that feed other sparks of genius to do great things."
C_Programming,397bnx,iDinduMuffin,1 point,Fri Jun 12 09:32:28 2015 UTC,You might find something like this in a hyped up embedded device conference
C_Programming,397bnx,xsqr,-5,Wed Jun 10 08:39:08 2015 UTC,I'd hope not
C_Programming,396a3j,somedudeperson,15,Tue Jun 9 15:44:27 2015 UTC,"What a C programmer should know about memory. Modern C to work your way to more advanced topics. Handmade Hero (in C++, but written like C) to see a real application being developed. Learn the basics assembly programming and how to interface it with C (calling conventions, etc.). Use a disassembler to study what your compiler emits. Learn how to use threading, and, more importantly, how thread synchronization works. Learn how to leverage function pointers.   Sorry, I don't have a links for all of these, since I don't know where you'd learn it online."
C_Programming,396a3j,skeeto,10,Tue Jun 9 18:33:46 2015 UTC,"I would say, just get your feet wet. Try programming a simple user-space client/server pair using the sockets API. Have the client send a text message to the server, and then have the server send the message back, except all in uppercase."
C_Programming,396a3j,mythicalmammoth,1 point,Tue Jun 9 16:05:01 2015 UTC,do a network tic-tac-toe game
C_Programming,393ckm,lobocode,3,Mon Jun 8 23:28:36 2015 UTC,The only time is when I used it to design a hierarchical state machine for a pretty complicated system.  The machine diagram translated nicely into the boost::statechart library. I know that's c++ but there are c statechart libraries as well.
C_Programming,393ckm,goose_on_fire,3,Tue Jun 9 01:46:42 2015 UTC,"IMO creating a diagram in UMLis more complicated and time-consuming than just writing the goddamn code/pseudocode (just calling the functions, not necessarily implementing the functions).  On the other hand: UML is for users, as documentation of what is supposed to happen, and as a handholding for the implementor, but not necessarily to generate code.  CASE tools are very expensive, and the only use I've seen for them yet is to generate CRUD code from a database model."
C_Programming,393ckm,bart2019,2,Tue Jun 9 11:43:56 2015 UTC,"IMHO, UML is primarily for planning medium to large software projects in such a way that a large number of poor to mediocre indifferent code monkeys can be guided fill it out without doing too much damage to the whole. That's why you don't see it in open source, which is itch-driven."
C_Programming,393ckm,skeeto,2,Tue Jun 9 13:14:25 2015 UTC,I haven't seen a UML diagram since I left Uni. My impression was that it's only use is for the business higher-ups to put on slides to woo other business people. Of course none of them can actually read it but that's not the point.
C_Programming,393ckm,maep,1 point,Thu Jun 11 12:17:06 2015 UTC,"It's not really a C topic per se.  But yeah, I hear you.  (As an aside, I wish there were a subreddit for general programming discussion.  I might make one.)  Just as an anecdote, I've never actually used strict UML for any purpose whatsoever.  I've used pseudo-UML in flow charts and whatnot while prototyping and planning.  I've used it for homework assignments.  There's a standardized language definition for UML and I think that's actually kind of crazy.  I know that there are some code generation tools which you can use UML in conjunction with, but I don't know what they are, and I've never actually met a person that uses them.  I wouldn't mind using UML.  But most tools are shit.  The only one I've ever used and truly appreciated for diagramming was Microsoft Visio, but again, that wasn't really strict UML, it was just for object and logic diagrams and stuff."
C_Programming,393ckm,Zaemz,1 point,Mon Jun 8 23:35:40 2015 UTC,/r/programming is a reddit for discussion and news about computer programming   Am I missing something?
C_Programming,393ckm,Threesan,1 point,Tue Jun 9 03:00:55 2015 UTC,This is /r/C_Programming
C_Programming,393ckm,lsd_is_awesome,1 point,Tue Jun 9 03:09:01 2015 UTC,Can't open posting on /r/programming ( can only share links ) .
C_Programming,393ckm,bart2019,1 point,Tue Jun 9 03:54:35 2015 UTC,"Ooh.  Well, there's /r/coding, too.  Eh, no: same problem: no self posts."
C_Programming,393ckm,BlueGiant601,1 point,Tue Jun 9 11:38:38 2015 UTC,/r/coding is equal to /r/programming ( can only share links ).
C_Programming,3932pz,muktabh,3,Mon Jun 8 22:14:34 2015 UTC,"I've enjoyed Expert C Programming, 21st Century C, and Understanding and Using C Pointers."
C_Programming,3932pz,TheTIC,2,Mon Jun 8 23:37:06 2015 UTC,Expert C Programming: Deep C Secrets           Current $34.73 Amazon (New)   High $35.17 Amazon (New)   Low $27.78 Amazon (New)    $34.73 (30 Day Average)    Price History Chart and Sales Rank | FAQ
C_Programming,3932pz,PriceZombie,1 point,Mon Jun 8 23:37:25 2015 UTC,Thanks. I just checked and one of my friends has 21st century C. Will read this one soon.
C_Programming,3932pz,mythicalmammoth,3,Tue Jun 9 21:04:11 2015 UTC,"""Numerical Recipes in C"" for the matrix stuff"
C_Programming,3932pz,madwilliamflint,1 point,Tue Jun 9 15:54:03 2015 UTC,I love that damn book.  I've gone through a couple copies just wearing it out.
C_Programming,3932pz,WalrusTheSailor,1 point,Tue Jun 9 17:57:48 2015 UTC,Thanks.
C_Programming,392ya7,bioenggirl,2,Mon Jun 8 21:43:02 2015 UTC,dude you have to format your code..  add 4 spaces before each line
C_Programming,392ya7,benwaaaaaaaah,0,Mon Jun 8 21:53:54 2015 UTC,Whoops! Sorry! Its my first time on Reddit :(
C_Programming,392ya7,benwaaaaaaaah,2,Mon Jun 8 22:57:14 2015 UTC,No worries lol. Just go up and edit your post to familiarize yourself with the formatting.
C_Programming,392ya7,FUZxxl,1 point,Mon Jun 8 23:05:07 2015 UTC,"You can edit your posts after you wrote them, just click edit."
C_Programming,392ya7,WalrusTheSailor,2,Tue Jun 9 07:47:10 2015 UTC,"Formatted it, and tried making it slightly more readable as the question doesn't seem to be edited yet.  #include<stdio.h>  int cal1(int p, double q) {     int w = p - q / 4 (p % 5);      return w - 1; } double cal2(double t) {     int    i;     double tt = 0.0;      for (i = 1; i <= t; ++i) {         tt = tt + cal1(i, t);     }      return ttt; }  int main(void) {     printf(""%.4f\n"", cal2(4.0));      return 0; }   I haven't tried it, but 4 (p % 5) shouldn't compile. And, where does ttt come from when you return it?"
C_Programming,392ya7,WalrusTheSailor,1 point,Mon Jun 8 22:52:58 2015 UTC,Thank you for formatting it! It should be return(tt*t). Im sorry! Its my first time using Reddit :P
C_Programming,392ya7,mythicalmammoth,2,Mon Jun 8 22:59:57 2015 UTC,No problem. Please edit your original post to include the right piece of code. Put some effort into the presentation of the post and people should be able to help you soon.
C_Programming,3932dg,rhascal,9,Mon Jun 8 22:12:03 2015 UTC,You can use a function pointer.
C_Programming,3932dg,Jack126Guy,1 point,Mon Jun 8 22:44:54 2015 UTC,Thanks!
C_Programming,3932dg,WalrusTheSailor,4,Mon Jun 8 23:05:58 2015 UTC,"I usually don't bother saying this, but please try Google first..."
C_Programming,3932dg,WalrusTheSailor,3,Mon Jun 8 22:48:51 2015 UTC,His answer was more direct ^  Search: https://www.google.com/webhp?sourceid=chrome-instant&rlz=1C1MSIM_enUS604US604&ion=1&espv=2&es_th=1&ie=UTF-8#q=function%20as%20a%20formal%20parameter%20c&es_th=1  Don't assume a noobie knows the correct search term or they might already know the answer.
C_Programming,38yw6u,lestofante,2,Mon Jun 8 00:37:27 2015 UTC,"If the header is the same but you need to link different libraries depending on the target, that's the makefile's job. If you need to include different-but-equivalent headers but for different targets, that should be done by including only the correct search paths, which is the job of the makefile. The only time I've seen something that looks like this done in the header (correctly) is when you need to write a unified header that builds on multiple hosts; has nothing to do with different targets and everything to do with differentiated hosts and toolchains."
C_Programming,38yw6u,bunkoRtist,2,Mon Jun 8 01:16:32 2015 UTC,"Thanks, I didn't think of a shared header, but seems a nice idea; it should work like an interface in OOP"
C_Programming,38yw6u,OldWolf2,2,Mon Jun 8 08:34:11 2015 UTC,"Definitely do it in the makefile. If your program includes two functions of the same name it causes undefined behaviour, which may lead to the wrong function being linked, or a link error, or code bloat, etc."
C_Programming,38yw6u,FUZxxl,1 point,Mon Jun 8 01:32:08 2015 UTC,The linker doesn't care about what header files you include. It doesn't even know! That's why when you link against a library you have to pass -lsomething to the linker command line. Some platforms (like Plan 9) have compiler extensions so the linker can figure out what library you want to use depending on the headers you include but that's not standard C.
C_Programming,38w7ah,ch1ck,3,Sun Jun 7 10:07:20 2015 UTC,"Can you show us the defective code? I highly suspect you made a programming mistake as there is nothing wrong with the string[i] syntax, which behaves equally to *(string + i)."
C_Programming,38w7ah,FUZxxl,3,Sun Jun 7 11:04:23 2015 UTC,"// anagram.c #include <stdio.h> #include <string.h>  int main () {     char F[40];     char S[40];     int i;     int sizeF;     int sizeS;      printf(""Enter first word: "");     scanf(""%s"", F);      printf(""Enter Second word: "");     scanf(""%s"", S);      sizeF = strlen(F);     sizeS = strlen(S);      for (i=0; i<sizeF; i++) {         printf(""%s\n"", *(F+0));     }      return 0; }   and into the terminal I had:  cd Documents  gcc -o anagram anagram.c  warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat]  ./anagram  Enter first word: Hello  Enter Second word: World  Segmentation fault (core dumped)  My code isn't even nearly finished, I also tested it without a for loop and just a printf statement but still doesnt work."
C_Programming,38w7ah,FUZxxl,6,Sun Jun 7 12:18:51 2015 UTC,Have you paid attention to the warning gcc gives you? Do you know what the compiler tries to tell you?
C_Programming,38w7ah,Rhomboid,1 point,Sun Jun 7 12:29:54 2015 UTC,"No, I'm only new to programming and I don't know what it means."
C_Programming,38w7ah,arhombus,3,Sun Jun 7 12:32:35 2015 UTC,changed it to %d...  wow  It has numbers now which will be good enough for what I'm doing but just for curiousity... How do I make it print individual letters instead of numbers?
C_Programming,38w7ah,F54280,9,Sun Jun 7 12:35:45 2015 UTC,"The %s format flag expects a pointer to a character, which is interpreted as the first character of a null-terminated string, i.e. it prints the character pointed to and all subsequent characters until the terminator is found.  You're trying to pass a single character (which gets promoted to an int due to the rules of variadic functions), not a pointer to a character, so that is why you get a segfault, as that character value is treated as a pointer which is then dereferenced, but it's a nonsense value that doesn't point to anywhere valid.  The %d format flag expects an int, which it converts to decimal and prints.  Due to the promotion rules, it works to pass a char instead of int, but you probably did not want that character value converted to a decimal.  The %c format flag expects a character (again promoted to int, but that doesn't matter here), and prints it as a character without any conversion to decimal.  It does not take a pointer, and therefore it cannot print anything but that single character.  If any of this was news to you, you need to find a trustworthy source of documentation about the C standard library.  These are the kind of things that a decent book should go over in detail.  You can't learn C by trial and error; it requires that you are willing to read reference documentation."
C_Programming,38w7ah,arhombus,2,Sun Jun 7 12:46:07 2015 UTC,That was a really good explanation! Thankyou :D
C_Programming,38w7ah,bart2019,2,Sun Jun 7 12:51:03 2015 UTC,"And to add on to what he said, there are no strings.  Strings do not exist.  A ""string"" is a sequential string (aka array) of chars in memory, ASCII encoded in binary, ending with a null byte (eight zeros in binary).  %s expects a pointer to a character, as Rhombold said.  That in the context of scanf or printf reads the memory, starting at the first character, and increments in 1 byte (the size of a char) until it reaches the null terminator.    That is a string.  There is no string, only a chars with a null terminator.  And this applies to ALL programming languages.  This is how the computer works.  No programming language has strings, they all have chars and they hide what they're actually doing in memory.  You can see this by creating a string and then seeing the memory address and value of each element in the array."
C_Programming,38w7ah,FUZxxl,2,Sun Jun 7 14:28:49 2015 UTC,"ending with a null byte (eight zeros in binary).   CHAR_BITS zeros, in binary... (C can work on non 8-bits-per-addressable-unit machines)"
C_Programming,38w7ah,raevnos,2,Sun Jun 7 19:02:09 2015 UTC,"Good point.  Anything else incorrect in what I said?  Please do correct me, I'm just learning this stuff."
C_Programming,38ux2z,NLKNguyen,17,Sun Jun 7 01:10:38 2015 UTC,"I'd guess it's because the most need for raw C is in infrastructure software, and Google (like everyone else) just reuses a lot what is available in Linux and OSS."
C_Programming,38ux2z,rcoacci,1 point,Sun Jun 7 01:40:24 2015 UTC,"Yeah, that makes sense."
C_Programming,38ux2z,cogburnd02,1 point,Sun Jun 7 16:23:19 2015 UTC,"What /u/rcoacci said, plus this:  The two people at Google most likely (IMO) to pick C as a project language (Rob Pike [of U.P.E.] and Ken Thomson [of ed]) helped invent Go, so they seem to tend to use (and work on) it instead. (They also helped to invent UTF-8, so we as the internet owe them a huge debt of thanks, too)  :-)"
C_Programming,38ux2z,dumael,7,Wed Jun 24 18:17:53 2015 UTC,"My perspective on the use of C over other languages is that while C is a good cross platform language, it's lowest common dominator material.   Java, Python are much high level languages which give greater programmer productivity, a very useful aspect for a software-as-a-service orientated company.  Secondly, what advantages are there in choosing C over Java, C++. For stuff like android, Java makes a lot of sense as android is to a large degree platform independent / platform details are abstracted away.  The choice between C and C++ can become even more ridiculous. Take GCC for example, it was a large open source C project which ended up having a home-brewed object system and garbage collection added in later. GCC has since moved to C++.  If you believe your C project is going to grow so large as to require reinventing language features from other languages and there is a language out there with them (C++), why not pick C++ from the start?  If you're going to pick C over C++, what precisely do you gain? Nothing. Virtually all valid C source is valid C++ source, and C and C++ are easy enough to mix in a project. You lose templates, generic algorithms etc.   Some of the complaints of C++ such as the abuse of operator overloading, exceptions are going to be handled through code review and coding standards rendering them pointless, since any large project is going to have code review+standards anyway.  TL;DR: Chose the right tool for the job. C is often not the right tool."
C_Programming,38ux2z,dumael,1 point,Sun Jun 7 15:53:25 2015 UTC,"Great answer. Thanks! I thought they do a lot of  kernel programming where C is strong there, but as other answer suggested, they probably use what's out there."
C_Programming,38ux2z,dumael,2,Sun Jun 7 16:08:25 2015 UTC,"One thing I didn't touch on was dealing with legacy issues. There's been occasional calls[1] for the linux kernel to be written in C++.   When you do have a large existing project written in C[2], the man-effort in ensuring that the transition to C++ doesn't break anything, decisions on use and acceptability of language features, developer knowledge of C++,  can be so much that staying with C is the correct socio-logical, productivity orientated decision.   Not necessarily the correct technological decision but the cost of changing is unjustifiable.  There's also personal bias in tool choice. Consider writing a OS kernel from scratch. Bill Gates back in the 90's has approached you and your kernel team[3], opened his wallet regarding salaries and cost of developing a new OS kernel, and is letting you run the show. All technical decisions are yours, the big-wigs just want results.  Between you and your team, you're clocking in a number of man decades in OS design. Your less worried about language choice, you want to build the best. You set out the architecture, how APIs should be designed, etc. You reach for a tool to write this and BOOM. You've picked C.   Was this a conscious choice? Were the benefits of language X over language Y weighed properly given (lack of) knowledge of language Y over X? If your developers are building a product, can they build it to last without major changes, i.e. without breaking backwards compatibility. Can they build this with their existing knowledge or with their relative lack of knowledge with language Y?  Or was this choice deliberate? You inspected the compilers, the language and came to the decision that C++ is the bad choice as microsoft's toolchain at the time was inferior to their C toolchain[4]. The code produced from use the advantageous language features is inferior. Overheads are unacceptable for other features. So C is the choice. Well, C++ could be choice, but the compiler team down the corridor is promising X/Y/Z that you need in a few months. Are you going to write an OS kernel against compiler features that don't exist? Technical decisions are yours, results are for the big-wigs who can be/are surprising technical.  So like the God of Abraham and Isaac you proclaim: ""THE KERNEL INTERFACES SHALL BE WRITTEN FOR THE STYLE OF C, ALL OTHER KERNEL INTERFACING LANGUAGES SHALL BE SECOND CLASS CITIZENS"". ""AS THE KERNEL INTERFACES ARE WRITTEN IN C, SO SHALL THE INTERNALS BE WRITTEN IN C."" An thus the tribes of hardware driver developers spake only C for fear of being branded heretics.  But, BeOS was written in C++, Apple's Mach kernel is partially written in C++.  The choice of language for low-level software is going to be informed by the writer's personal bias in language choice. Legacy software interface issues play a part (One of itaniums greatest contributions was as solid C++ ABI), toolchain issues play a part. Sometimes the ""lesser"" choice is correct, other times when toolchain, engineer, engineer productivity, API design align, C++ is the obvious superior choice. And for a lot of cases, today it is the superior choice.  (Aside, this post is mostly about C vs. C++)  [1] This is being stupidly generous in counting.   [2] Notionally, this can be applied to any project regarding language changes.  [3] I'm heavily paraphrasing, but to my knowledge, this is how the windows NT kernel was developed.  [4] Take this as fiction, I wish to illustrate the engineer's choice of ""use the superior tool, despite absolute inferior results today or use the inferior tool  and produce superior results today"". 10 Years later and MS don't support C99, but they do have a decent C++ toolchain."
C_Programming,38ux2z,Bonejob,1 point,Sun Jun 7 18:03:22 2015 UTC,"Very very informative and entertaining :) thanks a lot for sharing your thought. Just one more thing I want to ask from your experience, do you see/estimate a major shortage of C/C++ developers in a foreseeable future because everything else is easier and more attractive/practical to young developers and because schools are leaning toward Python (not even Java) ?"
C_Programming,38ux2z,Bonejob,1 point,Sun Jun 7 19:22:10 2015 UTC,"Admittedly, I'm going to be biased in my post but:  I don't for-see a shortage of C or C++ programmers ever. C is a relatively simple language, and its use as a teaching language is great as it can be used to illustrate a great many things about programming / computing.   Further: I honestly believe that any university course on programming, has to teach C to be called a programming language course. Why? Because many, many programming languages can be translated into C. Since C is so basic, nearly everything can be mapped onto what a processor does[1], so not teaching C could be seen as crippling a student.  C++ in a conventional style has everything of C but the solutions often differ in their style. You can impart the basics but the style notions differ, i.e. how data-structures are traversed, the notions of making sure your data-structures are STL compatible.  Yes, my university taught Java, like many others. But they also taught C and C++. I wish the lecturer for C and C++ had been more confident in teaching C++ so that I'd have a leg up there.  Fundamentally, I don't believe someone can call them-self a programmer if they cannot pick up a language by at least doing 'monkey-see, monkey-do' with another language along with reading a book or two on a language. Sure, their code might be crap but that can always be solved.  Do I see a potential shortage in C or C++ programmers? Nope. If you have a shortage of programmers for a language, you're talking of ""there is nobody/few people who can at least do monkey-see, monkey do in another language"". In that situation if you look out the window, it's probably a Mad Max / Fallout situation.  If you mention a shortage of professional programmers for language X, yeah, that I can understand. Because I'd describe someone as a professional $(LANGUAGE X) programmer when they know the language standard, knows common open-source  styles etc for that language. Expensive as you might expect.  To paraphrase Dijkstra, ""Computer Science is no more about computers than astronomy is about telescopes"", that is a programmer should be able to write binary search over a suitable data-structure.   TL;DR: A programming language is noise over the job at hand. But they can be still highly valuable.  [1] C has been described as portable assembler. In fact there is a language lower level than C which is not C, C-- which is even more explicit than C.  (Edit: extended the TL;DR)"
C_Programming,38ux2z,angdev,2,Sun Jun 7 20:30:23 2015 UTC,"Thank you, sir! :)"
C_Programming,38ux2z,grable,5,Sun Jun 7 20:55:42 2015 UTC,"I would argue that most of the programmers at google while being aware of C do not think about it first. The culture at Google lends itself by its nature to being a young crowd. C being an older language and not ""Hot"" means that it gets relegated to the bottom of the toolbox.  The primary language at Google is Python. They like to say it's C++ but only the primary low level stuff is C++ and most of those programs have Python  scripting or inclusion. For example the main search algorithm is a decentralized C++ stack, but the search interface controllers and parameterization is done in Python. When I have worked with their code and there people, Python is there goto language, driven mostly by the feeling that is is ""easier"", and maintainable. Since C does not fit into these categories well, it fails the ""Google"" test."
C_Programming,38ux2z,grable,1 point,Sun Jun 7 15:56:26 2015 UTC,"Wow, interesting, I'm surprised that Java is not their de facto language instead. But in your opinion,  is Python still ""hot"" now after all the years?"
C_Programming,38ux2z,OldWolf2,2,Sun Jun 7 16:22:14 2015 UTC,"The statement was method of comparison between C and Python. Python is much prefered over C for applications due to the amount of work required to turn out said application. O and lazy programmers :)  Read the rest if you want some other opinions :)  Most ""HOT"" projects are moving towards Javascript on Node/Meteor depending upon the programmer's preference. The unification of the front end and back end languages was a forgone conclusion when javascript was chosen as the language of choice for client side applications. I believe this will reach its ultimate conclusion and we will start to sway back towards having ""desktops"" again where the power is stored on the client and the backend becomes the preprocess/datastore. This will depend upon the march of bandwidth progression. We started writing internet applications as ""thin"" client becuase of the restrictions of communication capacity not processing power. As communication capacity grows we will couple of clients to our data more and more and the cycle will start again :)  I lived through the first cycle of this from Mini/Dumb terminals to Desktops, then onto thin client, and now we are starting to see things flow back towards the client via javascript. Being in a  browser does not matter BTW, the browser is just taking the role of the OS for interface concerns. Google made a smart choice with Chromebooks. That will be the cycle for the next 10 years as we migrate applications to our portable devices and we figure out how we as users will adapt the technology to our lives.  WOW, just read my Diatribe. I guess I needed to express myself this morning :) Sorry must be age getting to me :)"
C_Programming,38vab0,CProgrammingQuestion,6,Sun Jun 7 03:14:53 2015 UTC,"0x80000000 is a mask consisting of the most significant bit (MSB) of a 32 bit integer set and all other bits cleared.  Using with it bitwise-and is therefore checking if the MSB is set.  The loops keep left shifting the value, placing each bit of the desired fields (exponent and significand) into the MSB.  The loops then convert them to characters for display.  The same applies to 0x00400000, which is really a more stupid way of writing (1<<22).  When used with bitwise-and, it extracts the value of the 22nd bit, which is the uppermost bit of the fraction.  Again bit-shifting is used in the loop to extract all the other 23 bits of that field.  0x000000ff is a bitmask that selects the lower 8 bits of the value.  It's extracting the exponent field, which has been shifted right by 23 bits, putting the 8 bits of the field in the lowest position.  The mask is necessary to remove everything to the left of the exponent, which in this case is just the sign field, but since this person is using signed integers, all those bits will can 1s due to sign extension.    By the way, this code is pretty awful, and I wouldn't advise using it as a learning source.  A left shift on a signed integer with a negative value invokes undefined behavior, as does shifting a 1 into the MSB of a signed integer (i.e. going from positive to negative), and a right shift on a signed integer with a negative value invokes implementation-defined behavior.  All of the integer operations need to be done with unsigned integers.  And reading a member of a union that wasn't the last member written (i.e. writing to myFloat->f and then reading from myFloat->i) is also undefined behavior, but some compilers let you get away with it, but it's not a good idea to rely on that.  In any case, this code displays a complete lack of understanding of the rules of C."
C_Programming,38vab0,Rhomboid,4,Sun Jun 7 05:58:46 2015 UTC,"A 32-bit floating point number is stored in the following way in binary:  SEEE EEEE EFFF FFFF FFFF FFFF FFFF FFFF  where S represents the sign bit, EEEEEEEE is an 8-bit exponent, and FFFFFFFFFFFFFFFFFFFFFFF is a 23-bit fraction.  0x80000000 in binary is 1000 0000 0000 0000 0000 0000 0000 0000, or a mask for only the most significant bit in a 32-bit number. The first loop in initialize() skips the first bit (which stores the sign bit) and then checks the next high 8 bits for their value (it moves the bits to the left and then checks the new high bit) and saves the character '0' or '1' into binExp[] depending on what the bit is. Note that this corresponds to the exponent bits above. The second loop in initialize() then checks the remaining 23 bits and saves the characters into binFrac[].  0x00400000 in binary is 0000 0000 0100 0000 0000 0000 0000 0000. This is also a mask for the 9th significant bit in a 32-bit number. If you remember from above, the sign bit is the highest bit, then the next 8 are for the exponent (stored into binExp[] above). So the loop in createFraction() checks the highest bit of the 23 bit portion used for the fraction (stored into binFrac[] above) and then shifts left and keeps checking it.  0x000000ff in binary is 0000 0000 0000 0000 0000 0000 1111 1111. This is also a mask for the lowest-significant byte in a 32-bit number. This is used immediately after shifting the value to the right by 23. This will cut off the 23 bits of the fraction, leaving the 8 bits of the exponent in the lowest byte position. The mask will then retrieve only those 8 bits (necessary because the next highest bit is still the sign bit)."
C_Programming,38t040,masklinn,3,Sat Jun 6 15:45:50 2015 UTC,I can't really understand most of the code but that was really fun to read through!
C_Programming,38tsas,Comrade57,2,Sat Jun 6 19:25:30 2015 UTC,"This is done to organize programs when they grow larger. Generally large production projects are broken up into ""library targets"" which are pairs of header files and source files which handle a specific task (e.g. math.h and math.c) which are all used in a primary ""binary target"" which contains the main function and once compiled can be run by itself.  Writing everything in a single file will become incoherent for everything except the simplest programs, and it's hard for someone looking at a project written like this to find where certain tasks are done. In addition, because of this separation these modules can be compiled and tested individually; if one breaks they don't all break."
C_Programming,38tsas,roxven,2,Sat Jun 6 19:32:23 2015 UTC,"Also, many compilers support incremental compilation. You can modify one of many files and it will only compile what is necessary instead of the whole thing."
C_Programming,38tsas,f5f5f5f5f5f5f5f5f5f5,2,Sat Jun 6 22:23:34 2015 UTC,Can you name one of these many compilers?
C_Programming,38tsas,hroptatyr,2,Sun Jun 7 06:19:05 2015 UTC,"This is not a property of a compiler, but of the build system (make, etc..)."
C_Programming,38tsas,amstan,2,Sun Jun 7 06:23:41 2015 UTC,"It's not the compiler which supports incremental compilation, it's the build system. Programs like make were written for that exact purpose."
C_Programming,38tsas,FUZxxl,1 point,Sun Jun 7 10:53:26 2015 UTC,"Probably you would be using a build system in a case where that functionality is desirable, right?"
C_Programming,38tsas,roxven,0,Sat Jun 6 22:49:29 2015 UTC,You just tell it to compile the program and it figures it out.
C_Programming,38tsas,f5f5f5f5f5f5f5f5f5f5,1 point,Sat Jun 6 22:54:56 2015 UTC,"Right, but what I mean is, when is that setup desired versus the traditional choice of a build system?"
C_Programming,38tsas,roxven,0,Sat Jun 6 22:55:50 2015 UTC,When you have a lot of stuff to compile.
C_Programming,38tsas,f5f5f5f5f5f5f5f5f5f5,1 point,Sun Jun 7 00:19:07 2015 UTC,Do you know what a build system is?
C_Programming,38ua56,vidjuheffex,6,Sat Jun 6 21:51:09 2015 UTC,Microsoft and the C standard don't play very well together. Fire up a VM running Linux or a BSD and work in it.
C_Programming,38ua56,raevnos,4,Sun Jun 7 03:35:30 2015 UTC,"that %zu was a C99 feature,   It is a C99 feature.  It's just that when you're using MinGW, you're using Microsoft's C runtime (with a few enhancements) and Microsoft has for years thumbed their nose at C99, refusing to support anything but C90.  It's gotten better in recent years, as they've improved C99 support in VS2013, but all that stuff goes into only the latest versions of the runtime (e.g. MSVCR120.DLL) whereas MinGW targets the system runtime (MSVCRT.DLL) which is essentially set in stone and will never change.  (They do this because people want to be able to build completely standalone programs.  If they depended on a version of the runtime from VS, like MSVCR120.DLL, then people would have to tell their users to install the Visual Studio Runtime Redistributable package in order to be able to run MinGW-compiled programs, and people would hate that.  It's always a tradeoff.)  Defining that preprocessor value is a way of telling MinGW to replace the crappy Microsoft printf() implementation with one actually written by the MinGW people which is C99 conformant.  Of course, this bloats your executable size, because it's statically linked in (so that there's no MinGW DLL for programs to depend on) rather than using something that already exists in MSVCRT.DLL, so it's not enabled by default.  Again, there's always tradeoffs."
C_Programming,38ua56,Rhomboid,1 point,Sun Jun 7 06:26:54 2015 UTC,"Try using Pelles C IDE, it is tiny, free, and the (imo) best C IDE for Windows. It also comes with lots of tutorials, examples, and a good Help File! Also, what is %zu supposed to do? What are you trying to format/print?"
C_Programming,38ua56,angdev,3,Sat Jun 6 23:03:41 2015 UTC,%zu is the format specifier for size_t.
C_Programming,38ua56,zifyoip,1 point,Sat Jun 6 23:15:28 2015 UTC,But not on every platform apparently. Though that tidbit gets left out constantly.
C_Programming,38ua56,zifyoip,3,Sun Jun 7 00:35:58 2015 UTC,"Well, if you have a compiler and library that conform to the C99 standard, then %zu is the format specifier for size_t."
C_Programming,38ua56,_java_csharp_cpp_c,0,Sun Jun 7 07:48:21 2015 UTC,"You could open up a free account at Koding, which gives you a decent web-based IDE and access to an Ubuntu 14.04 VM with root access.  If you use my referral link, here, we both get 500MB extra space free on the VM."
C_Programming,38ua56,_java_csharp_cpp_c,1 point,Sun Jun 7 06:05:06 2015 UTC,"I installed Ubuntu to a Hyper-V VM. It's all good. I'm just curious why that flag isn't default. Seems like whatever gets you to the ""C Standard"" should be on, and you should have to actively deviate from the norm. I'll sign up so you get the referral though, no harm in that."
C_Programming,38sq5v,Shtreimel,3,Sat Jun 6 14:16:49 2015 UTC,"This question is slightly off-topic as it's about complexity analysis, not C programming, even though you use C syntax."
C_Programming,38sq5v,FUZxxl,2,Sat Jun 6 15:07:25 2015 UTC,This comment is also technically off-topic.
C_Programming,38sq5v,mephux,0,Sat Jun 6 16:17:57 2015 UTC,"You right, my bad.  I'll open this thread in a 'better fitting' subreddit, if still someone can help me here it woukd still be great."
C_Programming,38sq5v,FUZxxl,2,Sat Jun 6 16:25:48 2015 UTC,You might want to try in /r/compsci and /r/askcomputerscience.
C_Programming,38r7ya,jeffb415,1 point,Sat Jun 6 03:09:57 2015 UTC,Where is the function it_create defined?
C_Programming,38o679,jmprobert,1 point,Fri Jun 5 14:10:31 2015 UTC,I'll be here to answer any questions or comments you might have. Feedback is welcomed.
C_Programming,38o679,ibraim_gm,1 point,Fri Jun 5 14:16:47 2015 UTC,Cool. I'm looking forward to the results.
C_Programming,38o679,_predator_,1 point,Fri Jun 5 15:22:50 2015 UTC,Great! Looking forward to sharing them here.
C_Programming,38p4xl,tmtwd,12,Fri Jun 5 17:57:23 2015 UTC,"Yes, but the only guarantee is that the assignment happens before the increments. The order of the increments is undefined. (not that it matters in this case)"
C_Programming,38p4xl,grable,1 point,Fri Jun 5 18:34:12 2015 UTC,you mean for the second one?
C_Programming,38p4xl,grable,3,Sat Jun 6 21:35:21 2015 UTC,Yes..
C_Programming,38p4xl,ErnestHemroidway,6,Sat Jun 6 23:37:11 2015 UTC,"Even though the two code segments (I wouldn't call them statements. The first segment is actually three statements.) are semantically equivalent, I would advise against using the second. The very fact that you had to ask is a huge red flag. Although you now know the answer, anyone who reads your code will have to look this up, maybe even you if you come back after some time.  Besides, there is very little benefit to the second statement: writing shorter code rarely produces more efficient executables, and usually just makes your code more confusing to read."
C_Programming,38p4xl,blunaxela,4,Fri Jun 5 20:47:04 2015 UTC,except for the fact that this is idiomatic c code which you may see on even  your first day of programming with c.
C_Programming,38p4xl,beagle3,5,Fri Jun 5 21:05:15 2015 UTC,"I was a bit skeptical that it was really idiomatic C code, but I did a quick grep on the Linux kernel tree to satisfy my curiosity. I found around 220 occurences of the second form. So I would agree about being well aware of it, although you may chose not to incorporate it into your coding style."
C_Programming,38p4xl,dmc_2930,2,Sat Jun 6 04:16:21 2015 UTC,"It will have the same result only as long as ptr and s2 do not point to each other (if they do, e.g. ptr = &s2 or s2 = &ptr or something like that), then it is not guaranteed to have the same effect (might, might not)."
C_Programming,38p4xl,dajoli,1 point,Sat Jun 6 02:42:40 2015 UTC,"Yes, they are the same. Why wouldn't they be?"
C_Programming,38p4xl,dmc_2930,2,Fri Jun 5 20:29:48 2015 UTC,It would depend on the precedence of the * and ++ operators. *(ptr++) is quite different to (*ptr)++.
C_Programming,38ltsx,0x12345,35,Fri Jun 5 01:32:05 2015 UTC,"Not a C feature strictly speaking, but maybe it is... Depends on how you look at it.  C tends to put me in a mind set of writing simpler code. And I think it does that to other people too.  I also find C code easier to read (considering, of course, only the pieces of code I've looked at). I think that's because other people tend to do the above as well.  Anyway, this is a very subjective kind of thing. I can't really say that this is a feature of C. I believe this has more to do with how I program than anything. However, sometimes we forget to consider the kinds of ""moods"" different languages put us in, and I think this sort of issue affects me a lot."
C_Programming,38ltsx,phao,6,Fri Jun 5 03:17:56 2015 UTC,"This is a very good point which is hard to formulate precisely. I think it's the basic feature set of C that makes you think in very concrete terms which sometimes leads to good, simple code. And when thinking abstractly in C, you're thinking way beyond any particular language construct.  In contrast, in C++, just because it is possible to express some invariants (e.g. with inheritance, templates, etc) there's always a nagging feeling that you should do it properly. This can be great sometimes to catch certain errors early, but it's also possible that the assumed invariants are wrong and you end up throwing it all away (or more commonly, continue fighting and molding the problem domain to fit your type hierarchy)."
C_Programming,38ltsx,wild-pointer,5,Fri Jun 5 08:52:35 2015 UTC,"My thoughts exactly:   And when thinking abstractly in C, you're thinking way beyond any particular language construct.   I actually still remember the day when I had that realization."
C_Programming,38ltsx,phao,1 point,Fri Jun 5 12:59:18 2015 UTC,Please elaborate!
C_Programming,38ltsx,_RPM,2,Fri Jun 5 16:22:59 2015 UTC,"It's difficult to explain. I'm going to try, but lower your expectations. I bet much of it is wrong, and I also believe much of what I'm going to say is significantly personal. I find it very difficult to talk about why I prefer language X over language Y.  No feature of C on its own is exceptionally good. In other languages, that's not really true. For example, people love their templates and classes in C++. These standing out features have a reason to be so: they can be very good tools for problem solving. In C, you don't really have ""standing out features"" like that.  In C, then, to make something which is useful to your project, you have to find a way to combine these primitive building blocks of the language. However, this isn't about or unique to C, because even in languages with standing out features you still gotta do that.  The thing is that in C the building blocks you use are pretty general and primitive (some people call C a low level language because of that), and this allows you to implement a great deal of programming techniques (that doesn't mean it'll be easy to do so, however). And this goes back to what /u/wild-pointer said originally:   In contrast, in C++, just because it is possible to express some invariants (e.g. with inheritance, templates, etc) there's always a nagging feeling that you should do it properly. This can be great sometimes to catch certain errors early, but it's also possible that the assumed invariants are wrong and you end up throwing it all away (or more commonly, continue fighting and molding the problem domain to fit your type hierarchy).   So because the language offers you the means to an end, you feel inclined to use it. Even more so, you feel inclined to use it ""properly"" to avoid many the pitfalls involved while at the same time taking advantage of some extra benefits that are possible with a bit of an extra effort (as for example, taught in the several books on C++ good programming practices [Meyer's, Sutter's, Alexandrescu's, ...]). So you end up thinking about the problem ""just"" so you can fight to make it fit the solution the language gives you instead of thinking about the problem to come up with a fit solution (it won't be perfect, and it can end up being worse, but I believe it's possible to do better). If you ever have heard of the saying ""solution looking for a problem"", it's a fit in here.  And, just to be clear, this isn't to be confused with Turing Completeness. C Isn't ""more Turing complete"" or anything like that. Any computational problem you can solve with a C program, you can solve with any other general purpose language out there. I'm talking about the means C offers you to achieve that problem solution.  However, take all of this with care. Again, this is just a shot I'm giving a explaining what I think about languages, and I'm terrible at it."
C_Programming,38ltsx,phao,2,Fri Jun 5 17:56:20 2015 UTC,"Well put!  I mean, every now and then when writing in C I start to feel the pain and think that I could solve this or that in python, bash or awk (or any modern language) in two lines and start to wonder why I'm reinventing the wheel. C isn't always the right tool for the job, and that's fine. I feel that C isn't a language that should be used in isolation, and that it works great in combination with other languages.  I wouldn't write a GUI toolkit in C, but I might write the ""engine"" in C, which could then be configured with a DSL. Like others have said, almost any other language have ffi bindings to C, but often you don't even need that. Handle the interactive and asynchronous parts in a high level language, and run it as a separate process and communicate over a pipe."
C_Programming,38ltsx,wild-pointer,4,Fri Jun 5 18:41:07 2015 UTC,a.k.a. less features to muck things up. I completely agree.
C_Programming,38ltsx,chasesan,5,Fri Jun 5 15:19:17 2015 UTC,"simpler? I dare you, no... double-dare you, to start reading some C GTK code..."
C_Programming,38ltsx,zeroneo,4,Fri Jun 5 13:58:59 2015 UTC,"Sure, you're not the first one to tell me it's terrible. I imagine it is.  There are other C related stuff that have a bad reputation. For example, many GNU projects have an awful (afaik) source code. The one that I saw and remember disliking was bash.  I remember reading that the BSD and plan9 people despised GNU stuff a lot because of exactly that issue."
C_Programming,38ltsx,phao,1 point,Fri Jun 5 14:03:32 2015 UTC,"The GNU tools are wonderful from a user perspective, but, yeah, the code is usually a big, ugly mess."
C_Programming,38ltsx,skeeto,1 point,Fri Jun 5 19:08:59 2015 UTC,its the worst thing I have ever seen.
C_Programming,38ltsx,coloroftheskye,1 point,Fri Jun 5 16:03:46 2015 UTC,I've switched to vala for that stuff
C_Programming,38ltsx,benwaffle,24,Fri Jun 5 16:38:54 2015 UTC,Not casting returns from malloc (and other void *'s)
C_Programming,38ltsx,airuike,22,Fri Jun 5 02:21:49 2015 UTC,"No name mangling.  Looking at C code, you have IMHO a much better feel of what's really going on. C++ has stuff like operator overloading that means you have to learn the style of the specific library you are working with to a much greater degree than C. Just creating a new object on the stack can call a boatload of constructors which you aren't even aware of.  Having to look at errors from templated code is a pain. Small mistakes explode into pages and pages of unreadable junk."
C_Programming,38ltsx,Aransentin,13,Fri Jun 5 03:16:19 2015 UTC,"Easy interoperability with other languages. C is kind of a lowest common denominator, so no matter what language you're using, you can do FFI with C.  Edit: I mean C is the lowest common denominator for FFI, not that C is bad in any way for being the LCD."
C_Programming,38ltsx,GBGamer117,10,Fri Jun 5 02:40:36 2015 UTC,Designated initializers.
C_Programming,38ltsx,raevnos,11,Fri Jun 5 03:30:44 2015 UTC,printf. std::cout is such a joke.
C_Programming,38ltsx,maep,2,Fri Jun 5 06:49:15 2015 UTC,"Can't you use printf in C++? What's the supposed benefits of std::cout? I haven't written much c++ code, I tend to use either C or Java and don't really have a use for a language in the middle."
C_Programming,38ltsx,hutcho66,4,Fri Jun 5 11:39:21 2015 UTC,"From what I've read, C++ streams are supposed to be both type safe and (statically) customizable, which you can't say about printf and friends (I don't know about Java stuff though).  If you have a good C compiler, like I imagine most C coders do, you'll be warned of a bad printf call (in which the format string and the types don't match), but if you don't then you won't and UB will start creeping into your code. Also, you can't really customize printf to print your own types.  You can make ostream instances (e.g. std::cout) work with your own types by overloading the << operator taking an ostream& and your type. This lets you customize ostream instances to work with your own types in a static way (e.g. non late binding, non dynamic, at compile time, not at runtime, ...). You can even throw templates in the middle.  Since invoking the << operator on an ostream is just a regular type checked function call, you also get type safety.  Those 2 properties, afaik, are major motivations behind the streams stuff in C++.  If you want those properties or not is another story. Bjarne thought they were worth having and gave his attempt to satisfy them in an I/O set of facilities.  Personally, I'd like the type safety, but the customization (in the way provided by streams) I don't find that important. I rely on the compiler to tell me about bad printf calls, which is not as good as ""real type safety"", but it's often good enough."
C_Programming,38ltsx,phao,18,Fri Jun 5 14:18:24 2015 UTC,"The complete lack of C++ streams! Sorry, but they're just retarded... There's a reason that C#, Obj-C, Java, etc. went a different way on that.  Also, C can be a lot easier to read and understand... Don't have to dig through 10 source files of something that's all abstracted to hell, just to see how something is done. I do prefer OOP though, just not the over-abstraction insanity that some people use it for."
C_Programming,38ltsx,WestonP,4,Fri Jun 5 03:25:27 2015 UTC,"Agreed, at first I kept trying to use IOStream for opening files but it was such a pain in the ass I just used the FILE mechanism (I'm not sure what this is officially called) and it's a whole lot easier to use."
C_Programming,38ltsx,1337Gandalf,7,Fri Jun 5 05:04:32 2015 UTC,"I mostly agree with you but   There's a reason that C#, Obj-C, Java, etc. went a different way on that.   and   I do prefer OOP though, just not the over-abstraction insanity that some people use it for.   don't seem to work very well together. If any language community has ever taken OOP, fetishized it, and ran with it well past the point of self-parody, it's Java. Anyone for a new BufferedReader(new InputStreamReader(new FileInputStream(new FileReader(...))))? Here's a convenient AbstractThingReadingFactoryBuilderFactoryFileReaderThing to create one for you."
C_Programming,38ltsx,deong,0,Fri Jun 5 11:12:37 2015 UTC,"FileReader is meant for reading streams of characters. For reading streams of raw bytes, consider using a FileInputStream."
C_Programming,38ltsx,benwaffle,2,Fri Jun 5 16:40:41 2015 UTC,"I do prefer OOP though, just not the over-abstraction insanity that some people use it for.   I also prefer OOP thats why i write C with ""Classes"" with _new and _free for each one, not sure if its a good way to write correct C code but it works for me."
C_Programming,38ltsx,afonso360,1 point,Fri Jun 5 09:00:26 2015 UTC,"Yeah, I think a lot of us have come to write a modular style of C, using struct pointers to hold the ""object"", and related functions that work on it, taking it as the first param. The more unique benefits of OOP are things like inheritance and templates... When used well, they can really save a lot of nearly redundant code and clutter, and offer some nice capabilities too. I find that much more useful when writing libraries than when writing applications, though."
C_Programming,38ltsx,WestonP,4,Fri Jun 5 09:31:17 2015 UTC,"Templates don't really have anything to do with OO. Classes are one part of the C++ type system that can be parameterized, but they're no more special than functions or structs (which are just classes anyway) in that regard."
C_Programming,38ltsx,deong,-1,Fri Jun 5 11:15:43 2015 UTC,"Also, C can be a lot easier to read and understand... Don't have to dig through 10 source files of something that's all abstracted to hell, just to see how something is done.   The point of abstractions is that you don't have to see how something is done to read and understand the code using it.  Do you pop open the Linux/glibc source to read and understand code that uses fork?"
C_Programming,38ltsx,Drainedsoul,4,Fri Jun 5 07:52:21 2015 UTC,"Like I said (and you conveniently excluded from the quote), people going nuts with over-abstraction is the problem."
C_Programming,38ltsx,WestonP,6,Fri Jun 5 09:10:42 2015 UTC,"Do you pop open the Linux/glibc source to read and understand code that uses fork?   The nice thing about fork() is that very good documentation about how exactly it works exists. The same thing cannot be said about most abstractions people program in their own code. Using a well-established standard function is one thing, reading code that uses custom abstractions with spotty documentation and idiosyncratic behaviour is another."
C_Programming,38ltsx,FUZxxl,2,Fri Jun 5 13:19:23 2015 UTC,"In which case documentation and code quality seem like the issues, not the abstraction."
C_Programming,38ltsx,Drainedsoul,2,Fri Jun 5 15:07:22 2015 UTC,Code with less abstraction usually doesn't have the problem that you have to wade through layers of abstraction to find out where a certain artifact comes from.
C_Programming,38ltsx,FUZxxl,1 point,Fri Jun 5 15:11:00 2015 UTC,"It's just verbose, filled with repetitive boilerplate, and more error prone.   I'm not sure that's better."
C_Programming,38ltsx,Drainedsoul,3,Fri Jun 5 15:40:18 2015 UTC,If you think C code is full of boilerplate then you are doing it wrong. In fact my experience is that C code has less boilerplate than Java or C++ code as there are less useless layers of abstraction.
C_Programming,38ltsx,FUZxxl,1 point,Fri Jun 5 16:09:30 2015 UTC,"If you think C code is full of boilerplate then you are doing it wrong.   Checking the return values of functions is ""doing it wrong""?  Structuring the code to ensure clean up gets called is ""doing it wrong""?  These are both things that are eliminated by C++'s abstractions."
C_Programming,38ltsx,Drainedsoul,1 point,Sat Jun 6 01:16:05 2015 UTC,"Checking the return values of functions is ""doing it wrong""?   I don't see how that's boilerplate. Outside of trivial examples, my code usually reacts differently to many possible errors. I think exceptions are misused in C++ and Java because the way they are used encourages the programmer to sweep errors under the rug and not deal with them in a sensible manner. In the BASIC days it was ON ERROR RESUME NEXT, today it's just passing through all received exceptions, crashing the application if the slightest thing goes wrong.   Structuring the code to ensure clean up gets called is ""doing it wrong""?   You are right that it requires discipline to free your resources in C but destructors aren't a very good solution in my opinion because they hide behaviour from the user. When you destroy an object in C++, it's hard to know exactly what happened as the destructor may do arbitrary things. I prefer to have deallocation be a dumb operation, requiring me to call a cleanup function instead when I need to clean things up.  There are indeed ways to improve clean-up boilerplate, for instance, I believe Go's defer statements are very useful and versatile but because C lacks an exception system, I don't see how they can be accurately ported over to C as they wouldn't run when you jump over them with setjmp and longjmp."
C_Programming,38ltsx,FUZxxl,1 point,Sat Jun 6 10:40:06 2015 UTC,I'll assume you've read this: http://www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html
C_Programming,38ltsx,DownloadReddit,0,Tue Jun 9 07:13:10 2015 UTC,You don't have to use iostreams; stdio works perfectly well in C++.  Of course this is assuming you don't want the i18n that streams offer.  There are also numerous third party libraries for text streaming and formatting with i18n.
C_Programming,38ltsx,OldWolf2,3,Fri Jun 5 03:51:14 2015 UTC,What? i18n is way harder with iostreams than with stdio...
C_Programming,38ltsx,zuurr,2,Fri Jun 5 05:07:22 2015 UTC,"Yes, that's obvious, and what many people do. The problem is when you deal with other people's code that uses iostream nonsense."
C_Programming,38ltsx,WestonP,-1,Fri Jun 5 04:24:07 2015 UTC,"There are certainly bad abstractions, but I've never been convinced there's such a thing as too much abstraction. Some of the worst abstractions are deep, but so are some of the best."
C_Programming,38ltsx,agrif,5,Fri Jun 5 15:45:37 2015 UTC,Variable length arrays.
C_Programming,38ltsx,skeeto,-6,Fri Jun 5 02:44:19 2015 UTC,That's a feature of C++ and not C... In C you either declare a larger array that you need or use malloc and realloc... C++ has vector etc.
C_Programming,38ltsx,hutcho66,4,Fri Jun 5 11:40:58 2015 UTC,This has nothing to do with malloc() and such. I'm talking about the C99 feature where automatic storage duration array sizes can be chosen at run time. It's a block-scoped version of alloca() (and much more!).
C_Programming,38ltsx,skeeto,1 point,Fri Jun 5 11:47:20 2015 UTC,"Variable-length array:       In computer programming, a variable-length array (or VLA) is an array data structure of automatic storage duration whose length is determined at run time (instead of at compile time).   Programming languages that support VLAs include Ada, Algol 68 (for non-flexible rows), APL, C99 (although subsequently relegated in C11 to a conditional feature which implementations are not required to support;    on some platforms, could be implemented previously with alloca() or similar functions) and C# (as unsafe-mode stack-allocated arrays), COBOL, Fortran 90, J.     Interesting: Ch (computer programming) | List of data structures   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,38ltsx,autowikibot,6,Fri Jun 5 11:47:28 2015 UTC,C++ does not have VLAs. It's a C99 feature that so far hasn't been accepted into C++.
C_Programming,38ltsx,bames53,1 point,Fri Jun 5 17:06:55 2015 UTC,"Huh, TIL. I was taught ANSI C in school and have just been using that (I'm not working in programming or anything, I'm an elec. eng student).   Is there a need for them in C++ though? I understand std::vector is an object and hence allocated on the heap, would there be a noticeable difference having variable length arrays on the stack?"
C_Programming,38ltsx,hutcho66,2,Sat Jun 6 11:41:35 2015 UTC,"Yes, there are sometimes reasons to want to put things on the stack, but it's true that vector is sufficient for the majority of uses of VLAs.  VLAs also have some problems so the C++ committee has been resistant to them, but some work has been going on to address the need for stack allocation. For example, see dynarray."
C_Programming,38ltsx,bames53,4,Sat Jun 6 15:28:24 2015 UTC,"C has less features than C++, but because it has less features, I don't have to worry about using those features being used (by me or some library).  That is to say there are less things to muck up your desire to keep things simple and efficient."
C_Programming,38ltsx,chasesan,3,Fri Jun 5 15:23:22 2015 UTC,Recursively calling main
C_Programming,38ltsx,imnotcam,2,Fri Jun 5 01:50:32 2015 UTC,Is there any practical use for that?
C_Programming,38ltsx,raevnos,14,Fri Jun 5 03:30:00 2015 UTC,IOCCC entries of course
C_Programming,38ltsx,OldWolf2,1 point,Fri Jun 5 03:54:13 2015 UTC,"Bonus points if ""main"" is some const array or something wacky that gets dropped into .text and still does this."
C_Programming,38ltsx,Hellenas,1 point,Fri Jun 5 11:58:00 2015 UTC,the only one
C_Programming,38ltsx,MacASM,3,Fri Jun 5 17:07:10 2015 UTC,"Multi-call binaries: You can fork() and then call main instead of exec() to get some effects that are hard to do otherwise. The same thing could also be done with setjmp and longjmp, but where's the fun in that?"
C_Programming,38lkxs,PokeMaverick,6,Fri Jun 5 00:27:55 2015 UTC,"The most common way is to pass a pointer to a buffer into the function and have  it write into that. For example:  char *func(char *buf, size_t len) {     strncpy(buf, ""the string to return"", len);     buf[len-1] = '\0'; // strncpy doesn't guarantee null termination      // returning the pointer is optional, but many of the standard     // library functions do this to make chaining calls together easier     return buf; }   Another common way is to have the function allocate memory for the string and  return that. For example:  char *func(void) {     char* str = malloc(64); // note: make sure to allocate enough     strcpy(str, ""the string to return"");     return str; }   The second function is nice as it allows you to return strings of any length  while the first function is limited to the size of the passed in buffer. Care  must be taken, though, to make sure that any allocated memory is later freed.  If all you want is to return a constant string literal you can do it like so:  const char *func(void) {     return ""this is a string literal""; }   Just make sure you don't try to modify or free this pointer. (Note the const on the return value.)"
C_Programming,38lkxs,zomgreddit0r,3,Fri Jun 5 01:23:51 2015 UTC,The benefit of doing the first way is that the caller decides the allocation strategy.
C_Programming,38lkxs,f5f5f5f5f5f5f5f5f5f5,6,Fri Jun 5 15:45:37 2015 UTC,"There are 3 possible ways I have, in decreasing order of preference:   Pass a pointer to a string buffer and a length as parameters to your function, use those to return your string (using strncpy to make sure you don't overflow your buffer). Allocate the returned string using malloc and have the caller be responsible for freeing it. Return a pointer to a static buffer. This is the least preferred option as it is not thread-safe."
C_Programming,38lkxs,Nirenjan,3,Fri Jun 5 01:10:06 2015 UTC,"Return a pointer to a static buffer. This is the least preferred option as it is not thread-safe.    In C11 you can use static _Thread_local char buf[BUF_SIZE]. But I think nobody should do that unless there is a damn good reason.   edit: damn reddit, changing my numbers. how do I get it to stop doing that?"
C_Programming,38lkxs,maep,1 point,Fri Jun 5 08:02:58 2015 UTC,"I didn't know about _Thread_local. Time for me to read up on the new C standards. Thanks.  For formatting, I think you can prefix with a backslash, and it will prevent the markdown formatter from overriding the numbers. Eg.   \3. Return a pointer...   Edit: Turns out the backslash should be right before the period.   3. Return a pointer..."
C_Programming,38lkxs,Nirenjan,2,Fri Jun 5 16:45:04 2015 UTC,"For point one, are you meaning a pointer to a pointer, and to allocate into that space?  (Basically making malloc over again.)  char *foo; myfun( &foo, 10 );  ... void myfun ( char **ps, size_t len ) {     *ps = malloc( len ); }   Or passing it an already allocated block, and then using the length to fill it, effectively making your own strncpy?  char buf[ BUFSIZ ]; myfun( buf, BUFSIZ );  ... void myfun( char *b, size_t len ) {     for( size_t i = 0; i < len; i++ )         b[ i ] = 'a' + (len % 26); // do stuff }   Your wording is odd."
C_Programming,38lkxs,dumsubfilter,4,Fri Jun 5 01:28:40 2015 UTC,"He means your second example. A slight enhancement to this is to have the function provide a second out parameter that can be used to inform the caller how much memory is needed. For example:  void myfun( char * b, size_t len, size_t * len_needed ) {     // Store len characters of the answer in *b     // If len_needed != NULL, store number of characters needed for a full answer in *len_needed }   This allows the caller to choose how the buffer gets allocated. E.g. the caller could use a statically sized buffer allocated on the stack:  // Only need so many characters in this use case. char s[MAX_LEN]; myfun(s, MAX_LEN, NULL);   Or a dynamically allocated heap buffer, completely managed by the caller:  int len_needed; char * b; myfun(NULL, 0, &len_needed); b = (char *) malloc(len_needed); myfun(b, len_needed, NULL); ... free(b);   The choice is left to the caller.  Note, though, that this kind of usage assumes calling the function is on the cheap side. (Or at least that there's a fast path through the function when called with a 0 input length.)"
C_Programming,38lkxs,nemotux,2,Fri Jun 5 02:31:20 2015 UTC,"That second example is terrible.  Why would you ever want to do two calls to the same function to populate you string?  That's just the worst design I've seen.  You'd be better off returning it while you've allocated it:  b = myfun( NULL, 0 );   You wouldn't care about the length of it, so the third argument is pointless.  If you needed it, you'd just run strlen on it."
C_Programming,38lkxs,dumsubfilter,2,Fri Jun 5 03:40:25 2015 UTC,Having myfun() allocate the buffer is explicitly avoided by the approach - and for good reason. It means management of memory isn't shared by two separate modules. That makes tracking down memory bugs easier. And there's nothing that says the first call to myfun() has to actually construct the string - it just has to determine its length.
C_Programming,38lkxs,nemotux,2,Fri Jun 5 13:49:33 2015 UTC,"It still seems like a bad way to do it.  To calculate the length you'd pretty much be needing to run through the string once, or perform the same steps to actually construct it.  There's got to be a better way."
C_Programming,38lkxs,dumsubfilter,2,Fri Jun 5 18:15:59 2015 UTC,"Speed is not always the most important thing in your codebase. This particular pattern, I think, is useful when you're talking about designing an API between two distinct modules or when designing an API for arbitrary 3rd-party clients. In such environments, modularity and isolation of things like memory management often trump performance considerations. Because they make it more difficult to have confusing bugs that cross between modules (and between development teams). It all depends on the context."
C_Programming,38lkxs,nemotux,2,Fri Jun 5 18:30:48 2015 UTC,"I still don't like the third argument.  size_t myfun( char *b, size_t len ) {     if( b == NULL  ) // optionally len == 0         //calculate and return required length }"
C_Programming,38lkxs,dumsubfilter,2,Fri Jun 5 18:57:54 2015 UTC,"Another way is to have a string pool... It works much like #3, but can be thread safe and solves some other problems. Something like this:  #define StringPoolSize 64 #define StringPoolMaxChars 256     int StringPoolCounter = 0; char StringPoolBuffer[StringPoolSize][StringPoolMaxChars];  char * GetPooledString(void) {     char * String;      GetMutexLock(StringPoolMutex);      String = StringPoolBuffer[StringPoolCounter++];     if(StringPoolCounter >= StringPoolSize) StringPoolCounter = 0;      ReleaseMutexLock(StringPoolMutex);      return(String); }   You'd of course need to replace GetMutexLock()/ReleaseMutexLock() with your platform's mutex lock/unlock functions, and create a global init function to set it up.  This approach has some pitfalls and obvious drawbacks like any of the others, but the pool Size and MaxChars can be tweaked to better fit the intended use, so you don't have problems with it rolling over too soon, etc. I find that it's a good fit when you have code where you'd really rather just have C++'s std::string, but instead need to use C for whatever reason, and it doesn't make sense to have the calling function manage the memory. It should be used with care, however.  Strings have always felt like an afterthought in C, which might be the simple truth. I do enjoy being able to very simply and efficiently iterate through each char in a string, though. That process can be quite a bit heavier in some of the newer languages."
C_Programming,38lkxs,WestonP,2,Fri Jun 5 02:45:58 2015 UTC,"Adding some extra content... definitely don't do the following, it will get overwritten when you return and you try to call another function.  char *foo() {     char retbuf[20];     /* Do something */     return retbuf; }"
C_Programming,38lkxs,Nirenjan,5,Fri Jun 5 01:16:00 2015 UTC,"It's not even that, it's on the stack and will be destroyed as soon as the function ends, leaving your pointer pointing to an invalid memory location, potentially crashing your program as soon as you try to do anything with it.  Perhaps you meant to make retbuff static?"
C_Programming,38lkxs,dumsubfilter,2,Fri Jun 5 01:22:25 2015 UTC,Having retbuf static was my point #3 above. Thanks for giving a better explanation.
C_Programming,38lkxs,Nirenjan,1 point,Fri Jun 5 04:15:48 2015 UTC,"The fact that the pointer is placed on the stack won't make it invalid. The fact that, when popping a pointer from the stack (which happens when the current block ends) will free that pointer, will."
C_Programming,38lkxs,YoYoYonnY,1 point,Mon Jun 8 20:18:45 2015 UTC,"I know what you're trying to say, but the way you are saying it is wrong oddly worded.     retbuf is an array of characters, which are automatic, and local to the function foo.  When foo returns, that block of memory is no longer valid, also it may be overwritten by other function calls or what not.  Even if it is not, in trying to use the address returned to you by foo, you'll find it's pointing to an invalid block of memory, resulting in undefined behavior if you attempt to use it in any way.     It has nothing to do with freeing the pointer."
C_Programming,38lkxs,dumsubfilter,1 point,Tue Jun 9 06:31:15 2015 UTC,"I am a little confused on your first possible way. Some of these words are new to me. does this sound right?   create a char array as a buffer, then pass a pointer to that buffer array as well as the size into my function.   char * functionName (char * bufferArray, int bufferSize)  {        code  }   Then do I use strncpy to copy the string I want to return into the buffer like this?                strncpy(bufferArray, word, bufferSize);   and then finally return bufferArray? or would I return nothing?    return *bufferArray;   What I am trying to do is find a certain word in a string and if I find it, return it to compare that it is the correct word."
C_Programming,38lkxs,Nirenjan,2,Fri Jun 5 13:43:53 2015 UTC,"You're pretty much spot on - copy the string over to bufferArray.  As far as the return value is concerned, to use your example, how would the caller know if the word was found or not. You can go with any approach here.   Return the pointer to the string if the word was found, and NULL if it wasn't. Return an int value that has one value for ""found"" and another for ""not-found"".   The cool thing about C is that it does exactly what you tell it to do, nothing more and nothing less. That's also the disadvantage of C :)"
C_Programming,38lkxs,coloroftheskye,1 point,Fri Jun 5 16:41:57 2015 UTC,"It is for an Assignment and I am supposed to do it where I return a string and compare it with a ""literal string"" in a different function, otherwise I would normally just do it how you suggested above.   Thank you for your help, I think I understand this a lot more! have a good one."
C_Programming,38lkxs,Nirenjan,1 point,Fri Jun 5 16:51:42 2015 UTC,"is thread-safe as long as the static buffer is also const. Just have to be carefull   \e very cool edit that my ""3."" gets displayed as a 1.... when will the fucking retards learn that you should just fucking accept what I type..."
C_Programming,38lkxs,coloroftheskye,2,Fri Jun 5 18:36:29 2015 UTC,"No it's not thread safe... const doesn't mean that the variable is placed in read-only memory, it's simply an indication to the compiler that writes to the variable are not allowed. It's not thread safe in that another thread can wind up overwriting the buffer.  Let's take the following example, function foo converts the passed parameter (let's say an IP address) into a string and returns a pointer to a static buffer. Two functions bar and baz call foo with different values from different threads. If either thread gets pre-empted after the call to foo, but before the function can use the value, the buffer gets overwritten and you may not get the value that you expect.  static char foobuf[16]; // Enough for an IPv4 address (255.255.255.255) const char *foo(uint32_t ip) {     sprintf(foobuf, ""%d.%d.%d.%d"",             (ip >> 24) & 0xFF,             (ip >> 16) & 0xFF,             (ip >> 8) & 0xFF,             (ip >> 0) & 0xFF);     return foobuf; }  void bar() {     char *result;     uint32_t ip = 0x01020304; // 1.2.3.4      result = foo(ip);      // Preempted?     if (strcmp(result, ""1.2.3.4"") != 0) {         printf(""Mismatch!"");     } }  void baz() {     char *result;     uint32_t ip = 0x05060708; // 5.6.7.8      result = foo(ip);      // Preempted?     if (strcmp(result, ""5.6.7.8"") != 0) {         printf(""Mismatch!"");     } }   There's even a possibility in the above code that a thread gets preempted while in foo but right before the return. foobuf gets overwritten even before foo returns."
C_Programming,38iv1x,FrankMagecaster,6,Thu Jun 4 14:43:00 2015 UTC,"Pick any linux tool(that is written in C) and dig into it. The way C projects are structured is something you have to get used to.  Read the Linux Programming Interface. I cannot recommend this book enough.  And if you can think of a program that would be useful in your daily life, write it. Even if it turns out to be complete crap, it will give you experience and some reality to that C programming is like."
C_Programming,38iv1x,crisader,1 point,Thu Jun 4 15:29:34 2015 UTC,"Funny you mention that book, I bought it a few weeks ago and am about 50 pages into it! I had to take a break from it during exams but plan to dive back into it shortly."
C_Programming,38iv1x,bit_inquisition,7,Thu Jun 4 16:11:14 2015 UTC,"My .02 as a person who has been working with embedded devices and C for 10+ years:  This might sound counter-intuitive, but I'd say the first thing I look for in a candidate is not knowledge or experience with Arduino or any other SoC, but the ability to break down tasks into small components, and the ability to write clean C code. So I would recommend make your craft better first, then get experience.  Often, it's much easier to teach specific hardware or device concepts to a person than to teach them how to write clean code.  Your bare-bones OS would not be bad for your resume, of course, but I'd be more interested about what you learned during that project. For example, what you learned about interrupts. What properties can interrupts have and why would you prefer one method versus another? (For example, level-triggered vs. edge-triggered) What did you learn about interrupt handlers?  Especially as a new grad, I might even prefer you don't have any pre-conceived knowledge about hardware details. Some people can self-teach very well but some people learn all the wrong things without direction. Undoing that is a lot harder than starting from scratch."
C_Programming,38iv1x,tmtwd,1 point,Thu Jun 4 15:50:50 2015 UTC,"quick question. I am kind of having the opposite problem. I am by no means a competent C programmer, but I have a certificate in programming which included 2 C courses (not bird courses, maybe not too hard either), but now I am learning micro-controllers and stuff which involves C-code.  I am kind of thinking it would have been just as easy if I had started microcontrollers without any prior experience. Do you have any tips of getting better?"
C_Programming,38iv1x,bit_inquisition,1 point,Fri Jun 5 11:48:42 2015 UTC,"It really depends on which microcontroller you're working with and what area you are interested in. It doesn't help that a lot of the code that comes with a microcontroller from the vendors is poorly written.  Maybe there's a book somewhere that can teach some of the common concepts in a clear concise manner but I don't know any. Not a specific recommendation, but hardware concepts written by software or platform developers (like some of the docs in the linux kernel) are actually pretty good IMO.  Sorry I'm not being very useful but the state of the union in embedded is pretty weak in terms of formal education."
C_Programming,38iv1x,bit_inquisition,1 point,Fri Jun 5 15:13:54 2015 UTC,"I completely agree, clean code is a priority for me. My philosophy is I should be able to pick up any project that I have not worked on in months/years and be able to relearn its functionality quickly through documentation.  If I cannot do that I consider it a failure.  Even for school assignments that I will most likely never look at again, I'll always document every function, make a readme, keep my formatting consistent (and clean of course), and push it to my github.  As for the bare-bones OS, the entire purpose of the project would be the learning aspect.  Researching different methods to accomplish the same task is essentially my main goal so I can have a deeper understanding of not just how an OS as a whole works, but the pros/cons of different details within it.  Proper documentation of a large project like this is also something I'm trying to get out of it.  For learning hardware/device concepts, what would you recommend for self teaching the right way? Or should I put that on hold until some job trains me in it? I'm a decent self-learner but in most cases always like to have an experienced human resource."
C_Programming,38iv1x,Lisu,1 point,Thu Jun 4 16:30:42 2015 UTC,"For learning hardware/device concepts, what would you recommend for self teaching the right way?    I don't really know. Obviously some kind of a mentor thing would be good but how do you find a mentor who has the time to teach? Maybe someone else can answer that and I'd be interested in hearing the community's thoughts too.  Speaking of community, getting involved with embedded-oriented communities is probably a good way."
C_Programming,38iv1x,Poddster,1 point,Thu Jun 4 18:04:59 2015 UTC,How do you know what to comment/ how to comment? I just feel like I end up writing: this does this and this other thing does this other thing. The end.
C_Programming,38iv1x,r_smart,1 point,Fri Jun 5 00:42:17 2015 UTC,"I feel that way all the time haha. I'll always comment any function, even if it's trivial.  Depending on the length/logic in the function I'll explain a general overview of how it works in a way that can be understood by a beginner. If need be I'll put in some line comments within the function that explains conditional statements in English.  A good way to test your comments is have someone else look at your code and see if they understand. Or come back to it a few weeks later and see if you can pick it back up easily."
C_Programming,38iv1x,Poddster,14,Fri Jun 5 02:40:53 2015 UTC,y school sadly uses Java as its goto language for almost every class but I always find myself using C instead and telling the professor to deal with it.    wow you're so cool.  Really though: an attitude like that means you'd be a shit employee. So stop it.
C_Programming,38iv1x,r_smart,3,Thu Jun 4 21:42:08 2015 UTC,"He's paying for his education, not the other way around. I see no reason he shouldn't be allowed to tailor it to the things he wants to use professionally.  Java is a totally different animal, and spending a lot of time with it would be a waste of his time.  You could probably argue he should look at going somewhere that's not a java school, but as a senior, why bother now?"
C_Programming,38iv1x,1337Gandalf,2,Thu Jun 4 22:28:56 2015 UTC,"He's paying for his education, not the other way around.   ""I'm the customer so I know what's right!!!""  I imagine people on English courses choose what books they want to read, right? ""I only want to read spot the dog this semester, plz. I think it'll be most useful to me overall"".   To me it looks like he's deliberately closing his horizons to a different experience because he thinks he knows best, but imo he clearly doesn't, because he doesn't even know how to find a job in C. (pro-tip: the question has been asked a lot, you can google it. The answer is ""spam companies and recruiters"" like the rest of us). Being so arrogant and thinking you know best when you're literally a newbie is a recipe for disaster.  The fact of the matter is programming in Java, or Python, or even Haskell (infact especially Haskell) will make you a better C programmer as you can appreciate what it does well and what it doesn't, and you can learn ideas that are common idioms in other languages. (e.g. for haskell the extreme reliance on immutable state to avoid large classes of bugs).   I've been writing C drivers for ~10 years now and the shittest programmers I've worked with are like this guy. ""I'm a C programmer and a C programmer ONLY"". e.g. When they use Python, which is now also required as part of the job, they write terrible C-in-Python. But it even shows in the C they write. They don't learn anything. They ""learnt C"" before they started here and that's all they know. They're writing the same crappy C they wrote 10 years ago. The best programmer I work with (and myself, naturally, as I'm literally amazing), are well versed in many different paradigms and idioms and use those ideas to influence the code we worth with.  Being a good programmer is universal, and the more stuff you learn, the better you'll be. It's easy to be a shit C programmer, by only staying with C. It's hard to be a good programmer, but you do that by learning and experiencing as much programming as you can, especially in other languages."
C_Programming,38iv1x,r_smart,3,Fri Jun 5 08:21:16 2015 UTC,"I think most of your comments are good and true. I think anyone who writes a lot of code should not be afraid of learning different things.  At the same time, I think that there's nothing wrong with a senior level student shaping their education more for the job they want instead of continuing working with java which he's probably been doing for the last three years.  I don't know when you went to school, but it's become a trend at a lot of universities to really only teach java and basically create the very types of people you're (rightfully) railing against. There's been a lot written about this by people smarter than me.   In the picture you paint of OP, you would be correct, I just didn't read his comment that way and felt you were being unnecessarily mean.  Speaking of things not to do in a professional setting... :)"
C_Programming,38iv1x,Poddster,1 point,Fri Jun 5 12:00:23 2015 UTC,"@/u/Poddster I use java regularly for personal projects. I'm not deliberately avoiding other languages because of biased, I just like the idea of practicing data structures in C for memory allocation practice. I'm also entering an internship learning all different kinds of languages. This entire thread is blown out of proportion by assumptions based on one sentence."
C_Programming,38iv1x,lobocode,2,Fri Jun 5 16:28:39 2015 UTC,"This isn't /r/java, go there if you want to be butthurt."
C_Programming,38iv1x,lobocode,2,Tue Jun 9 22:21:22 2015 UTC,"I didn't mean for my words to sound douchey, but as /u/r_smart said, it does not benefit me for what I want to do! And in every case I'll tell the professor I'm going to do it in C for my own beneficial learning and they've been more than okay with it every time."
C_Programming,38dlek,TheAvengingKnee,2,Wed Jun 3 15:02:26 2015 UTC,++1 should be ++i
C_Programming,38dlek,ponyoink,1 point,Wed Jun 3 15:05:59 2015 UTC,"Thanks, also saw I had a typo on fclose, I ran the program now and it created the file but with a ? after it. so something like test.txt? was the file generated. It printed the numbers there but it did not do the ranges correctly so with a test range of 5 to 8 it generated 3 numbers 6,4,5."
C_Programming,38dlek,heliox,0,Wed Jun 3 15:25:22 2015 UTC,"For a brief moment, I thought this was /r/seduction"
C_Programming,38dlek,Jack126Guy,2,Wed Jun 3 23:41:50 2015 UTC,The question mark may actually be a newline character ('\n') at the end of the filename. The fgets function stops at a newline but keeps it in the string.  You can remove it by looking for the newline and changing it to a null character. (Use strchr.)
C_Programming,38dlek,javawag,1 point,Wed Jun 3 17:12:51 2015 UTC,"Looks pretty cool!   Couple of things - first you really shouldn't name your variables as single letters - it makes the code much harder to read and you fall into silly traps that are easily avoided. For example, the reason your random numbers are coming out wrong is line 34 - you're telling it to get a random number between 0 and the lowest number (l), and then add the range of numbers you wanted (a). You wanted to write:  x = (rand() % a) + l;   even better (you'd need to change your declarations at the top to match these new names):  number = (rand() % range) + lower;   which means ""let x be a random number between 0 and the range (a), plus the lowest (l)"". It's a bit weird because it's not how humans work out random numbers, but there you go.  Your second bug, the ""???"" is because you are using uninitialised memory. Your char s[100] variable is full of 100 bytes of literally any value (could be a number, a letter, a space, a symbol, a fire-breathing dragon, a non-printing character, the list goes on). You then copy the user-entered filename in, which occupies the first few bytes. The rest is still garbage, so the memory might look like:  TheAvengingKneeva90a80gh^&$£usaih_g89+3p2(hae;gsadg ...   C only knows when a string ends if it ends with a NUL byte* - this is written '\0'. So, once you've written your name in there you need to write a NUL byte at the end of the name. An easy way to do this, if you're not too worried about performance (and really, with 100 bytes, you don't need to!), is to just initialise the whole memory to NUL. So, let's change line 6 to:   char s[100] = { '\0' };   Here we say ""I'd like 100 characters, each set to '\0' (NUL)"". That way, when you enter your name, the rest of the string is still filled with NULs. So, the memory will look like this (0 here means NUL, not the digit zero):  TheAvengingKnee00000000000000000000000000000000   When you call fopen() with this value in memory, it knows as soon as it hits the first '\0' (shown as 0 above, remember!) that the string is finished. Thus, your file will just be named ""TheAvengingKnee"".  * - So how comes the string ends at all? Well, remember I told you each character/byte** could be ANY value at all? That includes '\0'. So it ends whenever it happens by chance to find a random '\0' in amongst the memory!  ** - Characters are 1-byte when using C (unless you use Unicode, in which case it all gets very crazy!)  Anyways, hope that helps! (EDIT: Forgot to finish typing the whole post before posting. Durr.)"
C_Programming,38dlek,javawag,1 point,Wed Jun 3 17:28:13 2015 UTC,"tried the   char s[100] = { '\0' };   it did not work, it still adds a ? after the file name."
C_Programming,38dlek,lishyguy,1 point,Wed Jun 3 18:05:21 2015 UTC,"Damn. See /u/Jack126guy's comment, looks like fgets is eating the newline character as well. Not invalid memory this time! What you'll want to do here then, is to iterate through each character of the string, changing the first newline you see into a '\0'. Give that a go (you'll need a loop!) but if you get stuck I'll show you how I'd write it :)"
C_Programming,38abfv,rhascal,6,Tue Jun 2 22:27:57 2015 UTC,"Meaning you want this to print something like   ""       $300.000""   You'll want to print the $%.2lf to a temporary buffer using sprintf, then print that buffer using %15s.  (Edit: Reddit swallowed the spaces)"
C_Programming,38abfv,boredcircuits,2,Tue Jun 2 22:44:48 2015 UTC,The problem requires using %f unfortunately. I have no idea if it is even possible and have submitted a few times without specifically adhering to that requirement and it has been rejected by the professor =/.
C_Programming,38abfv,_teslaTrooper,2,Tue Jun 2 23:37:40 2015 UTC,"I don't see the problem, you're using %f aren't you?   Did you get any explanation as to why it was rejected?"
C_Programming,38abfv,FUZxxl,2,Wed Jun 3 02:38:02 2015 UTC,Have a look at the strfmon function. It's not part of ISO 9899:2011 (C11) but of IEEE 1003.1-2008 (POSIX) so you can use it on every POSIX compliant operating system.
C_Programming,38abfv,spc476,1 point,Wed Jun 3 07:39:44 2015 UTC,"#include <stdio.h> int main(void) {   printf(""$%15.3f\n"",300.0);   printf(""$%-15.3f\n"",300.0);   return 0; }"
C_Programming,38abfv,FUZxxl,1 point,Wed Jun 3 00:19:25 2015 UTC,"no dice, thanks though"
C_Programming,38abfv,spc476,1 point,Wed Jun 3 00:51:05 2015 UTC,How's that supposed to help?
C_Programming,38abfv,Criffer,1 point,Wed Jun 3 07:40:24 2015 UTC,I misread the problem.
C_Programming,38abfv,glinsvad,0,Wed Jun 3 16:16:53 2015 UTC,It looks like you're storing currency in a float. Stop that.
C_Programming,38abfv,BigPeteB,2,Wed Jun 3 12:19:59 2015 UTC,"OP's problem still arises when you represent currency as either integer multiples of smallest-denomination or any other integer count of all denominations. The problem is presentation, not (or also) representation."
C_Programming,38abfv,sgthoppy,2,Wed Jun 3 15:41:29 2015 UTC,It's a homework assignment. Relax.
C_Programming,38abfv,psu72,1 point,Wed Jun 3 17:54:20 2015 UTC,Isn't %lf for doubles? Also are doubles or integers better suited for currency than floats?
C_Programming,389cq2,raccjoe,5,Tue Jun 2 19:14:30 2015 UTC,"The problem with this question is that C++ has templates, which makes it possible to write containers that work seamlessly with any type, built-in or user-defined.  C does not have that, and so writing generic containers involves working through a lot of tradeoffs.  Is the container to be type-safe?  If so, then you're probably looking at some ugly, ugly macro layer to stamp out code like a poor man's template system.  But maybe you don't need that, and instead you know that you're only going to use this container with built-in types, so you can write a fixed number of implementations without macros.  Or maybe you have a specific use case in mind and you don't care about flexibility, and you just write the code for that bespoke situation.  That's the problem with finding libraries for data structures in C.  It's far less cut and dried than in C++.  There's really not that much to implementing a dynamic resizable array, since in C you don't have to worry about overloading operators or being exception safe or any of that stuff.  Really the only difficult part is the resize step, and that's actually a lot easier than in C++ because (a) objects don't have constructors or destructors, so they can be managed by a simple memcpy(), and (b) you can use realloc() which takes care of that memcpy() for you if it was necessary.  (Sometimes the heap allocator can simply expand your allocation without having to copy anything, which is really nice.)  The important part is that when you choose the new size, you should always multiply the previous size by some constant to obtain the new size, rather than adding some constant.  This assures the growth follows a geometric series, which is what allows you to achieve O(1) amortized append behavior, rather than O(n).  The constant that you multiply by lets you trade off memory waste for performance (i.e. the constant factor in the O(1)).  3/2 is a common choice.  Here's a quick example:  size_t tokenize(const char *s, const char *delim, char ***tokenarray) {     size_t size = 0, capacity = 4, wordlen;     const char *begin = s, *end;     char **tokens = malloc(capacity * sizeof(char *));      do {         begin += strspn(begin, delim);         if(!*begin)             break;         end = strpbrk(begin, delim);         wordlen = end ? (size_t)(end - begin) : strlen(begin);         if(size == capacity) {             capacity = capacity * 3 / 2;             tokens = realloc(tokens, capacity * sizeof(char *));         }         memcpy(tokens[size] = malloc(wordlen + 1), begin, wordlen);         tokens[size++][wordlen] = 0;         begin = end;     } while(end);     *tokenarray = tokens;     return size; }   This tokenizes a string using the given set of delimiters, creating an array of strings containing each token.  The array starts out with capacity 4, and is resized as necessary.  It's meant to be used as e.g.  const char *str = ""The quick brown fox jumps over the lazy dog.\n""; char **tokens; size_t numtok;  numtok = tokenize(str, "" .\n"", &tokens); for(size_t i = 0; i < numtok; i++) {     printf(""got <%s>\n"", tokens[i]); }  ...  for(size_t i = 0; i < numtok; i++) {     free(tokens[i]); } free(tokens);   Anyway, that's just an example of how the implementation of the dynamic array can be very simple, and completely nestled within the implementation of the tokenizing algorithm."
C_Programming,389cq2,Rhomboid,0,Tue Jun 2 20:11:04 2015 UTC,You might want to use floating point for your growth factor...
C_Programming,389cq2,raevnos,2,Wed Jun 3 09:50:36 2015 UTC,"capacity * 3 / 2 means (capacity * 3) / 2, not capacity * (3 / 2)."
C_Programming,389cq2,zifyoip,1 point,Wed Jun 3 11:28:20 2015 UTC,"My capacity is 1  1*3 = 3  3/2 = 1.5,  Rounded down to 1"
C_Programming,389cq2,DownloadReddit,2,Thu Jun 4 20:51:40 2015 UTC,"Well, sure, if you start the capacity at a silly value like 1. That's why you don't start the capacity at 1."
C_Programming,389cq2,zifyoip,4,Fri Jun 5 04:27:14 2015 UTC,https://github.com/nothings/stb/blob/master/stretchy_buffer.h
C_Programming,389cq2,manvscode,1 point,Tue Jun 2 19:25:59 2015 UTC,Does this realloc everytime an element is pushed in?
C_Programming,389cq2,ankit_rohatgi,4,Tue Jun 2 21:20:21 2015 UTC,"TLDR: no.  Looking at 'stb__sb_push(a,v)':  #define stb_sb_push(a,v) (stb__sbmaybegrow(a,1), (a)[stb__sbn(a)++] = (v))   It evaluates 'stb__sbmaybegrow(a, 1)' and then pushes the item onto the buffer. 'stb__sbmaybegrow(a, n)' is defined as  #define stb__sbmaybegrow(a,n) (stb__sbneedgrow(a,(n)) ? stb__sbgrow(a,n) : 0)   which calls 'stb__sbgrow(a, n)' only if 'stb__sbneedgrow(a, n)' evaluates to true. 'stb__sbneedgrow(a,n)' is defined as:  #define stb__sbneedgrow(a,n)  ((a)==0 || stb__sbn(a)+(n) >= stb__sbm(a))   which evaluates to true if a is NULL, or the required size of the stretchy buffer   stb__sbn(a) + (n)   is greater than or equal to the capacity of the buffer  stb__sbm(a)"
C_Programming,389cq2,floopgum,1 point,Wed Jun 3 00:53:05 2015 UTC,"No, but please read the code."
C_Programming,389cq2,manvscode,1 point,Thu Jun 4 17:31:13 2015 UTC,"It wasn't very clear to me, that is why I asked."
C_Programming,389cq2,ankit_rohatgi,2,Thu Jun 4 18:56:28 2015 UTC,"The implementation of vectors in C is an interesting problem and you can find implementations in any dynamically typed programming language implementation that is written in C (Python, Ruby, PHP). The hard/interesting part is that if you want dynamic/mixed types contained within the vector, then you'll need to implement your own object system. This is a solved problem and is a great exercise if you are interested in data structures. Typical implementations use a a struct with a discriminated union, and an integer to  identify which member of the union is active. Overall, your API provides a dynamic layer between the underling statically typed C variables. You'll then have to implement the Vector API to support the Object API. It gets really interesting here because you notice the recursion. Your Object system can also have a vector type. But things can get even harder once you realize that you can push any type your object system supports onto the vector, even nested vectors. You'll then need to implement an algorithm for garbage collection if don't want to leak any memory. If you are really interested, I can show you my own implementation that is on GitHub."
C_Programming,389cq2,0x12345,1 point,Wed Jun 3 05:14:52 2015 UTC,That sounds interesting indeed. I haven't thought so far about nested vectors and its implications.. I would appreciate if you shared the link to your implementation :)
C_Programming,389cq2,0x12345,2,Wed Jun 3 18:41:19 2015 UTC,"https://github.com/libobject/libobject This is the initial version. It has strings, doubles, arrays, and maps. Take a look at the src/object.h for the C data structues.  There is garbage collection in the initial implementation yet because I haven't integrated my current version with libobject but I do have a initial implementation if you're interested but it isn't on GitHub yet.   The hard part about the GC is that for every object created, it needs to be pushed onto a stack somewhere in order to keep track of all objects. As is, I can free each object i create manually but once I start creating some complex nested data structures it gets difficult to manage."
C_Programming,389cq2,benwaffle,2,Wed Jun 3 20:10:25 2015 UTC,I like glib: https://developer.gnome.org/glib/stable/glib-data-types.html
C_Programming,389cq2,geocar,2,Wed Jun 3 16:58:36 2015 UTC,"Thanks a lot guys for your great responses. Sorry that it took so long for me to answer but it took some time to digest all the information that was given here and let's not talk about all the googling I had to do.. The books on C I read so far used linked lists as examples for ADTs most of the time and especially with reference to databases. While I see the advantage of easy deletion and insertion, the not existing random acces always bothered me and recently read about cache misses because of the segmented nature of linked lists. Creating an array with realloc capabilities to get the sequential order of memory and the ability to increase their size dynamically was what I wanted, a vector. I'm telling you this so you know where I come from and probably some of the knowledge you try to teach me may be lost on me for now.    @geocar So you're saying whlie the implementation of an vector is trivial it's hard to generalize it to fit every use case without introducing bugs/leaks? I thought about using _Generic to determine the type and work my way up form there what, after some thinking, is equivalent to 'determine type -> magic -> generic vector'... And as Rhomboid already said, it would end up with lots of macros which puts the usage of _Generic itself in question.    I understand why you don't recommend vector libraries but doesn't inventing the wheel over and over again introduce unnecessary bugs, readability and maintenance problems (or at least redundancy)? Maybe I try to make C something that it is not but I can't imagine professionals using the language without the capabilities for reusability in mind. While I can see the reason for embedded platforms I can't see it for well established architectures like for example x86. Also this is not a rant against C. I just want to understand the techniques and mindset it is used to create readable, maintainable and hopefully reusable code.    @Rhomboid Thanks for your thorough response. Could you elaborate on your point that multiplying the former size of a buffer by a constant results in constant time for appending? Also, amortized means average case in this context, doesn't it? I understand that at a certain point the growth of the multiplication is faster than by adding a constant, so you need less reallocations for a bigger buffer size in the long run. But doesn't that mean, depending on the initial buffer size and constant you multiply/add by, your 'amortized append behavior' is worse for vectors under a certain size?"
C_Programming,389cq2,geocar,2,Wed Jun 3 18:35:46 2015 UTC,"whlie the implementation of an vector is trivial it's hard to generalize it to fit every use case without introducing bugs/leaks?   That's exactly right: At least in C. It's a bit easier in C++.   doesn't inventing the wheel over and over again introduce unnecessary bugs, readability and maintenance problems (or at least redundancy)?   No.  In fact, consider the number of companies that actually do reinvent the wheel: Even when it comes to wheels it's always worth re-evaluating it from the perspective of the problem you actually have rather than the problem you think you have.   I can't imagine professionals using the language without the capabilities for reusability in mind.    Professionals do attempt to create reusable components: When they identify a problem-solution pair, they try to make the solution as generic as possible in the hopes it will fit other similar problems.  That doesn't mean they're right, and even if they are: It doesn't mean that a ""vector"" is such a component. To me, it's just a pointer and a length. I already know the layout in memory and I see no point in wasting cycles allocating memory and copying things around so that I can write Java or Python with a C compiler."
C_Programming,389cq2,geocar,1 point,Thu Jun 4 14:02:50 2015 UTC,"I definitely wasn't prepared of a link to actual tires and rims :D    I looked over C++ Templates and found it easy to read and surprising to learn that nowadays the disadvantages are negligible expect for longer compile-time, if I understood correctly. Unfortunately the debate C++ vs. C is fought so vigorously it is impossible for somebody not proficient in both languages to filter out the bias from the facts. As a beginner in programming in general C seems the way to go for me though. C++ gives great abstractions and an ever growing expansion to their standard library but for now I think sticking with one language and learning the fundamentals is more important, or at least that's where I put emphasize on. That is where your point of correctly identifing the problem comes into play. Abstractions will blind you from the real problem if you don't know what's going on behind the curtain. I'm sure (not based on actual knowledge) abstratctions can greatly contribute to maintainability and readability of large code bases, what doesn't concern me for now though.    Sorry for the long reply again, but I jumped languages for a long time because people told me that the language I'm learning won't get me a job anywhere and rather learn X. Without ever considering that the principles behind a language/feature is the integral part of programming and the syntax just a way to express your ideas, I stumbled along and gave up because it didn't make any sense to me at all and drained all the fun for programming I had until recently.    Our opinions may differ on some of the above written but I greatly appreciate the time you took to explain your position to me."
C_Programming,389cq2,geocar,2,Thu Jun 4 19:41:50 2015 UTC,"I looked over C++ Templates and found it easy to read and surprising to learn that nowadays the disadvantages are negligible expect for longer compile-time, if I understood correctly.   That is about right. C++ compilers are much smarter than C compilers.   Unfortunately the debate C++ vs. C is fought so vigorously it is impossible for somebody not proficient in both languages to filter out the bias from the facts.   Few people are proficient in both languages. Good programmers do not usually use C or C++ :)   I'm sure abstractions can greatly contribute to maintainability and readability of large code bases   The right abstractions can, but choosing the right abstractions is not always straightforward.  This is where experience and taste are important: Programming is like writing, where we have things we call rules, but we actually remain free to apply our own style and can greatly appreciate the flavour of an expertly written work.   I jumped languages for a long time because people told me that the language I'm learning won't get me a job anywhere and rather learn X.  Without ever considering that the principles behind a language/feature is the integral part of programming and the syntax just a way to express your ideas, I stumbled along and gave up because it didn't make any sense to me at all and drained all the fun for programming I had until recently   It is good that you are considering this point. There's an article by Chuck Moore that you might find interesting.  ""C programmers"" is not a class, but a property: Programmers who can express themselves in C. People express themselves in C in many different ways - not just the way that I do.  The best reason to do it the way Rhomboid suggests is that more people express themselves in that way than they do in my way.  However.  Writing popular things is important to magazine writers. It is not important to the computer, and it is not important to me. I think it is important to always consider the problem that I'm trying to solve, and if that is writing fast and correct programs, then it is a distraction to worry about things that don't contribute to fast and correct programs.  Happy hacking."
C_Programming,386yrb,Tatyanazaxarova,12,Tue Jun 2 08:12:25 2015 UTC,"C and C++ are not the same thing. Never have been, never will be. Telling people to always return by reference is harmful to code complexity and maintainability in C++.  In a world with RVO and move semantics returning by value in C++ is very often,though not always, perfectly fine."
C_Programming,386yrb,StrangerInTheNight,2,Tue Jun 2 11:54:56 2015 UTC,"Telling people to always return by reference is harmful to code complexity and maintainability in C++.   Not a C++ dev, but I'm curious why are references harmful?"
C_Programming,386yrb,seekingsofia,2,Thu Jun 4 23:52:56 2015 UTC,"I wasn't saying that all references are harmful but that returning by reference only to ""optimize"" adds code without actually making things faster in 90+% percent of the cases.  Because to return by reference you need to allocate on the heap. This is because returning a reference to a local variable is an error. Maybe you don't want to allocate on the heap, especially for efficiency.  Then maybe you say ""I'll just have a ref parameter and modify that instead of returning"" but then you need to create a variable at the call site for no real good reason.  I hope this was understandable to you, I'm not always the best at explaining."
C_Programming,386yrb,StrangerInTheNight,6,Sat Jun 6 02:45:24 2015 UTC,This article is over 9 years old and the advice isn't very good anyway.
C_Programming,386yrb,skeeto,8,Tue Jun 2 12:58:48 2015 UTC,"To add some C-specific complaints about their advice, let's see...   Place case labels in narrow range   This might be helpful if you're switching over an enum. But that assumes you're comfortable reordering or renumbering the values of the enum to optimize a switch statement. And it assumes a majority of the switch statements being optimized will have cases for the same range of values.   Place frequent case labels first  Break big switch statements into nested switches   That's interesting advice. I suppose if you know the compiler is going to emit if-else cascades for the labels you have, it makes sense.   Minimize local variables   Compilers are exceptionally good at register allocation and combining. Frame pointer optimization is the norm in optimized code, as is combining adjustments to the stack. Don't try to outsmart the compiler; use as many local variables as you like.   Declare local variables in the inner most scope   Totally irrelevant in C, since variables have no cost other than adjusting the stack pointer, and an optimizing compiler will just do this once at the start of the function. (It might be good for code style, but that's different.)   Reduce the number of parameters. Use pointers and references in such cases.   Only makes sense if you have quite a lot of parameters, and in frequent cases don't need to reference all of them. Otherwise, it's forcing more parameters through a level of pointer indirection that might not be necessary. And it's harder for the caller to use.   Prefer int over char and short   Not portable advice! Use int8_fast_t and friends if you care deeply about trading space for speed.   Prefer initialization over assignment   Irrelevant in C. (Much of the rest of the the advice is as well, but this one is maybe not so obvious to newcomers.)"
C_Programming,386yrb,BigPeteB,3,Tue Jun 2 14:51:19 2015 UTC,I've always been told that the compiler will be much better at optimisation than you will ever be
C_Programming,386yrb,ThatOtherGuyAbove,3,Tue Jun 2 16:06:24 2015 UTC,"If you try to beat that compiler at what it does you will lose most of the time. But the compiler just translates the instructions you give it.  If you instruct the compiler to generate code that allocates all variables on the heap for absolutely no reason than your code will be slower. Your compiler can't say ""Oh heap allocations aren't cheap all modify this code to use the stack!"". It's not what you asked for so it's not what you will get."
C_Programming,386yrb,StrangerInTheNight,3,Tue Jun 2 16:22:13 2015 UTC,"That depends on the situation. Occasionally the programmer knows something about the code which the compiler can't deduce on its own in which case some fairly significant wins over the compiler optimizations alone can be achieved.  However, modern compilers are very, very good and these situations are somewhat rare."
C_Programming,3880b7,Shtreimel,2,Tue Jun 2 14:39:27 2015 UTC,"Not talking about the logic just yet, your code definitely doesn't work because both j and k start at zero, not lower. Also, you use the variable i I assume instead of j at one point. And, of course, declare temp somewhere.  With those changes, I believe the logic checks out., but it's not as clean IMO, because the swap that moves the pivot to the center (Which is basically the most important part of the partition function) isn't very obvious from the code. Also, with that said, you only really saved two lines off the end, so gains are somewhat minimal. I would however agree with the fact that you can increment their i at the end rather then beginning of the loop and it results in a cleaner setup. I question somewhat why they did it the way they did."
C_Programming,3880b7,DSMan195276,1 point,Tue Jun 2 17:39:13 2015 UTC,"Thank you for the answer, I forgot cleaning the code.  Thank you for noting me this, now, the code is okay, right?  I just think that if the loop can move the pivot to the middle it should do so if it's so simple.."
C_Programming,3880b7,DSMan195276,2,Tue Jun 2 17:49:42 2015 UTC,"It's true, I'm fairly certain this code works.  In some ways, people expect to see the pivot value moved at the end of the partition function, so people tend to do it that way. It's also quite possible you'll get faster code from your book's version rather then this version (The best would probably be your change to i's initial value, along with their code). There's also the catch that lots of people use lower for their pivot, in which case you would have to do the partition in the opposite direction for this to work.  Since you're not explicitly moving the pivot value, it would be worth inserting a comment stating:  /* At the end of the loop, the value in numArray[upper], our pivot, will be  * located between both partitions, so there is no need to move it explicitly */   Just for the readers sake, so they don't get confused by your code."
C_Programming,387lkb,Ajpennster,3,Tue Jun 2 12:43:25 2015 UTC,Stack memory goes out of scope at the end of the function.
C_Programming,387lkb,Chooquaeno,2,Tue Jun 2 12:52:33 2015 UTC,I'm aware of that. Can you expand? How does that cause problems for me?
C_Programming,387lkb,OlderThanGif,2,Tue Jun 2 13:18:54 2015 UTC,"Take your qextract function. You're returning query, which is a pointer into the mtarget array. The instant you execute a return statement, mtarget goes out of scope and you have to assume that that array no longer exists. Hence, you're returning a pointer to an array which has been deallocated."
C_Programming,387lkb,antoniocs,1 point,Tue Jun 2 13:21:18 2015 UTC,And the textract seems to be doing the exact same thing.  char lcopy[len+1];   Is a local array which *request points to.
C_Programming,387lkb,OlderThanGif,1 point,Tue Jun 2 13:26:32 2015 UTC,I see. Is there a way I can convert it to a const char*? Or do I definitely have to use the heap?
C_Programming,387lkb,dmc_2930,2,Tue Jun 2 13:26:58 2015 UTC,"Forget about the const char *. const is not causing you problems and is not your issue here (though I'm not sure why you're trying to return it as a const char * when it's not). The problem is that you're trying to return a pointer into an array that's a local variable and hence going out of scope. The most straightforward solution is to put your array somewhere where it's not going to go out of scope, i.e., use malloc to put it on the heap."
C_Programming,387lkb,OlderThanGif,3,Tue Jun 2 13:31:29 2015 UTC,How about creating a local string and then passing it into the function? I'm trying not to use Malloc to prevent leaks as the user can close the program at any given moment.
C_Programming,387lkb,FUZxxl,2,Tue Jun 2 13:37:04 2015 UTC,"When the program closes, the OS will deallocate all of the memory.  There's no need to avoid using malloc() and free(). Just make sure you match every malloc() call with a free() call.  If you insist on not using malloc and free, you can either make the string buffers global variables ( declare them outside of your functions ), or make them static ( which means they will persist across calls, and make your functions non-reentrant, ie if they're called from multiple threads at once it'll potentially screw things up, and the previous values will be overwritten the next time you call the functions ).  The correct thing to do here is to use malloc and free."
C_Programming,387lkb,Chooquaeno,2,Tue Jun 2 13:47:24 2015 UTC,"Yes, that works and is a common way to structure things in C!"
C_Programming,387lkb,autowikibot,1 point,Tue Jun 2 13:39:18 2015 UTC,Thanks a lot. I was really going crazy with this sort of behavior.
C_Programming,387lkb,dmc_2930,1 point,Tue Jun 2 13:39:41 2015 UTC,as the user can close the program at any given moment.   How may that cause memory to be leaked? All memory associated with a process is freed once the process terminates.
C_Programming,387lkb,antoniocs,1 point,Tue Jun 2 21:26:26 2015 UTC,"A memory leak occurs when memory is allocated but not freed when it is no longer in use. The issue is not memory not getting freed when the program is closed. It is known that the memory is no longer needed at that point.  The issue is that some memory does not get freed every time the program performs some task, but the program continues running.  https://en.wikipedia.org/wiki/Memory_leak"
C_Programming,387lkb,autowikibot,1 point,Wed Jun 3 07:28:37 2015 UTC,"Memory leak:       In computer science, a memory leak is a type of resource leak that occurs when a computer program incorrectly manages memory allocations  in such a way that memory which is no longer needed is not released. In object-oriented programming, a memory leak may happen when an object is stored in memory but cannot be accessed by the running code.  A memory leak has symptoms similar to a number of other problems (see below) and generally can only be diagnosed by a programmer with access to the program's source code.    Image i     Interesting: Windows System Resource Manager | New (C++) | Windows Filtering Platform   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,387lkb,dmc_2930,-3,Wed Jun 3 07:28:51 2015 UTC,"This code is more C++ than C - C does not support declaring arrays with non-constant sizes:      char mtarget[len+1];   This is allowed in C++, but not in C."
C_Programming,387lkb,antoniocs,5,Tue Jun 2 13:48:51 2015 UTC,I think you can with Variable-length array
C_Programming,387lkb,dmc_2930,1 point,Tue Jun 2 13:56:26 2015 UTC,"Variable-length array:       In computer programming, a variable-length array (or VLA) is an array data structure of automatic storage duration whose length is determined at run time (instead of at compile time).   Programming languages that support VLAs include Ada, Algol 68 (for non-flexible rows), APL, C99 (although subsequently relegated in C11 to a conditional feature which implementations are not required to support;    on some platforms, could be implemented previously with alloca() or similar functions) and C# (as unsafe-mode stack-allocated arrays), COBOL, Fortran 90, J.     Interesting: Ch (computer programming) | List of data structures   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,387lkb,dumsubfilter,0,Tue Jun 2 13:57:33 2015 UTC,"It's part of C99 but not all compilers support it (nor are they required to, per C99)"
C_Programming,387lkb,dmc_2930,2,Tue Jun 2 13:58:28 2015 UTC,"Ok, so it is allowed in C and I think GCC and Clang both support this."
C_Programming,387lkb,dumsubfilter,1 point,Tue Jun 2 14:01:55 2015 UTC,len already has a value in it. How is this non-constant?
C_Programming,387lkb,dmc_2930,2,Tue Jun 2 14:52:46 2015 UTC,"It's not a compile time constant.  It's allowed in newer C compilers, but not older ones. ( It's a part of C99 ).  For pre-C99, you can do this:  char array[16];   But not this:  int len=16; char array[len];   As others have pointed out, most new C compilers support this nowadays, but it's only supported officially in C99, and even then it's not required.  It's better to just use malloc() and free()."
C_Programming,387lkb,dumsubfilter,0,Tue Jun 2 14:56:36 2015 UTC,"but it's only supported officially in C99, and even then it's not required.   What's that even supposed to mean?  Of course it's ""required"" that it be allowed if you're professing to be C99 compliant.  You can't just support part of the standard and claim to be compliant."
C_Programming,387lkb,dmc_2930,0,Tue Jun 2 20:08:19 2015 UTC,The C99 standard says that it is optional for compiler makers. Not everything in the standards is mandatory.
C_Programming,387lkb,dumsubfilter,1 point,Tue Jun 2 20:20:12 2015 UTC,"That doesn't even make sense.  Citation needed.  You can't just choose to not support part of the inclusions of the standard, and then claim to be C99 compliant.  It doesn't work like that.  ""Sure, I've got a C99 compiler... it doesn't support integers though.""  What?"
C_Programming,387lkb,antoniocs,-1,Tue Jun 2 20:32:06 2015 UTC,You can look at the Wikipedia page linked earlier. C99 explicitly made variable length array support optional.   I'm sorry it doesn't fit in to your world view. I didn't write the standard.
C_Programming,385dlr,linuxn00b7,5,Mon Jun 1 23:44:56 2015 UTC,"What is this intended for? I can tell you that running this on my Linux box, it finishes in just under 2 seconds, and I'm not sure what to make of what was printed."
C_Programming,385dlr,necrophcodr,1 point,Tue Jun 2 08:38:36 2015 UTC,Same here on OSX.
C_Programming,385dlr,bunkoRtist,1 point,Tue Jun 2 14:59:40 2015 UTC,"Hmm, there must be a difference in how windows is treating the execution if linux and mac are just flying through it.  To see the intended result, you could create a text file and save the output to it, then scroll up and down through the text file quickly to create the optical illusion"
C_Programming,385dlr,bames53,3,Tue Jun 2 17:32:02 2015 UTC,"The difference is the Windows console. As I understand it, on Windows, writing to the console involves IPC calls to csrss.exe, and that these are blocking calls: the program makes the IPC call, blocks until csrss updates the console, and then continues execution. This means you get very frequent context switches and processes waiting on each other, and so the program runs slowly.  On Unix systems, the output is written using regular file IO. Instead of being kept in a synchronous lockstep with the terminal, the program can fill up a buffer of several kilobytes without interruptions. When the buffer is full then the program does have to wait for more room to be made by the terminal device consuming data from the buffer, but there are far fewer interruptions because the buffer is a lot bigger than the chunks of text written with the Windows console API.  One way you can see this is if you compare the time required to run the program with output redirected to a file vs. the normal time. On Windows, running the program normally, with output being displayed in the console, takes many minutes, while running the program with the output redirected to a file takes only a few seconds. On Unix, the execution time is not more than a few seconds either way. On Unix there may still be differences depending on how quickly the terminal empties the buffer vs. how quickly data can be written to the disk drive.    I'm not actually all that familiar with the Windows console model, so if anyone has a better description of Windows' console behavior please correct me. I'd also be interested in any good references that cover this area."
C_Programming,385dlr,necrophcodr,1 point,Tue Jun 2 19:12:06 2015 UTC,"Yes, this better explains kinda what I was thinking.  Essentially windows is refreshing the terminal screen after each argument is processed, whereas the UNIX systems were processing the output first and then printing the entire output at once."
C_Programming,385dlr,necrophcodr,1 point,Wed Jun 3 05:38:02 2015 UTC,"it doesn't print any new lines, so it's just one long line though. no scrolling happening there."
C_Programming,385dlr,necrophcodr,1 point,Tue Jun 2 18:45:49 2015 UTC,"Ah, ok.  So then it's just a difference in how the OS's are handling the output.  In windows it is starting a new line when it reaches the terminal border.  If it's just keeping it all on one line, then the equation would have to be modified to ""\n"" every 2000 characters, or however many characters long your terminal window is.    edit : no, not 2000, that's how many characters total in the terminal window, probably like around 100 or so characters per line."
C_Programming,385dlr,boarhog,2,Tue Jun 2 18:54:43 2015 UTC,"well, on linux i gather the average terminal window is 80 by 25 characters, but it all depends, and there's no reliable portable way of determining this.  however, you really should make use of that fflush( stdout ) call."
C_Programming,385dlr,crookedkr,1 point,Tue Jun 2 22:39:26 2015 UTC,Yes I just found the windows terminal to be 80 by 25 as well.  I haven't learned the fflush( stout ) call yet.  But will look into it...
C_Programming,385dlr,zenkibudo,1 point,Wed Jun 3 05:41:10 2015 UTC,"Wow, either there's some kind of technical mishap occurring, or Linux is waaaaay faster than windows when it comes to 'for' loops and printf, lol.    In a nutshell, this program prints out patterns of text in calculated intervals, so that while the text scrolls up the screen in the terminal, it makes visuals or seemingly animated displays.  It's an optical illusion based on the speed of the cpu.  There's a sweet spot though, for if the scroll is too fast (like yours) or too slow (1987 pc's) then it won't have the optical illusion effect."
C_Programming,385dlr,DetSomEnGangVar,1 point,Tue Jun 2 17:10:44 2015 UTC,"Here, try this out then.  It's a very simplified version.  The dots should print out slowly like an installation progress bar would appear.  If it just prints out all 10 dots instantly, then add a zero to both variables dot and pause, and run again.  Continue to add a zero to 'dot' and 'pause' until you can see the dots print out one by one :p  #include <stdio.h> #include <stdlib.h>  long i; long dot = 100000000; long pause = 1000000000;  void test(long x) {     if(x % dot == 0)     {         printf(""."");     }     return; }   int main() {     for(i = 0; i < pause; i++)     {         test(i);     }     return 0; }"
C_Programming,385dlr,OldWolf2,1 point,Tue Jun 2 18:31:14 2015 UTC,"it doesn't print anything until it is completely done, then prints everything. might want to fflush(stdout) too."
C_Programming,385dlr,zenkibudo,3,Tue Jun 2 18:47:36 2015 UTC,Zero errors from compiler with  gcc code.c -o code -pedantic -Wall -Werror -Wextra -std=c11   I call shenanigans!  ps. nice :)
C_Programming,385dlr,OldWolf2,1 point,Tue Jun 2 08:04:36 2015 UTC,"Thanks! I was just experimenting with modulus in a 'for' loop, and I noticed when I printed a series of ""."" dots, except for when 'i' was divisible by 7 [ if( i % 7 ==0){printf(""0"")}else{printf(""."")} ] All the zeros printed out in the sea of dots would be lined up in an angle.  When I changed the number to 13, 43, 22, they would always be lined up on the terminal screen, but in different angles.  So I thought, that be cool to continuously fill the screen with dots thousands of times, but flash different patterns of other characters within the dots.  Eventually I replaced the dots with blank spaces "" "" and things got real :)  edit : typo"
C_Programming,385dlr,crashnburn254,3,Tue Jun 2 17:16:25 2015 UTC,Can someone make a gif of what it is supposed to look like?
C_Programming,385dlr,zenkibudo,1 point,Wed Jun 3 04:15:46 2015 UTC,"Sorry I'm not smart enough to make an animated gif, but here is a 'single frame' screencap.  Since there's no carriage returns/line feeds in the code, the display of the rotating selection of characters generally enjoys a different startX and startY on the console.   As the characters stream by at hi speed, this tends to create some interesting effects -- ranging from swaying left/right, and more...     Simple stuff with surprising results."
C_Programming,3876dy,Kwbmm,3,Tue Jun 2 09:51:59 2015 UTC,"You need to override stdin because that is setting up the communication between the two programs. You do not need to overwrite stdout, as you are currently doing, because the child program isn't writing to the pipe.  On Windows these are two completely different programs. They don't share any variables or any other data aside from the inherited pipes. Thinking of this as forking, in the Unix sense, is really the wrong way to think about it.  All that said, is your child hitting an error?"
C_Programming,3876dy,Meefims,1 point,Tue Jun 2 12:12:37 2015 UTC,"I think the child is executed fine. I cannot debug it but its exit code is 0, so it should be ok. Of course, as you say I'm overwriting the stdout, so I'm not seeing any output on console.   Also, what if, after overwriting stdin, I want to get some data from input from the child process? Should I save the handle of stdin before overwriting?  EDIT:  I noticed I have no way to check the exit code of the child, so I don't know if it's giving any error... Also tried changing some bits here and there, still no luck and not being able to see stdout of the child process doesn't help at all..."
C_Programming,3876dy,Meefims,1 point,Tue Jun 2 12:21:03 2015 UTC,"In your code you have created one pipe. That pipe has a read end and a write end. Since your child process needs to read from the pipe you set the child process's stdin to the read end of the pipe in the parent uses the write end to populate the data in the pipe.  If you want the child to communicated back to the parent then you need to create a second pipe and set the child's stdout to the write end of that second pipe. Of course, if you do so you must keep in mind that you must keep data flowing or you may deadlock.  If you want the child to output but not to the parent process then don't override stdout."
C_Programming,3876dy,raevnos,1 point,Wed Jun 3 02:12:45 2015 UTC,"I'm not knowledgeable by any means about Windows programming, but I think you need to be setting si.hStdInput to readP, not writeP."
C_Programming,3876dy,raevnos,1 point,Tue Jun 2 18:48:09 2015 UTC,Tried. Not working :(
C_Programming,3876dy,raevnos,1 point,Tue Jun 2 20:31:08 2015 UTC,"Like I said, I'm not keen on Windows programming, but I'm pretty sure pipes work on it the same way that they do on unix systems. You get a pair of file descriptors/handles, linked so that anything written to the first is read from the second, but it's a one way thing. You can't read from the writing end or vis versa (On unix, if you do need bidirectional pipes, there's socketpair()). So that's why your setting the child's standard input to the write end looked odd. Same for standard output.   So, I think you're trying to get the child process to display stdout to the same location as the parent process (The terminal in most cases). You probably should be setting the child's stdout to the parent's stdout. Maybe that's the default if you don't explicitly set hStdOutput? I don't know.  That way the parent writes to the write end of the pipe, the child reads it because the read end of the pipe has been set to be its standard input, and then it writes stuff on standard output that goes back to the terminal."
C_Programming,3876dy,FUZxxl,1 point,Tue Jun 2 21:24:26 2015 UTC,"I got the principles since it's pretty similar to that in Unix, the point where I get confused is when I call SetHandler: on Microsoft docs it's written that with the flag I used, the child process inherits the handle (which I believe is what I want to do)  but then in the examples provided before calling SetHandler there's a comment saying this is done to NOT inherit the handle...   I'll post later the link to the example I'm referring to..  EDIT: This is the link I was referring to"
C_Programming,3855nk,rhascal,2,Mon Jun 1 22:49:03 2015 UTC,Try removing the newline characters from the scanf format string.
C_Programming,3855nk,scifreak_666,1 point,Mon Jun 1 23:12:49 2015 UTC,Oh. Thanks lol.
C_Programming,3855nk,OldWolf2,1 point,Mon Jun 1 23:19:44 2015 UTC,Please indent your code with four blanks so it appears in a mono-space font.
C_Programming,3855nk,linuxn00b7,1 point,Mon Jun 1 23:26:33 2015 UTC,"Not sure how to indent on reddit. Also, once a problem is solved, what is etiquette for the sub, edit in some fashion?"
C_Programming,3808sj,CProgrammingQuestion,5,Sun May 31 22:00:14 2015 UTC,"The problem is the order of the linked list. When you allocate memory, you advance the start pointer of the block that is being split up (line 44) but you never change it back when blocks are merged. Let me illustrate:  When you initialize your heap with 1000B and allocate one block of 200B, you will get this situation: (where HEAP is the location of the initial pool)  HEAD = &{     HEAP + 200, 800, 1,     &{ HEAP, 200, 0, NULL } }   When you call my_free(HEAP); in this situation, the two blocks will never be merged because you're only merging with consecutive free blocks, not those that are in front of the block you just free'd. The problem is that your linked list is in reverse order, i.e. the Chunk with the highest start address is in front."
C_Programming,3808sj,thefeistelnetwork,1 point,Sun May 31 23:03:59 2015 UTC,So my problem is that I am assigning head to what ever the size of my malloc call is? How do I fix it?
C_Programming,3808sj,thefeistelnetwork,2,Sun May 31 23:19:16 2015 UTC,The problem is that you're not merging your free'd blocks correctly. Try printing out the entire linked list after each call to my_malloc() and my_free() and you will immediately see what the problem is.
C_Programming,37y2ln,criustitan,3,Sun May 31 10:44:39 2015 UTC,"Ouch, this is complicated. For a more beautiful algorithm, look at the algorithm by Knuth and Plass."
C_Programming,37y2ln,FUZxxl,3,Sun May 31 14:43:35 2015 UTC,Everyone starts somewhere; so long as the algorithm actually does the job then no complaints from me. Once it's working then the learning coder can look for ways to improve it.
C_Programming,37y2ln,OldWolf2,1 point,Tue Jun 2 07:02:53 2015 UTC,You don't appear to be null-terminating each row of outLine? That could explain the lines running onto each other.
C_Programming,37y2ln,OldWolf2,1 point,Tue Jun 2 07:04:11 2015 UTC,"You didn't show how outLine is declared but I'm guessing it is char outLine[LARGENUMBER][41].  If you want to support strin being longer than 40, and assigning output to multiple lines (both justified) then you are going to have to introduce another function which calls the existing justify twice (or more) for each chunk. It could look like this:  void justify_inner(char strin[], size_t len) { // your existing code here, with minor modifications to get the  // length from ""len"" instead of treating strin as a null-terminated string }  void justify(char strin[]) {     size_t len = strlen(strin);     while ( len > 40 )     {         justify_inner(strin, 40);         strin += 40;         len -= 40;     }     justify_inner(strin, len); }"
C_Programming,37z6sc,MrsTeddyBear,14,Sun May 31 17:22:54 2015 UTC,"How would you, as a human compute that?"
C_Programming,37z6sc,cym13,5,Sun May 31 17:28:17 2015 UTC,"I honestly don't know. For example, I can just say the package weights 70 pounds. So that's an additional 60 pounds which makes it 3.00 dollars for a total of 13.00 to ship. I don't know what math equation I would need to write to get the computer to understand my logic."
C_Programming,37z6sc,cym13,12,Sun May 31 17:44:39 2015 UTC,"A computer can only do what to tell it to, so as long as the problem isn't clear to you, you can't tell it how to solve it.  Try to write your computations of the shipping price of a 70pounds package more rigorously, one step after another. Decompose. Do it on paper. Then do it with another package. No matter how easy it may seem, don't try to be smart (because a computer isn't) and just write it as clearly as possible.  Once you're done with that, just translate each step into C."
C_Programming,37z6sc,SrPeixinho,4,Sun May 31 17:51:38 2015 UTC,I wish I had your patience not to just give the answer. Damn I'm a bad teacher.
C_Programming,37z6sc,Jack126Guy,3,Sun May 31 18:56:16 2015 UTC,I figured it out. Weight = (var-10)/10 x .5 + 10 and the computer seems to calculate it correctly. Thanks for the help. :)
C_Programming,37z6sc,sebuelias,2,Sun May 31 19:11:44 2015 UTC,"if the weight of the package is 10 pounds or more it costs 10 dollars plus .50 for each additional 10 pounds.    That statement has an ""if"" in it. So check the condition (the weight of the package is 10 pounds or more) in your program."
C_Programming,380qd7,Faymus,6,Mon Jun 1 00:18:24 2015 UTC,"This is a C programming sub.  However the following lines are not valid in C:  #include <cstdlib> #include <iostream> using namespace std;   Those lines look like C++, however your program is not valid in C++ either due to the use of variable-length arrays.  Your program is not idiomatic for C++, and you're posting on a C sub, so I am assuming you want to write in C. To achieve that, remove the above three lines, and make sure you are using a C compiler, not a C++ compiler."
C_Programming,380qd7,OldWolf2,0,Mon Jun 1 01:14:02 2015 UTC,"I am trying to program in C. I am using netbeans on a Mac , and the first line is inserted as soon as I open a new project. The other 2 lines my professor instructed us to use. I commented the lines out right now, and it still runs. Thanks. still not finding elements that are the same though."
C_Programming,380qd7,OldWolf2,2,Mon Jun 1 01:30:51 2015 UTC,"There must be some kind of miscommunication , as those lines cannot be used in C.  Try to save your file as "".c""  (and not "".cpp"" or "".C""), that might fix the compiler issue."
C_Programming,380qd7,FUZxxl,0,Mon Jun 1 01:46:15 2015 UTC,"I just checked Netbeans and it says C/C++ project, so they might do it for convenience, and let the enduser take out the ones they will not be using I guess."
C_Programming,380qd7,OldWolf2,3,Mon Jun 1 01:52:17 2015 UTC,"No, that's not the case. The IDE creates a C++ project for you, not a C project."
C_Programming,380qd7,OldWolf2,3,Mon Jun 1 23:25:31 2015 UTC,"Your loops using feof are all wrong, see here for explanation.  Instead the loop test condition should be a read operation, and the loop breaks when the read fails.  Later on there is a buffer overrun:  int item[lines];  for (i=0; i<=lines; i++) {      // ...     printf(""%d\n"", item[i]);   Arrays of dimension lines have valid indices 0 through lines-1, so the last iteration of this loop will read beyond the end of the array.  The for(j=0;j<= records;j++) loop has the same problem.  Next: the loop that reads file should also check that i < lines to avoid array overflows. If your file had any lines that contained more than 2 ints then you would overflow your arrays. You probably should also abort in this situation.  The test if (feof(file)) is redundant because the only way execution can reach that point is if feof(file) is true. That test should just be removed and its code block out-dented.  The printf(""file not found""); is bogus: it's currently unreachable; and if the file really were not found then fopen would have failed -- which you should be checking for.  Finally, any of the scanf could be failing, you never check its return value.   Once you have fixed all of these problems: if the problem still recurs then use your debugger and step through the comparison loop, inspecting the values in the comparison to check that they are what you expect.   I see that you have inserted some debugging printf statements to output your variables. But you haven't said whether those are outputting what you expect or not. It would be helpful to post a sample input along with the complete program output showing the problem (but again, don't bother doing this before fixing the above errors).  This link may be useful: How to debug small programs"
C_Programming,380qd7,panderingPenguin,0,Mon Jun 1 01:06:59 2015 UTC,"see here for explanation   Thanks for your help! I really appreciate it, and I will read the mentioned material. My program compiles, runs, and outputs fine, but it does not do the check and update of the stock items. I did put in prints to see where it is going wrong, and it isnt reading past the first element in the first array for some reason.              Widget Corporation     Transaction Report as of May 30, 2015     Item Number     Amount in Stock     1112            32     1212            15     1241            7     1562            25     1822            106     1900            12     2100            48     How many records do you wish to process?     2     Please enter item number to process     1112     Please enter quantity to process     2     Please enter item number to process     1212     Please enter quantity to process     5   7  1112             2100  1112             2100  1212             2100  0                 2100  7  0                 32767  1112             32767  1212             32767  0                32767  7  0                0  1112             0  1212             0  0                0  0                0  deep loop        Item number 0 and qty of 127371377 new qty -127371377  7  0                0  1112             0  1212             0  0                0  0                0  deep loop        Item number 0 and qty of 1 new qty -127371377  7  0                1479047536  1112             1479047536  1212             1479047536  0                1479047536  7  0                32767  1112             32767  1212             32767  0                32767  7  0                -1892260673  1112             -1892260673  1212             -1892260673 0                -1892260673  7  0                32767  1112             32767  1212             32767  0                32767"
C_Programming,37wr5m,c_user05302015,5,Sun May 31 01:16:20 2015 UTC,"Do you have all warnings enabled on your compiler? I usually make it a point to compile everything at least once under -Wall -Wextra -pedantic, because they catch a lot of subtle bugs. That said, the compiler is unlikely to be of help here; you'd need a static code analyzer to catch this one.  You're heap-allocating network_driver, but in the call to malloc, you're only asking for 8 bytes:  malloc(sizeof(NetworkDriver *))   You should be asking for the size of the structure, not the size of a pointer to the structure. Common mistake; we've all made it a dozen times.  For your second error, you'll have to show us the rest of your code; where is packetdescriptor.h?"
C_Programming,37wr5m,acwaters,6,Sun May 31 01:27:23 2015 UTC,"Further info: a good idiom for malloc is to write  network_driver = malloc( sizeof *network_driver );   Then you know you are mallocing the right amount of space, the only thing you have to watch out for is that you don't forget the * !   With the pattern p = malloc(sizeof(Typename)); it is not immediately obvious whether the right amount of space has been allocated; the reader has to fish around in the code for the declaration of p and also this is fragile code because you might later change the type of p and overlook making adjustment to this malloc."
C_Programming,37wr5m,OldWolf2,1 point,Sun May 31 02:00:22 2015 UTC,"Hey, thanks for the reply! I've got all those compiler flags set up.  When I malloc the size of the structure, I get slightly different output from Valgrind: http://pastebin.com/MUYfMNN2  There's a lot of other various files, but here's packetdescriptor.h: http://pastebin.com/kaP8NJxG"
C_Programming,37wr5m,acwaters,2,Sun May 31 02:00:50 2015 UTC,"Why do you have a big block commented out in init_network_driver? In that block is an allocation for network_diver->pd. With that commented out, pd is a pointer to random memory. You're not showing us most of the code; without seeing the implementations for init_packet_descriptor and packet_descriptor_set_pid, the best I can do is a guess that one or both of them expect a valid pointer."
C_Programming,37wr5m,dragon_wrangler,2,Sun May 31 03:29:21 2015 UTC,"/facepalm  That was it, I had commented out that block when rewriting parts of the function and forgot to put that in.  Thanks for all your help! I'm running into another segfault with another part of the program (line 90), but it's entirely unrelated so if I need help later I'll create another post."
C_Programming,37wr5m,tmtwd,6,Sun May 31 03:46:44 2015 UTC,"Once your problem is solved, it's generally considered polite to leave your post up so that other people can search for the same problem you had."
C_Programming,37wr5m,Hellrazor236,1 point,Sun May 31 06:16:46 2015 UTC,"Yeah, I was looking forward to this post!"
C_Programming,37wr5m,DSMan195276,4,Sun May 31 14:01:05 2015 UTC,Please don't remove your question when it has been answered! This makes your question useless for all future visitors of this thread.
C_Programming,37v5te,TheAvengingKnee,6,Sat May 30 17:42:04 2015 UTC,"Obligatory do not ever ever ever ever ever ever use gets(). It has no acceptable uses under any possible circumstances. fgets(s, sizeof s, stdin); is what you want instead of gets(s); (Actually, your compiler should be giving you a warning if you ever try to use gets)  Your program definitely gives output. You only have two errors beyond gets: (1) your for loop should be testing for <, not <=; and (2) you should be printing spaces between each number. Beyond that, it works well, though.  Why do you think it's not producing output? Where are you looking for the output?"
C_Programming,37v5te,OlderThanGif,1 point,Sat May 30 17:57:23 2015 UTC,"well the printf should print something in my program nothing comes out, now it acts like it is not finding the file in the same directory as the c program."
C_Programming,37v5te,dragon_wrangler,1 point,Sat May 30 18:03:37 2015 UTC,"Why don't you post a screenshot of that error, there shouldn't be an issue opening that file if it exists."
C_Programming,37v5te,poundSound,1 point,Sat May 30 18:29:00 2015 UTC,the error is just the one I have written in the code if the file cant be opened.
C_Programming,37v5te,MotuProprio,1 point,Sat May 30 19:55:47 2015 UTC,"A common problem I've found on Visual Studio, although may apply to other IDEs: If you're on a network drive and you start the programme without debugging, it starts in a default location, not in the folder with your data file. If this is the case try running with the debugger so that your IDE runs the programme and can do relative paths for you."
C_Programming,37v5te,MotuProprio,1 point,Sat May 30 20:58:48 2015 UTC,I've just run it myself and it's worked. Your code lacks some newline characters and repeats the last number twice though. But it works.  You may want to define your string size with a constant defined with #define. It's more convenient.
C_Programming,37v5te,lishyguy,1 point,Sat May 30 18:02:04 2015 UTC,"When I try to read the file it gives me the error for null. the file name is nums.dat, but it does not seem to find it."
C_Programming,37w2ri,learningC2015,1 point,Sat May 30 21:51:50 2015 UTC,What is your question?
C_Programming,37w2ri,FUZxxl,1 point,Sat May 30 22:57:09 2015 UTC,"I'm trying to make is so that when \t is read from the file, I can replace the output with something else.  In the code above it should be when \t is read from the file the code will output ""there is a tab!""."
C_Programming,37w2ri,raevnos,1 point,Sat May 30 23:19:00 2015 UTC,"Is it not working?  Also: ch is an int, right?"
C_Programming,37w2ri,raevnos,1 point,Sun May 31 06:36:21 2015 UTC,"Correct it is not working, it will take the else branch even when \t is taken in from the file. Also yes ch is an int."
C_Programming,37vo7s,jkudria,3,Sat May 30 19:59:29 2015 UTC,"I'm a little unsure what you're getting at here.   I was wondering if I could have a Data union that includes different data types of the same size (i.e. a char array, a float, etc.)   Remember if multiple datatypes need to be put into a stack, you'd have to create a stack for each data type, since a union only allows a single datatype to be used.  You basically answered your question yourself. From my point of view, I am not sure why I'd use a generic stack (although I am sure there are some reasons), but yes. You should be good!"
C_Programming,37vo7s,Pants__Magee,2,Sat May 30 20:25:07 2015 UTC,"I implemented a stack well enough, but the fact that I can use it with only one data type (e.g. int) bugged me - I was just thinking if there was a simple-ish way to write it to be able to contain multiple different data types (e.g. an int and a char *)"
C_Programming,37vo7s,Pants__Magee,2,Sat May 30 22:27:12 2015 UTC,Why not create a stack as a void *? That way you can send a pointer of whatever datatype you want to it. That's probably the best way for it to be generic.
C_Programming,37vo7s,Wetbung,1 point,Sun May 31 02:50:09 2015 UTC,"Hm. Didn't think of that. I've grasped pointers, but I haven't yet gotten used to employing them properly..."
C_Programming,37vo7s,acwaters,3,Sun May 31 04:32:05 2015 UTC,"I'm not sure what ""this sort of thing"" is. What you are describing will work, but what is the purpose? If you are trying to come up with a typeless variable I think you will find that this makes for more work than just keeping track of types unless you have some special reason for doing this.  If you want to try making a typeless variable, consider that you will have to manually keep track of the actual type stored in each union and then consider all of them each time you do anything with the union. Here is a quick start to what I think you are asking about. Just dealing with something simple like an addition would be complicated and unless there is a good reason for doing it, I wouldn't suggest it."
C_Programming,37vo7s,smorrow,1 point,Sat May 30 20:33:01 2015 UTC,"The purpose is to experiment and see what I can do with C :)  The thing is, I wouldn't have any operations on the data itself - it's just data storage in a stack. Granted that could still get a tad more complicated and things could spin out of hand pretty quickly."
C_Programming,37vo7s,acwaters,3,Sat May 30 22:28:34 2015 UTC,"Sounds like you're trying to use variant types to hack a sort of generic programming into C. This is extremely dangerous.  What you're trying to do is properly called parametric polymorphism. You may have seen it in action in C++, C#, or Java; most modern statically-typed languages have evolved some native support for type polymorphism, as programming without is one of the least DRY things you could possibly do.  Unfortunately, C is not a modern language, and it unapologetically supports no type-safe polymorphism whatsoever. Your options are (1) create everything explicitly and suck up the extra typing; (2) use macros to preprocess a set of tokens into qualified type names for you; or (3) exploit unions, void pointers, varargs, and aliasing to subvert the type system entirely. (1) is the route that is normally taken by C programmers, though (3) is occasionally used and endorsed in the professional community, usually in library solutions -- cf. malloc, printf, sockaddr, and others. In general, avoid doing (3) yourself with extreme prejudice. (2) is an alternative solution, but it usually makes for ""feature""-rich code that is hard to read and harder to maintain.  In short, C is a dumb language; it gives you very little in the way of high-level features, and those who use it tend to like it that way, as they usually want access to low-level implementation details without restrictions or surprises. Not that C doesn't also have its fair share of those, but they are in general well-known, well-documented, and commonly subverted in real-world implementations."
C_Programming,37vo7s,Pronouns,2,Sun May 31 01:01:01 2015 UTC,"Sounds about right, since I come from a very high-level language - Python. I understand C's limitations (advantages?) - I was simply playing around to get a feel for what I can and cannot do. I tend to learn a language by, well, playing around. Turns out doing this is not as simple as I expected..."
C_Programming,37vo7s,bunkoRtist,1 point,Sun May 31 02:32:11 2015 UTC,"(3) exploit unions, void pointers, varargs, and aliasing to subvert the type system entirely.   Making it explicit: once you start doing this, it isn't even valid C.  Russ Cox: https://news.ycombinator.com/item?id=7647520"
C_Programming,37s7sx,franklesby,4,Fri May 29 23:35:43 2015 UTC,This shit is the reason why I don't suggest beginners to learn C programming on Windows.
C_Programming,37s7sx,FUZxxl,1 point,Sat May 30 09:45:26 2015 UTC,"The problem isn't Windows, it is poorly written *nix programs ported to Windows extremely poorly. *nix dev's do not understand the Windows kernel, file system, or good programming habits for Windows, nor how to build proper installers (if they even bother), thus every *nix port I've ever used sucks and sucks bad. There is no better platform to learn programming than Windows. It has the most well-written and supported free IDE's, compilers, tools, debuggers, and hyper-visor support. VMWare Workstations debugger integration only works on Windows and is by far the greatest piece of debugging software ever created by mankind. Even *nix devs & fanboy's like John Carmack develop all of their software in Windows for these reasons. Malware reverse-engineering, no matter the target platform, takes place exclusively in a Windows environment. Every RE tutorial you read will almost certainly be about using a Windows-based software tool. Hell the satellite OS and software we wrote last year was entirely created and debugged on a Windows 7 box."
C_Programming,37s7sx,angdev,1 point,Mon Jun 1 22:24:14 2015 UTC,"The error means that your program is linked against the shared/dynamic version of the libgcc runtime library, but that library cannot be located by the operating system when the executable is run.  The operating system uses PATH (among other things) to locate dynamic libraries, and generally speaking this problem should be solved by putting the directory that contains that DLL in the PATH.  (It can also be solved by putting the DLL in the same directory as the executable, but obviously that would be stupid in this case because you'd have to be constantly making copies of it for every project.)  Is that directory in your PATH?  If so, you should check the value of PATH that Eclipse is using when it runs the program, because it could be modifying the PATH and removing essential components.  (Remember that environment variables are inherited from parent to child.)  If not, you need to modify your PATH and re-start Eclipse.  You can also link against the static version of that library by adding -static-libgcc to your link command."
C_Programming,37s7sx,Rhomboid,1 point,Sat May 30 00:23:10 2015 UTC,"How would I do that?  I've done it before, but I've always had the location of the file and the PATH it needed to be added to"
C_Programming,37s7sx,Rhomboid,1 point,Sat May 30 00:59:41 2015 UTC,"i uninstalled and reinstalled and can compile and run the programs, they just cant run in the eclipse console.  hmm..."
C_Programming,37s7sx,angdev,1 point,Sat May 30 03:24:46 2015 UTC,"If so, you should check the value of PATH that Eclipse is using when it runs the program, because it could be modifying the PATH and removing essential components."
C_Programming,37s7sx,Lisu,1 point,Sat May 30 03:38:30 2015 UTC,where is it located in eclipse settings
C_Programming,37s7sx,angdev,1 point,Sat May 30 15:04:14 2015 UTC,"Not exactly a solution to your problem, but have you heard of Pelles C compiler? It's generally considered the best C environment for Windows programming."
C_Programming,37s7sx,Lisu,1 point,Sat May 30 00:36:00 2015 UTC,"If I download Pelles, will I need to download anything else to make it work?"
C_Programming,37sa43,tmtwd,6,Fri May 29 23:54:38 2015 UTC,That code is incorrect since x should be an int *. Just make y an int * and set it equal to x.  int *x = malloc(sizeof(int)); int *y = x; *x = 5; /* *y also equals 5 */
C_Programming,37sa43,Meefims,0,Sat May 30 00:04:43 2015 UTC,oh yeah good point ! :)
C_Programming,37nea9,THRAKERZ0D,7,Thu May 28 22:29:20 2015 UTC,"General rule of thumb: using float when dealing graphics, since your human eye won't be able to see the difference. Use double with scientific computing, or anywhere precision actually matters. That's regardless of the platform.  On x64 you'll have better performance with single precision, depending on what you're doing and how you're doing it. For example, my student intern's raytracer is 17% faster when switched to single precision mode (compile-time switch). Theoretically you can see up to a 100% speedup with single precision, since twice as many floats can be packed into a single x64 SSE register (SIMD) -- though compilers generally don't emit packed SSE instructions without help (intrinsics).  Technically the same SIMD situation would apply to integers, but it's unusual to be using SIMD for lots of integer operations, so 32-bit integers are practically never going to be faster than 64-bit integers on x64. When it comes to integers, pick the size that suits the expected range of values, as others are saying. I use int64_t and uint64_t when I explicitly require a 64-bit int.  Beware that long on Windows is still only 32 bits wide on x64. (Yes, it's stupid.)"
C_Programming,37nea9,skeeto,5,Fri May 29 00:34:52 2015 UTC,"so 32-bit integers are practically never going to be faster than 64-bit integers on x64.   Not quite. Notice that a 32-bit integer takes half as much space as a 64-bit integer, leading to improved cache usage."
C_Programming,37nea9,FUZxxl,3,Fri May 29 07:16:00 2015 UTC,"Generally, you should not use variables of type float as double is to float as int is to short with respect to size expansion, that is, the machine does computations with double precision and rounds them down to float precision when writing the result. You should generally only use float variables if the space improvement is significant or if the loss of precision is negible.  You should not use long by default as int is still the native integer type. Use long where you would use long otherwise. main always returns an int, declaring main to return a long is undefined behaviour."
C_Programming,37nea9,FUZxxl,6,Thu May 28 22:37:58 2015 UTC,"the machine does computations with double precision and rounds them down to float precision when writing the result.   This isn't true on x64, where the old x87 instructions are no longer any practical use. Example: sqrtss vs. sqrtsd"
C_Programming,37nea9,skeeto,2,Fri May 29 00:37:45 2015 UTC,"Well, the C language specifies that this is what's supposed to happen. I know that implementations don't really stick to it."
C_Programming,37nea9,FUZxxl,2,Fri May 29 07:13:04 2015 UTC,"I'd have to look at the standard, but I believe what C specifies is that the result should be the same as if it were computed with more precision and then converted, not how it's implemented."
C_Programming,37nea9,boredcircuits,1 point,Fri May 29 16:05:28 2015 UTC,"I'd have to look at the standard, but I believe what C specifies is that the result should be the same as if it were computed with more precision and then converted, not how it's implemented.   When you use a float as an operand to an arithmetic operator, it's converted into a double. This is not being undone until something forces a conversion back to float, like you assigning the result to a variable of type float. Thus, this expression:  float a; /* ... */ float b = a * a * a;   may have a different result then  float a; /* ... */ b = a * a; b *= a;   because in the latter case, the intermediate result is rounded to float while it's kept as a double former case."
C_Programming,37nea9,FUZxxl,3,Fri May 29 16:12:02 2015 UTC,"From 6.3.1.8 Usual arithmetic conversions:   First, if the corresponding real type of either operand is long double, the other operand is converted, without change of type domain, to a type whose corresponding real type is long double.  Otherwise, if the corresponding real type of either operand is double, the other operand is converted, without change of type domain, to a type whose corresponding real type is double.  Otherwise, if the corresponding real type of either operand is float, the other operand is converted, without change of type domain, to a type whose corresponding real type is float.   And later:   The values of floating operands and of the results of floating expressions may be represented in greater range and precision than that required by the type; the types are not changed thereby."
C_Programming,37nea9,boredcircuits,1 point,Fri May 29 16:53:23 2015 UTC,Do you think this is different from what I said?
C_Programming,37nea9,FUZxxl,3,Fri May 29 17:00:20 2015 UTC,"Yes.  This part in particular:   When you use a float as an operand to an arithmetic operator, it's converted into a double.   No conversion to double occurs when both operands are float.  (I'll admit I'm not an absolute expert here, so feel free to prove me wrong.)"
C_Programming,37nea9,boredcircuits,1 point,Fri May 29 17:12:11 2015 UTC,"Ah yes, I missed that one. I got confused because of the argument promotion rules where float arguments are promoted to double."
C_Programming,37nea9,FUZxxl,1 point,Fri May 29 17:15:53 2015 UTC,No worries!
C_Programming,37nea9,boredcircuits,3,Fri May 29 17:31:33 2015 UTC,"In theory int is the native type, although some 64-bit systems still have int 32-bit."
C_Programming,37nea9,OldWolf2,1 point,Fri May 29 01:26:20 2015 UTC,"Even on these platforms, int is the “standard” integer type with respect to operand size expansion. Notice that typical 64-bit architectures can operate on 32 bit quantities just fine."
C_Programming,37nea9,FUZxxl,2,Fri May 29 10:47:24 2015 UTC,"Thanks you, this is exactly what I was looking for."
C_Programming,37nea9,GBGamer117,4,Thu May 28 22:47:00 2015 UTC,"In my personal opinion (and this really is a matter of opinion):   Use fixed size integers wherever possible, except:    Use a size_t if you're describing the size of an object. Use an intptr_t if you're converting to/from pointers Use the type that an external API tells you to use (i.e., return an int from main)    Use a [u]int32_t for any number that will never get near a billion Use a [u]int64_t for any number that will get near a billion Use unsigned types in counters and cases where you need defined overflow behavior. Otherwise, use signed types"
C_Programming,37nea9,FUZxxl,6,Thu May 28 22:47:37 2015 UTC,"Furthermore, use int when the size doesn't really matter and the values are going to be sufficiently small."
C_Programming,37nea9,Drainedsoul,1 point,Thu May 28 23:09:51 2015 UTC,Don't use int for values that should never be negative.
C_Programming,37nea9,FUZxxl,3,Fri May 29 02:48:45 2015 UTC,"It depends. Often it's easier to use int in such cases any way as you avoid weird behaviour when comparing numbers. Furthermore, the Google coding standard suggests to always use signed types unless there's a damn good reason not to."
C_Programming,37nea9,Drainedsoul,0,Fri May 29 07:14:35 2015 UTC,"Often it's easier to use int in such cases any way as you avoid weird behaviour when comparing numbers.   If you're doing this you should ask yourself two questions:   Why are you comparing a value that can be negative with a value that can't be negative?  Fundamentally you should be able to see those represent different values. Failing #1, doesn't the signed value being negative have some external meaning?  For example if you're trying to write or read in POSIX the size should be always positive (i.e. unsigned), however the return value is signed because -1 is reserved to indicate an error.  Just straight up comparing them ignores this distinction and misses handling the error path correctly.    Furthermore, the Google coding standard suggests to always use signed types unless there's a damn good reason not to.   That's not a compelling argument.  The Bible says to do a lot of things as well, does that mean that we should just do them unquestioningly?  Types should convey something semantic about what they represent.  If I just see an int I see a value that could be positive or negative.  If I see int age it raises questions: What do the negative values mean?  If I see unsigned int age it's unambiguous, I can infer exactly what values the variable can have and what they mean from the type and name alone."
C_Programming,37nea9,FUZxxl,2,Fri May 29 15:10:59 2015 UTC,"Why are you comparing a value that can be negative with a value that can't be negative? Fundamentally you should be able to see those represent different values.   The natural numbers are extended to the integers giving a meaningful value to meaningless expressions such as 3 - 5. Even when the range of valid input values does not contain any negative numbers, computations on the input data can often result in negative values. A common example is this loop that does thing() on the numbers from n-1 to 0 in descending order:  for (i = n - 1; i >= 0; i--)     thing(i);   If i is an unsigned variable, this loop loops indefinitely. Indeed, it's tricky to change the loop so it works with an unsigned counter. For instance, one could use a do-while loop:  i = n - 1; do {     thing(i); } while (i--);   or one could loop from i = 1 to n:  for (i = n; i > 0; i--)     thing(i - 1);   or one could give special treatment to the i = 0 case. A subtle bug is also introduced when n is zero; for an unsigned i, this causes the loop to go on for UINT_MAX times. All these problems can be avoided by making i a signed variable.   Failing #1, doesn't the signed value being negative have some external meaning? For example if you're trying to write or read in POSIX the size should be always positive (i.e. unsigned), however the return value is signed because -1 is reserved to indicate an error. Just straight up comparing them ignores this distinction and misses handling the error path correctly.   I'm not sure what your argument is supposed to mean. If write was to return an unsigned variable, one could not easily tell apart errors from success—technically, one could use 0 for “error” as a call to write with non-zero length is guaranteed to either fail or write at least one byte, but the convention for all system calls is to return -1 on error—regardless of result-type. Incidentally, you find mmap returning (void*)-1 on error.   That's not a compelling argument. The Bible says to do a lot of things as well, does that mean that we should just do them unquestioningly?   The people who wrote Google's coding standards aren't stupid and there are a lot of good reasons for their rules. I understand that this is an “appeal to authority” but it's important to understand that others deem it good style to use signed types whereever possible.   Types should convey something semantic about what they represent. If I just see an int I see a value that could be positive or negative. If I see int age it raises questions: What do the negative values mean? If I see unsigned int age it's unambiguous, I can infer exactly what values the variable can have and what they mean from the type and name alone.  Types should convey something semantic about what they represent. If I just see an int I see a value that could be positive or negative. If I see int age it raises questions: What do the negative values mean? If I see unsigned int age it's unambiguous, I can infer exactly what values the variable can have and what they mean from the type and name alone.   You are correct in the regard that an age cannot be negative, but the difference of two ages is likely negative but if you subtract two objects of type unsigned from one-another, you always get a positive value. The C language does not really provide a system to ensure that only valid values be stored in variables and abusing the signed-ness of a variable for this purpose is often rather unproductive. Furthermore, the guarantee that the value is positive isn't even useful: If someone attempts to store a negative age, it just wraps around, creating an invalid age that looks valid instead of an invalid age that can be caught with a simple test.  The type systems of most modern programming languages unfortunately mix up representation with aspect, where representation is how the compiler needs to treat a datum (e.g. as a 32-bit signed integer in two's complement representation) and aspect is how that datum is supposed to be used in the program (e.g. as a velocity). In these type systems, the aspect of a datum implies its representation and the type of the result of operators is usually the type of the arguments to that operator. This is often not sensible (and also generally false for the C language); for instance, it doesn't make sense to see the difference between two data of aspect age as an age."
C_Programming,37nea9,Drainedsoul,1 point,Fri May 29 16:01:01 2015 UTC,"Even when the range of valid input values does not contain any negative numbers, computations on the input data can often result in negative values.   Don't perform those computations.  Or, if you need to, that's a compelling reason to use a signed integer.  In your example of the age, how often do we care that the difference between a 30 year old and a 35 year old is technically -5 years?  Usually we only care about the absolute value of the difference, which doesn't require negative numbers.   A common example is this loop that does thing() on the numbers from n-1 to 0 in descending order   There's a well established C idiom for this:  for (size_t i=n;(i--)>0;) {  }   Problem solved.   If write was to return an unsigned variable, one could not easily tell apart errors from success   My point was that write returns a signed value, which means it represents something fundamentally different than the unsigned size you pass into it.  Comparisons between these values aren't well defined (which was your argument for using signed types: So you can easily compare them with other signed values) because they don't actually represent the same thing.  The only time it makes sense to compare the value returned by write to the size (which is unsigned) is after you've checked and handled the -1 (i.e. error) case.  In this case you're guaranteed that the value is strictly positive, so you're free to cast it to an unsigned type and proceed with your comparison between values which now actually represent the same thing.   technically, one could use 0 for “error” as a call to write with non-zero length is guaranteed to either fail or write at least one byte   Depending on what you mean by ""fail"" this isn't true: When a TCP socket is closed gracefully write operations will succeed and write 0 bytes, which signals end of stream.   abusing the signed-ness of a variable   You're not abusing anything.  The domain of ages is strictly positive, why would you choose a type that can uselessly represent negative values to hold it?  It's the same (and even more compelling) for sizes.  size_t is unsigned, and yet I see C/C++ code where people use int instead constantly."
C_Programming,37nea9,FUZxxl,1 point,Fri May 29 23:14:10 2015 UTC,"Don't perform those computations. Or, if you need to, that's a compelling reason to use a signed integer.   You often don't know when you're going to perform such computations and sometimes you try to do so and they silently return wrong results because you forgot that the type was unsigned. It's often not easy to see which computations may involve negative numbers (for example, see the loop I postet). The compiler can some times warn you about this but that doesn't always happen.   In your example of the age, how often do we care that the difference between a 30 year old and a 35 year old is technically -5 years? Usually we only care about the absolute value of the difference, which doesn't require negative numbers.   Of course a signed difference is super useful. For example, we could switch on that signed difference to do different things depending on that age difference. This is so important that C has a special case in the - operator: subtracting two pointers yields a (signed) ptrdiff_t, whereas the numeric type for pointers is an uintptr_t.   There's a well established C idiom for this: [...] Problem solved.   That's horrible code which wouldn't get through code-review (if I were to do it) because it perverts the conventions of a for-loop and because it's not valid C89. Again, I didn't say it's not possible to write that loop, I just said it's going to look uggly and the obvious way doesn't work, which is something the programmer needs to recognize.   Depending on what you mean by ""fail"" this isn't true: When a TCP socket is closed gracefully write operations will succeed and write 0 bytes, which signals end of stream.   That's a fair point. I forgot about that case.   The domain of ages is strictly positive, why would you choose a type that can uselessly represent negative values to hold it?   I've already explained it in the parent comment: An age itself may not be negative but computations you do on ages may involve negative values, so it's a good idea to make these computations possible.   It's the same (and even more compelling) for sizes. size_t is unsigned, and yet I see C/C++ code where people use int instead constantly.   POSIX has ssize_t for precisely that reason."
C_Programming,37nea9,Drainedsoul,1 point,Fri May 29 23:34:39 2015 UTC,"you forgot that the type was unsigned   I don't really see how this is a convincing argument.  I could equally make an argument against signed types by saying that you might overflow them and invoke UB instead of well-defined behaviour because you forgot you were using a signed type.  If a programmer is incapable of comprehending the program and types at play it indicates either poor code or a poor programmer.   This is so important that C has a special case in the - operator: subtracting two pointers yields a (signed) ptrdiff_t   Which, as far as I'm concerned, is a flaw in C: What happens when you try and get the distance between two pointers which are further apart than PTRDIFF_MAX?   If an array is so large (greater than PTRDIFF_MAX elements, but less than SIZE_MAX bytes), that the difference between two pointers may not be representable as std::ptrdiff_t, the result of subtracting two such pointers is undefined.   Wonderful.   it perverts the conventions of a for-loop   Then refactor it into a while loop.   it's not valid C89   What year is it?   POSIX has ssize_t for precisely that reason.   Which, unlike size_t cannot represent all sizes.  Adding signedness to a nice, neat, unsigned guarantee just makes it messy: size_t can represent any size, ssize_t can't.  Pointers can point anywhere in memory (being at least conceptually of unsigned type uintptr_t) but the difference between them, being signed, can't represent the difference between arbitrary pointers.  Ultimately, when it comes to sizes, using signed types involves a lot of ""that will never happen"", and the history of programming is so littered with examples of things that would ""never happen"" but somehow did that you'd think people would know better."
C_Programming,37nea9,bunkoRtist,2,Fri May 29 23:52:57 2015 UTC,"There's definitely no reason to restrict your data types to ""only"" longs and doubles. By using the native size of the compiler I think you'll get the most consistent speed across platforms, but it might or might not be faster than using a smaller fixed size. On some machines, the memory bus can load multiple addresses in parallel, but again... that's all machine+compiler-dependent. My guess is that since these differences will typically be negligible for general-purpose programming, if you needed these incremental improvements enough that it was worth coding in a target-optimized way, you'd already know. If you happen to have a critical section of code that's doing heavy-duty stream processing it might be worth considering this again."
C_Programming,37nea9,angdev,2,Fri May 29 04:42:43 2015 UTC,"No. No. Yes. You could see a reduction in performance, and an increase in code-size. Integers should always be unsigned unless signed math/comparison is needed. Unsigned operations can be faster than signed."
C_Programming,37nea9,BigPeteB,2,Fri May 29 23:07:35 2015 UTC,"I hardly ever touch floating-point, but I work on code that has to be highly portable, so I've learned a lot about the size of fixed-point types.  Taking your question literally, ""Should I only use longs on x64?"", the answer is ""No, don't do that.""  Don't naively substitute long for int every place you see it. Sometimes long might be a better choice, but honestly when you start caring about the sizes of types, there's almost always a better choice.  Here are some general suggestions I've come up with:   Match existing APIs. Plenty of them consume or return int, and you should continue to do this. main() is required to return an int, so returning a long is bad. On rare occasions, don't match existing APIs. The code I work with has a portability layer so it can run on top of POSIX, Windows, etc. But while they have similar APIs, in some cases POSIX uses size_t where Windows uses long, or other silly things like that. In those cases, I generally solve the problem by picking the most sensible type (often size_t, but not always) and making a small function to check the arguments and convert as needed. Use fixed-size types where needed. If you're writing network protocols, they always specify integers as a particular number of bits (32, 16, or whatever). Use the C99 types for those exact sizes. Learn the C99 semantic types and use them. Some of them are much more specialized than people often realize, so knowing these limitations can be important. For example, size_t is a ""count of contiguous bytes"", such as array sizes. On 8086 and 80286 this would have been a 16-bit value due to segmented addressing, even though those could address 20 and 24 bits worth of memory respectively. Similarly, ssize_t is a ""count of bytes consumed/returned or a negative error value"". It's common to have a size_t argument and ssize_t return value. But because one is unsigned and the other is signed, you have to check the range of your argument! If someone asks to operate on 3GB of data but your return value is ssize_t, you can only indicate that you operated on at most 2GB. As for other types like intptr_t and ptrdiff_t, I found that I rarely needed them; there's usually a way to do things without explicitly using those types. Typedef your own types as needed. If you're returning an int as an opaque handle (even if it's really just an index into an array), typedef it. Then if you decide to make it shorter or longer (or change its type entirely), the typedef will protect callers from the change. For anything that's left, you could just use int as the ""default"" type, but if it doesn't hurt anything, consider picking an explicit type like int32_t. Lastly, if you're going to use bare types, prefer int instead of long. int has been the same size from the 80386 all the way through modern 64-bit processors and will continue to be for quite a long time, whereas Windows and Linux don't agree on how big long should be on a 64-bit platform."
C_Programming,37nea9,inhuman4,3,Mon Jun 1 14:02:10 2015 UTC,"The bit width of a system is determined by the size of the general purpose registers. So a 64bit machine deals with 64bit chunks as the minimum size. For this reason it is best to use int which tells the compiler to use the native size for the target CPU. This is the most efficient way since it lets CPU work in its native format. Double vs float is really up in the air, if you are only targeting 64bit go with double, otherwise just decide what level of precision you need and go with that. Also a side note: pointers will always be in the native format regardless of what they are pointing to. Same as 1. Go with the native format, and let the compiler decide what 'native' means at compile time. If you are an embedded developer like me the whole size things matters a lot. I have code that runs on chips spanning 8bit to 64bit. In this arena it makes a huge difference because 8bits = 255 max so it is easy to overflow counters. Typically we use <stdint.h> which provide uint32_t, int64_t, int8_t, etc. Which lets us manually define sizes for each variable. So if I have to make a counter than goes from 0->1000 I would use at uint16_t, which makes it less efficient on a 32bit machine, but guarantees that it will work on an 8bit machine.  Personally I always make my counters unsigned. This will generate compiler warnings when I try to store a signed variable in an unsigned variable, which in turn forces me to double check that I don't accidentally put a signed value where it shouldn't belong."
C_Programming,37nea9,drobilla,6,Thu May 28 23:47:36 2015 UTC,"So a 64bit machine deals with 64bit chunks as the minimum size. For this reason it is best to use int which tells the compiler to use the native size for the target CPU.   This is not what int means.  It is larger than (or equal in range to) a short, and smaller than (or equal in range to) a long, and capable of storing at least 0..65535 when unsigned.  That's all.  In practice, on x64 on all major platforms, int is 4 bytes, i.e. 32 bits, not 64 bits."
C_Programming,37nea9,inhuman4,1 point,Fri May 29 08:25:49 2015 UTC,TIL
C_Programming,37nea9,GBGamer117,1 point,Fri May 29 13:57:38 2015 UTC,"This is usually so (at least AFAIK) you can have a type of each width. char = 8, short = 16, int = 32, long(Unix)/long long(Windows) = 64.  I may be wrong."
C_Programming,37nea9,FUZxxl,1 point,Fri May 29 17:12:16 2015 UTC,"No, you're completely right. The first UNIX ports for 64 bit machines actually used a 64 bit int type and it was a disaster because programmers had to resort to unportable extensions (C99 wasn't around back then) to get a 32 bit int and generally required fix-ups."
C_Programming,37nea9,f5f5f5f5f5f5f5f5f5f5,2,Fri May 29 23:39:28 2015 UTC,"Where I work, we're either dealing with single board computers or network stuff. So the size of the integral types are limited to valid values."
C_Programming,37nea9,angdev,1 point,Fri May 29 00:55:55 2015 UTC,"So if I have to make a counter than goes from 0->1000 I would use at uint16_t, which makes it less efficient on a 32bit machine, but guarantees that it will work on an 8bit machine.   For for-loops/counters on embedded systems where optimizations are necessary use uint_fast16_t (for your example of 0..1000). The uint_fastN_t types are guaranteed to be at least the size specified, but will be placed in larger native registers if possible (usually with the benefit of increased performance and reduced code-size)."
C_Programming,37nnd0,rhascal,6,Thu May 28 23:38:33 2015 UTC,"Most of that sounds like file I/O in general. If you must do it in plainest possible C you probably ought to look at the standard functions in stdio.h, but depending on target platform they might be elsewhere.  For images (loading and displaying) look at SDL. Loading and displaying an image isn't that difficult:  http://lazyfoo.net/tutorials/SDL/07_texture_loading_and_rendering/index.php (Most of that code is error handling, which you of course needs, but it hides the fact that the code that does something is just a few lines really.)  There might even be some part of SDL, or some extension for it, that helps you with saving games. There definitely are functions in there to help with drawing text and reading player input (in a platform-independent way).  C might not be the best choice, in general, for that type of game, but I guess you did not come here to ask about that. Overall if you want ideas for how to implement a game a better place is probably /r/gamedev anyway (and in this case perhaps also /r/gamebooks)."
C_Programming,37nnd0,livrem,3,Fri May 29 07:16:36 2015 UTC,Thanks! C is my only language currently and it is what I study in school. I just felt like doing a fun project for practice.
C_Programming,37nnd0,MatterMass,3,Fri May 29 09:00:45 2015 UTC,"C is a great language to do something like this in. Not because it is the easiest language to do it in, but because it will teach you about what goes on that other languages do automatically for you."
C_Programming,37nnd0,livrem,2,Fri May 29 18:08:24 2015 UTC,"But that translates to ""this is a great project for learning C"" rather than ""this is a great project for using C"". I actually think C is great for making games in general, but when there is a lot of text and static images it seems so much easier to just use JavaScript+HTML for instance (like I have done). Makes it easier to get to run on more platforms, and 90 % of all the work is already taken care of because all the graphics expected to go into a gamebook is sort of what a browser-engine already does.  But for learning C... great! It is probably a lot more fun than to do it in HTML as well."
C_Programming,37nnd0,Hellenas,3,Sat May 30 21:32:37 2015 UTC,"Since livrem already mentioned SDL, I'm going to toss out here Allegro, but  I definitely prefer SDL of the two.  The way you're handling the graphics is pretty simple, so you won't have a tough time picking up either.  Lazfoo has a good series on SDL (and I just noticed liverm already linked him, sorry).  You can find tutorials on youtube for allegro pretty quickly IIRC.  I've been using SDL a lot as of late in C specifically (as opposed to C++ which I think is more common for it and games in general), so if you have any questions about SDL specifically feel free to message me and we can probably figure out what's going on.  It's pretty fun to use!"
C_Programming,37nnd0,OldWolf2,2,Fri May 29 12:16:52 2015 UTC,Great thank you!
C_Programming,37ofv7,SLXShujo,2,Fri May 29 03:30:31 2015 UTC,"Just a tip, instead of:  system(""pause"");   use:  getchar();       There is multiple reasons to use getchar() and it probably doesn't matter for you right now, but you might as well make it a habit."
C_Programming,37ofv7,hust921,1 point,Fri May 29 16:21:34 2015 UTC,"you're calling return before calling ""system(""pause"")"", that way the execution ends before pausing it. try this :  include<stdio.h> include<time.h> include<conio.h> include<stdlib.h>  int main(void) {      time_t seconds;  seconds = time(NULL);   printf(""Hours since January 1, 1970 = %ld\n"", seconds/3600);  system(""pause"");   return(0); }"
C_Programming,37ofv7,Plets,1 point,Fri May 29 04:03:21 2015 UTC,"thanks man, XD such a fail there, this helps me a lot"
C_Programming,37ofv7,Plets,2,Fri May 29 04:10:34 2015 UTC,"You're welcome ! everyone makes these mistakes one time or another, if you need anything feel free to pm me."
C_Programming,37ofv7,chenshuiluke,1 point,Fri May 29 04:17:11 2015 UTC,"Well, since you want it to execute every x seconds, you're gonna need a loop that sleeps for a period of time. Try this:  #ifdef _gnu_linux__         #include <unistd.h> #endif #ifdef _WIN32         #include <windows.h> #endif #include <stdio.h> #include <stdlib.h> #include <time.h>  void mySleep(int sleepMs) {         #ifdef __gnu_linux__                 usleep(sleepMs * 1000);   // usleep takes sleep time in us (1 millionth of a second)             #endif             #ifdef _WIN32             Sleep(sleepMs);         #endif } int main() { time_t seconds; seconds = time(NULL);  int delay = 1000; while(1) {     printf(""Hours since January 1, 1970 = %ld\n"", seconds/3600);     mySleep(delay); } system(""pause"");  }     Remember, 1000ms = 1s."
C_Programming,37ofv7,theropfather,1 point,Fri May 29 05:56:01 2015 UTC,"XD holy cow, this is like that spills the glass. Ive just surfed the surface of c coding tonight and now this! its very weird for me. Its frigthening and encouraging finding that there is a lot more to learn.  So i just ran it, and i see that time functions dont work with the delays, and that sleep thing is doing the job for us. But the thing is that i need it to stop it on any point. Like pausing a movie. I cant put a scant or getchar because it stops the program just to take the input. I dont want it to wait, just to immediately stop when i press enter. Thanks for your help, ive never seen this sleep thing, ill save it in another file and search more about it. Greetings from Mexico!"
C_Programming,37ofv7,chenshuiluke,1 point,Fri May 29 06:22:13 2015 UTC,"I thought I would comment the above code so you can understand it better. The key thing to remember is it includes a lot of conditionals, basically if were on Linux include this file, if were on Windows include this file.   The reason is that sleeping requires some intervention from the OS and thus each OS provides a different method for achieving this.   Any line beginning with a # is a pre-processor directive, basically instructions to the compiler. If we're on Linux the pre-processor recognises this and only includes the unistd.h header.  #ifdef _gnu_linux__           //If Linux     #include <unistd.h>      //Use linux header that contains usleep #endif #ifdef _WIN32                  //If Windows     #include <windows.h>  //Use Windows header that contains Sleep #endif  #include <stdio.h> #include <stdlib.h> #include <time.h>  void mySleep(int sleepMs) {     #ifdef __gnu_linux__       //Make sure we use the correct function     usleep(sleepMs * 1000);   // usleep takes sleep time in us (1 millionth of a second)     #endif     #ifdef _WIN32          Sleep(sleepMs);     #endif }  int main() {     time_t seconds;     seconds = time(NULL);      int delay = 1000;      while(1)     {         printf(""Hours since January 1, 1970 = %ld\n"", seconds/3600);         mySleep(delay);      }      system(""pause"");  }"
C_Programming,37ofv7,chenshuiluke,1 point,Fri May 29 11:48:50 2015 UTC,"Lol I blundered as well. The loop doesnt reassign the time each time it executes, so it essentially stays the same. I temporarily changed   while(1) {     printf(""Hours since January 1, 1970 = %ld\n"", seconds/3600);     mySleep(delay); }   to  while(1) {     seconds = time(NULL); //Changes the seconds variable at each iteration     printf(""Seconds since January 1, 1970 = %ld\n"", seconds); //Shows you in seconds, so it's easier to see that it's working.     mySleep(delay); }   This way, the seconds variable is updated every second or so. As for the pausing mechanism, you'll probably need to do some sort of multithreading, which is most likely way out of your league atm, sorry :P."
C_Programming,37jdi0,andrespm_,3,Thu May 28 01:30:27 2015 UTC,"mineven=a[0];   You are overwriting the minimum value every iteration.  Protips:   int b, c, d maxeven=0, mineven, maxodd=0, minodd;   You forgot a comma here. Did you even try to compile this...?   if(a[i]%2==0)   You used ""i"" already in the outer loop. It works, technically, but is very confusing and should be avoided at all costs.   int b, c, d,   The scope of these variables are way too large. Declare them later when they are used, inside the loop.   printf([...], mineven )   If the array size is 0, 'mineven' is printed uninitialized here. Always compile with all warnings active; it should have shown you this.   {if(a[i]%2!=0)   Decide on a brace style and stick to it.   El numero mayor de los pares   Always use English - especially when working with others, or showing code to somebody else!   void genera   Concise function names like this clutter the namespace, declare it with static so it can't interfere with other code."
C_Programming,37jdi0,Aransentin,1 point,Thu May 28 02:10:06 2015 UTC,"Made some changes      int b, c, d,sumap=0, sumai=0, maxp=a[0], minp=a[0],      maxi=a[0], mini=a[0],i; srand(time(NULL)); for(i=0; i<x; i++) {     b= 1+ rand()%100;     a[i]=b;     printf(""%i\t"", a[i]);     if(a[i]%2==0)     {         sumap+=a[i];         if(a[i]>maxp)         {             maxp=a[i];         }         if(a[i]<minp)         {                minp=a[i];         }     }     if(a[i]%2!=0)     {         sumai+=a[i];         if(a[i]>maxi)         {                maxi=a[i];         }         if(a[i]<mini)         {                mini=a[i];         }     }     }"
C_Programming,37jdi0,domen_puncer,1 point,Thu May 28 02:18:20 2015 UTC,"Well, you initialise it to a[0] (before a[0] is initialised even!), either initialise to first odd/even, or to INT_MIN, INT_MAX.  You can also just use else instead of if(a[i]%2!=0)."
C_Programming,37jdi0,netsx,1 point,Thu May 28 11:34:00 2015 UTC,Does somebody now why is it only taking the last odd value? it works with the even numbers but not with the odd ones.
C_Programming,37gs4q,argunner,5,Wed May 27 14:54:56 2015 UTC,"You say POSIX? I say bullshit! This project's code quality is mediocre at best and it contains several unportable things and issues. From the top of my mind:   You use ANSI escape sequences to get colours. These are not part of POSIX. If you want to do portable terminal programming, employ curses (without any ncurses extension), the IEEE standardized interfaces for that task. You define macros whose name begins with E in public headers. All names beginning with E are reserved for errno values from the header errno.h, do not use these names. You use syntax that looks like sgml but probably isn't. Please document your syntax and use a proper parser if possible The URLs in your package comments lack // You don't do any error checking at all on IO operations even though you pretend to do so. Why?"
C_Programming,37gs4q,FUZxxl,2,Wed May 27 17:58:00 2015 UTC,"Well I'm new , yes i know that the macros which start from E are used by error.h but it slipped off from my mind as i'm not frequent .I'll try to fix all of them point by point Thanks a lot for descriptive review :) Cheers @FUZxxi"
C_Programming,37gs4q,Nirenjan,4,Thu May 28 00:04:33 2015 UTC,"Why not simply use syslog(3) if this is for POSIX?  If you want to have a local logging facility instead of using the system logger, then you might want to consider using standard POSIX levels (LOG_ERR, LOG_EMERG, etc.) instead of strings, and save the output in syslog format."
C_Programming,37gs4q,DSMan195276,3,Wed May 27 17:41:37 2015 UTC,"This project has a fair amount of what I would consider major errors:   None of the header files guards A linked list is not the right structure to hold a string!!!! If the string has to be of variable size, use a malloced buffer, and realloc it as you need. Anything but a linked list with one entry per char. As you've probably realized with your ptr->next->next->next->next code, it's very inconvient, and it's also very slow and not very memory efficent. You treats arrays as though they are one entry longer then you declared them. char buf[0] is not valid AFAIK, and you could just as easily just declare a single char and take the address of it instead of declaring an array in this instance. Also, strings need to have the null terminator at the end, so char tag[4] can only validly hold a string of length 3 inside. You shouldn't call read with a buffer size of 1, it's just going to be very slow. You're better off using a buffer size of say, 4096 (4K), checking the size report from read, and then adding the entire blob of read characters from the buffer into your big string. if you want to read char's one byte at a time, try using something like fgetc, where you can use the FILE standard interface, which will do buffering for you. Make sure your code is consistant in styling and general guidlines. Overall it's good, but there are some places where it get's a bit ugly. Also, in some places you cast the results of malloc, in others you don't. In general casting the result of malloc is considered a no-no for C, though others may disagree with me on that. Your code appears to only work with a specefic set of strings that you provide to the log function for the log-level. You should probably just use an enum to provide integer values for your choices, pass that enum into your write-log, and use the enum value to index an array to get the correct strings from. You'll probably find this cleans up the code a lot as a bonus.   That said, please don't be discouraged by my analysis - Everybody has stuff to learn, and every project has stuff to fix. I'm pointing these things out in the hope that you'll learn from them and that they'll be helpful to you."
C_Programming,37h94m,neophytez,1 point,Wed May 27 16:54:33 2015 UTC,Use the shunting yard algorithm. It's simpler. Wikipedia has a complete description.
C_Programming,37h94m,FUZxxl,1 point,Wed May 27 18:11:37 2015 UTC,Can anyone help me with simple equation without brackets? I'm stuck at the beginning :/
C_Programming,37h94m,spc476,1 point,Thu May 28 07:45:49 2015 UTC,"An expression can be defined as:  expr -> term ( ( '+' / '-' ) term )* term -> factor ( ( '*' / '/') factor )* factor -> NUMBER / '(' expr ')' NUMBER -> ('0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9')+   If you are unfamiliar with the format, it's a type of Backus-Naur form.  In English this is:  An expr is a term, followed by zero or more (the outer parenthesis followed by a star) of, a plus or minus (the parentheses forms a group, the slash is a choice, and items in single quotes are literal characters) and a term.  A term is a factor, followed by zero or more of: multiplication or division, followed by a factor.  A factor is a number or an open parenthesis, an expression and a closed parenthesis.  A number is just one or more  (the parenthetical grouping followed by a plus) literal digit characters.  It's recursive because expr eventually ends up on NUMBER, which may call expr as part of its action.  This describes the nature of a simple parser to parse expressions and will successfully parse:  2+5*9 (((((3))))) (((3))+((9))) (2+5)*(7-2)   Translating the above Backus-Naur form into C is left as an exercise for the reader, but as a hint:  convert each rule into a function.  The ""zero or more"" or ""one or more"" bits will translate into a loop."
C_Programming,37fojf,operatorHammer,5,Wed May 27 07:56:50 2015 UTC,"If you want to make it a bit more nasty, write a byte to each allocated location so that the system has to actually map a physical page in.  for(;;) { char * c = (char * )malloc(4096); * c = 127; }   I used to write some super nasty fork bombs.  What you're doing is just a simple memory exhaustion.  Add to it some use of fork, so that your program splits and then allocates a ton, and then splits again.  Learn about Copy on Write semantics.  Try to have your fork bombs spend the most time working hard in OS code like paging to disk or resolving CoW when you write to shared pages.  To answer your question, there isn't really any good way to prevent this.  Yes you can do limits.conf or the equivalent, but even then you can create ""grinders"" which nearly lock the system by spending their time making the kernel work hard.  Most modern network operating systems are vulnerable to these sorts of attacks, even from user/ guest accounts.  First version of OSX that was presented at BSDCon in San Francisco, a USENIX event, I ran one of my simplest bombs on one of the Macs they setup for people to play with.  It was pretty cool because the kernel panic wrote text right onto the GUI when it died.    Linux, Windows, and OSX are also trivial to attack in this way.  It just takes some time to tune to get the best grinding behavior.  If you do it right, even kill -9 makes zombies rather than removing the process.  In the end however, resource exhaustion or kernel grinding attacks are classified as denial of service attacks and thus are not considered critical especially if they're local."
C_Programming,37fojf,California_Democrat,1 point,Wed May 27 14:44:57 2015 UTC,Wow! Thank you very much for this great insight.
C_Programming,37fojf,TehJohnny,5,Wed May 27 16:04:22 2015 UTC,"Well, you never leave the loop so you'd endlessly allocate a byte per loop until you ran out of memory.... >> I don't understand what you're trying to accomplish with an infinite loop of mallocs."
C_Programming,37fojf,primitive_screwhead,2,Wed May 27 08:31:03 2015 UTC,"This was intended to test my systems stability under hard circumstances. It seemes that Linux gives this process the highest priorty and I can't even kill it with ctrl-c.  The 4GB RAM are full very quickly as top shows. My 8GB swap shouldn't used up so fast, but top stops actualising at arround 80% RAM usage."
C_Programming,37fojf,FUZxxl,4,Wed May 27 08:43:57 2015 UTC,"Try using ulimit if you want to prevent a process from using all the system resources.  By default many Unix systems, and linux, are fairly permissive about allowing processes to use resources (as it can be more efficient than having quotas everywhere)."
C_Programming,37fojf,akmark,2,Wed May 27 09:38:38 2015 UTC,"Your system is slow because it swaps like mad, not because your process gets high priority (it doesn't). Swapping takes time and when parts of the windowing system are swapped out you get an unresponsive user interface. I removed my swap partition to solve this problem."
C_Programming,37fojf,cQuaid,1 point,Wed May 27 18:25:12 2015 UTC,"There are good tools for simulating system stress versus simple exhaustion, I would implore you to look at them since you are using linux and they are free. One that I have used in the past and was easy to use was stress."
C_Programming,37fojf,balkenbrij,2,Fri May 29 04:09:17 2015 UTC,"Welllllllll, a couple of things about your memeater:  1) I'd do larger allocations... something like 1024.  2) usleep(1) during each loop to give yourself an interruptible point for your ctrl+c to go through, or just call kill -9 <pid>  If you want to attempt to give it a lower priority: nice -n 19 <binary to run>  If you want to play around more, cgroups would be the way to go.  There a number of memory and cpu options.  Your best bet is probably larger allocation chunks and a very very low sleep."
C_Programming,37fojf,robertmeta,1 point,Wed May 27 10:50:23 2015 UTC,Thank you for usleep(). This makes it much more debugable.
C_Programming,37f0um,TheAvengingKnee,1 point,Wed May 27 03:40:29 2015 UTC,"The answers on that question should help you find your ""missing semicolon""  else if (stext[i] >= 'x') {      stext[i]=stext[i] - 26; }   Why are you checking for this? Why are you subtracting 26? Can you explain what you think this code does?  else {     stext[i]=stext[i] + n; }   You have an issue here as well. Think about what the value of stext[i] will be before and after this line, and think about whether that's actually what you want. For example, what happens if stext[i] is 'm' before this and n is 20?"
C_Programming,37f0um,dragon_wrangler,1 point,Wed May 27 04:46:34 2015 UTC,"yeah I want it to wrap around but I am not sure how I could do that, I dont know what I would do to actually have it so if you add 20 to m it goes back to A and starts from there."
C_Programming,37f0um,dragon_wrangler,1 point,Wed May 27 05:32:18 2015 UTC,yeah I want it to wrap around but I am not sure how I could do that   Then you copied an earlier part of the code from somewhere without understanding what it does because you've already done it once.
C_Programming,37cyr8,BigTerminator,2,Tue May 26 18:46:42 2015 UTC,"Using fgetc() you're implementing your own parsing. This can work fine and shouldn't be a pain to use so long as you define a proper interface to your input parsing function.  However it's unnecessary. The C standard library already comes with facilities to parse input for basic types like ints. The function you want is one of the scanf() functions.  #include <stdio.h>  int main() {   int i;   int return_value;   while (1 == (return_value = scanf(""%d"", &i))) {     printf(""You input the number: %d\n"", i);   }   if (EOF == return_value) {     printf(""End of input.\n"");   } else if (0 == return_value) {     printf(""There was an input error while attempting to read a number.\n"");   } }"
C_Programming,37cyr8,bames53,1 point,Tue May 26 19:07:57 2015 UTC,"You should call scanf like this:  scanf(""%d\n"", &i)   to capture the newline introduced when the user hits enter."
C_Programming,37cyr8,FUZxxl,2,Tue May 26 22:10:39 2015 UTC,"Do you actually need to convert them into integers?  Then read up on strtoul().  If you just need to parse them out as strings, look at strtok()."
C_Programming,37cyr8,ryl00,1 point,Tue May 26 19:08:30 2015 UTC,"Read a line at a time, then use sscanf() or strtol()."
C_Programming,378qju,CProgrammingQuestion,6,Mon May 25 20:11:24 2015 UTC,Took a glance at your code. I believe you're passing a Node*** to search_list_add() which takes a Node*.
C_Programming,378qju,Erno3000,6,Mon May 25 20:39:07 2015 UTC,"I think /u/Erno3000 is correct.   You should get a warning while compiling that code. At least if you compile with -Wall to gcc/clang. You didn't say what compiler you're using.  Whatever you're using, you should turn up warnings until it warns you about then, and then fix all the warnings."
C_Programming,378qju,looneysquash,1 point,Mon May 25 23:51:42 2015 UTC,"CIFY (Compiled It For You), gives following warnings:  erno@ubuntu:~/Desktop/Untitled Folder$ gcc -Wall *.c main.c: In function ‘readInput’: main.c:42:3: warning: passing argument 1 of ‘convertWordToDesiredFormat’ from incompatible pointer type [enabled by default]    convertWordToDesiredFormat(&nameChecker);    ^ main.c:9:6: note: expected ‘char *’ but argument is of type ‘char (*)[50]’  void convertWordToDesiredFormat(char *theWord);       ^ main.c:45:4: warning: passing argument 1 of ‘search_list_add’ from incompatible pointer type [enabled by default]     if (search_list_add(&list, nameChecker, inputfile) == -1) {     ^[Reddit Enhancement Suite](http://redditenhancementsuite.com/)  In file included from main.c:1:0: list.h:18:5: note: expected ‘struct Node *’ but argument is of type ‘struct Node ***’  int search_list_add(Node *list, char theWord[], char inputFile[]);      ^ main.c: In function ‘convertWordToDesiredFormat’: main.c:59:3: warning: implicit declaration of function ‘tolower’ [-Wimplicit-function-declaration]    theWord[count] = tolower(theWord[count]);    ^   Looks like OP has some more cleaning to do.  If it's a homework assignment, always use -Wall and valgrind!"
C_Programming,378qju,Erno3000,2,Tue May 26 12:54:50 2015 UTC,can you reduce this code to something minimal that has the problem? E.g. 20 lines tops.
C_Programming,378qju,OldWolf2,1 point,Mon May 25 23:30:22 2015 UTC,Here's a diff that might be of some help.  It's search_list_add that I think is the culprit.
C_Programming,376v9h,unfitapolo,2,Mon May 25 10:45:15 2015 UTC,"Please post your code, threads should not work the way you described."
C_Programming,376v9h,_teslaTrooper,1 point,Mon May 25 11:17:22 2015 UTC,"I edited my post with a link to the code. Please note that this is a very rough sketch, but the problem comes mainly form the variable Chave witch is supposed to store 6 random values for each of the consumer threads, but all of them end up sharing the same variable.  Thanks in advance."
C_Programming,376v9h,_teslaTrooper,2,Mon May 25 11:30:41 2015 UTC,"I had a quick look and it seems like you're passing the same pointer to each of your threads, so they will be accessing the same data.  Also I'm seeing a lot of this: aux=pointer + (1 + N * sizeof(int));. I haven't checked but are you sure you need n * sizeof(int) instead of just nthere?"
C_Programming,376v9h,_teslaTrooper,1 point,Mon May 25 11:41:18 2015 UTC,"I think I need the n * sizeof(int), I did some testing of the program and that part seems to work as I intended it to work. The implementation of sem_init was part of the assignment to coordinate the threads, it basically guarantees that only one consumer process is reading from the shared memory at any given time.   I believe I have to pass that pointer to each of my threads because I need them to share certain variables, but the ones I define inside the consumer thread such as Chave[6]={0, 0, 0, 0, 0, 0}, Reads and aux, I need them to be unique to each consumer thread but in reality they are being shared among the 4 consumer threads."
C_Programming,376v9h,_teslaTrooper,2,Mon May 25 13:24:58 2015 UTC,"calling srand seems to fix it.   You don't have to multiply by sizeof as much as you do, read this. Your shmem size is  6*sizeof(int) = 24 bytes, but you use memory at aux = pointer + (1 + NUM_THREADS * sizeof(int)); with aux being an int*, that makes it point to pointer + 20 which is 80 bytes offset from your shared memory. It only works because shmget rounds up to PAGE_SIZE (4096)."
C_Programming,377zaq,TheAvengingKnee,7,Mon May 25 16:59:06 2015 UTC,"Your strlen() call needs to be after you set the string (ie fgets() ). You're calling it before, on an uninitialized string, which gives an invalid value and may cause an out of bounds memory read."
C_Programming,377zaq,WestonP,2,Mon May 25 17:47:05 2015 UTC,"I would highly recommend this instead. (Forgot the #, just add it on) http://pastebin.com/ZmJPj7br"
C_Programming,37624c,2ns910mrso9,8,Mon May 25 04:38:08 2015 UTC,"It depends on how robust your program needs to be in the face of errors. If it's an internal tool that's used in scenarios that are unlikely to encounter low memory situations, then you're probably safe. If it's customer facing, then you probably want to handle all possible errors."
C_Programming,37624c,Meefims,1 point,Mon May 25 05:15:21 2015 UTC,"It also depends on the life of the function parameters. If the parameters are well known to be within bounds, you can use an assertion that only compiles in debug code. Otherwise, you may be wasting time checking for errors."
C_Programming,37624c,f5f5f5f5f5f5f5f5f5f5,2,Mon May 25 15:41:04 2015 UTC,"Always check malloc, unless you really don’t care about the program being portable or existing for all that long.  If you don’t want to have to do it everywhere and you can’t really handle it not returning  a valid memory block, then just make yourself a wrapper, and use that instead:  void *malloc_checked(size_t size) {     void *rv = malloc(size);     if(!rv) {         fputs(""fatal error: insufficient memory\n"", stderr);         fflush(stderr);         abort();     }     return rv; }   (If you’re optimizing: In GCC/Clang/GNU-compatible compilers, mark this __attribute__((__malloc__)) to tell it that the output won’t alias, and use __builtin_expect to tell it that the failure branch is unlikely.  In MSVC you can use __declspec(noalias) instead of __attribute__((__malloc__)) IIRC.)"
C_Programming,37624c,nerd4code,1 point,Mon May 25 19:00:32 2015 UTC,"If you have any reason at all to doubt it, then validate it."
C_Programming,37624c,neilalexanderr,1 point,Mon May 25 09:38:12 2015 UTC,"Proper error handling is often one of the hardest (at least among the most tedious) parts of a program. Uncommon errors never happen until they do, and then usually on your user's machine. If you haven't checked for an error, and don't even log it somewhere it's very hard to diagnose.  As much as possible I try to divide functionality into discrete operations that either work or fail. If something fails, things are reverted going up the stack and finally I get to some point in the program where it makes sense to deal with the failure, i.e. notify the user and either try again, try something else, or abort the program.  In practice I try to start any operation like this by first allocating all the resources I need, and if any of try them fails, fail as soon as possible. This isn't always possible or worth it, and can lead to passing a lot of parameters. For very small utility programs I generally just print to stderr and exit on any error."
C_Programming,37624c,wild-pointer,1 point,Mon May 25 15:29:17 2015 UTC,"Yes. If an error is possible, but in practice just doesn't really happen, it's safe to ignore. I'd focus on handling errors well rather than just handling all possible errors."
C_Programming,37624c,Alyte,3,Mon May 25 13:00:01 2015 UTC,I am currently dealing with a massive project where the developer didn't expect people to be manually running things or bad data to be possible in his system so he built no safeguards.    Please dont do this.
C_Programming,37624c,DustyLiberty,1 point,Mon May 25 14:26:45 2015 UTC,That's different: never trust user input at all. I meant in the context of some library where errors are defined for functions but they're super rare and you've never really encountered them.
C_Programming,37624c,Alyte,-1,Mon May 25 15:31:03 2015 UTC,"I'm a big fan of never checking memory allocations (on a Unix operating system). If a memory allocation fails, there's really only one sensible course of action: crash. On more obscure operating systems, dereferencing a null pointer may do something other than crash, in which case you'd want to catch a failed malloc() and explicitly crash."
C_Programming,37624c,OlderThanGif,3,Mon May 25 13:20:37 2015 UTC,"I may be wrong, but couldn't just not checking memory allocations lead to obscure behaviour, not necessarily a crash, and so much confusion as to why your program is behaving weirdly? And on top of that, because you don't really know what your program's going to do, couldn't it end up doing something you really don't want, bad for security?"
C_Programming,37624c,Alyte,2,Mon May 25 15:36:22 2015 UTC,"Specifically on Linux, malloc never fails due to a lack of memory. The kernel will allocate more virtual address space to the process but until that space is actually accessed, will not be backed by actual memory. In an OOM situation the OOM killer will be invoked and the allocating process will either have its virtual allocation filled by scavenged memory or be itself terminated."
C_Programming,37624c,trapxvi,5,Mon May 25 16:59:26 2015 UTC,"Oft-repeated, but not universally true.  malloc will return NULL when out-of-memory if overcommit is disabled via /proc/sys/vm/overcommit_memory.  And of course it’ll still return NULL if it’s out of address space, which happens easily in 32-bit processes."
C_Programming,37624c,nerd4code,1 point,Mon May 25 18:53:57 2015 UTC,If you are out of address space crashing is a sensible response
C_Programming,37624c,Spudd86,2,Mon May 25 19:47:03 2015 UTC,"IMHO crashing should only be a last-ditch response, and only after the program/programmer has demonstrated a complete inability to handle the situation.  If you’re exporting an API for example, you may want to catch allocations of ridiculously huge allocations, or handle the error yourself without bringing the entire thing down.  If you’re using an API, you may want to be able to handle its errors cleanly without resorting to signal handlers and other acts of desperation."
C_Programming,37624c,nerd4code,1 point,Mon May 25 20:03:26 2015 UTC,"The problem with out of memory error paths is that they are incredibly difficult to write correctly, and nearly as difficult to test. The anount of stuff you can do while unable to allocate memory is severly limited, even writing to a file is likely to fail, even if you aren't calling printf or the like because if you can't allocate memory it's reasonably likely the OS can't either so almost anything you try to do will probably fail. If you have no OS then you probably have to deal with allocation failures, but you also probably have some infrastructure for doing so, and a lot more options.  If you are writting a library that deals with malloc fails you had better have tests for tjat cover every single instance of malloc, because if you don't it's almost certain that your out of memory handling is broken.  One of the libdbus developers has a blog post about how hard it is to properly deal with malloc failures (libdbus does) and they basically say it's not worth doing unless absolutely necessary."
C_Programming,37624c,Spudd86,1 point,Mon May 25 20:35:50 2015 UTC,"For most programs, the most “appropriate” course of action is to print out an error message and exit.  If possible, they should clean stuff up.  Crashing precludes both of those actions."
C_Programming,37624c,nerd4code,1 point,Mon May 25 20:53:12 2015 UTC,"Cleaning up usually requires memory allocation.  Edit; I agree for most difficult to deal with errors, but memory sllocation failure is rare on most desktop/server/phone OSs, rare enough that if it happens  probably have a bug, and difficult enough to do right that there is good chance your attemp to clean up will fail. Better is to make sure crashing will lose very little data, that way you are protectong against crashong bugs too."
C_Programming,37624c,Spudd86,2,Mon May 25 22:48:48 2015 UTC,"int *x = malloc(1000000000 * sizeof *x); x[999999999] = 0;   If the malloc failed in that code, you could get some weird behaviour, just because x being the null pointer could cause x + 999999999 to be some legitimate part of memory. I think any time you're mallocing more than a page (or more than a few pages?) there's a possibility immediately accessing the end of the array (before accessing the beginning of the array) could cause weirdness. Probably if you're mallocing a huge array, you plan to access the beginning of it some time soon, though."
C_Programming,37624c,OlderThanGif,1 point,Tue May 26 04:54:52 2015 UTC,"Yes, if you actually get a NULL from a malloc and then try to access it in C, you’ve invoked undefined behavior per the language standard.  The compiler could have generated code sth your program checks for the the situation (ha), or goes on with its life as usual, or accidentally stars the robot rebellion.  If it crashes right away, you’re quite lucky."
C_Programming,37624c,nerd4code,1 point,Mon May 25 18:28:52 2015 UTC,"No you are not lucky if it crashes on defreference of NULL, that's what happens on pretty much every system with virtual memory, which these days is everything that's not miniscule.  Yes it is undefined behaviour and anything is ALLOWED to happen, but what actually happens is a crash."
C_Programming,37624c,Spudd86,2,Mon May 25 19:50:57 2015 UTC,"But the compiler can elide references to that NULL pointer (to non-volatile), even if you make them explicit—according to the language, it’s allowed to optimize as if NULL dereferences do not occur.  That means that the crash could happen well after the allocation failure, possibly after you do some other stuff that shouldn’t’ve happened.  It’s like reading a password, doing the stuff the password should’ve guarded, and then checking that the password was correct.  [Editing: Also, C/C++ are not intended only for use on systems with virtual memory, or where there are tons of process/user protections in place; they’re also intended for building software that provides such things, or operating in modes/environments where those things aren’t possible.  If you’re in kernel mode and something returns NULL, you damn well better handle it properly.]"
C_Programming,37624c,nerd4code,1 point,Mon May 25 19:59:01 2015 UTC,"The compiler will only do that if it can prove something is always NULL, so not malloc return. It will also remove checks fir NULL if you dereference the pointer before the check, then sometimes optimize out the furst dereference, leading to really non obvious weirdness.  Yes you should check, I was mostly poiting out that the response on most systems to NULL dereference is a crash, IIRC this is even be true on some non virtual memory systems that have special behaviour for 0 pointers (ie: generate a hardware interrupt)  EDIT: even in kernel mode on virtual memory systems you will crash on NULL deref because the kernel gets to use virtual memory too, but yes the kernel really needs,to deal with OOM situations."
C_Programming,37624c,Spudd86,1 point,Mon May 25 20:19:45 2015 UTC,"It can “safely” assume that a pointer is never NULL if it’s dereferenced, and then it can get rid of or move the dereference.  For example:  foo *p = (foo *)malloc(sizeof(*p)); *p = (foo)0xDEADBEEF; call_function(); some_other_function(p); free(p);   Because malloc is __attribute__((__malloc__)) or __declspec(noalias) on a modern compiler, p cannot alias anything; therefore the first initialization can be entirely discarded.  That means the crash might not happen until well into or after some_other_function.  If there’s pure/const/constexpr-ness in conjunction with inlining, then that entire block (or even just the allocation of p) could be discarded, and nobody would ever know that the malloc failed.  In which case, maybe it’d be okay not to have checked?  It’s also possible to offset a NULL pointer (e.g., to access a member of a struct), in which case you can be anywhere within SIZE_MAX of 0 and the mapping/lack thereof at address 0 is irrelevant.  And of course, it’s also theoretically possible for the compiler to use something other than a zero-word for its internal representation of NULL, in which case there’s no telling what’ll happen, although I’ve never heard of this being done except in odd cases like C++ member pointers or Harvard-architecture function pointers.  I’d also note that not all kernels or VM mappings are created equal; it’s perfectly possible on a lot of systems to set up some mapping f(x)→x, and this is quite common during startup/shutdown/sub-64-bit stuff even on x86."
C_Programming,37624c,nerd4code,2,Mon May 25 20:47:19 2015 UTC,"I'm a big fan of never checking memory allocations (on a Unix operating system). If a memory allocation fails, there's really only one sensible course of action: crash.   Remind me never to use code you wrote.  I work on embedded systems. If we dereference null, it doesn't just terminate the process; it locks up the whole system. The only recourse is to reboot the device.  Is this the kind of behavior you want from your office phone, or emergency call box? Probably not.  If the system is running low on memory and malloc returns null, I may not be able to complete the operation that was requested. But at least I can make sure the rest of the system stays operational. Maybe this means your emergency phone only registers with 2 redundant servers instead of 3. Isn't that a lot better than crashing and possibly getting into a reboot loop?"
C_Programming,376djg,CProgrammingQuestion,1 point,Mon May 25 06:38:06 2015 UTC,"I'm surprised you're not getting a segfault at this line in addToFront:  strcpy(newNode->word, theWord);   You're copying a string into a pointer that doesn't point to anything yet because it hasn't been initialized."
C_Programming,376djg,raevnos,1 point,Mon May 25 06:54:49 2015 UTC,"readInput(myList, file1);   If a function is to change the value of a variable declared outside that function, you must pass it a pointer to that object so that you can update its value inside the function and have it be retained when the function ends:  void foo( int *x ) {        *x = 3; } ... int x; foo( &x );   Therefore:        readInput(myList, file1);   If you want 'myList' to not be NULL when this function ends, you need to make readInput take a pointer to a pointer to a node, and pass it the address of the node you wish to be updated:  struct node *n; readInput( &n, ... );   That's why your list is NULL when you're done."
C_Programming,376djg,dumsubfilter,1 point,Mon May 25 07:12:10 2015 UTC,"include <stdio.h>  include <stdlib.h>  typedef struct node {     int data;     struct node  *next; } Node;     void addToFront( Node ** headPtr, int newData) {     Node* newNode = malloc(sizeof(Node));     newNode->data  = newData;     newNode->next = *headPtr;     *headPtr = newNode; }    void removeFromFront(Node** headPtr)  {     if ( headPtr == NULL )         return;     Node toRemove = headPtr;     *headPtr = (headPtr)->next;     free(toRemove); }    void printAll(Node* front) {     printf(""List: "");     Node *curr = front;     while ( curr != NULL  ) {         printf(""%d "", curr->data);         curr = curr->next;     }     printf(""\n""); }    void delete(int toRemove, Node ** headPtr) {     Node curr = *headPtr;     Node *prev = NULL;     while ( curr->data != toRemove ) {         prev = curr;         curr = curr->next;     }     if (prev != NULL) {        prev->next = curr->next;        curr->next = NULL;     } else {        *headPtr = (headPtr)->next;     }     free(curr);    }    int main(void) {    Node *myList = NULL;    addToFront(&myList,42);   addToFront(&myList,32);   addToFront(&myList,12);    addToFront(&myList,92);    printAll(myList);    delete(92,&myList);   printAll(myList);   delete(32,&myList);   printAll(myList);     }"
C_Programming,3761fi,CProgrammingQuestion,1 point,Mon May 25 04:31:51 2015 UTC,Could you put your code here or on something like pastebin? It would make it a lot easier to help you.
C_Programming,3761fi,2ns910mrso9,1 point,Mon May 25 04:48:35 2015 UTC,I added print statement to the search_list_add function that prints theWord and the List->word. They are the same every time after the first word goes through my addToFront. Why is this? I haven't even added the second word to the list yet it is in the location List->word???
C_Programming,3761fi,2ns910mrso9,1 point,Mon May 25 05:02:58 2015 UTC,I put the code on pastebin as requested. /u/2ns910mrso9 http://pastebin.com/D9Zz0WZ8
C_Programming,3761fi,DSMan195276,1 point,Mon May 25 04:59:58 2015 UTC,"Well, I couldn't run it through a debugger since I don't have the Node definition, but I think it's the fact you're calling search_list_add() twice in readInput().  Try setting a variable to hold search_list_add()'s return and then print and check the variable."
C_Programming,373e4h,EpikHighBornHater,8,Sun May 24 14:31:27 2015 UTC,Because the printf is outside of the loop?
C_Programming,373e4h,jijijijim,5,Sun May 24 14:34:26 2015 UTC,"Don't just say that the code ""doesn't work"", tell us exactly what happens.  Anyway, the printf call should probably be inside the for loop."
C_Programming,373e4h,dreamyeyed,3,Sun May 24 14:34:35 2015 UTC,"Now that you know the problem from the other posters, using the correct scope would help you catch this yourself. As of C99, you can do this:  for(int i = 0; i < x; i++) {     ... }   Now the scope of i is the for loop, so any external mention would be an error at compile time."
C_Programming,373e4h,wgunther,2,Sun May 24 14:40:30 2015 UTC,"You are calling printf outside of the for loop, which means that you basically print out just the number at arraylol[14].  Also, when printing integers you should use %i instead of %d."
C_Programming,373e4h,_predator_,3,Sun May 24 14:35:49 2015 UTC,%i and %d are the same with output.
C_Programming,373e4h,wgunther,1 point,Sun May 24 14:38:36 2015 UTC,"Should've double checked that, derp. Thanks for pointing that out."
C_Programming,373e4h,_predator_,2,Sun May 24 14:46:16 2015 UTC,"Actually, i will have the value 15 after the loop and the index will be outside of the array. Depending on your architecture and alignment that means the value that is printed out is that of x, since that happens to be behind the array."
C_Programming,373e4h,thefeistelnetwork,1 point,Sun May 24 18:44:38 2015 UTC,"Yeah you are right, of course i is being incremented before i < x is checked, so of course i is 15 outside of the loop."
C_Programming,373e4h,_predator_,2,Sun May 24 21:07:29 2015 UTC,"Your printf is not inside of a loop. It will only print once with whatever index is in i , which is 14."
C_Programming,371a9n,riczreich,3,Sat May 23 22:51:02 2015 UTC,I think the question assumes the array IS at least N+1 in size since you're never told.  I hope this isn't a real codebase.
C_Programming,371a9n,pixel4,5,Sat May 23 23:32:04 2015 UTC,It's probably homework.
C_Programming,371a9n,raevnos,2,Sun May 24 03:16:21 2015 UTC,"Start walking backwards. No need to look at items less than x.  #include <stdio.h>  void insert(int v[], int N, int x) {      while (N > 0 && v[N-1] > x) {         v[N] = v[N-1];         N--;     }      v[N] = x;  }  void test1() {      int N = 9;     int v[] = {11,22,33,44,55,66,77,88,99,0,0,0,0,0,0,0,0,0,0};      insert(&v[0], N++, 42);     insert(&v[0], N++, 69);     insert(&v[0], N++, -10);     insert(&v[0], N++, -123);     insert(&v[0], N++, 123);     insert(&v[0], N++, 83);     insert(&v[0], N++, 75);      printf(""test1: "");     for (int i=0;i<N;i++) printf(""%i, "", v[i]);     printf(""\n"");  }  void test2() {      int N = 0;     int v[] = {0,0,0,0,0,0,0,0,0,0};      insert(&v[0], N++, 100);     insert(&v[0], N++, -100);     insert(&v[0], N++, 666);      printf(""test2: "");     for (int i=0;i<N;i++) printf(""%i, "", v[i]);     printf(""\n"");  }   int main(void) {      test1();     test2();  }"
C_Programming,371a9n,pixel4,1 point,Sun May 24 04:30:01 2015 UTC,Maybe you should tell what you've already tried. This way we can tell you what you did wrong and point you in the right direction...
C_Programming,371a9n,24monkeys,1 point,Sat May 23 23:56:51 2015 UTC,edited
C_Programming,371a9n,24monkeys,1 point,Sat May 23 23:59:59 2015 UTC,"Sorry, I'm on my phone. Could you post a example input and the output of your code?"
C_Programming,371a9n,DSMan195276,1 point,Sun May 24 00:10:33 2015 UTC,"Arrays don't really have a related 'size' to them, they only do if you keep track. So, presumably the array sent to insert is already big enough to handle N + 1 items, and the code calling insert will have to increment the size of the array that it sent to insert as N to account for the fact that they just added another item to that array.  In other words, insert doesn't have to worry about changing the size of the array, the code calling insert on the other hand has to make sure it has space for N + 1 items inside the array, and then keep track of how many items are actually inside it."
C_Programming,36ve9o,stymiee,11,Fri May 22 12:48:31 2015 UTC,"Technically that's not C, it's GNU C, a distinct and incompatible dialect.  It seems wildly irresponsible to rely on non-standard vendor extensions for something as mundane as parsing JSON.  The whole world does not use gcc (although clang probably emulates some or all of these extensions because there's enough software out there that requires it.)"
C_Programming,36ve9o,Rhomboid,7,Fri May 22 13:18:19 2015 UTC,"clang should compile this fine, at least. For a one-off piece of code that this mostly appears to be, it's not that bad.  It does stink that it needs extensions to do it this way, because the code itself is pretty cleanly done. Without the extensions it be much more annoying to read, and slower as well."
C_Programming,36ve9o,DSMan195276,5,Fri May 22 14:38:26 2015 UTC,"This is a convenience but does not compile to anything differently than standard C would. Without the extensions, the code would be no slower."
C_Programming,36ve9o,bodangly,1 point,Fri May 22 19:21:00 2015 UTC,"I should have probably clarified that I was talking about the js0n parser as a whole, not just the specific extension shown in the title. Like in the SO post, the js0n code also uses the && address-of-label extension to create a jump table to a bunch of simple routines inside of a function using goto. While gcc and clang can do some optimization similar to this if you use static functions instead of the goto routines, I can't picture it being as optimal because the functions don't have access to all the variables in the original parser function except if you pass them (And it would be harder for gcc and clang to turn it into a direct jmp to and back). You could probably do a big switch with conditional goto's, but I'm fairly certain gcc still wouldn't produce as good of code as this can."
C_Programming,36ve9o,DSMan195276,1 point,Sat May 23 03:18:15 2015 UTC,"Actually, I am fairly certain if you passed variables to static functions they would get optimized away as variables global to the scope of the parser, but I see your point. Thanks for clarification."
C_Programming,36ve9o,bodangly,2,Mon May 25 16:55:06 2015 UTC,"Whenever I see someone implementing this kind of thing, I always think to myself ""why don't this guy just use lex (or variant)?"".  Aside from just doing it for fun, I can't really see a real reason to do this. Can anyone CMV?"
C_Programming,36ve9o,24monkeys,2,Sat May 23 02:16:47 2015 UTC,There are quite a few GNU extensions which I wish would be picked up in the C and C++ standards; I've used both the range assignment and address-of-label many times in personal code.
C_Programming,36ve9o,acwaters,1 point,Fri May 22 17:54:45 2015 UTC,"What is ""&&"" doing here? I didn't realize it had a second use besides a logical AND."
C_Programming,36ve9o,salgat,2,Sat May 23 00:11:48 2015 UTC,Got me really confused too. It lets you access the address of a label. Here is the docs.
C_Programming,36vfen,Cjedilo,10,Fri May 22 12:58:48 2015 UTC,"Please remember to give a source for this. The article, I can't remember where I read it, describes the hard work it took to find it and what it means.  Please, please, please."
C_Programming,36vfen,ponchedeburro,10,Fri May 22 13:23:52 2015 UTC,"http://jroweboy.github.io/c/asm/2015/01/26/when-is-main-not-a-function.html  I'm sorry, I was lazy, I just saved the code to my computer and started talking about it with a friend... And he suggested reddit might like it too.  But I found it!"
C_Programming,36vfen,Hellenas,2,Fri May 22 13:25:45 2015 UTC,"Thanks, that was a good read.  I got the feeling something like this was happening, but using const for force it out of .data into read-only was really sharp of him!"
C_Programming,36vfen,DSMan195276,7,Fri May 22 16:47:40 2015 UTC,"With some assembly knowledge you could probably actually writes a bunch of macros that look like assembly code and dump out machine code byte-by-byte. Label's wouldn't be easy or clean, but you could probably make it kinda work if you're careful (It would be much easier with something like ARM or MIPS rather then x86, but oh well):  #define EAX 0 #define ECX 1 #define EDX 2 #define EBX 3  #define MOVL_IMM_REG(src, dest) 0xB8 + (dest), (src) & 0xFF, ((src) >> 8) & 0xFF, ((src) >> 16) & 0xFF, ((src) >> 24) & 0xFF #define INT(imm) 0xCd, (imm) & 0xFF  const char main[] = {     MOVL_IMM_REG(1, EAX), /* exit() syscall number */     MOVL_IMM_REG(0, EBX), /* exit code */     INT(0x80) };   Note, the above is untested (And probably doesn't work without some tweaking). Obviously, you should never do this and it's not really practical for more complex assembly anyway.  Edit: Wow, I'm honestly shocked this untested code works without modification now that I've gotten a chance to try it."
C_Programming,36vfen,Rhomboid,2,Fri May 22 15:13:39 2015 UTC,"gcc at least others not tried, nicely builds this into a hello world thing   The compiler doesn't matter; what matters is that you're using x86_64 Linux (and only that specific combination), not that you're using gcc.  If you were using gcc on x86 Linux, or gcc on Windows or OS X, or gcc on ARM or Sparc or whatever, this will fail hard."
C_Programming,36vfen,FUZxxl,1 point,Fri May 22 14:48:39 2015 UTC,"What OS are you doing that on? On many operating systems, the read-only data section is loaded as not executable so this won't work."
C_Programming,36vfen,FUZxxl,1 point,Fri May 22 16:48:51 2015 UTC,I used ubuntu 14.04 LTS and gcc to compile this.
C_Programming,36vfen,FUZxxl,1 point,Fri May 22 17:31:14 2015 UTC,That's weird. On amd64? How did you invoke the compiler?
C_Programming,36vfen,Rhomboid,1 point,Fri May 22 17:31:40 2015 UTC,"In a virtual box, amd64 indeed.  gcc no_function.c ./a.out"
C_Programming,36vfen,FUZxxl,1 point,Fri May 22 17:34:38 2015 UTC,Hm... that's weird. I don't understand why the rodata segment is executable.
C_Programming,36vfen,Rhomboid,1 point,Fri May 22 18:06:21 2015 UTC,"I continued to search and search some more until I found a very obvious and simple solution on a stack overflow post that I’ve lost the url to sadly. All I have to do is declare the main function as const Changing it to const char main[] = { was all I needed to do to get it in the right section, so lets try compiling again.   From the original article posted above, stack overflow might have the answer why this works."
C_Programming,36vfen,FUZxxl,1 point,Fri May 22 18:24:17 2015 UTC,".rodata is grouped in the same segment as .text:  $ readelf -lW a.out  Elf file type is EXEC (Executable file) Entry point 0x4003c0 There are 8 program headers, starting at offset 64  Program Headers:   Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align   PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x0001c0 0x0001c0 R E 0x8   INTERP         0x000200 0x0000000000400200 0x0000000000400200 0x00001c 0x00001c R   0x1       [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]   LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000694 0x000694 R E 0x200000   LOAD           0x000698 0x0000000000600698 0x0000000000600698 0x000228 0x000230 RW  0x200000   DYNAMIC        0x0006b0 0x00000000006006b0 0x00000000006006b0 0x0001d0 0x0001d0 RW  0x8   NOTE           0x00021c 0x000000000040021c 0x000000000040021c 0x000044 0x000044 R   0x4   GNU_EH_FRAME   0x000594 0x0000000000400594 0x0000000000400594 0x00002c 0x00002c R   0x4   GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10   Section to Segment mapping:   Segment Sections...    00         01     .interp     02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame     03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss     04     .dynamic     05     .note.ABI-tag .note.gnu.build-id     06     .eh_frame_hdr     07        There's only the two main LOAD segments, one that's read-write and one that's read-execute."
C_Programming,36vfen,Rhomboid,1 point,Fri May 22 18:41:42 2015 UTC,That's really weird. rodata should really not be executable.
C_Programming,36z51a,matthewtaylor99,1 point,Sat May 23 10:22:09 2015 UTC,"First of all -- either C or C++, not C/C++ -- they're quite different languages nowadays.  Second of all, this isn't an OpenGL tutorial, this is a doubly linked list tutorial (which frankly is downright braindead simple)"
C_Programming,36z51a,Genocidicbunny,0,Sat May 23 16:48:22 2015 UTC,C and C++ are different all know that   Also tutorial has opengl graphics in it with source code at the down. Plz check it there if you haven't
C_Programming,36z51a,antoniocs,0,Mon May 25 15:08:14 2015 UTC,"Not everyone knows that, especially with people like you saying stuff like ""Tutorial in C/C++ ..."". It just confuses more the people that don't there is a big difference between C and C++.  Pick one! It is either a tutorial for C or C++."
C_Programming,36slnp,ipconfider,7,Thu May 21 20:03:22 2015 UTC,You can use fscanf before the for loop to get the values into separate variables.
C_Programming,36slnp,Nirenjan,2,Thu May 21 20:38:22 2015 UTC,Thanks! So a number can only be scanned one time ?
C_Programming,36slnp,DSMan195276,2,Thu May 21 21:06:39 2015 UTC,"Kinda. The FILE structure has an offset inside which indicates where the next 'read' will take place. You can use ftell to get this exact position (Though, for this situation the exact offset is not important). Point being, functions like fscanf start reading from the file starting at this offset, and also increment this offset by however many bytes they end-up processing. So, if you call fscanf twice, the second fscanf will start reading the file at the location of the offset, which will be right where the first fscanf stopped reading. In this way, you're right, you'll only scan a number one time, because after you scan it the offset of the FILE will be located past that number. Any subsequent fscanf calls (Or any other function to read from a FILE) will never read that data again.  The reason I said not exactly is that fseek allows you to change that offset directly - So if you do an fscanf after opening a FILE, and then do fseek(file, 0, SEEK_SET);, that will set the offset back to zero, effectively putting you back at the beginning of the file. If, after the fseek, you call fscanf again, you'll again start at the offset (Which is now zero), and read the same data you read before.  In general, if you don't use fseek, then you'll never end-up reading any data twice. fseek can be very useful though. A common use is if you have random access files (Where you have a bunch of entries all the same size, so you can easily calculate the offset of any one entry), and also when you want to read a file again without closing it (You can fseek to the beginning of the file and then just start reading it again like normal)."
C_Programming,36slnp,dumsubfilter,1 point,Fri May 22 03:33:02 2015 UTC,You can also just call rewind.
C_Programming,36slnp,aZeex2ai,-6,Fri May 22 03:48:27 2015 UTC,Do your homework yourself.
C_Programming,36oxlg,tmtwd,21,Wed May 20 23:44:14 2015 UTC,"You are having a fundamental misunderstanding of how the 'stack' operates in this case. Yes, it does operate like a stack at the function call level. See here for a diagram. As functions return the context is 'popped' off the stack. But when your compiler references local variables on the stack they do so by offset from the stack pointer. So if in the local scope you have variables A, B and a stack pointer SP then A's address might be 'SP+0' and B's address might be 'SP+4.' When you call a function from a particular function it pushes a new state of space for locals and parameters and the function itself understands how to operate on it relative to the pointers to the stack.  The heap exists in a separate area of the process's memory space (it is always helpful to know that on modern OS's there is a flat memory model where there is an illusion of continuous memory that is abstracted away from reality). Since the heap provides an allocation (dedication of a space in memory to a particular address) it is a meaningful value compared to stack-allocated values which are only meaningful as part of the memory context of a particular function invocation. So if you allocate X and Y on the heap the address of it is some value W and Z which are particular places in memory.  Therefore these locals only truly exist during a function because otherwise the relative references from the stack pointer aren't pointing to the right places in memory to do meaningful work. You can still arbitrarily access values in a current stack frame because of that. You can pass by reference stack variables to other functions because you can pass the literal address of a memory location (performing the SP+offset conversion) and so you are pointing to the true location of the variable as opposed to a relative location."
C_Programming,36oxlg,akmark,1 point,Thu May 21 00:24:36 2015 UTC,"You can pass by reference stack variables to other functions because you can pass the literal address of a memory location (performing the SP+offset conversion) and so you are pointing to the true location of the variable as opposed to a relative location.    void bar(int * x){     int abba = *x + 423;//this references x relative to the current stack frame?     foo(x); //the refences the literal address of x? }  void foo(int * y){     *y = 52; //does this reference y relative to the stack frame or does it reference the literal address of y? }   If we can just reference the literal address of values on the stack, why don't we reference the literal address of all values on the stack?"
C_Programming,36oxlg,akmark,2,Fri May 22 09:36:54 2015 UTC,"Let's start with a trivial example.  void callee( int *value ) {     *value = 2; }  int caller( void ) {     int caller_local_value = 1;     callee( &caller_local_value );     printf( ""%d"", caller_local_value ); }   This is an example of us passing by reference a stack memory location to callee, which is the same as a pointer to a heap location. The output of caller() is 2. Let's compare to:  void callee( int value ) {     value = 2; }  int caller( void ) {     int caller_local_value = 1;     callee( caller_local_value );     printf( ""%d"", caller_local_value ); }   In this case we pass by value. The output of caller() is 1. This makes it so we can preserve lexical scoping which is very important in a third case:  void pong(int); void ping(int t) {     if ( t > 0 ) {             pong(t-1);     } }  void pong(int t) {     if ( t > 0 ) {             pong(t-1);     } }   In this case if t was not relative to a function's invocation the first 't' would cause an infinite ping-pong-ping function call chain. Since the parameter is passed by value and is part of the function's local scope by being relative to the stack pointer the calls look like:  ping(3) pong(2) ping(1) pong(0) ; terminate  In the comment I am replying to there is definitely a misunderstanding of pointers. In bar:   we have a parameter that is a pointer x, and it points to some integer value abba is initialized to the value pointed to by x plus 423 foo is called with a pointer x, and it points to some integer value we just increased by 423   Then in foo:   we have a parameter that is a pointer y, and it points to some integer value we set the value pointed to by y to 52.   The piece that you might be missing here is that parameters are passed as stack variables. So in foo the pointer y is actually SP+some offset and the rest of the function is based around referencing these values. Using objdump -d is really helpful to see what your function actually does:  ; bookkeeping push   rbp mov    rbp,rsp  ; (brackets mean memory reference) ; move the value of memory address 8 bytes less than the stack pointer to rax, which is y mov    rax, [rbp-0x8] ; write value 0x34 to the value y points to (*y) mov    [rax],0x34  ; bookkeeping pop    rbp  ; return ret   If this wasn't relative you couldn't call foo at multiple function depths."
C_Programming,36oxlg,Jack126Guy,1 point,Fri May 22 23:57:17 2015 UTC,"thank you, I will meditate on this"
C_Programming,36oxlg,OldWolf2,6,Sat May 23 00:21:25 2015 UTC,"It's not the variables that are being stacked on top of each other, but rather stack frames, which are like ""boxes"" that roughly correspond to function calls. Let's say you have this program:  #include <stdio.h>  void a(void); void b(void);  int main(int argc, char** argv) {     int somevar, somevar2;     puts(""main started"");     a();     /* do other stuff */     return 0; }  void a(void) {     int somevar, somevar2;     puts(""a started"");     b();     /* do stuff */ }  void b(void) {     int somevar, somevar2;     puts(""b started"");     /* do stuff */ }   When the program starts, main is called, and the two variables are allocated on the stack in the top stack frame. It doesn't matter which variable is on top, because we can access each one just fine. Only the current stack frame is random-access (assuming we're not using pointers to other variables).  Now, what happens when a is called? A new stack frame is pushed onto the stack, and the local variables are placed into it. Again, only the top frame is random-access, which is why we can have these two variables with the same names.  Then b is called, and a similar thing happens. The stack frame for b is pushed, and new local variables are put in that stack frame.  When b returns, its stack frame is popped from the stack, and the stack frame for a is now at the top. As you would expect, the local variables in a are now accessible.  When a returns, its stack frame is popped, and the local variables for main are now accessible."
C_Programming,36oxlg,Jack126Guy,2,Thu May 21 00:19:20 2015 UTC,"Only the current stack frame is random-access (assuming we're not using pointers to other variables).   Well this is nonsense. All of the frames are random-access . Of course you will need a pointer to access any variable whose name is not in scope, but scope is a different thing to stack frames.   Stack frames are optional anyway, in fact gcc doesn't use them at optimization levels other than -O0."
C_Programming,36oxlg,OldWolf2,2,Thu May 21 00:56:09 2015 UTC,"All of the frames are random-access . Of course you will need a pointer to access any variable whose name is not in scope, but scope is a different thing to stack frames.    Yes, I know, which is why I have the parenthetical.   Stack frames are optional anyway   I think it's still a good conceptual view."
C_Programming,36oxlg,OldWolf2,3,Thu May 21 01:00:46 2015 UTC,"You can read and write anywhere in ""the stack"", but you can only remove items from the ""top"" .     I say ""top"" because the stack may either grow up or grown down, but it is convention to use ""top"" to refer to the end which you push and pop from.  In your code the variables may go in either order in ""the stack"" . Assuming they're not optimized out entirely of course."
C_Programming,36oxlg,panderingPenguin,2,Wed May 20 23:50:24 2015 UTC,"How can you write anywhere to the stack:  ie  int x= 42; int y = 32;   we cannot control where these ints are allocated, just that x is located 'below'.  Do you mean, that you can read anywhere on the stack, but you can only write and remove from the top of the stack?  As a comparison, you can read, write, or remove anywhere on the heap?"
C_Programming,36oxlg,jdonniver,4,Thu May 21 00:02:59 2015 UTC,"No, you can read and write anywhere in the stack. Example:  // push onto stack int x = 42; int y = 32;  // write into stack x = 52; y = 71;   You can only remove from the top.   we cannot control where these ints are allocated, just that x is located 'below'.   x is not located 'below'. These will both be pushed onto the stack but could happen in either order."
C_Programming,36oxlg,Mines_of_Moria,2,Thu May 21 00:49:52 2015 UTC,"Do you mean, that you can read anywhere on the stack, but you can only write and remove from the top of the stack?   No he means read and write to arbitrary elements in the stack in a random access manner.  You have a stack pointer to the top of the stack, and a frame pointer to the base of the current frame. In your example, assume y is on top of the stack with x below it, that your system used 4 byte integers, and has byte addressing, and that the stack grows downward (each pushed element has a lower address than the previous so the top grows towards address 0). Then all you have to do to access x for whatever purposes you wish is to access address (stack_pointer + 4) which is x. Sure, you can only push and pop to the top of the stack but that is really only done at the beginning and end of function calls, and always done in order so this isn't a big deal. You still have random access reads and writes due to the magic of offsets."
C_Programming,36oxlg,Rhomboid,1 point,Thu May 21 01:26:44 2015 UTC,"Sure, you can only push and pop to the top of the stack but that is really only done at the beginning and end of function calls, and always done in order so this isn't a big deal. You still have random access reads and writes due to the magic of offsets.   Unless you're particularly insane and use alloca(). It allocates memory on the stack that is automatically deallocated when the function returns.  Did I mention that it's terrible and you should never use it?"
C_Programming,36oxlg,Narishma,3,Thu May 21 15:11:12 2015 UTC,I suggest you mess around with GDB and see how simple programs work in memory. It will give you a lot of clarity.
C_Programming,36oxlg,Rhomboid,3,Thu May 21 03:05:27 2015 UTC,"It puts foo at the bottom of the stack and bar at the top of the stack.    It does no such thing.  You have no guarantees whatsoever about where those variables are located on the stack, if it all — the compiler might choose to store them in registers if their addresses are never taken.  The word ""stack"" is not in the standard at all.   if you want to access foo, you first have to take off bar   Nonsense.  You can assign to, read from, or otherwise do whatever you want to foo and bar in any order you want.  The stack is something that is used for allocation, not access.  Imagine you are the person working at the desk of a hotel.  You have 100 rooms available, which are all initially empty, and people are going to be checking in and checking out and you need to keep track of which rooms are free and which are occupied.  If those people could come and go at will, you would need to keep track of the status of every room individually.  You might have a set of keys on the wall, or maybe a computer program.  When a new guest arrives, you search for an empty room and assign it to them.  This models how allocation of objects with dynamic storage duration in C works.  Such objects have lifetimes that are arbitrary — they can start and end at any time, so there's no way to optimize their allocation.  But that's not the case of objects with automatic storage duration.  The lifetime of such objects follows the flow of execution of the program — their life ends when the flow of execution leaves the scope in which they were defined.  This presents a fixed ordering to their lifetimes.  For example:  void foofunc(void) {     int foo;                // B     ... }                           // C  void barfunc(void) {     int bar;                // A     foofunc();     ... }                           // D  int main(void) {     barfunc(); }   Tell me what you know about the lifetimes of foo and bar.  Step through it in order of execution: (A) bar's life begins, (B) foo's life begins, (C) foo's life ends, (D) bar's life ends.  This means that foo's life is a strict subset of bar's life.  It's impossible for foo to be alive when bar isn't.  Going back to the person running the hotel, assume all guests fit a first-in, first-out pattern like this.  The clerk can use a different strategy now in assigning room numbers.  They don't have to keep track of the status of every room, they can just remember what the last room assigned was.  Suppose all the rooms are empty.  Alice shows up, she gets room 1.  Bob shows up, he gets room 2.  Chris shows up, he gets room 3.  The clerk knows that the next thing that will happen is that either a new guest will arrive, or Chris will check out.  It's impossible for Bob or Alice to check out before Chris.  The clerk can forget about rooms 1 and 2, because they must be occupied if Chris is still a guest.  Using this strategy, the clerk has much less information to remember (a single number vs. the status of 100 rooms) and the room are neatly organized into a series of occupied rooms followed by all empty rooms.  There can never be any gaps or holes.  But note in this analogy that anyone staying at the hotel can come and go as they please while they are still checked in.  Nothing about the setup requires that Bob stays in his room until Alice leaves, or anything like that.  In this analogy, each guest has a room number, which is analogous to a memory address.  Any guest can order take-out at any time, and the delivery person can go right to the door of the room.  Everything is still random access.  The properties of the stack apply to lifetime (i.e. order of allocation and deallocation) not to how the individual elements are accessed."
C_Programming,36oxlg,angdev,1 point,Thu May 21 05:42:58 2015 UTC,"assume all guests fit a first-in, first-out pattern like this   I think you mean first-in, last-out."
C_Programming,36oxlg,DSMan195276,1 point,Thu May 21 09:15:50 2015 UTC,You're right.
C_Programming,36orkf,tmtwd,3,Wed May 20 22:58:42 2015 UTC,"You're starting with a bad assumption.  The following is bad:  int * c = &b;   Maybe you meant:  int ** c = &b;   In which case c holds the address of b, which is 1.  And yes, that means there's a performance penalty (ignoring compiler optimizations) because to get at the actual value you need to do **c whereas otherwise you can do *b.  One more dereference.  b = malloc(sizeof(int)); *b = 45;   After this, b will hold some address on the heap, and that address will hold the value 45.  In your last example, q holds 0 (the address of z).  Again, assuming you meant int ** q = &z."
C_Programming,36orkf,boredcircuits,1 point,Wed May 20 23:08:15 2015 UTC,thanks :)
C_Programming,36orkf,angdev,3,Wed May 20 23:33:14 2015 UTC,"The value at address 2 should be 1 (the address of b). I am not sure about your performance cost question. But if you're wondering if it is more costly to double-reference pointers than single-reference, than yes. To update address 0 you could type *b = 33 or a double-reference **c = 33.  For your final question (z): z holds the address of the malloc (230), and *z points to the memory you have allocated (and can use). When you do *z = 99 z still holds the address of the malloc (230), but now that memory holds the value of 99. q will contain the address of z (0), so *q will be the value 230."
C_Programming,36orkf,dragon_wrangler,2,Wed May 20 23:10:21 2015 UTC,"int a = 32; int * b = &a; int * c = &b;   First off, c should be of type int** because it contains a pointer to a pointer to an int.   is the value at address 2 stored as a value of 1 or 0?   It would be a 1, because you're assigning the address of b (which is 1) to variable c.  b = malloc(sizeof(int)); *b = 45;   then the value at b is not 0 but 45.  No. When you call malloc(), you will receive a pointer to space on the heap. So b will be some arbitrary value like 0x1000. After the second line, b will still be the same, but the memory at location 0x1000 will contain the number 45.  int * q = &z;   Again, this should be int**. In any case, it will hold the value of the address of z, which is 0.   I'm not sure what magic you're expecting to happen, but in these examples the compiler will do exactly what you're telling it to."
C_Programming,36npd7,samisafish69,4,Wed May 20 18:40:09 2015 UTC,I found this neat pdf on modern C a few days a go. It seemed interesting at the time.  http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf
C_Programming,36npd7,G0T0,3,Thu May 21 19:13:33 2015 UTC,"Reading the linux kernel is a bald move, right?  EDIT:  I'm not a pro either but I would arrange the steps into a list.    arhcitectural level: firm understanding of pointers, memory map, how the stack works (you can find resources everywhere) C part 1: syntax of C, what you can do with it, what it is capable of and beyond standard library: because it exists on almost every platform and you don't want to repeat yourself  C part 2: what you really get when you compile your program. tip of the iceberg Structuring a C program: you can go with ye olde structs & static functions or using the OO approach"
C_Programming,36npd7,bebe3000,3,Wed May 20 22:09:42 2015 UTC,It always seemed daunting and hard to get into for me... Any tips on where/how to start?
C_Programming,36npd7,jkudria,3,Thu May 21 02:33:03 2015 UTC,"Maybe start by   git clone ""git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git"" && find linux -name ""*.c"" -exec ""$EDITOR {}""   Jokes aside, you should look into Eudyptula Challenge."
C_Programming,36npd7,SeriousBug,2,Thu May 21 06:30:04 2015 UTC,"Lol I know how to use the command line :)  But damn, thanks for the link. I know what I'll be up to for the next x amount of weeks/months."
C_Programming,36npd7,jkudria,1 point,Thu May 21 12:44:55 2015 UTC,"Deitel's ""C How to Program"" is pretty good. It's what I use."
C_Programming,36npd7,qzomwxin,1 point,Wed May 20 19:52:36 2015 UTC,"Learn it in its native environment, xv6. And you'll learn something about Unix too.  Disclaimer: I haven't done that, but I've done it with Plan 9, which is close enough. xv6'll be better in that it's ANSI C."
C_Programming,36npd7,smorrow,0,Mon May 25 12:37:32 2015 UTC,while(*s++ = *s2++)     ;
C_Programming,36npd7,tmtwd,0,Wed May 20 22:48:04 2015 UTC,What about apue: http://poincare.matf.bg.ac.rs/~ivana//courses/ps/sistemi_knjige/pomocno/apue.pdf
C_Programming,36mrec,new--USER,12,Wed May 20 15:02:05 2015 UTC,That's nonsense. Probably what they meant is something like this:  char *s; // ... printf(s);   That has security implications unless you make assurances that the string s can't have any formatting symbols in it.
C_Programming,36mrec,OlderThanGif,4,Wed May 20 15:07:10 2015 UTC,"Right, it's based on the concept of ""Never Trust Input""."
C_Programming,36mrec,dragon_wrangler,3,Wed May 20 15:23:58 2015 UTC,printf()'ing string literals is fine. The problem comes in when you printf() variables for the format part of that function. CWE-134 has more information about this type of thing
C_Programming,36mrec,effect0r,1 point,Wed May 20 17:27:25 2015 UTC,"As other users have shown, the issue itself doesn't come from passing string literals without formatting strings in printf.  The issue is whenever printf is passed a string that contains format string(s) without any arguments to go with them.  In order to see for yourself, compile and run this:    char buf[] = ""AAAA"" ;   printf(""%16x.%16x.%16x.%16x.%16x.%16x."");   Hopefully you'll see the bytes 41414141 printed somewhere onto stdout.  When used correctly, printf actually pushes the list of function arguments onto the stack and then interprets the format string and pops them off accordingly.  Whenever printf doesn't get any arguments (as you saw from the snippet above) it just ends up popping off as many as it needs to satisfy the format string!  I've just begun researching format-string bugs and I think they're pretty neat."
C_Programming,36mrec,-Polyphony-,1 point,Thu May 21 15:36:24 2015 UTC,"The issue here simply relates to the format string, the first argument to printf. This string determines how many arguments printf will attempt to read off of the call-stack. For example, the format-string ""%s, %d:"" will cause printf to read a char * and an int off of the stack. printf doesn't actually know how many arguments you provided it, so it's just hoping you got it right (And compilers are good about checking the arguments you provide against format-strings).  The issue is that if you do something like this, printf has no way of knowing you messed up:  printf(""%s, %d:"", ""Opps, forgot the int..."");   I forgot to give printf an int variable. Since printf is never told how many arguments I actually gave it, it has no way of knowing that I didn't provide it an int. Instead, it will just simply read the next data (which is basically garbage) off of the call-stack and print it as an int. A malicious user could write a clever printf string to cause your program to execute arbitrary code, which is a huge security issue.  Like I noted, compilers warn about these situations, so it's unlikely you'd ever write the above out without the compiler throwing a fuss. The issue comes if you don't provide a string literal as the first argument to printf. Like this:  printf(s, ""Opps, forgot the int..."");   What does s contain? We don't know, and neither does the compiler (And at run time, it's entirely possible s will change as the program runs). If s contains too many % modifiers for printf, then printf will start reading past the arguments on the stack into who-knows-what.  However, it's worth noting that this:  printf(""Hello world!\n"");   Is perfectly fine - printf simply got a constant string with no format-specifiers. It's impossible to modify that string literal, so there's no danger that somewhere along the line this could get a format-specifier added to it. if you want to print out an arbitrary string s though, then you need to do this:  printf(""%s\n"", s);   That prints 's' as a string, and s won't be checked for format information because it's not the format-string, ""%s\n"" is."
C_Programming,36mrec,DSMan195276,1 point,Thu May 21 15:42:40 2015 UTC,"Thank you for the thorough reply. I think I must have misinterpreted what the book was saying, and this explanation makes sense."
C_Programming,36ln5m,tmtwd,6,Wed May 20 08:19:05 2015 UTC,"Because of precedence, *ptr1.x is parsed as *(ptr1.x). You can either use parentheses: (*ptr1).x or just use the -> operator: ptr1->x. a->b is shorthand for (*a).b."
C_Programming,36ln5m,FUZxxl,1 point,Wed May 20 08:23:54 2015 UTC,"It's also a good idea to use parentheses when dereferencing so that it is clear what you intend to dereference.  You might want to increment a pointer and get the value: x++, or you might want to increment the value pointed to: (x)++. With the first, you can easily confuse someone who doesn't have operator precedence memorized, so you use *(x++)."
C_Programming,36ln5m,f5f5f5f5f5f5f5f5f5f5,2,Wed May 20 12:40:13 2015 UTC,You need backslashes in front of the asterisks. Markdown is swallowing them.
C_Programming,36ln5m,joelwilliamson,2,Wed May 20 12:45:41 2015 UTC,(*pt1).x or pt1->x
C_Programming,36jzvz,tmtwd,18,Tue May 19 23:11:46 2015 UTC,"In your first example, ptrToConst is given an address to some place in memory (g), then that location is given the value 'a' and the result is printed out.  In the second example, ptr is given the address 97 (the ASCII value of 'a'), and then attempts to print out the contents of this address.  What's at address 97?  It's not a valid address, so you seg fault.  The lesson: 'a' is not a pointer, so don't cast it to one!  In the third example, ptr is never given an address at all (and so has an unknown, probably meaningless address), and then attempts to assign the value 'a' to whatever address it happens to hold.  Since the address probably is not valid, you seg fault.  The lesson: always initialize your variables!"
C_Programming,36jzvz,boredcircuits,5,Tue May 19 23:29:30 2015 UTC,"A pointer only stores the address (or in other terms: a pointer always points to a memory location). Trying to assign 'a' to a 'char *' doesn't work because 'a' does not reside in memory. When you first do  char *ptrToConst = &g;   You're assigning the memory location of variable 'g' to 'ptrToConst'. This means that the line  *ptrToConst = 'a';   Is the same as assigning 'a' to variable 'g'.  Try printing 'g' after assigning 'a' to '*ptrToConst' and you'll see it'll print 'a', too."
C_Programming,36jzvz,JustJanek,3,Tue May 19 23:37:59 2015 UTC,"'a' is a character literal.  Character literals have type int.  Assuming you're using an implementation that uses ASCII (which it is safe to assume that you are), 'a' is the same as the integer literal 97.  Anywhere that you wrote 'a' in your program, it's as if you'd written 97.  char *ptr = (char *)97;   This is a request to convert the integer 97 into a pointer to char.  The standard says that whether this is possible or not is implementation defined.  On the common implementations you're likely to encounter today, this is defined(*).  So you've created a pointer to char that points to address 97.  But how do you know there's anything valid at address 97?  You don't, and on most operating systems, the lowest page in memory is explicitly unmapped to catch segfaults, so it's virtually guaranteed that this will segfault.  Even if it didn't, it would be nonsense.  You can't form a pointer to a random address like that.  I think what you were probably going for was char *ptr = &'a'; but this is explicitly illegal and would have failed to compile.  You can't take the address of a character literal (or an integer literal), you can only take the address of a named variable, i.e. an lvalue.  In other words, 'a' does not reserve any storage space for a variable.  It's just a number, one which is used as part of a larger expression.  For example, if you wrote printf(""%d\n"", 10 + 20); there's no storage allocated for the 10 or the 20, and you can't take their addresses.  (In fact the compiler will almost certainly perform constant folding such that the values 10 and 20 don't even exist anywhere.)  (*) Note however that doing so is often a mistake.  Most compilers will warn you if you try to do this without a cast.  Putting a cast there like you've done silences the warning, but that doesn't mean the behavior is correct.  It's still just as broken as ever, except now there's no warning.  Your third example is just straight up undefined behavior.  Any attempt to access an uninitialized variable is undefined behavior.  For pointers this includes both accessing the pointer value itself as well as dereferencing it:  int i; printf(""%d\n"", i);      // undefined behavior  int *ptr; printf(""%p\n"", ptr);    // undefined behavior printf(""%d\n"", *ptr);   // undefined behavior"
C_Programming,36jzvz,Rhomboid,1 point,Wed May 20 05:40:01 2015 UTC,"char * ptrToConst = ""a""; //this is a valid null terminated string, which characters 'a' and '\0'  In your examples above, you can just change from single to double quotes and it will appear to do what you want. Single quotes are a multi-byte literal. Double quotes are a constant null-terminated string.  long derp = 'derp'; //this is a 4-byte character literal.  Yes, you can play fun compiler tricks with this stuff."
C_Programming,36jurr,tmtwd,8,Tue May 19 22:34:38 2015 UTC,"You're changing g, which is of type char. This is perfectly legal. When you point a pointer-to-constant at a variable, the variable doesn't magically gain const semantics; you just get a constant view to the variable. Try changing the value through ptrToConst; you'll find you can't, which is exactly as you would expect."
C_Programming,36jurr,acwaters,3,Tue May 19 23:00:31 2015 UTC,The value of your pointer doesn't change. It still points to the address of g. Only the contents of g are changed in your code.
C_Programming,36jurr,wallet_idiot,1 point,Tue May 19 22:51:09 2015 UTC,char g = 'u'; char t = 'q';  char const *ptrToConst = &g; char * const constPtr = &g; ptrToConst = &t;   Then how come this works?
C_Programming,36jurr,wallet_idiot,1 point,Tue May 19 22:58:10 2015 UTC,The pointers are declared differently and so mean different things. See the top answer from this question on stackoverflow.
C_Programming,36jurr,teringlijer,1 point,Tue May 19 23:01:57 2015 UTC,"ptrToConst is a pointer to a constant value; you cannot change the value through the pointer. But you can change the address that the pointer points to!  If you want an immutable pointer to an immutable value, try char const *const ptrToConst."
C_Programming,36jurr,teringlijer,3,Tue May 19 23:02:15 2015 UTC,The const declaration only guarantees something about ptrToConst. It does not guarantee anything about g. That ptrToConst at some time points to g is fine. That g is mutable is also fine. Further analysis is not performed by the language.
C_Programming,36jurr,himdel,2,Tue May 19 22:54:09 2015 UTC,"so what is the point of char const *ptrToConst  = &g;  It seems to me that to make it work the way we want it to work we would have to declare g as constant, and if we did that, it would be unnecessary to declare ptrToConst as constant, unless it is for documentation purposes."
C_Programming,36jurr,teringlijer,3,Tue May 19 23:00:44 2015 UTC,"Oh, it's not used to protect g, it's used to protect g from changes via ptrToConst. It would protect you from *ptrToConst = 'r'; so that you can pass ptrToConst to a function and be reasonably  able to expect that g won't change, but that's it. And of course the function might cast the pointer to (char *) (or have a memory related bug..)."
C_Programming,36jurr,garion911,1 point,Wed May 20 00:46:12 2015 UTC,this is what I was trying to understand :)
C_Programming,36iny7,TheDusen,4,Tue May 19 17:51:43 2015 UTC,"I believe that ebp + 2 isn't memory which your program ""owns"", because it never requested it.  So when you try to access it to print it out, the memory manager can say essentially ""access refused"" and segfault, but it's not required to do this.  I could be wrong though - I don't know any assembly so I don't know what you're doing in that line.  I assume you're filling ebp with a pointer to memory that your program owns, though.  If you're not filling it with that, then any attempt to access the memory in ebp with or without adding 2 will be using an initialised variable, and the computer is allowed to segfault on that."
C_Programming,36iny7,lishyguy,1 point,Tue May 19 18:01:22 2015 UTC,"Your right about the inline assembly, that's the only way that I've found to get ebp, which should allow access to that memory right?"
C_Programming,36iny7,lishyguy,6,Tue May 19 18:37:14 2015 UTC,"I don't really know how memory management of assembly code works, to be honest, and I don't know what *ebp is meant to represent after the line asm(...);, but I do know that the value of ebp (i.e. the pointer) should now have something in it.  So I know that after the asm() line you've put something in ebp, but I don't know what that is, and I definitely don't know what's in the memory that ebp points to (which is the value of *ebp).  Your program definitely owns the memory where ebp is stored, but it probably doesn't own where ebp points to, so trying to deference the pointer is invalid and can segfault.  Even if you own *ebp then you might not own *(ebp + 2).    Here's an example with simplified memory.  We'll assume that I own no memory other than what I explicitly request and mention.  First let's request enough space to store a char *.  char *ptr;   So there's nothing useful (just garbage) in ptr, and dereferencing ptr with *ptr can segfault, because ptr almost certainly points to memory we don't own.  Let's assume that the value of ptr is stored at 0x10, and that our char * is 8 bytes long, so it uses memory 0x10 to 0x17.  Now let's request some memory, and store some characters in that memory.  char array[24] = ""abcdefghijklmnopqrstuvw"";   Let's assume that sizeof(char) == 1 and that the compiler stored array[0] in memory address 0x18, array[1] in address 0x19 and so on up to array[23] in 0x2f.  So now our memory looks like this:  Offset:  0x00   0x01   0x02   0x03   0x04   0x05   0x06   0x07   0x08   0x09   0x0a   0x0b   0x0c   0x0d   0x0e   0x0f    0x00   ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??    0x10   <-----------------------ptr----------------------->     'a'    'b'    'c'    'd'    'e'    'f'    'g'    'h'    0x20   'i'    'j'    'k'    'l'    'm'    'n'    'o'    'p'    'q'    'r'    's'    't'    'u'    'v'    'w'   '\0'    0x30   ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??     ??   Where the question marks repesent values we don't know, in memory addresses that we don't own.  Now, if we set ptr = 0x23, then we're allowed to do *ptr because we own 0x23.  If we do  printf (""%x\n"", *ptr);   we'll get the output 0x6c, because 'l' in ASCII is 153, which is 0x6c in hex.  We can even do  ptr += 2; printf (""%x\n"", *ptr);   and get out 0x6e, which is 'n' in ASCII (since we're now looking at memory address 0x25).  But if we have ptr = 0x25 and we try to do  ptr += 16; printf (""%x\n"", *ptr);   we would probably get a segfault, because we're trying to access memory value 0x35, which we don't own.  We're perfectly allowed to add 16 to ptr, because 0x35 is a valid pointer (there was no overflow or anything like that), but as soon as we try to dererence it (*ptr), we're trying to read memory which we don't have access to.  For security, the computer can block this request, and that's a segfault.  Remember that we definitely own the memory where ptr is stored, but not necessarily the memory that it points to.    Now the comparison to your code is that filling ebp with any number is fine - that's an allowed operation.  But the pointer now stored in ebp could point anywhere.  It could point to memory that you're allowed to read.  It might not.  It might point to the very very last address in memory that you have permission to read.  In the latter case, accessing *ebp would be allowed, but *(ebp+2) would segfault.  Without knowing what value is stored in ebp, you don't know if you own that memory or not.  Bear in mind that computers aren't required to segfault when you access out-of-bounds memory, I believe.  They often do, and that's the best case scenario, because you know something's gone wrong - if it accesses out-of-bounds memory and doesn't segfault then it could be overwriting important data that the program needs to run!"
C_Programming,36iny7,lishyguy,1 point,Tue May 19 19:25:01 2015 UTC,"Thanks for the reply. I think I figured out where the issue is. I'm compiling while making a .s file, it all compiles as gcc -m32 progmain.s prog.s -o prog. That's where the restriction is coming in. I have no idea why this is the case though. It runs fine while using the two c files."
C_Programming,36iny7,lishyguy,1 point,Tue May 19 19:54:52 2015 UTC,"It sounds like there may well still be a memory problem somewhere around - compiling it in steps shouldn't (in general) make previously acceptable memory suddenly out-of-bounds.  When compiling it in a single step, though, it's possible that the slight variations in how GCC works means that you're now getting ""lucky"" and whatever you're filling ebp with is accidentally pointing to owned memory.  When it comes to segfaults, the order of blame normally goes:  1. blame the code 2. blame the code 3. blame the code ... 10000. maybe suspect the standard library 10001. maybe suspect the compiler 10002. maybe maybe very maybe suspect the hardware"
C_Programming,36iny7,lishyguy,2,Tue May 19 20:02:59 2015 UTC,You're right. What i'm trying to do is display the last arguments passed into a recursive function. I was going off this stack overflow answer:  http://stackoverflow.com/questions/26967446/print-the-function-arguments-in-recursive-function
C_Programming,36iny7,DSMan195276,3,Tue May 19 20:19:47 2015 UTC,"Yeah, C really doesn't want you to do that - C is sometimes called ""portable assembler"", because it abstracts the different assembly languages, while still being very close to the machine terms of how computers work.  Using inline assembler makes your program only work on that very specific assembler language, and playing with the stack trace and whatnot assumes a very specific memory layout - it's not surprising that Mac OS X and Linux are handling things differently.  Your Mac box is probably 64-bit too, and while the -m32 option should help a bit, it probably doesn't do the whole job of making 64-bit instructions and layout identical to 32-bit.  If you want a recursive function to know what arguments the original one was called with, I'd just pass them as additional parameters at the start, and keep passing them down the chain.  If you want to keep a record of every set of parameters, write them out into an array somewhere.  You're essentially trying to read them from the stack trace like an emulated array here, so I'd just make my life simpler and save them in a format of my own choosing."
C_Programming,36iny7,FUZxxl,1 point,Tue May 19 20:28:43 2015 UTC,"Also, to more directly answer the title question: different compilers and different operating systems / kernels handle memory management differently, and memory can depend on the state of the computer at runtime.  So maybe you got lucky on your Mac, but maybe if you reboot it, you might get a segfault when you turn it on again - the fact that it segfaults on any computer is generally indicative that there's memory corruption somewhere.  In general, it's a good thing if the segfault happens, because it tells you that something went wrong."
C_Programming,36kpv3,tmtwd,3,Wed May 20 02:29:02 2015 UTC,"Your makerect_pointers function is making copies of the arguments passed into it  struct rect_pointers makerect_pointers( struct point pt1, struct point pt2)   and then you are grabbing the addresses of the local arguments  struct point * tmp1 = &pt1; struct point * tmp2 = &pt2;   As soon as that function returns, those addresses to those variables are no longer valid."
C_Programming,36kpv3,ryl00,1 point,Wed May 20 02:50:41 2015 UTC,"I also tried this but I have the same problem  struct rect_pointers makerect_pointers( struct point pt1, struct point pt2){    struct rect_pointers temp;    temp.pt1 = &pt1;   temp.pt2 = &pt2;    return temp; }"
C_Programming,36kpv3,ryl00,2,Wed May 20 03:13:47 2015 UTC,"Same problem.  What you need is something like this:  struct rect_pointers makerect_pointers( struct point *pt1, struct point *pt2){   struct rect_pointers temp;   temp.pt1 = pt1;   temp.pt2 = pt2;    return temp; }   and then call it like this:  struct rect_pointers abc = makerect_pointers(&point1, &point2);"
C_Programming,36il8b,RandomMarvellousGuy,1 point,Tue May 19 17:34:02 2015 UTC,"Here's a website that tells you how to make a minesweeper solver.    If that doesn't help, please share more detail."
C_Programming,36il8b,zenkibudo,2,Thu May 21 03:27:25 2015 UTC,"Thanks a lot for answering, I have already lost hope for being noticed here!   But... Uhm.. The thing is, my aim isn't to create a minesweeper solver, I'm quite sure it would be easier to download it, my aim is to learn how to programm in C by creating a minesweeper solver. I had seen the link you posted but the author made it in Java, which is not really my point.   But hey, man, thanks for answering anyway!"
C_Programming,36il8b,zenkibudo,1 point,Thu May 21 08:15:22 2015 UTC,"Understood.  Will this be your first project?  If so, it's a worthy goal, but might prove discouraging as a first.   There is no shame in creating small programs that do very little in someone else's eyes.  Main thing is to learn C in small bites, creating small programs that do dumb little things.  As your expertise grows, you will naturally consider adding some features to one of you minor efforts, and one day it's become something much larger and a bit impressive.    Then entertain more seriously your worthy goal: the minesweeper solver.  At that time, you might find the code ideas pouring out of you faster than you can type.  That's how it happened for me.  And like you say -- perhaps it's really not about the minesweeper solver at all, but just working with ideas to learn C.  In this case, any dumb little idea will do: a program that tells the current time and date.  Now, put it in a nice GUI.  Now, add a full calendar display....last month, this month, next month, side by side.  Add buttons that let the user view the calendar 5 years into the future -- or back.   It sounds trivial, until you start to code it.       Any little thing will do.  You'd be surprised how far the idea of 'adding features' will take you.  All the complexity you need to learn will arrive, but in your own, manageable steps, and according to your growing capabilities."
C_Programming,36il8b,zenkibudo,2,Thu May 21 08:23:54 2015 UTC,"Oh, you seem to be so much right...  Since I have been programming for around 5 years already, I thought that I could just learn how to programm in C in like 1 week. I suppose that you are right that it is completely something different and I shouldn't just start with such a project. Thank you for opening my eyes, I will start with that ""future-adding"" method of yours!"
C_Programming,36il8b,raevnos,1 point,Thu May 21 12:30:37 2015 UTC,"If your native language is Java, then your estimate  might not be too far off :D   Really, a lot of languages look like C these days, with nearly identical syntax to C.  But, I am waaaay biased so you cannot trust my opinion on this whatsoever.   I did port a whole Java Tetris game to C in a couple days some years back.   The extreme similarity made this possible; I knew nothing of Java that time.    Hence, I began my warped opinion that gobs of language creators have cloned and ripped off C syntax unashamedly for decades. lol"
C_Programming,36jgn6,rbg1827,1 point,Tue May 19 20:57:36 2015 UTC,Why do you want to do that?
C_Programming,36jgn6,FUZxxl,1 point,Wed May 20 08:36:15 2015 UTC,I want to minimize the number of programming languages I have to learn and maximize the number of languages that my code can be translated to.
C_Programming,36jgn6,_predator_,1 point,Wed May 20 20:15:37 2015 UTC,"I don't know, is it possible to translate C/C++ into any other higher language? Isn't it more so that you can access libraries written in C/C++ from pretty much any other higher level language like C#, Java or Python?"
C_Programming,36j5ft,drinkmorecoffee,6,Tue May 19 19:45:10 2015 UTC,"You should check out cppcheck, I may not be the best for everything but I don't know of any better general-purpose static code analysis that is open-source (GPL)."
C_Programming,36j5ft,cym13,1 point,Tue May 19 19:59:35 2015 UTC,Thanks!  I'll have a look.
C_Programming,36j5ft,rolloyolo,5,Tue May 19 20:10:36 2015 UTC,clang static analyser is fine
C_Programming,36j5ft,raevnos,1 point,Tue May 19 20:01:34 2015 UTC,"Looks like it's a Mac tool so I'll have to build from source on Windows or Linux, which is a pain.  Still, I'll have a look and see if it makes sense.  Thanks for the tip!"
C_Programming,36j5ft,moocat,5,Tue May 19 20:11:11 2015 UTC,"Dunno about Windows, but it's likely available as a package in most linux distributions. clang-analyzer in arch."
C_Programming,36j5ft,dvhh,3,Tue May 19 21:35:15 2015 UTC,Coverity.
C_Programming,36ei9p,-Kuroh-,3,Mon May 18 19:34:38 2015 UTC,"Best: splay, because they require the least amount of rebalancing in an insert or delete operation. (Assuming you don't use splaying to implement them or include it as a last step)."
C_Programming,36ei9p,raevnos,1 point,Mon May 18 20:14:15 2015 UTC,So Splay -> BR -> AVL?
C_Programming,36ei9p,raevnos,1 point,Tue May 19 17:56:38 2015 UTC,"Depends on lookup patterns in your data.   Edit: If you just care about insert and delete speed, though, that's not an unreasonable order (note that most documentation on splay trees includes splaying a new node to the root; I don't think that's strictly necessary but doing so might change things)."
C_Programming,36ei9p,raevnos,1 point,Tue May 19 18:05:41 2015 UTC,You should also look at skip lists.
C_Programming,36ei9p,FUZxxl,1 point,Tue May 19 18:08:41 2015 UTC,"I had not heard of it yet, thanks for the tip."
C_Programming,36ei9p,FUZxxl,2,Tue May 19 18:15:08 2015 UTC,That depends. What is your ratio of insertions and deletions to lookups? What does your data look like?
C_Programming,36ei9p,FUZxxl,1 point,Tue May 19 08:34:13 2015 UTC,"I don't have a specific function in mind, just looking for an overall view."
C_Programming,36ccij,terrellgorence,5,Mon May 18 06:28:24 2015 UTC,"http://beej.us/guide/bggdb/  That's my favorite GDB guide. It's really nice, I recommend you all check it out."
C_Programming,36ccij,Mines_of_Moria,2,Mon May 18 20:11:51 2015 UTC,You'll love this then. https://github.com/longld/peda
C_Programming,36ccij,Ch1gg1ns,1 point,Mon May 18 15:33:05 2015 UTC,"IME, it can be pretty buggy. And the more complicated the stuff you're doing, the more likely it is to totally bug out. It sort of sucks if you get used to relying on it and then you can't use it for a significant fraction of your hairiest bugs.  I'm not saying you shouldn't try it -- it's pretty nice, but it blows up in my face pretty often. YMMV, of course."
C_Programming,36ccij,halax,2,Mon May 18 18:23:49 2015 UTC,"GDB brings back bad memories with Bomb Lab. But if anyone wants to learn GDB, I think you can find some bombs lying around."
C_Programming,36ccij,Vungtauno,1 point,Mon May 18 20:42:49 2015 UTC,"The binary bomb? that was a lot of fun, but became silly when you finally realize you can set a breakpoint at explode()"
C_Programming,36ccij,textwolf,1 point,Mon May 18 14:20:03 2015 UTC,"I have to admit, I've never used gdb and this made me want to look at it."
C_Programming,36ccij,tehcyx,1 point,Mon May 18 18:44:48 2015 UTC,"You can cycle through different layouts using the layout command, so that if you have the source file readily available you can view the context of your code in either the C if gdb finds your source code or the assembly and not just each line as it executes.  The configurability of print and x are also pretty nice. display things as hex data, binary, octal, pretty much whatever you want."
C_Programming,36ccij,textwolf,1 point,Mon May 18 14:15:29 2015 UTC,"Take it a step farther and get cling. You can definately learn a lot faster with a gdb or a true repl. I use cling to test my ideas out beforehand and not having to constantly compile is awesome. Although it is ideally for C++, but I barely notice."
C_Programming,36ccij,NamesAreHardasHell,1 point,Mon May 18 19:00:36 2015 UTC,call me old fashioned
C_Programming,36e5i0,Kwbmm,5,Mon May 18 17:56:49 2015 UTC,"You read 6 bytes for the status message, but it's usually only 5 bytes long (You're also not checking to see if it's +OK). Do you think it could be filling in that last byte with the first one of the file size?"
C_Programming,36e5i0,raevnos,1 point,Mon May 18 18:32:30 2015 UTC,I don't think so because debugging shows that dummy is storing 0 up until the call to Recv is performed.
C_Programming,36e5i0,raevnos,5,Mon May 18 20:44:04 2015 UTC,"Why would dummy be anything but 0 until then? You set it to 0 and then don't do anything with it until that read. It's the last byte of the status array that you need to be looking at.  I see another bug involved in printing out the status code. What if you get '-ERR\r\n'? 6 bytes, no trailing 0, passed to printf(), which expects a 0-terminated string. Similarly, if you're not seeing garbage now with a '+OK\r\n', it's because you're lucking out and that last byte is getting set to 0.  The server sends 9 bytes: '+OK\r\nABCD' (Where ABCD is the size in big endian format), and then the  contents of the file '12345'. I'm willing to bet that your issue comes from reading the status string as '+OK\r\nA', and then size 'BCD1'. The file size is probably small enough that byte A is 0, meaning you don't see the problem in your printf of the status code."
C_Programming,36e5i0,raevnos,1 point,Mon May 18 20:51:15 2015 UTC,:s
C_Programming,36e5i0,BigPeteB,1 point,Tue May 19 03:43:16 2015 UTC,"statusshould be fine because if you look at its definition is:  char status[STATUS_MSG_SIZE+1] = {0};   And STATUS_MSG_SIZE is 6. Also when I fill it through Recv:  Recv(sockFD, status, STATUS_MSG_SIZE, 0);  //Get the status   STATUS_MSG_SIZE is passed as how many bytes to read, so I see no way in which status could have another character different from \0 as terminating character.  Also the status is printed after the Recvso I can check what's being printed.   The server sends 9 bytes: '+OK\r\nABCD'   The server can't do that. Each sequence of bytes (status message, file size, bytes composing the file) are sent through separate Sendcalls from the server, so I know that if I'm receiving a status message it will be at most 6 chars."
C_Programming,36e5i0,BigPeteB,3,Tue May 19 10:51:16 2015 UTC,"I missed seeing the extra byte in the definition of the status array, but everything else I said still stands.    The server sends 9 bytes: '+OK\r\nABCD'   The server can't do that. Each sequence of bytes (status message, file size, bytes composing the file) are sent through separate Sendcalls from the server, so I know that if I'm receiving a status message it will be at most 6 chars.   That's not how socket streams work. Datagrams, yes, but streams appear as a single stream of bytes to the client that is read from as much as requested no matter if the server writes a byte at a time or a megabyte."
C_Programming,36e5i0,BigPeteB,2,Tue May 19 17:50:38 2015 UTC,"More importantly, the send and recv APIs return the number of bytes sent/received, which may be fewer than the number of bytes you requested to send/receive.  As a TA, I saw a lot of students not check the return value. Then I tested their program reading a 1GB file, which of course doesn't fit in a network buffer all at once. Unsurprisingly, everyone's programs told me it got ridiculous transfer speeds like 300TB/s, because it wasn't actually receiving the entire file, just the first few tens or hundreds of KB.  If OP checks return values, it would be a lot more obvious that when he reads ""+OK\r\n"" into his buffer, he's reading 6 bytes, not 5.  The bug would probably also be obvious if requesting a file larger than 16MB. That will have a size >= 0x01000000, and it will be apparent that the first byte of the size is ending up in the status message array."
C_Programming,36e5i0,raevnos,1 point,Tue May 19 19:03:00 2015 UTC,"Granted this might be the error, here I did some testing and added a printf after each Recv call, in this way:  printf(""retVal of dummy: %d, should be %lu\n"", retVal,sizeof(uint32_t));   Here's the output (client):  ./client 127.0.0.1 1234      Enter a filename to fetch (at most 26 characters): Specification.pdf     retVal of STATUS: 5, should be 6     Received status: +OK      retVal of dummy: 4, should be 4     Received file size: 16466     retVal of input_file: 16384, should be 16466     Enter a filename to fetch (at most 26 characters): Specification.pdf     retVal of STATUS: 5, should be 6     Received status: +OK      retVal of dummy: 4, should be 4     Received file size: 16466     retVal of input_file: 16466, should be 16466     Enter a filename to fetch (at most 26 characters): manual.html     retVal of STATUS: 6, should be 6     Received status: +OK      retVal of dummy: 4, should be 4     Received file size: 16861244     retVal of input_file: 65863, should be 16861244     Enter a filename to fetch (at most 26 characters): Specification.pdf     retVal of STATUS: 5, should be 6     Received status: +OK      retVal of dummy: 4, should be 4     Received file size: 16466     retVal of input_file: 1024, should be 16466     Enter a filename to fetch (at most 26 characters): Specification.pdf     retVal of STATUS: 5, should be 6     Received status: +OK      retVal of dummy: 4, should be 4     Received file size: 16466     retVal of input_file: 16466, should be 16466     Enter a filename to fetch (at most 26 characters): manual.html     retVal of STATUS: 5, should be 6     Received status: +OK      retVal of dummy: 4, should be 4     Received file size: 65864     retVal of input_file: 65864, should be 65864     Enter a filename to fetch (at most 26 characters): manual.html     retVal of STATUS: 6, should be 6     Received status: +OK      retVal of dummy: 4, should be 4     Received file size: 16861244     retVal of input_file: 65863, should be 16861244     Enter a filename to fetch (at most 26 characters): QUIT   Here's the output (server):  ./server_tcp_2.3 1234     (./server_tcp_2.3) socket created     (./server_tcp_2.3) listening on 0.0.0.0:1234     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59208     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) --- received string 'GETSpecification.pdf'     (./server_tcp_2.3) --- client asked to send file 'Specification.pdf'     (./server_tcp_2.3) --- sent '+OK     ' to client     (./server_tcp_2.3) --- sent '16466' - converted in network order - to client     (./server_tcp_2.3) --- the other host has closed connection. Closing socket.     (./server_tcp_2.3) - connection closed by server     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59209     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) --- received string 'GETSpecification.pdf'     (./server_tcp_2.3) --- client asked to send file 'Specification.pdf'     (./server_tcp_2.3) --- sent '+OK     ' to client     (./server_tcp_2.3) --- sent '16466' - converted in network order - to client     (./server_tcp_2.3) --- sent file 'Specification.pdf' to client     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) - connection closed by client     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59217     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) --- received string 'GETmanual.html'     (./server_tcp_2.3) --- client asked to send file 'manual.html'     (./server_tcp_2.3) --- sent '+OK     ' to client     (./server_tcp_2.3) --- sent '65864' - converted in network order - to client     (./server_tcp_2.3) --- sent file 'manual.html' to client     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) - connection closed by client     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59218     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) --- received string 'GETSpecification.pdf'     (./server_tcp_2.3) --- client asked to send file 'Specification.pdf'     (./server_tcp_2.3) --- sent '+OK     ' to client     (./server_tcp_2.3) --- sent '16466' - converted in network order - to client     (./server_tcp_2.3) --- the other host has closed connection. Closing socket.     (./server_tcp_2.3) - connection closed by server     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59221     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) --- received string 'GETSpecification.pdf'     (./server_tcp_2.3) --- client asked to send file 'Specification.pdf'     (./server_tcp_2.3) --- sent '+OK     ' to client     (./server_tcp_2.3) --- sent '16466' - converted in network order - to client     (./server_tcp_2.3) --- sent file 'Specification.pdf' to client     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) - connection closed by client     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59222     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) --- received string 'GETmanual.html'     (./server_tcp_2.3) --- client asked to send file 'manual.html'     (./server_tcp_2.3) --- sent '+OK     ' to client     (./server_tcp_2.3) --- sent '65864' - converted in network order - to client     (./server_tcp_2.3) --- sent file 'manual.html' to client     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) - connection closed by client     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59223     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) --- received string 'GETmanual.html'     (./server_tcp_2.3) --- client asked to send file 'manual.html'     (./server_tcp_2.3) --- sent '+OK     ' to client     (./server_tcp_2.3) --- sent '65864' - converted in network order - to client     (./server_tcp_2.3) --- sent file 'manual.html' to client     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) - connection closed by client     (./server_tcp_2.3) waiting for connections ...     (./server_tcp_2.3) - new connection from client 127.0.0.1:59224     (./server_tcp_2.3) - waiting for commands ...     (./server_tcp_2.3) - connection closed by client     (./server_tcp_2.3) waiting for connections ...   Now as you can see (by cross-checking the filesize on both the client and the server) the files are passed correctly even if I did no change (except for saving the return value of the Recv function). I'm not sure how to interpret this: I may agree with you there is an error, but how do I solve it?"
C_Programming,36e5i0,rafleury,1 point,Tue May 19 20:40:49 2015 UTC,"You say the files are passed correctly, but I see no evidence of that.  Most of your lines indicate a discrepancy between the number of bytes you requested, and the number of bytes you received.   retVal of STATUS: 5, should be 6  retVal of input_file: 16384, should be 16466  retVal of input_file: 65863, should be 16861244  retVal of input_file: 1024, should be 16466   You're not even getting the same filesize every time.   Enter a filename to fetch (at most 26 characters): manual.html  Received file size: 16861244  Enter a filename to fetch (at most 26 characters): manual.html  Received file size: 65864   Go reread the comments we've given you here. Ask yourself this: ""If +OK\r\n is 5 bytes, why am I trying to read 6 bytes?""  Get a piece of paper, and draw the data that's being sent on the network, byte by byte. It's just a continuous stream of bytes, so when you ask to read 6 bytes, you're going to get the next 6 bytes, even if this means reading part of another field.  Edit: formatting"
C_Programming,36e5i0,rafleury,1 point,Tue May 19 21:37:39 2015 UTC,"But I read 6 bytes because I don't know which will be the status message: if I receive a -ERR\R\N it's six bytes, how am I supposed to know in advance the amount of bytes that I have to read?  As I understand it, this is an issue of the specifications (??), status messages should have all the same size, right?   Is it possible to fix this?   Also, how can you explain the fact that now the file transfer is working (despite the fact that the size saved in dummy is wrong) and the files are not corrupted? The output I put above led, at each try, to a correct file transfer."
C_Programming,36e5i0,rafleury,2,Wed May 20 08:26:57 2015 UTC,"As I understand it, this is an issue of the specifications (??), status messages should have all the same size, right?   I'm glad you noticed this! Your professor or book author deliberately designed a protocol that's difficult to read. They want you to find the solution to this problem.  You're right, it would be easier if every status message was 6 bytes long. But they're not, and you aren't allowed to change it. So you have to deal with it. That's part of what this homework assignment is trying to teach you.  There are a couple of ways you could do this. Since this is your homework, I don't want to just give you the answers :-) but I'll ask some questions to point you in the right direction.  Option 1: You could always read 6 bytes. This means that sometimes, you'll have read 1 byte of the next segment of the response. How many bytes remain in that next segment? How would you reassemble those bytes into a single entity so that you can read them the way you want?  Option 2: Maybe you don't need to read so many bytes. Can you determine the response by looking at the first 5 bytes? What about the first 1 byte? Then you can decide what to do next, which might mean reading some extra bytes to complete the segment of the response you're currently reading. (Think of this like the file size... you can't read the whole response until you know the file's size, because you wouldn't know how many bytes to read. So maybe the same is true for the status code. Maybe you can't read the whole status code until you know how long you're expecting it to be.)  Option 3: Maybe if you had enough of the message, you could just search for the status code. Is there a byte or bytes that every status code has in common? Could you search for them if they were in a buffer? Maybe you could allocate a large buffer (say 1024 bytes) and Recv as much data as will fit in there. (But don't use Readn, because that might ask for too many bytes. What happens when you ask it to readn 1024 bytes, but the response is shorter than that?) Then you search the buffer for the status code. Once you find it and decode it, that will determine what else you would find in the buffer, and you can copy and process it appropriately. Some responses might be too big to fit in the buffer all at once, so you might need to call Recv again to get more of the response.   Also, how can you explain the fact that now the file transfer is working (despite the fact that the size saved in dummy is wrong) and the files are not corrupted? The output I put above led, at each try, to a correct file transfer.   You're correct; technically I can't say for certain, since I didn't see the contents of the files that you saved after downloading them. What I can say for certain is this: either your output is wrong or your file transfers aren't working correctly.  Unless you've been changing the files on the server, they should have the same size every time. But your output indicates that they don't. So either your output is wrong but the files are somehow saved correctly in spite of this (which seems illogical), or the output is correct, and your program thinks the files are different sizes across different runs (in which case it's very unlikely that it's saving their contents correctly).  Check the files! If you fetch a file just once, does it have the correct size? Does it have the correct contents? Are there bytes missing at the beginning or end of the file? If you fetch it multiple times, deleting the saved file in between, is it identical every time?  If you're able to, get a copy of the files another way, and use a comparison tool to compare the original file with the one you downloaded. If you're on Linux, you can just diff the files and it will tell you if there are differences between them.  You can also just check them manually. If it's a PDF, you should be able to open it in a PDF reader. If it's an HTML page, you should be able to open it in a browser."
C_Programming,36e5i0,tmtwd,1 point,Wed May 20 13:12:40 2015 UTC,"That's not how socket streams work. Datagrams, yes, but streams appear as a single stream of bytes to the client that is read from as much as requested no matter if the server writes a byte at a time or a megabyte.   Didn't know that, noted! Thanks!"
C_Programming,36e5i0,niekze,2,Tue May 19 20:42:20 2015 UTC,I'd also move the socket setup code outside the while loop if it's supposed to allow multiple transfers per session.
C_Programming,36e5i0,rafleury,1 point,Mon May 18 18:35:04 2015 UTC,This part was moved inside to see if it solved the issue. Originally the Socket and Connect where put outside of the loop.
C_Programming,36e5i0,Aransentin,2,Mon May 18 20:27:35 2015 UTC,white space is your friend when it comes to readability
C_Programming,36e5i0,BigPeteB,1 point,Tue May 19 03:43:34 2015 UTC,How do you know the server is responding to your request correctly?  Are you stepping through the code to be sure the part you identified is really the trouble spot?
C_Programming,36e5i0,Aransentin,1 point,Mon May 18 18:35:33 2015 UTC,"What do you mean by this comment: ""//Because we receive a 32-bit unsigned integer, it is at most 10 chars (232-1)""?"
C_Programming,36e5i0,BigPeteB,1 point,Mon May 18 18:39:26 2015 UTC,"This is a comment I put near an array of characters and can be removed. At first I thought the server was sending the size encoded as a string, but then I realized that it was actually transmitting an unsigned long.  So that comment was a leftover of a previous (wrong) approach."
C_Programming,36e5i0,raevnos,1 point,Mon May 18 20:42:27 2015 UTC,"How do you know the server is responding to your request correctly?   I know because the server prints on screen the size of the requested file in host byte order before converting and sending it. Also, the specifications say to test our client (and then our server) with the provided server (client): the both provided client and server were tested to see if they properly work (running the client against the server) and they do.   Are you stepping through the code to be sure the part you identified is really the trouble spot?   I debugged the program and went throught the function calls:  Recv(sockFD, (void *)&dummy, sizeof(uint32_t), 0);   No matter what, it saves into dummy a wrong number. I was able to follow the calls up until recv(..) was called, but then the debugger doesn't allow me to step inside the function (anyway I assume recv is working properly since it's part of the socket API )."
C_Programming,36c7bn,tmtwd,6,Mon May 18 05:22:33 2015 UTC,"The subtle difference is that, in the pass-by-value version, a copy of each argument is made and passed to the function (in addition to the copies that are put into temp). This may lower performance slightly."
C_Programming,36c7bn,Jack126Guy,1 point,Mon May 18 05:40:44 2015 UTC,"is it better style to use the pass by reference function, then?"
C_Programming,36c7bn,FUZxxl,1 point,Mon May 18 06:57:07 2015 UTC,"Yes. For best performance, pass a constant pointer. Just change the first line of the function definition to this:  struct rect makerect_byref(const struct point *pt1, const struct point *pt2){"
C_Programming,36c7bn,baudvine,1 point,Mon May 18 17:31:55 2015 UTC,cool thanks
C_Programming,36c7bn,F54280,2,Mon May 18 21:15:03 2015 UTC,"They're functionally equivalent. Depending on how clever the compiler is, there might be a speed difference but it could swing either way. The largest difference is in what the function signature suggests: that #2 might change the contents of the points. Add a const and you're golden.   E: fwiw, you can probably tickle your compiler to output assembly code, that'll show you exactly how different the resulting programs are."
C_Programming,36c7bn,ralusp,2,Mon May 18 05:45:18 2015 UTC,"The second one can have undefined effects if you pass NULL or invalid pointers.  Also, in C++ those functions could have vastly different results, if struct rect had copy constructors / operator*() implemented."
C_Programming,36c7bn,F54280,2,Mon May 18 06:36:00 2015 UTC,They will behave very differently - the second function is using the pt2 parameter for both points.  ;)
C_Programming,369qpc,RockDiesel,4,Sun May 17 15:45:41 2015 UTC,This is really nice.
C_Programming,369qpc,ruertar,-1,Sun May 17 21:38:00 2015 UTC,Got excited for a moment until I saw it doesn't work in Windows :)
C_Programming,36b0cu,tmtwd,5,Sun May 17 22:23:16 2015 UTC,"Just like const integers, const pointers can be assigned to when they're declared. It makes sense for the same reason: const int foo wouldn't be much use if you could never assign it a value. The assumption is that when you declare the variable, whether an integer or a pointer, you know what value it should have."
C_Programming,36b0cu,BigPeteB,2,Mon May 18 00:39:57 2015 UTC,"Behold, a great snippet on C and const behavior:  http://en.wikipedia.org/wiki/Const_(computer_programming)#C_convention"
C_Programming,36b0cu,angdev,1 point,Tue May 19 18:34:05 2015 UTC,"apparently const pointers have to be assigned a value when they are declared   Assignment and initialization are different things, even if they both use the = sign. The distinction matters more in C++ than C, but C programmers should still be aware of it.  char * const ret3 = &b; is initialization, not assignment."
C_Programming,36b0cu,bames53,2,Tue May 19 22:24:50 2015 UTC,"so int * b = &c; is initialization, and int b = 32 is assignment?"
C_Programming,36b0cu,bames53,1 point,Tue May 19 22:28:41 2015 UTC,"No, both of those are initialization. Initialization happens in a declaration; assignment is separate."
C_Programming,36bnrf,tmtwd,1 point,Mon May 18 02:00:56 2015 UTC,"Are you sure it prints 54 and 0, or does it print 0 and 54? And could that possibly have to do with the fact that you're not actually returning anything from makerect? :P  You've got some undefined behavior going on here; your compiler's making it easy on you by implicitly returning zero (or you got lucky), but reading an undefined value like this is a good way to end up with a trap. The language will let you get away with a lot of shenanigans, and nobody can catch every mistake. Remember to turn on warnings to protect against oversights like this!"
C_Programming,36bnrf,acwaters,1 point,Mon May 18 03:34:42 2015 UTC,"cool that fixed it, how did  I not notice !!"
C_Programming,369bz7,IskaneOnReddit,6,Sun May 17 13:06:02 2015 UTC,"I see no reason, why the second way should not be possible.    It's not nearly as simple as you think it is.  Consider:  typedef struct {     foo *f;     // ... more fields here ... } bar;  // ... 10,000 lines later ...  typedef struct {     // ... } foo;   You're requiring the compiler to parse an arbitrary amount of code, it's not always going to be just a few lines ahead.  And that code might contain references to bar, whose declaration hasn't yet even been finished.  As a pathological case, consider:  typedef foo bar;   // compiler required to scan ahead to see what foo is...  typedef char static_assert[(sizeof(bar) == sizeof(int)) * 2 - 1];  typedef int foo;   The second line is a form of a static assertion.  It asserts that sizeof(bar) == sizeof(int) is true, otherwise this is attempting to declare an array of size -1, which is invalid and causes parsing to halt.  In other words, to know whether the second line is a valid declaration requires knowing sizeof(bar), but knowing sizeof(bar) under your proposal would have required being able to parse the second line on the way to parsing the third line, resulting in a logjam.  What's the compiler supposed to do?  You can't make more exceptions, like saying that you skip over declarations that mention bar, because then you introduce the possibility that the speculatively parsed version and the eventual actual parsed version are different, which opens up a whole can of worms.  And you can't special case things like array sizes, because that's just one of many ways of writing a static assert.  You may say that such a program is not likely to occur and is written by an idiot, but that's not the point.  You have to deal with all the ramifications that a proposal makes possible, not just the ones that are easy to deal with.  The point is that lookahead/speculative parsing is a landmine.  It's not simple or trivial AT ALL.  Just name your struct like every other C programmer and move on."
C_Programming,369bz7,Rhomboid,3,Sun May 17 14:58:20 2015 UTC,"The C language has been carefully constructed so that one pass over the source code is sufficient to parse C code. This especially means that the source code cannot reference tthings it doesn't know about. Except for function calls (where the compiler basically guesses), you are not allowed to reference things that haven't been declared yet.  Contrary to your statement, lifting this requirement is complicated as some syntax can only be parsed when the type of an identifier is known. For instance, consider this statement:  foo = (*bar)(baz);   Depending on the what bar is, this could be...   When bar is a variable, a call to the function pointed to by bar with argument baz, the result is assigned to foo. When bar is a type, a cast of baz to type *bar.   In your case, things get even more complicated due to scoping rules. If the compiler sees Node inside the struct declaration, it doesn't know if Node is a reference to a type declared inside the struct or a reference to a global type. This is something very hard to resolve. The extra effort required to support using undeclared identifiers is in general too complex for this little bit of convenience."
C_Programming,369bz7,FUZxxl,1 point,Sun May 17 13:59:26 2015 UTC,"Thanks. Well it's not impossible, but it would increase compilation time and introduce a lot of bugs in the compiler at first :P"
C_Programming,369bz7,Aransentin,3,Sun May 17 14:40:48 2015 UTC,Is it possible to forward declare this typedef   typedef struct Node Node; struct Node {         Node* next; };
C_Programming,369bz7,Aransentin,3,Sun May 17 14:01:37 2015 UTC,"Yea, but the struct is not anonymous."
C_Programming,36aik1,yotamN,2,Sun May 17 19:49:49 2015 UTC,"Quick and dirty:  Read the signature file (Using fread(), making sure when you call fopen() to use the 'b' flag so it works on Windows) into one uint8_t array. Load the other file into another array the same way.   Now, standard C is interesting in that while the function for searching a string for a character (strchr()) has a duplicate for searching raw bytes (memchr()), there's no such equivalent for strstr(). If you're on a linux or BSD OS, you can use memmem(). If you don't have that option, you have to do the search yourself. Which is probably the point of the exercise... memchr() and memcmp() will be very useful. Find the first byte in the search array that's the same as the first byte in the signature, use memcmp() from there to see if there's a match, repeat as needed.  EDIT: A more advanced version might bypass stdio completely and use mmap(), and possibly a fancy search algorithm like BMH or KMP."
C_Programming,36aik1,raevnos,1 point,Sun May 17 20:08:56 2015 UTC,Considering I don't understand what you said in the EDIT I will go with your first suggestion. But wouldn't it be easier to store the binaries in char and compare them with strstr?
C_Programming,36aik1,raevnos,2,Mon May 18 18:32:36 2015 UTC,"No. They can have 0 bytes all over the place, not just at the end. Using functions that work with strings on data like that will not work as intended."
C_Programming,36aik1,FUZxxl,1 point,Mon May 18 18:40:32 2015 UTC,Notice that the naïve approach to implement memmem() is an O(n²) operation. Have a look at the Knuth-Morris-Pratt algorithm for a better approach.
C_Programming,369pfl,logicalcontradict,3,Sun May 17 15:33:09 2015 UTC,"It's fine that you asked here- but you'll probably get more responses in /r/learnprogramming. It's just a bigger subreddit, and dedicated to questions like these.  I haven't used Clion before, so I won't be of much help, but good luck!"
C_Programming,369pfl,LackingIsntEmpty,2,Sun May 17 15:52:23 2015 UTC,You'll have to post the code for extended help.
C_Programming,369pfl,_COMPLEX_H,2,Sun May 17 15:58:07 2015 UTC,"Get yourself a compiler, compile the code and fiddle around until it works. You're not providing nearly enough information for me to help you any further though."
C_Programming,369pfl,FUZxxl,1 point,Sun May 17 18:23:48 2015 UTC,Do you have access to a mac or Linux os?
C_Programming,369pfl,Mines_of_Moria,0,Sun May 17 21:06:57 2015 UTC,"I am also currently learning c. We used visual studios to run, compile and debug. If you are a student (university) you can probably get visual studios for free. There are also online compiler's but I don't know whether you can debug"
C_Programming,369pfl,-007-bond,1 point,Sun May 17 16:24:47 2015 UTC,"Visual Studio is free for everyone, not just students."
C_Programming,368vhb,tmtwd,9,Sun May 17 08:21:14 2015 UTC,"The const refers to the char, not to the pointer."
C_Programming,368vhb,Rhomboid,3,Sun May 17 08:28:58 2015 UTC,You can make a pointer const by putting const after the astrix.  http://stackoverflow.com/a/1143272
C_Programming,368vhb,eLBEaston,3,Sun May 17 08:25:39 2015 UTC,"That's a pointer to constant data. The address, as you said, is mutable. You're changing where the pointer points to, not what's there. What that const allows the compiler to do is to put the data into read-only memory, that's why you can't write to a literal string: it's represented as a const char *, so that you can still loop over it the normal way, but the memory itself is read-only."
C_Programming,368vhb,Ubertekk,2,Sun May 17 08:29:56 2015 UTC,"For this to be useful, the function should return a const char *, which is appropriate for returning, say, a lookup-result into a dictionary of fixed strings.  You can always cast away the ""const"" though as you've done; C will help you, but at the end of the day you can do whatever you want to any memory you want. Best. thing. ever."
C_Programming,368vhb,bunkoRtist,1 point,Sun May 17 08:34:42 2015 UTC,"In fact, char *strrchr(const char *s, int c); is a Standard C function.  The issue arises because the function has to work with both char * and const char * inputs. If you make it return const char * then it will be annoying for people doing, say:  char buf[12] = ""fooblah""; char *ptr = strrchr(buf, 'b');   // compiler error *ptr = 'x';   The convention adopted by the C standard library is to accept char const * and return char *. When the function was originally designed, const wasn't even a part of the language. Making the return value be char const * would have broken existing programs (as well as leading to the above annoyance)."
C_Programming,368vhb,OldWolf2,1 point,Sun May 17 12:18:16 2015 UTC,"It depends on how it's declared.  You can either make the type const, the pointer , or even both  (const int * const foobar).   This page explains it pretty well:       there are two ways of declaring a const pointer: one that prevents you from changing what is pointed to, and one that prevents you from changing the data pointed to."
C_Programming,368vhb,chalk46,1 point,Sun May 17 11:22:09 2015 UTC,"Your declaration const char *ret declared a pointer to const char. The pointer itself is not constant, the value pointed to is. To get a const pointer to char, write  char *const ret"
C_Programming,368vhb,FUZxxl,1 point,Sun May 17 12:06:44 2015 UTC,read it backwards:   char const *ret; ret is a pointer to a const char  const char *ret; same thing (putting const before char is an exception to the rule)  char * const ret; ret is a const pointer to char  char const * const ret; ret is a const pointer to const char
C_Programming,368eg2,Gigglyp,4,Sun May 17 04:09:02 2015 UTC,"The ""no special characters"" check only checks if the character at offset 'i' is a special character or not and 'i' happens to point to your null terminator.  What you want to do instead is loop and check each character in the string excluding the last null terminator.    You'll run into the same problem with your digit check.  You need to iterate and check each character [0-i) to and keep a counter for each digit.  Then after the loop ensure the counter is >= 2.  You could work these checks right into your original 'while' loop."
C_Programming,368eg2,infey,3,Sun May 17 04:21:17 2015 UTC,"Keep track of how many numbers are in the string in your while loop. If p falls between 48 and 57 inclusive, it is a number, else it is something else.   Reference the ASCII chart"
C_Programming,368eg2,Lobreeze,2,Sun May 17 04:19:21 2015 UTC,"Make sure to only allow an input to be so big, so you can avoid buffer overflow attacks."
C_Programming,366kzs,MallocNofree,6,Sat May 16 17:29:52 2015 UTC,"strtok() uses hidden state, either a global variable or a local static variable. A function written in this style is called non-reentrant, and that is a very bad thing (usually) because it can't be used easily in multithreaded code. Some C libraries include a strtok_r() function which is reentrant (and thus has no hidden state).  getline() is a slightly different kettle of fish. The function itself doesn't have hidden state (probably), but the file descriptor (if you're on an operating system that uses file descriptors) just gets advanced when you read more data. Reading in from a file sequentially and keeping track of what offset you're in into the file is generally regarded at the operating system's job, and so any code implementing getline() sort of functionality won't need any hidden state. (It's also worth keeping in mind that some file descriptors may not be pointing to files at all, and may be infinite in length, and so it wouldn't be possible in general to keep an offset as state)"
C_Programming,366kzs,OlderThanGif,3,Sat May 16 17:39:19 2015 UTC,"Notice that getline() operates on a FILE*, which is an abstraction over whatever interface for IO the platform uses. Furthermore, notice that on UNIX, even when you stream data, there is still an offset into the file which you can get with ftell(). You just can't seek. This is also the reason why you can't read more than 264 bytes over a pipe on Linux."
C_Programming,366kzs,FUZxxl,2,Sat May 16 17:46:22 2015 UTC,This is also the reason why you can't read more than 264 bytes over a pipe on Linux.   I had no idea!!
C_Programming,366kzs,OlderThanGif,2,Sat May 16 17:48:46 2015 UTC,thanks!
C_Programming,366kzs,Pigsquirrel,2,Sat May 16 17:42:06 2015 UTC,"getline() saves its position because it uses files. Everything that uses files saves position using the builtin seek functionality of files. This isn't something that C provides, it's something that the operating system does natively. Think of files as a cassette tape. Reading or writing to the file causes the tape to move, but it doesn't reset until you manually rewind it.  strtok() is special and weird. It uses a static variable buried deep in the standard library. strtok() is evil.  Bonus answer: That's a bit of a tough one. The easiest way to build the chunk would be to use strcat() and a malloc'd char array and build the chunk in that, but it isn't as elegant as using the file offset.  I did a quick bit of googling, and getting the file offset actually seems to be rather difficult. lseek() apparently can be used to get the offset by lseeking 0 and returning the current offset (this link) or just use ftell() like a normal person. If you do take this approach, be careful, since readline() leaves the file positon at the end of what it read, where the next call to readline() will begin.  EDIT: The byte amount is not useless. getline() does some weird stuff with malloc() behind the scenes, and it needs to ""remember"" how big of a buffer is malloc'd or else things will explode. It uses the byte amount pointer to keep track of how big an area is malloc'd. You can also use this if you would like to reuse the buffer yourself for some purpose, since you would have no other way of knowing how big the buffer is.  Don't forget to free() the buffer after you finish a getline() session, too."
C_Programming,366kzs,bunkoRtist,2,Sat May 16 17:39:27 2015 UTC,"thanks!  man, C really is voodoo (at least to me)."
C_Programming,3674vf,H_Korean,2,Sat May 16 20:29:57 2015 UTC,"printf(""Enter the first time: ""); printf(""%d%d%d"", &a.hour, &a.minute, &a.second); printf(""Enter the second time: ""); printf(""%d%d%d"", &b.hour, &b.minute, &b.second);   Some of these should be scanf() calls. I'm pretty sure you can figure out which ones."
C_Programming,3674vf,dragon_wrangler,1 point,Sat May 16 20:51:47 2015 UTC,"I see; Also, earlier on, the portion involving:     int convertToSecond (struct time amount)     {         int t = amount.second;         t += (amount.minute *60);         t += (amount.hour *60 *60);         return t;     } Is that portion correct?   edit: Hm, I assume the scanf() should be right above each     printf(""%d%d%d"", &a.hour, &a.minute, &a.second); statements?"
C_Programming,3674vf,danmickla,2,Sat May 16 20:59:48 2015 UTC,You're almost done with the class and you still don't get that statements go in an order?   Srsly?
C_Programming,3674vf,dragon_wrangler,2,Sat May 16 21:11:54 2015 UTC,"Your convertToSecond() function looks correct. Your convertToTime() function doesn't.  Here's what you have right now:  second = amount %60; amount -= second; minute = amount %60 / 60; amount -= minute %60; hour = amount %3600;   Do you know what the relative precedence of the division and modulus operators are?   Try this instead:  second = amount %60; amount -= second; minute = (amount/60) %60; amount -= minute %60; hour = ((amount/60)/60) % 60;   Because of integer division, the subtraction lines are unnecessary, so you can also write it like this:  second = amount %60; minute = (amount/60) %60; hour = ((amount/60)/60) % 60;   As for the scanf statements, no. Two of the lines that I quoted should be replaced with calls to scanf instead of printf. The arguments will stay the same."
C_Programming,362np9,framelessframes,14,Fri May 15 16:11:20 2015 UTC,"This is hotly contested, not just for functions but everywhere you might have a brace.  I prefer the second style, for three reasons: I like plenty of vertical spacing, the function declaration line gets to be too busy when you also include function parameters, and vim has some shortcuts to jump between functions that only works when the brace is in the first column.  But I've also learned to not be too tied to any one style: it seems like every file I work with has a slightly different style, and I'll just conform to each as needed."
C_Programming,362np9,boredcircuits,10,Fri May 15 16:34:08 2015 UTC,I prefer and write the second. But I have worked at places where the first was preferred.  I find the second easier on the eyes for purposes of indentation.
C_Programming,362np9,MaxPowerGuy,8,Fri May 15 16:26:51 2015 UTC,"I use the first, in my opinion the tabbing makes it clear enough so that if you write  int main(int argc, char* argv[]) {     if (some_condition) {         do_something();     } else {         do_something_else();     } }   One could argue that why bother giving a whole line for the closing braces then? Well they nicely mark the end of the block, while the if / else / function name / for etc. nicely mark the beginning.  In the end for me it doesn't really matter, as long as you're consistent through your code whatever style you decide to use, and if you work with a team then you're not always (more like never) the one deciding about stuff like naming standards or code-style standards... So it's often about adapting more than deciding once and for all what way you're going to write your code.  And obviously, depending on the language, you don't even get to choose how to wrap your blocks, and honestly I don't know any dev that is only writing in one language."
C_Programming,362np9,LowB0b,5,Fri May 15 18:27:49 2015 UTC,"I use kernel style which combines the both. Functions are done like this:    int main() {     ; }     while switches, structs, loops, conditionals, etc... are done like this    switch (i) { case 1:     break; }   I learned about it here, and thought it made the most elegant code."
C_Programming,362np9,THRAKERZ0D,3,Fri May 15 20:43:48 2015 UTC,"Me too, but that is mostly because most of my work is done in the kernel. The same level switch & case is often contentious elsewhere though"
C_Programming,362np9,studioidefix,1 point,Fri May 15 22:20:37 2015 UTC,Plus you have the benefit of using their checking scripts to ensure you're doing it correctly.  scripts/checkpatch.pl
C_Programming,362np9,lucidguppy,-1,Sat May 16 10:58:48 2015 UTC,"That document is horrible - ""do it this way. Because: K&R. Inconsistent? Too bad, K&R.  BTW - these other things are non-K&R because we said so"""
C_Programming,362np9,motocali,1 point,Fri May 15 22:30:18 2015 UTC,"Style is subjective.  What do you want, do it this way because: Science?  IT isn't science.  It is style.  The kernel codebase is in -- Linux Kernel Style.  It is all arbitrary.   The important thing is that it is consistent (not the rules, but the implementation)."
C_Programming,362np9,robertmeta,0,Sun May 17 10:35:23 2015 UTC,"Perhaps, but the powers that be decided it so and it is the basis of every single line of code in the Linux kernel."
C_Programming,362np9,studioidefix,-2,Sat May 16 06:18:42 2015 UTC,"Perhaps, but the powers that be decided it so and it is the basis of every single line of code in the Linux kernel.   ba·sis ˈbāsəs/ noun the underlying support or foundation for an idea, argument, or process.  If the basis for every line in the kernel is to satisfy a couple of guys need to obnoxiously format code, Linux is definitely a more interesting project than I ever imagined."
C_Programming,362np9,motocali,6,Sat May 16 06:38:17 2015 UTC,"I use the second because it is traditional (and popularized through K&R). The reason for it is that original functions were declared like  main(argc, argv) int argc; char *argv[]; { }   So it was obvious where to put the brace. But in if, while, for, &c. statements having the brace on the same line was practical."
C_Programming,362np9,kotzkroete,3,Fri May 15 17:05:23 2015 UTC,"I prefer the first because there is less vertical whitespace than the second so I can read more code without having to scroll. It also encourages me to keep lines to a reasonable limit.  Ultimately, this basically comes down to personal preference and the style guide that the project uses. There are reasons for and against both styles, and the most important thing is to be consistent."
C_Programming,362np9,spurious_interrupt,2,Sat May 16 04:54:07 2015 UTC,"Which one do you use   I follow the standard of the codebase, (sometimes industry,) language and platform I am working on.   and why?   Because coding style is about communication.  If you want to communicate with the largest number of people, speak in the style that most of the people in that community are going to use.  Doing anything else unprofessional amateur hour nonsense.    You never need to come up with your own ""style"", basically ever (unless you have written a new language).  If you are working in an existing standardized codebase, follow the standard -- might seem obvious but some idiots mess this simple thing up.  If you are in a wildly unstandardized codebase with absolutely no norms or doing greenfield development, pick the most popular and well documented existing standard.  Every second you spend bike-shedding ""style"" is completely wasted, of NEGATIVE value -- as you just introduced another standard, and now you have to document it and maintain that documentation.  By following an existing standard you avoid all the trivial pointless nonsense, examples and documentation make more sense and are in ""your"" style, and you generally get the documentation on the style (style guide) and tooling support for free.  I personally hate GNU style (a lot), yet when working in a GNU codebase, I use it, and not via some third party tooling to reformat.. I simply adapt.  It takes a few days to really get in the flow, but it makes reading the REST of the GNU style codebase less painful once you acclimate.  There are old projects that have styles that are very unique (I am thinking of qmail in specific), and in those"
C_Programming,362np9,robertmeta,1 point,Sat May 16 05:36:10 2015 UTC,"Original Source  Title: Standards  Title-text: Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit.  Comic Explanation  Stats: This comic has been referenced 1536 times, representing 2.4108% of referenced xkcds.    xkcd.com | xkcd sub | Problems/Bugs? | Statistics | Stop Replying | Delete"
C_Programming,362np9,xkcd_transcriber,1 point,Sat May 16 05:36:34 2015 UTC,"I personally prefer what wikipedia has just told me is the ""Allman"" style - http://en.wikipedia.org/wiki/Indent_style"
C_Programming,362np9,Cyclobox,2,Fri May 15 17:38:54 2015 UTC,"Indent style:       In computer programming, an indent style is a convention governing the indentation of blocks of code to convey the program's structure. This article largely addresses the free-form languages, such as C programming language and its descendants, but can be (and frequently is) applied to most other programming languages (especially those in the curly bracket family), where whitespace is otherwise insignificant. Indent style is just one aspect of programming style.  Indentation is not a requirement of most programming languages, where it is used as secondary notation. Rather, programmers indent to better convey the structure of their programs to human readers. In particular, indentation is used to show the relationship between control flow constructs such as conditions or loops and code contained within and outside them. However, some programming languages (such as Python and occam) use the indentation to determine the structure instead of using braces or keywords; this is known as the off-side rule, and in these languages indentation is meaningful to the compiler, not just a matter of style.  This article uses ""brackets"" to refer to what are known as ""parentheses"" in American English, and ""braces"" to refer to what are known as ""curly brackets"" in American English.     Interesting: HTML Tidy | Indent (Unix)   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,362np9,autowikibot,1 point,Fri May 15 17:39:27 2015 UTC,"Which one do you use   The second one.   why?   Make the code more readable, in my opinion. But I use the first one when I write Java so..."
C_Programming,362np9,khoyo,1 point,Fri May 15 17:42:51 2015 UTC,"I use the second style almost exclusively in my own code, the only exception being blocks that fit on one line. No particular reason; it's the style I learned years ago with C++, and I stuck with it and other less conventional elements (identifiers are always lowercase) through years of Java in school.  That said, I suppose it's important to not get too caught up in these holy wars but simply adapt the style used in whatever codebase you're working on. When it's your codebase, you'll get to set the conventions."
C_Programming,362np9,acwaters,1 point,Fri May 15 18:07:18 2015 UTC,Second for functions but the first variant for conditional expressions and loops.
C_Programming,362np9,creatid,1 point,Fri May 15 18:25:33 2015 UTC,"I use the second because our company's style guide mandates it. I prefer the first, though."
C_Programming,362np9,rogue780,1 point,Fri May 15 18:46:43 2015 UTC,"I realize this is the C_Programming thread but...  I prefer uncuddled as I find it more readable, but Tcl being my go-to language, it requires cuddled-everything (unless you escape the end of the line... bleh)."
C_Programming,362np9,deusnefum,1 point,Fri May 15 19:30:14 2015 UTC,"The 2nd, definitely.  Everything lines up nicely that way: the opening bracket (in any editor worth its salt) and the closing bracket will share the same left margin/indent, greatly improving chances of a clean compile, first time (no, ""whoops i forgot a brace"").  As a beginner, I used 1st method.  But, I'm Not saying only beginners code that way.  I'm saying that over time, I could appreciate more what the 2nd method does for clean/readable/compilable code."
C_Programming,362np9,zenkibudo,1 point,Sat May 16 00:08:36 2015 UTC,"This is purely personal preference. The more important point is that in your own code you chose one and stick to it, and if you are in someone else's code base you stick to what they do (or whatever the style document says)."
C_Programming,362np9,crookedkr,1 point,Sat May 16 00:24:53 2015 UTC,Regardless: a brace means an indent.
C_Programming,362np9,danmickla,1 point,Sat May 16 01:34:32 2015 UTC,"Beauty may be in the eye of the beholder on that particular point, but there's at least one brace style choice that I'd say with some conviction should not be done: leaving them out when they're optional. Don't do that. Really, just type the darn things, it doesn't take that long. You don't want to repeat the goto fail thing."
C_Programming,362np9,bunkoRtist,1 point,Sat May 16 10:53:35 2015 UTC,"The second style makes matching of braces much much easier because the symmetry is obvious on visual inspection. It's less of a problem with a good editor, but man... in reality though you'll be conforming to the codebase you're in. The worst possible thing is to mix styles."
C_Programming,362pcr,Chronomath,3,Fri May 15 16:24:29 2015 UTC,"Can you post the code where you're assembling the IP header and you're sending the packet? Without it, it's hard to tell where things are going wrong.  Also, just as a heads-up, I think what you're trying to do is a lot easier achieved with a few iptables rules (in case you're running Linux)."
C_Programming,362pcr,thefeistelnetwork,2,Fri May 15 20:04:21 2015 UTC,Port zero?
C_Programming,362pcr,neilalexanderr,3,Fri May 15 19:33:41 2015 UTC,"He's not biding it, should it matter ? The raw socket is for sending purposes only.  OP, actual code might be helpful, without that you're just guessing where your issue is and asking people to help"
C_Programming,362pcr,studioidefix,1 point,Fri May 15 21:09:02 2015 UTC,"I am happy to be told that I am wrong, but I would expect that there may still be some routing decisions made by the operating system based on the sockaddr provided (i.e. interface selection)."
C_Programming,362pcr,neilalexanderr,2,Fri May 15 21:13:16 2015 UTC,"Well yes, but the port number is not involved in routing decisions. In fact, there is not even a port number in the IP header."
C_Programming,362pcr,thefeistelnetwork,2,Fri May 15 22:02:53 2015 UTC,"Agreed, but a sockaddr represents a socket endpoint, not an IP host. An endpoint with port 0 is not valid, so just be sure that the error is not the result of a validation check."
C_Programming,362pcr,neilalexanderr,1 point,Fri May 15 22:23:15 2015 UTC,"That is correct if you're talking about a TCP or UDP socket. Since this is a raw IP socket, the rip_output() function (which doesn't care what's going on in the layers above IP) will handle the data before passing it on. If the IP_HDRINCL option is set - which is the default on Linux - the rip_output() function will expect the IP header in the first 20+ bytes of the payload and the sin_addr member is only used to determine the output interface (sin_port member is never consulted, see below).  OP also mentioned that his sendto() call returned -1 with errno EAFNOSUPPORT, which usually means there is something wrong with the IP header that was passed. An invalid value in sin_port with a TCP/UDP socket would have resulted in errno being set to EINVAL.  For those who like details: The data takes the following path: sendto() -> sendit() -> sosend() -> rip_usrreq() -> rip_output() -> ip_output() -> L2. The first three calls are protocol-agnostic and deal with stuff at the socket layer, including copying of data from the userspace to the kernel, and all the IP related stuff happens in the following three calls. The L2 part depends on the interface, it would be looutput() for loopback devices, ether_output() for ethernet, etc. and may call further functions. The following are the relevant parts of the rip_usrreq() and rip_output() functions.  int rip_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam, struct mbuf *control) {     struct inpcb *inp = sotoinpcb(so);     /* ... */     switch(req) {         /* ... */     case PRU_SEND:         {              u_long dst;               if(so->so_state & SS_ISCONNECTED) {                  /* ... */                  dst = inp->inp_faddr.s_addr;              } else {                  /* ... */                  dst = mtod(nam, struct sockaddr_in*)->sin_addr.s_addr;              }              error = rip_output(m, so, dst);              m = NULL;              break;         }         /* ... */     }     /* ... */     return(error); }  int rip_output(struct mbuf *m, struct socket *so, u_long dst) {     /* ... */             if((inp->inp_flags & IP_HDRINCL) == 0) {         M_PREPEND(m, sizeof(struct ip), M_WAIT);         ip = mtod(m, struct ip*);         /* ... */         ip->ip_src = inp->inp_laddr;         ip->ip_dst.s_addr = dst;         /* ... */     } else {         ip = mtod(m, struct ip*);         if(ip->ip_id == 0)             ip->ip_id = htons(ip_id++);         opts = NULL;         flags |= IP_RAWOUTPUT;         ipstat.ips_rawout++;     }     return(ip_output(m, opts, &inp->inp_route, flags, inp->inp_moptions)); }   The ip_output() function fills out the remaining fields in the IP header (again, depending on the socket options), looks up a route from the routing table (including caching and verification of routes), deals with multicast and broadcast, checks if the packet can be sent on the selected interface, and takes care of fragmentation. I have omitted this function because the code is not really relevant to prove my point. So the bottom line is: if you create a socket with socket(AF_INET, SOCK_RAW, IPPROTO_RAW), the sin_port member will be ignored (and the sin_addr member will be ignored if you used connect() on the socket). The source is from 4.4BSD-Lite, so it may not be exactly the same as in the Linux kernel, but the Socket API and the concepts are the same.  Source: TCP/IP Illustrated Volume 2, Wright/Stevens, Pearson Education"
C_Programming,362pcr,thefeistelnetwork,1 point,Sat May 16 17:19:14 2015 UTC,"Very informative and precise, thanks!"
C_Programming,362pcr,neilalexanderr,1 point,Sat May 16 18:38:54 2015 UTC,"Yhea sorry should have posted more info. But atleast I was able to solve it. I was passing the address to the sockaddr_in not the pointer, this was causing the error."
C_Programming,362pcr,domen_puncer,1 point,Fri May 15 23:13:02 2015 UTC,"Note that we couldn't really find the issue for you with info you provided.  Ideally, you'd provide the simplest possible example that compiles and shows the problem. The (un)surprising side-effect is that it's likely you'll solve the issue while creating that example."
C_Programming,35z6mv,Hillford,3,Thu May 14 19:11:28 2015 UTC,"If you choose to go with K&R, Steve Summit's class notes are a really good companion resource, explaining aspects that the authors leave a bit light."
C_Programming,35z6mv,legobreath,2,Thu May 14 20:48:08 2015 UTC,"thanks for these man, these are great!"
C_Programming,35z6mv,tmtwd,5,Thu May 14 23:52:24 2015 UTC,"http://home.netcom.com/~tjensen/ptr/pointers.htm //this page is very clear and easy  http://cslibrary.stanford.edu/102/  and the resources in the sidebars.  If you learn how to manage pointers, structures, memory management, and if you can figure out how to implement a linked list then I think that is a good start for learning C.  The K&R is classic, but I got it a year ago and I mostly use it as a reference. If you can manage to learn from it, it is probably the best way to go."
C_Programming,35z6mv,PriceZombie,1 point,Thu May 14 20:32:51 2015 UTC,"thanks m8, appreciate the help!"
C_Programming,35z6mv,necrophcodr,1 point,Fri May 15 00:26:23 2015 UTC,The C Programming Language   Current $52.89     High $62.58      Low $40.99    Price History Chart and Sales Rank | GIF | FAQ
C_Programming,35z6mv,qwertyuiop-1,1 point,Thu May 14 19:13:01 2015 UTC,Adding my own contribution for any other newbies that come by  koding.com seems to be an awesome resource; Allows you to code on the cloud without downloading a unix/linux OS and gives you tips to get started!
C_Programming,35z6mv,Lobreeze,1 point,Thu May 14 19:38:31 2015 UTC,"downloaded Ubuntu, and began programming   I keep seeing this idea from beginners that C is a linux thing or you need to install linux if you want to learn to program in C. Can somebody please explain where they're getting this idea? This isn't an anti-linux rant in any way, I'm just curious about the source of this misunderstanding."
C_Programming,35z6mv,tmtwd,4,Thu May 14 20:54:35 2015 UTC,"It's easier and a more natural part of the environment. If you want to use the, for instance, native development environment of visual Studio, you might run into issues in regards to C."
C_Programming,35z6mv,tmtwd,3,Thu May 14 22:24:52 2015 UTC,I'm guessing because linux distros (as well as most *Nix desktop os's) come with a compiler and other stuff already.
C_Programming,35z6mv,Lobreeze,2,Thu May 14 22:19:32 2015 UTC,"Ill go ahead and give my response on why I did it;  I was told to, LOL!  just heard it was ""easier""  like i said, I know shit about programming m8, so I figured hell ill listen until I understand whats going on;"
C_Programming,35z6mv,Lobreeze,2,Thu May 14 23:44:34 2015 UTC,"Nothing about C is easy... is there not an introductory class you can take before ""advanced C programming""???  I'm sorry but I'm just trying to wrap my head around how any school lets a student with 0 *nix experience and 0 programming experience be expected to take an advanced C class."
C_Programming,35z6mv,Lobreeze,1 point,Fri May 15 07:03:15 2015 UTC,maybe it is a euphemism for beginner c?
C_Programming,35z6mv,tmtwd,0,Fri May 15 07:51:24 2015 UTC,"No, that was one of the issues we had, was that we spend the first 2 weeks of the course ""reviewing C basics"" then jump right in; Which is why im trying to get a head start now;  also, we have to do stuff that sounds really weird to me, like tests involving code on PAPER that we have to debug  :D"
C_Programming,35z6mv,ChaoticxSerenity,2,Fri May 15 14:25:55 2015 UTC,"odd, it sounds like you should be more than prepared for the course if you spend the summer learning.  Code on paper is a way to help you 'reason' about code.  For example, if you're just using gcc you may not know why a program runs or crashes, but on paper you have to think it through step by step to see what happens. I do something similar on occasion, although many people aren't fans."
C_Programming,35z6mv,tmtwd,1 point,Fri May 15 19:25:02 2015 UTC,"That isn't weird, you should be able to debug code on paper..."
C_Programming,35z6mv,Lobreeze,0,Fri May 15 17:28:53 2015 UTC,"alright, itll be my first go at programming, figured everything should just be done on the compiler;"
C_Programming,35z6mv,tmtwd,1 point,Fri May 15 18:30:10 2015 UTC,a compiler isn't going to debug a program for you
C_Programming,35z6mv,Lobreeze,1 point,Fri May 15 18:31:48 2015 UTC,"Right; You have any tips and tricks to share on things that left you banging your head against the wall when learning C? Or any sort of methodology I should apply when going about programming in C, or even programming in general?"
C_Programming,35z6mv,tmtwd,0,Fri May 15 19:25:12 2015 UTC,"Yeah, learn something easy, and learn the basics of programming before even thinking about touching C.  I'm still flabbergasted that you are forced to take an advanced C course with 0 programming experience. How is that even possible? What kind of program are you in? I'm seriously at a loss here"
C_Programming,35z6mv,Lobreeze,0,Fri May 15 19:33:57 2015 UTC,"I dont have that option; I study electrical engineering at a local university in my state; Im starting to believe you are not here to be supportive, rather antagonistic, even if you do not notice it yourself;"
C_Programming,35z6mv,tmtwd,0,Fri May 15 20:53:05 2015 UTC,"linux is great, and ubuntu is easy. Its a great place to start!"
C_Programming,35z6mv,Lobreeze,1 point,Fri May 15 01:20:01 2015 UTC,I think the train of thought (not saying this is correct) is:      C is a low level language Linux seems like it gets down to the nitty gritty low level parts Learn C using Linux
C_Programming,35z6mv,tmtwd,0,Thu May 14 23:08:15 2015 UTC,"I totally agree, macs have gcc so it works just like linux.  Windows supports c perfectly well, too.  But linux is awesome"
C_Programming,35z6mv,themadnun,-1,Thu May 14 23:12:16 2015 UTC,Windows supports c perfectly well???   I literally don't even know where to begin with how wrong that comment is...
C_Programming,35zm2d,ipconfider,2,Thu May 14 21:07:16 2015 UTC,"Don't forget to pass an address into scanf:  scanf(""%d"", &z[a][b]);   Your compiler should at least be giving you a warning about this."
C_Programming,35zm2d,boredcircuits,1 point,Thu May 14 21:13:59 2015 UTC,"Yes , I found about it Just a moment later ! .   Now I am trying to display the numbers on the screen :   for (c=0; c<2; c++)  {     for (d=0; d<2; d++)     printf(""\n""); {      printf(""%d"", z[d][c]); } }   This is not working. Any other ideas about this problem ?"
C_Programming,35zm2d,boredcircuits,3,Thu May 14 21:22:36 2015 UTC,"I'm going to reformat your code, and then it should be more obvious:  for (c=0; c<2; c++) {     for (d=0; d<2; d++)         printf(""\n"");     {          printf(""%d"", z[d][c]);     } }   If this isn't how the code looks to you in your editor, that's a problem.  Code formatting is an essential tool for visualizing what the code is actually doing.  I'm going to clean it up just a bit more, for clarity:  for (c=0; c<2; c++) {     for (d=0; d<2; d++)     {         printf(""\n"");     }      printf(""%d"", z[d][c]); }   In this case, your inner loop only prints a new line each time.  The outer loop prints one number, but that number's going to be out to lunch (because d is 2, outside the range of your variable).  You probably meant to have the printing of the new line a bit lower down in the code, after the inner loop finishes.  Basically, swap the printfs in that last bit of code."
C_Programming,35zm2d,boredcircuits,1 point,Thu May 14 21:29:03 2015 UTC,Thanks a lot ! . Now my final question :   If i put in   #define N 2   and replace every two with N. I will get sometimes(?) the error        message Permission Denied   Id  returned 1. exit status    Any idea why this is ?  this also happens when I undo everything (changing everything back to two's) until I restart the compiler.
C_Programming,35zm2d,necrophcodr,3,Thu May 14 21:41:54 2015 UTC,"That's not a C problem.  It sounds like the program is still running when you try to recompile it, and the compiler can't overwrite the executable while it's still in use.  Restarting everything probably closes your program along the way."
C_Programming,35zm2d,_predator_,1 point,Thu May 14 22:02:21 2015 UTC,-snip-
C_Programming,3604tj,andrespm_,1 point,Thu May 14 23:41:11 2015 UTC,"The easiest way is not to expect the user to write the entire array at once, call 10 times the function to get 1 number and build your array afterward."
C_Programming,3604tj,cym13,1 point,Thu May 14 23:44:56 2015 UTC,The function will only repositionate the array
C_Programming,3604tj,studioidefix,2,Thu May 14 23:46:21 2015 UTC,"repositionate   The correct term here is 'sort' the array.   What /u/cym13 meant was ask user to input one number at a time, keep a counter as to how many numbers were entered and when you hit 10, stop expecting new input. How you take the input does not affect your sorting function."
C_Programming,3604tj,studioidefix,1 point,Fri May 15 02:30:28 2015 UTC,"That's not the problem anymore. Now I have to write the function that sorts the array as in the picture.   for (int i=0;i<10;i++)        {       if(a[i]==i) a[i]=i;  else a[i]=0; }   It doesn't work, it doesn't sort the array, and doesn't fill the unwritten elements with 0"
C_Programming,3604tj,studioidefix,1 point,Fri May 15 02:37:55 2015 UTC,"It won't sort the array, this code will only work when the input given is the same as the output required. I think you need to rethink your approach, the code you have written is not a sorting algorithm"
C_Programming,3604tj,Erno3000,1 point,Fri May 15 03:30:16 2015 UTC,Can you help  me a little more?
C_Programming,3604tj,dragon_wrangler,2,Fri May 15 03:40:05 2015 UTC,"I'll give you some pseducode. You have two arrays, input[] & output[]. You fill in input via the user. This can be done directly, without any need for sorting :  for (i = 0; i < count; i++)     if i exists in input[]         output[i] = i     else         output[i] = 0"
C_Programming,3604tj,jdonniver,0,Fri May 15 05:10:42 2015 UTC,What exactly do you need help with?  You could end a program using  exit();   if that's your only question.  Also take a look at   assert();
C_Programming,3604tj,jdonniver,1 point,Fri May 15 00:30:34 2015 UTC,"for (int i=0;i<=10;i++)   {     if (b[i]<=9 && b[i]>=0)     {   a=1;         printf(""aa"");}     else         printf(""intente de nuevo"");         exit(0); }   I have this, but it only works if the number out of the range is at the first position"
C_Programming,360837,pleasehelpidontknowh,2,Fri May 15 00:09:31 2015 UTC,"For future reference, you can go to /r/cpp_questions for help with C++."
C_Programming,360837,Jack126Guy,3,Fri May 15 05:49:56 2015 UTC,"What exactly do you have a problem with? The general structure of the program, or the decryption problem itself?  If it's the latter: from what I understand, the general idea of what you have to do is roughly:   Find a possible match for the crib (for example, ""food"" may have been encrypted as ""abbc"", or ""gzzy"", you may choose either one). Determine a partial decryption function for the crib - which letters map to which letters (so that you can perform the decryption) Print the decrypted messages.   Step 1 is probably the hardest part, try and think about how you can solve this problem. keep in mind that a given letter will always map to the same letter, and if there are multiple possible matches for the crib, you can use any of them. 2. is just a question of comparing the crib with its match, 3. is just a question of applying the decryption information from step 2 to the ciphertext and printing it to stdout."
C_Programming,35x84b,tmtwd,6,Thu May 14 07:13:43 2015 UTC,"To understand that, you should split that typedef apart into two typedefs, since that's what the comma does. So you end up with this:  typedef struct cell cell; typedef struct cell *list;   If you look closely, you will notice that the * in the second typedef should actually go with the struct cell:  typedef struct cell * list;   So what is this doing? It's defining the type list to be equivalent to a pointer to a struct cell.   You could alternatively do the following to get a similar effect, although technically the types are different:  typedef struct cell cell; typedef cell* list;   In practice though they are identical."
C_Programming,35x84b,Genocidicbunny,3,Thu May 14 07:23:18 2015 UTC,"I'm not sure the last point is relevant (edit: has been removed now). The type is as it is because of the grammar and semantic rules, not because of greedy parsing."
C_Programming,35x84b,sftrabbit,2,Thu May 14 08:14:32 2015 UTC,"You're right. I wanted to point it out as a rule of thumb, but perhaps that asking a bit much."
C_Programming,35x84b,Genocidicbunny,1 point,Thu May 14 08:44:22 2015 UTC,interesting and confusing :)
C_Programming,35x84b,Antidote,2,Thu May 14 07:32:51 2015 UTC,Welcome to C!  It gets better.  Eventually all the little oddities just sort of come together and it all clicks.
C_Programming,35x84b,Chooquaeno,0,Thu May 14 08:53:50 2015 UTC,The pointer type syntax basically isn't consistent with anything else or anyone's expectations.
C_Programming,35x84b,smikims,1 point,Fri May 15 00:29:44 2015 UTC,"Yeah, IMO because of the grammar rules using commas like this can get needlessly confusing very quickly. That's why for the course I TA'd this semester we make the students do a typedef Node* NodePtr; so they don't try to do Node* a, b; and then can't figure out why it doesn't work."
C_Programming,35x84b,jaccovanschaik,7,Thu May 14 10:02:27 2015 UTC,"... which is exactly why putting the asterisk next to the type is wrong. A declaration of the type  Node * a;   does not say that a is a Node*. It says that *a is a Node. That is to say, if you apply the dereference operator (*) to a you get a Node, which is exactly what happens.  So that declaration should be  Node *a, b;   meaning that both *a and b are Nodes (and therefore a must be a pointer to a Node).  (I'm sorry, this is a pet peeve of mine)."
C_Programming,35x84b,smikims,1 point,Thu May 14 15:13:32 2015 UTC,"I agree, and that's the way I write it when I write C, but when you're teaching beginners that might not be obvious, especially since we're teaching C++ where it's much more common to put it with the type. But IMO it would have been better if the grammar rules just grouped it with the type since that's how most people naturally think of it."
C_Programming,35x84b,Genocidicbunny,1 point,Thu May 14 20:15:04 2015 UTC,So if there were no typedef declaration I would have to do this:  struct cell a; struct cell * list = &a;   which would be the same thing as:   cell a; list bs = &a;   with a typedef declaration.
C_Programming,35x84b,bames53,2,Thu May 14 20:09:01 2015 UTC,Correct!
C_Programming,35x84b,chalk46,2,Thu May 14 20:10:10 2015 UTC,"The way to read typedefs is to remove the typedef keyword and look at the resulting variable declaration:  struct cell cell, *list;   Hopefully you can see that this is a variable declaration, declaring the variables cell and list, where cell is a struct cell and list is a struct cell *.  What typedef does is turn a variable declaration into the declaration of type names, where the variable names become the type names:  typedef struct cell cell, *list;   declares two type names cell and list, where cell is the same as the type struct cell and list is the same as struct cell *.  As another example, recall that you can declare a variable of a struct type at the same time you define the struct:  struct foo { int a, b, c; } bar;  bar.a = 10; bar.b = 5;   bar is a struct foo variable. typedef works here as well:  typedef struct foo {int a, b, c; } bar;   Now bar is another name for the type struct foo.  structs can also be anonymous:  struct {int a, b, c; } bar;   and you can declare multiple variables:  struct {int a, b, c; } bar, *baz;   typedef works with these as well, causing bar and baz to be type names, even though the struct type itself is anonymous and can't be written directly.  typedef struct {int a, b, c; } bar, *baz;  bar b; b.a = 10;  baz ptr = &b;"
C_Programming,35w10k,meith1,2,Wed May 13 23:54:08 2015 UTC,"without reading the article, I'd guess proto is a struct variable with lots of function pointer members.  The #define _(N) proto.N macro is letting you do _(destroy)(...) or _(move)(...) instead of typing proto.destroy and proto.move."
C_Programming,35w10k,airuike,2,Thu May 14 00:13:07 2015 UTC,"proto is the name of something. Look for it in the rest of the source code (or in your IDE use ""go to declaration"")."
C_Programming,35w10k,OldWolf2,1 point,Thu May 14 01:27:19 2015 UTC,"With regard to your edit, add an extra enter after your sentence  like that. it will help. And then the 4 spaces before these three lines.   Good luck with the lessons"
C_Programming,35w10k,BlindTreeFrog,1 point,Thu May 14 02:37:33 2015 UTC,Could you please put four blanks in front of every line of code so the code comes out readable? Thank you.
C_Programming,35w10k,FUZxxl,-2,Thu May 14 09:20:19 2015 UTC,"I guess I'm gonna be the guy who comes out and says ""why?"".  There's been a ton of attempts to force an object oriented paradigm onto C, and you could spend time trying to follow anyone's particular attempt. If what you really wanted to learn was OOP you'd use C++ or Java, but if you're specifically interested in learning how OOP could be implemented on top of C please at least invest your time in learning one of the implementations that are economically not a waste of time like objective-c."
C_Programming,35w10k,BlindTreeFrog,5,Thu May 14 01:06:12 2015 UTC,"From the article:   I learned C before I learned Object Oriented Programming, so it helped me to build an OOP system in C to understand the basics of what OOP meant. You are probably the kind of person who learned an OOP language before you learned C, so this kind of bridge might help you as well."
C_Programming,35vmx9,tmtwd,17,Wed May 13 21:59:14 2015 UTC,"It fails because you're trying to free a pointer that lives on the stack (&d), not the heap (what you got from malloc).  Put the free before reassigning abc;"
C_Programming,35vmx9,boredcircuits,-1,Wed May 13 22:03:04 2015 UTC,interesting.
C_Programming,35vmx9,panderingPenguin,4,Thu May 14 00:00:39 2015 UTC,"Commenting further on his point, your code currently has a memory leak because the memory you originally malloc'd for abc is still allocated, but you no longer have any references to it so you couldn't free it if you wanted to. That's why he suggested you move the call to free to before you change the pointer in abc as this will fix the memory leak. On the other hand, d lives on the stack and will go out of scope when your function finishes execution so there's no need to free it as it will be cleaned up on its own."
C_Programming,35vmx9,boredcircuits,3,Thu May 14 01:13:34 2015 UTC,thanks!  Will the memory leak continue after the program has finished execution?
C_Programming,35vmx9,bames53,6,Thu May 14 01:40:25 2015 UTC,"No.  All memory the program uses, leaked or not, is reclaimed by the operating system when the program terminates.  This is a feature of the operating system though, not C."
C_Programming,35vmx9,Wiggledan,2,Thu May 14 02:16:53 2015 UTC,"Yeah, there are systems where this is not true: memory will remain leaked until the device is restarted."
C_Programming,35vmx9,boredcircuits,1 point,Thu May 14 18:04:04 2015 UTC,"Kind of an interesting FYI: Some other languages have what's called a garbage collector, and it automatically reclaims (""collects"") any leaked memory (""garbage"") to be used again, so you don't have to free it yourself like you do in C."
C_Programming,35vmx9,annath32,2,Thu May 14 03:00:05 2015 UTC,You can do garbage collection in C if you really want to.
C_Programming,35vmx9,bames53,1 point,Thu May 14 05:09:04 2015 UTC,"My operating systems theory is rusty, but I believe the answer is no. When the process ends, all of the actual memory that was allocated to a process as virtual memory is reclaimed by the OS, and that includes the heap space granted to it.  This may be a horrible/factually incorrect description though, so take it with a grain of salt."
C_Programming,35vmx9,bames53,2,Thu May 14 02:18:18 2015 UTC,"Look at it like this:  void *abc = malloc(10); printf(""%p\n"", abc);   This prints out the value returned by malloc(). In order to free the memory allocated by malloc, you must pass this value to free.  // other code  printf(""%p\n"", abc); free(abc);   If the value printed by this code is not the same as the value printed earlier, then the free call is not going to free the memory allocated by that malloc(). example  Furthermore, it doesn't matter how this value gets to free(). The user could type the address in, and as long as the right value is entered, then the deallocation works correctly. Try running the following program and see if you can type in input that allows it to complete successfully, and also see if you can get it to print out an error message like your original program shows.  #include <stdio.h> #include <stdlib.h>  int main() {   void *abc = malloc(10);   printf(""The allocated memory has the address: %p\n"", abc);    void *input;   printf(""Enter an address to be deallocated: "");   scanf(""%p"", &input);    printf(""The address about to be deallocated is: %p\n"", input);   free(input); }"
C_Programming,35vmx9,OldWolf2,1 point,Thu May 14 18:30:12 2015 UTC,What if I accidentally enter an address that is not part of my program and vital to my computer's os or something?
C_Programming,35sjq3,tmtwd,15,Wed May 13 03:40:23 2015 UTC,"C does not have references, and a pointer is a pointer.  Moreover, it's not a matter of stack vs. heap.  There aren't only two places where a pointer can point.  You could have a pointer to a memory-mapped file, to a shared memory segment, to a static variable in .data or .rodata, to a function in .text, or a pointer to a function in a shared library, which depending on your operating system might actually point to a slot in the PLT or an import descriptor in the import table, or an analogous structure.  And so on."
C_Programming,35sjq3,Rhomboid,3,Wed May 13 05:21:12 2015 UTC,"In the C language, all pointers to data types behave equally, independently of where they point to. The C language allows for the following things to be possible though:   pointers to different data types may have different sizes and may not be convertible into one-another without loss of information pointers to functions might be incompatible to pointers to data   In other language environments or platforms this can be different. For instance, in programs for the 8086 (e.g. DOS programs), the stack could be in a different segment than data. In some programming languages, you needed to specify what segment a pointer points to so the compiler can generate correct assembly."
C_Programming,35sjq3,FUZxxl,2,Wed May 13 08:29:42 2015 UTC,Nope. A pointer is a pointer. The same pointer can refer to stack vs heap at different points in it's lifetime:  int *heap = (int *)malloc(sizeof(int)); int stack;  int *pointer; pointer = heap; *pointer = ...; pointer = &stack; *pointer = ...;
C_Programming,35sjq3,moocat,2,Wed May 13 03:52:26 2015 UTC,"There's one small difference, as others have pointed out without making it clear:  int * myfunc() {     int x;     x = 25;     return &x; }   This function will not do what you want it to do, because 'x' exists on the stack and a pointer to it should not be returned ( because it goes away when the function returns). If you wish to return it, you should either malloc() space for it, or make it static:  int *myfunc( void ) {      static int x = 25;      return &x;      /* x is no longer on the stack because it is static */  }   In this case, every time you call myfunc() you will get the same pointer. Also, the value in x will persist between calls to myfunc(), and x will no longer be on the stack.  There are also functions for allocating memory on the stack that you should never use unless you're trying to be evil. alloca() is one of them. Do not use it...... use malloc() and free() instead."
C_Programming,35sjq3,jdonniver,2,Wed May 13 15:09:54 2015 UTC,"They're both just numbers, but of course they are not used in exactly the same way.  A stack variable will be accessed by an assembly instruction like this:   mov EAX, DWORD PTR [EBP-4] (EBP-4 is the stack pointer)   The heap pointer needs to be stored somewhere. If it's only used for a short while the pointer could be held in a register (like eax). So accessing data from the heap might look like this:   mov EBX, DWORD PTR [EAX] (EAX is the heap pointer returned from malloc)   So far the stack and heap pointers are basically the same. The difference arises when the heap pointer needs to stick around for a while. The compiler might want to use the registers for other things, so it will put the heap pointer on the stack. So to get the heap data you would first need to get the heap pointer from the stack. That's probably what you read.   mov EAX, DWORD PTR [EBP-4] (get the heap pointer from the stack and move it into EAX)  mov EBX, DWORD PTR [EAX] (get data from the heap using the EAX heap pointer and move it into EBX)"
C_Programming,35sjq3,Websly,1 point,Wed May 13 20:34:57 2015 UTC,"A pointer is a number. One single number that can be set to anything you want it to be, just like an int. There's no extra pieces of information connected to it. Nothing at all that tells you what part of memory that number would point to or what you're allowed to do with that particular location in memory, or if that memory even exists.  You might live at 2001 Hal Street. That address directly identifies your house and I could send things to you by using it. I might try to send something to your neighbour by sending a package to 2002 Hal Street. That might exist, or it might not. There's absolutely no way to know from just looking at the number 2002. A pointer is an abstract number and nothing more. It knows not what that address represents or if it even represents anything at all."
C_Programming,35sjq3,sireel,1 point,Wed May 13 04:08:42 2015 UTC,"As other replies have said: no, there isn't.  As other replies haven't said: there is a small one. Once you leave the stack frame that a pointer is pointing at, that memory could change without warning at any point. If you're pointing at heap memory, if the contents of that memory changed, it was done on purpose (either by your code, or code you called)."
C_Programming,35sjq3,OldWolf2,1 point,Wed May 13 08:40:57 2015 UTC,"By the way, it's good to avoid redundant casts as they clutter up your code and can cause error messages to be surpressed:  int * x = malloc( sizeof(int) );   or to remove the possibility of a type mismatch:  int * x = malloc( sizeof *x );"
C_Programming,35rhdg,SlayterDev,4,Tue May 12 22:16:02 2015 UTC,"The readme has a lot of info on the instruction set but if you look at the wiki you'll see the full documented instruction set. I wrote a ""compiler"" in python so that you can write the code then make ""executable"" programs I'm calling chip files.  Any ideas on features or instructions I should add? I'd like to build this into something really cool."
C_Programming,35rhdg,dongas420,2,Tue May 12 22:18:07 2015 UTC,"There's an absolute ton of stuff that you could do. You could start by allocating your own memory pool so that you can load values to and from memory addresses, or you could limit the clock speed so that it really behaves like its own machine. You could add call and return operations that push or pop the program position onto the stack, which will let you add functions proper. You could upgrade your compiler so that you can integrate data directly into your program file, as other assemblers can.  You could also try simulating hardware interrupts so that your machine isn't running at 100% all the time, implementing some virtual memory-mapped I/O registers to get keyboard input and such, or using ncurses and creating a section of video RAM that you can write to in order to put stuff onto the terminal.  You should try looking at the specs and documentation for an old home computer or video game console to get a sense of what you can really do."
C_Programming,35rhdg,fredmorcos,1 point,Wed May 13 07:01:32 2015 UTC,I think you're misunderstanding the meaning of this? I haven't taken a look at it yet but I think it's a VM in the JVM sense rather than in the Dosbox or Qemu sense.
C_Programming,35rhdg,dongas420,2,Wed May 13 10:55:56 2015 UTC,"If that's the case... cutting out the lower-level hardware stuff, it's still good to be able to implement and manipulate a comprehensive instruction set, work with a memory pool, and extend the feature set of the compiler.  Older hardware is very limited and requires you to implement stuff like multiplication, division, and modulo from scratch, though, so maybe looking into something more modern like ARM assembly would be a better idea if the goal is just to create something like the JVM instead of messing with low-level stuff."
C_Programming,35rhdg,zenkibudo,2,Wed May 13 12:25:14 2015 UTC,All fantastic ideas! I'm modeling some of the instruction set off my experience with MIPS and ARM assembly sets. So I implemented a link register to hold the program position after a jump so you can write functions. I'll be looking into writing a memory pool soon and declaring memory chunks in the source code. Thanks for the ideas!
C_Programming,35rhdg,_COMPLEX_H,3,Wed May 13 14:54:53 2015 UTC,"Thanks for sharing this, intrigued as hell.  Can only afford this brief comment rt now.  Saving link.... thanks again."
C_Programming,35rhdg,tmtwd,1 point,Tue May 12 23:45:40 2015 UTC,"Thanks for commenting, neato mosquito. Can't stay long, just replying for posterity."
C_Programming,35rhdg,spurious_interrupt,3,Wed May 13 02:22:01 2015 UTC,Very cool
C_Programming,35t631,MartenBE,6,Wed May 13 08:19:54 2015 UTC,"First, you don't have to and probably shouldn't cast the result of malloc().  Also -- personally -- I'd avoid using typedef here.  I'm not sure if it buys you anything.  As to the question: Personally I'd probably pass the value size to CreateContainer() instead of making the function a black box:  struct container * CreateContainer(size_t value_size) {   struct container *rc = malloc(sizeof (struct container));   assert(rc != NULL);    rc->value = malloc(value_size);   assert(rc->value != NULL);    return rc; }"
C_Programming,35t631,ruertar,3,Wed May 13 11:10:52 2015 UTC,"The first function just won't work. For one thing, you never initialize the Value pointer in the returned structure to point anywhere. Also, you're allocating the wrong amount of space. Your Container structure needs space for an int and a pointer-to-char, but you are allocating space for an int and (n + 1) chars.  The second function is fine, but you should check the return call of malloc, and don't forget to write a corresponding function to free the memory you've allocated."
C_Programming,35t631,zifyoip,2,Wed May 13 10:11:44 2015 UTC,The second method is correct. The first assumes that there is no padding between the two members in order to ensure each has the proper memory alignment for the target architecture. Since whether or what padding exists differs between processor architectures the first is at best unportable.
C_Programming,35t631,Meefims,1 point,Wed May 13 09:23:08 2015 UTC,Could you clarify what you mean with padding?
C_Programming,35t631,Rhomboid,6,Wed May 13 10:03:11 2015 UTC,"The compiler is allowed to insert padding between struct members, as well as at the end of the struct, in order to affect the alignment of the individual fields, as well as the alignment of the struct overall.  The size of a struct is therefore not necessarily the sum of the sizes of each of its fields.  But that's really a very minor reason as to why the first one is broken.  It's broken because it tries to allocate a single block of memory, i.e. there's only one call to malloc().  But the struct that you've written contains a pointer to some other memory region, which means there needs to be two allocations, one for the struct and one for the thing pointed to by the pointer that's inside the struct.  It looks like you were trying to go for a technique called flexible array members.  This is a technique where you define a struct that will sit at the beginning of a larger allocation.  It's usually achieved by having the last member of the struct be an array of 1 char (not a pointer), with the idea being that this array will extend out past the bounds of the struct into the memory that comes directly after the struct, and that whatever allocated the struct has arranged for there to be valid memory there, for example by allocating more than the size of the struct.  In C99 I believe you can also signal this with an array of unspecified size, which is usually forbidden in a struct, but when used as the last member signals your intent to use the array as a flexible array member in this fashion.  But again, this is a technique for allocating a single contiguous span of memory, which means there is no pointer in the struct.  A pointer means that you're pointing elsewhere, to some other allocation.  (It would technically be possible to use a pointer that points to the next byte after the struct, in conjunction with an allocation scheme that allocates extra space after the struct, but that would be rather pointless as that pointer would be completely redundant.  If you can access the pointer, then you already have the address of the struct, which means you have the address of what comes after it, which means you didn't need the pointer.)"
C_Programming,35sxs4,tmtwd,3,Wed May 13 06:18:35 2015 UTC,"It is easy, you already wrote it right there. t=12 after this not 12.854 blah blah..."
C_Programming,35sxs4,thoferon,10,Wed May 13 06:37:46 2015 UTC,"It's probably worth mentioning that the result of integer division isn't a rounded number, it's a truncated number. If you want 12.8 to round to 13 you need to use a function that's specifically for rounding."
C_Programming,35sxs4,Rhomboid,1 point,Wed May 13 06:42:45 2015 UTC,"As said by the other answers:  int x = 3 int y = 2 int z = x / y;  /* z = 1 */   To go further, you should also read about undefined behaviours. For instance, you should check if y is equal to 0 or, less obviously, if x is equal to INT_MIN and y to -1. To explain the last one, for 8-bit integers, INT_MIN would be -128 and x/y would be 128 which leads to an integer overflow."
C_Programming,35sxs4,Spudd86,1 point,Wed May 13 08:05:22 2015 UTC,"I want the rounded integer.   That's exactly what your example gives you, only the rounding mode used is round-towards-zero, which is also commonly known as truncation.  Is that the rounding mode that you wanted, or did you want a different mode, such as round-to-nearest?  (Note that there are at least a dozen different rounding modes.)  If that's what you want, then you need to do the division as floating point division, then perform the rounding explicitly, e.g.  #include <math.h>  int result = round((double)4139 / 322);   // result equals 13   The round() function implements round-to-nearest.  If you were only going to display the number, you could also just use printf() to do the rounding:  #include <stdio.h>  printf(""%.0f\n"", (double)4139 / 322);     // prints 13"
C_Programming,35qwzm,Trepunktnoll,47,Tue May 12 19:46:41 2015 UTC,char *basic1;  int *basic2;  long *basic3;
C_Programming,35qwzm,Enlightenment777,8,Tue May 12 20:23:15 2015 UTC,https://xkcd.com/138/
C_Programming,35qwzm,alecbenzer,1 point,Wed May 13 00:35:41 2015 UTC,"Image  Title: Pointers  Title-text: Every computer, at the unreachable memory address 0x-1, stores a secret.  I found it, and it is that all humans ar-- SEGMENTATION FAULT.  Comic Explanation  Stats: This comic has been referenced 63 times, representing 0.0995% of referenced xkcds.    xkcd.com | xkcd sub | Problems/Bugs? | Statistics | Stop Replying | Delete"
C_Programming,35qwzm,xkcd_transcriber,3,Wed May 13 00:35:53 2015 UTC,Those should be void pointers I would think since he was not specific?
C_Programming,35qwzm,wsppan,13,Wed May 13 17:09:05 2015 UTC,"I see what you did there with the 'pointers' in the title ;) And for C Programming I usually use an IDE called CodeBlocks, which (if you choose the correct DL file) downloads gcc along with it, so it works splendidly!"
C_Programming,35qwzm,son_of_a_lich,13,Tue May 12 20:02:34 2015 UTC,"Relevant Xkcd  Jokes aside, for C I would personally recommend skipping the IDE if possible - You just learn so much more about the actual compilation process that is extremely helpful to know.  That said, you can do C programming without a Linux distro installed, though IMO a Linux distro would be the preferred environment. You still have a range of options without one.  First, Windows does have a C compiler, lc I believe. If you install Visual Studio I think it comes with it (Forgive me, I don't know all the details on it). If your going to be using gcc in the class though, you're probably better off learning with gcc.  Another option is trying to avoid Windows completely and using cygwin, which you can install in Windows, and comes with it's own terminal emulator and gcc copy, and relevant headers. cygwin is much like having a Linux distro installed inside of Windows, which is nice for some things, but annoying in that it feels more separated from the rest of the OS.  The other big option is MinGW, which is just a port of gcc for Windows. I presume if you install MinGW, compilation from eclipse would work, as long as you give it the right paths to MinGW. In general I've had pretty good luck with MinGW.  Have you considered a virtual machine with Ubuntu or Linux Mint or etc. on it? That might be a good option. Installing those on virtual machines is extremely simple (Since you don't have to worry about overwriting anything), and I'm sure there are tons of guides for getting a development environment setup in them."
C_Programming,35qwzm,DSMan195276,5,Tue May 12 20:42:01 2015 UTC,Another advantage of using a virtual machine for learning C is that you can play around with all sorts of dangerous stuff without messing up your own system.
C_Programming,35qwzm,batorius,3,Tue May 12 21:16:57 2015 UTC,"^ This.  I only use VMs for college stuff and other experiments, since it's not uncommon to install a bunch of stuff you're only going to use for, like, a week (sometimes a few hours).  Edit: I normally install Lubuntu, since it has all Ubuntu has to offer, minus the heavy GUI and other programs you never gonna use."
C_Programming,35qwzm,24monkeys,1 point,Wed May 13 04:31:05 2015 UTC,"I kind of agree, but what exactly does writing from the command line give you?  An ide will give the same errors as from the command line and will structure code better and have some useful features.  Of course, I still use a text editor (and have been for c for the past year), but if I could go back in time I probably would have started with code blocks or something"
C_Programming,35qwzm,tmtwd,1 point,Wed May 13 10:03:19 2015 UTC,"Writing the code from the command-line doesn't really matter - Text editors like vim and emacs can structure code for you anyway, and they're command-line based.  The point more avoiding letting the IDE perform tasks such as compiling your project, or even less then that, letting your IDE do everything to the point that you have no idea how the files are being compiled.  Specifically if he's going to be doing embedded, he's going to be working with the compiler a lot - Either throwing it some more complex switches, or having a fairly complex compilation process for his programs. If you avoid letting the IDE create your project for you from the get-go and write your own Makefile's to compile your project, you'll have tons more knowledge of how the compiler, linker, etc. all work together - And when you get to embedded and realize you probably don't have a choice but to write your own Makefile's (Or using some other build system that he's configuring by hand), you'll be much better off of you've already done something similar before."
C_Programming,35qwzm,DSMan195276,5,Wed May 13 13:51:24 2015 UTC,"As mentioned, CodeBlocks, under correct settings will downloads gcc for you. Though if you plan on programming in C for a while, it might be better to get a Linux OS.  You might also want to try programming without an IDE - just using a simple text editor such as Gedit, Notepad++, etc. and the terminal. I feel that this will help you get a better idea of what goes on in building projects, with regards to library inclusion, build scripts, etc."
C_Programming,35qwzm,Dihydrogen_Oxide,3,Tue May 12 20:38:36 2015 UTC,"It's really not even necessary to use Linux, but it would probably be best. I'm currently using Windows and vim in Powershell and compiling with tcc, although I do have gcc installed.  If OP would rather stick with a graphical text editor and compile from within it, there is NppExec for Notepad++ and it's fairly easy to set up."
C_Programming,35qwzm,sgthoppy,2,Tue May 12 20:43:30 2015 UTC,"On Windows I use Pelles C IDE. It is tiny, free, simple, yet feature packed. IMO it is the best C compiler for Windows, 2nd best debugger, and 2nd best assembler. It also has many examples & tutorials to get your started in C programming (console & Windows)."
C_Programming,35qwzm,angdev,2,Wed May 13 00:42:15 2015 UTC,"void *get_basic_pointer(size_t s) {    .     void *basic_pointer = malloc(s);       if (basic_pointer == NULL) {           fprintf(stderr, ""UNABLE TO ALLOCATE MEMORY FOR %zu SIZE POINTER\n"", s);           exit(EXIT_FAILURE);       }       return basic_pointer;   }"
C_Programming,35qwzm,wsppan,2,Wed May 13 18:59:58 2015 UTC,"I don't know who's joke was worse, your's or /u/fuzzymcchimp 's >>"
C_Programming,35qwzm,TehJohnny,2,Thu May 14 06:51:23 2015 UTC,Definitely mine. Fuzzymchimps was acually pretty funny.
C_Programming,35qwzm,wsppan,1 point,Thu May 14 14:47:07 2015 UTC,Naw man; I got a very hearty lol out of yours.  Also /u/TehJohnny: this post was just asking for it :D
C_Programming,35qwzm,fuzzymcchimp,1 point,Fri May 15 00:07:46 2015 UTC,"I like CodeBlocks (installs mingw). Cygwin will have a more linux-y feel. Or there's a Visual C++ community edition (previously express edition).  Or you could install mingw on its own. Or the Visual C++ compiler might come standalone with the Windows SDK (no experience here). The Eclipse CDT claims to work with all of the above (cygwin, mingw, or VC++), but I haven't used it myself."
C_Programming,35qwzm,dtfinch,1 point,Tue May 12 23:30:40 2015 UTC,Asking for basic pointer you should read up on pointer basics
C_Programming,35qwzm,kubatyszko,1 point,Wed May 13 02:38:09 2015 UTC,BASIC doesn't support pointers.
C_Programming,35rj3s,Clauc,2,Tue May 12 22:29:35 2015 UTC,"Why are you taking in the numbers as characters and then converting them to integers, instead of just taking them as integers?"
C_Programming,35rj3s,Dihydrogen_Oxide,1 point,Tue May 12 22:37:14 2015 UTC,"First off, there's much better ways of writing your utbrytning function.  If nothing else, use strtok instead of tokenizing yourself.  Or use something from the scanf family of functions.  But that's not the problem.  The real problem here is that your loops stop at 99 ... but what if the user only puts in 5 items?  The rest of the array holds garbage values, and your code will include those when calculating the one with the highest frequency!  After that, your print statement uses occurance and number backwards."
C_Programming,35pxbh,giaggion,5,Tue May 12 15:25:45 2015 UTC,There's no array in that...
C_Programming,35pxbh,raevnos,1 point,Tue May 12 15:30:42 2015 UTC,"Thats funny, I'm new in ""c"" so i'm sorry , basically I have to use an array of random numbers and see how many zeros are in it, I will try to fix this now and then ask again thanks"
C_Programming,35pxbh,FancyJesse,2,Tue May 12 15:36:19 2015 UTC,"Always keep the question in mind when trying to complete an assignment. And since you're new to it, a bit of pseudo code might help."
C_Programming,35pxbh,FancyJesse,1 point,Tue May 12 15:38:54 2015 UTC,"Ok , I'll keep it in mind, thanks"
C_Programming,35pxbh,Dihydrogen_Oxide,1 point,Tue May 12 15:41:29 2015 UTC,Good luck!
C_Programming,35pxbh,Dihydrogen_Oxide,3,Tue May 12 15:47:08 2015 UTC,"So you have a good start right now.   Since you've already defined MAX, you might as well use it:  for( i = 0; i < MAX; i++ ) {    As for counting how many 0's are generated in 100 randomly generated numbers, you don't need an array. You can just increment a counter each time   rand()%10+1 == 0   If the assignment requires you to store the random numbers in an array, you first have to define the array where you'll store these numbers.  <datatype, probably int or double> <array name>[ numbers of array entries, probably use MAX here as well]  eg.  double storage[50];   Then for each random number generated, you would want to store each of them in a separate array entry."
C_Programming,35pxbh,bodangly,1 point,Tue May 12 15:50:36 2015 UTC,"First of all I really appreaciate the time you spent to answer me, and yes, I have to use array, it's not my decision, so after I define my array what do you mean for ""store each of them in a separate array""? I mean,my thought was to create this array of random numbers, read the numbers to find the zero's and then print how many ""0"" the program found"
C_Programming,35pxbh,Dihydrogen_Oxide,2,Tue May 12 16:13:53 2015 UTC,"You're correct that you have to use a for loop to generate your random numbers. Now you have to store these random numbers you're generating into the array.  Lets say I defined an array of integer int arr[10]. To store the number 7 in the first entry of the array, its arr[0] = 7. Now if I want to store the number 4 into the third entry of the array, I use arr[2] = 4.  And yes, you have the right idea that you store the random numbers in an array, count the numbers of zeros, then print out how much there are. For counting the numbers of zeros, you can either count them after you've generated your random number array, or you can do it while you're generating the random number array."
C_Programming,35pxbh,Dihydrogen_Oxide,1 point,Tue May 12 16:32:36 2015 UTC,"Just a note, you say arr[3] for the third entry, but its arr[2]. Obviously you know this since you 0 index the first time, but it may confuse OP."
C_Programming,35pxbh,Choo5ool,1 point,Tue May 12 17:42:41 2015 UTC,"Yes, good find. I'll change that now, thanks."
C_Programming,35pxbh,Dihydrogen_Oxide,1 point,Tue May 12 17:54:27 2015 UTC,"You helped me so much , i'm still working but I think now I can make it,thank you!"
C_Programming,35pxbh,Dihydrogen_Oxide,1 point,Tue May 12 18:21:38 2015 UTC,"Sounds good, let me know if you run into anything else"
C_Programming,35mfet,tmtwd,17,Mon May 11 18:28:23 2015 UTC,"You have the right idea. The syntax for referencing the 'x' field would be:  *(*f).x = 320;   Or, equivalently (and what most C programmers would write):  *f->x = 320;"
C_Programming,35mfet,OlderThanGif,2,Mon May 11 18:37:47 2015 UTC,cool! I got it to work
C_Programming,35mfet,ZaberTooth,-7,Mon May 11 18:52:31 2015 UTC,"This will work fine, but I'd even prefer the more verbose  (*f)->x = 320;   Just because I can never remember the order of operations."
C_Programming,35mfet,GBGamer117,15,Mon May 11 21:36:16 2015 UTC,"That's not what that does, that would only work if f was a struct **, and x was a normal int.  What you mean is *(f->x) = 320."
C_Programming,35mfet,ZaberTooth,7,Mon May 11 21:43:07 2015 UTC,"Yep, you're totally right. This is precisely why I favor the use of parentheses, because sometimes the order of operations is not always immediately obvious.  Edit: the classic example that comes to mind is this:  *++p;   versus  *p++;"
C_Programming,35mfet,zifyoip,0,Mon May 11 23:44:57 2015 UTC,"because sometimes the order of operations is not always immediately obvious.   Though there's absolutely no ambiguity in what you wrote. There's only one possible way to interpret (*f)->x, even if you don't know the operator precedence."
C_Programming,35mfet,sftrabbit,4,Tue May 12 10:33:24 2015 UTC,"They are saying the ambiguity is *f->x, and they mistakenly thought it was equivalent to (*f)->x, which only serves to back up the point."
C_Programming,35mfet,none_shall_pass,3,Tue May 12 10:53:06 2015 UTC,"Can I malloc both a struct and an element inside a struct?    You can malloc anything you like. It's just bytes.  Malloc actually has no clue about anything in the universe except giving you a pointer to the number of bytes you want, or failing."
C_Programming,35mfet,gryftir,0,Tue May 12 14:30:25 2015 UTC,"You can also allocate both at the same time:    You don't need the separate pointer, for for clarity.  void * alloc = malloc(sizeof(struct Foo) + sizeof (int)); struct Foo * f = (*f)alloc; f->x = (int)(alloc + sizeof(struct Foo));"
C_Programming,35mfet,HiramAbiff,8,Mon May 11 22:05:51 2015 UTC,Isn't there the potential for alignment problems with this approach?  Other nits: pointer arithmetic on void*'s isn't allowed and the cast to int pointer is missing the *.
C_Programming,35mfet,Poddster,1 point,Mon May 11 23:53:28 2015 UTC,"Isn't there the potential for alignment problems with this approach?   Yep. There's no real portable way in C to get the alignment of something (That I know of).  You can just assume it's in quantities of sizeof(ptr) or sizeof(void) or sizeof(uintptr_t) or 128bits or something, but there's no guarantee. It's system dependent and not exposed by C."
C_Programming,35mfet,bames53,2,Tue May 12 15:21:46 2015 UTC,"To get the alignment requirements for an object you use _Alignof. This is standard C, and it was added in C11."
C_Programming,35mfet,dumsubfilter,1 point,Thu May 14 21:48:27 2015 UTC,"The only time you want to malloc sizeof struct + space is when you've got an incomplete array as the last member of the structure, as a ""flexible array member"":  struct foo {     size_t asize;     int array[]; } *ptr;  ptr = malloc( (sizeof *ptr) + N * sizeof( int ) );"
C_Programming,35mb78,tmtwd,7,Mon May 11 17:56:58 2015 UTC,"First you need some storage for the actual data:  f.x = malloc(sizeof(int));   Then if malloc succeeded, you can assign to it:  if (f.x != NULL) {     *(f.x) = 320; }"
C_Programming,35mb78,moocat,2,Mon May 11 18:04:35 2015 UTC,"how come it is legal to do:    f.y = ""hello"";   without a malloc?"
C_Programming,35mb78,boredcircuits,4,Mon May 11 18:13:12 2015 UTC,"Actually, that's illegal.  Your compiler should at least give you a warning.  y needs to be const char* to be legal.  But, let's say your structure had const char *y ... how does this work?  ""hello"" is a convenient shorthand to represent an array of characters: {'h', 'e', 'l', 'l', 'o', '\0' }.  This array lives in some read-only location in memory (which is why const is needed).  f.y = ""hello""; assigns y to point to this location in memory.  So, you don't need to malloc because the data already has a memory location to live in."
C_Programming,35mb78,OlderThanGif,1 point,Mon May 11 18:38:05 2015 UTC,"Did this change in C11? I remember in C99, string literals were char *, not char const *, in spite of being read-only."
C_Programming,35mb78,boredcircuits,2,Mon May 11 18:43:53 2015 UTC,"Nothing changed in C11.  String literals are of type char[] and it's technically legal to assign to a char *, just illegal to make any modifications.  That's why I said the compiler should issue a warning, and you should only ever assign to a const char * in practice."
C_Programming,35mb78,boredcircuits,1 point,Mon May 11 18:55:07 2015 UTC,"struct Foo{   int x[32]; };  struct Foo f; f.x = {32, 23 32 ,32};   then why is this illegal?"
C_Programming,35mb78,OlderThanGif,4,Mon May 11 19:07:13 2015 UTC,"A couple things to talk about here.  First, you can't assign arrays, only initialize them.  So, the following is valid code:  struct Foo f = { {32, 23, 32, 32} };   To be equivalent to your char* example, the structure would have been:  struct Foo {     int *x; };   But you still get an error on assigning.  Why is that illegal?  It's worth pointing out that while ""hello"" is shorthand for an array, f.y = { 'h', 'e', 'l', 'l', 'o', '\0' }; is still illegal.  The string notation does some ""magic"" behind the scenes that array notation doesn't do.  Honestly, I don't exactly know why this is illegal.  I don't think there's any technical reason it could be allowed, but the language doesn't support that notation.  Edit:  I forgot that C99 allows for compound literals, that makes the syntax legal, you just need to add a cast:  f.x = (int[]){32, 23, 32, 32};"
C_Programming,35mb78,jdonniver,1 point,Mon May 11 19:22:42 2015 UTC,thanks
C_Programming,35mb78,Dihydrogen_Oxide,2,Mon May 11 19:54:20 2015 UTC,"You can't assign to an array. (You can initialize an array, and you can assign to specific elements in an array, but you can't assign to an array per se).  If the x in your case were a pointer instead of an array, you could do something like:  struct Foo {   int const *x; };  struct Foo f; f.x = (int []){ 32, 23, 23, 32 };   Which is sort of analogous to assigning to a char * with a string literal."
C_Programming,35mb78,grable,1 point,Mon May 11 19:25:33 2015 UTC,thanks
C_Programming,35mb78,grable,1 point,Mon May 11 19:54:29 2015 UTC,"Because ""hello"" in this case is a pointer to an array of characters and has an address."
C_Programming,35kmir,DemandAmbition,7,Mon May 11 07:04:42 2015 UTC,At what position are you writing after a call to rearrange()? and at what position should you be?
C_Programming,35kmir,Erno3000,1 point,Mon May 11 08:37:42 2015 UTC,"Hey, thanks for the reply, I'm trying to rearrange any unwritten characters to the start of the array and then start writing after that until the array is full again,"
C_Programming,35kmir,Erno3000,2,Mon May 11 08:43:40 2015 UTC,"Haha Tnx for the answer, but it was actually a hint for you. Determine for yourself what the value of position and pos should be when rearrange() returns. At what position in line[] are you writing after you wrap around?"
C_Programming,35kmir,Erno3000,2,Mon May 11 08:53:01 2015 UTC,"Hey, thanks very much for your suggestions, I've got my code working now, it took a little bit of frustration trying to picture where everything was in the string, and printing my variables out with each step to figure it out but now I understand it better!"
C_Programming,35kmir,Wiggledan,1 point,Sun May 17 15:35:45 2015 UTC,"No problem, glad it's working now. I guess frustration will always be part of learning C ;)  Out of curiosity, what tools (editor/ide etc.) do you use? Because this is a textbook problem where debuggers come in very handy."
C_Programming,35kmir,PriceZombie,1 point,Sun May 17 16:06:17 2015 UTC,"I was using code::blocks at home, but coming too-from work I just ended up using that website to be honest!"
C_Programming,35kmir,zenkibudo,1 point,Sun May 17 16:46:09 2015 UTC,"Haha, thanks, I'll look at that and try and get it working myself! A much better way of learning!"
C_Programming,35kmir,kojiba,2,Mon May 11 11:36:44 2015 UTC,"Good luck on your C adventures! I started learning C about half a year ago, and I tried starting with K&R, but it was way over my head and I got stuck around chapter 2.  Imo, the K&R book, while classic and still a totally valid way to learn C, is becoming more and more outdated. The original version came out in '78 and the 2nd edition in '88. It was the C standard before there even was one, meaning it doesn't necessarily conform to C89/99/11. Also, it's not written very well for beginners, because it's so concise and more of an overview of all the primary features of the language.  So.. it's still totally valid to learn from, as tons of people have, but if you find yourself banging your head on a wall with K&R, check out C Programming: A Modern Approach. I'm about 80% through it, and it covers everything very well and thoroughly. Each chapter introduces new concepts, with explanations, examples, exercises, and programming projects pertaining to those concepts. If you take your time on each chapter and do (mostly) all the exercises/projects, you'll be surprised at how simple things become over time.  I've also been doing /r/dailyprogrammer challenges every week. I'm only good enough to do the easy challenges, but they also help a ton with learning (and can be fun). The best way to get better at coding, is simply to code more things more often and challenge yourself constantly.  ...Sorry for the wall of text, I mostly wanted to show you the ""bigger and better"" version of K&R that was recommended to me. I very highly recommend it."
C_Programming,35kmir,Erno3000,2,Mon May 11 16:07:28 2015 UTC,"C Programming: A Modern Approach, 2nd Edition   Current $111.45     High $133.88      Low  $71.48    Price History Chart and Sales Rank | GIF | FAQ"
C_Programming,35lc6u,Ceffa93,2,Mon May 11 13:11:24 2015 UTC,Look up algorithms for computing greatest common divisor. It'll probably be on Wikipedia.
C_Programming,35lc6u,raevnos,2,Mon May 11 15:12:47 2015 UTC,"I got 22:  int gcd(int a, int b){return b?gcd(b,a%b):a;}   it would be nice to get rid of that return keyword..."
C_Programming,35lc6u,iwasanewt,2,Mon May 11 15:23:55 2015 UTC,"Getting rid of the return is undefined behaviour, but it's the correct answer for the website. You and I came to exactly the same solution other than that."
C_Programming,35lc6u,lishyguy,2,Mon May 11 15:30:58 2015 UTC,"It would be disappointing if relying on undefined behaviour is the 'correct' solution.  Ok, this is bullshit."
C_Programming,35lc6u,iwasanewt,2,Mon May 11 15:40:08 2015 UTC,"I think you're omitting the wrong word:  g(int a, int b){return b?g(b,a%b):a;}   Without it being specified, the return type of a function defaults to an integer, IIRC.  Coupled with shortening the function name, that should do it."
C_Programming,35lc6u,dumsubfilter,2,Mon May 11 16:26:25 2015 UTC,"Your solution is good (and actually sane), but the website doesn't allow you to change the function signature."
C_Programming,35lc6u,iwasanewt,2,Mon May 11 16:36:03 2015 UTC,"It's a poorly written problem overall, because it relies on undefined behaviour - the solution omits the word return because it's too many letters.  There's a recursive solution for the gcd, and given we're after brevity, recursive is the way forwards.  My solution is: b?gcd(b,a%b):a;, let me break that down:   ?: is the ternary conditional operator, and it's like an if/else statement.  The bit before the ? is the test, the bit between the ? and the : is the if (true) bit, and the bit after the : is the false bit. b is the conditional test, which is the same as the test if (b != 0) gcd (b, a%b) finds the gcd of b and the remainder of a / b, which is part of the recursive solution Otherwise, the function returns a and ends."
C_Programming,35lc6u,lishyguy,1 point,Mon May 11 15:29:17 2015 UTC,"Uhm i'm quite disappointed with this challenge too, thnks for the answer though, works perfecly"
C_Programming,35lc6u,_5__,1 point,Mon May 11 20:05:18 2015 UTC,"not sure how to do it in less than 15 chars, but I got   int i;for(i=a>b?a:b;a%i+b%i!=0;i--);return i;   which is 45 chars. See if you can shrink that?"
C_Programming,35it75,MEO92,5,Sun May 10 20:06:44 2015 UTC,"If you are doing embedded stuff, get yourself a development board with a popular controller on it. They are dirt cheap and you have plenty of resources online. Learning C with a good book is a good start, but it won't help you when you have to fiddle around with a dozen registers to get your serial port running."
C_Programming,35it75,solanoid_,1 point,Sun May 10 21:18:27 2015 UTC,"Currently have Raspberry Pi 2 which I use Python for, but I want to program in C on it. I also have a few mBed platforms which I use the C++ IDE on the mBed website for.  I am looking into purchasing a low-level uC to do learning with."
C_Programming,35it75,snops,5,Sun May 10 21:22:53 2015 UTC,"Currently have Raspberry Pi 2 which I use Python for, but I want to program in C on it.   The raspberry pi isn't great to learn embedded programming, as you are either going through Linux, or dealing with quite complicated bare metal setup.   I also have a few mBed platforms which I use the C++ IDE on the mBed website for.   Why not just use some of your mBed platforms? If they are not the ""official"" mBed, then you can probably program them with a separate IDE, for instance you can program Freescale's boards with Kinetis Design Studio.  The skills I suggest you focus on are Interrupts, raw peripheral access (no MBED Libraries), linkers, choosing ROM/RAM targets, boot, and power saving (sleep modes etc).   An excellent book I recommend to cover all of these topics is Making Embedded Systems. If you already know C, or are learning it elsewhere, its an excellent introduction and I certainly wish I had found it when starting out. In another thread you said:   I am really looking for a textbook that will take me from a basic knowledge of C programming and embedded systems to having a decent understanding of writing and understanding embedded software.   I believe this really is the book."
C_Programming,35it75,snops,3,Sun May 10 22:00:55 2015 UTC,This is exactly what I am looking for.  I have a Freescale KL-25Z so I think I will take your advice and download KTS and give it a shot.  I will definitely look into that book. Could you recommend a book for learning C to complement it?  Thank you so much for your advice.
C_Programming,35it75,pinealservo,5,Sun May 10 22:10:34 2015 UTC,"K&R is still pretty good tbh. The only other C books I have are C Pocket Reference, which doesn't really have anything extra, just a different format, and Deep C Secrets, which is very interesting, but probably overkill.   In embedded programming, you don't really need that deep a knowledge of the C standard library, as you won't be using much of it, and some parts (e.g. filesystem's, locale, malloc) don't make much sense for embedded targets.  Getting pointers solid looks like a good next step for you, and K&R certainly contains enough information for you to learn that. Being comfortable with the concept of ""an address in memory"" is key to embedded programming, and pointers are a very powerful construct for that, which IMO explains the popularity of C for embedded."
C_Programming,35it75,solanoid_,1 point,Sun May 10 22:26:05 2015 UTC,"One of the downsides of K&R is that it hasn't been updated since before the C99 standard. Both C99 and C11 (the current version) have introduced features that can be especially helpful in the context of embedded systems programming.  I'm not familiar with any of the introductory books that cover C11, but Harbison and Steele's reference is a great one that covers up through C99. As the title says, it's a reference, but you'll really want to have something like this handy to resolve the various odd questions about the weird corners of C syntax and semantics that come up occasionally."
C_Programming,35it75,FUZxxl,1 point,Mon May 11 01:19:13 2015 UTC,"I have started using AVR microcontrollers. You will find lots of good tutorials online, also all the necessary software is free and on linux you can setup your environment in 10 minutes and start coding.  I haven't used an AVR dev-board in the last few years. The STK500 is from Atmel, has support for many different controllers, but is quite expensive (~$90). There are lots of different models available, but something like this looks good to me. It has a bootloader installed which means you don't need an external programmer."
C_Programming,35it75,Tuna-Fish2,3,Mon May 11 05:05:30 2015 UTC,"What is it that you don't know how to do? K&R is great at teaching you the syntax of C, but you need to have a solid understanding of pointers and imperative programming before."
C_Programming,35it75,flamesflight,2,Mon May 11 10:10:30 2015 UTC,"I have a decent understanding of imperative programming and a rudimentary understanding of pointers. I have studied C academically in terms of Embedded programming (introductory course) and Real Time Computer Systems (intermediate level course, interrupts, registers, stack, assembly etc) as well as programming micro controllers (specifically, mBed platform [C++] and Raspberry Pi [Python].).  I am really looking for a textbook that will take me from a basic knowledge of C programming and embedded systems to having a decent understanding of writing and understanding embedded software."
C_Programming,35it75,synthead,3,Sun May 10 21:02:31 2015 UTC,"IMHO understanding pointers well is like learning math. Beyond the very basic level, just reading more will really not do that much. You need to write code to develop the kind of intuitive understanding that allows you to use them with confidence.  I recommend doing lots of tiny projects that use a lot of pointer fiddling. Implement stuff like:   Linked list Doubly linked list Binary Tree Red-Black Tree Some spatial tree, like an octree Malloc/Free   Also, learn to use valgrind. If you intend to write a lot of low-level stuff in your career, learning it or another similar memory debugger at some point is probably necessary, and learning it now will probably save you a quite a bit of your time by telling you how your data structures are leaking."
C_Programming,35it75,DoingIsLearning,2,Sun May 10 21:20:52 2015 UTC,CS50 on EdX/ youtube/ harvard starts with C language. For a good book try the beta LearnCthehardway.com
C_Programming,35jz6u,thesoundofbutthurt,2,Mon May 11 02:34:05 2015 UTC,"Man, what the hell. As far as I can tell, this generates some kind of lookup table for a 6502 emulator that compresses sequences longer than a byte, into bytes. (Hence ""base 256"".) The clever part is that much of the calculation is done at compile time by using the outcomes of the calculations as enum indexes, which forces the compiler to evaluate the expressions at compile time. (Any modern compiler would have done that regardless.)  The smug cleverness of this thing makes me sick. It could have been written in a clear, sensible way without losing any of the ""optimizations"". This mess tells a really shitty story about what's going on. This kind of code is straight from the 80's, and we've moved on. Compilers work now. Glad I don't have to deal with this kind of stuff any more."
C_Programming,35jz6u,teringlijer,1 point,Mon May 11 19:19:22 2015 UTC,"Case in point, here's the cpu part of Fogleman's NES emulator written in Go. You can get close to that result with C. That code is a joy to read. Zero cleverness, maximum transparency. (And hardly any need for comments.)"
C_Programming,35jfn8,whoiskamryn,7,Sun May 10 23:26:10 2015 UTC,Er. Borland? Why in the world?
C_Programming,35jfn8,raevnos,3,Mon May 11 00:12:18 2015 UTC,"Hard to say, considering Microsoft provides compilers for free now ..."
C_Programming,35jfn8,Fylwind,1 point,Mon May 11 01:13:17 2015 UTC,"Thanks, I'll check that out!"
C_Programming,35jfn8,Chooquaeno,1 point,Mon May 11 16:40:17 2015 UTC,I know it's old! But it works. I learned to program a few years back using notepad and borland... its what I picked back up now that I'm programming for fun again :)
C_Programming,35jfn8,Chooquaeno,4,Mon May 11 16:46:47 2015 UTC,"I have not ever used or investigated Borland C/C++, but given the nature of other C/C++ compilers I suspect the problem is that you have not actually told bcc32 to link against any libraries nor where to look for the include files."
C_Programming,35jfn8,Fylwind,1 point,Sun May 10 23:55:36 2015 UTC,"Ok I found the command line option to link to a library with bcc32. So I basically have to link to the directory winsock2.h is found, for example?"
C_Programming,35ibzq,fenulol,5,Sun May 10 17:38:10 2015 UTC,"For starters, scanf requires exact formatting.  Your example input contains spaces that you are not considering when you scan."
C_Programming,35ibzq,dumsubfilter,2,Sun May 10 18:09:48 2015 UTC,"Does your code compile? If so, what does it do differently than what you expect? If not, what errors do you get?"
C_Programming,35ibzq,raevnos,1 point,Sun May 10 17:54:24 2015 UTC,"Yes, compile.  http://imgur.com/kaE4wk7 this is going on."
C_Programming,35ibzq,raevnos,2,Sun May 10 18:26:46 2015 UTC,Here's a hint: where are the newlines in your output coming from?
C_Programming,35ibzq,raevnos,1 point,Sun May 10 21:24:36 2015 UTC,"That looks like it's working fine, aside from telling it to read 4 rows and only giving 3. What's the issue you're having?"
C_Programming,35ibzq,raevnos,1 point,Sun May 10 18:30:16 2015 UTC,DAMN! I forgot about the '/0' as the last space of the string.
C_Programming,35ibzq,_predator_,1 point,Mon May 11 01:02:54 2015 UTC,"You're dealing with arrays of characters, not strings. No need for the trailing nul unless you want to start printing a line at a time."
C_Programming,35f38g,RockDiesel,3,Sat May 9 19:02:14 2015 UTC,"Haha I hate you now, just spent the last 3 hours I should have been sleeping implementing my own version."
C_Programming,35f38g,hutcho66,2,Sun May 10 17:36:06 2015 UTC,Can't wait to go thru this! I've been looking for an article on this to get my feet wet for a while - thanks for posting!
C_Programming,35f38g,down_my_banana,2,Sun May 10 08:20:06 2015 UTC,Very cool. Would this be related to how emulators are implemented?
C_Programming,35f38g,shoobiedoo,2,Sun May 10 09:22:58 2015 UTC,Yep! You'd implement say an instruction set for a Z80 based off the specification for the cpu and you've got yourself a z80 emulator :)
C_Programming,35f38g,aspl,1 point,Sun May 10 11:29:02 2015 UTC,"I've been wondering if it's possible to simulate lower clock frequency as well. I want to make a VM of sorts based off a quite old architecture and processor, so I was hoping to try and emulate its speed even on new hardware"
C_Programming,35f38g,taylorha,2,Sun May 10 13:24:09 2015 UTC,"Sure, why couldn't you? I would imagine all you would really need to do is put a timer check in the main loop and either spin or sleep the thread until it's time to execute another instruction."
C_Programming,35f38g,BigPoopBreakfast,2,Sun May 10 14:43:22 2015 UTC,"I've thought of that, and there's no apparent reason that it shouldn't be able to work, but I've always thought it wouldn't be as 'accurate' as I'd like. No foundation for that thinking, I just like to overcomplicate things in my head. Guess I should actually get around to doing it and tackle the problems as they come up."
C_Programming,35h5as,tmtwd,3,Sun May 10 08:39:56 2015 UTC,"It's a pretty ugly use of a for loop in general, so I'm not surprised it's confusing.  All that bit does (save = (char *) 0;) is set save to a null pointer. Throughout the iterations of the for loop, if the condition c == ch never passes (that is, we never find the character we're looking for), then the function will just return this null pointer because save will never be updated."
C_Programming,35h5as,sftrabbit,2,Sun May 10 08:48:18 2015 UTC,It means that if the character is not found then a null pointer is returned.  The compilation error in your snippet is due to failure to #include <stdio.h>.  (There are also logic errors as pointed out in /u/danielkza's reply)
C_Programming,35h5as,OldWolf2,3,Sun May 10 10:28:58 2015 UTC,"There are also two other errors. When passing a char* to printf the correct specifier is %s, or if you actually just want to print one character, you have to dereference the pointer yourself (as in printf(""%c"", *save)). But if save is null that's an invalid operation.  The key thing to understand is that the existence of a null pointer is fine, but actually dereferencing it in any way is undefined behaviour and a programming error."
C_Programming,35h5as,danielkza,2,Sun May 10 13:24:00 2015 UTC,"%p, like in the error message, would work fine."
C_Programming,35h5as,rabidcow,1 point,Sun May 10 15:19:32 2015 UTC,"Indeed, because that would only print the address that the pointer corresponds to, without ever dereferencing it."
C_Programming,35h5as,danielkza,2,Sun May 10 22:00:03 2015 UTC,"That is a horrible implementation of strrchr().  For one thing, (char *)0 is an unidiomatic way of writing NULL.  For another, it violates the standard, which says that the null character is considered part of the string, which means if you pass zero for ch, it must return a pointer to the terminating null, whereas the above code treats that as a not found condition and returns NULL.  Here is how I'd write it:  char *strrchr(const char *s, int c) {     const char *ret = NULL;      do {         if(*s == c) {             ret = s;         }     } while(*s++);     return (char *)ret; }"
C_Programming,35h5as,Rhomboid,1 point,Sun May 10 22:07:45 2015 UTC,agreed!
C_Programming,35h5as,Rhomboid,1 point,Sun May 10 22:25:35 2015 UTC,how come you declare ret as const? doesn't that mean you can't write to it?
C_Programming,35g3ja,tmtwd,10,Sun May 10 00:40:19 2015 UTC,"You are trying to assign a value to an address that is not write-able.  char *stack = ""init""; //""init"" is stored in read-only memory.  Try malloc-ing the memory for the stack, and then memcpy'ing ""init"" to it."
C_Programming,35g3ja,akzever,1 point,Sun May 10 00:53:37 2015 UTC,thanks
C_Programming,35g3ja,jmct,4,Sun May 10 00:58:15 2015 UTC,What's K&W?
C_Programming,35g3ja,iwasanewt,2,Sun May 10 14:04:29 2015 UTC,"The C Programming Language (sometimes referred to as K&R, after its authors' initials)  * oh, didn't even see the W in K&W"
C_Programming,35hpu7,andrespm_,7,Sun May 10 14:10:02 2015 UTC,"That is C++, not C. This is /r/C_Programming."
C_Programming,35hpu7,zifyoip,-1,Sun May 10 14:16:07 2015 UTC,It's C
C_Programming,35hpu7,Rhomboid,2,Sun May 10 18:04:32 2015 UTC,"It most certainly is not.  Look at your error message — it mentions operator overloading, namespaces, and templates, all of which are not present in C."
C_Programming,35fhml,tmtwd,3,Sat May 9 21:12:59 2015 UTC,"Change your initialisation of s to this:  char s[23] = ""hello\0is this broken?"";   Then see if you get a different result for my_strcat and strcat."
C_Programming,35fhml,sftrabbit,1 point,Sat May 9 22:33:06 2015 UTC,"ah, I see!"
C_Programming,35fhml,Rhomboid,2,Sat May 9 22:42:05 2015 UTC,"char s[23] = ""hello"";   This initializes s with the five characters h, e, l, l, and o, followed by eighteen nulls.  It's going to be quite forgiving of a strcat that doesn't null-terminate.  You should consider a better testcase, e.g.:  char s[256]; memset(s, 'X', sizeof(s)); strcpy(s, ""hello""); my_strcat(s, "" world""); puts(s);"
C_Programming,35escr,cptwolf,1 point,Sat May 9 17:24:45 2015 UTC,"Why do you use the ## operator? It's not needed here. Just write  #define MAKE_STR(VAR_NAME, STR) const char *VAR_NAME = STR   and use like this:  MAKE_STR(fn_name, ""main""); printf(""%s"", fn_name);   If this doesn't solve your problem, please provide further information. How is this question related to C99?"
C_Programming,35escr,FUZxxl,1 point,Sat May 9 17:46:49 2015 UTC,"That worked. Thanks! Not sure what got in my head with ##.  I had originally intended to include some questions about VA_ARGS in macros, and c89 doesn't' support that."
C_Programming,35escr,FUZxxl,1 point,Sat May 9 22:13:35 2015 UTC,The ## operator is employed when you need to create new tokens. It's almost never needed.
C_Programming,35d7de,cas_999,3,Sat May 9 04:30:08 2015 UTC,"A quick note before talking about the program: Most people uses websites like pastebin for posting code. You actually took the time to format your post, so it's less of an issue, but it'd be worth considering in the future, just because this is a decently large piece of code. Also, another note, I'm guessing your include of strings.h is a typo. The actual standard library is string.h.  I was able to modify your program and get it to work. The basis of the problem here is a use-after-free bug created by the stack, which basically just means that you're using a pointer to some memory that you already called free on. The situation where this happens is when you call top and then pop. top returns the data pointer, but then pop calls free on this same pointer. All of this happens before you actually use the result of top, meaning that when you use that result you're reading a value that you already freed, and thus a use-after-free bug.  Fixing the allocation problems isn't to complex for this code, surprisingly. I'm not going to just post my edited code, but I will give you the general idea, which is basically to remove your copyString call and free(tmp->data); line from the stack code. That way, the stack doesn't handle allocation of the data supplied to it at all, instead it simply keeps hold of whatever is pushed, and then returns that same pointer on a top.  With that modification, you provide a string to push (Such as the result of formats), and then the stack will return this same string when you call top. The advantage here is that by removing the copyString and the matching free, the stack no longer has to worry about managing the memory pointed to by data. Instead, the user of the stack is responsible for managing their own memory.  You actually use the stack in the code as though the above was already the case for the most part. For example, the usage of formats is correct, formats returns an allocated buffer, and then you push that allocated buffer on to the stack to store it. You leak the result of formats currently, but if you implement what I'm describing, then that usage of formats will actually be right.  The only real catch is making sure that all the inputs to push are malloc'd strings (There's one case where the string you're pushing isn't a malloc'd string - Use strdup for this situation). Then, it's just a matter of calling free correctly, which just means calling free on every return of top after you're done using it (So not in pop).."
C_Programming,35d7de,DSMan195276,1 point,Sat May 9 07:08:43 2015 UTC,Another way of fixing the problem is to have pop both pop and return the pointer to data.  I think using copyString is a good idea because then the stack structure can fully manage its own memory. Imagine if some entries were string literals and some were malloc'd strings for example.  (Your idea is workable of course but the OP's way is less risk of an invalid free or a memory leak).
C_Programming,35d7de,OldWolf2,1 point,Sat May 9 07:48:45 2015 UTC,"I personally like pop returning the pointer as well as removing it, IMO it makes problems like this one more obvious.  Personally, I disagree. I have a few problems with the stack mallocing it's own copies of the strings. The first is that you don't really avoid invalid free's or memory leaks because you still have to pass back (In top or pop) a new copy of the string you currently hold. Meaning, you have to allocate a copy when you receive it in push, and allocate a copy when you pass it back in top or pop. If you don't free the copy provided to push, or don't free the result of pop, then you'll still get memory leaks (Which is virtually the same as my setup, except my setup doesn't require calling free when you push).  Also in your setup, like in OP's code, if you just pass the same copy that the stack is holding back with top, then a use-after-free error is extremely easy to do (Just don't make your own copy of the string before you pop). On the flip side, if you keep passing copies back, then every time you use top you have to pass a new copy of the string, meaning that successive calls to top don't require the same pointer.  Personally, I think that having the stack manage it's own strings just needlessly complicates the setup and the code for no benefit. If you don't have the stack manage it's own memory, then you can use the same stack code with malloc'd strings, string literals, struct's, etc.. Obviously, pushing a string literal onto a stack with malloc'd strings is an issue, but I wouldn't consider that a huge risk, and it's easy enough to strdup them before passing them to the stack, and in either case here you have to know whether or not you're pushing a string literal or an allocated string. In your setup, any code that pushs a string has to keep track of if that string was malloc'd or not: If the string was malloc'd they have to free it, but if it's a literal they don't. So, you really can't mix malloc'd strings and string literals even with your setup, or else after you push the string you wouldn't know whether or not to free it. So, with either approach the code itself doesn't really change any besides the usage of strdup if you have a string literal, because in both cases you have to keep track. In my case, you just have to add an extra strdup, and in your case you have to make sure not to call free. But, in this case, an extra advantage of my code is that if I have a stack that's only going to ever contain string literals, I can completely avoid allocating any memory at all - just pass the string literals to push, and then get them from pop - No strduping required.  This is actually a design point that I feel pretty strongly about. Later today I may write-out some examples."
C_Programming,35d7de,DSMan195276,1 point,Sat May 9 18:05:00 2015 UTC,"Notice that strings.h exists, too, on POSIX-like systems which might be why OP didn't catch the error."
C_Programming,35d7de,FUZxxl,1 point,Sat May 9 12:52:14 2015 UTC,"Yes, it is a real standard header. I actually had that note in my comment but must have removed it when editing. Originally, I thought strings.h actually implicitly included string.h, which is why he didn't notice, but it doesn't - you get errors about all the str functions not being defined if you compile it with only strings.h."
C_Programming,35d7de,DSMan195276,1 point,Sat May 9 17:46:21 2015 UTC,"As well as what DSMan said here are some style notes:   snprintf(buf, length, ""(%s%s%s)"", s2, op, s1); is an improvement over a series of strcpy and strcat use char const * instead of char * for any case where the string will not be modified (mostly function parameters, but also some function return types and local variables) In infix either check s1 and s2 are non-NULL before calling formats, or do that check in formats, or both.   Finally, you could have solved the problem by debugging. Here is an intro if you haven't debugged before."
C_Programming,35d7de,OldWolf2,1 point,Sat May 9 07:50:50 2015 UTC,Have to use c89 for school
C_Programming,35d7de,OldWolf2,1 point,Sun May 10 03:38:03 2015 UTC,"const is in C89. sprintf also is (you can use that instead of snprintf in my example, since you calculated the length)."
C_Programming,35d7de,FUZxxl,1 point,Sun May 10 07:59:50 2015 UTC,You might want to revamp your argument parsing. Look into the getopt function for how to do easy and painless argument parsing.
C_Programming,35d7de,pfp-disciple,1 point,Sat May 9 12:53:28 2015 UTC,"others have made great comments, including the use after free problem, and debugging. I hughly recommend looking into debugging, and the various tools (valgrind, cppcheck, lint, gdb, etc).  I just want to say that, for the most part, your code looks great! It is well formatted, the variables and functions are well named. The structure is very readable. What you have accomplished well is writing maintainable code. Note that DSMan said you can fix the problem with relative ease -- that's because your code is maintainable.  One more, minor, comment: your CopyString() as written could be replaced with strdup()"
C_Programming,35bigx,H_Korean,3,Fri May 8 18:55:25 2015 UTC,"gradeCnt++;         if (grade[c] == STOP_VALUE -1)     {         break;     }   instead of       if (grade[c] == STOP_VALUE -1)     {         break;     }     gradeCnt++;   if you stop on the first one, you'll be dividing by 0. And regardless what you set STOP_VALUE to, your count will be 1 short, since you exit the loop before incrementing the count.  ---- Edits: ----   Also, though it isn't relevant here, typecasting takes precedence over division, so:  (float) gradeSum/gradeCnt  would typecast gradeSum to float then divide. Reference: http://en.cppreference.com/w/c/language/operator_precedence printf(""\nYou have made the maximum # of entries.\n""); would never print, as the loop would not be entered if c == array size."
C_Programming,35bigx,Dihydrogen_Oxide,1 point,Fri May 8 19:33:11 2015 UTC,"I see...So how would I go about including that? You were right, I changed the array size to 10 to test it and it did not print.  However, when I took out the gradeCnt++; it just gave a large line of text repeating ""Please enter a grade"".   How would I go about including the maximum # of entries? Would I change the IF   if(c > ARRAY_SIZE)         {             printf(""\nYou have made the maximum # of entries.\n"");         }   ?  What would I have to do to go about including the print statement?"
C_Programming,35bigx,Dihydrogen_Oxide,1 point,Fri May 8 19:59:48 2015 UTC,"Since you're incrementing gradeCntr right after inputting a value, use that to check. The reason why c wouldn't is because it's incremented after the loop.      gradeCnt++;     if(gradeCnt==ARRAY_SIZE)     {         printf(""\nYou have made the maximum # of entries.\n"");     }   should do the trick"
C_Programming,35bigx,Dihydrogen_Oxide,1 point,Fri May 8 20:04:11 2015 UTC,"Ahh, so I was messing around with it, and added -1 to the IF statement. Turns out all I had to do was add -1 so that it would print out the maximum it seems."
C_Programming,35bigx,sftrabbit,1 point,Fri May 8 20:10:32 2015 UTC,"Yeah, that would work too, since c would always be one less than gradeCntr when you're doing that check"
C_Programming,35bigx,sftrabbit,1 point,Fri May 8 20:56:58 2015 UTC,Seems to work okay for me:  Enter grades when prompted. Valid rating are 1-100. Enter x when finished. Please enter a grade [01/100]: 50 Please enter a grade [02/100]: 25 Please enter a grade [03/100]: 30 Please enter a grade [04/100]: 40 Please enter a grade [05/100]: -1  ==Data Entry Complete==  Grade  1: 50 Grade  2: 25 Grade  3: 30 Grade  4: 40  Average: 36.25
C_Programming,35bigx,Dihydrogen_Oxide,1 point,Fri May 8 19:31:25 2015 UTC,"Hm....I'm trying to figure where I went wrong with it accepting 0 as one of the input...Ideally, I'm trying to get it to print  ==Data Entry Complete==  Grade 1: 50 Grade 2: 25 Grade 3: 25 Grade 4: 30 Grade 5: 0   or something like that  Edit: Okay, so it did work, but now I need to figure why ""-1"" exits instead of just ""x"". Any explanation? Or some kind of insight that'd help me get a better grasp on it?"
C_Programming,35clwk,c_param_ooo,4,Sat May 9 00:39:44 2015 UTC,"Their is actually ""no standard"" according to what I read.   Read about sequence points."
C_Programming,35clwk,wgunther,1 point,Sat May 9 00:46:41 2015 UTC,Thank you!!
C_Programming,35clwk,crookedkr,1 point,Sat May 9 00:51:17 2015 UTC,I believe this is undefined behavior. You need a sequence point between the increments for them to apply properly as /u/wgunther suggested.
C_Programming,35clwk,OldWolf2,1 point,Sat May 9 00:49:23 2015 UTC,I tried to turn optimization off and it did nothing. Thank You for the undefined tip though!!!
C_Programming,35clwk,OldWolf2,1 point,Sat May 9 00:50:35 2015 UTC,"Actually it is undefined behaviour, meaning anything could happen. (program crash, explode, etc.)  The case of a finite number of permitted results is called ""unspecified behaviour"" (which is not the case here)."
C_Programming,35clwk,a3f,1 point,Sat May 9 00:55:34 2015 UTC,"When you say ""a whole slew of results"" it sounds to me like you are describing a large but finite number of possibilities. Especially combined with ""since order of evaluation is not defined"", which seems to be implying that the ""slew"" arises from the lack of definition of order (which is not true)."
C_Programming,35clwk,raevnos,1 point,Sat May 9 03:59:12 2015 UTC,"It's undefined and unspecified behavior.  It's unspecified which argument is evaluated first, the only guarantee is that all are evaluated before function entry.  It's undefined because you are modifying the same i more than once between sequence points."
C_Programming,35aekf,Clauc,4,Fri May 8 13:31:31 2015 UTC,"char dices[3][3] = { {'O', ' ', ' '},{' ', ' ', ' '},{' ', ' ', 'O'} };    printf(""%d\n"", kast[a]);   There's your problem. The array you pass to printf is not null-terminated, causing the problems you experience. Use a string like this instead:  const char *dices = ""O  \n   \n  O\n"";   This should work. I'm not really sure what you expected to happen when you print a two-dimensional array of characters."
C_Programming,35aekf,FUZxxl,1 point,Fri May 8 13:53:45 2015 UTC,"You mean like this?   if(kast[a] == 1){     const char *dices = ""  \n  O \n  \n"";     printf(""%s""), dices;"
C_Programming,35aekf,FUZxxl,1 point,Fri May 8 14:27:02 2015 UTC,"If you were to fix the printf invocation, then yes."
C_Programming,35bjbw,FanboyREDDIT,3,Fri May 8 19:02:28 2015 UTC,"int ax, ay, bx, by, aux1, aux2;         scanf(""%d%d%d%d"", &ax,&ax,&ay,&ay);         scanf(""%d%d%d%d"", &bx,&bx,&by,&by);        What are you trying to do here?  It looks like you are trying to read in 4 numbers on each line, but youre only reading in 2.  you might need ax1 and ax2 as well as ay1 and ay2, same for b."
C_Programming,35bjbw,rafleury,1 point,Fri May 8 21:14:10 2015 UTC,"On the exemple ax1 is equal to ax2, since its a square, rectangle. So I read the entry, and put both in the same variable. Because they will be always equal (?) (or not? maybe that is my mistake?)"
C_Programming,35bjbw,rafleury,1 point,Fri May 8 22:37:37 2015 UTC,"Nope, you can have a square start at (1,3) and end at (4,6) for example."
C_Programming,35bjbw,rafleury,1 point,Fri May 8 22:39:44 2015 UTC,The sides of the rectangle are always parallel to the x and y axes.
C_Programming,35bjbw,rafleury,1 point,Fri May 8 22:45:06 2015 UTC,In the example I provided they are parallel too.  All this means is that the rectangle (Square) is not rotated at all.
C_Programming,35bjbw,SeriousBug,1 point,Fri May 8 22:45:56 2015 UTC,"But in the input, for this example would be x0 = 1, y0 =3, x = 4... oh damn, u right, I got that."
C_Programming,35bbdw,zer0_m0,3,Fri May 8 17:59:30 2015 UTC,"You are not going to write your own pdf renderer (i.e. a program that computes from a PDF file what it looks like), it's highly complicated to do so. You can take an existing PDF renderer and slab your own frontend on it, the libpoppler contains a renderer but you could also use ghostscript or similar tools."
C_Programming,35bbdw,FUZxxl,1 point,Sat May 9 12:25:19 2015 UTC,"Yes, that is what I am trying to do. I can't find the renderer part. I was asking if. someone could point it out of the libpoppler. I looked at ghostscript also. No, worries though. I got someone irl helping me."
C_Programming,35bbdw,FUZxxl,2,Sat May 9 13:37:23 2015 UTC,"libpoppler looks complicated. Here is the API of ghostscript, maybe it's easier to use for you."
C_Programming,358aig,zer0_m0,17,Thu May 7 22:59:34 2015 UTC,Sockets. Pipes. Mailboxes.
C_Programming,358aig,playaspec,6,Thu May 7 23:18:48 2015 UTC,Is there a pdf that shows how to use them?
C_Programming,358aig,raevnos,6,Thu May 7 23:24:44 2015 UTC,"W. Richard Stevens' Unix Network Programming, Vol. 2."
C_Programming,358aig,lucidguppy,2,Fri May 8 04:17:35 2015 UTC,This isn't free but it was well worth it
C_Programming,358aig,loderunnr,6,Fri May 8 10:48:22 2015 UTC,Shared memory. Memory mapped files. Message queues. Signals.  Read these for an extensive coverage of some Interprocess Communication (IPC) methods:   http://beej.us/guide/bgipc/output/html/multipage/index.html https://docs.freebsd.org/44doc/psd/20.ipctut/paper.pdf https://docs.freebsd.org/44doc/psd/21.ipc/paper.pdf
C_Programming,358aig,angdev,3,Fri May 8 12:12:57 2015 UTC,"Yes there is, but you will need to be a bit more specific as to what you are trying to do. Are you trying to force the other program to open the file against it's will? Or is the target program something you have developed yourself and you are looking to use a standardized way of communicating between the processes (through sockets, pipes, and mailboxes as /u/playaspec pointed out)."
C_Programming,358aig,_predator_,1 point,Thu May 7 23:49:09 2015 UTC,I would not say I am trying to force it but yea I have to write a program the tell another program to open a pdf specifically. I do not know what program is going to be used but adobe's acrobat is popular.
C_Programming,358aig,maep,1 point,Fri May 8 00:13:15 2015 UTC,It seems I can use system() to do it. I will give that a try. Thanks for your attention.
C_Programming,358aig,bigbassdaddy,2,Fri May 8 00:23:48 2015 UTC,"I'd use popen to do that, just because you will be able to receive return values of the program you called which allows you to react when something went wrong. Pipes also have more ""features"" you may like. Just google it."
C_Programming,356s26,_COMPLEX_H,9,Thu May 7 16:03:52 2015 UTC,"Have you declared scanner before you are using it in main? If an undeclared function is used, a C compiler will assume that the return type of the function is int."
C_Programming,356s26,zifyoip,1 point,Thu May 7 16:06:09 2015 UTC,"Christ, it was declared as a type char in the header. It was returning pointer to char in the source file though!  I need a system. Thanks as always, zifyoip..."
C_Programming,356s26,bames53,8,Thu May 7 16:11:39 2015 UTC,"it was declared as a type char in the header.   This is the reason that the implementation file should always include its own header. The first line of scanner.c should be #include ""scanner.h"". That way, when you compile scanner.c, any differences between the header prototype and the c file will produce compiler diagnostics."
C_Programming,356s26,loderunnr,1 point,Thu May 7 18:02:13 2015 UTC,"Yes, you're right, I stopped doing that at some point. Probably from laziness in putting up #ifndef catches. I would have continued to if not for this reminder, thanks."
C_Programming,356s26,wgunther,3,Fri May 8 01:59:57 2015 UTC,"I see you've got some help already. I just wanted to cheer you up.  The only way to understand pointers is to get them wrong a lot and learn a little more each time. It's pretty counter-intuitive at first, but pretty soon you're ""thinking with pointers"".  If you know how to use your debugger (gdb, lldb or an IDE like Visual Studio), try looking at the memory at breakpoints. Look at the addresses for your strings and see how the bytes are laid out. Look at the memory at the address of a struct. Understanding memory layout is key to understanding pointers.  This article is also a fantastic explanation of how your program handles memory. It gets pretty technical but it really covers it all."
C_Programming,356s26,geeknerd,1 point,Thu May 7 21:47:15 2015 UTC,"Oh, I was staring at gdb for quite a while, wondering why scanner cut the integer of size X down to nothing. It just didn't occur to me that the definition was wrong, because I was also had the source file open. I was fairly certain i was right about the pointers, and I kind of was here."
C_Programming,356s26,wgunther,4,Fri May 8 01:56:49 2015 UTC,"It would help to post something compilable as well. getline isn't standard C either, so be explicit about what extensions you are using."
C_Programming,356s26,geeknerd,1 point,Thu May 7 16:09:59 2015 UTC,Isn't it now though? That's why I'm using it. Edit:Apparently not? I wonder where I got that idea from.
C_Programming,356s26,tmtwd,5,Thu May 7 16:12:42 2015 UTC,"While not standard C, getline() is now a POSIX C extension, so it's standardized there. http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html  One thing to note now that you have your first problem sorted:   The application shall ensure that *lineptr is a valid argument that could be passed to the free() function. If *n is non-zero, the application shall ensure that *lineptr either points to an object of size at least *n bytes, or is a null pointer."
C_Programming,3533bw,Ceffa93,10,Wed May 6 18:21:46 2015 UTC,"If memory management is your top concern, a ""flat map"" might be the way to go instead of hash table.  And it's easy to implement yourself.  Just have an array of structures of keys/values, and keep the array sorted by keys.  Lookups are O(log n) (binary search to find item), insertions/deletions are O(n) (because you have to move things around, or grow the size of the array which means copying each item).  Iteration is very fast: it's cache-friendly (you're just looping over an array), and there's no pointers to chase around.  It has very low memory overhead, because a node is just a key and value, no pointers to maintain the data structure.  Though you might consider allocating each value, if the value is a large."
C_Programming,3533bw,boredcircuits,7,Wed May 6 18:53:31 2015 UTC,What does your data look like? The best choice for a data structure cannot be made without knowing what kind of data you are using.
C_Programming,3533bw,FUZxxl,5,Wed May 6 22:20:40 2015 UTC,"Are you sure you actually need a hash-table and that something else wouldn't work?  You could always go for the bucket-style hash. You pre-allocate a fairly large array of pointers (Which doesn't ever change size), and your hash indexes this array. Each entry in the table refers to a linked-list of items with that hash. So the look-up plan is to do your hash, then iterate through the linked-list at that location and read/insert/remove/etc. your item. The setup is extremely easy and it can be fairly effective, as if your hash is decent then your linked-lists shouldn't ever get very long.  Something like this:  struct item {     struct item *hash_link;     /* stuff */     int key; };  struct item *hash_table[2048] = { NULL }; /* Initialize all of them to NULL */  /* Calculate the hash */ int hash_get(int key) {     /* Extremely simple hash alg, just take the lower bits of the key */     return (key % (sizeof(hash_table)/sizeof(hash_table[0]))); }  void hash_insert(struct item *i) {     int index = hash_get(i->key);      /* Insert onto the beginning of the list */     i->hash_link = hash_table[index];     hash_table[index] = i; }  struct item *hash_index(int key) {     int index = hash_get(key);      struct item *cur;     for (cur = hash_table[index]; cur; cur = cur->hash_link)         if (cur->key == key)             return cur;      return NULL; }   That's not the greatest code (It only works for struct item objects, nothing else), but that's the basic idea, and for a one-off it would be just fine. If you need multiple hash tables you'd probably want to look into using container_of to make the hashing stuff generic. I could show you an example if you'd like. Other then that, this should be decently effective for a hash-table if speed isn't a huge concern. Obviously, you have to manage the memory holding the nodes themselves, but in general that's not a huge deal. Just allocate them all separately using malloc, and then fall free on them when you remove them from the hash_table (Removing is like hash_index's code, but you remove cur from the list as well as return it).  If you wanted, you could also have the hash table make copies and do the memory management itself. That could simplify things though it would be slower. If you went that route, then you'd just use malloc and make a new struct item in hash_insert, and then call free on it when you call hash_remove. You'd also want a hash_empty function, or something similar, that can loop over the entire hash table for you and free every node in the linked-lists.  Edit: Corrected an error, hash_index returns a pointer to a struct item, not a struct item by-value - Very important distinction."
C_Programming,3533bw,DSMan195276,6,Wed May 6 23:20:12 2015 UTC,"There are binary trees, binary search, real hash tables, Judy arrays, and, if you're mostly interested in text, you could look at tries."
C_Programming,3533bw,bart2019,1 point,Wed May 6 19:30:30 2015 UTC,"Trie:       In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree (as they can be searched by prefixes), is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Values are normally not associated with every node, only with leaves and some inner nodes that correspond to keys of interest. For the space-optimized presentation of prefix tree, see compact prefix tree.    Image i - A trie for keys ""A"", ""to"", ""tea"", ""ted"", ""ten"", ""i"", ""in"", and ""inn"".     Interesting: Trie-sur-Baïse | Trie-Château | Lalanne-Trie | Radix tree   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,3533bw,autowikibot,3,Wed May 6 19:31:06 2015 UTC,You could have a look at uthash.
C_Programming,3533bw,imaami,2,Thu May 7 04:26:31 2015 UTC,"http://playcontrol.net/opensource/LuaHashMap/ maybe? I've never used it, but I came across it doing some Lua stuff, had a similar idea I never followed through with."
C_Programming,3533bw,TehJohnny,2,Wed May 6 18:39:31 2015 UTC,KHash? (Here: https://github.com/attractivechaos/klib )
C_Programming,3533bw,p3s3us,2,Wed May 6 20:37:05 2015 UTC,"While everyone's throwing out their own particular favourite, let me throw down mine:  https://apr.apache.org/docs/apr/1.5/group__apr__hash.html  APR has a lot of things you don't need, but it does have a lot of things that you will look for from time to time."
C_Programming,3533bw,matjam,2,Wed May 6 21:16:05 2015 UTC,"Strong recommendation for KyotoCabinet. It does what you want, is very light on memory, can persist to disk if necessary, and overall very efficient.  http://fallabs.com/kyotocabinet/"
C_Programming,3533bw,doom-o-matic,1 point,Thu May 7 13:05:41 2015 UTC,Disk based hash tables/btrees okay? http://fallabs.com/kyotocabinet/ and many other options.
C_Programming,3533bw,raevnos,1 point,Wed May 6 18:45:46 2015 UTC,"i tried btrees, waaaay to heavy for what i need to do"
C_Programming,3533bw,sanjayar,1 point,Wed May 6 19:40:33 2015 UTC,consider - http://concurrencykit.org/
C_Programming,354m3g,learningccc,5,Thu May 7 01:42:30 2015 UTC,"""str== strcat(argv[1],str2);"" may be problematic. The ""=="" is a comparison, rather than an assignment operator. strcat copies the second argument's content's to the end of the first string. This will append to argv[1], probably running over the end of ""argv[1]""'s allocated space.  You should try the following:  strcat(str, argv[1]); strcat(str, str2);  Possibly also check that strlen(argv[1]) + strlen(str2) is less than the amount allocated for str."
C_Programming,354m3g,lurkanibal,3,Thu May 7 02:40:03 2015 UTC,"You should try the following:  strcat(str, argv[1]); strcat(str, str2);   The first of those should be a strcpy, not strcat. The contents of the array str have not been initialized."
C_Programming,354m3g,zifyoip,1 point,Thu May 7 12:17:19 2015 UTC,"If you're programming for Unix or Linux, it's usually a bad idea to enforce certain file extensions. The Unix way is to let the user specify any file name and not mess with it. For instance, what TeX does (implicitly adding .tex to files without an extension) is a really shitty idea."
C_Programming,3563me,GolDyGTA,2,Thu May 7 12:37:36 2015 UTC,I think you're in the wrong sub OP. Perhaps you are looking for /r/csharp?
C_Programming,353va4,IamFuzzles,7,Wed May 6 21:52:51 2015 UTC,"There's nothing in the standard C library to do that.  You have to use platform specific APIs, but you didn't specify what platform you're using (hint: always do that.)  On Windows, you use FindFirstFile() and FindNextFile().  On POSIX, you use opendir(), readdir(), and closedir().  Note that the only members of struct dirent that are required to exist are the inode number (d_ino) and the filename (d_name).  On some systems there may also be a type field (d_type) that allows distinguishing between files and directories without having to stat() the name, but that's not portable."
C_Programming,353va4,Rhomboid,1 point,Wed May 6 22:01:32 2015 UTC,"Ugh, the worst part of programming. Wtb a single standard OS :P"
C_Programming,353va4,TehJohnny,2,Thu May 7 13:39:03 2015 UTC,Can you please define what the term “text file” means in this context? There isn't anything making files containing plain text special and it's going to be a bit tricky to find out which files contain plain text.
C_Programming,353va4,FUZxxl,1 point,Wed May 6 22:23:00 2015 UTC,A possible solution could be to accept one file as an argument and then use find and xargs to do the work for you.
C_Programming,353va4,f5f5f5f5f5f5f5f5f5f5,1 point,Thu May 7 01:18:53 2015 UTC,"I apologize that this is very much microsoft C, but I hope you find it useful, adaptable."
C_Programming,3526b9,petosorus,1 point,Wed May 6 14:06:25 2015 UTC,"I'm not familiar with this area, but a quick Google search for ""matrix library c"" gives this StackOverflow answer.  If these libraries don't have the required functionality, then sure, write your own and host it. However, bear in mind that just because you can't find it doesn't mean it doesn't exist."
C_Programming,3526b9,Nirenjan,1 point,Wed May 6 16:07:35 2015 UTC,"I'll look at those tomorrow at work, thanks."
C_Programming,3527w3,meith1,2,Wed May 6 14:19:50 2015 UTC,"You may want to post a link to the complete Makefile in gist or pastebin. With just the snippet you've provided, it's hard to see what the issue is. Also, it would help to get a copy of the build output."
C_Programming,3527w3,Nirenjan,1 point,Wed May 6 16:13:15 2015 UTC,http://pastebin.com/Fgq75Nbn  This is what it looks like now. I tried changing things around after googling a bit. I don't have much experience in it.
C_Programming,3527w3,Zange_F,2,Wed May 6 17:00:31 2015 UTC,Use the variable LDLIBS instead of LDFLAGS.  Source:  https://ftp.gnu.org/old-gnu/Manuals/make-3.79.1/html_chapter/make_10.html  https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html
C_Programming,350wxi,RedTissueLapShade,2,Wed May 6 04:33:01 2015 UTC,I found this helpful  http://c-faq.com/struct/
C_Programming,350wxi,tmtwd,2,Wed May 6 05:28:44 2015 UTC,The site seems to be down. Here is a google cache version: http://webcache.googleusercontent.com/search?q=cache:UBivok6hWFMJ:c-faq.com/struct/+&cd=1&hl=en&ct=clnk&gl=uk
C_Programming,350wxi,antoniocs,1 point,Wed May 6 10:20:58 2015 UTC,Awesome. Thank you!
C_Programming,350wxi,NoMoreIdols,2,Wed May 6 21:20:17 2015 UTC,"Implement some of these in C without objects, and you will be in for a challenge. http://en.wikipedia.org/wiki/Book:Data_structures"
C_Programming,350wxi,FUZxxl,1 point,Wed May 6 05:33:11 2015 UTC,What do you mean with “without objects.?” You are going to have a hard time programming anything in C without using objects.
C_Programming,350wxi,FUZxxl,1 point,Wed May 6 06:18:21 2015 UTC,You are going to have a hard time programming anything in C without using objects.   uh...?  I think you knew what you wanted to say but somehow you said the inverse.
C_Programming,350wxi,tmtwd,3,Wed May 6 06:40:32 2015 UTC,"I think I was very clear in what I said. Here is the definition of the term object from ISO 9899:2011§3.15:   3.15 (object)  1 region of data storage in the execution environment, the contents of which can represent values  2 NOTE When referenced, an object may be interpreted as having a particular type; see 6.3.2.1.   Thus, in the program  #include <stdio.h> int main() {     puts(""Hello world""); }   You are already using an object—namely, an object of type char[12] created by the string literal ""Hello world""."
C_Programming,350wxi,NoMoreIdols,2,Wed May 6 06:45:43 2015 UTC,You are right of course. I suppose he was referring to C++ objects or java objects.
C_Programming,350wxi,BigPeteB,1 point,Wed May 6 07:15:56 2015 UTC,"That's right. Many examples of data structure implementations are written in languages that use classes (c++, java, etc). I suppose I should have said ""classes""."
C_Programming,350wxi,NoMoreIdols,1 point,Wed May 6 13:39:00 2015 UTC,"Sure, which is why we call them ""class oriented languages"".  Oh wait, we don't.  Sorry, but /u/FUZxxl is being needlessly pedantic. In common parlance, ""objects"" and ""classes"" are part of the same concept, and the term ""objects"" is not used with C except to say that it's something C++ has and C doesn't."
C_Programming,350wxi,FUZxxl,1 point,Wed May 6 15:41:58 2015 UTC,I am glad there is at least one person on reddit that can understand me.
C_Programming,350wxi,NoMoreIdols,0,Wed May 6 15:50:12 2015 UTC,"Ehem... “object” is a fairly general term. The special thing object oriented languages have is the focus on objects (as opposed to, say, functions); this is explained greatly in the article execution in the kingdom of nouns. The fact that there are no classes or methods or inheritance in C doesn't mean that C doesn't have objects."
C_Programming,350wxi,ollir,1 point,Wed May 6 15:51:02 2015 UTC,In the kingdom of math-land I suppose that any set or element of a set can be called an object.
C_Programming,350wxi,FUZxxl,2,Wed May 6 20:35:59 2015 UTC,Ok go work for a committee now.
C_Programming,34ztts,cas_999,2,Tue May 5 22:45:58 2015 UTC,"That's an interesting problem, since you normally see it going the other way - infix to postfix. I wonder if you can do the shunting yard algorithm in reverse..."
C_Programming,34ztts,raevnos,1 point,Tue May 5 23:15:12 2015 UTC,"Yeah, and most everything talking about postfix to infix isn't in C so it doesnt really help me."
C_Programming,34ztts,raevnos,1 point,Wed May 6 00:36:25 2015 UTC,"Being able to translate between different programming languages is a useful skill. The tricky thing with C compared to most other languages is having to free up memory yourself, but for a short-lived program like this, you can cheat and just not worry about it.  Example code here is C#, but he also describes the algorithm in detail. That would be a good starting point."
C_Programming,34ztts,Nirenjan,1 point,Wed May 6 00:47:18 2015 UTC,Thanks for this.  Using a binary search tree actually sounds simpler though in my opinion.. I feel like this algorithm won't be quite as easy to implement in C as it looks in C#
C_Programming,34ztts,balkenbrij,2,Wed May 6 01:15:45 2015 UTC,"Seems to me that the easiest way to convert it into a tree is to use a stack walking from from left to right - push numbers on to the stack as nodes, and when you get an operator, pop the right node and then the left node, and push the operator node onto the stack. Repeat until you use up all the parameters, success is when you have a stack with a single element - the root node. If you wind up with an operator and have only 1 element in the stack, then you know you have a malformed expression with too many operators, or if you have more than 1 element in the stack after you're done with all the arguments, then you have too many operands.  Sorry if this isn't much help, rather late where I am right now."
C_Programming,34z2ju,tmtwd,8,Tue May 5 19:18:24 2015 UTC,"When you use a ++ operator it will increment the address by the size of that variable type. An integer is 4 bytes, so ++ will increment that address by 4 bytes, while a char is 1 byte, hence the ++ operator will increment that address by 1 byte.  On that note, you will not be able to increment a void pointer(void*)."
C_Programming,34z2ju,Dihydrogen_Oxide,1 point,Tue May 5 19:43:45 2015 UTC,"More generally, you cannot increment a pointer whose base type has an unknown size. That's implicitly the case for void, but also for types that have only been forward declared, e.g. opaque data types."
C_Programming,34z2ju,Nimbal,1 point,Wed May 6 07:44:56 2015 UTC,"Opaque data type:       In computer science, an opaque data type is a data type whose concrete data structure is not defined in an interface. This enforces information hiding, since its values can only be manipulated by calling subroutines that have access to the missing information. The concrete representation of the type is hidden from its users, and the visible implementation is incomplete. A data type whose representation is visible is called transparent.  Opaque data types are frequently used to implement abstract data types.     Interesting: Opaque pointer | Abstract data type | Information hiding   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,34z2ju,autowikibot,1 point,Wed May 6 07:45:20 2015 UTC,"I didn't know about that data type, I'll be sure to look into them. Thanks!"
C_Programming,34z2ju,Dihydrogen_Oxide,0,Wed May 6 14:48:05 2015 UTC,"You can increment a void pointer, in that case the address is only incremented by one, like a char pointer.  EDIT: Seem like I was wrong. Thanks for the corrections."
C_Programming,34z2ju,hyh123,13,Tue May 5 21:06:34 2015 UTC,No. gcc implements incorrect behaviour there. Incrementing a pointer to void is undefined as void is an incomplete type (that cannot be completed) who's size is thus indeterminate.  gcc implements incorrect semantics with respect to pointer arithmetic on pointers to void.
C_Programming,34z2ju,FUZxxl,7,Tue May 5 21:58:06 2015 UTC,"gcc is not incorrect. Compilers are allowed to offer extensions, so long as they do not break the behaviour of strictly conforming programs.  A program that increments a void * is not strictly conforming so the compiler can do what it likes so long as there is a warning given if the compiler is invoked in conforming mode."
C_Programming,34z2ju,OldWolf2,1 point,Wed May 6 01:32:38 2015 UTC,Compilers aren't obligated to warn for undefined behavior (unless it's required for this specific case).
C_Programming,34z2ju,smikims,1 point,Tue May 12 02:06:46 2015 UTC,"They're required to give a diagnostic for constraint violations, and incrementing a void * is a constraint violation."
C_Programming,34z2ju,OldWolf2,3,Tue May 12 11:50:53 2015 UTC,Thanks for letting me know. I didn't know that.
C_Programming,34z2ju,hyh123,1 point,Tue May 5 23:32:52 2015 UTC,"Can you cast a void pointer to, say, a char pointer to increment it?"
C_Programming,34z2ju,CptObviousRemark,1 point,Wed May 6 06:22:14 2015 UTC,"Yes, that's possible and legal."
C_Programming,34z2ju,FUZxxl,1 point,Wed May 6 06:26:02 2015 UTC,If it's undefined behavior then GCC is perfectly within their rights to do whatever the hell they want in that case.
C_Programming,34z2ju,smikims,5,Tue May 12 02:06:01 2015 UTC,"It works in some compilers - like GCC - but it's not portable and will cause warnings; e.g. ""warning: pointer of type 'void *' used in arithmetic [-Wpointer-arith]"" for GCC."
C_Programming,34z2ju,Aransentin,3,Tue May 5 21:29:53 2015 UTC,"The question you are asking looks like an operator precedence one, assuming you are asking if *(p++) is the same as *p++, regardless of pointer type. If that is true, then yes. It isn't a question of the type of pointer, it is simply the fact that ++ always happens before *, unless parenthesis say otherwise. I personally never rely upon precedence this heavily, since it hurts readability."
C_Programming,34z2ju,Pigsquirrel,3,Tue May 5 19:32:50 2015 UTC,"You're going to have to define what you mean by ""the same.""  If you tried to copy a nul-terminated character string using, say, a pointer to int and the above code, it would fail horribly, because checking for zero would only find a case of a int-sized zero (on most platforms, 4 consecutive nul bytes) not a single char-sized nul character.  (But on the other hand, it would copy sizeof(int) bytes per pass, which is much more efficient than copying a single character at a time, and in most real world implementations of strcpy() or strcat() you will definitely find something along those lines at the core of the algorithm, after accounting for alignment and remainders of the length modulo sizeof(int).)  However if you had two arrays of ints and you wanted to copy from one to the other, stopping on the first zero integer, then the above work work, because the operations on pointers (like dereferencing, postincrement, etc.) are the same regardless of the type being pointed to, with the exception of void.  But I don't know why you'd ever want to do that; the code you're referring to is rather specialized to the case of copying nul-terminated strings, so it's rather pointless to talk about what it would do with other types."
C_Programming,34z2ju,Rhomboid,1 point,Tue May 5 19:56:05 2015 UTC,"so you're saying, if I didn't mention they were char pointers, you could most likely assume they were?"
C_Programming,34z2ju,OldWolf2,1 point,Tue May 5 19:58:39 2015 UTC,"Yes, because the loop exits when it finds an element equal to 0; and strings are commonly stored this way but other data rarely is stored that way."
C_Programming,34z2ju,SinanUnur,2,Wed May 6 01:33:46 2015 UTC,"No, they are not. See the C FAQ."
C_Programming,34z2ju,OldWolf2,2,Tue May 5 21:26:09 2015 UTC,"If s2 points to an item in a null-terminated sequence, then both of those snippets are the same. However your title seems unrelated , C has various different sorts of pointer."
C_Programming,34z2ju,gandalf013,2,Wed May 6 01:30:14 2015 UTC,"One difference in the two snippets is that the second snippet will increment p and s2 even when *s2 is 0, while the first one will not."
C_Programming,34z4r4,SinanUnur,1 point,Tue May 5 19:34:51 2015 UTC,"Without actually digging into the standard, I'd think not allowing +offsetof() fixed a bug.  Edit: or not. Unary plus can apparently be used with things besides literal numbers."
C_Programming,34z4r4,raevnos,1 point,Tue May 5 19:41:59 2015 UTC,"My copy of the C99 draft says:   More latitude is permitted for constant expressions in initializers. Such a constant expression shall be, or evaluate to, one of the following:   an arithmetic constant expression,    And, later, ...   8 An arithmetic constant expression shall have arithmetic type and shall only have operands that are integer constants, floating constants, enumeration constants, character constants, and sizeof expressions.   Also,    offsetof(type, member-designator) which expands to an integer constant expression that has type size_t,"
C_Programming,34zhhr,jpw22,3,Tue May 5 21:09:49 2015 UTC,Use a BLAS library like MKL or ATLAS.
C_Programming,34zhhr,raevnos,2,Tue May 5 21:23:35 2015 UTC,Performance-wise it doesn't really make sense to use BLAS for small (<10) matrices/vectors as they are not optimized for those.
C_Programming,34zhhr,Fylwind,3,Wed May 6 05:14:39 2015 UTC,"The code you linked to is atrocious and the author clearly does not understand C, arrays, or pointers. I would suggest not using it, or even reading it, as it will give you bad habits.   As /u/FUZxxl points out, do not use pre-processing for optimizations. Not only are macros hard to debug, they will be no faster than properly written code. As /u/SilverSnurfer points out, basic math libraries exist for almost every programming language, and they will most certainly be better than anything you could come up with yourself!"
C_Programming,34zhhr,angdev,2,Tue May 5 23:45:18 2015 UTC,Your system quite likely already has libraries for doing this kind of thing that take advantage of your hardware better than anything the compiler is going to produce for this kind of code. Vector operations and linear algebra are a fundamental part of scientific applications and 3d graphics so pretty much any system outside of a headless server will have libraries for ripping through this kind of stuff with hardware acceleration.  This is a big part of the job of programming: looking up what libraries are available to your program and how to say pretty please with a cherry on top to them. (a perfectly formatted and byte correct cherry at that). Some days I feel I'm less a programmer and more a guy with a higher than average tolerance for reading the manual.
C_Programming,34zhhr,FUZxxl,2,Tue May 5 23:27:33 2015 UTC,Write explicit loops and let the compiler figure out how to optimize them. Give the compiler enough information to actually perform optimization.
C_Programming,34zfzj,geoforceman,4,Tue May 5 20:58:26 2015 UTC,"Absolutely you can, and you should :) Capture and display are completely different jobs. If you want to spin it fast your sampling function should have nothing to do with the timing details of terminals, gui views, or anything else display related. I'm not an arduino or embedded guy but I assume this is a single threaded situation and you're storage limited? Depending on your frequencies of interest you may get by splitting the program's time between sampling and display, but if that's not cutting it you may need to do nothing but sample for as long as you can then communicate the results after. What kind of storage are you working with? Sd card?"
C_Programming,34zfzj,goose_on_fire,1 point,Wed May 6 01:08:55 2015 UTC,"Like the other guy said, absolutely. Can and should. Sampling and display should be decoupled.  In sensor systems, a regular sampling rate is a major factor in how good your system will be. Sample at accurate intervals, and you can deal with the rest later.  Instantaneous readings from a sensor are often not really what you want to display to a human anyway. We kinda suck at raw data. Keep a moving average and display that periodically instead.   If this is a test/debug setup, absolutely gather however many samples you can in an array and dump them at the end of the test. I've done so many times."
C_Programming,34vwv4,stymiee,1 point,Tue May 5 00:17:37 2015 UTC,"There are various ways how a strictly conforming program can detect if the return-value optimization is performed (aliasing, longjump, maybe others).  As a result, this optimization does not preserve language semantics and is invalid for C (and would be invalid for C++, too, if not explicitly allowed there)."
C_Programming,34xiee,Waylash,2,Tue May 5 11:31:29 2015 UTC,What have you tried so far?
C_Programming,34xiee,LeinadSpoon,1 point,Tue May 5 11:43:14 2015 UTC,"{     int n1,n2, sum = 0;   printf(""Enter a number  : "");  scanf(""%d"",&n);   if ( n % 2 == 0 )      printf("" %d is even number"");  else      printf("" %d is odd number"");   }          for (i = n1; i <= n2; i++)          printf(""i = %d\n"", i);          if (i % 2 == 0)          printf("" ==> Adding %d\n"", i);          sum = sum + i;        }          if (i%2=0)         printf(""sum = %d\n"", sum);          return 0;    can't seem to get it right keep on giving me syntax error i know what syntax error means but i only need the right syntax or an example to the question..."
C_Programming,34xiee,Cracky7,10,Tue May 5 12:06:42 2015 UTC,"Compare the number of } with the number of {'s.  And after that it's going to give you a different type of error, but baby steps."
C_Programming,34xiee,f5f5f5f5f5f5f5f5f5f5,2,Tue May 5 12:45:49 2015 UTC,"One trick I learned was add one for each { and subtract one for each }. But generally, creating both the opening and closing at the same time is a great way to limit these problems."
C_Programming,34wny7,JasonAndradeCan,2,Tue May 5 04:18:34 2015 UTC,What happens if you try configure and then make?
C_Programming,34wny7,FUZxxl,1 point,Tue May 5 10:22:58 2015 UTC,"By default ""configure"" will build the library for OSX/x86.  This simply won't work when building apps for iOS.  There are a bunch of other problems too.  Like needing "".a"" files for armv7 and/or x86."
C_Programming,34wny7,FUZxxl,1 point,Tue May 5 16:38:55 2015 UTC,Ah! You're trying to cross-compile?
C_Programming,34v7zv,Phatnut,4,Mon May 4 21:00:55 2015 UTC,"You can. Your problem is the way you're calling strtok, you're supposed to only pass the string in once. The second call should say  q = strtok(NULL, "" "");"
C_Programming,34v7zv,grable,2,Mon May 4 21:19:23 2015 UTC,"but if i call  p = strtok(NULL, "" "");   it will start off at where q left off right? I need to check the next token without affecting p. i need two pointers. one to the token current token (p) and one to the next token (q). what you just told me defeats the whole purpose of having two pointers since they are essentially pointing to the same place."
C_Programming,34v7zv,grable,2,Mon May 4 21:30:24 2015 UTC,"strtok maintains it's own pointer to where it was in your string between calls (which is so gross, but also irrelevant if you're just studying). What you do on your end is up to you. You could make separate variables that point to each word in your string if you that's what you want. Or you could only use one and loop through checking it at each step."
C_Programming,34v7zv,aZeex2ai,2,Mon May 4 21:39:49 2015 UTC,"your comment does very little to explain how strtok is behaving. i need two pointers that point two different positions (tokens) in the string. think of it like p = current and q = next. i'm using this so i can know just before i hit '\0' in the string.  for (p = strtok(s, "" ""); p != NULL; p = strtok(NULL, "" "")){     if((q = strtok(NULL, "" "")) != NULL){         printf(""%s "", rev(p));     }     else{         printf(""%s"", rev(p));     } } putchar('\n');   The purpose is to delete the trailing blank space at the end of the string. This causes the loop to skip every other token in the string."
C_Programming,34v7zv,technical_guy,2,Mon May 4 21:47:36 2015 UTC,"Sorry, I think you edited to clarify your question after I started replying. I see where your confusion is now. Your pointers would not point to the same thing. For example:  char *p; char *q; char    s[]=""hello world"";  p = strtok(s, "" ""); // p now points to the 'h' in hello q = strtok(NULL, "" ""); // q now points to the 'w' in world   strok is an ancient, bizarre little critter so your confusion is understandable. What a goofy way to implement a function that chops up a string.  edit: you changed your question after I started writing a reply again so none of your code was there when I wrote this."
C_Programming,34tes5,TheEngineerNerd,24,Mon May 4 12:23:55 2015 UTC,"The two languages are closely related with C++ being a direct descendent of C via way of ""C with Classes"", essentially just a series of additions to C.  This was eventually developed further and split off into its own language to become C++.    Today, the two have diverged substantially, especially with respect to the situations they tend to be used in, and what is considered ""good"" or ""proper"" coding style in each.  However, despite this divergence C remains almost a strict subset of C++ so it is possible to write C code and (as long as you avoid doing a few things) have it compile without issue using a C++ compiler.  The reverse is not true.  Short of restricting yourself to the subset of C++ that is also in C, you will not be able to compile C++ code using a C compiler.  That being said, modern C++ code looks substantially different than modern C code even though they share a similar past, as the language communities have developed very different philosphies.  C++ code will generally use a higher level of abstraction than C code.  You will often see C programmers much more willing to get down and dirty, so to speak, working at the bit and byte level, and performing manual memory management (although these can also come up in C++ as well).  C tends to be used for very low level projects: firmware, operating systems, embedded software, ect.  C++ is generally used at the application level on projects where performance is still desirable, but a higher level of abstraction is appreciated, such as video games and web browsers.  Which one you learn depends a lot on what you want to do.  If you're interested in getting down close to the hardware, or value a compact and comparatively simple language I would start with C.  If you want to get into application development or have no interest in low level software then definitely go with C++."
C_Programming,34tes5,panderingPenguin,11,Mon May 4 13:05:48 2015 UTC,"This is a really long answer because there's a lot of nuance in the situation; hopefully you will find some answers within.   The TLDR: They are effectively separate languages as used by their practitioners, and you won't really know one by learning the other even if some of the knowledge will transfer cleanly.  There are subsets of C and C++ that are essentially the same language. Their respective standards groups have compatibility between the languages as an explicit goal, though they are not perfectly synchronized so there tend to be places where new features have not been brought in from the other yet.  Many compiler suites provide C and C++ support via single compiler that switches how it works based on compile-time options. So, aside from a couple of assumptions in the type checking and symbol naming, the C-compatible subset of C++ compiles to machine code very much like what you would get by compiling that same code written as C via the C-mode compiler.  C has a mountain of legacy code in embedded systems, operating systems, etc. So its standard committee is very conservative in how they change the language, and compiler vendors are slow to move to newer versions. It's a very old language; all the ideas in C were well-developed in the 60s and the major distinction it has from its predecessors is a static type system and memory model that recognize the shift from word-oriented to byte-oriented addressing in the machines that the developers used. Look and feel and basic feature set were intentionally kept very close to B, which was in turn a mostly syntactic overhaul and simplification of BCPL, which was in itself a subset of CPL oriented towards machine-level bootstrapping of the CPL language at the University of Cambridge and University of London. The design of CPL itself started in 1963, based on the ideas in ALGOL 60 but aimed at a larger domain of programming areas.  C++ was an attempt to bring some newer ideas in programming languages (type-based abstraction, Simula-style objects, generic programming) to the C language. Because C structures are capable of encoding most compound data structures and can also contain references to code (via function pointers), the features of C++ were prototyped and initially implemented via a preprocessor to a C compiler.  The new features just expanded into a particular encoding in C structures. They still follow a similar implementation technique, though modern compilers may find better code for it due to knowing more about the intent.  Bjarne Stroustrup, the initial and primary designer of C++, used the design criteria that you shouldn't have to pay a runtime cost for features not used by your program as a guide for how he integrated features into C++ atop of the base C language. He also held compatibility with C as a strongly desired feature. These guides to the development of C++ are probably the source of both its wide acceptance and the sheer weight of books on the ""right way"" to code in C++. It's very much an ""a la carte language"", by design, but one must be tasteful about which features are used and how they are used together.  Because the extensions of C++ over C focus on abstraction, or the idea of writing programs that hide (hopefully) irrelevant details of how they work from other programs that call them, a programmer that learns C++ first may well feel lost as to how to build things in plain C, as these are precisely the details that are quickly abstracted away. However, highly experienced C++ programmers will most likely have learned exactly how C++ features translate to C (which is practically prerequisite to knowing which features one ought to use in C++ when designing a library or other system from scratch) and will find a shift to programming in C less daunting but perhaps more irritating than to the novice C++ programmer. It can be quite frustrating to have powerful, time-saving tools taken away, even if the same ends can be achieved through a manual encoding of the same techniques.  On the flip-side, an experienced C programmer will have a leg up on the novice C++ user in understanding the costs and benefits of various C++ features, but may be tempted to avoid hiding the sort of details they are used to working with. Experienced C programmers learn a distrust of opaque code bordering on the neurotic as a survival mechanism, so exploiting features that hide things is very difficult to motivate. This would lead to a rather stilted style of C++ code and grumbling from fully-converted C++ coworkers, though, which is perhaps why many in the C++ camp strongly advocate learning C++ first.  One must also keep in mind that although most of the features in C++ have been around in programming languages since the late 60s/early 70s, it's taken quite a while to work out how the underlying concepts fit together in the engineering of systems. A lot of early ""object-oriented"" work, especially once ""Object Oriented"" became a silver bullet buzzword in the industry, ended up chasing bad analogies and led to poorly designed systems as a result.  More recent approaches to designing programs in C++ take advantage of a rising level of understanding among practitioners of both object oriented design as well as alternative approaches such as functional programming and type-generic programming. C++ itself has also advanced at a much faster pace than C (for various reasons it hasn't been used as widely in areas that require really long-term support, like OS kernels, as C has, which makes its practitioners a tad bit less conservative in language extension) and so today's C++ is markedly different in style (if not substance) than that of 10-15 years ago.  To wrap it up: both C and C++ are widely used, but the features of C++ beyond C are of the sort that can have a huge effect on the style of programs and what you have to know to understand them at different levels. An intermediate user of either language, unfamiliar with the other, will likely see a typical example of the other as rather foreign. Expertise at either can be both helpful and detrimental towards learning the other, depending on the situation."
C_Programming,34tes5,pinealservo,8,Mon May 4 20:25:40 2015 UTC,"They are different languages. C++ builds on top of C, adding a ton of features, like classes and templates. In a way, this means that C++ is a ""better"" C, in another it doesn't. See this Linus rant (warning: strong/abusive language). In any case, the ways the languages are used are usually very different, and learning C++ won't necessarily teach you good C, though I'd argue that it would force you to learn the absolute basics.  There are some ways to exchange code written in the two languages, of which I'm not really knowledgeable about.  A Google search will probably help you discover more."
C_Programming,34tes5,phail3d,4,Mon May 4 12:33:05 2015 UTC,Ha I love Linus' attitude.
C_Programming,34tes5,Lobreeze,1 point,Mon May 4 14:30:15 2015 UTC,"Ahhh, I see!"
C_Programming,34tes5,wild-pointer,3,Mon May 4 13:05:16 2015 UTC,"C++ programmers tend to be embarrassed about their C origins, and what would be the right way to do things in C is often poor style in C++. It has several features to help you avoid making simple mistakes, and adds a few other convenient features. But this leads to one big difference between C and C++ which is that C++ code tends to be more over-engineered than the idiomatic C equivalent would be. The C++ language allows you to specify many details in the language itself, and it seems to be hard to know where to stop. For instance, I don't know if this is a joke or not: http://www.boost.org/doc/libs/1_57_0/libs/geometry/doc/html/geometry/design.html"
C_Programming,34tes5,w8cycle,1 point,Mon May 4 15:55:41 2015 UTC,"Wtf... that Boost lib is written so straight, but surely has to be trolling... so much code for so little benefit."
C_Programming,34tes5,maep,10,Mon May 4 23:38:40 2015 UTC,"What is the difference in the usage of C vs C++?   C tends to be use more by libs and low-level mission critical stuff such as kernels and embedded systems. C++ is used for more complex applications like browsers, games, or professional productivity tools.   Can C and C++ programs be interchanged, or are they separate languages?   They are separate languages but you can carefully write your code to be compiled as both C and C++   If I learn C++ would I know C?   No. Although some would disagree here. But you could pick up C a lot quicker than if you would start from scratch."
C_Programming,34tes5,bebe3000,0,Mon May 4 12:27:59 2015 UTC,Thank you!
C_Programming,34tes5,maep,-5,Mon May 4 12:32:44 2015 UTC,"I want to disagree with you. If you really want to learn C++ you pick up the fundamentals of C along the way. Some may say C is the subset of C++ after all.  My example: I wrote a network monitoring program with C libs, unions and bitfields, using only namespaces from the C++ features because this was all I need. Then I wrote my homework consisting of template metaprogramming and OOP. I think It's that simple but please show me a corner case when C++ can't help you."
C_Programming,34tes5,smikims,18,Mon May 4 14:06:35 2015 UTC,"For one, there is no good C++ support or even a compiler for some chips, like specialized DSP. If you have to build a toolchain for your custom chip C is a much easier target. It's almost trivial to write a C compiler. It took nearly 30 years for a standard compliant C++ compiler to appear.  In the strictest sense, C is not a subset of C++. There are a bunch of C constructs that won't compile as C++, such as implicit void* casts, variable length arrays, designated initializers and some others.   I think It's that simple but please show me a corner case when C++ can't help you.    I could turn this around and ask you for a corner case where C can't help you. It really ends up being a matter of personal preference. C++ forces me into a certain way of thinking which and i feel I constantly have to fight against. C code flows more naturally for me and I can spend more time pondering the problem instead of thinking about abstract implementation."
C_Programming,34tes5,Zardoz84,1 point,Mon May 4 14:49:13 2015 UTC,It took nearly 30 years for a standard compliant C++ compiler to appear.   It's only been standardized since 1998. By that measure you could say the same thing about C since it's been standardized since 1989 but has existed since the early '70s.
C_Programming,34tes5,bebe3000,-2,Tue May 12 02:12:07 2015 UTC,"In the strictest sense, C is not a subset of C++. There are a bunch of C constructs that won't compile as C++, such as implicit void* casts, variable length arrays, designated initializers and some others.   But you can write C code that can be compiled on a C++ compiler. I had a text adventure game, that Only need to add explicit casts to allow be compiled by g++ .  They share a common subset."
C_Programming,34tes5,DSMan195276,-7,Mon May 4 19:22:51 2015 UTC,"cross compilers for microcontrollers   of course C++ can't help you with that but your skills still matter very much in contrast to say, python   implicit void* casts   implicit casts? tell that to the guy who casts functions in C to void explicitly as a hint to the compiler   variable length arrays   you still have alloca. anyway, isn't it considered bad strategy?    designated initializers   I really liked it but it's just syntactic sugar.  Since I love C too, let's just settle on the evergreen ""right tool for the job"" phrase."
C_Programming,34tes5,Zardoz84,4,Mon May 4 16:57:56 2015 UTC,"Personally, I consider the two to hold a completely different mindset, given from the features both have.  C++ focuses on having a very large variety of features, basically having a bunch of features for every case, and then lets you pick what you think will work. I find that it's pretty common that lots of problems can be 'coerced' into using the C++ provided features for most of their usage, which simplifies things, but may lead to a more verbose/ugly solution.  C++ also has a mindset of hiding things from, and doing things for the programmer, in many ways as a safety net and in an attempt to make things easier to read. Thus, you get classes, overloads, constructors/destructors, etc. etc. The idea is that you use the language to handle a lot of the small things that you need done so the programmer doesn't have to think about them or even look at them.  C focuses on having a fairly small specific set of features - Those which are considered more 'fundamental' and thus allow you to build any extra features you'd like. To that end, for example C doesn't have a 'grow-able' array in it's standard library (C++ does), however it has the features to allow you to implement one fairly easy. This may be more work, but you can fit your usage more to your specific program at hand, which may let you do a more optimal implementation, or a simpler implementation (Or, of course, there's also the option of using something like glib, which is a separate library but provides extras similar to the C++ standard library).  Unlike C++, C takes the mindset of forcing the programmer to explicitly state what they want, and not hiding virtually anything. Ignoring usage of the preprocessor, which can change the meaning of virtually anything, If you see a statement like a + b in C, you know that this is just an addition of two integral variables (Say, ints, or pointers, etc..). Likewise, ignoring macros, the statement foo(2, 3) is a function call to the function foo, with two arguments. It does however mean that some things like files are less safe in C, because in C++ they have a destructor that can automatically close the file for you, vs. C where you have to explicitly call fclose.  I find that, for most people, C++ approach appeals to them more, however for me, I much refer the C approach. Obviously, with that in mind I'm biased. That said, I do know both, though I know C better."
C_Programming,34tes5,chefgroovy,2,Mon May 4 18:04:51 2015 UTC,"""C is the assembly for the Unix virtual machine.""  C++ on his origin, was a C with classes (POO), but It evolved to be more. Some one could say that it's like a kraken trying to touch and reach every programming paradigm. Both have his own strengths and weakness. But on C you could know (and you need to know) exactly what is doing your program. Also, I think that is a good language to learn programming because you learn what is doing exactly your code."
C_Programming,34tes5,Zardoz84,0,Mon May 4 19:11:34 2015 UTC,"I have to use both. As was mentioned, C is used for extreme low level stuff. Controller chips and the like.  I've yet to write a GUI in C, not really sure how I would start, unless Qt would handle it.  Maybe in Ncurse?  For what its worth, can use custom C functions in C++ fairly easily."
C_Programming,34tes5,chasesan,3,Mon May 4 15:31:22 2015 UTC,"I wrote GUI programs on C. With GTk+. The fact is that GTK+ is a C library. NCurses (and any *curses lib) is a C library for generate text mode GUIs with windows, buttons, dialogs, etc. Very nice to use."
C_Programming,34tes5,TehJohnny,2,Mon May 4 19:16:32 2015 UTC,I wrote a GUI in C using IUP. They make it pretty easy.
C_Programming,34tes5,1337Gandalf,1 point,Mon May 4 21:43:31 2015 UTC,"Why would writing UI code be any different besides having libraries developed for the specific language? Neither has GUI code in the standard, how could they? Like if I was writing a Win32 program I'd be using the same clunky Win32 API in either language."
C_Programming,34tes5,chasesan,-9,Tue May 5 01:25:16 2015 UTC,"They're almost exactly the same, C++ has classes which combines functions and structs, and there's vectors and other advanced shit, but for the most part (aside from the standard library, but C++ can use the C standard library anyway).  tl;dr they're like 90% compatible, and are basically the same."
C_Programming,34tes5,lhxtx,4,Mon May 4 19:18:44 2015 UTC,"You must be missing experience on one or the other. They have similar syntax, and one was based on the other about 30 years ago, and C++ allows the use of the C library (allowing compiling some C as C++)."
C_Programming,34vl8o,chickmagnet3,1 point,Mon May 4 22:41:05 2015 UTC,"To add the ""//////"" stuff you mean? Just paste it into your format string."
C_Programming,34vl8o,DontNeedNoThneed,1 point,Mon May 4 22:48:33 2015 UTC,that and strip the .bsp ending  thanks
C_Programming,34vl8o,DontNeedNoThneed,1 point,Mon May 4 22:52:01 2015 UTC,Some library on your system will have a function for that because it's such a common task. It'll be in the libraries provided by your OS because file naming conventions are platform specific. Or you can roll your own by starting at the end of the name and stepping back looking for the last period.
C_Programming,34vl8o,DontNeedNoThneed,1 point,Tue May 5 00:17:59 2015 UTC,"kinda what silver snurfer said but:  printf(""/////////////////////////////""); //x20 or whatever for (for loop  that goes through list(array of strings i assume?) {     printf(""// %15s//\n"", stringName);    //20 - 1(space) - 4(/) } printf(""////////////////////////////""); //again   kinda new to C and i've been doing java all day, but I'm somewhat certain this will left-align the names though, like in your picture.  edit: nvm not an array of strings, sounds like you got it sorted though"
C_Programming,34vl8o,fernando_69,1 point,Mon May 4 22:52:01 2015 UTC,okay but what string? and also how would i strip the .bsp ending?
C_Programming,34suwj,tmtwd,7,Mon May 4 07:22:46 2015 UTC,"Please don't write so much stuff in a single line, because it makes your code hard to read. Instead of this:  for( ;*s != '\0' ; *s = (*(p+i) = *(c2+i)), i++);   write something like this:  for( ;*s != '\0' ; i++){     *(p + i) = *(c2 + i);     *s = *(p + i); }   Try removing i while it is in this form, you'll find it much easier. Also, think about the loop you are using. Could you perhaps use while instead of for?"
C_Programming,34suwj,SeriousBug,2,Mon May 4 08:22:50 2015 UTC,"you are quite right, I will take this into consideration"
C_Programming,34suwj,raevnos,2,Mon May 4 08:27:36 2015 UTC,I don't think you can increment an array. Assign c2 to a pointer and try that.
C_Programming,34suwj,sftrabbit,4,Mon May 4 07:53:03 2015 UTC,That's the right answer. The issue is that the c2 in c2++ is implicitly converted to a pointer to the array's first element (array-to-pointer conversion) and so is an rvalue expression because the pointer is temporary. You can't increment a temporary value because there's nowhere to store the result of the increment.
C_Programming,34suwj,zuselegacy,1 point,Mon May 4 08:07:58 2015 UTC,cool
C_Programming,34suwj,sftrabbit,1 point,Mon May 4 08:16:35 2015 UTC,"not sure about the part of rvalue - array names are non modifiable lvalues hence incrementing is illegal, not because they are rvalues."
C_Programming,34suwj,benwaffle,2,Mon May 4 10:22:35 2015 UTC,"I think you're right. The array-to-pointer conversion would only even occur if the operator expected an rvalue operand, but the increment operator expects an lvalue. More specifically, the increment operator expects a modifiable lvalue, which an array is not (although I can't find the standard quote that specifically says that an expression denoting an array is a non-modifiable lvalue - I can only find a note at §8.3.4/5)."
C_Programming,34suwj,OldWolf2,2,Mon May 4 10:40:19 2015 UTC,That's one of the differences between pointers and arrays - you can't assign or increment an array
C_Programming,34rww2,jpereiramp,3,Mon May 4 01:09:18 2015 UTC,"If each symbol is two bits, then that means you have to pack four symbols into each byte.  Or in other words, you only output a byte for every four symbols.  You can only read or write whole bytes, you can't output groups of 2 bits.  Based on what you've written, you're trying to write to the file for every symbol, and that just can't possibly work.  There are a large number of ways you could write code to achieve that.  One example would be to write a function that takes four symbols, packs them into a byte, and then outputs that byte to a specified file handle.  Or you could do all the packing at once into a byte array and then only write the whole array at the end.  In either case, you'll have to add between zero and three padding symbols at the very end, because, again, you can only read and write whole bytes."
C_Programming,34rww2,Rhomboid,1 point,Mon May 4 01:18:21 2015 UTC,"Thanks for the help! I was able to make a function that returns an unsigned char (byte) and it's working 100% for every case!  Now, all that's left is to print the struct's data without padding between, for example, a char and an int, or a short and a char. What would be the best approach to remove the padding in the binary files ?   Thanks again!"
C_Programming,34rww2,Rhomboid,2,Mon May 4 02:09:15 2015 UTC,"Wait, you've completely changed the question.  Before you were asking about how to pack 2-bit symbols into a byte, and now you're talking about structs?  You don't want to use a struct for this, because you can't portably guarantee that there won't be any padding.  Various compilers have various non-standard ways of specifying that, but it's just the wrong way to do it.  Instead you should read an array of bytes and do whatever unpacking you need to do manually."
C_Programming,34rww2,FUZxxl,2,Mon May 4 02:39:13 2015 UTC,"If the output format is supposed to be portable, never attempt to write structures to files. You need to write some marshalling code to do that for you. Don't listen to people who suggest you to use #pragma pack, that pragma is unportable and leads to code that breaks on other platforms.  You can have a look at the memf function for an easy way to solve your problem. Or you can write the marshalling code yourself.  Assuming your external data representation is in network byte order (big endian) and you want first a four-octet quantity, then a two-octet quantity and finally a one-octet quantity, you can do something like this, assuming int has a size of at least four octets:  void marshall(const struct s *s, unsigned char buf[7]) {     buf[0] = (s->i1 >> 24) & 0xff;     buf[1] = (s->i1 >> 16) & 0xff;     buf[2] = (s->i1 >>  8) & 0xff;     buf[3] = (s->i1 >>  0) & 0xff;      buf[4] = (s->s1 >>  8) & 0xff;     buf[5] = (s->s1 >>  0) & 0xff;      buf[6] = (s->c1 >>  0) & 0xff; }"
C_Programming,34rww2,zenkibudo,2,Mon May 4 12:10:06 2015 UTC,"Many compilers align structs to fall on 8 byte (and other multiple of 2) boundaries by default.   They do that to speed processing, and the way they do that is by padding the struct with bytes where needed.    As a consequence, when writing those structs to binary files, that padding will be visible when viewing with the right kind of file viewer.    To avoid this, tell your compiler to align on a single-byte boundary.     Note:  i like what /u/FUZxxl said about avoiding writing structs directly, he's right you know.  But if your instructor/employer is forcing the issue, then check out your compiler's documentation for single-byte alignment to remedy this."
C_Programming,34rww2,FUZxxl,2,Tue May 5 00:37:17 2015 UTC,"Notice that it's not “many compilers” that do that, it's the platform's ABI that specifies where padding is to be introduced.  To turn off padding, employ #pragma pack, which is a common extension. Keep in mind that you need to turn the pragma off after you declared all the structures you need to be packed! This pragma may not work on architectures like MIPS, SPARC or old ARM chips that do not allow misaligned memory access. Some compilers emulate misaligned memory accesses for packed structs, but you should still never take a pointer to a member of such a structure."
C_Programming,34rd23,tmtwd,21,Sun May 3 22:12:12 2015 UTC,"You might want to allocate some memory for the char pointer to point to, before you copy data to the memory section the char pointer points to."
C_Programming,34rd23,necrophcodr,9,Sun May 3 22:25:17 2015 UTC,"strcat is going to write characters, starting with the nul at the end of the string t points to.  In your first example, t is uninitialized - i.e. points to who knows what. When strcat tries to use the uninitialized value of t as an address - boom.  Second example, t points to a valid string - which is probably located in the TEXT segment of your code. In this case, strcat can use t and find the nul at its end. But, then it will try to start modifying memory. Who knows what's there. It might be some other string literal. It might be read-only memory. Boom.  Third example, t points a valid string again, this time on the stack. Again, strcat can find the end - and, because you gave it a size of 20 chars, there's plenty of extra room after the null to hold the 5 new characters you're adding onto the end. That's why it works.  Fourth example, t points a valid string again, also on the stack. Again, strcat can find the end - but, since you didn't specify the size, t is only just big enough to hold the string you initialized it with (6 chars 5 + trailing nul). When strcat tries to write after the nul it's going to run into other parts of the stack. In this case, probably some padding and t2. In any event, it's writing where it's not supposed to.  In general, you have to make sure that t points to a valid string and that there's sufficient space allocated after t's terminating nul to hold the additional contents strcat is going to write.  Unlike some other languages, C forces you to worry about the details of memory allocation. This will take getting used to on your part. Much like if you learned to drive a car with automatic transmission and then tried to drive a car with manual transmission."
C_Programming,34rd23,HiramAbiff,1 point,Sun May 3 22:41:33 2015 UTC,"thanks, I read this answer carefully. I tried this:  char* t = ""tsrnesteirnt""; strcpy(t, ""hello"");   I left plenty of room after the t pointer for ""hello"", however there is still a bus error?"
C_Programming,34rd23,awwtowa,1 point,Sun May 3 23:09:20 2015 UTC,"dst is the first argument, not the 2nd, see man page.  I think because that is a string literal, the compiler optimized the allocation into a static one. So its actually allocated both t and t2 in read only memory space so you will get a segfault when trying to write to it. See this stack overflow about it  Good luck!"
C_Programming,34rd23,neilalexanderr,1 point,Mon May 4 13:30:19 2015 UTC,Probably it is a better idea to use strncpy and fixed buffer sizes/allocations instead of strcpy to reduce the chance of overflow?
C_Programming,34rd23,Betadel,1 point,Mon May 4 09:33:53 2015 UTC,strncpy doesn't add a terminating NUL character. So be careful.
C_Programming,34rd23,grable,6,Mon May 4 17:26:46 2015 UTC,"char *t = ""hello"";   When you write the above line you're using a kind of shorthand to tell the compiler to allocate an array of six chars and store hello in it. Further you're telling the compiler this array of chars you're asking it to make should be read only. You can't concatenate another string onto it for both those reasons: it's neither long enough to hold any more characters nor editable."
C_Programming,34rd23,grable,4,Sun May 3 22:37:06 2015 UTC,"Writing to string constants is usually a bad idea. And having enough room for the strings also helps.  char a[32]; strcpy( a, ""hello ""); strcat( a, ""world"");   or  char* a = ""hello ""; char* b = ""world""; char* x = malloc( strlen(a) + strlen(b) + 1); strcpy( x, a); strcat( x, b);   Note the use of strcpy before strcat. The reason for this is safety, because strcat will search for a zero terminator, causing problems with uninitialized storage."
C_Programming,34rd23,OldWolf2,3,Sun May 3 22:47:24 2015 UTC,"so anytime you use string literals, it is implicitly declared as const? and the +1 in the malloc is for the '\0' char?"
C_Programming,34rd23,Rhomboid,3,Sun May 3 22:51:31 2015 UTC,Yes
C_Programming,34rd23,Rhomboid,2,Mon May 4 02:28:46 2015 UTC,"ok, this is pretty clear :)"
C_Programming,34rd23,boredcircuits,3,Sun May 3 22:50:36 2015 UTC,"Regarding the following line: char *t = ""hello ""; :  Your title reveals a misunderstanding. The thing you are concatenating to is ""hello "". This is not a char *.  Nor is it contained in t, or owned by t.   t is a pointer which points to the first character of ""hello "". However ""hello "" already existed before t ever did, and will continue to go on existing after t dies. t and ""hello "" are completely separate objects, with the only relation being that t is set to point at the 'h' on its creation. t could be made to point elsewhere after that; in which case ""hello "" will still exist but just not be pointed at by t.  Once you understand this then it should be clear what the problem is."
C_Programming,34rd23,boredcircuits,1 point,Sun May 3 22:57:46 2015 UTC,interesting
C_Programming,34rd23,Fylwind,2,Sun May 3 23:09:46 2015 UTC,"In your first example, you've declared a pointer but you haven't assigned it to point to anything.  And now you're going to ask strcpy() to start writing to wherever that pointer points, which is undefined behavior.  How can you expect that to work?  In your second example, you are asking strcat() to try to write to a string constant.  String constants have type const char [n], which decays to a rvalue of type const char *.  You cannot modify string constants.  Even if you could, only enough memory to hold ""hello"" plus a nul terminator has been allocated, but you're asking strcat() to write stuff off the end past that, so this has no hope whatsoever of working, even on an implementation that doesn't store string literals in read-only memory.  The third example works because you allocated actual writable (non-const) arrays of char and provided sufficient space in them to hold the strings you're going to write.  Note that ""hello "" and ""world"" in your third example are not a string literals, they're array initializers.  That's a subtle distinction, but it's very important.  C lets you write what looks like a string literal there, but really you're providing the initial contents of those arrays, the same as if you'd written char t[20] = {'h', 'e', 'l', 'l', 'o', ' ', 0};.  (See footnote.) Because this array is not const, you are permitted to write to it, unlike the case above where the string literal (an array of const char) decayed to a pointer to const char.  Your fourth example fails because you didn't allocate enough space.  You are permitted to omit the size of an array if it's initialized with an initializer, in which case the size will be inferred from the initializer.  It's exactly as if you'd written:  char t[7] = ""hello ""; char t2[6] = ""world"";   When you ask strcat() to append to t, you're asking it to write out of bounds of the array.  That invokes undefined behavior, which means you have no guarantees about what the program will do next.  It could continue on and appear to work fine if there happened to be sufficient unused space adjacent to the end of that array.  Or it could crash immediately.  Or it could continue to run for a short while and then crash later.  In your example that's what happened, because your compiler has enabled stack smashing protection, which means that upon return from a function, code is inserted to check to see if a canary value that was put there previously is overwritten.  This indicates that the function that just returned has smashed its stack (i.e. overwritten out of bounds of some stack variable) and that is why the program terminates.  At all times you have to be mindful of what allocates memory and how much.  char *ptr allocates memory for a pointer, but not for anything for it to point to.  It is crucially important that you understand that whenever using strcpy() or strcat() or anything dealing with strings, you must know a) how much memory was allocated for the buffer you're using, b) how much of that space has already been used (in the case of concatenation), and c) how much space you're asking the function to write into the buffer.  The sum total of b) and c) must never exceed a), and you must always account for the plus one of the nul terminator in all of these sizes.  Footnote:  When dealing with array initializers, any members that don't have a corresponding initializer are zero-initialized, so that last zero (i.e. the nul-terminator) is not strictly necessary.  If it was not present, the rest of the array would have still been initialized to nuls.  However, I wanted to make the point that the length of the initializer includes a nul terminator, so that in the fourth example it would be clear why the implied sizes for t and t2 were 7 and 6.  (In other words, those arrays were initialized to contain a single nul terminator.)"
C_Programming,34r4ju,mickey_2011,7,Sun May 3 20:59:45 2015 UTC,"It's a fairly meaningless task, since indexing an array is just pointer arithmetic in disguise. Nonetheless, a[i] is equivalent to *((a) + (i)) - just use that rule to translate your code."
C_Programming,34r4ju,sftrabbit,1 point,Sun May 3 21:02:27 2015 UTC,"but do I need to have something like int *a ? and if yes, where would that go?"
C_Programming,34r4ju,sftrabbit,3,Sun May 3 21:06:24 2015 UTC,"Whenever you have int a[] as a function argument, that is actually treated as a pointer, so in these cases you could just replace it with int* a and it would be exactly the same. However, int a[N] should remain the same, because you still need to declare an array at this point."
C_Programming,34r4ju,sftrabbit,3,Sun May 3 21:55:20 2015 UTC,That's not true. An array and a pointer are different. It is only when used as a function argument type that an array is treated as a pointer.
C_Programming,34r4ju,SrPeixinho,1 point,Sun May 3 21:40:44 2015 UTC,"Woops. My memory failed me, then. Sorry. Please, post the correct answer though, don't just point the wrong. Op will be thankful. Thank you!"
C_Programming,34r4ju,zifyoip,1 point,Sun May 3 21:53:54 2015 UTC,Indeed.
C_Programming,34qhsj,figurelover,9,Sun May 3 17:45:29 2015 UTC,Looks like a homework assignment.
C_Programming,34rrxt,tmtwd,3,Mon May 4 00:24:43 2015 UTC,"The second part of a for line is not the end condition; it's the continuation condition, much like the condition in a while loop. So, the loop terminates when *s1 and *s2 are not equal."
C_Programming,34rrxt,Jack126Guy,3,Mon May 4 00:48:14 2015 UTC,"the end condition of the for loop would be met and the for loop would break, right?   No.  That's not how for loops work.  The loop continues as long as the condition is true.  If *s1 == *s2 is true for the first time through the loop (as in your example) then the loop continues, advancing both s1 and s2 forward to compare the next two corresponding characters and so on until a difference is found (or the nul terminator is found) at which point the loop stops."
C_Programming,34rrxt,Rhomboid,1 point,Mon May 4 00:50:45 2015 UTC,Okay thank you :)
C_Programming,34rrxt,Rhomboid,2,Mon May 4 00:57:32 2015 UTC,"I have no idea what you're asking.  Are you asking about the part after the opening parenthesis and before the first semicolon?  It contains nothing.  There is nothing to initialize, so there is nothing to put there.  Any of the three portions of the statement can be left empty, for example this is an infinite loop:  for(;;) {     ... }"
C_Programming,34rrxt,rollergo11,1 point,Mon May 4 01:01:32 2015 UTC,thanks :)
C_Programming,34rrxt,Rhomboid,1 point,Mon May 4 01:03:36 2015 UTC,Just discussing. I'm fairly new to this stuff. Wouldn't for( ;x == y; whatever) just be written as a do-while loop?
C_Programming,34rrxt,rollergo11,2,Mon May 4 02:22:25 2015 UTC,"You can write any kind of loop in terms of any other kind loop, more or less.  But if the ""whatever"" in your example is not empty, it usually makes more sense as a for loop than a while loop.  for(;foo;) would certainly be unidiomatic, though."
C_Programming,34rrxt,technical_guy,1 point,Mon May 4 02:35:28 2015 UTC,Oooh I see. Thank you kind stranger :)
C_Programming,34rrxt,ruertar,2,Mon May 4 02:37:49 2015 UTC,"Maybe adding a few comments and braces will help:   /* Behaviour - compare 2 strings and return -1 if left string is < right string, or + 1 if     left string is > rights string or 0 if they are the same */  int strcmp(const char *s1, const char *s2) {     /* loop while the characters pointed to by s1 and s2 are the same. If they are different         the for loop will end. Note we do the if statement inside the loop before we increment         the pointer positions on both strings. Also note if the first chars are different we wont         even enter the loop (because the char pointed to by *s1 wont equal the char pointed to        by *s2)     */     for ( ; *s1 == *s2; s1++, s2++) {         /* if *s1 is the end of string character then we have hit the end of string 1              without finding any difference between the 2 strings, so return 0        */         if (*s1 == '\0') {             return 0;         }      } /* end for loop */      /* if we fell out the loop it means the characters at *s1 and *s2 are different, so this return         statement just tries to point out which string was higher or lower and return a value based on         this.  Effectively we are just comparing ascii type values so A is lower than B    */     return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1); }   Note in the return statement we are saying:  variable = (condition) ? this value if condition is true : this value if condtion is false  so x = (1 ==2) ?  100 : 200;  would always set x= 200 because the condition is false.    The return in the strcmp above is testing the character at *s1 to the character at *s2, but it looks complex because it is first casting the value on both pointers to (unsigned char *).  This is just good defensive coding making sure we are comparing apples to apples.    Hopefully this helps you understand a little better."
C_Programming,34rrxt,ruertar,2,Wed May 6 08:25:41 2015 UTC,"This is a better way to do it IMHO.  int scmp(const char *s1, const char *s2) {   while (*s1 == *s2 && *s1 != '\0')     ++s1, ++s2;   return *s1 - *s2; }   Only one return statement, fewer branches, and it returns how different the differing characters are."
C_Programming,34s1mj,tmtwd,2,Mon May 4 01:53:36 2015 UTC,"No. So to break this down into smaller steps:  p is set to the address of the terminating zero of s1, by adding the number of characters. (This assumes that s1 is a properly terminated string).  The while loop actually breaks down sort of like this:  Write a character from memory pointed at by p, from the memory pointed at by s2, unconditionally  The pointers are both incremented after the copy is done  Then the while() condition is tested. The condition being tested is ""was the character we just copied non-zero?"" If so, we want to write at least one more character, either the next legitimate character in the string, or the terminating '\0' character.  So this is sort of confusing, because the standard idiom of a while loop is that the condition is tested to determine if it should execute the body of the loop. In other words, a while loop generally means a loop body can execute zero or more times, while a do loop will always execute at least one time.  But in this case the loop body is empty, no {}, just a semicolon indicating a ""null statement,"" and the condition tested is the result of an assignment, with two post-decrements. At least one copy is always done. The value at *p is not tested before being over-written.  The test will fail after the terminating zero as been copied from the second string to the first.  This is less confusing when you've read a lot of C code, since this is a ""standard idiom."" It is used in K&R as an example of how concise C can be.  Although, keep in mind, this implementation can go off and do unsafe, undefined things if the strings are not terminated correctly, if the pointers are not valid, if they overlap, etc. So in modern production code you would probably not want to use plain strca()t. There is strncat(), which takes a length and provides some additional protection, and strlcat(), which is not standard but is safer. Really the answer is that plain old strings in C are not safe unless the code very carefully manages all the things that can go wrong."
C_Programming,34s1mj,paulrpotts,1 point,Mon May 4 02:14:33 2015 UTC,"Ah, so it is kind of like saying: [C PSEUDOCODE]  char e; while(e = (*p++ = *s2++)){ if (e == '\0) break; }   or maybe that is all wrong   Thanks for your explanation :)"
C_Programming,34s1mj,paulrpotts,1 point,Mon May 4 02:20:53 2015 UTC,"Yeah, I think that is equivalent. It is also equivalent to  while ( 0 != ( *p++ = *s2++ ) );   Basically, in the condition of a while or an if, you're in a ""Boolean context,"" which causes the compiler to test for 0 as false, or != 0 (any value other than zero) as true.  I just edited my answer because I realized my version written as a do loop as not correct.   I wrote:  do {     *p++ = *s2++; } while ( *p != '\0' );   But that will not actually copy the terminating zero. You'd need an extra step:  do {     *p++ = *s2++; } while ( *p != '\0' );  *p = *s2;   Really, just about any other way to write it is less concise, although maybe clearer to people not used to idiomatic C."
C_Programming,34s1mj,Rhomboid,1 point,Mon May 4 02:29:30 2015 UTC,right - you are the real vip
C_Programming,34s1mj,paulrpotts,1 point,Mon May 4 02:32:22 2015 UTC,"#include <string.h> int main(){     char c[40] =  ""hello"";     const char* c2 = "" world"";     char* p = c + strlen(c);     do     {             *p++ = *c2++;     } while (*p != '\0');      *p = *c2;      printf(""%s\n"", c);     return 0; }   Actually, this doesn't seem to work - if prints ""hello w"". I think I need to init the value of p."
C_Programming,34s1mj,paulrpotts,2,Mon May 4 02:51:36 2015 UTC,"That's because it's wrong.  You're checking *p after it's been incremented, which means it's checking some value of c that hasn't been assigned to yet, just as you worried about originally.  In this case, every character in c[] except for the first five are initialized to nulls, which means the loop stops after one iteration (copying the ' ') and then the *p = *c2 copies the 'w', and then by sheer luck the string is nul-terminated after that because of the fact that it was initialized with all nuls due to providing an intializer shorter than its size.  But in general that won't be the case and this will go all haywire, reading potentially uninitialized data."
C_Programming,34s1mj,paulrpotts,1 point,Mon May 4 03:03:56 2015 UTC,"Yeah, sorry. See my correction. It's a good reminder that I should always test even seemingly trivial code. Especially when it's late and I'm tired..."
C_Programming,34r2lv,KozRoss,1 point,Sun May 3 20:43:33 2015 UTC,"Depends. Some libraries let you redefine their allocation functions, or you could configure the GC library to redefine malloc/free/etc."
C_Programming,34r2lv,raevnos,1 point,Sun May 3 21:31:06 2015 UTC,How would I configure GC to redefine malloc/free/etc?
C_Programming,34r2lv,raevnos,1 point,Sun May 3 22:02:16 2015 UTC,"It's an option when you build the library, iirc."
C_Programming,34rc1r,mickey_2011,2,Sun May 3 22:03:39 2015 UTC,"You just showed us your quick sort implementation - how did you manage to turn that into a ""proper program""? And a recursive function is one that calls itself."
C_Programming,34rc1r,sftrabbit,1 point,Sun May 3 22:18:19 2015 UTC,I put it in between this  include <stdio.h>  int main(void) {     //code here     return 0; }
C_Programming,34rc1r,necrophcodr,1 point,Sun May 3 22:19:59 2015 UTC,How do I make my program call itself?
C_Programming,34rc1r,necrophcodr,1 point,Sun May 3 22:20:37 2015 UTC,"You don't. You call a function that then, based on some decision, calls itself too. Example:  #include <stdio.h> int rec( int a ) {     if( a == 0 ) {         return a;     } else {         return rec( a - 1 );     } } int main( int argc, char **argv ) {     return rec( 5 ); }   The above example is a simple program that returns 0. It does so by calling the function int rec( int ), which will call itself with the integer parameter decreased by one until it is zero, and then return the result. Try to read it and understand why this is. You can run it through your head, or write down what the program is doing, until it exits."
C_Programming,34rc1r,hutcho66,1 point,Sun May 3 22:51:43 2015 UTC,"I know what recursive means now, and maybe I would be able to do it on any other program, but I simply cannot figure it out for this algorithm"
C_Programming,34rc1r,infey,1 point,Tue May 5 02:28:34 2015 UTC,"That is why you should try writing down every single step of the program. I don't mean the code, I mean writing down, in English (or whatever native tongue), what exactly is happening. For instance:    Program enters main. Call rec function with parameter 5. .... And so on."
C_Programming,34o6wr,1994mat,2,Sat May 2 23:47:02 2015 UTC,"You can call C functions from C++ code just fine and most C code is valid C++ code, too."
C_Programming,34o6wr,FUZxxl,1 point,Sun May 3 02:08:05 2015 UTC,"Changing the gcc from the makefile to g++ gives me errors, I once fixed all of these but some of them are in the .o files which I can't edit"
C_Programming,34o6wr,SantaCruzDad,4,Sun May 3 02:13:44 2015 UTC,"You don't need to do that - just compile .c files with gcc, compile .cpp files with g++, and link everything."
C_Programming,34o6wr,FUZxxl,1 point,Sun May 3 08:21:00 2015 UTC,The problem is that these gcc files are all pasted on the same line and I'm new to this.
C_Programming,34o6wr,FUZxxl,3,Sun May 3 16:28:54 2015 UTC,"You might need to slap extern ""C"" around declarations for symbols in the object file you can't change."
C_Programming,34o6wr,FUZxxl,1 point,Sun May 3 08:56:02 2015 UTC,"if I change the gcc to g++ I get several errors.  This was part of the errors that was easily fixable:   MMAL_PARAMETER_CAMERA_CONFIG_T cam_config =  {          { MMAL_PARAMETER_CAMERA_CONFIG, sizeof(cam_config) },          .max_stills_w = state->width,          .max_stills_h = state->height,          .stills_yuv422 = 0,          .one_shot_stills = 0,          .max_preview_video_w = state->width,          .max_preview_video_h = state->height,          .num_preview_video_frames = 3,          .stills_capture_circular_buffer_height = 0,          .fast_preview_resume = 0,          .use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RESET_STC }; mmal_port_parameter_set(camera->control, &cam_config.hdr);     The .max_stills_w lines said they were expecting a primary-expression before the . token, I had to remove those lines and set them afterwards  After fixing these errors I got even more in files that I couldn't edit anymore  EDIT: found the errors after editing the main file,   things I did to the main file to get this error:         added cv::Mat x;      added cv::cvtColor(cv::Mat(image), x, cv::COLOR_BGR2HSV);     (image is the original IplImage image you get with raspiCamCvQueryFrame(capture);)      Changed 3 methods to put text on ""&x"" instead of ""image"", and one that shows the image now has a cast     cvShowImage(""RaspiCamTest"", static_cast<CvArr*>(&x));    Compiling gives me this error:   pi@raspberrypi ~/git/robidouille/raspicam_cv $ make g++ -c -Wno-multichar -g -I/usr/include/opencv -  I/home/pi/git/userland/host_applications/linux/libs/bcm_host/include -  I/home/pi/git/userland/host_applications/linux/apps/raspicam -I/home/pi/git/userland -  I/home/pi/git/userland/interface/vcos/pthreads -I/home/pi/git/userland/interface/vmcs_host/linux -  I/home/pi/git/userland/interface/mmal  -MD RaspiCamCV.c -o objs/RaspiCamCV.o    RaspiCamCV.c: In function ‘MMAL_COMPONENT_T* create_camera_component(RASPIVID_STATE)’: RaspiCamCV.c:231:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:232:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:233:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:234:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:235:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:236:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:237:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:238:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:239:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c:240:8: error: expected primary-expression before ‘.’ token RaspiCamCV.c: In function ‘RaspiCamCvCapture raspiCamCvCreateCameraCapture2(int, RASPIVID_CONFIG*)’: RaspiCamCV.c:464:26: error: invalid conversion from ‘int’ to ‘MMAL_STATUS_T’ [-fpermissive] Makefile:45: recipe for target 'objs/RaspiCamCV.o' failed     This is easily fixable by changing the cam_config lines to   MMAL_PARAMETER_CAMERA_CONFIG_T cam_config =  {      { MMAL_PARAMETER_CAMERA_CONFIG, sizeof(cam_config) } }; cam_config.max_stills_w = state->width; cam_config.max_stills_h = state->height; cam_config.stills_yuv422 = 0; cam_config.one_shot_stills = 0; cam_config.max_preview_video_w = state->width; cam_config.max_preview_video_h = state->height; cam_config.num_preview_video_frames = 3; cam_config.stills_capture_circular_buffer_height = 0; cam_config.fast_preview_resume = 0; cam_config.use_stc_timestamp = MMAL_PARAM_TIMESTAMP_MODE_RESET_STC; mmal_port_parameter_set(camera->control, &cam_config.hdr);     as for the other error, just gotta cast it correctly   RaspiCamCV.c:464:26: error: invalid conversion from ‘int’ to ‘MMAL_STATUS_T’ [-fpermissive] MMAL_STATUS_T status = (MMAL_STATUS_T)-1;   And then the first g++ line compiles but I get this on the second g++:  g++  objs/RaspiCamTest.o libraspicamcv.a -lopencv_highgui -lopencv_core -lopencv_legacy -lopencv_video -lopencv_features2d -lopencv_calib3d -lopencv_imgproc -lpthread -lm -L/home/pi/git/userland/build/lib -lmmal_core -lmmutil -lvcos -lbcm_host -lX11 -lXext -lrt -lstdc++ -L. libraspicamcv.a -o raspicamtest   libraspicamcv.a(RaspiCamCV.o): In function default_status': /home/pi/git/robidouille/raspicam_cv/RaspiCamCV.c:126: undefined reference toraspicamcontrol_set_defaults(RASPICAM_CAMERA_PARAMETERS)' libraspicamcv.a(RaspiCamCV.o): In function create_camera_component': /home/pi/git/robidouille/raspicam_cv/RaspiCamCV.c:332: undefined reference toraspicamcontrol_set_all_parameters(MMAL_COMPONENT_T, RASPICAM_CAMERA_PARAMETERS const)' collect2: ld returned 1 exit status Makefile:57: recipe for target 'raspicamtest' failed make: ** [raspicamtest] Error 1"
C_Programming,34o6wr,Robotnik00,2,Sun May 3 17:17:17 2015 UTC,"Did you read my remark about slapping extern ""C"" up front the declarations of the offending symbols? It would be great if you could give me the source you're working with so I can have a look on my own."
C_Programming,34o6wr,Robotnik00,1 point,Sun May 3 17:24:32 2015 UTC,"Yes, but I have no idea which is offending or how to edit the flags since it's more of a script, the compiling lines are all formatted like this:   $(OBJS)/%.o: %.c     gcc -c $(CFLAGS) $< -o $@  the source is in the tutorial link"
C_Programming,34o6wr,Robotnik00,2,Sun May 3 17:48:24 2015 UTC,"You don't need to edit the makefile. See, the compiler complains it cannot find raspicamcontrol_set_defaults which seems to be declared in RaspiCamControl.h. Just slab extern ""C"" around that include directive:  extern ""C"" { #include ""RaspiCamControl.h"" }   and many of these issues should vanish. Proceed in a similar way with the remaining offending symbols."
C_Programming,34o6gm,jpereiramp,2,Sat May 2 23:42:02 2015 UTC,"This is an interesting assignment. I suspect that the compiler is actually going to screw you over (I'd be curious to know if this is noted in the assignment, but more on this below), but regardless the task isn't too daunting and I'm just going to ignore the issue that I'll note down below.  The first thing you need to check is are you supposed to be writing literal '1' and '0' characters to the file (Which I highly doubt) or are you actually just trying to write the bits for each of these pieces of data to the file? The first case does require some code to convert to a string, but with the second case you actually already have the data in a binary representation ('values' just points to some binary data which is the contents of the structure). You can literally just write what's contained at 'values' byte-by-byte to write the int's, short's, and char's to the file.  Do you have some type of format you're supposed to follow? That will greatly influence how you go about handling the file itself. In general, you're going to have a simple format that you follow for writing and read that information you described to and from the file. If reading the data back into a structure isn't a requirement then you can be a bit more liberal on your fileformat. Since you mentioned that 'c' is 01, 's' is 10, and 'i' is 11, I suspect you have some type of format to follow.  I would recommend first reading over the assignment again, looking to see if they have any tips or etc. on the file-format, write-out exactly how the file is supposed to be laid out - make a diagram that lists each entry in the file and how many bytes it will take. You will probably have variable length sections, make note of them and how they're laid out (IE. ""This section is a list of entries defined below. The number of them is defined above in entry 'blah', which entry each is, is defined above by entry 'blah2'"").  For example:  Len (bytes)   | Entry 4             | Number of entries (nentries) 4             | Number of extra entries (neentries) nentries * 4  | nentrie number of 4-byte integer values for foo neentries * 4 | neentrie number of 4-byte integer values for bar   Obviously that's just a random example, but I think that once you have that written out you'll have an easier time proceding with the assignment. Once you have this done, you'll want to start going one-by-one down the list and creating the file one piece at a time. You'll want to take a look at the 'f' functions to do this with a FILE. Specefically, fwrite will be of use to you, because it allows you to write a piece of data 'as binary' to a file. You could, for example, take an int and write it directly to a file as 4-bytes using fwrite, instead of just printing the digits like with fprintf.  And my note: If you try to write actual defined struct variables this way, you'll probably find it doesn't work. The compiler will insert ""padding"" bits into your struct to keep things aligned - For example, in general int's are 4-byte aligned. That means if you put a char and then an int, the char itself will only be 1 byte long, and then 3 extra bytes of empty space will be inserted so that the next int falls on a 4-byte boundary. I would probably recommend ignoring this unless your professor has actually mentioned something in the assignment or a lecture, etc. You can get around this by simply not using a struct and instead creating the 'values' buffer by hand. If your professor didn't say anything about this but shows test code sending the address of struct variables for the 'values' argument though, I'd ask him/her about it, as it might be something they overlooked."
C_Programming,34o6gm,DSMan195276,1 point,Sun May 3 06:47:25 2015 UTC,fwrite() should do what you want
C_Programming,34o6gm,dragon_wrangler,1 point,Sun May 3 00:14:54 2015 UTC,"You could start by working with this - displaying numbers in binary:  /*-------------------------------------------------------------------------      itoabin()      Convert an integer to binary-represented string   ---------------------------------------------------------------------------*/   char *itoabin(unsigned long num, char *string)   {   int iii,jjj=0, start_bit;   int size = 4; //for a 32 bit long - adjust for other types as needed        start_bit=(size<<3)-1;       for (iii=start_bit; iii >= 0; iii--)        {           if(iii && iii != start_bit && ((iii+1)%8) == 0) /* formatting - add space if desired */               string[jjj++] = 32;           string[jjj++] = ""01""[((num >> iii) & 0x1)];       }       string[jjj]='\0'; //cap it        return string;   }     //USAGE:   char buff[33];   puts(itoabin(1028, buff);"
C_Programming,34j2lk,Alyte,10,Fri May 1 16:01:59 2015 UTC,"An integer variable takes 4 bytes(which are sequential in memory), and a char variable takes 1 byte.  When you stored the address if 'hello_world' in x, you basically gave it the address of the start of the string(which is occupied by 'H'), which you then passed to 'adr'.  Since 'adr' holds the address of the integer, when you dereference it, the value you get would be the value of the byte you stored in 'adr'(which is 'H'), as well as the next three subsequent bytes('e', 'l', 'l'), because integers are 4 bytes long. Therefore, arr[0] now holds the chararcters h,e,l,l.  Now, when you print a string using a char array, it would print all the characters in the array(not quite sure, someone correct me if I'm wrong). As previously mentioned arr[0] = 'h','e','l','l', and arr[1] = '?', giving you 'hell?'."
C_Programming,34j2lk,Dihydrogen_Oxide,2,Fri May 1 16:19:53 2015 UTC,Why would it stop at 'l' and not run to '\0'.
C_Programming,34j2lk,f5f5f5f5f5f5f5f5f5f5,2,Fri May 1 16:23:17 2015 UTC,"Do you mean the printf or the storing the values in arr[0]?  the last character printf would print is '?'. As for the non-null terminated string, I would assume that he just got lucky and everything else in memory following array arr in memory is just zeros.  If you mean storing values in arr[0], it's because arr[0] stores a single integer, which is 4 bytes. Given that char's are 1 byte each, arr[0] would store the next four characters starting at the given address."
C_Programming,34j2lk,Dihydrogen_Oxide,11,Fri May 1 16:50:42 2015 UTC,"It's not luck, it's endianness. The x86 architecture is little-endian, so the lower bits of the '?' converted to an int are stored first, and the rest are zero. Check."
C_Programming,34j2lk,Jack126Guy,2,Fri May 1 16:58:27 2015 UTC,"AHH shit, that's good to know. Thanks!"
C_Programming,34j2lk,Dihydrogen_Oxide,1 point,Fri May 1 17:01:24 2015 UTC,I see it now
C_Programming,34j2lk,f5f5f5f5f5f5f5f5f5f5,9,Fri May 1 17:03:00 2015 UTC,Alternate title: Pointers are giving me hell
C_Programming,34j2lk,boarhog,1 point,Sat May 2 10:40:14 2015 UTC,If I was not a poor student you would have gold right now.
C_Programming,34j2lk,Lisu,3,Thu May 7 07:53:01 2015 UTC,"int arr[] = {1, '?'};   This allocates space for a couple of integers. The second integer is the converted value of the character '?'. If you're on a little endian machine then this means that the first byte of the second integer will be the same as the byte representing '?', and the second byte will be the same as a null terminator.  int main(void) {     char hello_world[] = ""Hello world!"";   This creates the source character data.      void *x;     x = &hello_world;     int *adr = (int*)x;   This just gets the address of the character data, but in a form so that it can be treated as though the memory contains ints instead of chars. Technically, accessing the memory using this pointer causes undefined behavior, but on x86 hardware you probably won't notice.  These three lines could be replaced with `void x = (int)&hello_world;      arr[0] = *adr;   This copies data from the place adr points into arr. adr points into the hello_world array, so it could be replaced with:  arr[0] = *(int*)&hello_world;   The data that's copied is the size of an int, which today is generally four bytes. These would be the four bytes representing ""Hell"" from the original array.  Of course remember that using this pointer this way is technically undefined behavior. Not that this is at all a good idea, but a better way to do the copy would be: memcpy(&arr[0], &hello_world[0], sizeof(int));.  Note that this now means the first four bytes of arr are the same as ""Hell"". And on a little endian machine, the next bytes are ""?"" followed by a null terminator. This is a C string, if the memory is interpreted as an array of char.      printf(""%s\n"", (char*)&arr[0]); }   This line simply treats arr as an array of char and prints it. Meaning the C string created in the previous line is printed.  On a little endian machine with four byte ints you get ""Hell?"". On a big endian machine with four byte ints you'd get ""Hell"". On a little endian machine with two byte ints you'd get ""He?"". On a big endian machine with two byte ints you'd get ""He"".  After fixing the obfuscation, this is what the program should look like:  #include <string.h>  int arr[] = {1, '?'};  int main(void) {     char hello_world[] = ""Hello world!"";     memcpy(&arr[0], &hello_world[0], sizeof(int));     printf(""%s\n"", (char*)&arr[0]); }"
C_Programming,34kqnc,tmtwd,11,Sat May 2 00:27:19 2015 UTC,"String constants in C are usually put in read-only memory, hence the segfault."
C_Programming,34kqnc,grable,1 point,Sat May 2 02:11:07 2015 UTC,Is that compiler implementation specific?
C_Programming,34kqnc,s1337m,2,Sat May 2 17:32:11 2015 UTC,"Yes. As far as i know writing to string constants is undefined behavior, so the compiler can do whatever it wants."
C_Programming,34kqnc,grable,4,Sat May 2 20:27:16 2015 UTC,"The third line does not compile because (*s) is a char. The ++ simply returns the same (*s) (but increments the value), so it is still a char, not a char*. The second line works because you are casting.  By the way, you shouldn't assign a literal string such as ""h"" to a char*. It should be assigned to a const char*, assigned to an array, or strcpy-ed to dynamic memory."
C_Programming,34kqnc,Jack126Guy,1 point,Sat May 2 00:43:44 2015 UTC,"The third line does not compile because (s) is a char. The ++ simply returns the same (s) (but increments the value), so it is still a char, not a char*. The second line works because you are casting.   the second line DOESN'T WORK"
C_Programming,34kqnc,Jack126Guy,2,Sat May 2 00:50:07 2015 UTC,"Eh? I'm sure it's unsafe, but it still compiles for me (with a warning, of course)."
C_Programming,34kqnc,Jack126Guy,1 point,Sat May 2 00:51:35 2015 UTC,"char* s = ""h""; //char* t = (char)(s)++;    ah , it compiles but there is a seg fault"
C_Programming,34kqnc,WetwareDefect,5,Sat May 2 00:56:33 2015 UTC,"Yes, if you try using whatever t points to (such as puts(t)), you would get a segfault, because t points to the memory location 0x00000068 (""h"" has an ASCII value of 0x68), which is probably invalid/not owned by your program."
C_Programming,34kqnc,an_original_username,4,Sat May 2 01:01:58 2015 UTC,"This always fails     (*s)++;  Because s points to a string literal (stored in an area of read-only memory) and you're trying to modify it by incrementing it.   What is it that you're trying to achieve?  Do you want t to point to a copy of the contents of s but incremented by 1?  Heres a long form of what I think your trying to do. I don't think it can be done in a single line declaration as you can't deference a pointer while declaring it (afaik).  char* s = ""h"";  //s points to readonly string literal char* t = malloc(sizeof(char)); //alloc a char for t to point to *t = *s + 1;    //add 1 to char pointed to by s and assign result to location pointed by t  printf(""*s == \'%c\', *t == \'%c\'\n"", *s, *t); printf(""s == 0x%08x, t == 0x%08x\n"", (int)s, (int)t);   The output is:  *s == 'h', *t == 'i' s == 0x08048560, t == 0x08549008"
C_Programming,34kqnc,Zephyron51,1 point,Sat May 2 10:41:44 2015 UTC,interesting. When I get the chance I will put this through the compiler.
C_Programming,34kqnc,karesx,2,Sun May 3 07:44:11 2015 UTC,"Neither of these work (line 1 works, but 2 and three don't compile).  Why not? I checked google, but the results related to a different problem.  char* s = ""h"";     //char* t = (char)(s)++;      char* t = (*s)++;     EDIT:  in fact, even this gives a seg fault, why is this?    char* s = ""h"";  (*s)++;   When dealing with pointers like this,  be aware of the actual memory the program has asked for.   Line 1 declares a pointer type named s, which is machine word dependent; it  also declares a read only single byte for 'h'; a const char type . Where the compiler puts 'h' is only important if you want to determine how it will fail, and not why it fails.  The value of the pointer s is the address for the memory location that the compiler placed 'h'. Line 2 declares a pointer t. t is initialized with the value s points to,  plus one.  Dereferencing s gives the ascii value of 'h'; it is then incremented, which is the ascii value for 'i';this value is then cast to a pointer type. So t has the value 'h'. Since t is a pointer, the value is a location in memory.  The program has not requested the memory location that t has the value of. If you don't have access to that location, dereferencing the pointer will cause problems.  The segfault is because you tried to change the read only memory location where 'h' was placed."
C_Programming,34kqnc,rnsanchez,3,Sun May 3 04:01:16 2015 UTC,"Okay, wait....  char* s = ""h"";   Lemme confirm, you want to set a variable (which is a character) to the letter 'h', and then you want the pointer of that? Because that's not what's happening - right now, you're making a variable (which is a pointer to a character) which holds 'h' (translated into some random number).  Perhaps you want this?  char r = 'h'; char* s = &r;     I think I understand now; I completely didn't realize you wanted a string (I haven't played around with strings for months for some weird reason). You aren't allowed to modify strings, hence why they're called ""immutable"". Unfortunate, but it's just one of the properties of strings. Characters ARE mutable, which is why my example worked."
C_Programming,34kqnc,rnsanchez,2,Sat May 2 08:25:14 2015 UTC,"or just char s[] = ""h"";"
C_Programming,34k84t,downiedowndown,3,Fri May 1 21:38:13 2015 UTC,"At the end of read_string I see:  if(*out_string) { free(*out_string); }   You're always freeing the buffer holding the string you just read - the caller gets back a pointer to free'd memory.  As an aside, I find it odd that read_string allocates the buffer. I'd expect the caller of read_string to pass in the buffer and read_string just fills it in."
C_Programming,34k84t,HiramAbiff,1 point,Sat May 2 00:22:05 2015 UTC,"This was it! Thank you so much now the 'name_string' is allocated a place in the HEAP in the main, and free'd in the main too.  So much easier to follow the code now too."
C_Programming,34fww6,chickmagnet3,6,Thu Apr 30 20:28:27 2015 UTC,"You can combine the printf statements for readbility, something like this :      printf(""This is an example\n""            ""of how to simply\n""            ""your menu"");"
C_Programming,34fww6,studioidefix,1 point,Thu Apr 30 21:40:03 2015 UTC,"Could also use puts() if he doesn't need any formatting, though puts does newline after everything."
C_Programming,34fww6,TehJohnny,1 point,Mon May 4 12:42:45 2015 UTC,"The idea is top combine the print calls, so you could use puts and one less newline just as well, it's the combining calls that's key though"
C_Programming,34fww6,studioidefix,5,Mon May 4 17:30:57 2015 UTC,This seems like it'd be much better suited for a batch/bash script...
C_Programming,34fww6,OrderZero,7,Thu Apr 30 23:36:48 2015 UTC,its a C version of my python script I just did this because why not :)
C_Programming,34fww6,bucaran,4,Thu Apr 30 23:52:05 2015 UTC,Nice. Good job!
C_Programming,34fww6,Jack126Guy,2,Fri May 1 01:13:13 2015 UTC,Thanks!
C_Programming,34fww6,DSMan195276,3,Fri May 1 01:26:25 2015 UTC,"If you're not using any format arguments, why not use puts instead of printf?"
C_Programming,34fww6,tmtwd,6,Fri May 1 00:22:19 2015 UTC,"Your argument still stands, I personally wouldn't say one is inherently easier to read then the other but that's just my opinion, but as a note compilers like gcc will actually optimize printf statements that only print a single string along with a ending \n into puts statements for you."
C_Programming,34fww6,DSMan195276,1 point,Fri May 1 00:30:27 2015 UTC,puts is nicer to read!
C_Programming,34fww6,neuralnoise,4,Fri May 1 03:38:07 2015 UTC,"To each their own, personally I prefer using printf(""string\n""); because it's consistent with everything else. I tend to forget that puts includes an extra \n (Admittedly because I don't usually use it), and I usually end-up adding format information to my printf statements anyway."
C_Programming,34fww6,DSMan195276,1 point,Fri May 1 04:13:17 2015 UTC,ah yes spelling is important!
C_Programming,34fww6,studioidefix,3,Fri May 1 00:41:47 2015 UTC,"Just a heads up, you say quit is choice 0 but then later on you use check for choice 4. It should be one or the other."
C_Programming,34fww6,chenshuiluke,2,Fri May 1 05:38:17 2015 UTC,"Overall I think it's good. There's a few things here or there I'd personally do different, but how you did it is perfectly readable.  The only thing i have a hard time reading is the case statement really. Personally, I'd really advocate not putting a statement on the same line as the case statement, and also at the very least put a blank line between the last break and the next case. Something like this:  switch (choice) {     case 1:         info();         break;      case 2:         Snapchat();         break;      case 3:         Unlock();         break;      case 4:         printf(""Quitting program!\n"");         exit(0);         break;      default:         printf(""Invalid choice!\n"");         break; }   This is definitely a bit wordier, but personally I think it's much easier to read when there's more spacing and the code is indented directly below the case. Some of the less important things you could get away with leaving, like not indenting the break. I think that having stuff like break, case, and exit(0) all in line with each-other without any spacing in-between makes it very hard to read what's actually happening though."
C_Programming,34fww6,AlpineCoder,1 point,Fri May 1 01:33:26 2015 UTC,"Oh definitely use case dependent. Try sending kernel patches without switch and case on the same level, much yelling will ensue."
C_Programming,34fww6,zenkibudo,1 point,Fri May 1 05:22:44 2015 UTC,"Personally, i think the code is well organized and easy to read. I'm unsure about that extra semicolon on line 97, so I'll just assumed you're using it for the sake of NOP. The only thing I can suggest is checking the return value of system(), but that would make the program more complicated :P"
C_Programming,34fww6,FUZxxl,1 point,Thu Apr 30 20:43:08 2015 UTC,Okay thanks! but Sleep(); or sleep(); is not working but the quit on line 101 is not working... any ideas?  Edit: got Sleep working!
C_Programming,34fww6,FUZxxl,1 point,Thu Apr 30 20:54:43 2015 UTC,I think you prototyped it as qiut(void) but declared it quit(void).
C_Programming,34efc7,gauravgupta,3,Thu Apr 30 13:55:13 2015 UTC,"thenewboston? Ive said it before and ill say it again, he is not a good teacher at all. He is inconsistent, and awful at explaining non-trivial things. People get hooked on his tutorials because the first few are easy enough, then he gets to classes and objects and all the other abstract things in programming and he degrades to a ""just do what i do and youll get it"" kind of teacher.  The best way I can recommend is a book. I still find them unmatched in terms of going through anything thoroughly. Tutorials are often made by people who do it on their free time, therefore they have little incentive to make a good one, whereas if you write a shitty book, it just wont sell, simple as that."
C_Programming,34efc7,Monkey-Maker,2,Fri May 1 00:25:29 2015 UTC,Harvard's CS50
C_Programming,34efc7,gordonv,1 point,Thu Apr 30 22:36:42 2015 UTC,Where do you go to find the CS50 class? I have looked around the site but cant find the place to actually start.
C_Programming,34efc7,_gh0st_,1 point,Thu Apr 30 23:41:28 2015 UTC,edx.org - then sign up for CS50. :)
C_Programming,34efc7,gordonv,2,Thu Apr 30 23:48:10 2015 UTC,Thanks!
C_Programming,34efc7,_gh0st_,2,Thu Apr 30 23:48:28 2015 UTC,"Also, check out reddit.com/r/cs50 . Very awesome sub"
C_Programming,34f2uc,Hitch_en,2,Thu Apr 30 16:48:39 2015 UTC,"I haven't used SDL before, but I think this tutorial is what you are looking for."
C_Programming,34f2uc,ezrik1414,1 point,Thu Apr 30 17:29:45 2015 UTC,"I have looked through that tutorial and unfortunately it hasn't really helped. My program needs to print the string character by character, down a line, then character by character and so on as it goes through two a loops. That tutorial helps for just simply printing a line of test to an SDL window, thanks for your help anyway though dude."
C_Programming,34f2uc,SeriousBug,2,Thu Apr 30 17:34:36 2015 UTC,SDL uses SDL_ttf for text. You can use it to render text onto surfaces.  Is there a specific reason why you want SDL? You could just do this on the console with something like ncurses or PDCurses.
C_Programming,34f2uc,SeriousBug,1 point,Thu Apr 30 17:41:29 2015 UTC,"The assignment requires use of SDL for whatever reason. I have SDL_TTF in use and I know how it works, it's how I can make it render just a single character from an array multiple times on one line with a set spacing in between each one I'm stuck on."
C_Programming,34f2uc,Zange_F,3,Thu Apr 30 17:47:18 2015 UTC,"I think what you are looking for is these functions:  From SDL_ttf, TTF_RenderText_Solid, just call this with a one character string to create a surface of that character.  From SDL, SDL_CreateTextureFromSurface to turn the character surface into a texture.  Again from SDL, SDL_RenderCopy to actually render the character. Note the dstrect argument, it picks where the character is actually rendered at. See SDL_Rect, you can simply create a rectangle, and change the x and y coordinates between the render calls."
C_Programming,34ekk5,psion1369,11,Thu Apr 30 14:36:19 2015 UTC,"if(input == ""w"")   input is a char. You're comparing it to a string. Try 'w'"
C_Programming,34ekk5,dragon_wrangler,4,Thu Apr 30 14:42:07 2015 UTC,You're comparing it to a string.   Even worse: He's comparing it to a pointer. I'm surprised the compiler isn't emitting any warnings that would've helped him figure out the problem on his own.
C_Programming,34ekk5,Spire,3,Thu Apr 30 17:23:25 2015 UTC,"Good point, gcc 4.4.3 with just the default warnings shows ""warning: comparison between pointer and integer"" on that line."
C_Programming,34ekk5,dragon_wrangler,1 point,Thu Apr 30 17:31:22 2015 UTC,(A string literal is a const char *.)
C_Programming,34ekk5,Chooquaeno,2,Thu Apr 30 18:31:17 2015 UTC,"No! It's not. A string literal has type char[n] where n is the length of the string including a trailing \0 byte. There isn't even a const qualifier, although the literal should be used as a pointer to const data."
C_Programming,34cuo2,Mines_of_Moria,2,Thu Apr 30 03:08:04 2015 UTC,"This prints   x=1234567 y=ffffffff    No, it doesn't.  It might print  x=ff y=ff   or it might print  x=ffffffff y=ffffffff   but it certainly does not print x=1234567.  The type char is equivalent to either signed char or unsigned char. This is implementation-defined.  If char is equivalent to signed char, then the value of y will be −1, so the value of x will be −1, which is represented as 0xffffffff in two's complement representation. When a char value is passed as a variadic argument to a function (like printf), the integer promotions are applied, which converts the char value to a value of type int. That's why you'll see x=ffffffff and y=ffffffff.  On the other hand, if char is equivalent to unsigned char, then the value of y will be 255, so the value of x will be 255, so you will see x=ff and y=ff."
C_Programming,34cuo2,zifyoip,1 point,Thu Apr 30 03:18:56 2015 UTC,"I edited my post, I wrote the wrong thing at first. Thanks, that's enlightening. These slides i'm looking at certainly make it seem like x should be something different.   https://imgur.com/uwn9TbW.jpg"
C_Programming,34cuo2,zifyoip,1 point,Thu Apr 30 03:25:59 2015 UTC,"Well, fine, but did you read the rest of my comment in which I explain what is going on?"
C_Programming,34cuo2,zifyoip,1 point,Thu Apr 30 03:28:41 2015 UTC,"Yes, makes sense. Thanks. I don't think I have any questions, but if that changes I'll let you know. Did you see the slide I put up?  edit: wait, so x is only ff? it's 4 bytes, so is the rest 0x012345ff?"
C_Programming,34cuo2,zifyoip,2,Thu Apr 30 03:36:30 2015 UTC,"No, the value of y is either −1 or 255, and that value is assigned to x, so the value of x is either −1 or 255."
C_Programming,34cuo2,zifyoip,1 point,Thu Apr 30 03:42:47 2015 UTC,What happens to the other bytes in x if y is 255?
C_Programming,34cuo2,zifyoip,3,Thu Apr 30 03:49:55 2015 UTC,"When you assign a value to an int, you are assigning a value to the whole int, not just some little piece of it.  If you assign the value 255 to x, then you are assigning the value 0x000000ff to x, because the value 255 is represented as 0x000000ff in a 32-bit int."
C_Programming,34cuo2,zifyoip,1 point,Thu Apr 30 03:52:27 2015 UTC,"Okay, so is it accurate to say that when you have something like x=y, where one of the variables is a char and the other is an int, that  they will cast to the larger size, being the integer? So then char becomes 0x000000ff if unsigned?"
C_Programming,34cuo2,zifyoip,3,Thu Apr 30 03:58:54 2015 UTC,"The value is always cast to the target type. If you think about it, you'll see that it has to be that way. That's the only behavior that makes sense. The value of the target variable is always of the target type, so it's going to be a value of the target type after the assignment, so how is the assignment going to make sense unless the assigned value is cast to the target type?  char c = 20; int i = 100; long L = 1234567890; float f = 456.789f; double d = 987654.321;  i = c;  /* value of c cast to int */ i = L;  /* value of L cast to int */ i = f;  /* value of f cast to int */ i = d;  /* value of d cast to int */ c = i;  /* value of i cast to char */ d = L;  /* value of L cast to double */ L = f;  /* value of f cast to long */ f = d;  /* value of d cast to float */ d = f;  /* value of f cast to double */"
C_Programming,34cpqr,jlan90,2,Thu Apr 30 02:26:34 2015 UTC,"There are problems with your current code (where you have listen(), , no handling of SIGCHLD, etc.) I'd fix first, but basically yes.  W. Richard Stevens' classic Unix Network Programming would be worth looking at."
C_Programming,34cpqr,raevnos,1 point,Thu Apr 30 02:51:06 2015 UTC,Im not sure if im just missing something but what is the error in this code. this code runs fine and opens the image file fine. Also if i wanted to send it a mp3 file instead of an image how would i do that?
C_Programming,34cpqr,ahminus,3,Thu Apr 30 03:50:18 2015 UTC,"This has nothing to do with the discussion, but ""this code runs fine"" does not mean the code is fine.  It means you haven't yet produced the conditions under which it will fail.  ""This code runs fine"" is a bad way to think about whether your code contains errors and/or bugs."
C_Programming,34cpqr,raevnos,2,Thu Apr 30 18:09:48 2015 UTC,"You only need to call listen() once, not every time through the loop. It's like bind() that way. You never touch Connect_Count so there's no limit on how many processes are running at once You never reap the child processes when they exit so eventually the host's process table fills up with zombies. You don't fclose() F, though that's not a huge deal since that process exits anyways, but it will be an issue with threads You don't do any verification of the file before opening (What if I ask for /etc/passwd?), which again isn't a huge deal in a toy web server that's only going to bind to localhost, but if you're ever going to expose it to the internet at large is a must. It's a web server. Files are files. Data is sent the same way, but the Content-Type header needs to change for different data. /etc/mime.types on linux has a huge list of content type and file extension mappings, or you could roll your own."
C_Programming,34cpqr,raevnos,1 point,Thu Apr 30 04:05:37 2015 UTC,Thank you for the fixes! So if i run an mp3 through the current code would it work just be labeled incorrectly in the Content type header?
C_Programming,34cpqr,raevnos,1 point,Thu Apr 30 04:23:20 2015 UTC,"Your browser wouldn't be very happy when it tries to treat a mp3 as if it was a jpeg, but yes."
C_Programming,34cpqr,raevnos,1 point,Thu Apr 30 04:25:38 2015 UTC,even if i were to run it with localhost:port/SongName.mp3 it would still treat it as jpeg?
C_Programming,34cpqr,w8cycle,2,Thu Apr 30 04:30:06 2015 UTC,That's what the server is telling the browser that the data it's getting is supposed to be.
C_Programming,34cpqr,tmtwd,1 point,Thu Apr 30 04:31:38 2015 UTC,Sorry if these questions are stupid/obvious but why is that?
C_Programming,34d1hl,meatwadd667,3,Thu Apr 30 04:09:27 2015 UTC,Can you please put four spaces in front of every line of code so the code comes out readable? It says so for a reason in the submission text.
C_Programming,34d1hl,FUZxxl,2,Thu Apr 30 09:22:14 2015 UTC,"Re-posted for clarity.  THIS IS NOT MY CODE  // CSCI 112 include <stdio.h>  include <stdlib.h>  include <time.h>  include <string.h>  define NUM_RANKS 13  define MAXPLAYERS 4  define MAXCHAR 40  define MAXGAMES 11  define MAXCARD 5  char deal(); int num_players = 0; int totalChips = 0; int betChips(int totalChips); int main(void) { // declaration char player[MAXPLAYERS][MAXCHAR] = { 0 };  char playerCard[MAXPLAYERS][MAXCARD] = { 0 };  int playerHand[MAXPLAYERS] = { 0 };  int playerChip[MAXPLAYERS] = { 0 };  int playerBet[MAXPLAYERS] = { 0 };  int card = 0;  int winnerTotal = 0;  int winner = 0;  int totalbet = 0;  int PLayerChipTotal = 0;  const char rank_code[] = { '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' };  const char cardValue[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 10 };  srand((unsigned)time(NULL));  printf(""Enter number of players: ""); scanf(""%d"", &num_players); fflush(stdin);  for (int i = 0; i < num_players; i++) {     printf(""Enter the players name: "");     gets(player[i]);     printf(""Enter number of chips: "");     scanf(""%d"", &playerChip[i]);     fflush(stdin); } for (int igame = 1; igame < MAXGAMES; igame++) //loop over each round {     for (int icard = 0; icard < MAXCARD; icard++) // loop over each hand     {         for (int iplayer = 0; iplayer < num_players; iplayer++)         {             card = deal();             playerCard[iplayer][icard] = rank_code[card];             playerHand[iplayer] += (int)cardValue[card];         }     }// end loop of cards each hand     for (int ihand = 0; ihand < num_players; ihand++) //display the players's hands     {         printf(""\n%s has: "", player[ihand]);         for (int icards = 0; icards < MAXCARD; icards++)         {             printf(""%c"", playerCard[ihand][icards]);         }     }     for (int iplayer = 0; iplayer < num_players; iplayer++) //place player bets     {         playerBet[iplayer] = betChips(playerChip[iplayer]);         totalbet += playerBet[iplayer];     }     // who is the winner the one with the highest playerHand[] value     winnerTotal = playerHand[0];     winner = 0;      for (int iplayer = 1; iplayer < num_players; iplayer++)     {         if (winnerTotal < playerHand[iplayer])         {             winner = iplayer;             winnerTotal = playerHand[iplayer];         }     }     // recalulate the chip winner get all     for (int iplayer = 0; iplayer < num_players; iplayer++)     {         if (iplayer == winner)             playerChip[iplayer] = totalbet - playerBet[iplayer];         else             playerChip[iplayer] -= playerBet[iplayer];     }     printf(""\n\nRound %d winner is %s with %d points and won %d chips.\n\n"", igame, player[winner], winnerTotal, totalbet); // winner is player[winner]     printf(""\n------------------------------------------------------------------\n"");     playerHand[0] = { 0 };     playerHand[1] = { 0 };     playerHand[2] = { 0 };     playerHand[3] = { 0 };     totalbet = 0; } //print out overall winner PLayerChipTotal = playerChip[0]; winner = 0; for (int iplayer = 1; iplayer < num_players; iplayer++) {     if (PLayerChipTotal < playerChip[iplayer])         winner = iplayer; } printf(""\n\nThe winner is %s with a grand total of %d chips\n\n"", player[winner], playerChip[winner]); return (0); } // end main() char deal() { int num_cards; int rank;  const char rank_code[] = { '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A' };  rank = rand() % NUM_RANKS; // picks a random rank  return rank; } int betChips(int totalChips) { int chips = 0; chips = totalChips / 10;  if (chips == 0)      chips = 1;  chips = rand() % chips;  return (chips); }"
C_Programming,34d1hl,ruertar,1 point,Thu Apr 30 12:02:05 2015 UTC,"Try printing out each player's bet and chip count after each round so you can at least see what's happening.      if (iplayer == winner)         playerChip[iplayer] = totalbet - playerBet[iplayer];   You might have an issue here. If you have three players who each bet their max in the first round, two of the players will end up with 90 chips, but the winner will end up with 20 chips. You might want += instead of ="
C_Programming,34d1hl,dragon_wrangler,2,Thu Apr 30 15:40:16 2015 UTC,That was it! Thank you so much. And I apologize about the spacing issue when I originally posted this. It appeared fine on my page however now I see that It caused issues. Anyways now the code is working perfectly.
C_Programming,34d1hl,aZeex2ai,1 point,Thu Apr 30 23:43:49 2015 UTC,"Now that your code works perfectly, what happens when you input a player name that is longer than the size of your players array?  I would expect a segmentation fault. This is because gets will happily write past the end of the buffer and into memory that it shouldn't.  To prevent writing buffer overflow vulnerabilities, use fgets instead."
C_Programming,34d1hl,Mines_of_Moria,1 point,Fri May 1 17:16:13 2015 UTC,"He should get a deprecation message when compiling a program using gets() with GCC, iirc"
C_Programming,34ajv3,LiquidClimber,2,Wed Apr 29 16:42:38 2015 UTC,"""return makes integer from pointer without cast"".    This is happening because you try to return an array (or pointer to ints), from a function, but the function was declared to return just a single int!"
C_Programming,34ajv3,TodayIsNotThatDay,1 point,Wed Apr 29 17:14:14 2015 UTC,"Note that this is in the wrap() function, in the default case.   You also have an issue in nextpos() where you're declaring next in a different scope than your return statement."
C_Programming,34ajv3,dragon_wrangler,1 point,Wed Apr 29 17:26:53 2015 UTC,Changed wrap() to return val[3]  how do I resolve my issue with nextpos()? thank you
C_Programming,34ajv3,dragon_wrangler,1 point,Wed Apr 29 17:34:05 2015 UTC,"Changed wrap() to return val[3]   Why? val should only have 3 entries, so val[3] is undefined. What do you expect that function to do? Also, it looks like you're only randomly moving in one of six directions (e.g. left/right/forward/back/up/down). Are you not allowing diagonals?   how do I resolve my issue with nextpos()? thank you   Just declare next at the top level of that function, at the same time as randvar and move"
C_Programming,34ajv3,TodayIsNotThatDay,1 point,Wed Apr 29 17:39:47 2015 UTC,"Yes I am only allowing movement to the six nearest neighbours strictly along x, y, or z - no diagonals so to speak   I am unsure how to resolve the issue with wrap() now given that returning val[3] is wrong. Maybe is is val[]? I am new to C programming, apologies for the slowness"
C_Programming,34ajv3,TodayIsNotThatDay,2,Wed Apr 29 17:51:56 2015 UTC,If you would like to return the array from that function you should declare the function to return a pointer to an int. So maybe something like this:     Int *wrap(. . .  This can be done since an array kinda points to the start address of the ints in memory
C_Programming,34bv4z,chansem86,2,Wed Apr 29 22:20:23 2015 UTC,"If you know how to read in the words to the linked lists, what don't you know about how to read in the reviews?"
C_Programming,34bv4z,theshankm,1 point,Wed Apr 29 22:37:05 2015 UTC,"I don't know how to read the reviews and compare them to the lists. any help would be greatly    The basic idea is that you iterate through the movie review, and for each word you search both lists. So your program needs a notion of a 'current word' as you read through the movie review. You can do this by reading through the movie review file character by character, building each 'current word' as you read it, and discarding the word it when you're ready to move to the next one.  One way is to start with the 'current word' being an empty string. Start reading characters from the file. When you read each character you decide 'is this character part of a word?' If it is, then you modify your 'current word' by adding the character. If it's not part of a word, then that means you've read in a whole word, and now you can search the lists of positive and negative words. After searching the lists, you're done with your 'current word' and can set it back to an empty string, so you can start reading in the next word."
C_Programming,34bv4z,bames53,1 point,Wed Apr 29 22:36:02 2015 UTC,"Keep in mind that there are many ways to do this. Depending on the size of your lists of words, it might be easier to loop through the linked lists searching for each word in the reviews."
C_Programming,34bv4z,theshankm,1 point,Wed Apr 29 22:40:34 2015 UTC,Please avoid writing titles in all caps. Your problem isn't any more important than other people's problems.
C_Programming,349c0g,tmtwd,21,Wed Apr 29 09:37:45 2015 UTC,"Assume we pass the strings ""foo"" (with some extra space following it) and ""bar"". After the first line of your function you have this:  ┌───┬───┬───┬───┬───┬───┬───┬───┬ │ f │ o │ o │ \0│   │   │   │   │ └───┴───┴───┴───┴───┴───┴───┴───┴  ^ ^ s1 s  ┌───┬───┬───┬───┐ │ b │ a │ r │ \0│ └───┴───┴───┴───┘   ^   s2   After the while loop, we have moved s to point to the end of s1:  ┌───┬───┬───┬───┬───┬───┬───┬───┬ │ f │ o │ o │ \0│   │   │   │   │ └───┴───┴───┴───┴───┴───┴───┴───┴   ^           ^  s1           s  ┌───┬───┬───┬───┐ │ b │ a │ r │ \0│ └───┴───┴───┴───┘   ^   s2   Then you just assign s2 to s, making s point to the beginning of the second string:  ┌───┬───┬───┬───┬───┬───┬───┬───┬ │ f │ o │ o │ \0│   │   │   │   │ └───┴───┴───┴───┴───┴───┴───┴───┴   ^           s1             ┌───┬───┬───┬───┐ │ b │ a │ r │ \0│ └───┴───┴───┴───┘  ^ ^ s2 s   Finally, you return s1, which points at the same string of characters it did originally. Your function has done nothing.  The actual implementation of strcat needs to copy the characters from s2 to the end of s1. You can do that by using strcpy to copy s2 to s when you have s at the end of s1. At the end of doing this, everything will look like this:  ┌───┬───┬───┬───┬───┬───┬───┬───┬ │ f │ o │ o │ b │ a │ r │ \0│   │ └───┴───┴───┴───┴───┴───┴───┴───┴   ^           ^  s1           s  ┌───┬───┬───┬───┐ │ b │ a │ r │ \0│ └───┴───┴───┴───┘  ^ s2   And then you just return s1."
C_Programming,349c0g,sftrabbit,1 point,Wed Apr 29 09:52:58 2015 UTC,ok that makes a lot of sense!
C_Programming,349c0g,Poddster,5,Wed Apr 29 10:02:17 2015 UTC,"First of all, I know the correct implementation of the strcpy function, which can be found here: >http://www.opensource.apple.com/source/Libc/Libc-167/gen.subproj/ppc.subproj/strcpy.c   strcat and strcpy do different things. strcat concatenates (aka appends) one string onto another. To do that it needs to allocate more storage, somehow. Strcpy simply copies the source string over the destination string's memory (and hopes it's big enough).   s = s2, means that the end of s1 is now pointing at the beginning of s2   No it doesn't.   It means the pointer s now points at what the pointer s2 was pointing at. And it's a useless thing to do as nothing reads s again after that line.  More importantly: After your loop is run, spoints at the end of s1. But then you reassign what it points to. So that loop was all for nothing.  Did you mean to do a dereference or a memcpy or something?   Is there a way to make this function work?   Yes, re-write the function to actually do something other than return s1 ;)"
C_Programming,349c0g,zifyoip,5,Wed Apr 29 09:49:47 2015 UTC,"strcat concatenates (aka appends) one string onto another. To do that it needs to allocate more storage, somehow.   No, strcat does no allocation."
C_Programming,349c0g,Poddster,1 point,Wed Apr 29 18:21:46 2015 UTC,"Correct. I can't imagine why I typed that. Whilst I didn't mean malloc[0], I thought it took an extra size parameter and just grew into the dest buffer, but it looks like it doesn't. I'm probably thinking of the myriad of strcat_s_super_Safe variants.  [0] strdup is the only one I know off the top of my head that will call malloc for you"
C_Programming,349c0g,zenkibudo,2,Wed Apr 29 20:04:03 2015 UTC,"Now that you've had time to read all the posts and such, here's some code for you:  char *my_strcat(char * s1,  char * s2)   {   char *p = &s1[strlen(s1)];      while(*s2)         *(p++) = *(s2++);     *p = '\0';      return s1; }"
C_Programming,349c0g,zenkibudo,2,Fri May 1 02:59:00 2015 UTC,"thank you, I am actually going to memorize this.  This is closest to the spirit of what I was trying to do. I figured it was impossible."
C_Programming,349c0g,pleasantguy,2,Fri May 1 03:15:49 2015 UTC,you are very welcome. i hope u enjoy it as much as i enjoyed writing and testing it.   I don't know why i love low-level string manipulation so much; i don't know why i love C so much.  Some things just are.
C_Programming,3496ec,tmtwd,6,Wed Apr 29 08:08:40 2015 UTC,They're just decimals. Somebody was too lazy to type 0.0 or 1.0  They're in there because the author is trying to force the expression to be handled as a floating point calculation.
C_Programming,3496ec,Rhomboid,1 point,Wed Apr 29 08:23:18 2015 UTC,"ok, thank you"
C_Programming,3499ve,tmtwd,7,Wed Apr 29 09:04:18 2015 UTC,"char* c = ""hello world\0"";    char* newch = &c[0];    *newch++;     printf(""%s\n"", newch); //I just pass in the pointer       Why are you doing this? If you want to print c, why not simply do:  printf(""%s\n"", c);   Also, you don't need an explicit \0 at the end of ""hello world"". C automatically puts a \0 at the end of any ""string literal"".   Why do I pass in the raw pointer in the first example, but in the second example I have to deference the pointer?   Because a string is a pointer to an array of characters, by definition, and a character is a character, by definition. So if you dereference the string pointer you'll get a character. So does it not make sense to you that if you want to print a string you provide the pointer and if you want to provide a character you provide the character?"
C_Programming,3499ve,Poddster,6,Wed Apr 29 09:55:19 2015 UTC,"Why do I pass in the raw pointer in the first example, but in the second example I have to deference the pointer?   Because %s expects a pointer to a char (i.e. a string), whereas %c expects a char.  That's how the function is specified, there's not much more to it.  In an alternative universe you could possibly have gone back to 1972 or whatever and decided to implement a format specifier for printf() that takes a pointer to char and only prints a single char, rather than a string, but that would be silly because there's no reason to involve a pointer for that.  Also your examples are very silly.  This newch thing isn't doing anything of value, and you're double null-terminating your string.  char *str = ""Hello world""; printf(""%s\n"", str); printf(""%c\n"", *str);"
C_Programming,3499ve,Rhomboid,2,Wed Apr 29 11:22:22 2015 UTC,"First you are dereferencing a pointer and not using it: change ""*newch++;"" into ""newch++;"". When you dereference a pointer you get the character. If you want to print a string, you need pointer to a string."
C_Programming,3499ve,petahi,2,Wed Apr 29 09:28:19 2015 UTC,"Ah, of course you are right, I didn't realize that."
C_Programming,3499ve,Chooquaeno,1 point,Wed Apr 29 09:39:50 2015 UTC,"You are the printf function, and you are given a character value. You want to print a string. How do you get the value of the next character?"
C_Programming,348t27,gillhimmy,8,Wed Apr 29 05:12:08 2015 UTC,"Your struct only holds pointers to arrays of characters. What you probably want is something like:  typedef struct{    char name[MAX_NAME_SIZE];   char sex[MAX_SEX_SIZE];   char entrance[MAX_ENTRANCE_SIZE];   char duration[MAX_DURATION_SIZE];  }Person;   Otherwise every time you create a new Person struct, you are only creating four pointers, not four spaces for strings, unless you are malloc-ing a new a,b,c,d every loop (in which case you also need to be free-ing each item of your structs, don't do any of this malloc/free stuff unless you know what I am talking about, I'm not sure of your programming level).  What you are doing right now is like making a new set of labels for a box you are going to ship, without actually making the boxes you are going to put your stuff in. Unfortunately in C, sometimes things sort of accidentally work even though they shouldn't. Its funny like that. Fix that, and see if you have any luck.  Could you post the whole code? theres some other weirdness with how you are defining a new Person every loop, though that might be you shortening your code. Also, don't make the instance name the same as your struct name.  //do this Person temp_person; //not this Person Person;"
C_Programming,348t27,jahmez,-3,Wed Apr 29 05:51:19 2015 UTC,I am not a beginner but i am not an expert on c either. I just updated the code and posted the whole code. Could take a look at it and see if that helps you in understanding it better?
C_Programming,348t27,SlayterDev,1 point,Wed Apr 29 06:07:05 2015 UTC,"Why do you declare a new array of persons at the top of the while loop? The way you have it written, the first iteration will create an array of size 0."
C_Programming,347tar,sheepsheepsheepsheep,3,Wed Apr 29 00:01:00 2015 UTC,"Your printf doesn't supply a format specifier or anything to display. In this case you want   printf(""Character entered: %c"", c);   getchar() only gets one character from the buffer once you press enter.    1) What is the significance of the c in char c. I put a, b, c, or d in it's place and it gives me the same results.   Nothing. It's just the name used to refer to the variable, you could call it slartibartfast for all the compiler cares, but that wouldn't be very readable ;)   2) How would I chance it so that it changes all the characters inputted instead of just the first one?   You would need to use a loop to loop over the line until it reached a predetermined delimiter. Then do your add on each character before moving to the next one.  Something like this in pseudocode:   while c != delimiter {     c = getchar();     putchar(c+5); }   *awaits corrections from people far more experienced and intelligent than me*"
C_Programming,347tar,Burgerlicious,3,Wed Apr 29 00:24:08 2015 UTC,"awaits corrections from people far more experienced and intelligent than me     Naw, i think you did a great job.  I would only add a small note on the irony that a function called 'getchar' returns an int.  Crazy, right? heh.     Humor aside, that fact could one day have an important ramification for your/someone's code, however unlikely."
C_Programming,347tar,zenkibudo,1 point,Wed Apr 29 00:29:54 2015 UTC,"I would only add a small note on the irony that a function called 'getchar' returns an int.  Crazy, right? heh.      Isn't it because chars are internally represented as ints because they used to be the same size? Also, because chars are ints."
C_Programming,347tar,GaProgMan,2,Wed Apr 29 08:08:11 2015 UTC,"It's because the return value has to be able to represent EOF in addition to any valid character, so a type wider than char must be used."
C_Programming,347tar,Rhomboid,1 point,Wed Apr 29 11:52:08 2015 UTC,"Yes, nailed it.  I remember in my first year programming in C, i was very upset about this, and so i wrote a wrapper for getchar that returned a char like it's supposed to, dammit.  LOL, big mistake..."
C_Programming,347tar,zenkibudo,2,Thu Apr 30 05:03:13 2015 UTC,"I think you've made some good very technical points.  I did read that technically a char is an int, or a kind of int.  And beats me if they used to be the same size.  Could be.  The int grows about 16 bits per decade or so.  And char is growing too.   I think the standard may say it's 8 bits wide somewhere, but that's getting blasted by WCHAR/TCHAR, and eventually they'll likely merge into a new, 16 bit  standard for one, universal char.   And you'll blink your eye, 20 years have gone by, and a char is now 32 bits, but yet is still the smallest atomic type for C....  It's already kinda sorta happening"
C_Programming,347tar,zenkibudo,3,Thu Apr 30 05:07:33 2015 UTC,"printf does not require any % in the format string. The original code was just fine, perhaps you overlooked the putchar on the next line."
C_Programming,347tar,OldWolf2,2,Wed Apr 29 03:43:43 2015 UTC,"I just looked through my syllabus and we actually haven't gone over loops yet. I have a feeling it's going to be asking me one variable after another until I get 5 variables that shift 4.  So basically loops are out of the question and it should be simpler than expected.  I wrote this earlier expecting it to yield something but the 2nd printf with d = getchar() didn't even pop up on the screen.  #include <stdio.h>  int main ()  {     char c;  char d;  printf(""Enter character: \n"");  c = getchar();  printf(""Enter character: \n"");  d = getchar();  printf(""Character entered: \n"");  putchar(c+2);  printf(""Character entered: \n"");  putchar(d+2);   }"
C_Programming,347tar,OldWolf2,3,Wed Apr 29 02:44:00 2015 UTC,"The Enter key is a character too. If you press one key and then Enter, the next two calls to getchar will return the keypress and the Enter key respectively.   So d will hold the value 10 here (which is the ASCII code for the Enter key). Then you add 2 to get 12 which is ""form feed"" in ASCII;  the actual output you get for this will depend on your system. It might be ignored, or print a funny symbol, or something."
C_Programming,347tar,ruertar,2,Wed Apr 29 03:45:24 2015 UTC,"1) What is the significance of the c in char c. I put a, b, c, or d in it's place and it gives me the same results.   There is no significance.  'c' is just a variable name and you could have used nearly anything you want.  'my_character', 'foo', 'banana', etc.  It is just a name.   2) How would I chance it so that it changes all the characters inputted instead of just the first one?   You would use a loop of some sort.  But remember -- you actually have to enter more than one character to get this program to work.  You have to enter a character then hit the enter key.  Imagine what would happen if you had a second getchar() call in there.  It might be an interesting experiment."
C_Programming,347tar,OldWolf2,2,Wed Apr 29 02:11:45 2015 UTC,"char c; should be int c; . To understand why, read the documentation for getchar. Which is a good idea to do in any case.  To get help with code, post the code you are having trouble with. Nobody knows what you did when you ""try to add more than 1 character""."
C_Programming,347tar,OldWolf2,1 point,Wed Apr 29 03:42:48 2015 UTC,"#include <stdio.h>  int main ()  {     char c;  int i = 0;   while (i<6)  {      printf(""Enter character: \n\n"");      c = getchar();      printf(""Character entered: \n\n"");      putchar(c+4); }  return 0;   }  This is what I have now and it seems to work but thing is when I run it, it returns a redundant line.    http://i.imgur.com/8Huncft.png  That's after just one return. It has that middle portion that I'm not sure how it came to."
C_Programming,3493sa,BinaryFallen,3,Wed Apr 29 07:29:10 2015 UTC,"scanf was unsafe because it takes anything the user enters and attempts to ram it into wherever you told it to. You might ask ""Enter your full name:"" and you pass in a buffer you think is large enough to hold names, but the user might enter the full text of war and peace and boom there goes your program. User entry needs to be treated like the plague, you have NO idea what the user will enter or how long it will be. I don't recommend scanf_s either, to my understanding that's a microsoft only half measure. You should use fgets."
C_Programming,3493sa,GaProgMan,1 point,Wed Apr 29 07:58:37 2015 UTC,Thanks for letting me know about that I will look up and learn to use fgets. Is fgets something that completely replaces scanf or will there be certain specific reasons why I would want to use scanf over fgets?
C_Programming,3493sa,GaProgMan,1 point,Wed Apr 29 11:36:21 2015 UTC,"A third case: fgets doesn't completely replace scanf and there's still no situation where you want to use scanf.  scanf can chop input up into variables using what's called a format string. fgets can't, but that's not an acceptable reason to use scanf. You can read the user input with fgets then chop it up once you safely have it in memory."
C_Programming,3493sa,GaProgMan,1 point,Wed Apr 29 13:17:58 2015 UTC,"Just a few comments on the code, not really that helpful:  What if I only have two initials? What if I enter a non-int value for my age (a decimal/real number or a word for example)?  Just some thoughts on the design of the code, they don't answer your question but they're worth thinking about."
C_Programming,348bin,Apairoftits,7,Wed Apr 29 02:25:35 2015 UTC,Post on /r/cpp_questions since this is a C++ question.
C_Programming,348bin,OldWolf2,3,Wed Apr 29 03:31:31 2015 UTC,"You should always post the error. I do see a problem though. Namely, your array of objects is static (since it is global). If an initializer is not provided for the default constructor is used for static variables. But since you provided a constructor, the class does not have a default constructor."
C_Programming,348bin,wgunther,1 point,Wed Apr 29 03:22:52 2015 UTC,"Edit. Just realized you said c++. You can disregard my comment.   To use a struct in C, you have to say   struct nameOfStruct varname;    So for example.   struct point { int x,y;  };  struct point myPoints[5];   Because of this it is common to use a typedef.   typedef struct { int x,y;  } point ;  point myPoints[5];"
C_Programming,348bin,nucular_expresso,2,Wed Apr 29 03:18:32 2015 UTC,I'm fairly new to C and haven't used struct/ typedef much. What's the reason in using  typedef struct point { } Point;   Instead of just  typedef struct { } Point;
C_Programming,348bin,sgthoppy,1 point,Wed Apr 29 04:21:41 2015 UTC,If you want a variable within the struct to have the type of the struct you must have the name before the {.
C_Programming,348bin,Spanone1,0,Wed Apr 29 08:01:09 2015 UTC,You don't have to type struct every time you use it.
C_Programming,348bin,f5f5f5f5f5f5f5f5f5f5,1 point,Wed Apr 29 05:24:02 2015 UTC,"That's the difference between ""struct Point { }"" and ""typedef struct { } Point"". Their case is different.  To answer the question, I think that the difference between ""typedef struct point { } Point"" and ""typedef struct { } Point"" is that the former allows referring to the struct as both ""struct point"" and ""Point"", whereas the latter only allows the latter. I'm not really knowledgeable on the actual reason, though, and someone more knowledgeable will have to confirm."
C_Programming,348bin,phail3d,2,Wed Apr 29 07:08:14 2015 UTC,"yes that's true, and to refer to the struct within its declaration (e.g. for a linked list) you need to use ""struct point"" since the typedef hasn't finished yet"
C_Programming,348bin,kill_jester,1 point,Wed Apr 29 08:17:47 2015 UTC,TIL. Thanks!
C_Programming,348bin,phail3d,1 point,Wed Apr 29 08:29:05 2015 UTC,I use that for lists.      typeset struct s_list      {         s_list *next;         ....     } list;
C_Programming,348bin,f5f5f5f5f5f5f5f5f5f5,1 point,Wed Apr 29 11:36:16 2015 UTC,If you don't have the struct tag attached then you've either typedef'd it or you're not using a c compiler.
C_Programming,348bin,An_Unhinged_Door,1 point,Wed Apr 29 13:08:39 2015 UTC,Can you post the exact error message?
C_Programming,348bin,Cronizal,1 point,Wed Apr 29 03:20:11 2015 UTC,Your struct doesn't have a default constructor. Therefore Reading temps[50]; won't work.
C_Programming,348bin,the-fritz,1 point,Wed Apr 29 07:47:34 2015 UTC,"Make a default constructor for Reading by adding default arguments:  Reading(int h = 0,double t = 0):hour(h),temperature(t){};"
C_Programming,3451k4,icodeuk,18,Tue Apr 28 10:40:55 2015 UTC,"A talented programmer is someone who knows their shit and writes quality code in reasonable time. This has nothing to do with relying on reference material and google searches (though, tbh, if you need to look up how to code a for loop everytime, you're probably not talented). Knowledge of using search engines and reference materials is a vital real-life skill in itself.  As a side note, the word ""talented"" is a pet peeve of mine, since it implies an inborn ability, while in reality skills like this are an acquired feat."
C_Programming,3451k4,phail3d,5,Tue Apr 28 11:27:14 2015 UTC,I've never met a baby that could code.
C_Programming,3451k4,OliStabilize,2,Tue Apr 28 13:25:32 2015 UTC,+1 for noting the usual/correct use of talent/talented — it's a natural ability.
C_Programming,3451k4,RainbowNowOpen,2,Tue Apr 28 16:57:51 2015 UTC,This pretty much sums it all for other languages as well.
C_Programming,3451k4,s0uly,5,Tue Apr 28 20:10:33 2015 UTC,Just out of curiosity what are the two books you carry with you?
C_Programming,3451k4,bithush,5,Tue Apr 28 12:09:40 2015 UTC,"K&R book, and Unix Network Programming."
C_Programming,3451k4,bithush,-5,Tue Apr 28 16:03:07 2015 UTC,Probably be better off with C in a Nutshell and/or Understanding and Using C Pointers IMHO.
C_Programming,3451k4,bithush,6,Tue Apr 28 16:35:52 2015 UTC,"""Understanding and Using C Pointers"" ... how did you arrive at the conclusion that I don't understand pointers?"
C_Programming,3451k4,wiktor_b,-8,Tue Apr 28 16:44:08 2015 UTC,No matter how well you know pointers I would bet money you will learn a few things from that book. It is god-tier in the C programming books world.
C_Programming,3451k4,bithush,5,Tue Apr 28 16:50:43 2015 UTC,That doesn't make it a good reference book.
C_Programming,3451k4,bithush,1 point,Tue Apr 28 17:34:35 2015 UTC,But it is a good reference book. Have you read it? It really is a great book to keep near by.
C_Programming,3451k4,Lobreeze,3,Tue Apr 28 19:34:44 2015 UTC,"Bithush, I own the C# 5.0 Nutshell book and I have to admit I do turn to it more than my Addison Wesley, and Microsoft, versions. It's very well written and formatted. I've just checked out the C Nutshell book and it does look great and very in depth. I've put one on order ... PAPER version :p Thanks for the suggestion :)"
C_Programming,3451k4,gliese946,3,Tue Apr 28 19:53:52 2015 UTC,It is a very helpful book. Probably the book I use the most as a reference. Another book I recommend to read (but not ref) is 21st Century C 2nd edition. Has a lot of great info. Some you no doubt already know but I would be surprised if you didn't learn a few very handy tips and tricks.
C_Programming,3451k4,ZaberTooth,-11,Tue Apr 28 22:00:50 2015 UTC,Honestly I would laugh at someone if they bragged about carrying two C books around with them.   Like are they carrying around K&R in a silly tote bag? Especially now that we have these crazy new inventions called PDFs...
C_Programming,3451k4,Lobreeze,10,Tue Apr 28 14:01:30 2015 UTC,I'd reciprocate with a smile.
C_Programming,3451k4,ZaberTooth,6,Tue Apr 28 16:04:24 2015 UTC,That is a gracious response to a childish comment.
C_Programming,3451k4,DustbinJ,7,Tue Apr 28 17:05:39 2015 UTC,"I would laugh at someone   This sub is about helping one another. This type of comment is not only unhelpful, but rude. Please consider this before making future posts."
C_Programming,3451k4,paulrpotts,-10,Tue Apr 28 16:43:21 2015 UTC,"Maybe someone shouldn't boast about carrying around massive textbooks in this day and age.   OP said that this bothers him. 10/10 times I would respond to that kind of boast with laughter. Carrying around 20 pounds of reference material does not make you a good programmer either...  OP even says he may be off base? How is my response off-topic?  Also, you may have noticed, many, many programmers are blunt. I don't need to use rainbows and euphemisms when I talk on the internet."
C_Programming,3451k4,Lobreeze,8,Tue Apr 28 16:46:39 2015 UTC,"OP is not bothered by carrying books. OP is bothered by what the term ""talented C programmer"" may mean: ""someone who has C ingrained in the brain and rarely needs to look at books, or manuals, for reference. Someone who rarely Google's for help on coming to a solution to a problem.""  OP is not boasting about carrying reference materials. OP is saying that he disagrees with the aforementioned interpreation of ""talented C programmer"". Presumably (and I would agree), OP thinks that one need not be a master of every nuance of the language in order to be considered talented.  OP is not saying he may be off base about carrying books. OP is saying he may be off base with his thoughts on what it means to be a ""talented C programmer"".   Your response is off-topic because it does not address the main point of the thread: what the term ""talented C programmer"" means. Instead, you missed the point entirely (i.e. that OP uses reference materials instead of memorizing the nuances of the language), and you make fun of OP's choice to use physical, rather than digital reference materials.  I'm a professional C programmer. I understand bluntness. Here's some bluntness: You misread OPs original post, and then made fun of him. You're a jerk."
C_Programming,3451k4,paulrpotts,1 point,Tue Apr 28 18:27:27 2015 UTC,"yeah man, I bet your social life is fucking exploding. I love being cynical and mean LOL, it's part of my badass attitude just like my favorite tv show characters!"
C_Programming,3451k4,xycu,-17,Wed Apr 29 14:25:23 2015 UTC,Please don't advocate piracy in this forum. It gives programmers a bad name.
C_Programming,3451k4,paulrpotts,10,Tue Apr 28 14:37:11 2015 UTC,"Because books aren't commercially available in PDF...  Welcome 2015, nice of you to join us."
C_Programming,3451k4,fjellfras,-8,Tue Apr 28 14:40:56 2015 UTC,"As far as I can determine, there is no legally available PDF version of K&R. There is a Kindle version. Do you know otherwise? If so, please share where it can be found. Otherwise, leave the grown-ups alone."
C_Programming,3451k4,paulrpotts,6,Tue Apr 28 14:43:23 2015 UTC,InformIT.com (Pearson) sells the hard copy and epub/mobi/pdf ebook versions.
C_Programming,3451k4,fjellfras,1 point,Tue Apr 28 14:50:47 2015 UTC,"Good to know, thanks. http://www.informit.com/store/c-programming-language-9780131103627"
C_Programming,3451k4,Lobreeze,3,Tue Apr 28 14:54:30 2015 UTC,It was actually released with much fanfare.
C_Programming,3451k4,jdonniver,2,Tue Apr 28 15:31:04 2015 UTC,"All right, my apologies to Lobreeze. In my defense, if you Google for ""c programming language kernighan ritchie pdf"", a legally available PDF does not show up in the first three pages of results. At least, that was my experience. The very first few results are either links to a PDF with a blurry image of the cover, which appears to have the copyright page removed, or links to the Amazon page, which (I think) will sell you a .mobi file."
C_Programming,3451k4,angdev,1 point,Tue Apr 28 15:40:35 2015 UTC,"No worries. For some reason legal pdf results often dont show up high ranked in google. Have to look directly on oreilly, informit and nostarch sites."
C_Programming,3451k4,chefgroovy,-1,Tue Apr 28 15:43:41 2015 UTC,"PDF/MOBI/etc all readable on a tablet.  Thanks for splitting hairs, gramps."
C_Programming,3451k4,awwtowa,5,Tue Apr 28 14:47:30 2015 UTC,"Do you know what the stack is? Do you know what the heap is? Do you know what variables in a C program are on the stack, and which ones are on the heap?  Do you know how to use malloc() and free() properly? Do you know what happens from the moment your program is loaded to the moment it is unloaded? Can you describe what the 'static' keyword does, and use it effectively?  If I give you a binary, can you tell me what libraries it's linked to, and what functions it calls? Can you tell me what functions it exports?  Do you know how to use mmap()? Sockets? man pages?  If you are tasked with writing a tool in C that does some very simple task, can you do it in under an hour?  ""Talented"": Are you good at C, or are you just okay at it?  Can you pass this test? http://www.barrgroup.com/Embedded-Systems/Embedded-C-Quiz  Source: Embedded C developer with > 10 years experience, expert level. I consider all of this to be basic knowledge.  Edit: I forgot about pointers. Do you know how to use them? If I have a pointer to an int32_t and it's address is 0x12345678, what happens if I do ptr++? What is it's new value? If you say anything other than 0x1234567C, you are not a talended C programmer. (Note: I used C99 fixed width types for this example. Not strictly C. Forgive me)  Edit: Do you know why you should never call a macro like this: MYMACRO( x++ )?"
C_Programming,3451k4,Poddster,2,Tue Apr 28 16:11:15 2015 UTC,"I got 9/10 on the test. The question I got wrong was:  Which of the following items should generally be declared using C's volatile keyword? Response:  A memory-mapped peripheral status register A global variable used within an interrupt service routine A global variable used by multiple tasks in a multi-threaded application All of the above   My gut feeling ended up being the correct answer, but I actually chose the first answer :(  I also took a bit of an educated guess on the question:  Which ANSI C compilers allow a variable to be declared both volatile and const?   And got it right.  My background is programming ASM & C(++) for about 18 years now. I have done lots of embedded as well."
C_Programming,3451k4,awwtowa,1 point,Tue Apr 28 22:36:12 2015 UTC,I think I would show myself to the door. Wouldn't even ask for parking voucher
C_Programming,3451k4,autowikibot,3,Tue Apr 28 18:46:17 2015 UTC,5 years out of school working in C and I still don't know all the methods in libc or POSIX. I'm not sure I even want to know. I usually open up the man page online because sometimes I find out FreeBSD does things a bit different than Linux.   I think its one of those 'manager lists nice to haves' and it gets misinterpreted as 'needed expert' skillset. I usually skip the adjectives and just meet/talk to the engineers.
C_Programming,3451k4,fjellfras,28,Tue Apr 28 11:32:50 2015 UTC,methods    NOT HIRED.  ;)
C_Programming,3451k4,awwtowa,1 point,Tue Apr 28 14:54:43 2015 UTC,Sorry ;(
C_Programming,3451k4,autowikibot,1 point,Wed Apr 29 12:26:34 2015 UTC,"Method (computer programming):       A method (or message) in object-oriented programming (OOP) is a procedure associated with an object class. An object is made up of behavior and data. Data is represented as properties of the object and behavior as methods. Methods are also the interface an object presents to the outside world. For example a window object would have methods such as open and close. One of the most important capabilities that a method provides is method overriding. The same name (e.g., area) can be used for multiple different kinds of classes. This allows the sending objects to invoke behaviors and to delegate the implementation of those behaviors to the receiving object. For example an object can send an area message to another object and the appropriate formula will be invoked whether the receiving object is a rectangle,circle, triangle, etc.     Interesting: Dispatch table | Template method pattern | Virtual function   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,3451k4,aninteger,1 point,Wed Apr 29 12:27:41 2015 UTC,"What do you work on, if you don't mind sharing?"
C_Programming,3451k4,Bonejob,2,Tue Apr 28 15:31:37 2015 UTC,Juniper's JunOS.
C_Programming,3451k4,chefgroovy,1 point,Wed Apr 29 12:23:59 2015 UTC,"Junos:       Juniper Junos is the FreeBSD-based operating system used in Juniper Networks hardware routers.  It is an operating system that is used in Juniper's routing, switching and security devices. Juniper offers a Software Development Kit (SDK) to partners and customers to allow additional customization.   The biggest competitor of Junos is Cisco Systems' IOS.     Image from article i     Interesting: JUNOS – Young liberal NEOS | Yuzu | Juno Awards of 1975   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,3451k4,chefgroovy,3,Wed Apr 29 12:25:00 2015 UTC,"In what city do you see ""Talented C Programmer"" all the time? In the last 5 years I have maybe seen one job requirement list C but most of the time they specifically want C++ or an entirely different language like C#/Java or Python. While C is pretty popular in open source I haven't seen it advertised ""all the time"" online in local job boards."
C_Programming,3451k4,Bonejob,1 point,Tue Apr 28 13:54:24 2015 UTC,"You are looking in the wrong place.   Thinggamajob  O and of course  Robert Half Technology  if you are looking for serious work call Robert Half I went from <70k per year to >120k per year. Robert Half can sell your skills, o and you don't pay for it the company that hires you does. Make aure you ahve your big boy pants on though... ;)"
C_Programming,3451k4,IWillNotBeBroken,1 point,Tue Apr 28 15:32:59 2015 UTC,"I applied at  Robert Half, thought was just going in for paper work, next thing I knew I'm taking a  test on the computer, to see how ""talented"" I was. They want that shit quantified.   Tons of interviews, no job. I suck at interviews"
C_Programming,3451k4,paulrpotts,1 point,Tue Apr 28 18:42:50 2015 UTC,"Care to share your experience on the test, and a couple of sample questions you were asked? I remember at one interview some years ago I was asked how I would solve the path problem. I completely failed it due to nerves."
C_Programming,3451k4,paulrpotts,1 point,Tue Apr 28 19:09:17 2015 UTC,"Was 10 years ago, and .NET. I don't remember any of it, and I'm sure it has changed since then. Was multiple choice though."
C_Programming,3451k4,ModernRonin,3,Tue Apr 28 19:33:25 2015 UTC,"I love subjective terms to describe programmers, just love them. I categorize them in the slot of ""rockstar!"" and ""superstar!""  Since we all have the innate capacity to think that we are ""Talented"" and most of us are wrong. BTW don't take that the wrong way I am not pointing a finger at you #icodeuk  I am ok with people not remembering the specific syntax for a specific structure, and needing to look it up. I am more interested in the ones that can learn from what they are doing, and get better. Don't give to shakes about what you have memorized or what you know, I want you to be able to figure it out. Please keep in mind this also comes with a caveat that they have to know their ass from a hole in the ground regarding code :)  When I want to hire a ""Talented C Programmer"" the questions I ask them is, ""Tell me about the most interesting code you have written"" and that is the job add in the tech journal as well...  B"
C_Programming,3451k4,CatsAreTasty,1 point,Tue Apr 28 15:25:56 2015 UTC,"How about looking at ""talented"" in a context that it's normally used in, such as ""a talented actress.""  It means that they're good at acting.  How they do it, what acting feats they can or cannot do -- that doesn't matter.  They're good.  That's it."
C_Programming,3451k4,Drainedsoul,1 point,Tue Apr 28 14:28:53 2015 UTC,"Meh, ""talent"" is a pretty useless word in this context. It's like looking for someone to hire for a band and demanding a ""talented"" musician as opposed to a skilled, hard-working musician. I'm an amateur musician, and some of my friends bemoan that they can't do what I do because they have no ""musical talent."" Of course, they also haven't spent thousands of hours practicing. I think the practicing is a lot more important than the ""talent."" Sure, I think a musician needs to have an ingrained ability to hear pitches and rhythms, and some people really don't even start out with this, just as some people really can't learn to program; they just don't think that way. But the work put in is far, far more important.  As for the books, don't worry about it. I have reference books on my shelves all the time. I've been programming in C for more than 25 years and I still look things up in Harbison and Steele's C: A Reference Manual and other books. I do embedded work most of the time and a lot of the standard libc APIs aren't available, so when I have to do something with a library call I often have to look it up. I prefer paper books personally. The people asking why you don't have a PDF file of K&R or whatever are probably advocating piracy; ignore that crap. Sure, you could have some reference books on a Kindle or what-not, but in general I think most of the good references look better in print, and you don't have to deal with DRM or dead batteries."
C_Programming,3451k4,Drainedsoul,2,Tue Apr 28 14:34:04 2015 UTC,I'm also an amateur musician too :) What music do you play/produce?
C_Programming,3451k4,bithush,2,Tue Apr 28 16:06:32 2015 UTC,"Some nerd rock, nerdcore rap-ish stuff, folk-ish stuff... it is a very part-time endeavor but I've been trying to teach myself recording, mixing, and mastering too. Some original songs, written and recorded for songwriting contests. It's all a bit of a mess at present, but there is some stuff here:  http://www.youtube.com/user/paulrpotts  and here:  http://commonlisp.bandcamp.com/"
C_Programming,3451k4,RainbowNowOpen,1 point,Tue Apr 28 17:34:14 2015 UTC,"Nice! I don't know what genre I'd class my music as but people seem to enjoy it. I do it for fun, purely because synthesizers and samplers are my ""other"" main hobby: https://soundcloud.com/base2music/midnight-star-curious-base2-remix"
C_Programming,3451k4,gliese946,1 point,Fri May 1 18:40:51 2015 UTC,Re: PDF's and dead battery. This is another reason paper always wins :)
C_Programming,346649,H_Korean,1 point,Tue Apr 28 16:46:41 2015 UTC,"What do you mean by ""basically just made it a really long sentence""?  Anyway, since guessCount stores the number of guesses so far, and MAX_GUESSES is the total number of guesses, working out how many guesses are left is a pretty trivial operation! If I've guessed 3 times, and I have 10 attempts... how many do I have left?"
C_Programming,346649,sftrabbit,1 point,Tue Apr 28 16:57:29 2015 UTC,"So wouldn't doing something like, if(guess==guessCount) basically print out when you have no more guesses?  edit: Also, you'd have 7. The issue, for me at least, is that I don't know how to get it to print it out consistently. For example, I want it to print out ""Incorrect, you have x-amount of guesses left."". I just do not know how to go about it. edit: I meant long sentence, but it turns out I forgot the \n portion of it."
C_Programming,346649,sftrabbit,1 point,Tue Apr 28 16:59:15 2015 UTC,"So far, I figured how to print out the correct number after all guesses have been used. However, I am now, at the moment it seems, stuck on printing out how many guesses remain after guessing incorrectly. Am I going the right direction? Outside of the IF statement there is the      printf(""Try again. Number of guesses left: %d\n"", MAX_GUESSES - 1); However, i'm not sure if that's entirely the right track to go on."
C_Programming,346649,sftrabbit,1 point,Tue Apr 28 17:33:40 2015 UTC,That is definitely on the right track. The only problem is MAX_GUESSES - 1. That would tell you how many guess you have left if you had only guessed 1 time and will always give you the same number. How would you change this to tell you how many guesses you have left if you have guessed guessCount times?
C_Programming,346649,sftrabbit,1 point,Tue Apr 28 17:36:02 2015 UTC,"Thank you, I was able to figure it out. I decided to add MAX_GUESSES - guessCount, and that straightened it out. My only issue is how do I go about including the guesses? Like, how would I be able to start the program and then it say that I have 3 guesses to solve? When I ran, all it did was count down from 3, and not include 3 itself"
C_Programming,343yuy,KenNoisewater_PHD,9,Tue Apr 28 02:50:23 2015 UTC,"Harvard's CS50 Intro to Computer Science class is considered to be one of the best online courses in CS and uses C for many of the problem sets.  As for books, my favorite and also recommended by the C FAQ is C Programming: A Modern Approach by KN King. It provides more explanation than the relatively tiny K&R book by the creator of C."
C_Programming,343yuy,Idoiocracy,8,Tue Apr 28 03:08:11 2015 UTC,Familiarize yourself with pointers.
C_Programming,343yuy,loderunnr,3,Tue Apr 28 04:24:30 2015 UTC,"I agree with this. The main reason that makes C ""harder"" than Java is understanding memory management.  If you already learned Java, try doing the beginner exercises you used to learn Java in C. You should be able to do most (if not every one) of them, and you'll get to see the main differences: no object-oriented constructs in the language, manual memory management, string manipulation (with strings as char arrays and arrays being indexed pointers)...  I feel that, if you know programming already, you learn C specifically by running into common problems a thousand times and understanding them better each time. So my advice really is: practice, practice, practice! Write a string reversal function. Write a sorting algorithm. Write a prime number sieve. Write a random number generator. Write stuff, get it wrong then get it right, and learn from it."
C_Programming,343yuy,Mines_of_Moria,1 point,Tue Apr 28 13:04:56 2015 UTC,"cool, do you any good websites that have simple C exercises to work on?"
C_Programming,343yuy,wild-pointer,1 point,Tue Apr 28 16:00:24 2015 UTC,"Hey, I'm just finishing a C class right now meant for UG students that have ~2 courses in Java, which is basically where you are. PM me and i'll send you the course website, which contains every lecture, ppt, and 10 assignments. It sounds very appropriate for you."
C_Programming,343yuy,ankokukaze,3,Tue Apr 28 23:39:00 2015 UTC,"C is much simpler than Java. Whether that makes it easier / harder I can't say, but there are certainly WAY less features to learn and remember."
C_Programming,343yuy,morto00x,2,Tue Apr 28 11:55:29 2015 UTC,Thanks for the replies guys!
C_Programming,343yuy,a_frog_on_stilts,2,Tue Apr 28 04:51:01 2015 UTC,"Also, spend some time to learn how your compiler and linker works, i.e. how C source turns into object files, which in turn are linked into an executable or library. Try to answer what the difference is between Java's import statement and C's include preprocessor directive. They are somewhat similar in purpose, but quite different technically."
C_Programming,343yuy,zenkibudo,0,Tue Apr 28 15:27:01 2015 UTC,I would always start with websites like http://www.cprogramming.com/  You just need to remember C is not OOP like Java.
C_Programming,344kz6,PhxkinMassacre,2,Tue Apr 28 06:37:07 2015 UTC,Your question suggests that you have a fundamental misunderstanding of something. What are you trying to accomplish?
C_Programming,344kz6,wgunther,1 point,Tue Apr 28 06:55:29 2015 UTC,i have an assignment where we have to time how long it takes for 2 different programs run and are only given the 2 for loops and the dst line (the other program is similar but the i and j's are swapped around). i have all of the other stuff figured out (i hope) but cant for the life of me figure out how to declare the dst and src in the program. due to a change in how our class track changed i learned basic java but now they teach c instead and this class expects you to have learned c (which i didn't) so im kinda in a rutt :P i just don't know what type it is. tried declaring it as an int and a char but neither compiled correctly.  here is the picture of the whole program so you can get a better idea http://i.imgur.com/PzOWZZ8.png
C_Programming,344kz6,wgunther,3,Tue Apr 28 07:10:21 2015 UTC,If you are assigning the thing like dst[i][j] = ... what kind of object by dst be?
C_Programming,344kz6,wgunther,1 point,Tue Apr 28 07:14:16 2015 UTC,that my problem. i have no idea. if i knew that then i could figure it out but i haven't encountered something like this before o.0
C_Programming,344kz6,wgunther,3,Tue Apr 28 07:22:11 2015 UTC,"I can't imagine you could produce this from whatever the assignment says and not know what kind of thing dst is. It would be like having an assignment to build a car, and you posting a picture of a wheel saying that you built it for the car but you're not sure what it does. What does the assignment say?"
C_Programming,344kz6,wgunther,1 point,Tue Apr 28 07:26:00 2015 UTC,"all it says is to compare the performance of the two versions of the code below on the same system.  Version A:  for(i = 0; i < 512; i++) {  for(j = 0; j < 512; j++) {  dst[i][j] = src[i][j];  }  }  Version B:  for(i = 0; i < 512; i++) {  for(j = 0; j < 512; j++) {  dst[j][i] = src[j][i];  }  }  i knew how to time it based off of an example from one of the classes but have never seen something in the format of ""dst[j][i]"" so i don't know what to declare dst as. like i mentioned, i only know really basic java due to class track changes so i have to kinda figure out C on my own as i go along."
C_Programming,344kz6,sftrabbit,3,Tue Apr 28 07:37:14 2015 UTC,"dst[j][i] is also something you were encounter in Java, although you declare it differently in Java. dst is called an array (specifically a two-dimensional array)."
C_Programming,344kz6,sftrabbit,1 point,Tue Apr 28 07:38:45 2015 UTC,"yeah we never got to array's in the class i was in so that explains a bit. ill look it up and try to figure it out, ill report back if i have any other questions. thanks :)"
C_Programming,344kz6,chalk46,1 point,Tue Apr 28 07:43:59 2015 UTC,"did a bit of research, made up an array, and got it to compile but get an ""segmentation fault (core dumped)"" error. i read up that it means i tried to access memory that i do not have access to but not quite sure where the error lies. anything in particular jump out at you? http://i.imgur.com/SkpbM9r.png"
C_Programming,344kz6,hardboy95,3,Tue Apr 28 08:42:45 2015 UTC,"You are only declaring the arrays to be 3 by 3. In the for loop you going way outside of that, for example, by assigning to dst[511][511]"
C_Programming,344kz6,zifyoip,1 point,Tue Apr 28 08:44:39 2015 UTC,"ohh ok. but if im doing a 512 by 512 array, does that mean i have to define all 262144 values of the array? can't imagine that is wise or what he wants us to do o.0 because im pretty sure we aren't supposed to change the ""512"" in the for loops  edit: changing the 512 to 3 in the for loops did clear up the error however. did it as a test"
C_Programming,344kz6,hardboy95,1 point,Tue Apr 28 08:50:53 2015 UTC,"Have you been asked to do this assignment before you've been taught  arrays? That seems strange, but if so, then I guess you're expected to search for something like ""C square brackets"", which gives you loads of results about arrays."
C_Programming,344kz6,zifyoip,1 point,Tue Apr 28 07:43:10 2015 UTC,"its hard to explain. depending on your specific major they altered the course tracks differently. originally i wasn't supposed to be taking this class but after they messed with everything i ended up in it. i was supposed to be taking 3 semesters of java but ended up with only 1, no class on C, but then ended up in a class where they expect you to already know C before going into it. so they expect you to already know arrays and such but a handful of us know nothing about them. this is more of a hardware/assembly course but they throw C projects at us and we either have to already know it or figure it out :/"
C_Programming,344kz6,hardboy95,1 point,Tue Apr 28 07:56:44 2015 UTC,That's a bit different because here they have been given the line that has dst[i][j] and they need to declare the variables.
C_Programming,344kz6,zifyoip,1 point,Tue Apr 28 07:37:16 2015 UTC,This link may be of some help.
C_Programming,344kz6,zifyoip,1 point,Tue Apr 28 12:46:14 2015 UTC,You cannot use variables in declaration of array. At the beginning of the code you must precisely assign its value. It's a  'beauty' of C. You can also make dynamic array but you must use pointers and function like malloc to assign a field in memory. I recommend you read e.g. K&R's book
C_Programming,344kz6,hardboy95,2,Tue Apr 28 07:57:38 2015 UTC,You cannot use variables in declaration of array.   This has not been true since 1999. Variable-length arrays were introduced in C99 and have been part of the language since then. (It is true that they were made optional in C11.)
C_Programming,344kz6,zifyoip,1 point,Tue Apr 28 10:01:51 2015 UTC,I mean that he cannot simply do this:     int n = 5;     int array[n]; Am I right?
C_Programming,344kz6,hardboy95,1 point,Thu Apr 30 15:46:42 2015 UTC,That is perfectly legal in C. That is a variable-length array.
C_Programming,344kc9,rockstarforlife,2,Tue Apr 28 06:28:51 2015 UTC,"Hi, I did this program for my class, now i have to change it all to pointer notation. Im having trouble with replacing ""array[i]"" with pointer notation in my functions.. how do you increment pointers like you do with a for loop array[i]? -thanks   I didn't take the time to read your code because of the formatting and the size. If you're asking a simple question, you should post a simple, well formatted piece of code, and then turn an answer about that piece of code to your larger project.   array[i] is by definition *(array+i). Arrays can be converted implicitly to a pointer to the first element of the array. To explain:   If you say *array that is the same as accessing the first element of the array since array will be converted to a pointer to the first element then dereferenced. Pointers have some special arithmetic operations, called pointer arithmetic. array+1 will be a pointer to the second element of the array. For example, suppose array is an array of 4 ints (and say ints are 4 bytes) arranged in memory as:    10   40  -23  145 0x10 0x14 0x18 0x1C   Then:  printf(""%p\n"", array);   // prints 0x10 printf(""%d\n"", *array);  // prints 10 printf(""%p\n"", array+2); // prints 0x18 printf(""%p\n, array+4);  // prints 0x20    Note: it's okay to take the address of the ""one past the end"" of the array, but it is illegal to dereference it."
C_Programming,344kc9,wgunther,1 point,Tue Apr 28 07:12:11 2015 UTC,"yea sorry i should have been more specific.. heres what im talking about..   void strfilter (char *arr, char *s2,char c) {  for (int i=0; i <= 20; i++) {  for (int q = 0 ; q <=40; q++){     if (s2[i]== arr[q]){          arr[q]= c;}     else         continue; }   } }  /////////  how do i take ""if (s2[i]== arr[q])"" and replace it with pointers and still be able to increment them. and with your answer im thinking of trying             this          ""if (*s2+i== *arr+q)"""
C_Programming,344kc9,javawag,2,Tue Apr 28 07:49:22 2015 UTC,"I have to admit - this isn't the clearest question! I'll give it a go though.  You're sort of missing the point(er) here. With the array, you are taking the first element, and using the [] operator to get the nth element (i.e. s2[2] is the 3rd element, s2[1] is 2nd, s2[0] is 1st, etc.).   A pointer which is used in the way you want to use it, i.e. sort of like an array, points to the first array element.  char *c = s2; // <- *c is now identical to s2[0]   So, from our c, how do we get s2[1]? Well, we can use c[1] just as we did with the array! And as /u/wgunther points out, because c[i] == *(c+i), we can do:  char secondChar = *(c+1); //<- note, NOT *c+1 which means (*c) + 1!   secondChar will be the same as c[1] here, because all we are doing is incrementing the pointer by 1, and then dereferencing. This means, we could do this:  c++; // Increment c pointer by 1, this now points at the next (i.e. second) array element char secondChar = *c; // Get the current (2nd) char   Now if you use c[0] or *c, you're dereferencing the second element, because we've moved the pointer along by one position.  I think if you read the above a few times, drink a few espressos, read them again sideways, and then squint slightly you'll probably work this out, but here's for the spoiler:  You don't need i. At all. Instead of incrementing i and then using that with the [] operator (c[i]), you just increment the pointer (i.e. c++), and dereference it (*c) to get the current value.  The only problem with this is, without using i, you may not know where the string ends. Luckily, in C, strings always (or should always!) end in the NUL character, '\0'. So, you should check each time if *c == '\0', and break from the loop when it is.  Hope this helps! Remember, C is way easier than it looks. Once you nail this whole pointer/array dereferencing, you're 90% of the way there so don't give up!"
C_Programming,344kc9,awwtowa,1 point,Tue Apr 28 09:23:32 2015 UTC,"This isn't the answer to your question and I won't answer it because I don't like giving answers out. By here is an example of how pointer arithmetic works in C. I didn't check work below, I just did it off the top of my head.   char *var = malloc(sizeof(char) * 100); // forms an array of 100 chars. Equivalent to char var[100];  char * head = &var; // head pointer points to the head of the array  char * cur = var; // Cur now points to the head of the array. We will use this as a cursor to navigate the array.  // Fill the array with values  for (int i = 0; i < 100; i++) {  *cur = i; // this is equivalent to cur[i] = i  printf(""Cur is:%d"", cur);  cur++; // this is incrementing the pointer address by 1. So we're moving the cursor to the next  index in the array.  }  // Let's replay what we entered in the array.   cur = head; // cur's pointer address now is at the head of the array  for (int i = 0; i < 100; i++) {  printf(""Cur is:%d"", cur); // print cur[i]  cur++; // increment cur's pointer address by 1.   }  // Let's check if index 3 in the array = 3  printf(""Cur[3] = %d"", *(cur+3));  So in memory it looks like  address | value  0x0        | 0     <<< Pointer head always points to address 0x0  0x1        | 1       0x2        | 2      <<< if cur is here, it is the same as cur = (head + 2). To deference the pointer, you add can do *(head+2)."
C_Programming,343rzs,Snappel,3,Tue Apr 28 01:54:50 2015 UTC,"Unless they're in another file, you're never defining those variables."
C_Programming,343rzs,raevnos,1 point,Tue Apr 28 06:36:06 2015 UTC,"I'm pretty new to writing code, but I thought they were being defined with 'extern char' in global.h. I suppose that's not the case? Where and how should I go about defining these variables? This is some older code that I have updated to a newer architecture so I can change a couple lines out for our new firmware chip."
C_Programming,343rzs,Rhomboid,4,Tue Apr 28 12:07:16 2015 UTC,"I thought they were being defined with 'extern char' in global.h. I suppose that's not the case?    No.  Those are declarations, not definitions.  The whole point of using extern in this context is that it turns a definition into a declaration.  And that's what you want in a header, because a header is meant to be included in multiple translation units, and if it included definitions then that would result in multiple definition errors.  (Note: some systems put global definitions in common sections which masks this error, but it's still an error.)  In C, if you want to use a global variable, you need a declaration in every translation unit that will access the variable, and a definition in exactly one translation unit.  That's usually done by putting a line like extern int foo; in a header which is included in every TU that accesses the variable, and then by putting a line like int foo; in exactly one .c file, not a header.  That takes care of the definition.  The definition is what actually causes memory to be allocated for the symbol, and for it to exist in the symbol table as 'defined'.  Symbols that are never defined result in undefined symbol errors from the linker.  Symbols that are only ever declared exist in the symbol table as 'undefined', which means when the linker needs to resolve the address of that symbol it cannot, because nobody ever allocated it anywhere, hence the undefined symbol error."
C_Programming,341cyz,rhascal,5,Mon Apr 27 15:14:45 2015 UTC,"Neither of those platforms are great if your goal is just to learn C. They're both interesting for other reasons, but not that one.  If you want to write C code, install linux on a PC or virtual machine, and you'll be able to compile, run, and debug it with plenty of resources at your disposal.  RPI is like an embedded linux device. You could write C on your linux PC, and it'll probably transfer over to the RPI relatively easily.  Arduino is an 8 bit CPU ( Atmel AVR ) typically, and is a wholly different beast. The Arduino language is called ""Processing"", and is very C like but not straight C. If you want to learn embedded C, it's a decent path to start down. Once you make a project or two, ditch the Arduino IDE and start using avr-gcc and avr-libc directly."
C_Programming,341cyz,jdonniver,2,Mon Apr 27 16:32:09 2015 UTC,"The Arduino language is called ""Processing"", and is very C like but not straight C.   It's a mix of C and C++. You can write plain C for the arduino."
C_Programming,341cyz,jotux,3,Mon Apr 27 23:44:14 2015 UTC,What do you want to do with it?
C_Programming,341cyz,Narishma,1 point,Mon Apr 27 15:22:56 2015 UTC,"I'd like to dabble in basic robotics, I haven't looked into it much yet, can either of those work for that?"
C_Programming,341cyz,naleag,3,Mon Apr 27 15:24:32 2015 UTC,"Arduino is literally meant for basic robotics and basic (to complex) electrical circuits additionally it's meant to be cheap. Though you don't actually work on a Arduino you work on a laptop with the arduino developer environment then load (flash) your program to the arduino board.  RPI can do basic robotics but it's more geared complex systems plus it's more expensive for the break out board and what not. You would be writing C code on the RPI its self and executing it from the RPI since it's a literal self contained computer.   I see a lot of people play with Arduino's first and build cool and silly devices and then for more serious projects (Home Theatre, Classic Arcade Machine, Home Automation) use RPI.   Also, if the RPI isn't powerful enough for your needs, there's always an oDroid."
C_Programming,341cyz,koffiezet,5,Mon Apr 27 15:39:12 2015 UTC,"An Arduino is not that much cheaper than a RPi... The moment you need a network connection though, you should consider the RPi. You can also use the GPIO pins on the RPi directly without a breakout board if you're careful (but it's very easy to fry the main CPU if you do something wrong here).  It's mostly a question of what you're trying to do. An arduino can do stuff better than the RPi:   PWM / realtime stuff Analog readouts once a design is finished: create cheap dedicated circuit boards"
C_Programming,341cyz,MrGeekAlive,1 point,Mon Apr 27 16:41:57 2015 UTC,"Great, thanks!"
C_Programming,341cyz,elektritekt,2,Mon Apr 27 15:48:44 2015 UTC,"Having used both for simple and complex projects, I would definitely choose an arduino to learn electronics / robotics. Much easier to work with, cheaper and very well documented."
C_Programming,341cyz,awwtowa,3,Mon Apr 27 16:03:13 2015 UTC,"I suggest looking into the TI TM4C123 Launchpad eval kit. It's bare bones embedded C or ARM assembly and it comes with PWM, Quadrature Encoding, CAN, I2C, SPI. We are currently using it in a class to build a robot car running a real-time operating system. Look up Jonathan Valvano for sample code and projects.  Edit: also the board itself is like $15"
C_Programming,341cyz,chefgroovy,3,Tue Apr 28 00:37:40 2015 UTC,"The RPI is great if you want to have a upnp server for your media files, serve web content, be a VPN gateway, and at the same time, do fun things like control your lights, home entertainment system, etc. You can code in C, Python, Haskell, etc. It is almost limitless in what you can do out of box (the latest RPI runs Ubuntu out of box).  While the Arduino is like a really sharp knife. It's amazing for cutting but terrible as a hammer or as a multitool. Want to learn how to bit bang, control LEDs using PWM and logic, charge a capacitor using PWM, maybe control servo positions using a feedback PID, etc? This forces you to take into account memory, time, and priorities which are stricter and finite resources compared to a Raspberry Pi.   That said, if your goal is to learn C, then I would go for an Arduino and a PC. Everything you can do on a Raspberry Pi can be done on a PC or even a virtual machine and probably perform better. Can't be said for the Arduino where you will learn about blowing the stack, interrupt race conditions, the lack of (good/standard) dynamic memory allocators, etc. PC+Arduino, I think you will cover your educational bases. One will teach you to be frugal about resource management, while the other will let you experiment freely.   And honestly, you really can't go wrong with the RPI either. Both are very well supported and there are numerous examples on the net. But if you can only buy one, get the Arduino for the reasons above."
C_Programming,341cyz,PinkyThePig,2,Tue Apr 28 00:57:18 2015 UTC,"I haven't used the Arduino, but I know the Raspberry has a huge community  as far as help goes. And the Raspberry Pi2 is pretty robust. I'm typing this in one now.  not to sound like a shill, but.... It does C/C++ robotic controls great in console mode, , and really fast doing GUI projects with Qt, Netbeans, etc.   Just be sure get the dual or quad core if want to use as regular computer."
C_Programming,33yq3b,Clauc,2,Sun Apr 26 22:16:15 2015 UTC,Two issues: 1) Your fill_array function doesn't do what you expect. It isn't even using its arguments. 2) You are passing a[10] to fill_array but a[9] is the last element in the array.
C_Programming,33yq3b,Meefims,5,Sun Apr 26 22:34:32 2015 UTC,"You need to add & in the scanf line  scanf(""%d"", &undersok);   Also passing n to frekvens is unnecessary as you know the array is of size 10. Also you are only filling the first 9 elements of the array.  Edit: fill_array is completely misbehaving."
C_Programming,33yq3b,Don_Equis,2,Sun Apr 26 23:03:10 2015 UTC,"The fillarray function will not actually fill any array in main. You are passing two integers to it, and filling the array in a local variable. You should make this function better   fillarray( int arr[], int n)   Call it with fillarray(arr,n)   The value of n should be set before calling this function."
C_Programming,33yq3b,ranon20,2,Mon Apr 27 00:55:09 2015 UTC,"#include <stdio.h> #include <stdlib.h>  void fill_array(int arr[], int b){  int n;  for(n = 0; n < b ; n++){     arr[n] = rand()%10 + 1;     printf(""Tal: %d\n"", arr[n]); } }  void frekvens(int arr[], int undersok, int n){   int count = 0; int i;  for(i = 0; i < n; i++){     if(arr[i] == undersok)     {         count = count + 1;     }  }  printf(""\nTalet upprepades %d ggr"", count); }  int main() { int arr[10]; int n = 10; int undersok;  fill_array(arr, n);  printf(""Vad ska jag soka efter? ""); scanf(""%d"", &undersok); frekvens(arr, undersok, n);  return 0; }"
C_Programming,33yq3b,cehmu,1 point,Mon Apr 27 05:55:25 2015 UTC,"sorry, i'm only just starting to learn to code, but wanted to see if i could find the error(s) in your code and make it work.   There were a few errors.  with fill_array:  it doesn't need any return value, so declare as void (not int)  instead of passing 'int', you need to pass 'int arr[]', to pass the address of the array. that way, your random numbers will be written into your original array (because, by passing the address ie arr[], you are telling the function WHERE to write to).  and finally, your for loop doesn't need the -1, as < will not count the last number anyway.   with frekvens, you should also do the same thing.  pass the address of the array with arr[], so that the function knows where to start reading.   in your main function, you should declare n = 10 (or even better perhaps, declare n first, and then declare arr[n] next to avoid using the 10 twice)  also, you should use & with scanf, as it expects a pointer, like this:  scanf(""%d"", &undersok);  i'm only just starting to understand this stuff, and it takes a while, but i suggest you just keep going and practice as much as you can with pointers until they start to become clear.  it takes time.  everyone can do it.  just keep going :D"
C_Programming,33yq3b,cehmu,0,Mon Apr 27 06:05:49 2015 UTC,HELP
C_Programming,33yjnp,tmtwd,8,Sun Apr 26 21:22:02 2015 UTC,"Because postfix operators have higher precedence than prefix operators, so *abc++ means *(abc++), whereas ++*abc means ++(*abc). In the first expression you are incrementing the pointer abc, but in the second expression you are incrementing *abc, that is, the character to which abc points.  If you mean to say (*abc)++, then you need parentheses. Pay attention to operator precedence."
C_Programming,33yjnp,zifyoip,1 point,Sun Apr 26 21:36:06 2015 UTC,"In addition to the other reply here, there's a difference between incrementing a pointer and incrementing a character.  Incrementing the pointer makes it point to the next character in the string, hence how initially *abc == 'h', *(abc + 1) == 'e' and *(abc + 2) == 'l'.  Incrementing the character makes the character one higher.  char is just a number in memory, so doing (*abc) + 1 adds 1 to 'h', which is 'i'.  Since 'h' == 104, at least in ASCII and 'i' == 105 then that's why incrementing 'h' gets you 'i'."
C_Programming,33yjnp,lishyguy,1 point,Sun Apr 26 21:46:59 2015 UTC,"zifyoip has your answer there, but the question tells me this would be a good time for you to learn to use your debugger. Pointers aren't so confusing when you can watch what address they point to. You would also have seen the 'h' in ""hell\0"" getting incremented to 'i'. (If you don't know why that happens yet check out how the alphabet was enumerated in ASCII. Very handy.)"
C_Programming,33yjnp,f5f5f5f5f5f5f5f5f5f5,0,Sun Apr 26 21:58:06 2015 UTC,There's also something weird about your string: thing is 5 characters long but strlen( &thing ) is 3.
C_Programming,33yjnp,zifyoip,1 point,Sun Apr 26 23:44:33 2015 UTC,"You mean strlen(thing), not strlen(&thing)."
C_Programming,33yjnp,f5f5f5f5f5f5f5f5f5f5,1 point,Mon Apr 27 00:31:58 2015 UTC,"Yes, thanks."
C_Programming,33yjnp,moocat,1 point,Mon Apr 27 00:42:25 2015 UTC,"The example has four explicit characters as \0 represents the NUL character.  C strings are NUL terminated, so it doesn't consider the explicit NUL part of the string, thus strlen returns 3 for h, e and l.  A C compiler will automatically add a NUL character to a string literal so specifying it is usually redundant."
C_Programming,33yjnp,f5f5f5f5f5f5f5f5f5f5,1 point,Mon Apr 27 04:58:25 2015 UTC,That's why it's weird.
C_Programming,33yjnp,dreamlax,1 point,Mon Apr 27 10:53:08 2015 UTC,strlen(thing) == 3 but sizeof thing == 5.
C_Programming,33xnpq,td00,25,Sun Apr 26 17:02:44 2015 UTC,"Run your program with valgrind, checking leaks. It's awesome!"
C_Programming,33xnpq,clm100,9,Sun Apr 26 17:05:47 2015 UTC,"No, this isn't freeing all the memory. Specifically, it's freeing the memory in the specific node passed -> the first node in list. You probably want to iteratively (or recursively) go through each node and free them from bottom up"
C_Programming,33xnpq,FreedomV2,5,Sun Apr 26 18:18:01 2015 UTC,What's the purpose of calling your destroy function rather than just calling free directly?
C_Programming,33xnpq,zifyoip,5,Sun Apr 26 17:07:19 2015 UTC,"I am more comfortable doing it that way as well, but for the sake of this project it has to be done with a function."
C_Programming,33xnpq,zifyoip,5,Sun Apr 26 17:26:21 2015 UTC,"What is the destroy function supposed to do? Is it supposed to free a single node, or free the whole list? Because right now it just frees a single node."
C_Programming,33xnpq,SeriousBug,1 point,Sun Apr 26 17:27:36 2015 UTC,"It is supposed to free the whole list, that's exactly what I'm trying to figure out.  That's what I thought was happening... now I just gotta figure out how to free the others."
C_Programming,33xnpq,Tuna-Fish2,10,Sun Apr 26 17:46:11 2015 UTC,"You have to free everything you allocated. This means that you need to call free as many times as you called malloc, no more, no less."
C_Programming,33xnpq,Chooquaeno,2,Sun Apr 26 17:50:29 2015 UTC,Wouldn't it only need to be used once in the     destroy     function?  Since each pointer is being passed through it.
C_Programming,33xnpq,zifyoip,8,Sun Apr 26 18:08:17 2015 UTC,"It needs to be dynamically called exactly as many times as malloc. That is, you don't need to have as many free() calls in the source code, but during runtime you need it to happen as many times as malloc.  For a quick debug test, add these to the top your file:  static int a;  void * malloc_(size_t s){     a++;     return malloc(s); }  void free_(void * p){     a--;     free(p); }   use malloc_ and free_ in your code instead of the originals, and then add a printf(""%d\n"",a); to the end of main. If it's not zero, you have a problem.  To fix this, destroy (which is a bad name, if it's a function meant to clear lists, call it destroy_list instead) has to iteratively or recursively walk over the list."
C_Programming,33xnpq,nevinera,2,Sun Apr 26 19:32:26 2015 UTC,"It doesn't matter whether free is called in a function or otherwise; for each malloc() call, you need a corresponding free() call."
C_Programming,33xnpq,nevinera,2,Sun Apr 26 19:21:43 2015 UTC,"Since each pointer is being passed through it.   What do you mean by this? Do you mean that a pointer to each node in every list is individually being passed to the destroy function? Where is that happening?  Or do you just mean that a pointer to the first node of each list is being passed to the destroy function? Because if that's what you mean, then you are freeing only the first node of each list."
C_Programming,33xnpq,Don_Equis,6,Sun Apr 26 18:11:21 2015 UTC,"void destroy(Linky *p) {   Linky *n = NULL;   while (p != NULL) {     n = p->nextPtr;     free(p);     p = n;   } }   Starting with a link pointer (which might be null): record the next pointer, free the current element, make next current. You want to stop whenever the pointer you are about to dereference is NULL."
C_Programming,3414m0,sonnedan,5,Mon Apr 27 14:06:54 2015 UTC,This is /r/C_Programming. Neither Visual Basic nor C# is C programming.
C_Programming,3414m0,zifyoip,-1,Mon Apr 27 14:34:10 2015 UTC,"Oh i am so sorry, i just though people knew how to program in C#. they are kinda alike."
C_Programming,33t4a8,Shtreimel,31,Sat Apr 25 10:42:07 2015 UTC,"The standard (C11 7.21.6.2 The fscanf function /10) says that:   If this object does not have an appropriate type, or if the result of the conversion cannot be represented in the object, the behavior is undefined.   There is a problem with the code, as scanf has no way to know at run-time that &a is a pointer to a char rather than a pointer to an int. As ""the behavior is undefined"", the program is technically free to do whatever (""it is legal for it to make demons fly out of your nose""). It depends on the compiler, OS and so on.  It probably won't actually crash, at least not immediately. Rather, it will write an int to the stack instead of a char, overwriting whatever is after the place where the char should be (assuming that sizeof(int) > sizeof(char), which is very likely). That might make the program crash later, or it might have no effect and go unnoticed (that is, until you switch to a different compiler which does things in a slightly different way)."
C_Programming,33t4a8,414RequestURITooLong,5,Sat Apr 25 11:17:41 2015 UTC,"A char on the stack will (typically) be the same size as an int (the native register size), so the code should (typically) work completely fine on a lot of platforms."
C_Programming,33t4a8,angdev,6,Sat Apr 25 18:43:57 2015 UTC,Gave it a try in Xcode on OS X. The scanf call hangs indefinitely. Interrupting it with the debugger you find execution stopped on a jae instruction in a function called read_nocancel.
C_Programming,33t4a8,reddilada,4,Sat Apr 25 22:44:39 2015 UTC,I just tried this and my neighbors house caught fire and burned to the ground.
C_Programming,33t4a8,Don_Equis,5,Sat Apr 25 23:45:46 2015 UTC,I tried passing that address to first responder but it couldn't reach the site. Maybe you need to add a rule in your firewall?
C_Programming,33t4a8,angdev,2,Sun Apr 26 01:11:01 2015 UTC,"No. A char in the stack will typically be of size 1. Probably because the function call alligns the stack that it causes no error. But run a code like  int main (void) {     char d, c, b, a;     a = b = c = d = 'a';     scanf(""%d"", &a);     printf(""%c%c%c%c\n. a, b, c, d);     return 0; }   When calling a function, though, a char and an int will have the same size in x86_64 on Linux and OS X for sure (don't know Windows).  Edit: I know in GCC 5 the ABI is changed, but I don't know how. This example may be affected."
C_Programming,33t4a8,Don_Equis,1 point,Sun Apr 26 10:13:32 2015 UTC,"Mmm maybe I should have been a bit more clear. The size would still be 1 byte on the stack, but there will be additional bytes padding the 1-byte to be aligned with the register size (or memory size). Which means when scanf is called with an int the extra bytes on the stack over-written will be the padding, so nothing bad will happen."
C_Programming,33t4a8,DSMan195276,1 point,Mon Apr 27 19:09:59 2015 UTC,"The padding is there because there's a function call. Without the function call or with extra chars as in my example, there would be no padding. This is enforced by the ABI. In other operating system there could be no padding. I think we agree in this.  Though, it still is undefined behavior."
C_Programming,33t4a8,5225225,17,Mon Apr 27 19:59:39 2015 UTC,"The answer is really that you have no way of knowing what will happen. The big catch is that that scanf() is going to write 4 bytes to the location pointed-too by &a, and that only points to one byte you actually declared. The compiler is allowed to do lots of fun things to your code which assume situations like this don't ever happen, meaning that whether or not this crashes and what it does if it doesn't crash is completely compiler dependent.  For a fun example, here's a simple piece of code which does what you described:  #include <stdio.h> int main() {     char a = 0, b = 0, c = 0, d = 0;     scanf(""%d"", &a);     printf(""%d | %d | %d | %d\n"", a, b, c, d); }   Fairly simple. A simple compile with default settings gives this result:  dsman195276@Laptop ~ $ gcc ./test.c -o ./test ./test.c: In function ‘main’: ./test.c:7:5: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘char *’ [-Wformat=]      scanf(""%d"", &a);      ^ dsman195276@Laptop ~ $ ./test 2049 1 | 8 | 0 | 0   That works like you'd ""expect"", it overwrites a, which ends up writing to 'b' contained on the stack. Now let's try it again, but with -O2:  dsman195276@Laptop ~ $ gcc ./test.c -o ./test -O2 ./test.c: In function ‘main’: ./test.c:7:5: warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘char *’ [-Wformat=]      scanf(""%d"", &a);      ^ ./test.c:7:5: warning: ignoring return value of ‘scanf’, declared with attribute warn_unused_result [-Wunused-result] dsman195276@Laptop ~ $ ./test 2049 1 | 0 | 0 | 0 *** stack smashing detected ***: ./test terminated   What gives? -O2 actually makes the program crash and prints something different. The crash is because of some code gcc inserts called the 'stack-protector'. It basically just checks if some places on the stack changed that weren't supposed to change, and then throws a 'stack smashing detected' error and crashes if any of them changed. The print-out of ""1 | 0 | 0 | 0"" is due to a separate optimization - Because no code ever modifies b, c, and d, and gcc knows it's illegal to access those variables through &a, because you'd be writing past the end of a which is illegal, so it completely removes those variables from the code and just passes 0 directly to printf. So it turns your code into this:  #include <stdio.h> int main() {     char a = 0;     scanf(""%d"", &a);     printf(""%d | %d | %d | %d\n"", a, 0, 0, 0); }   A valid program would never change the values of the variables b, c, and d, so this is a valid optimization. Because your program is not valid, however, using -O2 in this case changes the output of your program.  Edit: I should have pointed out - That second optimization that removed b, c, and d from the stack is actually what triggered the crash to happen. The 'stack-protector' is basically just an extra variable placed on the stack by gcc. gcc sets it to some value before the function's code runs, and then checks that it's the same value when the function returns, as a simple somewhat crude guard against to write past the end of the stack (If we did write past the end of the stack, it would end-up changing the stack-protector value). Our example code breaks this rule, because we write past the end of a. The catch is that if b, c, and d are on the stack, then we write to these locations and never write past the end of the stack. Without b, c, and d there, only a is on the stack, and the stack-protector is placed right after a, leading to us writing the '8' to the stack-protector instead of b, and crashing the program."
C_Programming,33t4a8,DSMan195276,3,Sat Apr 25 17:06:41 2015 UTC,"I don't get that output with GCC. With just gcc without -O2, I get  1 | 0 | 0 | 8   With -O2 I get  1 | 0 | 0 | 0  test.c:5:17: warning: format specifies type 'int *' but the argument has type 'char *' [-Wformat]     scanf(""%d"", &a);            ~~   ^~            %s 1 warning generated. 1 | 0 | 0 | 0   For clang, with -O2 I get  test.c:5:17: warning: format specifies type 'int *' but the argument has type 'char *' [-Wformat]     scanf(""%d"", &a);            ~~   ^~            %s 1 warning generated. 1 | 0 | 0 | 0 zsh: done                echo ""2049"" |  zsh: segmentation fault  ./test1   Weird. What versions are you running?  GCC: 4.9.2 clang: 3.6.0"
C_Programming,33t4a8,sudotouch,3,Sat Apr 25 22:42:21 2015 UTC,"I'm using gcc 4.9.0 on a Gentoo system. From other tests I've done with gcc, I know that it reorganizes variables on the stack to provide faster access to them. I guess for whatever reason 4.9.2 reorganizes these variables slightly and puts d in the memory location directly after a. Since they're never used it doesn't really matter the order."
C_Programming,33t4a8,FUZxxl,1 point,Sun Apr 26 00:26:18 2015 UTC,Well said.
C_Programming,33t4a8,mkfifo,8,Sun Apr 26 06:08:20 2015 UTC,"scanf(""%d"", &a) invokes undefined behaviour because of an argument type mismatch (cf. ISO 9899:2011§7.1.4/1): The directive %d requires the corresponding argument to be a pointer to a signed integer, i.e. an int (cf. §7.21.6.2/12) but you supply an argument of type “pointer to character” which is undefined behaviour.  The printf call is fine: You supply an argument of type “signed integer” (due to argument promotion) which is what %c expects."
C_Programming,33t4a8,EkriirkE,5,Sat Apr 25 11:14:11 2015 UTC,"Your teacher is wrong in that there is no guarantee of crashing, right in that this is a malformed program.  In c you cannot always just observe the behaviour of the code at runtime, as you end up observing a single instance of an implementation.  This example invokes undefined behaviour in the call to scanf as the format string and variable type do but agree.  The correct answer here is that the code might kill your cat."
C_Programming,33t4a8,Websly,2,Sat Apr 25 12:47:06 2015 UTC,"Memory alignment and platform dependent.  So many different results: Say char is 1 byte, %d wants 2 bytes.      scanf will overrun a and put garbage in the the next memory byte.  if the machine is little endian ""a"" will receive the correct value so long as it is (128)-127.  A big-endian machine will populate ""a"" incorrectly.      if a resides at the end of the variable memory location, scanf may cause an crash/illegal memory access error, stack will be corrupt if variable are placed here, as they sometimes are, and program will crash trying to return/jump to a now invalid address.     If other variables reside next to ""a"" in memory the one next to it will become corrupted/altered...    tl/dr: it could work, it could not.  undefined"
C_Programming,33t4a8,egonelbre,3,Sat Apr 25 18:13:41 2015 UTC,There could be a crash.  you're allocating a single byte (a). The scanf will write 4 bytes to that location. That means it will overwrite the 3 bytes following the 'a' variable. Whether the program will crash or not depends on what data is stored in those 3 bytes.
C_Programming,33t4a8,egonelbre,1 point,Sat Apr 25 11:18:02 2015 UTC,"Alright, thank you everyone for the answers, now I'll know what to answer if I get this kind of question in the upcoming exam. :)"
C_Programming,33t4a8,414RequestURITooLong,1 point,Sun Apr 26 14:06:17 2015 UTC,"It depends on how scanf is exactly implemented.   Short answer, both answers are correct...  Longer answer. char a would be (usually) somewhere on the stack - since it is a simple program there is probably plenty of room available for the rest of 3 bytes that is gotten from scanf. Although that operation may overwrite some other value on the stack. For example try running this program:  int main(int argc, char const *argv[]) {     char a, b, c, d;     a = '#'; b = '#'; c = '#'; d = '#';     scanf(""%d"",&a);     printf(""%c|%c|%c|%c\n"", a, b, c, d);     return 0; } // e.g. // f:\x\mainc>a.exe // 214212521 // ®|♀|─|¤   Essentially the program will work - but it is unlikely that it will do what you wanted it to do.  Of course, if the compiler is smarter - it might check that you shouldn't be passing a char pointer as an integer pointer and fail to compile. Alternatively it might crash at runtime as well, if some additional checks are provided."
C_Programming,33t4a8,egonelbre,7,Sat Apr 25 11:04:20 2015 UTC,"After bit of experimenting:  gcc 4.8.1 compiled and ran the program with no specific errors for this.  Withgcc 4.8.2and clang shows an error for doing it:  main.c:6:6: note: include the header <stdio.h> or explicitly provide a declaration for 'scanf' main.c:6:17: warning: format specifies type 'int *' but the argument has type 'char *' [-Wformat]         scanf(""%d"",&a);                ~~  ^~                %s   So if you have turned warnings into errors (-Werror) it will fail to compile.  Compiling it with address sanitizer (gcc -fsanitize=address main.c) will make it crash at runtime.  tl;dr; the behavior is unspecified by the C standard and hence the behavior is unspecified."
C_Programming,33pkb1,LiquidClimber,2,Fri Apr 24 13:36:04 2015 UTC,It will help if you have sample inputs and the corresponding outputs.
C_Programming,33pkb1,fnord123,1 point,Fri Apr 24 14:01:16 2015 UTC,"if you run it it prints a long list of numbers, then it prints the total. the total is not equal to the number of printed numbers. changing the seed gives a different list of numbers which an equally wrong total"
C_Programming,33pkb1,fnord123,4,Fri Apr 24 14:06:38 2015 UTC,"Sounds an awful lot like a homework assignment. If you're in school and learning and stuff, try not to cheat by using this code but come up with your own version.  In any event, I think this does what you want.  #include <stdio.h>                                                               #include <math.h>                                                                #include <stdlib.h>                                                               static int randomInt(int max) {                                                      return (rand() % max);                                                       }                                                                                 static int wrap(int val, int min, int max) {                                         if (val > max) {                                                                     return min;                                                                  }                                                                                if (val < min) {                                                                     return max;                                                                  }                                                                                return val;                                                                  }                                                                                 static int nextpos(int cur, int min, int max) {                                      int move = (randomInt(2) == 0)? 1 : -1;                                          int next = wrap(cur + move, min, max);         return next;                                   }                                                                                 static int sum(int* beg, int* end) {                                                 int s = 0;                                                                       int* p = beg;                                                                    while(p != end) {                                                                    s += *p++;                                                                   }                                                                                return s;                                                                    }                                                                                  void main() {                                                                        int positions[10] = {0};                                                         int min = 1, max = 10;                                                           size_t count = 0;                                                                int cur = 1;                                                                            while( sum(positions, positions+max) < ((max+1)-min)) {                       cur = nextpos(cur, min, max);                                                    positions[cur-min] = 1;                                                              printf(""%d\n"", cur);                                                             count++;                                                                     }                                                                                printf(""\nThe number of steps is %d\n"", count);                              }    I get 97 w/ seed set to 1 but we could have different random number generators so who knows whether it's what you get too."
C_Programming,33pkb1,dumsubfilter,0,Fri Apr 24 15:00:23 2015 UTC,for (nn=1; total<10; nn++){   How many times does that loop run?   Trying to figure out the code for counting the number of steps it takes to reach all positions at least once.    You are making this way too complicated.  int path[ LENGTH ] = { 0 }; int visited = 0; int here = rand() % LENGTH; while( visited < LENGTH ) {     if ( path[ here ] == 0 )         visited++;     path[ here ]++;     here = here == 0 ? 1 : here == LENGTH -1 ? here-- : rand() % 2 == 0 ? here - 1 : here + 1; }   Seems legit.
C_Programming,33mqi3,EamonRocks,2,Thu Apr 23 19:54:13 2015 UTC,Look up <sys/time.h>. That should give you a start.
C_Programming,33mqi3,f5f5f5f5f5f5f5f5f5f5,1 point,Thu Apr 23 21:26:36 2015 UTC,Ill take a look when im not in a rush and meeting a deadline hehe. Thanks!
C_Programming,33mqi3,zenkibudo,1 point,Fri Apr 24 00:51:14 2015 UTC,could do something like so:  #define ONE_HOUR 60*60*CLOCKS_PER_SEC  long start = clock();  if(clock() - start > ONE_HOUR ) {      //...tell user....
C_Programming,33mqi3,Don_Equis,2,Thu Apr 23 22:26:35 2015 UTC,Nice! So simple! Thank you very much!
C_Programming,33kwrc,-AcodeX,12,Thu Apr 23 10:32:27 2015 UTC,"What you're building there is called a ""linked list"". That term should help you find lots of info about them.  I don't follow what you're doing with the pointers. Normally you'd define the nodes like:  typedef struct node {     int value;     struct node *next; } node;  node *oneNode, *twoNode, *threeNode;   After allocating memory for them you can fill them out like:  oneNode->value = 1; oneNode->next = twoNode;  twoNode->value = 2; twoNode->next = threeNode;  threeNode->value = 3; threeNode->next = NULL;   Normally you iterate through a list with a loop, but if you want to directly refer to threeNode from oneNode you'd write oneNode->next->next for example:  i = oneNode->value; // i gets set to 1; i = oneNode->next->value; // i gets set to 2; i = oneNode->next->next->value; // i gets set to 3;  oneNode->next = oneNode->next->next; // oneNode gets linked to threeNode. twoNode cut out from list."
C_Programming,33kwrc,BigPeteB,7,Thu Apr 23 11:31:57 2015 UTC,"Awesome!  I was attempting to narrow down my specific question as much as possible, I do know I'm making a linked list :) I've gotten most functionality working with a singly linked list, and I was able to sort by altering the values themselves. I really want to learn the manipulation of and with pointers more thoroughly, so I wanted to try it this way.  I didn't typedef them after reading something typedef possibly being dangerous (I read this a while back, I can't actually prove that it's true, but I don't mind typing 'struct node', and I figure it's a good reminder that nodes are a struct I defined whenever I use them)  I can't believe the answer was that simple the whole time! I never found anyone using that in my searches, and I never tried that syntax because I thought it was far too simple to actually work, especially after having to use the (*pnode)->next with the pointer-to pointer.  Thank you for the help!"
C_Programming,33i0pg,bartmanx,14,Wed Apr 22 18:03:42 2015 UTC,"Please do everyone you ever work with a favor, and never ever ever use these ""idioms""."
C_Programming,33i0pg,graycode,8,Wed Apr 22 23:09:16 2015 UTC,Literally none of these should ever be used.
C_Programming,33i0pg,Ubertekk,2,Thu Apr 23 00:50:43 2015 UTC,This looks a bit like Template Meta Programming in C++. I hate this.
C_Programming,33i0pg,net_goblin,1 point,Thu Apr 23 08:59:20 2015 UTC,"better off just writing programs to generate code, frankly"
C_Programming,33ixva,rsheeler,9,Wed Apr 22 22:03:27 2015 UTC,"I think you are misunderstanding how pointers work. Pointers point to data, but are themselves a normal value.  Think of a pointer as an integer.  void assign(int link) {     link = 0x4F5920; //some value you are assigning it }   As you can probably assume, assigning a value to that integer has no effect on the integer that was passed to it.  You can solve the problem by instead passing a pointer to the node to the assign function (without having to get into pointers to pointers).  void assign(struct Node *node) {     char *string  = ""hello"";     node->ptr = string; }   In this case you are passing the node by pointer, so you access it's internals, you are accessing the actual object, which if you change will change the memory the original object uses. So you are changing the value of the data that the Node pointer points to, and at the same time changing the value of the pointer inside the node.  Alternatively. You could just pass a pointer to the pointer and change the data of the pointer you passed to the function to change where the original pointer points.  void assign(void **link) {     char *string  = ""hello"";     *link = string; } // ... snip ... assign(&new.ptr)"
C_Programming,33ixva,chasesan,5,Wed Apr 22 22:23:09 2015 UTC,"As written the assign function doesn't do anything that requires information from outside itself, meaning it's unnecessary to pass arguments into it at all.  It should simply return the pointer.  char* assign(){     return ""hello""; }  new.ptr = assign();"
C_Programming,33ixva,chasesan,2,Thu Apr 23 01:02:17 2015 UTC,"That is certainly true, but I tried to keep my code as close as possible to what he had. :)"
C_Programming,33ixva,ponyoink,6,Thu Apr 23 01:12:50 2015 UTC,The problem with your code is that you are not changing the value of ptr in the function; you are changing a local variable.  But you have to explain what isn't allowing means for you if you want real help.
C_Programming,33hcaf,cow_co,40,Wed Apr 22 15:05:48 2015 UTC,"You're going to have a hard time throwing a custom exception in C, considering that the language doesn't have exceptions at all. :)"
C_Programming,33hcaf,Aransentin,21,Wed Apr 22 15:14:48 2015 UTC,"Let's phrase it more positively: anywhere you can throw an exception, you can throw a custom exception in exactly the same way!!!"
C_Programming,33hcaf,clm100,5,Wed Apr 22 16:18:33 2015 UTC,oh shit.  I had no idea -_-.  Welp.  That's that then :P
C_Programming,33hcaf,bigbassdaddy,2,Wed Apr 22 15:33:27 2015 UTC,http://www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html
C_Programming,33hcaf,uncathartic,3,Wed Apr 22 17:41:28 2015 UTC,"Well, sure you could implement exceptions yourself, but I doubt that's what OP is looking for."
C_Programming,33hcaf,chasesan,4,Wed Apr 22 18:03:30 2015 UTC,"C doesn't have exceptions, so throwing one at all would be impressive."
C_Programming,33hcaf,bigbassdaddy,2,Wed Apr 22 17:11:33 2015 UTC,http://www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html
C_Programming,33hcaf,chasesan,3,Wed Apr 22 17:41:44 2015 UTC,"My comment stands. Though it would be more impressive if it could pass it up the call stack, or have nested try/catch."
C_Programming,33hcaf,bigbassdaddy,1 point,Wed Apr 22 22:27:46 2015 UTC,haha!
C_Programming,33hcaf,CatsAreTasty,5,Wed Apr 22 17:34:13 2015 UTC,In C we use [setjump/longjump](www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html) to implement exception handling.
C_Programming,33hcaf,bboe,3,Wed Apr 22 17:40:52 2015 UTC,"If you want exceptions, you will need C++."
C_Programming,33hcaf,theseoafs,1 point,Wed Apr 22 16:17:08 2015 UTC,"Ok, thanks.  Unfortunately, we're restricted to using C in the assignment.  Exceptions aren't vital to what I wanted to do, I just thought they might have been nice."
C_Programming,33hcaf,thrakkerzog,3,Wed Apr 22 16:24:58 2015 UTC,"A common pattern in C is to set errno and return -1 from a function to indicate there is an error. While -1 could indicate a valid return value, it's only an error if the return is -1 and errno != 0.  http://stackoverflow.com/questions/9856822/should-i-set-errno"
C_Programming,33hcaf,FUZxxl,7,Wed Apr 22 17:37:39 2015 UTC,Yeah but don't do that.  errno is really stupid and global state is really stupid.  Return a dedicated error code if a function you write needs to handle an error case.
C_Programming,33hcaf,Axman6,1 point,Wed Apr 22 17:46:39 2015 UTC,errno is thread safe at least. :-)
C_Programming,33hcaf,raevnos,1 point,Wed Apr 22 23:48:24 2015 UTC,You usually try really hard to make sure that -1 cannot be a valid result of the function to avoid that complexity.
C_Programming,33hcaf,Chooquaeno,0,Wed Apr 22 20:52:14 2015 UTC,"Exceptions are never nice. They should ever be used when truly not nice things have happened, and are usually more pain than they're worth."
C_Programming,33hcaf,Betadel,3,Thu Apr 23 14:05:51 2015 UTC,"You can use setjmp and longjmp, but since C doesn't have stack unwinding and destructors called like C++ exceptions, you'd have memory leak issues unless you're very, very careful."
C_Programming,33hcaf,kojiba,1 point,Wed Apr 22 18:09:22 2015 UTC,"Yeah.  I think I'll give it a miss lol.  I thought that if they were easy to do, then it might be a quite nice addition to my code which might garner some additional marks, but yeah."
C_Programming,33j2p6,Shtreimel,4,Wed Apr 22 22:38:11 2015 UTC,"0<=y will be evaluated to either 1 or 0 depending on the value of y. Then that value will be compared to 3. This comparison will always be true, so the first value after the ? (1) will always be returned."
C_Programming,33j2p6,ande3577,1 point,Wed Apr 22 22:49:27 2015 UTC,Thanks man that's the answer I've been looking for. :D
C_Programming,33j2p6,psu72,-2,Wed Apr 22 23:03:34 2015 UTC,"First,  (0<=y<=3)   is not valid C code... you would need to write   0 <= y && y <= 3   So in this case if y is between 0 and 3 inclusive, the value of the expression is 1, otherwise the  value of the expression is 1 / x  The general conditional expression (not statement) works something like a short-hand ""if"" statement  (some_boolean_condition ? value_if_condition_is_true : value_if_condition_is false)   (parens are optional if there's no ambiguity) For example  x = y > 7 ? 10 :12;   is completely equivalent to the ""if"" statement  if (y > 7)     x = 10; else     x = 12;"
C_Programming,33j2p6,_teslaTrooper,8,Wed Apr 22 22:47:14 2015 UTC,"It actually is valid C code, but probably doesn't do what the writer intended (see /u/ande3577's reply)  GCC has this to say: warning: comparisons like 'X<=Y<=Z' do not have their mathematical meaning [-Wparentheses]"
C_Programming,33j2p6,psu72,2,Wed Apr 22 23:41:29 2015 UTC,"I guess you're right... I've never used it since it doesn't do what you might thing, so I guess I always thought of it as invalid although it's acceptable to the compiler (with warnings)"
C_Programming,33iifx,H_Korean,2,Wed Apr 22 20:12:46 2015 UTC,"Put the print statement directly after the closing brace of the if statement.  If the guess is correct, it will break out of the loop before then, but each time it's an incorrect guess, it will print it out before restarting the for loop. Hope that helps!"
C_Programming,33iifx,Zargontapel,1 point,Wed Apr 22 20:21:58 2015 UTC,"Oh wow, thank you very much. That fixed it up right fast. Thanks! Also, is there anything I could do within the program? Like, is everything else just about right? Or is there anything that could be changed for a better presentation?"
C_Programming,33iifx,Zargontapel,1 point,Wed Apr 22 20:24:46 2015 UTC,http://c.learncodethehardway.org/book/ this book is good for learning about common tools and practices (needs either linux machine or MSYS installed in windows) and it starts from hello world to more advanced programs.
C_Programming,33iifx,Zargontapel,1 point,Wed Apr 22 20:31:48 2015 UTC,"I see. In the class I am taking, the instructor told us to get these two. The texts being Programming in C 4th edition and an Absolute Beginner's Guide to C. I think I may look through what you linked though. Overall, with the kind of ""student"" that I am I'd probably be best off with a Dummie's Guide lol"
C_Programming,33iifx,acwsupremacy,1 point,Wed Apr 22 20:33:29 2015 UTC,"Everything looks really good, just make sure you can always follow the control flow in your programs, so you can solve small issues like this in no time. :)  EDIT: Oh, one other thing. This doesn't make any difference whatsoever in the execution of your program, but you'll commonly see programmers replace the   guessCount = guessCount + 1   with  guessCount++   It just makes the code look a bit cleaner and is a very common convention for simple, single increments."
C_Programming,33iifx,Chooquaeno,1 point,Wed Apr 22 20:34:27 2015 UTC,"Thank you. So far, the only thing that makes it somewhat difficult to follow the flow is the {}, I tend to end up forgetting where one starts and another ends to be honest, but I can usually pick up where if I look very slowly through it all. So you're saying that changing guessCount = guessCount + 1 can be more cleaner if it were changed to guessCount++, I'm just curious how that works out exactly. Would you be kind enough to explain?"
C_Programming,33iifx,FUZxxl,2,Wed Apr 22 20:43:45 2015 UTC,"Yeah your braces are fine, it follows C convention, it just takes some time to get used to.    For the ++ operator, think about how for every line of the program, the compiler generates machine language to represent that.  Fortunately, most processors provide specific machine language operations to increment a value by 1.  For x86, this is the 'inc' operation.  So the compiler just replaces 'guessCount++' with 'inc [whatever memory location represents guessCount]' when it generates the machine code.  Since this is so easy, it was made a standard operation when they designed C.   Probably a bit more in depth than you're ready for, but that's really the best way to explain it."
C_Programming,33iifx,doom-o-matic,1 point,Wed Apr 22 21:18:49 2015 UTC,"In general, myvar = myvar + othervar; can be replaced with myvar += othervar; the ""compound"" or ""assignment"" addition operator; similar operators exist for the rest of the binary operations, subtraction, division, bitwise ops, etc.  In addition (pun very much intended), C has increment and decrement operators, ++ and --, which are often convenient in e.g. while and for loops.  So x++; x += 1; and x = x + 1; all mean the exact same thing."
C_Programming,33fn7e,aurikel,5,Wed Apr 22 03:15:40 2015 UTC,"I see a few problems here.  First, get rid of alphamatch[]. It's needless.  Second, think about the two loops.  Which is faster - testing each character 26 times, or testing each character once? How might you decrease the execution times?  Do you think you need to loop through and test each character against each one in the array?  C has some cool features, like 'c' - 'a' is 2. That might help you figure out the problem."
C_Programming,33fn7e,dmc_2930,1 point,Wed Apr 22 03:26:50 2015 UTC,"Thanks for your input! You're absolutely right about the horrendous algorithm I had going on; I got lazy. Reworking the loops but I gotta take a couple of moments to think on implementing your hint into the if conditions. Having some troubles thinking about how I would track count and total, then printing on a letter by letter basis with one loop. I'm only allowed to print the frequency for letters actually present, and only once per letter."
C_Programming,33fn7e,chalk46,1 point,Wed Apr 22 03:38:13 2015 UTC,"well I'd worry more about streamlining it once you get everything working.  once you rewrite stuff, you run the risk of introducing more bugs."
C_Programming,33fn7e,veeberz,2,Wed Apr 22 13:15:06 2015 UTC,"Tried it in CentOS, works fine. Compiled with gcc -std=c99 main.c  Suggestions: malloc seems useless in this program. Just statically allocate buffer. Also the line  if (buffer[l] != NULL )    should be  if (buffer[l] != '\0' )    Different data types with different sizes, may or may not cause a problem. Do you happen to know what kind of OS the server is running?"
C_Programming,33fn7e,veeberz,1 point,Wed Apr 22 03:53:06 2015 UTC,"I do not know what kind of OS the server is running, but most computers in our lab run XUbuntu 14.04. My inefficient code does work on my computer with gcc -Wall -std=c99 but I'm thinking the timeout can't be avoided with my code as-is."
C_Programming,33fn7e,veeberz,1 point,Wed Apr 22 04:12:07 2015 UTC,"I see. Does the assignment sheet provide constraints, like max input length?"
C_Programming,33fn7e,OldWolf2,1 point,Wed Apr 22 04:19:03 2015 UTC,"The first test shoves ""The Happy Prince"" by Oscar Wilde, of some 18,000 characters, into the program."
C_Programming,33fn7e,OldWolf2,2,Wed Apr 22 04:24:28 2015 UTC,"Try using one loop. No need to store characters a-z. Have an array of integers of size 26. When encountering a, increment the array at index 0, and so on. Accessing the element in the array is as simple as:  Determine if buffer[l] is in the alphabet. alphacount[(int)buffer[l] - (int)'a']++;   alphacount[26] will be an int storing the counts for each letter. Use a single loop for the buffer that increments the elements of alphacount for each letter, then iterate through alphacount and print your output. This way, instead of doing 26*18000 calls to isalpha and isspace, you only have 18000. Might be enough to not time-out. Good luck!"
C_Programming,33ehl2,BeefSmacker,4,Tue Apr 21 21:34:48 2015 UTC,Threads and signals are an annoying combination.  How are they behaving differently?
C_Programming,33ehl2,raevnos,1 point,Wed Apr 22 00:36:32 2015 UTC,"The flow of logic is this...  When SIGUSR1 is delivered it sets a global flag ""foo"" and halts the scheduling of new tasks on all threads.  Then, if and only if SIGUSR2 is delivered while ""foo"" is set, then it queries some stuff on each thread.  Then, if and only if  SIGUSR1 is delivered while ""foo"" is set, foo gets unset and the program continues execution.   So in the shell it would look like:   kill -10 <pid> (halt) kill -12 <pid> (resume) kill -10 <pid> (continue)   The above works exactly as expected.  In user code it should look like:   kill(getpid(), 10) kill(getpid(), 12) kill(getpid(), 10)   What I am seeing from this however is SIGUSR1 gets delivered and set ""foo"" but sometimes SIGUSR2 gets hit before all threads are halted, and sometimes the resume gets hit immediately after the halt.  Clearly a race but I assumed the two kill commands behaved the same."
C_Programming,33ehl2,xcombelle,2,Wed Apr 22 15:12:12 2015 UTC,"I think the main difference is that due to process creation (or similar things) the shell version add randomly sleep, context switching, ... which lead to different behavior in your multithread program  Welcome to the multithread hell !"
C_Programming,33ehl2,sh_,1 point,Thu Apr 23 12:22:22 2015 UTC,The tears are real....
C_Programming,33ehl2,ratatask,4,Thu Apr 23 15:45:52 2015 UTC,"You want to use raise(3), not kill(2). You also want to mask signals before creating threads, so that those signals are masked in all threads. Then unmask signals in the thread you want handling signals."
C_Programming,33ckhk,sindisil,11,Tue Apr 21 12:50:53 2015 UTC,"Many of these questions appear to be about things that I don't need to care about, because I can't imagine a situation in which that would be the clearest way to express my intent. These things always read like ""how much C language esoterica have you encountered?""  The answer is ""not much"" - when you're writing the code, instead of inheriting it from insanely proud code-golfers, edge-cases like these should be avoided, whether you know how they will behave or not. In my opinion, if someone who has just finished CS101 in C cannot understand the behavior of your code, you wrote it wrong.  (I know embedded devs need to use wierd tricks for various reasons - you folks are a special breed, and my indignation is aimed elsewhere.)"
C_Programming,33ckhk,nevinera,4,Tue Apr 21 16:10:33 2015 UTC,"if someone who has just finished CS101 in C cannot understand the behavior of your code, you wrote it wrong.   I like this as a general guideline."
C_Programming,33ckhk,Hellenas,2,Tue Apr 21 18:16:39 2015 UTC,"This is true for most of the items here, but I see union type-punning all over the place.  I don't use it myself, but a LOT of people seem to think it's OK, and I don't know if/when it is.  I have definitely memset structs and assumed that padding would remain zero."
C_Programming,33ckhk,FazJaxton,1 point,Tue Apr 21 22:40:08 2015 UTC,"Could someone who knows the standard come in and clear this up? Because I thought it was undefined behavior, but I can't actually find any evidence for or against it."
C_Programming,33ckhk,GBGamer117,6,Wed Apr 22 10:33:59 2015 UTC,"My instinct is to answer many of those questions with ""I know what gcc does, but lemme check the standard."
C_Programming,33ckhk,maep,3,Tue Apr 21 15:01:49 2015 UTC,Those were really interesting survey questions. I enjoyed being able to step back from slavishly considering the spec to speculate about what I believe my compiler does.
C_Programming,33ckhk,skeeto,3,Tue Apr 21 19:18:10 2015 UTC,"So, any chance we can see the results of this survey?"
C_Programming,33ckhk,acwsupremacy,2,Tue Apr 21 20:48:14 2015 UTC,"I answered it and realized I don't know the standard as well as I'd like to. I think I get the gist of what guarantees can and can't be made about the C memory model, and some of that comes from writing code and debugging assembly on a variety of different microprocessors. But as to things like whether writing one union member and reading another breaks optimization? Really, I haven't had a lot of need to look at whether the compiled code is accessing union members as fast as theoretically possible, or not... I always try to treat a union as a black box and put it in a struct with a separate enumeration that tells me how I last wrote it. That, and the other common ""use case"" for a union is to throw a number of types into one, so I have a sizeof() that gives me ""worst case"" -- what's the size I would have to allocate that would hold any of those members?  That said, I would like to see an annotated results (with chapter and verse from the standard) to see where I'm lacking."
C_Programming,33dw8w,hello_this_is_jim,6,Tue Apr 21 19:01:19 2015 UTC,A RPN (Reverse Polish Notation) calculator will help you learn how to work with string parsing and such.
C_Programming,33dw8w,MrAppleseed,2,Tue Apr 21 23:52:20 2015 UTC,Implement grep.
C_Programming,33dw8w,_COMPLEX_H,1 point,Tue Apr 21 22:54:17 2015 UTC,Console rpg game on ncurses like rogue. Also add some online in that game. (dream of oldfag)
C_Programming,33dw8w,kojiba,1 point,Wed Apr 22 08:08:35 2015 UTC,"Have you looked at Project Euler? There's a number of ways to solve each problem, so you can try out different data structures and algorithms."
C_Programming,33dw8w,wallet_idiot,1 point,Wed Apr 22 15:05:06 2015 UTC,Write a 6502 assembler.
C_Programming,33fi3a,all_mens_asses,1 point,Wed Apr 22 02:31:37 2015 UTC,:)
C_Programming,33c929,the9thdude,10,Tue Apr 21 10:23:08 2015 UTC,"To generate an EOF, you need to press Ctrl-D.  In addition, to specify precision in printf() you need to use %.0f (and not %f.0). Using a double for this makes little sense, in any case."
C_Programming,33c929,Aransentin,6,Tue Apr 21 10:44:11 2015 UTC,"Sweet! Thanks for the pointers, just a minor stumbling block :D"
C_Programming,33c929,ertlun,9,Tue Apr 21 10:48:43 2015 UTC,"Thanks for the pointers   Intentional or not, that's a beautiful pun."
C_Programming,33c929,Chooquaeno,2,Tue Apr 21 13:53:09 2015 UTC,"/* had to include int because Clang wouldn't compile it otherwise */   There's a reason for that.  Also, floating point arithmetic probably doesn't work the way you think it does."
C_Programming,33c929,Chooquaeno,1 point,Wed Apr 22 06:43:00 2015 UTC,"I know, but that's what the book says. I'd prefer to use integers in this instance since they're so small, but again, I'm just learning now so sticking to what the book says and I'll get to the more granular knowledge later."
C_Programming,33ceg6,EamonRocks,7,Tue Apr 21 11:41:10 2015 UTC,"If you are working in a terminal, then the arrow keys generate an escape sequence. To get this escape sequence, you need to turn off line buffering in the terminal driver termios. This is slightly complicated, you might want to look at a library like curses to do this stuff for you in a reasonably portable manner."
C_Programming,33ceg6,FUZxxl,2,Tue Apr 21 13:10:30 2015 UTC,"thanks! Ill look into it, see what i can come up with!"
C_Programming,33ceg6,FUZxxl,2,Tue Apr 21 18:21:11 2015 UTC,"If you need further help, feel free to ask!"
C_Programming,33c2di,kojiba,2,Tue Apr 21 08:38:47 2015 UTC,"Looks pretty fun! An interesting project and looks quite well-designed, too. Some little strange things remain (e.g. why do you define your own boolean type when you can use an int or bool from stdbool.h? Why do you redefine types from the Windows API?) but all together it looks pretty neat."
C_Programming,33c2di,FUZxxl,1 point,Tue Apr 21 13:14:00 2015 UTC,"Boolean type - is a idea from osx core foundation(CF), I was think about there are no stdbool.h in ansi c. I redefine symbols cause of cross-platform, my main developing system is osx. Added some more windows compability today) There are another bigger strange for people - is static names system like m(), c(), d(), deleter(object, className) and other=) But it create a space to choose how u want to use it, in pure it camel case like ""concatenateRCString"", but also can made     #define method(returnValue, methodName, className)  returnValue     concatenate(methodName, _className)           (className *object  for use C-style namings like concatenate_RCString, or etc. Please try it, create some issues with bugs and ideas=)"
C_Programming,33c2di,FUZxxl,1 point,Tue Apr 21 17:19:29 2015 UTC,"To format text as code, put four spaces in front of every line! Your comment is unreadable right no.  ANSI C, that is C89 does not contain stdbool.h but it doesn't contain stdint.h either which you seem to use. I'm also confused that you use $ for a macro name. $ is not a valid character for identifiers although some compilers support that as an extension."
C_Programming,33c2di,FUZxxl,1 point,Tue Apr 21 17:23:09 2015 UTC,"Forgot about stdbool.h  - thats because CF has CFInteger, maybe. About '$' - I use only clang, try on gdb and mingw/cygwin, that define works without any problems. Know about libcello also use it. '$' it idea to do dot notation like ""object.methodName""."
C_Programming,33c2di,FUZxxl,1 point,Tue Apr 21 17:29:32 2015 UTC,"If your approach to portability is “I tried with two compilers and both look like they support it,” you have no approach to portability. Go read some standards and platform documentation. Portability in C is the exact opposite of “it compiles on my machine.”  As said before, the dollar in identifier names is a common extension but frowned upon as it's not part of the C standard. I don't know Cello really well, but they seem to do some nasty stuff to make C look like an object-oriented language."
C_Programming,33c2di,Zardoz84,1 point,Tue Apr 21 18:10:09 2015 UTC,"I am in progress with crossplatform) Of course I need some help, because I don't have so much experience in portability. I will be grateful for the advice what to start from. Gone search some best-practices docs."
C_Programming,33c2di,Zardoz84,1 point,Wed Apr 22 06:03:36 2015 UTC,"Read and understand POSIX, the portable operating system standard. UNIX-like operating systems such as Mac OS X and Linux generally adhere to this standard. Look at POSIX if you'd like to know what functionality is portable and what not. Sadly, Windows does not really implement POSIX (their shitty compatibility layer doesn't count as they did great in making it utterly useless) and thus it's always a bit of a hassle to get thing to work on Windows, too; they're stuck in 1989 when it comes to C."
C_Programming,33bfiw,hobb0001,6,Tue Apr 21 03:47:03 2015 UTC,"It's nothing that's going to knock your socks off, but I particularly like GCC's C/C++ operand-omission extension to the ternary operator:  If you would ordinarily type an expression like x = p ? p : 0;, GCC lets you instead type x = p ?: 0;.  In a form like this, it's nothing special (though for long/qualified identifiers it sure saves screen space); where it really shines is when the operand in question has side-effects:  int *doomsday_ptr (void) {     static int ref = 0;      return (++ref < 10) ? 0xDEADBEEF : NULL; }  int main() {     // Oops! We've incremented the counter twice!     int *p = doomsday_ptr() ? doomsday_ptr() : 0xFACEB00C;      // Boom. GCC to the rescue.     int *q = doomsday_ptr() ?: 0xFACEB00C; }   A silly contrived example, but it illustrates the convenience of the feature beyond simply shortening expressions."
C_Programming,33bfiw,acwsupremacy,1 point,Tue Apr 21 05:02:21 2015 UTC,That actually seems pretty useful. Can you do the opposite as well? x = p ? 1 :; (Thought I realize this will be used far less often)
C_Programming,33bfiw,chasesan,5,Tue Apr 21 13:13:36 2015 UTC,"Decimal floats: 1.0df + 0.01df is exactly 1.01df  Also, nested functions, they give you closure ... quite literally:  unsigned int something(void) {       unsigned int i = 10;        static inline void inc_i(void)       {             i++;       }       inc_i();       inc_i();       return i; }"
C_Programming,33bfiw,hroptatyr,1 point,Tue Apr 21 05:35:56 2015 UTC,Just don't try to use that function anywhere else. :)
C_Programming,33bfiw,chasesan,5,Tue Apr 21 13:11:56 2015 UTC,"That's a tough one, since one usually avoids extensions when possible.  I personally like the ms extensions with use with structures. These are known as anonymous named structures iirc. Almost gives you inheritance.  struct str_a {     int x;     int y; }; struct str_b {     struct str_a; //no name     int z; }; // ... access it like it was part of that structure     struct str_b test;     test.x = 0;"
C_Programming,33bfiw,chasesan,2,Tue Apr 21 08:39:35 2015 UTC,"Anonymous struct members are part of c11 now, but it's not exactly the same"
C_Programming,33bfiw,neutralinostar,1 point,Tue Apr 21 09:20:16 2015 UTC,"Those have to be defined within the struct, which loses you a good bit of the utility of this approach. Since you have to define the anonymous struct every time you need to use it."
C_Programming,33bfiw,chasesan,5,Tue Apr 21 13:10:03 2015 UTC,A couple of things come to my mind even though I generally dislike extensions because they inhibit portability:   #pragma ident puts an identification string into the binary which ends up in the .comment section on ELF targets. Very useful to embed a version number or copyright string. This is reasonably portable and can easily be wrapped in #ifdef blocks. All the POSIX stuff is really nice and reasonably portable. The C99 functions are pretty cool even though they are not supported on Windows. Look into the BSD functions strlcpy and strtonum. They are useful and safe.
C_Programming,33bfiw,FUZxxl,0,Tue Apr 21 12:58:50 2015 UTC,"C99 is not supported by Microsoft Visual C. Windows is entirely indifferent to the standard (since it's an OS, not a compiler). I think some of C99 is supported in VS2012.  MinGW and Clang can compile all the way up to C11 on windows."
C_Programming,33bfiw,chasesan,2,Tue Apr 21 13:17:15 2015 UTC,"GCC's statement expressions and __auto_type (or typeof). E.g.   #define max(a,b) \    ({ __auto_type _a = (a); \        __auto_type _b = (b); \      _a > _b ? _a : _b; })   https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/index.html#toc_C-Extensions  (binary literals, various builtins (especially the upcoming overflow checks in GCC5), and vector extensions can be very nice as well but are more specific.)"
C_Programming,33bmg1,WCC96,2,Tue Apr 21 04:57:01 2015 UTC,"Are you perhaps failing on these ?  strrev(rever); system(""pause"");   These are platform dependent and will fail on Linux"
C_Programming,33bmg1,studioidefix,2,Tue Apr 21 05:21:41 2015 UTC,"That could be done with less memory and fewer steps. One string is plenty and all the reversing and all that is unnecessary. A cleaner algorithm would be to take your string and compare the first character to the last, then the second to the second to last etc. You only need to step through half the string. Watch out for one off errors due to trailing newline characters or length vs array index.  The meat would look something like:  for (i=0; i<(length/2); i++) {     if (myString[i] != myString[length-i-1]) {         isPalindrome=0;     } }"
C_Programming,33bmg1,dragon_wrangler,1 point,Tue Apr 21 07:03:31 2015 UTC,"A quick glance looks fine to me (other than the closing bold html tag), what problems are you having?"
C_Programming,33bmg1,hutcho66,1 point,Tue Apr 21 05:06:17 2015 UTC,"Two tips:   As mentioned above, don't use strrev. It isn't standard C. You should be able to write a similar function fairly easily. But you shouldn't need to for this problem Think about what it means to be a palindrome. The first char is the same as the last. Once you've created your lower case string with whitespace removed, think about how you could use two indexes to compare the first char to the last. Then the second to the second last. Do you still need to go all the way to the end of the string?"
C_Programming,33bmg1,j__h,1 point,Tue Apr 21 06:30:59 2015 UTC,"You should include the error message!  Seconding studioidefix suggestion on platform dependent calls: strrev, and system(""pause"")  If you do not have strrev you can define your own.  And on another note, you are not handling capitalization.  You also are doing more work than you have to with the copying and reversing (can be done in place), and also checking the entire length of string, but none of that is not technically wrong."
C_Programming,33a6tn,EamonRocks,10,Mon Apr 20 21:43:17 2015 UTC,"Actually, printf-sleep-printf really is the easiest way, however, the issue is that printf to stdout in Linux is buffered by default. What this means is that nothing will actually print until either a newline is reached or the buffer is flushed (happens by default at the end of your program).  There are a few different ways to handle this. The first is that you can flush the buffer whenever you want, such as:  printf(""%c"", ch); fflush(stdout);   But, if you plan on doing this for something as long as a story, it would probably much easier to simply turn off the buffer while you're printing using setbuf():  setbuf(stdout, NULL); ... printf(""%c"", ch); ...   So just turn off the buffer towards the beginning of your program and you should be good to go."
C_Programming,33a6tn,CuriouslyGeorge,5,Mon Apr 20 21:58:38 2015 UTC,"I see... That explain that weird behavior of letting all sleeps run out then printing all at once... Thanks! It was super helpful, always learning new stuff in this subreddit :D"
C_Programming,33a6tn,CuriouslyGeorge,2,Mon Apr 20 22:11:23 2015 UTC,"Here to help. Good luck with your program! :)  And if you're looking for suggestions, something else I think might be pretty neat is to print out whole words at a time and have the delay be related to how long the word is. So the longer the word, the longer the delay."
C_Programming,33a6tn,iwasanewt,3,Mon Apr 20 22:17:29 2015 UTC,"That's actually a pretty good idea but Im still kinda noobish so it would take me a bit of time and the deadline is pretty soon, but Ill definitely do it somewhere in the future for sure!"
C_Programming,33a6tn,HerrDoktorHugo,3,Mon Apr 20 22:46:21 2015 UTC,try using fflush
C_Programming,33a6tn,Ubertekk,2,Mon Apr 20 22:00:54 2015 UTC,Thanks! I wasn't aware of the actual use of that function
C_Programming,33a6tn,Kristler,2,Mon Apr 20 22:10:18 2015 UTC,"There exists a   little Perl script called ""baud"", which gives you the effect of a slow serial terminal printing characters one at a time. Maybe it can be useful to you, or give you inspiration for how to accomplish your effect."
C_Programming,33a998,rhascal,4,Mon Apr 20 22:01:09 2015 UTC,Most likely it can't find the file you're trying to open.  See the other replies for how to find that out.  As for formatting: put four spaces before each line of code and your asterisks won't disappear.
C_Programming,33a998,boredcircuits,2,Mon Apr 20 22:21:29 2015 UTC,"If you're getting ""bad stuff"", it means fopen failed for whatever reason. In order to see what went wrong, fopen will set the errno so you should know almost exactly what goes wrong. For better error reporting, I would recommed changing your first conditional block to look like this:  if (fp == NULL) {     printf(""bad stuff\n"");     perror(""Nemesis.txt"");     exit(1); }   perror() will automatically print the message the system has associated with the errno and should give you a better idea of what's going wrong."
C_Programming,33a998,CuriouslyGeorge,2,Mon Apr 20 22:13:29 2015 UTC,"If fopen returns NULL, errno will be set to indicate the error. Try something like this:   /* Include these headers */  #include <string.h>  #include <errno.h>   /* Change bad stuff to this */  if (fp == NULL) {       printf(strerror(errno));       exit(-1);  }   You should see your error."
C_Programming,33a998,dafrito,1 point,Mon Apr 20 22:16:04 2015 UTC,"Thanks! It states no such file, guess i need to figure out that"
C_Programming,33a998,R1cket,1 point,Mon Apr 20 23:42:04 2015 UTC,"I do have that written, it's not working though"
C_Programming,33a998,R1cket,1 point,Mon Apr 20 23:51:05 2015 UTC,\ \\ / // nada =/
C_Programming,33a998,Chooquaeno,1 point,Mon Apr 20 23:52:20 2015 UTC,I couldn't figure out how to display the asterisk so I replaced them for my post and noted the replacement at the bottom.   Sorry!
C_Programming,33aswx,JakeButtkiss,8,Tue Apr 21 00:36:56 2015 UTC,"Programming, like most crafts, requires regular practicing, self-critique (""is this good? Can I improve it?""), and studying.  Practicing gets your train-of-thought flowing, so you can express a solution.  Self-critique allows you to consider different known approaches when you are done.  This is because it takes experience to express more polished solutions.  Finally, you need to keep studying so you can get acquainted to new methods and approaches, develop new mindsets, and improve your self-critique.  It should not come as a surprise that this is a never-ending process."
C_Programming,33aswx,rnsanchez,3,Tue Apr 21 00:56:28 2015 UTC,"First, I'm going to preface this by saying that while I am a solid programmer, my background is more surely in hardware design.  This is why I like C; I feel like I can see and interact with the underlying architecture, but not with the headaches that come from how meticulous that can be.  I generally program a serious project with a few simple steps.   Design & Freeze Prototype and Review Tweak | Initial Debug Analyze and Refine   Design and Freeze  This is really what will feel like the most nebular step.  Basically, I look at the whole project, outline the specifications I need to achieve, relate how these specs line up, and make high-level diagrams and connect things that are related.  Once I have this diagram set up, I take each component, look at them and see if I can break them down into further components.  Once those are simple enough, I'll start making psuedo-code.  After doing this for each portion and finding myself satisfied, I finalize this design and freeze it, meaning that no further design changes can be made until it seems needed.  Specifications ought to be sured up and frozen as well in this, since a change in specification necessitates a change in design.  Prototype and Review  With the design frozen, I begin, probably from the psuedo-code, to define each small component piece by piece.  Every time a piece is completed, I try to verify that if behaves as has been specified in the design.  Then, I connect sub-components and verify larger component functionality (I think this is where my hardware influence shows through a bit strong...).  I enforce here that I am only looking for functionality, not optimality, since I can't chase two things at once.  Eventually, this culminates in connecting everything into the project prototype.  The goal here, the Review, is the verify that the large unit works as designed and specified.  Upon finishing this, we technically have a working product, but the goal now becomes to improve it.  Tweak  In this phase, we ought to look at small things that may have been overlooked in Design.  The hope is that there is nothing to find here, but it is better to look for things that can be a problem than not.  If something feels out of line from design, tidy it up.  The goal is to get everything in the project facing the same direction.  If you need to make serious design changes here, you messed up in the initial design phase and you risk introducing serious bugs trying to patch the whole project to fit a new design.  Patching is where most bugs in software are introduced, so be very wary and very parsimonious.  Analyze and Refine  At this point, we break down to every component again.  Ask the questions like this:   Where are we using or wasting the most time? Where are we consuming the most memory? Where are we leaking memory or forgetting handles, etc? What has the most throughput? Where am I performing I/O, if at all?   Using the answers from these, start attacking each component one at a time for inefficiencies.  Is there an array you are zeroing out that doesn't need zeroing out but only an initial null?  Are there loops that you might be able to unroll?  Are some of the functions that should be pure not?  Are there little tricks you can play with your switch statements, like turning them into indexing or the like?  I like to hit the inefficient items first, and then work down the chain.  The behavior and functionality of the components will not change (I guess unless you make a function pure or something, but that really is another thing), but their operation should become better.  After enough refining and tightening, you will have the same functionality, but better performance.  These are the general steps I follow.  Again, this comes more from a hardware point of view, where I would often be looking at how to lower gate count or (on and FPGA sometimes) alter placement or routing to work at faster clocks, so take that with a grain of salt, but I feel the methodology in itself is effective.  The final bit of advice is one you already are doing:  Be humble, don't be afraid to ask questions, don't be afraid to be wrong and get corrected, and speak up when things seem tough or funky!  Good Luck man!  Pick a fun project and just dive in!"
C_Programming,33aswx,Hellenas,2,Tue Apr 21 15:46:00 2015 UTC,Make stuff fall out for free(after you've waded through muck)
C_Programming,33aswx,GlassGhost,2,Tue Apr 21 02:32:26 2015 UTC,"Divide and conquer, use encapsulation and abstraction to break a problem up into smaller chunks, repeat on each chunk until they are easy to implement.  Don't get caught up in details, say you want to write a function that reverses a string in C it might look something like this (pseudocode):  i, j = 0 j = length(theString) while (i < j):     swap(theString[i], theString[j])     i++     j--   What is the 'swap' function? Its just a function that swaps the value of two characters. Encapsulate the problem of swapping two characters away from other problems you want to solve."
C_Programming,33aswx,akzever,1 point,Tue Apr 21 00:47:01 2015 UTC,"Break things down into smaller chunks.. You need 3 things in a program (generally)... Input, processing, and output. Pick one of those, and start coding it, breaking it down.. Every function you write should follow the same idea, I, P, O...   If you're still stuck, just start by writing pseudo code, or just comments.. Quite a bit of the time i'll write my comments for a function/method first, and then fill it in later. That way, I don't get tied down with the 'low level' of exactly how to do something, and work mainly on the 'high level' of the application/class/function."
C_Programming,33aswx,garion911,1 point,Tue Apr 21 05:59:29 2015 UTC,Pick some small to medium sized project (preferably something that doesn't involve a lot of mundane and repetitive tasks like GUI programming) and start coding. It's all about experience and practice. Be sure to constantly ask yourself if you could improve your solutions or find a better way to do it. Since you're almost graduating you should have all the theoretical foundations already.
C_Programming,33aswx,tsahyt,1 point,Tue Apr 21 10:15:31 2015 UTC,"A few comments on how I personally try to think when I'm writing new C code. This is not necessarily all about thinking like a programmer, since I think what you think about as a programmer is specific to the language you are writing in. These are some of the things I keep in mind when writing C code. They're a lot different than the things I keep in mind when writing other languages.  When you want to use a variable:   Where should I define it? Basically, I try to define it in as narrow a scope as possible, for example inside one branch of an if, or sometimes even inside a scope that I open just to introduce a variable or set of variables. Is this variable of automatic storage class (in braces without the keyword static), or does it have static storage class? If it is an automatic variable, have I initialized it to a sane value? Remember that automatic variables are never initialized by the compiler by default! If it is of static storage class, have I provided an initial value anyway for readability, even though the compiler will initialize it to a standard zero value for the type? My inclination is to use const when I can by default: const pointers to const memory, const integers, etc. So I think of it as const first and then decide if I need it to be non-const. If this variable is defined in the file outside of a scope, because it needs to be, can I get away with making it statically linked, instead of extern? This is a very basic form of encapsulation, keeping some variables ""modular"" to the source file unless they really need to be otherwise. The functions I'm writing -- can I make them static? Who will be calling them? If there is an API I'm implementing for this module, can I make it simple and small, with the rest of the functions private to this file (static?) Are there any other special requirements, such as making the variables volatile? If a cluster of variables goes together, and tend to be updated or read as a unit, would it make sense to put them into an aggregate -- a struct? Think hard about your loops. Sure, there is the very common pattern of for ( var = initial_value; var < out_of_bounds_value; var++ ) but there are lots of other ways to write loops. What condition to do you want to exist before and after the loop? Is it clearer as a while loop, which can execute zero times, or clearer as a do loop, which always executes at least once? Do loops are not very common, but I find that once in a while they can make my intent much clearer.   There's a lot more, such as what contract does each function imply, but maybe that is some food for thought."
C_Programming,335zxy,enahsg,24,Sun Apr 19 21:42:29 2015 UTC,"You need to setup the seed before calling rand(), see more info on srand() here."
C_Programming,335zxy,microchannelplate,29,Sun Apr 19 21:53:33 2015 UTC,"Can we add that to the list of ""things every single programmer pass through once in their lives""?"
C_Programming,335zxy,SrPeixinho,3,Sun Apr 19 21:56:20 2015 UTC,That one screwed me proper during a coursework project when I was studying.
C_Programming,335zxy,Skyfoot,3,Mon Apr 20 00:45:44 2015 UTC,"Here's a self-seeding rand() function you'll never have to initialize again. Tested, passes modest tests of even distribution (as well as stdlib version on my compiler anyway):  //Returns a pseudo-random number 0 through 32767. int rand(void)   {   static long comprand = 1L;   static int init_done = 0;         if(!init_done)       {              comprand = (long)((unsigned int)time(NULL));              init_done = 1;       }      return(int)(((comprand = comprand * 214013L + 2531011L) >> 16) & 0x7fff);   }     EDIT: this site has some great free resources and thoughts on random number generation. ""RANDOM.ORG is a true random number service that generates randomness via atmospheric noise.""  Especially check:  ""HTTP API to get true random numbers into your own code"""
C_Programming,335zxy,zenkibudo,5,Tue Apr 21 02:07:55 2015 UTC,"Like other said you nedd to seed the PRNG with srand(). rand() behaves like this because in some cases it is useful to have this behavior.  Generally, good randomness is hard. Anyone interested in good PRNG should watch this talk: https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful"
C_Programming,335zxy,maep,2,Sun Apr 19 23:17:46 2015 UTC,"The issue here is that rand() uses a PRNG (Pseudo-Random Number Generator) that needs to be seeded before it will begin returning integers.   If no seed value is provided,  the  rand()  function  is  automatically seeded with a value of 1.   So basically, your program starts the rand() PRNG at the same point every time you run the program with the results being the exact same. To alter the seed, you need to call srand() with a seed before calling rand.   If you're trying to get quick results, a popular method is to seed it with the current time. For example:  #include <time.h> ... srand((int)time(NULL)); ... rand();"
C_Programming,335zxy,CuriouslyGeorge,2,Sun Apr 19 21:57:14 2015 UTC,What's the reasoning behind the cast to int? I've been using it just fine without it.
C_Programming,335zxy,sgthoppy,1 point,Mon Apr 20 16:00:46 2015 UTC,"I would dare to say that it would work 99.999% of the time without the cast, but as a habit, I almost always do strict casting when the types are not guaranteed. By this, I mean that the type time_t is not explicitly guaranteed to be an integer, though I have yet to see it not defined as such on any *Nix system. Either way, going by the man page on sys/types.h:   time_t and clock_t shall be integer or real-floating types.   sys/types.h"
C_Programming,335zxy,CuriouslyGeorge,3,Mon Apr 20 16:35:55 2015 UTC,Some hoops to jump through if you want to use rand() for random numbers: http://eternallyconfuzzled.com/arts/jsw_art_rand.aspx
C_Programming,335zxy,rampant_elephant,2,Sun Apr 19 22:52:42 2015 UTC,"Thanks for this -- totally solved my un-even distribution problem been bugging me for days.  I was using the old modulus of rand() technique to limit my range.  Never again...doing this now:  do{       r = rand();   } while (r < LO || r > HI);     Much of the other tips might be disposable -- but this piece is the gem.   Getting an incredibly even histogram of distribution now.  Without investing $$ in a device, i think this is as random as it gets."
C_Programming,335zxy,zenkibudo,3,Sat May 2 09:09:26 2015 UTC,"Another good way to get random bits is to read from /dev/random or /dev/urandom.  FILE * rnd = fopen(""/dev/urandom"", ""r""); int i = 0; fread(&i, sizeof(i), 1, rnd);   That can be useful for reading lots and lots of random data. I use it some times but more often on arrays than on single ints.  Obviously it only works if you have random or urandom so it is only portable on unix like systems."
C_Programming,335zxy,SlayterDev,2,Mon Apr 20 02:37:37 2015 UTC,"Well first you need to use srand(time(NULL)) at the start of the program. This will ""seed"" the random generator with the current time. The seed is a number that the random number generator uses to make the numbers random which will solve your first problem.  As for making sure the number is less than 1000, you can use the following:  int choice = rand() % 1000;   This will ensure the number is less than 1000."
C_Programming,335zxy,serendib,2,Sun Apr 19 21:57:11 2015 UTC,"Keep in mind that seeding with time only gives you one new seed every second, so if he's running this program a bunch of times very quickly he will also experience non-random behaviour"
C_Programming,335zxy,SlayterDev,1 point,Mon Apr 20 01:53:28 2015 UTC,True. However that's normally standard practice for seeding rand() as far as I know.
C_Programming,335zxy,tsahyt,2,Mon Apr 20 03:15:01 2015 UTC,You could seed it from /dev/random on Linux (/dev/urandom on BSD afaik) and leave the time seeding as a fallback for systems that don't have that device
C_Programming,335zxy,EkriirkE,2,Mon Apr 20 07:45:07 2015 UTC,"I'd rather GeTickCount() or clock_gettime(CLOCK_MONOTONIC, &timespec);"
C_Programming,335zxy,michaelKlumpy,1 point,Mon Apr 20 11:40:22 2015 UTC,don't we all love it when OP asks a question and never returns?
C_Programming,335zxy,michaelKlumpy,2,Mon Apr 20 10:00:56 2015 UTC,"I back.  I wasn't able to test it out on my laptop (which was where I made the post) as there is something weird with it where I can't use certain time functions, and most responses had something to do with time.  Saying that, it seems to work fine now on my desktop, and is giving me different values each run through."
C_Programming,335zxy,RainbowNowOpen,1 point,Mon Apr 20 11:26:58 2015 UTC,welcome back :) and glad it worked
C_Programming,335zxy,RainbowNowOpen,1 point,Mon Apr 20 12:12:23 2015 UTC,I can't use certain time functions   o_O
C_Programming,335zxy,nunodonato,1 point,Mon Apr 20 14:58:01 2015 UTC,"I don't know why, but for example when I try to do ""time_t"" I always get an error on my laptop.  I don't know why.  It works fine on my desktop."
C_Programming,335zxy,Sean1708,3,Mon Apr 20 16:03:09 2015 UTC,"When you say you get an error when you ""try do do time_t"", do you mean you get a compile-time error when you declare storage of type time_t?  Or when you reference it?  Or is it a runtime error?  Suggestion: Post the smallest possible program you can that gives you such an error, along with the console output of the compile.  A kind soul might help..."
C_Programming,335zxy,disclosure5,1 point,Mon Apr 20 18:13:01 2015 UTC,"Many people here already replied regarding the need to set the rand seed.  I'd just like to pop in and comment on this because for me its a very philosophical thing! Think about, there is truly no way to get a real random number. Every random number is created given a set of inputs, and if you were to find out those inputs, you would realize it was not random at all.   Computer random numbers, just like everything in the universe, are not accidents or random, they have a cause. Isnt it beautiful? :P  Ok, i'm done :)"
C_Programming,335zxy,nunodonato,1 point,Mon Apr 20 09:23:47 2015 UTC,"Think about, there is truly no way to get a real random number.   Why not the eigenvalue of a quantum system?"
C_Programming,335zxy,Sean1708,1 point,Mon Apr 20 19:59:06 2015 UTC,"Think about, there is truly no way to get a real random number.   As the owner of one of these I'm fairly confident there is!"
C_Programming,335zxy,nunodonato,1 point,Tue Apr 21 10:38:03 2015 UTC,"no, there isn't :)"
C_Programming,335zxy,Sean1708,1 point,Tue Apr 21 13:21:01 2015 UTC,"yes, there is :)"
C_Programming,338v8t,yaboyuzi94,10,Mon Apr 20 16:04:18 2015 UTC,"Posting your homework verbatim and asking for help is not going to get you much of a response. Put some effort in first, then if you run into a problem you can ask for help. If you have absolutely no idea - start by looking up how to declare a struct."
C_Programming,338v8t,_teslaTrooper,1 point,Mon Apr 20 16:53:16 2015 UTC,"using the usual “while !feof ( )” sort of loop and the fread ( ) C library function.   Sounds like trouble already.  If you're writing while (!feof(file)), you're probably doing it wrong.  Or, more accurately, being taught wrong."
C_Programming,338v8t,boredcircuits,1 point,Mon Apr 20 17:13:14 2015 UTC,"This is definitely a homework question, so I'm not going to give you any code. I will however try to point you in the right direction.  I'm guessing he gave you a file-format layout kinda like this:  20-bytes - Name (null-terminated char array) 4-byte - Timestamp (Integer)   The idea is then to create a struct that can hold this data - Note that in this case, the order of the entries is important:  struct entry {     char name[20]; /* Array of 20 characters to hold the 'Name' entry */     int timestamp; /* 4-byte integer to hold the timestamp */ };   Once you have the structure created to match your binary data, you're going to want to look into the 'stdio.h' library header. I would google it, there is good information. You're going to be using the FILE interface to read a file. As noted, feof and fread are your friends here. Here are a few prototypes of interest:   /* Lets you open a file specified by the string 'path', and opens   * it using the mode settings from 'mode'. 'mode settings' are things   * like 'read-only', 'write-only', 'read-write', and a few others.   *   * The returned pointer refers to the open file, and can be passed to the other 'f' functions. */ FILE *fopen(const char *path, const char *mode);  /* Closes a file referred to by the FILE *. The FILE * is the same one you got from fopen() */ int fclose(FILE *);  /* This prototype is confusing but useful.  * The basic idea is that fread reads from the file given by the FILE * 'file'  * 'ptr' is just a pointer to some memory to store the data read from the file.  * This can point to *any* type of data.  *  * 'member_size' and 'member_count' refer to the size of each member, and the number of  * members referred to by 'ptr'. So, for example, if you wanted to read 20 'int's, then you  * could give the 'member_size' as the size of a single 'int' variable, and then 'member_count'  * as 20, the number of ints. Since you're only reading one entry, your 'member_count' can  * just be 1. */ size_t fread(void *ptr, size_t member_size, size_t member_count, FILE *file);  /* Returns whether or not you have hit the end of the file when you attempted a read. */ int feof(FILE *);   So for example, if I wanted to read a single 'int' from above from the file 'file', then I could do this:  FILE *file; int data; /* file = fopen(""File"", ""r"") */ /* Open the file here */ /* Read a single member, with a member size of 'sizeof(data)' */ /* Read it into 'data' by passing the address of the 'data' variable */ fread(&data, sizeof(data), 1, file);    That's the basic idea of what you want to do. Obviously, since you're reading multiple entries one at at time you'll need to use a loop. feof can be used to figure out when you can be done with the loop and done reading the file."
C_Programming,338v8t,DSMan195276,1 point,Mon Apr 20 17:17:30 2015 UTC,"The idea here is that a struct would represent a single record in the file and the file would have many records.  The field names he gave you are the fields in each struct.  So do this: 1) Make a struct with the field names he mentioned.   Each field needs a type (int, char, whatever) so you can either examine acars.bin file in an editor or ask teacher for the field types.  2) Make a big array of structs.  3) Make a loop that reads a record at a time. Each time you get a record, assign the values to a struct in your array. The loop stops when you reach the end of file (feof ()).  4) Make another loop that prints the values in each struct."
C_Programming,338v8t,w8cycle,1 point,Mon Apr 20 18:15:17 2015 UTC,"include <stdio.h>  include <stdlib.h>  int main() {     fopen (""acars.bin"", ""rb"");  struct flightRec float flightNum = 0, orginAirportCode = 0, destAirportCode = 0;  FILE *ptr;   return 0; } i have this so far"
C_Programming,335qy6,yall_,9,Sun Apr 19 20:26:24 2015 UTC,"That's C++'s standard string object. The 'C' version of that is just using a character array IE. char *.  SDL2 itself is a C library, so it shouldn't be that big of a deal to convert most of the std::string usage to plain char * since you have to pass char *'s to SDL's library. More then likely the std::string's won't be used besides calling c_str() on them to get the char * version of that std::string object. For fancier string manipulation functions from std::string, you can look-up what they do and then replace them with equivalent usages of the string.h functions and basic string manipulation.  As a quick note, a simple usage like this:  int foo(std::string str) {     bar(str.c_str()); }   Can be turned into this:  int foo(char *str) {     bar(str); }"
C_Programming,335qy6,DSMan195276,5,Sun Apr 19 21:16:14 2015 UTC,Use a c-style string (const char*) instead of std::string.  Depending on what loadSurface does with the std::string you may need to dive into the details of std::string to figure out what you need to change in order to make loadSurface work with a char*.
C_Programming,335qy6,cursecat,2,Sun Apr 19 20:35:47 2015 UTC,"Just call it ""C"".  ""Generic C"" is not a thing."
C_Programming,335qy6,theseoafs,1 point,Mon Apr 20 18:27:19 2015 UTC,This looks like a function that the tutorial is asking you to write in which case it should be very easy for us to suggest a replacement that relies on only C.  Can you link to the section of the tutorial so we can suggest what you need to do?  Otherwise replace std::stringwith const char * and then path.c_str() with just path. Hopefully that will be all that is required.
C_Programming,336n8h,DannyDevelops,3,Mon Apr 20 01:09:30 2015 UTC,"if you printf it, youll know whether its the division or the logger, since for me, the following:  #include <stdio.h>                                                            int main(){     int peakAccel = 5;     double peakAccelMS = peakAccel/1000.0;     printf(""%f\n"", peakAccelMS);     return 0; }   outputs 0.005000"
C_Programming,336n8h,inokichi,1 point,Mon Apr 20 04:05:50 2015 UTC,"You've got ""1000.0"" and he's got ""1000"".  Those are different types."
C_Programming,336n8h,ahminus,4,Mon Apr 20 18:06:45 2015 UTC,if peakAccel is an int then peakAccel/1000 is integer division. try: peakAccel / 1000.0
C_Programming,336n8h,crookedkr,1 point,Mon Apr 20 01:31:53 2015 UTC,"That makes sense. I have done that, however I am still not getting any output to the console from %f - I have even created:  double xxx = 9.99;   That doesn't print anything to the console either."
C_Programming,336n8h,crookedkr,5,Mon Apr 20 01:39:57 2015 UTC,post the full code
C_Programming,336n8h,Require_More_Mineral,2,Mon Apr 20 01:42:17 2015 UTC,"Perhaps the problem is in the logger code somewhere. Try creating the string with sprintf first, then printing that string."
C_Programming,336n8h,bpozega,-1,Mon Apr 20 12:39:28 2015 UTC,Int/int= Int. Rounds to nearest whole number  (float*) PeakAccel/1000= 0.005.   Cast a float to peakAccell or make peakAccel a double or float.
C_Programming,3355oy,andrespm_,3,Sun Apr 19 17:28:25 2015 UTC,"Would you prefer English or Spanish?  Please, ask your doubts. I will only point side topics in this comment. Also I know this is probably homework so I won't be giving you a complete solution. But I'll try to help you.  Here are things. They are asking you for a function. What you are doing looks more like a program. While your approach isn't technically wrong, I'd think if I can adjust that issue.  Here are some tips to improve your coding.   You're defining variables on a higher scope than the needed. When using an if clause on two exclusive cases, try using if-else clause. Try using the += operator. Use {} on the if statements or do all the statement in the same line. This is an old debate, some people will argue this, but is easier this way. If possible, define return value and arguments of the main function.   About why your program is not showing the right answer I found at least two mistakes (didn't try the program nor the corrected one). One error is in the function promedio and the other could be said it is in the for loop, but is a more general logical error.  Edit: promedio is not even called. You have the same error on your main function. And what does promedio return?"
C_Programming,3355oy,Don_Equis,1 point,Sun Apr 19 17:45:38 2015 UTC,"The function is at the end, but I don't know how am i gonna calculate the average with just one parameter. Also, I have to calculate the average of odd and even numbers, how do I separate them and change the n value for the number of even and odd data?"
C_Programming,3355oy,Don_Equis,1 point,Sun Apr 19 17:51:55 2015 UTC,At the time you are going to calculate the average you already need to know how many even and odd numbers had been input. How can you achieve that?
C_Programming,3355oy,Don_Equis,1 point,Sun Apr 19 18:25:36 2015 UTC,"promedio doesn't have to return, aaand I don't know"
C_Programming,3355oy,Don_Equis,2,Sun Apr 19 18:35:17 2015 UTC,"I'm a bit busy. But the idea, I'm answering it directly which I didn't want, is count the entries.   Edit: the other problem is that your division is an integer division. Try to correct those things."
C_Programming,3355oy,Don_Equis,1 point,Sun Apr 19 19:28:21 2015 UTC,"What do you mean with ""counting the entries""?"
C_Programming,3345xx,cas_999,6,Sun Apr 19 10:32:10 2015 UTC,"I copied your code into a file called seg.c and compiled as follows:  gcc -g seg.c -o seg   then start as follows:  gdb seg set args 3 10 + run   I get the following output:     Program received signal SIGSEGV, Segmentation fault.     0x0000000000400780 in create_tree (index=0x7fffffffe480, argv=0x7fffffffe580)         at seg.c:63     63    if(is_oper(argv[*index][0])){  So check line 63"
C_Programming,3345xx,mookymix,2,Sun Apr 19 11:06:50 2015 UTC,"I'm guessing you are trying to create some kind of calculator?  Problems: 1. Enum starts indexing at 0 by default, so the function manip_method won't distinguish EVAL from 0. 2. You really should defensively check that malloc doesn't return NULL. In your program, probably not, but... 3. The big issue, ""create_tree()"". When you pass index as ""c"" minus 1 or 2, that's ok in some sense. You are then passing an offset to args to compensate (IMO, better to do something like ""&argv[2]"" than ""argv + 2"" for example - clearer). But in the implementation of create_tree(), you start processing argv then at the back, and since index is a count, off the end of the argv array. The function create_tree should really have three arguments: an index, a limit, and an array pointer. In ""main()"", call with index = 0. Then increment as you call create_tree() recursively. You won't need to pass index as a pointer. In create_tree(), just compare index to limit as you go."
C_Programming,3345xx,lmlight77,2,Sun Apr 19 11:07:11 2015 UTC,"I think it's just confusion. So if I run as ./a.out 2 3 +, then  argv[0] == ""./a.out"" argv[1] == ""2"" argv[2] == ""3"" argv[3] == ""+""   c is initially set to 4, because of these 4 inputs.  then you subtract 1 from c in the else branch, so c is 3.  Then you give a pointer to *argv + 1 to create_tree.  And then you access argv[*index][0]. argv is {""2"", ""3"", ""+""} and index is 3. Since arrays are 0 indexed, you are reading behind the array and segfaulting.  I think you had in mind that c is initially set to the last array index. That would be argc (the number of elements in the array) - 1."
C_Programming,3345xx,haagch,1 point,Sun Apr 19 11:11:13 2015 UTC,"I changed c = c -2 and c = c - 1 to c = c -3 and c = c - 2.  I don't get a seg fault at that point anymore, but now I think my problem is I'm not creating the tree properly, because when I try to test it out and print it its only giving me one value."
C_Programming,3345xx,haagch,1 point,Sun Apr 19 22:20:34 2015 UTC,"So, I'm not good at C and this was something I want to learn too.  https://gist.github.com/anonymous/073df92a3311e28d96be  Someone may correct me here, but I think it's a problem passing char **argv and then trying to access it with argv[i][j], because with a double pointer the compiler doesn't know how long the ""arrays"" are anymore. When changing it to char *argv[] it seems to work.  As someone else has said, the sizeof() took the size of the address, because *Tree was a pointer.  But you want the size of struct node. You can also typedef struct {....} TreeNode, *Tree; but I did it in two steps. TreeNode is the same as node and actually unused. And then of course I added some printfs at the end.  It's still not working right, but maybe you see it yourself what needs to be done."
C_Programming,3345xx,degner,1 point,Mon Apr 20 02:09:06 2015 UTC,Thank you!
C_Programming,3345xx,yarauuta,1 point,Mon Apr 20 05:09:02 2015 UTC,"I don't know if this is the issue, but your malloc's are bad. Tree is a pointer, so sizeof(Tree) is sizeof(void *), so you're only allocating 4-8 bytes when you meant to allocate 16-24 bytes (plus padding), depending on platform."
C_Programming,332wjl,tmtwd,6,Sun Apr 19 00:27:46 2015 UTC,"No. *p++ means take the value pointed at by p, return it, then increment the pointer. So if you have an int a[10], and b points at a[0], then int c = *b++ means make c = a[0], and make b point to a[1].  If you want to increment the value pointed to by p, (*p)++."
C_Programming,332wjl,GBGamer117,2,Sun Apr 19 00:32:23 2015 UTC,""" *p++ means take the value pointed at by p, return it, then increment the pointer."" cleared up a lot for me thanks."
C_Programming,332wjl,Rhomboid,1 point,Sun Apr 19 00:36:37 2015 UTC,"int a = 23; int* ptr = &a; int bs = *ptr++; printf(""%d\n"", bs);//shouldn't this print out 24 in that case, though?  printf(""%d\n"", a);"
C_Programming,332wjl,GBGamer117,5,Sun Apr 19 00:39:38 2015 UTC,"You're still incrementing the pointer, not the pointed-to value.  As others have said, the post-increment operator has higher precedence than the dereference operator (unary *).  Print out this table and tape it somewhere near your computer."
C_Programming,332wjl,TehJohnny,1 point,Sun Apr 19 00:59:16 2015 UTC,ok
C_Programming,332wjl,TehJohnny,3,Sun Apr 19 01:08:43 2015 UTC,"(*ptr)++, not *ptr++"
C_Programming,332wjl,TehJohnny,1 point,Sun Apr 19 00:43:08 2015 UTC,"Ok, I remember what I wanted to do you  said "" *p++ means take the value pointed at by p, return it, then increment the pointer.""  so I thought *p++ should return the value of *p + 1, and leave the value of *p unchanged.  I see now that *p++ increments the pointer by sizeof(int) and just returns the int value at that address."
C_Programming,332wjl,CausticInt,1 point,Sun Apr 19 01:05:43 2015 UTC,"Why would it print out 24? Just because a bit of memory has a value (23) doesn't mean the next bit of memory has (24), when you increment your pointer from your int, you're moving the pointer to the next 4 bytes of memory which could be ANYTHING. The reason it works for the char one is because the next bit of memory IS a char because your string is stored in contiguous memory and are almost always ended by '\0' (null terminator) so you can do stuff like:    while (*newch != '\0') { dostuff(); newch++; }    And it will run until the memory *newch is pointing to == (0).    Now if you had, ""int a[2] = { 23, 24 };"" it would then point to the next address from a[0] which would be a[1] and == (24) :P"
C_Programming,332wjl,Fylwind,1 point,Mon Apr 20 16:54:53 2015 UTC,"Cool thanks, that explains it nicely :)"
C_Programming,332wjl,FUZxxl,1 point,Mon Apr 20 20:27:39 2015 UTC,"Pointers are tricky, you gotta pay attention to order of operations and all kinds of stuff, if you can master them (I still have issues with em after 15 years of ""learning C/C++""), you're basically set. :P They're the magic that makes C work."
C_Programming,3310s0,tmtwd,9,Sat Apr 18 13:42:37 2015 UTC,"It's to avoid a bunch of calls to malloc and free, presumably on a system where these calls are relatively expensive. Rather than freeing nodes when they are no longer needed, they are inserted into freelist. Then those nodes can be reused later, avoiding a call to malloc."
C_Programming,3310s0,zifyoip,3,Sat Apr 18 13:57:03 2015 UTC,"Ok finally that makes sense, it has been confursing me since I first read it almost a year ago!"
C_Programming,3310s0,Jack126Guy,1 point,Sat Apr 18 14:17:52 2015 UTC,"TIL: There is a slightly different application of the term ""free list""."
C_Programming,3310s0,autowikibot,1 point,Sun Apr 19 03:15:09 2015 UTC,"Free list:       A free list is a data structure used in a scheme for dynamic memory allocation. It operates by connecting unallocated regions of memory together in a linked list, using the first word of each unallocated region as a pointer to the next. It is most suitable for allocating from a memory pool, where all objects have the same size.  Free lists make the allocation and deallocation operations very simple. To free a region, one would just link it to the free list. To allocate a region, one would simply remove a single region from the end of the free list and use it. If the regions are variable-sized, one may have to search for a region of large enough size, which can be expensive.  Free lists have the disadvantage, inherited from linked lists, of poor locality of reference and so poor data cache utilization, and they do not automatically consolidate adjacent regions to fulfill allocation requests for large regions, unlike the buddy allocation system. Nevertheless, they're still useful in a variety of simple applications where a full-blown memory allocator is unnecessary or requires too much overhead.     Interesting: Free List (Liechtenstein) | List of political parties in Liechtenstein | Liechtenstein general election, February 1993   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,3310s0,Jack126Guy,1 point,Sun Apr 19 03:15:53 2015 UTC,what was the original application?
C_Programming,331iit,zakariii,2,Sat Apr 18 16:42:01 2015 UTC,"Here are some things you should take a closer look at:   strcmp(&statement[i],""="") - Strcmp compares two strings. Would it think that ""="" and ""="" are equal? What about ""= 0;"" and ""=""? How would you compare two chars instead of two strings? Would strncmp be helpful here? strcmp(var_library[x],&statement[i]) - What are the possible values of x in this for loop, and does it make sense to use it as an index for var_library?   Don't be afraid to experiment with small functions that do a single thing at a time. Take your time to get familiar with loops, arrays and strings, then you'll be able to get them to do exactly what you want."
C_Programming,3307by,tmtwd,6,Sat Apr 18 05:46:59 2015 UTC,"Why is this?   (char)c is necessary in both cases, it's a bug that it is not present in the second case in this code.   From the definition of strchr in the C standard (ISO/IEC 9899:2011) section 7.24.5.2/2:   The strchr function locates the first occurrence of c (converted to a char) in the string pointed to by s. The terminating null character is considered to be part of the string.   The reason behind this is to support strchr being called with both char values, and with values returned by getchar.  The char type may have negative values. Typically it has range 0 to 255 or -128 to 127.  The former is more common on ARM and the latter more common on x86 / x64.  However the getchar() function returns a non-negative value when it reads a successful character, even on systems with signed char. This is so that the EOF value is out-of-band.  To use a specific example, we might have:  int ch = getchar();  char *ptr = strchr(str, ch);   Using the old ANSI code page; if the person types é then ch has value 130.  However if str contains the same character, and we are on a system with signed char, then the value of *s for that character will be -126.  Then the test *s == c fails because -126 == 130 is false.  The cast is necessary to bring both operands into the range of char.  Technical notes: 1. Casting out-of-range values to char is implementation-defined but we assume the implementation will define the obvious conversion else the system will be unworkable;  2. Systems exist that do not have 8-bit char but I am ignoring them for the purposes of this post.   Also why do we need to cast s to a char at all (char *) s. Isn't salready a char pointer?   No, it's a const char pointer. The const makes a difference.  It is not permitted to implicitly convert pointers to const, to pointers to non-const as that would defeat the purpose of const. Example:  const char *ptr = ""foo""; char *p2 = ptr; p2[0] = 'x';  // oops   In fact the second line of that snippet must cause an error, the const exists in the type system to guard against this.    The function returns non-const char * because the same function is used to search in both const strings and non-const strings, and it is less annoying for the person using the function if it returns char *."
C_Programming,3307by,OldWolf2,3,Sat Apr 18 09:08:49 2015 UTC,"The first cast should not be necessary. In fact, that cast may cause the function to behave quite unexpectedly under some circumstances—for example, if the value EOF is passed in as the parameter c. It would be better to remove that first cast.  The second cast is necessary but dangerous. It is necessary because the function signature says that the function should return a char *, but the type of s is const char *, not char *. The cast is necessary to remove the const. But that is potentially dangerous, because s might be a pointer to a non-modifiable string, and casting it to a char * hides that fact."
C_Programming,3307by,zifyoip,7,Sat Apr 18 06:16:13 2015 UTC,"It doesn't make sense that strchr() takes a pointer to const but returns a pointer to non-const. I can only assume this is for backward compatibility with legacy code that was written before const was added to the language in 1989.  The C++ version of this function, std::strchr(), returns a pointer to const as one would expect."
C_Programming,3307by,Spire,4,Sat Apr 18 06:32:39 2015 UTC,"I can only assume this is for backward compatibility with legacy code that was written before const was added to the language in 1989.   I was mistaken about the reason. The actual reason is that strchr() needs to be able to take pointers to either const or non-const. Defining it this way is necessary in C because unlike C++, C doesn't support function overloading. More information here."
C_Programming,3307by,Spire,3,Sat Apr 18 06:40:52 2015 UTC,"The first cast should not be necessary.   In fact it is necessary - see my answer. You're not supposed to pass EOF (and if you do, it has to behave as if cast to char)."
C_Programming,3307by,OldWolf2,1 point,Sat Apr 18 09:14:54 2015 UTC,"Right, I noted that in my follow-up comment."
C_Programming,3307by,zifyoip,1 point,Sat Apr 18 12:32:25 2015 UTC,(char) c should not be necessary?
C_Programming,3307by,zifyoip,5,Sat Apr 18 06:17:51 2015 UTC,"Yes, that is what I meant.  However, looking more closely at the C specification, I see that the strchr function is supposed to cast its second argument to char, so actually that first cast is necessary in order to be strictly compliant with the standard. In that case, there should also be a corresponding cast in the return statement; the condition of the ?: operator should be *s == (char)c."
C_Programming,3307by,zifyoip,1 point,Sat Apr 18 06:24:08 2015 UTC,"But, according to this page there is not!  http://en.wikibooks.org/wiki/C_Programming/Strings#The_strchr_function"
C_Programming,3307by,OldWolf2,2,Sat Apr 18 06:53:38 2015 UTC,That implementation does not conform to the C standard.
C_Programming,3307by,geeknerd,1 point,Sat Apr 18 06:54:20 2015 UTC,I edited that snippet to fix
C_Programming,3307by,OldWolf2,2,Sat Apr 18 13:16:37 2015 UTC,The proper comparison is *s == (char)c to handle searching for '\0'   From the definition of strchr in the C standard (ISO/IEC 9899:2011) section 7.24.5.2/2:   The strchr function locates the first occurrence of c (converted to a char) in the string pointed to by s. The terminating null character is considered to be part of the string.
C_Programming,32zkj1,rhascal,4,Sat Apr 18 01:30:07 2015 UTC,"You should implement a toy Unix filesystem. You'll learn a lot and have to make use of all those things... You could use a single flat file as your disk, and implement stuff like cat, ls, etc on top of it.  This is a project you can make as complicated or as simple as you like. Plus I think it makes great example code."
C_Programming,32zkj1,codespam,1 point,Sat Apr 18 01:41:47 2015 UTC,You can implement a unix system from a .c text file (that compiles to a native program)??
C_Programming,32zkj1,tmtwd,1 point,Sun Apr 19 00:18:59 2015 UTC,Yes. That's possible. It won't be usable from other programs though. You could also use fuse.
C_Programming,32zkj1,FUZxxl,3,Sun Apr 19 19:54:31 2015 UTC,Write a language using flex and bison
C_Programming,32zkj1,vimv,1 point,Sat Apr 18 05:47:06 2015 UTC,^ Currently doing that for one of my final projects it's pretty cool
C_Programming,32zkj1,CraftyNecromancer,2,Sat Apr 18 21:30:34 2015 UTC,Writing a brainfuck interpreter helped me a lot to understand what a pointer is and how they work.
C_Programming,32zkj1,boraalper4,2,Sat Apr 18 04:20:13 2015 UTC,"Create a program that can accept a Cesar ciphered text document, and output the decrypted text. Basically, you have a dictionary file and you chop the ciphered text into words. you take a word and you try all possible shift values (26) and use a comparator. if you get a match, record that. do that until you are reasonably sure you found the correct shift, shift the text and output.   steganography - take as input a .ppm image. store a message. Basically, the first byte is the length of the message. after that, store your message in the least significant bits of the image. also, your program should be able to take a .ppm image with a message encrypted inside and output the secret message.  I've done both of these so if you want more detail let me know."
C_Programming,32zx6l,once-prg,6,Sat Apr 18 03:44:25 2015 UTC,"Numbers like 0.1 cannot be represented exactly using binary floating point.  The best the computer can do is use a nearby value, one that is very slightly larger or smaller, but in either case very close to 0.1.  If by chance it was smaller, then your calculation will result in something slightly less than 18000, and when you convert that floating point value back to an integer, the digits to the right of the decimal point are truncated (aka round toward zero) which results in 17999.  Normally when you think about rounding you are thinking of a different rounding mode, like round to nearest, which is probably the mode you want to use.  (The C standard library has round() and variants for this purpose.)  Another option is to use a printf() format string that performs proper rounding to the desired number of digits (including no digits, if that's what you want), rather than converting to an integer.  Most of the time you shouldn't be using floating point when dealing with currency.  The & operator takes the address of a variable, forming a pointer to that variable.  scanf() requires that you pass a pointer to int when using %d, because it needs to write to that variable.  If it worked like printf() and took the value as a regular parameter, rather than taking a pointer to the value, it wouldn't be able to modify anything because all parameters are always passed by value in C, which creates a copy.  This should have been explained in depth by whatever teaching materials you're using.  If not, find better ones.  You are on a path to misery if you continue to write programs that contain aspects that you don't understand.  Never, ever copy and paste code without understanding what it does.  Also, your program logic is quite broken.  The indentation implies that you think all three of those statements are part of the if statement, but because there are no braces, only the first one is part of the if.  You will get a nonsense answer if you enter a quantity of 1000 or less.  You need to rethink the logic here completely, because the multiplication of quantity times price needs to happen unconditionally, whereas you only want to subtract the discount if the quantity is greater than a given threshold.  Finally, choose better variable names.  That comment that you wrote that says /* quantity, price */ is an indication that you picked bad names.  It would be unnecessary if you had written simply  int quantity, price;   Don't pick three-letter cryptic variable names that need comments explaining what they really mean."
C_Programming,32zx6l,Rhomboid,4,Sat Apr 18 04:56:34 2015 UTC,"If you're just dealing with money, you can use cents as your unit and printf them as dollars."
C_Programming,32zx6l,f5f5f5f5f5f5f5f5f5f5,1 point,Sat Apr 18 13:16:09 2015 UTC,"A big thanks go here. I found a better way to do my coding. I'm using Let Us C 5th edition to program, and although it is more up-to-date and well explained than K&R, they still not good books. So what I decided to do is to just pick some syntax into the books and completely ignore the examples they give. What you consider ""three-letter cryptic variable names"" is actually just the result of me ""copying and pasting code without understanding what it does"". Now I found out only one able to teach me is myself, so I just got the basic control flow structures from let us C and decided to look the web for problems I could solve myself, its working pretty better. Thanks."
C_Programming,32zx6l,zifyoip,3,Sun Apr 19 21:45:46 2015 UTC,http://floating-point-gui.de/
C_Programming,32zx6l,dm1407,1 point,Sat Apr 18 04:53:27 2015 UTC,What Every Programmer Should Know About Floating-Point Arithmetic or Why don’t my numbers add up?
C_Programming,32zx6l,acwsupremacy,3,Mon Apr 20 08:26:52 2015 UTC,"Everyone has explained why you're getting the behavior you're getting; in general, when you're working with currency (or anything else that generally uses fixed precision) there is no need to deal with floating-point math and the subtle errors that result. In this case, simply do all your math and store all your intermediate values as cents, and divide by 100 to output in dollars. You'll still have to touch floating point once or twice, for input and output (that or else hack around it with messy format strings), but you won't be propagating and amplifying the error throughout your calculations."
C_Programming,32zx6l,chalk46,2,Sat Apr 18 19:58:44 2015 UTC,because you're not using floating point vars
C_Programming,32xmwi,pixel4,5,Fri Apr 17 15:46:28 2015 UTC,"Is it essentially inserting dlopen/dlsym calls at the start of the program? If not, why not?   When you use dlopen with RTLD_NOW and RTLD_GLOBAL, the result works actually pretty same as dynamic linking. However, linking creates a list of symbols that needs to be resolved before the program can execute. If any is missing, it won't run and execve will fail with ENOENT. Linker also does not resolve only function calls but other objects as well, eg. RTTI for C++. With dlopen, RTTI may not work correctly unless you use RTLD_GLOBAL. When you use dlopen and dlsym abd find that the symbol is not available, the program is already running so execve has succeeded.   Does build time linking provide optimizations over dlopen/dlsym?   Yes, all the symbols are loaded when the program starts and they are faster to use. Also, the linker does not need to care about thread-safety and concurrecy because there are no threads running so it can load the libraries much faster. In Unixes, the symbols are stored in a table which is easily cached by the CPU. The table can even be precomputed but that is not much used anymore for security reasons. In Windows, the linker actually changes the code so that it does not have any indirection.   Does build time linking simply give extra type checking?   No. For C, there is no type checking during linking. For C++, you need to use mangled names in dlsym and the type checking is therefore the same."
C_Programming,32xmwi,StenSoft,2,Fri Apr 17 20:55:05 2015 UTC,"When you link against a shared library, the linker looks at that library to make sure all the symbols needed are there.  At runtime, the loader will attempt to load the shared library. If it's not present, you'll get an error. If some of the symbols are missing, you'll get a different error.  It is not the same as opening a .so with dlopen() and calling functions via dlsym()."
C_Programming,32xmwi,jdonniver,1 point,Fri Apr 17 17:08:16 2015 UTC,"Abstractly, why's it not the same though?  Isn't the linker just inserting those dlopen/dlsym calls on your behalf;  what is ""the loader"" and how is it different from dlopen/dlsym, does it use anything lower level?"
C_Programming,32xmwi,jdonniver,2,Fri Apr 17 18:47:18 2015 UTC,"When you use dlopen() and dlsym(), the functions are not added to the symbol table of your binary.  When you link against a shared library, those functions and names are in your symbol table / jump table.  Caling foo() will work for shared libraries, but will not work if you use dlopen() and then try calling foo().   You can have multiple libraries dlopen()'d that use the same function names, but you can't link against multiple shared libraries with the same function names. You'll get an error that the symbol is defined twice.  Play with the objdump, nm, and ldd tools on linux to get an idea of what's going on.  Use objdump -t , you'll see what symbols are defined and undefined."
C_Programming,32xmwi,jdonniver,1 point,Fri Apr 17 19:15:32 2015 UTC,"But I could define a global uninitialize symbol and use dlopen/dlsym to initialize it.  foo = dlsym(lib, ""foo""); foo()  I think my question is around the lower level mechanic.  I know the high-level differences between dynamic loading and linking.  But I'd like to gain insights about the hidden lower-level implementation of dynamic linking; is it just wrapping dlopen/dlsym? Or is it more nuanced."
C_Programming,32xmwi,chasesan,1 point,Fri Apr 17 19:59:31 2015 UTC,"If you want to know how it works in detail, start reading the ELF specification and the loader source code - it's all out there.  It's not the same as using dlopen() and dlsym(), but it may use similar functionality. Try disassembling a simple hello world binary, one linked statically and one linked dynamically. Look through the calls and see what you find.  It does not use dlopen(), because in order to use dlopen, you have to link to libdl ( -ldl with gcc )."
C_Programming,32xmwi,benwaffle,1 point,Mon Apr 20 14:29:00 2015 UTC,I am actually somewhat curious myself. But I can assume it varies based on compiler and operating system.
C_Programming,32xmwi,StenSoft,1 point,Fri Apr 17 16:39:52 2015 UTC,I believe the .so file is mmaped when the process is executed. Try $ cat /proc/self/maps
C_Programming,32xmwi,adrusi,1 point,Fri Apr 17 21:47:55 2015 UTC,It is mmapped with dlopen as well
C_Programming,32uoyn,Pipprovis,11,Thu Apr 16 21:27:58 2015 UTC,strcpy_s and friends are Microsoft-only extensions. See https://msdn.microsoft.com/en-us/library/8ef0s5kh.aspx
C_Programming,32uoyn,rjw57,8,Thu Apr 16 21:43:42 2015 UTC,"Technically they are part of C11, but please don't use them. They have been introduced by Microsoft in an attempt to lock you into Windows. They are not going to be supported by Linux in the near future."
C_Programming,32uoyn,FUZxxl,3,Thu Apr 16 22:34:47 2015 UTC,Dang.  I haven't seen it mentioned in the book up to this point.  Thank you for the response.
C_Programming,32uoyn,FUZxxl,20,Thu Apr 16 21:50:41 2015 UTC,"The string functions provided by the C library are secure if you use them correctly. Please don't buy into the _s functions from Microsoft, they solve a problem that doesn't exist and do a very bad job at that."
C_Programming,32uoyn,Chooquaeno,4,Thu Apr 16 22:31:54 2015 UTC,strcpy_s is not available because you don't have C11…
C_Programming,32uoyn,raevnos,2,Thu Apr 16 21:38:57 2015 UTC,Forgive me.  I am new to C.  Is it possible to use C11 (I know that isn't the correct verbiage)?  Would you suggest using C11 standards?
C_Programming,32uoyn,raevnos,2,Thu Apr 16 21:49:35 2015 UTC,"Those _s functions are optional to C11, and not implemented in glibc, the linux standard library.  I'd stick to features that compilers and libraries are required to have for C11 support."
C_Programming,32uoyn,DreadedEntity,2,Fri Apr 17 07:03:41 2015 UTC,"If your book is telling you to  #define __STDC_LIB_EXT1__ 1   it's wrong.  You're supposed to use  #define __STDC_WANT_LIB_EXT1__ 1   before including any header files, and then see if   __STDC_LIB_EXT1__   is defined to see if you can use the functions in Annex K."
C_Programming,32uoyn,raevnos,3,Fri Apr 17 07:08:09 2015 UTC,"I am beginning to learn C using the book ""Beginning C, 5th Edition"" by Ivor Horton   That is your problem. You should use this book: http://en.wikipedia.org/wiki/The_C_Programming_Language"
C_Programming,32uoyn,FUZxxl,5,Thu Apr 16 23:13:32 2015 UTC,"The author of that Wikipedia article obviously had a very high opinion of the book, but is it that good? I'd consider spending for it if it really was the ""authoritative reference on C"".  And yes, I do realize that the co-author for the book literally designed C"
C_Programming,32uoyn,raevnos,7,Fri Apr 17 00:36:52 2015 UTC,"The problem with TCPL is that it hasn't been updated since the 80's. The language has gone through a couple of revisions since then. It's not a bad foundation for the basics, but it's not authoritative any more, the way it was in its first edition long before standardization."
C_Programming,32uoyn,FUZxxl,1 point,Fri Apr 17 07:10:35 2015 UTC,"Well, the stuff added in the revisions isn't substantial; these extensions shouldn't really matter for a beginner and you can have a look at them later on anyway."
C_Programming,32uoyn,OldWolf2,8,Fri Apr 17 09:00:01 2015 UTC,"Booleans, designated initializers and compound literals are all really useful things to pick up from the beginning."
C_Programming,32uoyn,FUZxxl,1 point,Fri Apr 17 09:09:26 2015 UTC,I never had the need to use the _Bool type. You can use int variables for boolean variables just fine and in fact that's what people have been doing for 20 years. Compound literals and designated initializers are useful but you don't need to know about them up front.
C_Programming,32uoyn,Mines_of_Moria,1 point,Fri Apr 17 09:18:12 2015 UTC,Using int for bools has problems.
C_Programming,32uoyn,OldWolf2,1 point,Fri Apr 17 14:30:09 2015 UTC,"I never had any. Of course, when you have a lot of booleans you might want to look for a different way to store them."
C_Programming,32uoyn,Mines_of_Moria,1 point,Fri Apr 17 15:26:25 2015 UTC,Like what? Readability? Issues using your code on various systems due to differing integer sizes?
C_Programming,32uoyn,FUZxxl,1 point,Sat Apr 18 07:09:36 2015 UTC,"Lack of implicit conversion to bool is the main thing. For example:  bool flag_test(uint64_t flags) {     return flags & SOME_FLAG; }   is perfectly fine with true boolean,  however with int then it will cause implementation-defined behaviour (probably returning 0) if SOME_FLAG > INT_MAX .  Of course you can be aware of this issue and work around it, but it's worse than actually having a true boolean."
C_Programming,32uoyn,DreadedEntity,3,Sat Apr 18 08:35:07 2015 UTC,"Good to know, thanks. The more C I learn, the more I realize how much I don't know. It's like my ignorance is growing exponentially while my knowledge increases linearly."
C_Programming,32uoyn,FUZxxl,1 point,Sun Apr 19 04:08:34 2015 UTC,"You can get a PDF of that book on the internet. It's a book for people who already know how to program; it's not too chatty and offers a great and correct description of the C language. Don't expect “The C Programming Language” too spoonfeed you; if you don't know what a pointer is, this book might not be for you."
C_Programming,32uoyn,raevnos,1 point,Fri Apr 17 08:59:16 2015 UTC,"Well I know what a pointer is, I know about referencing and dereferencing with * and &, I'm just having a fair amount of trouble using them correctly in my programs when dealing with arrays"
C_Programming,32uoyn,TehJohnny,1 point,Fri Apr 17 17:47:19 2015 UTC,Arrays in C are quirky. That's a bit unfortunate.
C_Programming,32uoyn,FUZxxl,-1,Fri Apr 17 18:19:57 2015 UTC,http://lmgtfy.com/?q=c+programming+language+pdf&l=1
C_Programming,32uoyn,TehJohnny,3,Fri Apr 17 05:45:47 2015 UTC,"Eh. Good book, but just a tad bit outdated."
C_Programming,32uoyn,FUZxxl,1 point,Fri Apr 17 06:55:56 2015 UTC,What does strcpy_s do that strncpy doesn't? I also see a strncpy_s ... >>
C_Programming,32ufo4,jlan90,5,Thu Apr 16 20:18:08 2015 UTC,You only allocate enough space to hold one record struct in your database pointer.
C_Programming,32ufo4,raevnos,3,Thu Apr 16 20:46:47 2015 UTC,Oh wow thank you! Dont know how i missed that.
C_Programming,32ufo4,raevnos,2,Thu Apr 16 20:55:53 2015 UTC,"I have a nother question you can hopefully answer. I want to use strcpy() instead of just setting   database[recordNum].username = tokenize   because otherwise all of the categories except for the index for all records are equal to the final record read in. However when i do use   strcpy(database[recordNum].username, tokenize);   instead, it gives me another seg fault. Do i have to allocate memory for each of the record facts if i want to use strcpy?"
C_Programming,32tzin,bravesaint,1 point,Thu Apr 16 18:21:13 2015 UTC,"The first question you need to figure out: how are you storing the lines?  First, let's assume we know there's always going to be 3 lines to read in, as your example shows.  In that case, your best bet is an array of arrays:  char dna[3][LENGTH]; for ( i = 0; i < 3; i++ )     fgets(dna[i], LENGTH, input);   But, we don't know the number of lines until we read the file.  So, there's two options.  First, you can set an upper limit (just like you did with the length of each line) if you know there will never be more than some maximum number of lines.  The second option is to do dynamic memory allocation:  typedef char dna_t[LENGTH]; dna_t *dna = (dna_t*) malloc(lines * sizeof(dna_t)); for ( i = 0; i < lines; i++ )     fgets(dna[i], LENGTH, input); ... free(dna);"
C_Programming,32tzin,boredcircuits,1 point,Thu Apr 16 18:51:54 2015 UTC,"Thank you for the reply!  How would I go about reading in that second line and assigning it to another variable which sets the length for a second array?  Say, I read in the first line and save that as a regular string (array of chars), THEN read in the 2nd line, save that as a variable, and use that to set the size of a larger array, which saves in the remaining lines? Does that make sense, my lingo/word use is fairly limited in C."
C_Programming,32tzin,boredcircuits,1 point,Thu Apr 16 19:07:26 2015 UTC,"Don't worry, I get what you're saying.  fscanf is the usual way to read a number:  int lines; fscanf(input, ""%d"", &lines);   But you have to be careful mixing fscanf() with fgets().  The ""correct"" way of doing this is to read in the line with fgets(), then use sscanf() to get the number from the line.  But in your case, just read in a character using fgetc(input) after reading the number and before reading the lines of DNA."
C_Programming,32tzin,boredcircuits,1 point,Thu Apr 16 19:34:43 2015 UTC,"I think I follow. So after the first line using fscanf, then fgetc for ONE character, then a loop to get the rest of the lines?"
C_Programming,32tzin,boredcircuits,1 point,Thu Apr 16 19:54:59 2015 UTC,"fgets() for the first line, fscanf() + fgetc() for the second line, and then a loop of fgets() for everything that remains."
C_Programming,32tzin,HiramAbiff,1 point,Thu Apr 16 20:05:21 2015 UTC,"Would you mind showing me the code to implement this? I'm just continuing to have issues...  So far I found a way to read it all, but I believe it's saving the entire text file (formatting correct, mind you) as a single array. Here's what I have for that part:  void makeArray(FILE *input,char firstDna[LENGTH][ROW]){     int i,j;      for(i = 0; i < LENGTH; i++){        for(j =0; j < ROW; j++){        fscanf(input,""%c"",&firstDna[i][j]);         printf(""%c"", firstDna[i][j]);        i++;        }     } printf(""\n\n\n""); }"
C_Programming,32rov0,DreadedEntity,5,Thu Apr 16 04:10:18 2015 UTC,"On a phone and only briefly looked, but change:  assignRandomName(people[i], firstNames, lastNames);  To:  assignRandomName(&people[i], firstNames, lastNames);  Also, loop from 0 to 9, not 0 to 10. That is, change <= to <"
C_Programming,32rov0,thrakkerzog,1 point,Thu Apr 16 05:16:02 2015 UTC,"So it seems that even if I fixed my function, the program would have still crashed because of my array selection. Why is that? I thought by declaring my array with [10] would give me an 11-element array (from 0 to 10)"
C_Programming,32rov0,SlayterDev,5,Thu Apr 16 15:05:10 2015 UTC,Wrong. Declaring an array with size [10] gives you 10 elements from 0-9.
C_Programming,32rov0,thrakkerzog,3,Thu Apr 16 15:08:11 2015 UTC,"array[10] declares an array of length 10, indexed 0->9.  Your program might not have crashed, but you are writing to memory outside of your array.  Depending on the compiler, it might have overwritten the value of ""i"", causing your loop to be very unpredictable."
C_Programming,32rov0,conciliatory,2,Thu Apr 16 15:20:36 2015 UTC,"#include <stdio.h>                                                               #include <stdlib.h>                                                              #include <string.h>                                                              #include <math.h>                                                                #include <time.h>                                                                 struct Man {                                                                                                                                 char firstName[10];                                                              char lastName[20];                                                           };                                                                                void assignRandomName(struct Man *man, char *firstNames[], char *lastNames[]);    int main() {                                                                                                                                      srand(time(NULL));                                                                char *firstNames[] = {""Jeff"", ""John"", ""Garrett"", ""Jason""};                       char *lastNames[] = {""Matthews""};                                                 struct Man people[10];                                                           int i;                                                                            for(i = 0; i < 10; i++) {                                                                                                    assignRandomName(&people[i], firstNames, lastNames);                         };                                                                                return 0;                                                                    };                                                                                void assignRandomName(struct Man *man, char *firstNames[], char *lastNames[]) {                                                                                    int randNum = rand() % 4;                                                        strcpy(man->firstName, firstNames[randNum]);                                     strcpy(man->lastName, lastNames[0]);                                              printf(""Man has been given the name: %s %s\n"", man->firstName, man->lastName); };"
C_Programming,32rov0,_teslaTrooper,1 point,Thu Apr 16 05:37:45 2015 UTC,"Thanks. I mean it works and I noticed and made the changes but you didn't explain them. I specifically said I'm having trouble with pointers, specifically"
C_Programming,32rov0,sireel,3,Thu Apr 16 15:01:34 2015 UTC,"EDIT: my example was incorrect, it should be *(people + i) and just (people + i), see /u/sireel and /u/dumsubfilter's replies.     people[i] can be written as *(people + (sizeof(man) * i))  As you can see, while people is a pointer, people[i] is the struct itself because the [i] includes a dereference. So you're passing a struct to your function which expects a pointer to a struct.   (people + (sizeof(man) * i)) (note the lack of dereference operator) can be written as &people[i] which is much more readable."
C_Programming,32rov0,_teslaTrooper,2,Thu Apr 16 12:24:19 2015 UTC,"I'm mostly a C++ programmer, but I think that you've made a mistake.  &people[i] is equivalent to (people + i) or ((void)people + (sizeof(man) * i)) because adding a size_t or unsigned to a pointer increments it by whole-object amounts, be that structs or ints. sizeof(Foo) returns a size in bytes, so the pointer needs to point to a byte type (or void, as void* are treated like byte pointers)."
C_Programming,32rov0,sireel,2,Thu Apr 16 14:51:22 2015 UTC,"Thanks for the correction, I tend to think of everything as byte arrays :/"
C_Programming,32rov0,_teslaTrooper,1 point,Thu Apr 16 18:33:44 2015 UTC,"you're welcome, and to be fair, everything is just byte arrays, but we've got compilers which are more helpful (sometimes 'helpful') than assemblers :D"
C_Programming,32rov0,dumsubfilter,1 point,Thu Apr 16 18:54:35 2015 UTC,"This is pretty helpful. Pointers are giving me a lot of trouble.  So if I just use an array without selecting an element then C will give me the memory address, right? But if I'm trying to select an element out of that array, it gives me the data and I need to reference it with &?"
C_Programming,32rov0,Chooquaeno,1 point,Thu Apr 16 14:42:02 2015 UTC,"yes that's it, my example wasn't completely right (I was thinking of a char pointer instead of a struct pointer) but the main idea is there."
C_Programming,32rov0,ModernRonin,1 point,Thu Apr 16 18:51:30 2015 UTC,"That's wrong.    people[ i ]   This is the same as:  *(people + i)   Whatever you think you are doing by adding that (sizeof(man) * ) stuff, is wrong."
C_Programming,32rov0,ModernRonin,1 point,Thu Apr 16 17:23:28 2015 UTC,http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Member_and_pointer_operators  http://c-faq.com/aryptr/aryptrequiv.html
C_Programming,32rov0,ModernRonin,1 point,Thu Apr 16 17:08:42 2015 UTC,"When you do assignRandomName(people[i] ...) you are passing a full structure (of type Man) to assignRandomName. Because people[i] is a struct, not a pointer.  If your intention was to pass the full struct, and not a pointer, then you would need to alter the declaration of assignRandomName() so it reads:   void assignRandomName(struct Man man, char *firstNames, char *lastNames)   In case the change isn't obvious, it's that the ""*"" has been removed from struct Man *man. You see, struct Man *man declares a pointer. A pointer that points to a structure. Specifically a pointer that points to a struct Man.  If you pass in a structure where you were supposed to pass in a pointer... it isn't going to work the way you expect.  So if you want to pass in a struct, then make the changes I mentioned above.  ...  However, you probably DON'T want to pass in a struct. The reason is, C passes function parameters ""by value."" In other words the compiler makes a copy of the parameter, and hands the copy to the function. So in your case, a copy of people[i] would be given to the code inside assignRandomName(). Changes would be made to the copy. And when assignRandomName() exited, the copy would be silently thrown away. Thus, no changes would ever be seen back at main().  So what you probably want, is to pass in a pointer to people[i]. Then you can ""chase the pointer"" and find the actual struct.  First, fix the for() loop. To make a pointer, you put ""&"" in front of the thing you want to make the pointer to. So inside the for() you put:  assignRandomName(&(people[i]), firstNames, lastNames);   You leave the declaration of assignRandomName() alone - it is already asking for a pointer. All good there.  You will need to fix the code inside assignRandomName(), it is not using the -> operator (access a struct via a pointer) correctly. I will continue when I get home... gotta close up shop now."
C_Programming,32rov0,raevnos,1 point,Fri Apr 17 00:15:42 2015 UTC,"Yeah, I knew C makes a copy so I was trying to give the function a pointer to my struct so I could edit the struct itself. I managed to get the program working with the advice of others that have commented, but thanks for helping me solidify my understanding"
C_Programming,32v8de,RiseOfBalls,4,Fri Apr 17 00:09:00 2015 UTC,Do your own homework.
C_Programming,32v8de,zifyoip,-5,Fri Apr 17 00:13:47 2015 UTC,i suck at this!!! no programming background and im in first semester of computer programming T.T
C_Programming,32v8de,SuaveZombie,1 point,Fri Apr 17 00:29:21 2015 UTC,"So your solution is to ask other people to write it for you? How do you think everyone else learned how to code?  If you're this stuck, I would suggest asking your Professor/TA for help. There's no shame in that."
C_Programming,32v8de,infey,6,Mon Apr 20 00:01:33 2015 UTC,Alright here a program whose output  looks like that. http://imgur.com/G2ydEos
C_Programming,32v8de,FUZxxl,1 point,Fri Apr 17 00:59:33 2015 UTC,"You, I like you."
C_Programming,32v8de,DustbinJ,5,Sun Apr 26 19:47:45 2015 UTC,"Yeah, I'll get right on it."
C_Programming,32v8de,DustbinJ,-5,Fri Apr 17 00:18:32 2015 UTC,OMG THANK YOU!!!
C_Programming,32v8de,FUZxxl,7,Fri Apr 17 00:29:33 2015 UTC,I'm joking. Do your own homework or pay me $100.
C_Programming,32pp3g,angdev,28,Wed Apr 15 18:36:30 2015 UTC,"Embedded engineer here, I think it is largely due to the variance of different processor families, and how they handle bit shifts, with or without rotates. As a habit (probably superstitious), I mask any shifts I make, and if the compiler decides that I did something extra and wants to get rid of it, great, but I'm guaranteed to get the behavior I want.  Modern processors and assemblers are probable consistent, but for sake of reliability, I will always take the extra code to make it very explicit what I want so that it is clear what I mean.  uint8 y = 0xA5; uint8 x = ( ( y << 4 ) & 0xF0 ) | ( ( y >> 4 ) & 0x0F );   Sure, the compiler might decide this is just a ROT, but I don't care what the compiler does, and if I need to guarantee the cycle count, I'll inline the assembly.  Edit: Also, I never trust signed shifts, mostly because I never assume to remember how they work, even if I researched it specific to this processor family. Id rather have verbose explicit code than clever code."
C_Programming,32pp3g,jahmez,2,Wed Apr 15 19:15:47 2015 UTC,"I'll inline the assembly.   Bingo. It does bother me (more than it logically should) that this gap in C exists vs. underlying hardware, along with very few other things (afaik, cli/sti, referring to x86, and such have no C equivalent). In C++ I ended up creating operators (<<< and >>>) for rotation, in C I have rol and ror, like the (x86) assembly. Still bothers me, but... it works."
C_Programming,32pp3g,r_notfound,2,Thu Apr 16 04:59:52 2015 UTC,"In C++ I ended up creating operators (<<< and >>>) for rotation   You can only overload operators, not create new ones (well, there are syntatic tricks for using other operators to create infix operators, then use a #define to hide the regular operators, but that's more of a trick, not a built-in thing)."
C_Programming,32pp3g,Steve_the_Scout,3,Thu Apr 16 16:17:03 2015 UTC,"I don't remember the details of what I implemented; it was close to 20 years ago. Either the compiler I was using let me do it (standards be damned, lots of compilers had loose conformance at the time), or I did some pre-processor mess or some such. It's even possible that I set out to create operators, realized I couldn't, and ended up defining inline functions rol and ror, and remembered it wrong.  That said, it has always bothered me that C++ doesn't have it. Comes up in an awful lot of crypto and hashing stuff."
C_Programming,32pp3g,r_notfound,1 point,Thu Apr 16 21:25:24 2015 UTC,How often do you need to rotate?  I've been an embedded software developer for 10+ years and I've never run into a situation where I need to rotate.
C_Programming,32pp3g,stillalone,1 point,Thu Apr 16 17:48:34 2015 UTC,"The only use for it I can think of was for a power-on walking bit memory test. It was written in assembly and verified that the RAM chips were still good (safety critical device, avionics).  Other than that, never that I can think of."
C_Programming,32pp3g,jahmez,1 point,Thu Apr 16 20:26:50 2015 UTC,"wouldn't you use a normal left shift for a walking ones test?  why the rotate?  For a walking zeros you would just invert the walking ones value,  I don't think the extra cpu instruction would hamper memory access enough to be a bother."
C_Programming,32pp3g,stillalone,1 point,Thu Apr 16 20:53:51 2015 UTC,"I honestly can't remember exactly what the algorithm was. It did a couple passes with a couple different memory tests, and I may even be misremembering it being a walking bit test, or even a rotate instruction.  Its probably the only time I can even POSSIBLY remember a rotate being used.  The memory test in question was checking every byte of ~64 megs of ram, and multiple patterns on each byte, so speed was important."
C_Programming,32pp3g,jahmez,13,Thu Apr 16 20:59:22 2015 UTC,Because the PDP-11 doesn't support rotations. You can use the a << x | a >> 32 - x idiom though which is recognized by all major compilers.
C_Programming,32pp3g,FUZxxl,2,Wed Apr 15 21:13:33 2015 UTC,this
C_Programming,32pp3g,GlassGhost,3,Wed Apr 15 22:07:50 2015 UTC,N3990 was a proposal for an operator in C++ for rotations.
C_Programming,32pp3g,wgunther,1 point,Wed Apr 15 19:27:06 2015 UTC,Link to N3990 paper and resolution
C_Programming,32pp3g,OldWolf2,-1,Wed Apr 15 20:00:03 2015 UTC,"Rotation is simply not really a useful arithmetical operation. It is a special case.  It would also be convenient to have other things, like have a small network daemon that spawns child processes in one command or have a command that does something with every file in a directory tree (recursively). I use it very often, but it is still a special case for many."
C_Programming,32pp3g,qci,1 point,Thu Apr 16 06:05:49 2015 UTC,Rotation is simply not really a useful arithmetical operation. It is a special case.   If it's not useful why does every processor I've used support it in hardware. Why does every compiler I've used support it through intrinsics? I've used rotates enough in my professional career that it has bothered me enough to ask a question that after several different C standards not one has standardized bit rotations.
C_Programming,32pp3g,qci,1 point,Thu Apr 16 19:59:22 2015 UTC,"You still haven't told me what you use rotations for. I remember to have implemented them exactly once, for my gameboy emulator which has several variants of rotations in 8 bit width.  What rotation widths do you miss? Nibbles? 8? 16? 32? 128? 53 bits width? With carry? Without? With filling 0? Or 1? Or leftmost bit? Rightmost bit? 1 or all step sizes? Overflow with or without trap?"
C_Programming,32rzrf,notconstructive,1 point,Thu Apr 16 06:10:51 2015 UTC,Does the web server support CGI? That's the easiest way.
C_Programming,32rzrf,raevnos,1 point,Thu Apr 16 09:48:10 2015 UTC,What's the purpose of application A? Are you just trying to add some functionality to Klone?
C_Programming,32rzrf,_COMPLEX_H,1 point,Thu Apr 16 19:57:41 2015 UTC,"I have never used Klone before, but I briefly looked through their website and source.  It looks like in order to install it Klone encourages you to follow their directions from their tutorial under the bootstrap section.  In this section you could either run wget (or curl or whatever you like) which will download/compile it for you or download the pre-compiled binaries.  I'm not exactly sure what you mean when you say you want to embed it in your application.  It looks like they provide a library that you can use within your application.  I would start by trying get Klone installed on your computer and see if you can get their pre-made application to work.  Once you get it working then see if you can follow their tutorial.  If the tutorial doesn't cover what you want I would get started looking at their examples from their wiki.  My guess is that what you really want is to use their library to interact with the webserver so if you want to fast track just read through their library reference.  I hope this helps."
C_Programming,32qp4c,Captain_Charisma,1 point,Wed Apr 15 23:06:59 2015 UTC,Why do you need to do this? Can't you do something else?
C_Programming,32qp4c,FUZxxl,1 point,Fri Apr 17 09:21:41 2015 UTC,"Make a second loop, and use it right after the first:  for ( index = 22; index <= 24; index++ )"
C_Programming,32qp4c,boredcircuits,1 point,Wed Apr 15 23:15:10 2015 UTC,"I tried that, but instead of giving the results for months 22, 23, 24, it prints 22, 23, 24 with the results from months 4, 5, and 6"
C_Programming,32qp4c,zifyoip,6,Wed Apr 15 23:31:46 2015 UTC,"Well, you didn't show any code, so I don't actually know what you are doing, but presumably you still need to calculate the values for all 24 months. You can't just calculate the values for the first three months and then jump to the last three months without doing the intermediate calculations.  So make a loop that does the calculations for all 24 months, but use an if statement to only print values for the first three and last three months."
C_Programming,32qp4c,zifyoip,1 point,Wed Apr 15 23:43:44 2015 UTC,"Ah yeah that would probably help, sorry.  include ""stdafx.h""  include <stdio.h>  include <math.h>  int main(void) {     int years, months, index;     double principle, rate, interest, dolPrin, princBalance, payment;  printf(""What is your Principle Balance? ""); scanf_s(""%lf"", &princBalance); printf(""For how many years will you be making payments? ""); scanf_s(""%d"", &years); printf(""What is the rate? ""); scanf_s(""%lf"", &rate);  months = years * 12; payment = 6648.10;  printf(""\nPrinciple = %.2lf     Rate = %.0lf%%\n"", princBalance, rate); printf(""Pay/Mo =     6,648.10     Years = %d\n\n"", years); printf(""Month   Principle    interest  $ to princ  Prin Balance\n""); for (index = 1; index <= 3; index++) {     principle = princBalance;     interest = (rate / 100) / 12 * principle;     dolPrin = payment - interest;     princBalance = principle - dolPrin;      printf("" %2d     $%.2lf   $%.2lf   $%.2lf    $%.2lf\n"", index, principle, interest, dolPrin, princBalance); }  for (index = 22; index <= 24; index++) {     principle = princBalance;     interest = (rate / 100) / 12 * principle;     dolPrin = payment - interest;     princBalance = principle - dolPrin;      printf("" %2d     $%.2lf   $%.2lf   $%.2lf    $%.2lf\n"", index, principle, interest, dolPrin, princBalance); }   return 0;   }"
C_Programming,32qp4c,no_coupon,6,Wed Apr 15 23:53:16 2015 UTC,"Yes, just as I thought. You have to do the calculations for all 24 months, of course—you can't just skip the calculations for the months in the middle.  Think about what you would do if you were asked to do this problem by hand, on paper, and write the numbers for the first three months and the last three months on a form. You would do the calculations, month by month, and for the first three months you would write the numbers on the form, and then you would continue doing the calculations, month by month, without writing numbers on the form, until you got to the last three months, when you would write numbers on the form again. Your program needs to do the same thing. If you were doing this by hand, on paper, you couldn't magically skip ahead to the last three months without doing the calculations for the intermediate months, and neither can your program."
C_Programming,32qp4c,dragon_wrangler,1 point,Wed Apr 15 23:58:44 2015 UTC,"Okay gotya, that would make sense. Thank you!"
C_Programming,32qp4c,no_coupon,0,Thu Apr 16 00:03:37 2015 UTC,"use condition inside loop if(index < 3 && index <22) { printf("" %2d     $%.2lf   $%.2lf   $%.2lf    $%.2lf""......""); }"
C_Programming,32qp4c,f5f5f5f5f5f5f5f5f5f5,1 point,Thu Apr 16 00:06:32 2015 UTC,That should probably be  if( index < 3 || index > 20 )
C_Programming,32o79u,reinka,5,Wed Apr 15 11:00:47 2015 UTC,"|| and && are short-circuit logical operators. || will evaluate the right hand expression only if the left hand side is false. && will evaluate the right hand expression only if the left side is true.  Since i is 1, ++i is necessarily true and so ++j && ++k is never evaluated."
C_Programming,32o79u,Meefims,3,Wed Apr 15 11:14:11 2015 UTC,"Try drawing a little tree of how your expression is parsed, like this example: http://i.stack.imgur.com/R8Bfx.png   See for yourself which nodes are accessed."
C_Programming,32o79u,Erno3000,1 point,Wed Apr 15 11:47:38 2015 UTC,"so the ""computer really uses"" the parenthesis like this:    ++i || ( ++j && ++k)      now i see where i was wrong. i was too much focused on the left associativity and thus assumed it would run like this    (++i || ++j) && ++k   thank you"
C_Programming,32o79u,Jon-Targaryen,6,Wed Apr 15 11:58:46 2015 UTC,Yep.  It's because && has higher precedence than ||.
C_Programming,32o79u,LittleHelperRobot,2,Wed Apr 15 14:57:44 2015 UTC,"Non-mobile: && has higher precedence than ||  That's why I'm here, I don't judge you. PM /u/xl0 if I'm causing any trouble. WUT?"
C_Programming,32o79u,Meefims,1 point,Wed Apr 15 14:58:09 2015 UTC,"No, based on the output ++i || ++j ran first."
C_Programming,32o79u,Jon-Targaryen,5,Wed Apr 15 12:02:32 2015 UTC,"No, the op has it correct now.  Parenthesis don't imply order of execution, just the way in which operands are bound to operators."
C_Programming,32o79u,OldWolf2,5,Wed Apr 15 14:55:48 2015 UTC,"&& has higher precedence than ||.  So the expression is ++i || (++j && ++k).  Then since ++i is true, the || short-circuits and does not evaluate the rest."
C_Programming,32o9op,sumdeadguyy,4,Wed Apr 15 11:32:01 2015 UTC,"The final for loop sets symbol=1 when you reach the null terminator of the string, as it's neither alphanumeric nor a digit. This is an effect of how you set up your char counting loop, as it will add 1 to the count when it reaches the null terminator (loop is not terminated until next time it's run).  It is also possible to do all your checks in a single loop (without counting characters) if you want to. Hint: set all variables that indicate whether a given type of character has been found to 0 before the loop."
C_Programming,32o9op,skjett,1 point,Wed Apr 15 12:02:58 2015 UTC,"Ahh. Thank you, now I understand. Guess ill have 2 projects then  Edit: I think I figured it out. Is it : While(password[i] != 0 // than put everything in this one loop?"
C_Programming,32o9op,skjett,2,Wed Apr 15 12:08:59 2015 UTC,"Yes, although the null character should be written '\0'. However, since the null character will evaluate to 0, you can skip the comparison and just write  while (password[i]) {     # do stuff     i++; }   or with a for-loop:  for(int i = 0; password[i]; i++) {     # do stuff }   Beware of the buffer overflow issue dMenche wrote about in his post, though."
C_Programming,32o9op,dMenche,4,Thu Apr 16 18:30:53 2015 UTC,"If someone happens to enter more than 100 characters, you'll get a fun buffer overflow. fgets() allows you to set a maximum length after which the input will be truncated, preventing this.  fgets(password, 100, stdin); will read from standard input either 99 characters or up to the first newline, whichever comes first, then add a null terminator.  You should also add a message warning that input will be truncated to 99 characters."
C_Programming,32o9op,Chooquaeno,2,Wed Apr 15 14:46:57 2015 UTC,"Arrrrrggghh! This is not your problem, but why on Earth are you doing:  if (condition)     other_condition = 1; else     other_condition = 0;   and  condition ? func() : 0;   instead of the other way around?!"
C_Programming,32o9op,Serranya,2,Wed Apr 15 13:14:02 2015 UTC,"Well I am a huge noob, and at the first one you said I was like facepalm, but can you explain the second mistake I made? I can't see what's wrong with it"
C_Programming,32o9op,Chooquaeno,2,Wed Apr 15 18:00:17 2015 UTC,The more idomatic way for the second one is to write:  if (condition)    func();   you should use  expr1 ? expr2 : expr3;   only if you want to do something with the result of this expression.
C_Programming,32o9op,neophytez,2,Wed Apr 15 18:13:40 2015 UTC,"This would be the more sensible way:  if (condition)     func();   and  other_condition = condition ? 1 : 0;   Note that the if statement conditionally executes a block of statements, whereas the ternary operator (?:) conditionally evaluates and expression and returns a value.  (Note that the second statement is not the same as writing:  other_condition = condition;   )."
C_Programming,32ok3j,NeuromancerNoob,4,Wed Apr 15 13:24:27 2015 UTC,"BubbleSort uses an array named a, but I don't see that array declared anywhere.  From the assignment, it looks like you're supposed to sort primarily on age and secondarily on name, but your swap and compare functions look just set up for age."
C_Programming,32ok3j,LeinadSpoon,1 point,Wed Apr 15 14:00:34 2015 UTC,you are using n rather than SIZE in your bubblesort.
C_Programming,32ok3j,duewyle,1 point,Thu Apr 23 23:15:55 2015 UTC,Yea thanks guys. I was sleep deprived when i posted. Woke up and fixed alot of the dumb mistake.
C_Programming,32o0y9,neophytez,3,Wed Apr 15 09:24:31 2015 UTC,"Use selection sort: https://en.wikipedia.org/wiki/Selection_sort      int iMin;      for (j = 0; j < difWords-1; j++) {         iMin = j;         for ( i = j+1; i < difWords-1; i++) {             if (freq[i][0] > freq[iMin][0]) {                 iMin = i;             } else if(freq[i][0] == freq[iMin][0]) {                 if(strcmp(tab[freq[i][1]], tab[freq[iMin][1]]) == -1) {                     iMin = i;                 }             }         }          if(iMin != j) {             int t0 = freq[j][0];             int t1 = freq[j][1];             freq[j][0] = freq[iMin][0];             freq[j][1] = freq[iMin][1];             freq[iMin][0] = t0;             freq[iMin][1] = t1;         }     }   Also you have buffer overflows on lines 76 and 112: length + 1 should be length"
C_Programming,32o0y9,bobdudley,1 point,Wed Apr 15 13:31:52 2015 UTC,You are the best! :D Thanks.  PS: why doesn't it work with this input?  3 To je primer z zelo dolgo besedo: zelodolgabesedabit zelodolgabesedabit zelodolgabesedabit zelodolgabesedabit   Output is:  besedo 1 dolgo 1 je 1   instead  zelodolgabesedabit 4 besedo 1 dolgo 1
C_Programming,32o0y9,bobdudley,1 point,Wed Apr 15 14:16:20 2015 UTC,For some unknown reason zelodolgabesedabit is at the end...  besedo 1 dolgo 1 je 1 primer 1 to 1 z 1 zelo 1 zelodolgabesedabit 4
C_Programming,32mnf3,Thamous,3,Wed Apr 15 00:33:35 2015 UTC,"I'm in a bit of a hurry, so I'll just point you to a similar question. Also you don't need to fead & write structure elements individually provided you take care of the padding (and your structures don't seem to have any) so you can just read and write the entire structure"
C_Programming,32mnf3,studioidefix,1 point,Wed Apr 15 01:15:30 2015 UTC,"Define ""cannot access"".  Describe what type of data pixelArray is, then describe what type of data is being read in from the file."
C_Programming,32mnf3,Chooquaeno,1 point,Wed Apr 15 03:43:20 2015 UTC,You are overwriting all the pointers to individual lines in pixelArray by that fread later down. You should read the lines individually. And you probably have to read them bottom up as well.
C_Programming,32im4k,yall_,29,Tue Apr 14 02:14:07 2015 UTC,"Check out the SDL library. It's used in many professional projects, and easy to get started with.  http://lazyfoo.net/SDL_tutorials/  https://wiki.libsdl.org/Tutorials"
C_Programming,32im4k,Choo5ool,8,Tue Apr 14 02:48:00 2015 UTC,"Highly recommend this answer. If you're interested at all in game development, SDL is the best place to start on non-windows platforms. It also provides an easy way to get started with OpenGL (for once you have some experience. OpenGL isn't that beginner friendly), but gives you a higher level 2d api which is probably where you should start."
C_Programming,32im4k,zuurr,4,Tue Apr 14 05:07:17 2015 UTC,IMO its the best place to start on Windows as well.
C_Programming,32im4k,dreucifer,9,Tue Apr 14 17:14:35 2015 UTC,"SDL is a great starting point, but use SDL2!  There are some additional libraries that go with it, like SDL_image and (iirc) SDL_mixer.  From these two it's a much shorter step to openGL, which is not easy, but it is powerful. That said, save yourself the trouble, and don't learn any openGL crap that isn't for versions 3.2 or above. 2.1 is a waste of everyone's time."
C_Programming,32im4k,sireel,12,Tue Apr 14 12:12:53 2015 UTC,"Useless advice: Don't start with ncurses if you don't want to end up like me.  Useful advice: GTK isn't bad. If you want ""graphics"" more than you want ""GUI"", there aren't a lot of great graphics libraries that I'm familiar with without going to full-blown OpenGL, which is not beginner-friendly, but you could try SDL, which will do what you want. A couple of (simple) higher-level graphics and game libraries are built on top of SDL, so any knowledge you gain with it should transfer pretty well."
C_Programming,32im4k,Halcyone1024,5,Tue Apr 14 02:42:55 2015 UTC,How do you feel about Qt?
C_Programming,32im4k,deviaan,8,Tue Apr 14 02:47:26 2015 UTC,"I liked using Qt last time I had to, but it inherits a lot of awful properties from C++, and its dependency on code generation isn't pretty. Also, I use MOC (Music On Console), so I'm slightly sad at Qt for petty namespace reasons. The documentation is good, though."
C_Programming,32im4k,Halcyone1024,2,Tue Apr 14 02:55:32 2015 UTC,Thanks :)
C_Programming,32im4k,deviaan,6,Tue Apr 14 03:07:24 2015 UTC,"If you want to ignore my useless advice, then you should take a look at Unicode blocks U+2500 through U+257F for line-drawing characters, U+2660 through U+2267 for suits, and U+1F0A0 through U+1F0DF for single-grapheme card fronts and backs."
C_Programming,32im4k,Halcyone1024,1 point,Tue Apr 14 02:49:21 2015 UTC,font support is spotty for suits and single-grapheme cards plus they are hard to spot on small font sizes.
C_Programming,32im4k,FUZxxl,5,Tue Apr 14 06:44:46 2015 UTC,"SDL or OpenGL are probably the best places to start. You didn't mention what OS you are on though, if you use Windows and you fancy developing some mental health problems you could try Win32 :P"
C_Programming,32im4k,bithush,3,Tue Apr 14 12:00:00 2015 UTC,Allegro is another alternative to SDL and OpenGL.
C_Programming,32im4k,zzopp,2,Tue Apr 14 13:33:22 2015 UTC,"Opengl is fairly simple to get running for a simple interface that's static like blackjack, have a look at that, SDL can interface with it or you can use something like glew, glfw, glut (freeglut3), etc"
C_Programming,32im4k,Beaverkilla,2,Tue Apr 14 09:29:11 2015 UTC,"You'll probably want to look into SDL2 and maybe OpenGL 3.3+ if you don't mind writing a bit of boilerplate before getting started with actually using it.  SDL2 offers some nice utilities for drawing simple 2D graphics in the form of blitting images onto ""surfaces"" (i.e. some rectangle in screen space), as well as fairly simple input and events, which sounds like exactly what you'd want.  If you want to go more advanced (but also much more powerful), you could use OpenGL 3.3 or above for 3D graphics (e.g. if you want a full on virtual table, cards flipping in 3D space, nice lighting effects, etc.) A lot of OpenGL tutorials I've seen tend to use C++ because it helps visualize the data as objects (which is OpenGL terminology for things like buffers, for example), but it's fairly simple to transfer them over to C, since it's mostly manipulating data and a few convenience functions to add in some default parameters or do a little extra work."
C_Programming,32im4k,Steve_the_Scout,2,Wed Apr 15 00:34:26 2015 UTC,Qt... and more Qt. It's literally blowing up as I type this. Don't bother with anyone that complains how it does this or that. It's an excellent framework. Period.  Everything has pros and cons.  http://www.qt.io/download
C_Programming,32im4k,_patientzero,3,Wed Apr 15 01:36:39 2015 UTC,How do you use Qt from C? I thought it was pretty much C++ only.
C_Programming,32jukc,sacha99,3,Tue Apr 14 11:12:17 2015 UTC,"There's yuck, a command-line parser generator that does what you want, only requirement is a C99 compiler but otherwise it's free of any dependencies."
C_Programming,32jukc,hroptatyr,2,Tue Apr 14 12:41:02 2015 UTC,Read the cat source and learn about getopt().
C_Programming,32jukc,Pedantick,1 point,Tue Apr 14 18:52:01 2015 UTC,"But can I parse files and websites through getopt() ? I haven't found any way to do it without using a ""-"" in front and my teacher won't use one when they test it ..."
C_Programming,32jukc,Pedantick,2,Tue Apr 14 22:51:14 2015 UTC,"getopt() will return a integer index to all arguments in argv it was unable to parse(it reorganizes them to the rear), called 'optind'. you can then run through these arguments yourself with argv[optind], and incrementing optind until it equals argc. See the man page for info."
C_Programming,32jukc,_gh0st_,2,Wed Apr 15 04:44:11 2015 UTC,Why not use int argc and char *argv[]?
C_Programming,32jukc,boredcircuits,1 point,Tue Apr 14 23:54:26 2015 UTC,Yep that's what I'm thinking of doing now. It is just that everywhere I looked on internet people seemed to say that using an automated tool like getopt was better.
C_Programming,32jukc,garion911,1 point,Wed Apr 15 00:37:23 2015 UTC,"Considering how long it's taken to get rid of gets, I don't think that's really true."
C_Programming,32irm7,_jho,4,Tue Apr 14 03:01:12 2015 UTC,"Sweet! I'm looking to write an Unlambda interpreter, once I wrap my head around a couple of things."
C_Programming,32irm7,Alyte,2,Tue Apr 14 05:03:58 2015 UTC,Oh god. What is that.  Haha send me a message and put it on github and I'll contribute if you want! I'm trying to get my feet wet with some open source shenanigans.
C_Programming,32irm7,Alyte,1 point,Tue Apr 14 05:12:36 2015 UTC,"Like Brainfuck, Unlambda is extremely simple - in fact I'm pretty sure Unlambda is even simpler. But, if you have anything to contribute, then sure."
C_Programming,32irm7,spaz_naz,3,Tue Apr 14 13:28:18 2015 UTC,"Line 62 will result in a buffer overflow for filenames greater than 32 characters in length. You might favor something like this:  #define MAX_FILE_NAME_LEN    (32) ... char fileName[MAX_FILE_NAME_LEN + 1] = { 0 }; .... strncpy(fileName, argv[1], MAX_FILE_NAME_LEN);   This way your name array has an extra item for the NUL terminator and you would only ever copy 32 characters at a time."
C_Programming,32irm7,theseoafs,1 point,Tue Apr 14 10:56:48 2015 UTC,You're totally right. That's just me being sloppy and not including error checking.
C_Programming,32irm7,theseoafs,2,Tue Apr 14 11:01:21 2015 UTC,"Not only does the unchecked copy to the fileName buffer result in a buffer overflow, it's totally unnecessary.  Just use argv[1] and pass that as the filename to fopen().   while(!feof(inFile))    This is not how you check for the end of a file.  Your loop should look like this:  while (fgetc(inFile) != EOF) { fileSize++; }    bf = (char *)malloc(sizeof(char) * (fileSize + 1 + 1)); // one for space one for null    sizeof(char) is 1.   inFile = fopen(fileName, ""r"");     You can just seek to the beginning of the file rather than closing and re-opening it.     default:    printf(""ERROR: non-brainfuck character encountered: %d\n"", (int)ch);     Non-brainfuck characters in brainfuck interpreters are usually just ignored (treated as comments).  Also why are you printing it as an integer?  Also there's no reason to keep commented-out code in a Github repository; just get rid of it."
C_Programming,32irm7,benwaffle,2,Tue Apr 14 16:27:14 2015 UTC,"Thanks for the advice.   I like the idea of passing argv[1] straight to fopen. I'll do that soon. I'll look into changing up that while loop. I've heard some people gripe about !feof(fp), but I haven't got around to figuring out why. Do I just seek to the beginning by calling fopen() again? The whole ""non-brainfuck characters"" thing I do was mainly for while I was getting it working, I could make sure that everything was nice and clean and working. Comment support is somewhere on the list of things to add.   Seriously though, thanks for the input! I'll update it soon."
C_Programming,32irm7,chasesan,3,Tue Apr 14 18:39:53 2015 UTC,"I'll look into changing up that while loop. I've heard some people gripe about !feof(fp), but I haven't got around to figuring out why.   http://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong  The accepted answer is correct but long and complicated and not particularly essential to understand.  Instead, just know that you loop through all the characters in a file by testing for EOF explicitly.  It's idiomatic, more performant, and most importantly, correct.   Do I just seek to the beginning by calling fopen() again?   Learn about fseek() at http://man7.org/linux/man-pages/man3/fseek.3.html.   Seriously though, thanks for the input!   You're welcome!"
C_Programming,32irm7,dev_dov_dang,2,Tue Apr 14 18:56:12 2015 UTC,"You should switch to C11, or at least C99"
C_Programming,32irm7,dev_dov_dang,1 point,Tue Apr 14 20:49:07 2015 UTC,Always a good exercise! Good job.
C_Programming,32irm7,boarhog,1 point,Tue Apr 14 18:49:31 2015 UTC,"Very well done! Implementing these programming languages is always a really fun exercise. They are especially awesome because of how simple they are usually, meaning they aren't too insane to implement.  In terms of your code style, you seem to have a lot of comments explaining pretty redundant things. I'm actually pro-comment, but some of your comments are too much.  I'd recommend removing some of the comments that explain really obvious things (""closes the file""). Also notice how you've got huge comments that span the entire line explaining what the next section of code does. Also note that you do everything in main. I'd really recommend extracting out these sections of code into their own functions. This makes the code easier to understand, and means you can use function names instead of huge comments to explain what is happening.  Other than that your code is really nice, and the whole thing is real well done!"
C_Programming,32irm7,istopped,1 point,Wed Apr 15 21:19:21 2015 UTC,"Yeah I guess the way I went about commenting this particular project was just paralleling the code with pseudo-code type comments. It could probably be split up into functions or multiple files, though I feel like it still follows the DRY principle pretty well. But I do agree with your points."
C_Programming,32iwtv,notconstructive,5,Tue Apr 14 03:48:37 2015 UTC,"Some of the best libraries will be the ones you write yourself.    Once you have built a list of useful functions that you tend to keep using again and again, from project-to-project, put them into a library, and simply include that library in new projects.  Other people's libraries have seldom helped me write programs.  That's just me, I guess.  In my early days of learning, I began to realize the time I was loosing in chasing down the perfect library could have been used to simply build it myself.     Exceptions are rare -- like the uuencode library I found long ago, and then later, an excellent JPEG library.    But even with the JPEG library, I wasn't content to use it as is, 'out of the box'.   I was soon re-writing key decoding routines in mixed C and assembly for more speed.  'Course, today, most PCs are powerful enough so that the lag time waiting on an image to paint is more attributed to download speed rather than JPEG decoding speed."
C_Programming,32iwtv,zenkibudo,4,Tue Apr 14 04:14:25 2015 UTC,"On top of /u/zenkibudo 's response, some of the standards are the ones you'll use the most.   Usually:  stdio.h // of course stdlib.h // also of course string.h ctype.h   string.h and ctype.h have all sorts of neat tidbits that can make things a lot cleaner. for example, isspace(). But like /u/zenkibudo said, if you write your own you'll probably have lots of them that you write yourself (and like better) to do these same things."
C_Programming,32iwtv,_jho,3,Tue Apr 14 05:07:45 2015 UTC,The stb libraries are fantastic single-file drop-ins. You might want to check those out.
C_Programming,32iwtv,johncmouser,1 point,Tue Apr 14 08:56:44 2015 UTC,"Ahh, tyvm! I stumbled across these one day and lost the URL. Been looking for them!"
C_Programming,32iwtv,TehJohnny,2,Thu Apr 16 20:41:12 2015 UTC,"Well, the libc is quite nice... Jokes aside, there are many libraries for specific tasks. I can't recommend any in particular but you should have a look at the stuff in Plan 9; lots of useful bits."
C_Programming,32iwtv,FUZxxl,1 point,Tue Apr 14 21:21:04 2015 UTC,pthreads.. I also find myself using Attractive Chaos' khash macros lately.
C_Programming,32iwtv,aninteger,1 point,Tue Apr 14 14:09:17 2015 UTC,ccan code
C_Programming,32iwtv,cunttard,1 point,Thu Apr 16 17:43:29 2015 UTC,SDL2 is a great platform abstraction library.
C_Programming,32iwtv,TehJohnny,0,Thu Apr 16 20:43:28 2015 UTC,"I don't know if this is what you're looking for, but I would familarize myself with Linux/Unix. You don't have to necessarily know Linux/Unix to be a good C programmer, but everyone I've met with a solid understanding of Linux/Unix and how to develop for it has also been very good with C (particularly device driver and kernel developers)."
C_Programming,32iwtv,huboon,-7,Tue Apr 14 05:25:06 2015 UTC,I think OP's username says everything about this thread that needs to be said.
C_Programming,32iwtv,Pedantick,5,Tue Apr 14 05:17:40 2015 UTC,i think you just wanted someone else to point out your user name.
C_Programming,32iwtv,cehmu,0,Tue Apr 14 06:35:04 2015 UTC,"I don't really think about my username anymore, honestly. I really just thought it was a dumb question."
C_Programming,32iwtv,Pedantick,2,Tue Apr 14 16:04:02 2015 UTC,"What about his question is dumb to you?   He wants to know about useful C libraries, what an idiotic thing to ask about."
C_Programming,32iwtv,Wiggledan,0,Tue Apr 14 16:09:06 2015 UTC,"It's not constructive, as I originally said. C is so mature it has multiple redundant libraries. Asking which is better/more valuable is a vague, dumb question, and has gotten vague, dumb answers."
C_Programming,32g1e2,BigAxeHax,16,Mon Apr 13 14:33:48 2015 UTC,%b for binary
C_Programming,32g1e2,psu72,2,Mon Apr 13 15:59:34 2015 UTC,"If at all, something for base n output where n is selectable."
C_Programming,32g1e2,FUZxxl,6,Tue Apr 14 17:12:51 2015 UTC,"Binary output, grouping for long numerical output, and the ability to choose point/comma (or possibly something else) for decimal separation."
C_Programming,32g1e2,acwsupremacy,1 point,Mon Apr 13 16:18:20 2015 UTC,please give some quick examples to clarify what you mean
C_Programming,32g1e2,acwsupremacy,3,Mon Apr 13 18:28:55 2015 UTC,"Binary output for numbers, pointers, etc., as you stated.  Digit grouping, e.g. print a long integer as 10,000,000 or 10.000.000 or 10 000 000 rather than the much less readable 100000000.  Programmer's choice of decimal separator character, the two customary ones being . and ,, though being able to choose any arbitrary symbol for both this and the group separator would be ideal.  Regarding the last point, I believe many implementations change the separators based on Locale, but that is an awful API that no programmer should ever be compelled to use."
C_Programming,32g1e2,OldWolf2,3,Mon Apr 13 18:35:47 2015 UTC,"The separator would have to be determined by the current locale, not by programmer selecting it explicitly"
C_Programming,32g1e2,FUZxxl,1 point,Mon Apr 13 23:23:07 2015 UTC,"POSIX already has this, the specifier is '; for instance, you can use %'d to get integers in decimal with digit grouping. This functionality is of course locale-dependent."
C_Programming,32g1e2,acwsupremacy,2,Tue Apr 14 20:10:49 2015 UTC,Lots of implementations have lots of different things; the question was what do you wish were standard in all libraries.
C_Programming,32g1e2,FUZxxl,1 point,Wed Apr 15 00:06:23 2015 UTC,"Well, POSIX is sn industry standard. Too bad Microsoft does not give a shit about POSIX"
C_Programming,32g1e2,boredcircuits,5,Wed Apr 15 07:25:42 2015 UTC,"Related: scanf needs a way to specify field width via an argument.  Right now there's two options:  char str[MAX+1];  // Have to do the +1 here scanf(""%"" MAX ""s"", str);   This only works if the width is known at compile-time, and you have to do the +1 in a less-intuitive place.  Or you can build the format string:  char str[MAX]; char fmt[32]; snprintf(fmt, sizeof(fmt), ""%%%ds"", MAX-1); scanf(fmt, str);   Ugh.  Ugly and inefficient.  And then you start questioning the safety of your format string: did I reserve enough room?  What if that overflows?  Is there a non-obvious way for an attacker to take advantage of this?  Did I put enough percent symbols in there?  I'd love to write:  char str[MAX]; scanf(""%*s"", MAX-1, str);   But * has a different meaning to scanf..."
C_Programming,32g1e2,stillalone,1 point,Mon Apr 13 16:48:10 2015 UTC,How often do you need this?  So far I've been doing alright with fgets.
C_Programming,32g1e2,boredcircuits,5,Mon Apr 13 17:35:57 2015 UTC,"I'll admit, not too often.  But it's such a simple feature, and really a pain those times you do need it.  Besides, fgets works on files ... what if you're parsing strings already in memory?  That's much more common, for me at least.  And remember that it applies to more than just strings, too (that's just the most obvious and common way to use it)."
C_Programming,32g1e2,FUZxxl,1 point,Mon Apr 13 17:58:29 2015 UTC,"You can use POSIX' %as which allocates a buffer for you. If you use scanf with %s, you probably want to use fgets instead though."
C_Programming,32g1e2,OldWolf2,1 point,Tue Apr 14 07:24:26 2015 UTC,scanf is crap anyway
C_Programming,32g1e2,boredcircuits,1 point,Mon Apr 13 23:23:49 2015 UTC,"scanf is crap because people use it for user interaction, and it's horribly suited for that job.  But when you want to parse formatted data (user input is not formatted!), it's a very useful tool."
C_Programming,32g1e2,OldWolf2,2,Mon Apr 13 23:42:44 2015 UTC,"sscanf is fine, if that's what you mean :)"
C_Programming,32g1e2,Criffer,9,Mon Apr 13 23:48:45 2015 UTC,"Extensible format specifiers.  printf(""%{binary}\n"", x);   makes a callback to  format_text_binary(char *p, size_t space, ...);"
C_Programming,32g1e2,Spire,6,Mon Apr 13 20:33:22 2015 UTC,"Interesting, although because function names cannot be resolved at runtime, you'd have to provide a mechanism to register the callback function for each custom format specifier."
C_Programming,32g1e2,Criffer,1 point,Mon Apr 13 23:29:41 2015 UTC,Yes they can. Look at dlsym(3)
C_Programming,32g1e2,FUZxxl,3,Tue Apr 14 10:21:00 2015 UTC,"dlsym is not part of ISO 9899:2011, it's only part of POSIX. The other thing is that the API is not going to work the way you imagine it to work because there aren't namespaces with symbols. This is going to be a nightmare with respect to shared libraries."
C_Programming,32g1e2,FUZxxl,1 point,Tue Apr 14 17:14:54 2015 UTC,A similar thing existed for Solaris in the 1980s. They used that mechanism to implement strftime. It was horribly complicated and slow so they got rid of it.
C_Programming,32g1e2,TraylaParks,3,Tue Apr 14 07:29:19 2015 UTC,Add commas
C_Programming,32g1e2,OldWolf2,2,Mon Apr 13 15:12:48 2015 UTC,"Would be nice if MS got around to supporting %zu, 16 years after it was standardized"
C_Programming,32g1e2,FUZxxl,1 point,Mon Apr 13 23:21:57 2015 UTC,Dafuq? They don't support %zu?!
C_Programming,32g1e2,thrakkerzog,2,Tue Apr 14 07:26:00 2015 UTC,ipv4 and ipv6 formatting would be neat but will never happen.
C_Programming,32g1e2,FUZxxl,1 point,Mon Apr 13 20:15:52 2015 UTC,%r for recursive would be cool. I have a hunch that it's going to be in POSIX soon.
C_Programming,32g1e2,FUZxxl,1 point,Mon Apr 13 18:49:01 2015 UTC,"%r is currently reserved in ""Embedded C"" for fixed-point arguments.  What do you mean by recursive?  Do you mean repeat a character?"
C_Programming,32g1e2,aninteger,1 point,Tue Apr 14 00:14:33 2015 UTC,"%r is an old extension discussed in the days when vprintf was introduced. The problem with printf is that it does not easily allow you to write custom printf-like functions because inside such a function you only have a va_args instead of a set of arguments. vprintf was introduced as a band-aid to fix these problems but it's clunky, does not play well with localization and doesn't allow you to nest custom printf-like functions unless you make a vprintf-like variant for each of them.  The specifier %r corresponds to two arguments: one of type const char* and one of type va_list. These two arguments are interpreted as if they were a call to printf on their own, so you can easily write custom printf-like functions like this:  extern _Noreturn void err(int eval, fmt, ...) {     va_list args;      va_start(args, fmt);     if (fmt == NULL)         printf(""%s: %s\n"", getprogname(), strerror(errno));     else         printf(""%s: %r: %s\n"", getprogname(), fmt, args, strerror(errno));     va_end(args);      exit(eval); }   It's easy to see that this mechanism is much simpler than vprintf and friends. The reason why we don't have it already is that the interaction between printf and wprintf via means of %r (there would actually be both %r for char-based recursion and %R for wchar_t based recursion) is tricky to implement. The proposal itself is very old, it dates back to the 80's."
C_Programming,32g1e2,FUZxxl,1 point,Tue Apr 14 06:02:44 2015 UTC,64bit numbers.. the specifier today is different on Linux and Windows. It would remove one ./configure check.
C_Programming,32g1e2,aninteger,2,Tue Apr 14 02:31:22 2015 UTC,"What does “64bit numbers” mean for you? C99 specifies %jd for an intmax_t which will be at least 64 bits if the compiler supports a 64 bit type. C99 also specifies the macro PRI64 for an int64_t (in inttypes.h), so what are you looking for?"
C_Programming,32g1e2,chasesan,1 point,Tue Apr 14 07:27:53 2015 UTC,"Wow, I did not know about those. I've been using %ld on platforms where sizeof long == 8, %I64d on Windows, and %lld else where."
C_Programming,32g1e2,FUZxxl,-1,Tue Apr 14 13:46:26 2015 UTC,"Is it too much to ask for all of it. But if I had to choose %f %s %d %x and the alignment/formatting stuff. So %02x, %5.2f, % 4s and so on."
C_Programming,32fb9e,tmtwd,27,Mon Apr 13 09:32:48 2015 UTC,"""h\n"" is a string literal, and writes to it aren't allowed. A compiler is free to put it in write-protected memory where any attempts to change the data leads to a segfault."
C_Programming,32fb9e,Aransentin,10,Mon Apr 13 09:36:44 2015 UTC,"The compiler can warn you about those cases: GCC uses the -Wwrite-strings flag. It is actually enabled by default for C++, but not for C.  $ gcc -Wwrite-strings write-string.c write-string.c:3:13: warning: initialization discards ‘const’ qualifier from pointer target type  char *red = ""h\n"";              ^  $ g++ write-string.c write-string.c:3:13: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]  char *red = ""h\n"";              ^"
C_Programming,32fb9e,danielkza,1 point,Mon Apr 13 10:40:43 2015 UTC,thanks
C_Programming,32fb9e,chasesan,7,Tue Apr 14 10:19:48 2015 UTC,"I laughed at this, it's almost like a clever programmer joke. Obviously you can't (shouldn't) change the value of a string literal.  Basically, change char *red to char red[] so that it is an array rather than a pointer. No more segfault."
C_Programming,32fb9e,chalk46,1 point,Mon Apr 13 14:54:20 2015 UTC,your welcome :)
C_Programming,32dly6,johncmouser,2,Sun Apr 12 22:30:42 2015 UTC,"In addition to this, tcc can run as an interpreter for .c files with a hashbang, so that acts as a proper script, rather than needing the compilation step."
C_Programming,32dly6,lishyguy,1 point,Mon Apr 13 00:27:36 2015 UTC,"True, but this also gives the advantage that any compiler can be used. The script uses whatever $CC is set to, whether it's Clang, GCC, or even 8cc — and of course the optimizations that come with them."
C_Programming,32dly6,OldWolf2,2,Mon Apr 13 01:10:25 2015 UTC,"This actually makes your 'script' invalid C though, so you can't eat your cake and have it."
C_Programming,32dly6,noname-_-,1 point,Mon Apr 13 01:54:05 2015 UTC,"Valid C99, no?"
C_Programming,32dly6,OldWolf2,1 point,Mon Apr 13 08:22:21 2015 UTC,#! isn't valid in a C program
C_Programming,32dly6,noname-_-,1 point,Mon Apr 13 08:25:58 2015 UTC,"Yeah, I guess it also introduces a whole slew of compatibility issues too, trying to remove the #! so it compiles correctly."
C_Programming,32dly6,GlassGhost,0,Tue Apr 14 06:53:59 2015 UTC,"I'm guessing you didn't actually click the link then, because it starts with //.  Valid C, but technically, it isn't a valid shell script. It works because of legacy behavior. If there's no hashbang and there's no binary, an executed file will be interpreted by the shell.  edit: I'm sorry, you're right. It's me who didn't click the link. I thought he was linking the top comment in that thread. You're right, it's not valid C."
C_Programming,32bpnl,funky_vodka,4,Sun Apr 12 11:53:17 2015 UTC,"Generally I add the headers and library file to the linker and compiler path (using GCC it is is the -L and -I flags).  That said some libraries, such as Lua are easy to build, so I will just put the source in my project generally."
C_Programming,32bpnl,MrGeekAlive,3,Sun Apr 12 12:05:53 2015 UTC,"As a general rule of thumb, locations like /usr/include should be considered off-limits.  They are owned by and managed by the package manager, not you.  Install your stuff elsewhere.  Most libraries let you configure an install prefix, which is /usr/local by default, which means headers go in /usr/local/include and libraries in /usr/local/lib.  These locations are generally part of the list of system search paths, so if you use that default you don't have to do anything extra.  But let's suppose you don't have root privileges to write there.  Let's say you're building libfoo and you want to install it somewhere under your home directory:  $ wget http://libfoo.example.com/libfoo-1.5.tar.gz $ tar xf libfoo-1.5.tar.gz && cd libfoo-1.5 $ ./configure --prefix=$HOME/mystuff $ make -j4 && make check && make install   Okay, the library is installed.  It's also a good idea to add $HOME/mystuff/lib to your LD_LIBRARY_PATH environment variable so that the dynamic linker can find .so files there.  $ export LD_LIBRARY_PATH=$HOME/mystuff/lib                     # if it was empty before $ export LD_LIBRARY_PATH=$HOME/mystuff/lib:$LD_LIBRARY_PATH    # otherwise   (In reality, you'd add these lines to your shell's RC startup file, otherwise you'd have to type them every time you start a new shell.)  Now let's build bar, a program which depends on libfoo:  $ wget http://bar.example.com/bar-4.2.tar.gz $ tar xf bar-4.2.tar.gz && cd bar-4.2 $ ./configure --prefix=$HOME/mystuff CPPFLAGS=-I$HOME/mystuff/include LDFLAGS=-L$HOME/mystuff/lib $ make -j4 && make check   This build bar.  bar can be installed as make install if you want, or you can run it uninstalled from the build directory.  Setting -I in CPPFLAGS tells the C preprocessor where to find the headers, and setting -L in LDFLAGS tells the linker where to find the libraries.  (Note that this is the link editor, not the dynamic linker; these are two different things that need to be configured differently.)  You can throw in some --disable-shared if you don't want shared libraries, and generally there are a ton of standard autoconf options, e.g. if you want to customize the CFLAGS you might want CFLAGS=""-g -O2 -march=native"" or whatever.  All of the above assumes autotools packages, which hopefully is the case.  Other build systems work differently, but the ideas are the same."
C_Programming,32bpnl,Rhomboid,1 point,Sun Apr 12 17:59:00 2015 UTC,that
C_Programming,32bpnl,that-bot,1 point,Sun Apr 12 18:01:33 2015 UTC,I wrote a script to help with the $HOME/mystuff approach and published it as a gist: https://gist.github.com/jtacoma/f3860106ad4b810afda9  pushenv ~/mystuff  I install a bunch of hefty or difficult-to-compile libraries to ~/local/[library name] and otherwise put project-specific dependencies in project-specific directories like ~/proj/myproject
C_Programming,32bpnl,jtacoma,1 point,Tue Apr 14 21:31:13 2015 UTC,"Here's a succinct example. Say you are building a game that requires libncurses.  Go download the library with your distro's package manager:  sudo pacman -S ncurses   Then include the library's header file into your .c files:  #include <ncurses.h> /* ... */   Then compile it, linking in the library when you do so.  $ gcc tetris.c -lncurses $ ./a.out   EDIT: Sorry, I didn't see the emphasis on custom. If the library isn't offered by your package manager, then just go with what /u/Rhomboid wrote."
C_Programming,32bo69,plethoraB,2,Sun Apr 12 11:27:54 2015 UTC,Hahaha nice one.
C_Programming,32bo69,ngvixt3hm,1 point,Sun Apr 12 17:54:11 2015 UTC,How much is one meter of code?
C_Programming,32bo69,dbj1303,3,Sun Apr 12 14:06:49 2015 UTC,"assuming we're talking about metric C and a standard font size ~1,000 lines.  Of course things get weird if you're trying to use US Standard units."
C_Programming,32bo69,jbshagendaz,1 point,Sun Apr 12 16:17:56 2015 UTC,I like to use imperial units: foot/fortnight.
C_Programming,3297e3,yall_,41,Sat Apr 11 18:47:38 2015 UTC,"How is it determined that the file of the script is 868 bytes?   You tell us — how did you come to that conclusion?  Are you talking about the size of the file?  A text file is just a series of characters.  And by the way, it's not customary to refer to a .c source file as a script, because C is not a scripting language, at least traditionally.  The size of the executable is larger than the size of the source for a number of reasons:   The program that you wrote has been turned into a series of machine instructions.  The size of a machine instruction varies with the different types of hardware.  On x86 a single instruction can be between 1 and 16 bytes, although most instructions are on the smaller end, averaging in the range of 3 - 5.  A given expression or statement in C might take many instructions to implement. The compiler inserts do-nothing instructions (nops) to ensure that things like function entry points and branch targets have a certain alignment.  This wastes a small amount of space but increases performance. The executable has a small amount of startup/initialization code from the C runtime library.  Even if you compile a program that does nothing, you'll see that code statically linked in.  You can see these as objects with names like crt*.o in your full link command if you use -v. The executable may have a symbol table and/or debug information if it has not been stripped, depending on the flags you used when compiling. The various sections and segments of the executable have certain alignment requirements, which wastes a small amount of space, which is negligible except for very small programs. The executable has a series of headers that describe the contents, which also take up a small amount of space. Assuming that your program is dynamically linked against libc, there will be a small amount of data needed to implement dynamic linking, such as a list of names of dynamic symbols and some kind of means of indirection (e.g. the GOT and PLT on ELF systems.)   You can see how all of the above come into play by using a tool like objdump or readelf to look inside the contents of the binary."
C_Programming,3297e3,Rhomboid,0,Sat Apr 11 19:06:05 2015 UTC,"All this is not the reason why the program is 9 kB in size; you can use the size command to see how much space is actually used inside the binary. The real reason is that code, data. and rodata are padded to multiples of 4 kB so the binary can be mapped into memory; the last section doesn't have padding at the end."
C_Programming,3297e3,FUZxxl,20,Sat Apr 11 20:21:19 2015 UTC,"...which is exactly what I said in my fifth bullet point, so ""all this is not the reason"" can only mean you didn't bother to read what I wrote."
C_Programming,3297e3,Rhomboid,2,Sat Apr 11 20:38:41 2015 UTC,"Ah, okay, I must have overread that part. Still, this is the real reason why the binary is 9k in size. The ELF headers aren't very large and neither is the symbol table."
C_Programming,3297e3,FUZxxl,3,Sat Apr 11 20:44:27 2015 UTC,"Dunno about ELF, but Portable Executable has two alignments for sections: FileAlignement and SectionAligment (virtual memory). The default file alignment is 512 bytes (minimum).  EDIT:  Some numbers with MinGW-W64  The code:  #include <stdio.h>  int _tmain(void) {     printf(""Hello World\n""); }     Compiler options Output size (Byte)    None 46,765   -Os 46,845   -s 16,384   -s -nostdlib -lmsvcrt 3,584   (previous) + -fno-asynchronous-unwind-tables 2,048 (3 sections + header)   (previous) + -Wl,--file-alignment=1 ** 768    ** Doesn't produce a valid executable."
C_Programming,3297e3,romcgb,7,Sat Apr 11 21:56:04 2015 UTC,"_tmain :(  1995 called, they want their entry point back"
C_Programming,3297e3,OldWolf2,2,Sun Apr 12 00:01:45 2015 UTC,What does -s do? What is _tmain?
C_Programming,3297e3,FUZxxl,2,Sat Apr 11 22:52:53 2015 UTC,"_tmain is specific to Windows, it's needed with -nostdlib  -s removes all symbol table and relocation information from the executable. It's like strip but done at link-time."
C_Programming,3297e3,romcgb,-1,Sat Apr 11 23:37:20 2015 UTC,"Technically correct, the best kind."
C_Programming,3297e3,littlelowcougar,1 point,Sat Apr 11 21:13:33 2015 UTC,You can use objdump to examine the compiled program. I'm sure the .text section is quite small.
C_Programming,3297e3,Chooquaeno,-1,Sun Apr 12 01:25:11 2015 UTC,"In short your program isn't just what you wrote, it includes everything your program uses such as any #include files and any libraries used."
C_Programming,3297e3,bithush,5,Sat Apr 11 19:38:36 2015 UTC,"Eh... no. Included headers are not part of the binary; try it out! You can include as many headers as you want, the binary size is not going to change.  Libraries aren't included either as most operating systems use a mechanism called shared libraries today, which loads common libraries at runtime."
C_Programming,3297e3,FUZxxl,6,Sat Apr 11 20:19:26 2015 UTC,"You're half right.   Headers won't affect output size, However how libraries are linked or included depends on your compile options.  Which I think OP is static linking causing the ""outside functions"" to be included in the final binary."
C_Programming,3297e3,EkriirkE,2,Sat Apr 11 20:29:50 2015 UTC,Depends on if you statically link or not. I have struck out that part of my post though to avoid confusion.
C_Programming,3297e3,bithush,3,Sat Apr 11 20:29:19 2015 UTC,OPs example is certainly not statically linked; such a binary would be much larger.
C_Programming,3297e3,FUZxxl,1 point,Sat Apr 11 20:32:12 2015 UTC,"Additionally, why does the executable program become so much larger after you compile it?   apart from /u/Rhomboid's extensive answer i can recommend taking a look at an old compiler source for early microcomputers like amiga or msx. You'll see how the standard library is implemented in a much easier way then you can with a compiler nowadays."
C_Programming,3297e3,balkenbrij,-5,Sun Apr 12 00:23:35 2015 UTC,"FYI: you can use Fabrice Bellard's Tiny C Compiler (aka TCC) to make smaller exe files that aren't bloated with compiler optimizations.  One reason the binary executable can be larger is because one line of code can be expanded into many cpu instructions. But also all the stuff the compiler includes for OS interaction, etc. Gone are the days where your code is all that the CPU sees.  An interesting read: http://blog.erratasec.com/2015/03/x86-is-high-level-language.html#.VRMWtvnF-FU"
C_Programming,3297e3,deftware,9,Sat Apr 11 21:02:56 2015 UTC,"Actually tcc usually produces much larger code because it doesn't optimize at all. Many optimizing compilers implement a -Os switch to optimize for size, which disables loop unrolling and stuff like that."
C_Programming,3297e3,FUZxxl,1 point,Sat Apr 11 22:54:28 2015 UTC,"Yes, code-wise, this is true. But no other compiler that I've seen can put out a 1.5kb PE executable."
C_Programming,3297e3,deftware,1 point,Mon Apr 13 05:47:04 2015 UTC,"That's because tcc contains its own linker which does a few things differently when it comes to the placement of data structures in the binary. The machine code itself is larger but if you don't have a lot of machine code, such differences might show themselves."
C_Programming,3297e3,FUZxxl,1 point,Mon Apr 13 06:29:44 2015 UTC,"An interesting read: http://blog.erratasec.com/2015/03/x86-is-high-level-language.html#.VRMWtvnF-FU   While everything the author states in that article is correct, x86 is still a low-level language. The definition does not change based on how hardware uses the machine instructions. For example, Java Binary Code is a low-level language when it is running on processors that run Java Binary Code natively:   Low-level languages can be converted to machine code without using a compiler or interpreter, and the resulting code runs directly on the processor."
C_Programming,328xki,Enlightenment777,9,Sat Apr 11 17:25:55 2015 UTC,"https://github.com/kframework/c-semantics looks for undefined behavior dynamically, as well as some violations of constraints statically.  This includes many of the MISRA rules.  It's free and open source.  I guess I should add, I'm the original author of this.  It's currently being developed and maintained by others though."
C_Programming,328xki,ellisonch,5,Sat Apr 11 18:41:40 2015 UTC,This works for C: http://cppcheck.sourceforge.net  There aren't a lot of good free tools out there that I know of. Especially ones that check for Misra compliance.
C_Programming,328xki,svaha1728,6,Sat Apr 11 18:18:10 2015 UTC,"Non helpful question perhaps, but why are you looking to conform to MISRA C?  I ask because generally people fall into two groups regarding MISRA:   Businesses developing software in industries that are required (or strongly recommended) to follow MISRA principles such as Automotive, safety related products, etc. For these companies, tools that cost $389 are no big deal. Everyone else    I was wondering if you had stumbled on MISRA as a sort of metric of code quality for your personal projects, or if you are in some other situation (start-up aimed at a safety industry) where you actually NEED MISRA compliance to pass certification, etc.  IMHO MISRA C has a lot good ideas to it, but can go too far in some places, and certainly isn't an end-all be-all of code quality.  edit: Feel free to PM me if you want to discuss in private rather than public."
C_Programming,328xki,jahmez,1 point,Sun Apr 12 08:08:34 2015 UTC,"Several compilers have fairily good builtin misra compliance checker. Tasking is quite OK from that perspective (but their linker/locator omfg). So you have two options. If you are just doing a hobby project, noone would hunt you down if you use a time limited eval copy of a compiler with builtin misra checker, and execute the misra check with it. If you are into commercial development however, then cough up that 400USD for PC-Lint. That tool deserves it."
C_Programming,32ajfg,lehigh93,5,Sun Apr 12 02:02:38 2015 UTC,"int * calcMatrix(int min, int max){     int numInts = max - min;     int * a1 = (int * )malloc(sizeof(int) * numInts);     int j = 0;     for (int k = min; k < max; k++) {         int r = k / N;         int c = k % N;         int sum = 0;         for(int i = 0; i < N; i++){             sum += A[r][i]*B[i][c];         }         a1[j] = sum;         j++;     }      return a1; }   There's with formatting.  Put four spaces before each line of code.  You don't need to typecast malloc.  Did you forget to include the header file for malloc by any chance?"
C_Programming,32ajfg,dumsubfilter,2,Sun Apr 12 04:06:58 2015 UTC,You can also just copy and paste the code in between triple-backticks  ``` /* example */ ```
C_Programming,32ajfg,-Polyphony-,1 point,Thu Apr 16 01:59:57 2015 UTC,```   That's great!  I kept asking if there was a way to do that without having to do the whole four space thing.
C_Programming,32ajfg,dumsubfilter,1 point,Thu Apr 16 03:35:18 2015 UTC,"I included the header, but the issue just resolved itself somehow.  Thanks dumsubfilter!"
C_Programming,32ajfg,johncmouser,1 point,Mon Apr 13 04:06:23 2015 UTC,"Typically an invalid conversion is caused by incorrectly casting void *.  On a side note, you do not need to cast the result of malloc(). See this post on stackoverflow.  You can just write:  int * a1 = malloc(sizeof(int) * numInts);"
C_Programming,32afrp,andrespm_,2,Sun Apr 12 01:28:03 2015 UTC,You haven't stated the problem that you're having or given the source you are having it with.
C_Programming,32afrp,Chooquaeno,1 point,Sun Apr 12 01:31:13 2015 UTC,"Well, I want to know if I can use a unique subroutine to calculate the salary of all workers, or if I have to make four subroutines for the four types of workers."
C_Programming,32afrp,Chooquaeno,1 point,Sun Apr 12 01:34:30 2015 UTC,Do you know what a switch statement is?
C_Programming,32afrp,Chooquaeno,1 point,Sun Apr 12 01:56:23 2015 UTC,"yeah, why?"
C_Programming,32afrp,cehmu,2,Sun Apr 12 01:59:14 2015 UTC,"Well, you want to approach this on a case by case basis."
C_Programming,32afrp,Chooquaeno,1 point,Sun Apr 12 02:04:41 2015 UTC,"So, I am almost finished, but I want to know how to add(a+b+c+d) together all the salaries in the cases. http://i.imgur.com/d7C636t.jpg http://i.imgur.com/OeX1T2h.jpg didn't make a subroutine for A, since it's a fixated salary"
C_Programming,328wnf,-Kuroh-,4,Sat Apr 11 17:17:54 2015 UTC,Since it's a double linked list:   Pick a starting node. Advance one pointer forward. Advance one pointer backward. Go until they meet again.
C_Programming,328wnf,dumsubfilter,5,Sat Apr 11 17:35:43 2015 UTC,"To be a little more precise:   Create 2 pointers and assign them both to the same node One pointer increments along the list, the other decrements When the both end up assigned to the same node again, display it"
C_Programming,328wnf,savagenick,2,Sat Apr 11 17:50:13 2015 UTC,"Yeah, that's what I said.  There's a bit of finessing involved though.    abc; p = a, n = a  abc; p = c, n = b  abc; p = b, n = c  abc; p = a, n = a ... you just printed the starting node with your step three.  Edit:  Technically, any node in a circular-odd-numbered-list is the middle."
C_Programming,328wnf,dumsubfilter,2,Sat Apr 11 17:56:23 2015 UTC,Thanks.
C_Programming,328wnf,dumsubfilter,1 point,Sat Apr 11 17:57:27 2015 UTC,Thanks. I'll try implement it.
C_Programming,328wnf,dumsubfilter,2,Sat Apr 11 17:56:57 2015 UTC,"It should actually be ""how do you handle an even number of nodes"".  Because there actually is a middle to an odd number of nodes.  You need to develop cases where each pointer can see the next.  I was laying out the general ground work for OP.  Once they get the concept down, they can work out the remaining details.  If I did the whole thing for them, what would they learn?"
C_Programming,328wnf,Computician,1 point,Sat Apr 11 17:57:24 2015 UTC,"What's the middle of four?  1 2 3 4  Is it 2.5 ?  Because that's not a valid pointer location.  See, you aren't counting the starting node when you're considering the remainders.  You're ignoring it, which is why you run into the scenario of thinking that an odd number of nodes is the special case.  It's actually the even number that has no middle.   But these are the special cases that the OP needs to figure out how they're too be handled.  Basically, if n = p and n != a, then you have an even number of nodes, and you have to decide which one (prev, or next) you want to make your middle:  abcd; n=p=a  abcd; n=b,p=d  abcd; n=c,p=c ... n=p=c !=a ... but clearly c is not the middle"
C_Programming,32avkd,once-prg,3,Sun Apr 12 04:00:25 2015 UTC,"Are you expecting it to print something every time you type a character? Because thats not what your code says. If you expect it to print something every time you type something, you need some braces for your loop. Its not python, where indentation counts."
C_Programming,32avkd,garion911,3,Sun Apr 12 05:17:07 2015 UTC,"Both your programs are counting characters. To count lines, the second one should be counting just newline ('\n') characters. It needs an if in the body of the while loop.  Also, should be  int main(void)   and return 0 to indicate success."
C_Programming,32avkd,raevnos,-5,Sun Apr 12 04:35:05 2015 UTC,"Yes, that's precisely it . I mean, don't get me wrong, that's what I was expecting since I'm doing it by the book, and you have that printf there, for me it seems logical it would print the increment every time I type something, that's the point I'm not understanding, it I have a statement:  printf(""%d\n"", nl);   that should print the contend of     nl formatted in 1 decimal point, followed by a newline character (""%d\n"") isn't it?  Feel free to tell me what's the point I'm not getting here.  Thanks"
C_Programming,32avkd,ratatask,3,Sun Apr 12 05:26:13 2015 UTC,"You are aware that this  code:    while (getchar() != EOF)                   ++nc;         printf (""%ld\n"", nc);   is the same as this ?:    while (getchar() != EOF) {       ++nc; } printf (""%ld\n"", nc);   That means your printf statement is not run until the input stream has ended. In a linux terminal, you do that by issuing CTRL+D, in a Windows console you do it with CTRL+Z."
C_Programming,32avkd,Wiggledan,2,Sun Apr 12 09:35:59 2015 UTC,"No, I didn't know it. Now you told me this, I was able to see the printf's output. I bit odd the authors don't say anything about this, I was starting to think they're crazy.  Thanks"
C_Programming,32avkd,chalk46,3,Sun Apr 12 16:14:20 2015 UTC,"That book, although recommended by tons of people, is getting pretty old (1st edition 1978, 2nd ed. 1988). It was written by the authors of C before a C standard was even made. It's not the best book if you're an absolute beginner, because it wasn't written to be super descriptive and simple; it just concisely covers all the features you would need. There's also a lot of modern coding practices and updated C facts that the book is missing due to its age. (Like int main(void) for example)  So you should either keep powering through K&R, and just look up help online when you need it like you did here, or go for an easier book that will explain things more clearly. I got stuck in like chapter 2 of K&R, and I switched to C Programming: A Modern Approach instead. Now I'm actually getting things and I plan on revisiting/completing K&R later."
C_Programming,32avkd,antlife,1 point,Sun Apr 12 16:34:52 2015 UTC,"Interesting, I felt precisely the same, K&R is more for experienced programmers who don't want lose much time with explanation, just want the get introduced to the language. Anyway, I switched to let us C, a better book of course."
C_Programming,32898f,AbstractedStory,8,Sat Apr 11 13:41:58 2015 UTC,You want a decompiler. It won't be the original source though. It will be a version of source code that would generate that machine code.
C_Programming,32898f,dallen,2,Sat Apr 11 14:02:34 2015 UTC,"I see, thanks!"
C_Programming,32898f,Genocidicbunny,4,Sat Apr 11 14:20:06 2015 UTC,"At best you're going to get something back that resembles C but is really prettified assembly. In general without some kind of debugging symbols, the original C code used to compile an executable is not recoverable, although tools like IDA can do a pretty decent attempt at it."
C_Programming,32898f,Pipfstard,2,Sat Apr 11 18:35:10 2015 UTC,"I've never come across any running on linux software that would be able to do that. There exitsts microapl's http://www.microapl.co.uk/asm2c/index.html, but it's a commercial project.   Converting back to original c is impossible, because some information is put away during compiling (variable names, comments, macroses are replaced with their definitions and so on).   You can use objdump. It would produce you asm code from binary, it could suit your needs."
C_Programming,32898f,FUZxxl,2,Sat Apr 11 15:46:36 2015 UTC,"Such programs exist, they are called decompilers. There aren't any free decompilers as far as I know and the commercial decompilers I know of are quite expensive. You could try to disassemble the binary and make sense of the assembly; it's a bit hard but fun to do."
C_Programming,32898f,bxedit,1 point,Sat Apr 11 18:58:29 2015 UTC,Are you talking about .net msil or are you talking about pure x86 executable binaries. With .net programs it is possible? However with executable binaries it would be practically impossible? Never heard of such a tool.
C_Programming,3297j4,Shtreimel,2,Sat Apr 11 18:48:48 2015 UTC,"The problem is the way you read input. The man page for scanf says:   s      Matches a sequence of non-white-space characters; [...]   However, \n is a white-space character, which means that user_input will never contain a \n, which means that change_string will call itself endlessly.  Adding those two lines makes the code work because (i=='\n') is the same as (i==10) (assuming your computer uses ASCII) and i will eventually reach that number. The code is still buggy because it will cause undefined behavior if the string has only a few characters.  To fix the code correctly, stop when you find a \0 instead of \n. Don't forget to check the first two characters too (your code currently doesn't do that). You may also want to use fgets instead of scanf:  fgets(user_input, 20, stdin);   The advantage of fgets is that it doesn't read more than 20 characters, which would cause undefined behavior. However, it does read the \n character unlike scanf. String handling in C is unfortunately quite complex."
C_Programming,3297j4,dreamyeyed,1 point,Sat Apr 11 22:21:41 2015 UTC,"Thank you man, I mistook \n with \0 have an upvote :)..  I can't use fgets, I was asked  to use scanf. (it's home work.)"
C_Programming,328arj,Theusualtype,13,Sat Apr 11 13:59:46 2015 UTC,"I think you should read about more sophisticated things you can do with printf. You can control the field width and justification; for example  #include <stdio.h>  int main() {     printf(""%-20s %3d\n"", ""Hello"", 130);     printf(""%-20s %3d\n"", ""Printing things"", 1); }"
C_Programming,328arj,wgunther,2,Sat Apr 11 14:13:32 2015 UTC,That is exactly what I was looking for! Thanks very much!
C_Programming,328arj,SeriousBug,6,Sat Apr 11 14:38:54 2015 UTC,"You also might want to look at the extended ascii characters, it has some characters that you can use to draw boxes on console, without having to use any special libraries.  You could get something like:  ┌───────┬────────┬───────┐ │ Name: │ ID     │ Inst. │ ├───────┼────────┼───────┤ │Dan Ak.│D129823A│ ITT   │ │Jen Ba.│J101010B│ DIT   │ └───────┴────────┴───────┘"
C_Programming,328arj,autowikibot,2,Sat Apr 11 14:35:13 2015 UTC,"Section 4. Unix, CP/M, BBS of article  Box-drawing character:       On many Unix systems and early dial-up bulletin board systems the only common standard for box-drawing characters was the VT100 alternate character set. The escape sequence Esc ( 0 switched the codes for lower-case ASCII letters to draw this set, and the sequence Esc ( B switched back:  A Bash script that displays all of the semigraphic characters:  On some terminals, these characters are not available at all, and the complexity of the escape sequences discouraged their use, so often only ASCII characters that approximate box-drawing characters are used, such as - (hyphen-minus), | (vertical bar), _ (underscore), = (equal sign) and + (plus sign) in a kind of ASCII art fashion.     Interesting: Code page 852 | Code page 950 | Box Drawing | Code page 850   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,328arj,gliese946,3,Sat Apr 11 14:36:09 2015 UTC,"one other thing I've found useful for this: you might not know it yet, but printf actually returns a value, which is the number of characters it has printed. You usually throw the return value away, but instead you can write t=printf("" [whatever]"");, giving you the number of characters in your variable t. If you have more than one printf statement in the first column, for the subsequent ones do t+=printf( whatever );. To make use of this, you first set a tab variable equal to 40, say, then print your first column, then, in a loop which you cause to be executed tab - t times you print a space. And voila your second column will begin printing at the 40th character on the line."
C_Programming,328arj,SuperImaginativeName,1 point,Sat Apr 11 23:45:14 2015 UTC,That's REALLY useful. Thanks!
C_Programming,328arj,bithush,0,Sun Apr 12 01:01:02 2015 UTC,Holy shit. TIL. Why is this NEVER mentioned anywhere!?
C_Programming,328arj,brunokim,2,Tue Apr 14 13:08:55 2015 UTC,The f in printf is for formatting. It is seriously powerful. Have a read up on printf and related functions.
C_Programming,328arj,FUZxxl,1 point,Sat Apr 11 14:20:29 2015 UTC,"You should really study printf's capabilities: it's a mini-language used by most other languages as well. Even Python, which already had a very good format function, also included a printf later.  /u/wgunther already told you about setting the width of a field hardcoding a value, but it can also be dynamic using an asterisk. Instead of printf(""%20s"", mystring), you can use printf(""%*s"", width, mystring). In your case, you can first create a function to read the maximum width of the name (first name and surname) field for all structs, and then use this value as input to your printf. The other fields seems to have a constant width, so that's unnecessary."
C_Programming,328arj,FUZxxl,1 point,Sat Apr 11 16:40:29 2015 UTC,Could you provide the content of the screenshot as text instead of a picture? Pictures are useless for copy-pasting and for blind people.
C_Programming,328arj,FUZxxl,1 point,Sat Apr 11 18:55:46 2015 UTC,"Well all the screenshot is is a lit of details in the form of a firstname, surname, ID Number and Institution for 30 different people in command prompt. I'm not really sure why it would be needed for copying and pasting."
C_Programming,3260xr,yall_,14,Fri Apr 10 21:43:39 2015 UTC,"Every program needs to have a main function. The examples you see in your book lacking a main functions are probably examples of how to write functions to perform various things. But, when they're used, they must be compiled together with some bit of code that defines a main function. Program execution does not happen the same way it does in C as it does in JavaScript. The main function tells the compiler what bit of code is ran when the program is ran.  The return type of the main function must be int (although the standard does leave some wiggle room for implementations to provide a way to provide other kinds of main function; this should probably be irrelevant to you though). void is not a valid kind of return for main. The confusion probably comes from Java which has a main method whose return type is void, or from a general understanding the C main function doesn't return anything because it can be compiled without an explicit return statement.  As for why the compiler warns you when the type defaults to int when it's not specified, this is for historical reasons. Back in the day, you did not need to specify the return type (or even parameters) for things, and the compiler would assume that they were ints. This is ANSI C from 25 years ago, and is not good C today, which is why the compiler is warning you that you should not use implicitly typed functions."
C_Programming,3260xr,wgunther,11,Fri Apr 10 22:01:35 2015 UTC,"yet when I look examples up online there are many programs which do not begin with that documentation.   You are looking at them wrong.  Every program must have a main().  That's the entry point where execution begins.  Without a main() a program will fail to link.  This is not necessary in JavaScript, because in JS you can have arbitrary statements outside of functions, but that's not the case in C.  You can only declare variables at file scope, you can't put code there.  All code has to be inside functions.  In JavaScript, execution starts at the top and follows linearly, but if that was how C worked, nothing would execute because you can only have declarations at file scope.  There must be an entry point, which is a function where execution begins, and that's main().   why does my compiler always return the warning ""main() type not specified, default to int""   Post your code if you want an answer to that.  The C standard says that there are two valid signatures for main:  int main(void) {     ... }   and  int main(int argc, char **argv) {     ... }   You must choose one of those.  If you're trying to do something like void main(), you're wrong; that's invalid.  If any teaching material is using anything but one of those two, it's horrible material and you should burn it and find better teaching material.  (Technically, it's allowable as implementation defined behavior for platforms to have extra arguments after argv, but you should ignore that.)  And at no point are you ""passing void"".  You are declaring the signature of the function, i.e. declaring the number and types of arguments, as well as the type of the return value.  void is not a value, it's a type.  A function declaration with (void) means that the function takes no arguments.  If you wrote () that would mean an unspecified number of arguments, not zero arguments.  You don't want that.  (This is a misfeature of C due to a long history of backwards compatibility with pre-standard C.)"
C_Programming,3260xr,Rhomboid,10,Fri Apr 10 21:59:33 2015 UTC,"The C standard says that there are two valid signatures for main:  ...   You must choose one of those.   That’s not quite true, it also allows any other implementation-defined prototype at all, not just “extra arguments”. A void return type is very commonly used on eg, embedded platforms where an exit code is pointless.   A function declaration with (void) means that the function takes no arguments. If you wrote () that would mean an unspecified number of arguments, not zero arguments.   Technically true, but as you said that goes only for separate function declarations, i.e. prototypes, not for function definitions."
C_Programming,3260xr,demyze,8,Fri Apr 10 22:13:07 2015 UTC,"If you want to go really far, main doesn't actually have to be a function: http://jroweboy.github.io/c/asm/2015/01/26/when-is-main-not-a-function.html"
C_Programming,3260xr,qm11,4,Sat Apr 11 01:56:13 2015 UTC,"In my Computer Systems Organization class back in '99 we had to write an assembly interpreter. We basically did exactly this to execute the code: load the interpreted bytes into an int array, cast it to a function pointer, and call it. I always thought it was a cool and powerful tool in C."
C_Programming,3260xr,WackityShmackity,2,Sat Apr 11 07:21:27 2015 UTC,"I’m talking about what the standard says, not what you can do."
C_Programming,3260xr,demyze,7,Sat Apr 11 12:25:58 2015 UTC,"You can also pass in envp for most C implementations. You're right that it isn't standardized though.   int main(int argc, char **argv, char **envp)  {   .....  }"
C_Programming,3260xr,aleph_nul,2,Fri Apr 10 23:44:46 2015 UTC,OP:    yet when I look examples up online there are many programs which do not begin with that documentation.   OP is confusing the top of the file (where he begins reading) with where the program's entry point actually is.  Good summary on your part.
C_Programming,3260xr,dumsubfilter,1 point,Sat Apr 11 18:32:41 2015 UTC,"If you're trying to do something like void main(), you're wrong; that's invalid. If any teaching material is using anything but one of those two, it's horrible material and you should burn it and find better teaching material.   Unless you're writing something for an embedded system."
C_Programming,3260xr,PatriotGrrrl,4,Sat Apr 11 19:02:40 2015 UTC,"main is not documentation, it is a function. It's special because it's the entry point, it's the first function called when you run your program.  Shared libraries won't have a main, because they're libraries and not programs.  Some random file that you look at won't have a main. Only one file in the whole project needs a main function.  In older versions of C, if you don't specify a function's return value it defaults to int and you get a compiler warning. In newer standards you have to specify a return value.  ""void"" is the nothing type. If the function returns nothing, you write ""void"" as its return type. If it takes no arguments, you write void where they arguments go when defining it (not when calling it).  You can't have a variable of type void. You can have a variable of type ""void*"" (void pointer). In this case, it means it's a pointer to an unknown type (instead of to nothing)."
C_Programming,3260xr,looneysquash,3,Fri Apr 10 23:50:13 2015 UTC,"main() is the first function called by the C library after it has self-initialized (by hidden code within your program). Some compilers offer several other (non-standard) functions that are called before main() gets called, for example so C code can initialize a system so that the C library can exist."
C_Programming,3260xr,angdev,3,Sat Apr 11 01:00:09 2015 UTC,"Additionally, why does my compiler always return the warning ""main() type not specified, default to int"" even when I copy the author's code verbatim?   I assume your function looks like this:  main(void) {     /* do stuff */ }   If that's the case, the warning is because you're not declaring the return type. Unlike in JavaScript, in C you have to state the type of value a function returns. It just so happens that the default if you don't provide one is int and main should return an int. This ""default typing"" was (is?) common, but it's bad practice."
C_Programming,3260xr,Jack126Guy,4,Fri Apr 10 22:04:28 2015 UTC,"It just so happens that the default if you don't provide one is int and main should return an int. This ""default typing"" was (is?) common, but it's bad practice.   Only in C89, not in the later standards."
C_Programming,3254st,Men_Of_Spoons,6,Fri Apr 10 17:40:00 2015 UTC,"A basic echo server is a good first project. Just listen on a port, and when someone connects (use netcat for this!), echo each line they send back to them.  From there you could do chat, if you want.  From there, I'd actually encourage you to work towards a very basic HTTP server. The HTTP protocol is surprisingly easy, and the original server was implemented by Tim Berners-Lee in only a couple hundred lines of readable C."
C_Programming,3250q3,WayNoWay1,4,Fri Apr 10 17:08:42 2015 UTC,"A definite possibility is that you are running into integer overflow. Two polynomials of degree 10,000 whose coefficients can be as large as 1000 can produce a product with coefficients larger than the maximum value of a (32-bit) int."
C_Programming,3250q3,zifyoip,1 point,Fri Apr 10 17:58:29 2015 UTC,What should I use instead?
C_Programming,3250q3,zifyoip,1 point,Sun Apr 12 14:42:13 2015 UTC,"A larger integer type, such as long or even long long."
C_Programming,3250q3,zifyoip,2,Sun Apr 12 15:53:42 2015 UTC,"Well, your output has trailing spaces at the ends of the lines, for one thing."
C_Programming,3250q3,FUZxxl,1 point,Fri Apr 10 17:15:17 2015 UTC,"Well, I tried again, and that's not it. Thanks btw"
C_Programming,3250q3,dijumx,1 point,Fri Apr 10 17:21:12 2015 UTC,What do you mean with “I am getting a wrong answer?”
C_Programming,3250q3,FUZxxl,3,Fri Apr 10 17:41:28 2015 UTC,"I assume (s)he means that the website they are submitting to is telling them they have a wrong answer, but not necessarily telling them how they failed."
C_Programming,3250q3,zifyoip,2,Fri Apr 10 17:49:36 2015 UTC,"I guessed something like that. Any way, this question is vastly underspecified. It doesn't even tell me what the expected output is."
C_Programming,3250q3,FUZxxl,2,Fri Apr 10 17:50:35 2015 UTC,Did you read the specification?  http://www.spoj.com/problems/POLYMUL/
C_Programming,3250q3,zifyoip,-1,Fri Apr 10 17:56:48 2015 UTC,How am I supposed to know that this is the problem OP is supposed to answer?
C_Programming,3250q3,FUZxxl,6,Fri Apr 10 18:00:50 2015 UTC,"Because it's the very first thing in OP's post, linked with the text ""The question."""
C_Programming,3250q3,sgthoppy,0,Fri Apr 10 18:01:51 2015 UTC,Ok. I must have overseen that link.
C_Programming,3250q3,dragon_wrangler,1 point,Fri Apr 10 18:02:25 2015 UTC,"One problem I can see is in the main function, you have  while (t-->0)   which, I believe, translates to  while (t=t-1>0)   and you can probably see why that isn't right. The while loop should look like  while (t-1>0)   or simply  while (t>1)"
C_Programming,324vjs,ElGringoFlicka,8,Fri Apr 10 16:29:38 2015 UTC,"Endianness is only observable if you access the underlying bytes of the type.  That's not what you're doing.  Expressions like val >> 8 and val & 0xff are performed as operations on uint16_t, which means the endianness is not exposed.  val & 0xff is always the LSB regardless of endianness.  You're only casting to uint8_t afterwards, but at that point it's just a formality to shut up any warnings; you've already isolated the byte in question, so the cast isn't really doing any work.  Compare yours with a broken way of doing it:  void brokenSend(uint16_t val) {     uint8_t *bytePtr = (uint8_t *)&val;     outByte(bytePtr[0], ADDRESS);      // MSB     outByte(bytePtr[1], ADDRESS + 1);  // LSB }   This example assumes big-endian, and will fail if the system is little-endian, because it's accessing the bytes directly, rather than doing bitwise operations on the entire width of the value.  Your version is fine, this example is bad and is given only as an example to compare against."
C_Programming,324vjs,Rhomboid,1 point,Fri Apr 10 16:43:58 2015 UTC,Thank you very much. Thanks for showing a bad example. I understand.
C_Programming,324vjs,FUZxxl,1 point,Fri Apr 10 17:03:48 2015 UTC,Your way of doing things is the right way. Please continue coding that way. You might be interested in this project of mine.
C_Programming,324vjs,OlderThanGif,1 point,Fri Apr 10 17:42:53 2015 UTC,"Your code will only work on platforms with an 8-bit char (byte), but other than that, no problems."
C_Programming,323mt3,wilcoholic88,8,Fri Apr 10 08:43:27 2015 UTC,"Do you have any prior experience in programming? If so, you might be able to finish K&R in 5 days, which is a pretty nice book if you already know how to solve proplems conceptually and only need a reference for the syntax of C (it has exercises as well). If you have no prior experience, there is no way you'll even come close in 5 days. Unless, of course, you don't have to be able to use the language, then block below is all you need.  auto break case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while"
C_Programming,323mt3,bricksnort,2,Fri Apr 10 09:13:59 2015 UTC,"Are those really, all the keywords in C?  you might want to include the preprocessor macros."
C_Programming,323mt3,stillalone,1 point,Fri Apr 10 16:16:14 2015 UTC,Well it should be 70-80% :)
C_Programming,323mt3,bricksnort,6,Fri Apr 10 20:12:23 2015 UTC,Do you already know a language?  Learning an entire language in a few days will almost never work...
C_Programming,323mt3,LongOdi,2,Fri Apr 10 09:09:46 2015 UTC,"That really depends. Are you familiar with any other programming languages? C is a rather ""small"" language in that there is not as much key words and syntax needed to memorize as opposed to a bloated language like C++ or Java. It is possible to learn the language of C in five days, but it will take much longer to become skilled at programming with it.  If you are not familiar with other languages, I recommend Head First C. It covers the basics of the language in a rather fun and easy to read format.  If you are familiar with other languages, you can try 21st Century C. It covers modern programming practices with C rather than the language itself.  They both cover C11, and I personally wouldn't settle having to use anything less than C99.  Hope that helps and good luck."
C_Programming,323mt3,mathengie,2,Fri Apr 10 09:18:28 2015 UTC,Can't be done.
C_Programming,323mt3,WeAreChris,1 point,Fri Apr 10 11:46:48 2015 UTC,"What /u/LongOdi said. If you want a helpful answer you'll have to tell us where you're coming from. Also, what do you actually need to know? C as a language is pretty small, but you need to know a lot more if you need to do anything useful.   That said, K&R would be a decent place to start and at least get an idea as to whether you think it's feasible."
C_Programming,323mt3,baudvine,1 point,Fri Apr 10 09:16:57 2015 UTC,"Non-mobile: http://en.wikipedia.org/wiki/The_C_Programming_Language  That's why I'm here, I don't judge you. PM /u/xl0 if I'm causing any trouble. WUT?"
C_Programming,323mt3,LittleHelperRobot,1 point,Fri Apr 10 09:17:01 2015 UTC,I know some C but I am essentially just barely a beginner. It has also been years ago that I last used C on a beginners level
C_Programming,323mt3,zenkibudo,1 point,Fri Apr 10 17:47:11 2015 UTC,Two days remaining -- how's it going?
C_Programming,31ztuc,LagMadeMeDie,2,Thu Apr 9 13:21:10 2015 UTC,"What happens that it can't continue? Does it seg-fault?  As a note, with a proper AVL tree you'll never call the rotate methods with a NULL t or t->left/t->right (Depending on which rotate you're calling). You might want to, instead of silently exiting if you find a NULL, use 'assert' or similar to alert you that there's a problem and you called rotate with a NULL pointer. I've only taken a bit of a glance, but seeing if there are any situations where this happens may help figure-out what's going on.  Also, I feel like your code is much more complex then necessary - I don't know if that's because you're following someone elses example code or etc.. But your AVL insertion can/should be a mostly linear process. You have a pretty complicated setup with 'InsertTree' and the other 'Insert' functions where they recursively call each-other. This complexity isn't necessary because you can do the actual insertion of the node in a single loop (Like a normal BST insert), then update the balance factors, then perform a rotation if necessary."
C_Programming,31ztuc,DSMan195276,1 point,Thu Apr 9 16:40:56 2015 UTC,"Yes, it simply says Segmentation fault. Do you have any simpler example that you can share?  We are reusing a code from some classes we had earlier, but it might be over complicated for this task"
C_Programming,31ztuc,DSMan195276,1 point,Thu Apr 9 17:35:06 2015 UTC,"If it's seg faulting, then you may find the program valgrind to be useful. I use it a lot for seg faults. I would recommend installing it and using it like this:  valgrind --mem-check=full --show-leak-kinds=all --log-file=""val_log.txt"" ./prog   You could omit the log-file portion if you want, I usually have valgrind write it's output to a log so it's easy to separate the output from valgrind and the output from my program. There are lots of programs, like tail, that can allow you to view the contents of the 'val_log.txt' file while it's written to, but that's getting a bit off-topic.  Your code will run slower with valgrind, but while it's running valgrind will tell you and warn you about the use of any uninitialized variables, dereferences of invalid memory locations (Which cause seg-faults), and memory leaks (Helpful with trees since it's easy to mess up some of the tree manipulations and end-up with losing part of your tree in the process).  I would personally recommend inserting those 'assert's into your rotation code, it doesn't have to be ""actual"" asserts but something like this:  if (t == NULL || t->left == NULL) {     printf(""SOMETHING IS BROKEN!!!!\n"");     printf(""T: %p\n"", t);     exit(0); /* Exit the program completely */ }   With code like that, an invalid call to your rotation code will result in your program blowing up with a message. This way, you won't continue on thinking the rotation happened and you can try to diagnose the issue closer to the source of the problem. You should note, if you do end-up calling a rotate with NULL, it's likely your balance factors are incorrect (And bad balance factors led you to think you need to do a rotate in a place where one wasn't actually necessary).  With that, I would recommend modifying your printAVL function to both print the balance-factor, do an inorder-traversal instead of pre-order, also indent based on how far down the tree the node is located. Basically, modify your printAVL so you get output like this:      Node: 0x10203040: Key: 102: BF: 0   Node: 0x12345678: Key: 30: BF 1 Node: 0x12341234: Key: 15: BF 1     Node: 0x23450204: Key: 14: BF 0   Node: 0x45050303: Key: 12: BF 1     Node: 0x98482848: Key 11: BF 0   With output like that, you can easily analyze the state of the tree and see if there are any incorrect balance factors. As a note, I put an incorrect balance factor in the above example, the node with key 12 has a balance factor of '1' when it should actually be '0'. It's pretty easy to see this is the case when comparing the fact that the height of the left and right trees on the node with key 12 are equal. By making your printAVL function output like that, and then putting lots of printAVL functions around your code, you can easily examine the state of the tree after various things are done to it, to confirm and test that the tree is always left in a correct state.  When I was writing an AVL tree implementation, I found it helpful to always print out the type of rotation I was performing, if one was necessary, print out the tree before the rotation, and print out the tree after the rotation. Even better, put a call to 'getchar()' in your main loop, and you can step through every insert to your AVL tree and then print it to make sure every insert works. When you find an insert that leaves the tree in a bad state, follow through your code and figure out why it was wrong."
C_Programming,31w981,yall_,18,Wed Apr 8 17:28:27 2015 UTC,"The main advantage of C I would say is that it is easily portable to new architectures.  Someone who codes in java for example may jump in and say blahhhh! java runs on any computer and doesnt need to be ported.  However if you write a program in java you are pretty much limited to architectures that java supports.  If you write a program in C you are also limited to architectures that have C compilers, but that is basically every architecture.  So if you have helloworld.c the only thing that needs to be ported is the print function. Helloworld.java however needs to port the entire java runtime, then port the print function to execute. One example of an application of C is writing programs for microcontrollers. You often only have two choices for programming languages(C or Assembly).  It is highly recommended to use C not only because it is easier, but also because code written in C can be easily ported to other microcontrollers."
C_Programming,31w981,Robotnik00,7,Wed Apr 8 18:06:55 2015 UTC,If someone who codes in java jump in and say blahhhhh ! ... ask him in what language was written the JRE :)
C_Programming,31w981,hotfudgegringo,1 point,Thu Apr 9 11:59:41 2015 UTC,Nice one.
C_Programming,31w981,CodyChan,14,Sat Apr 11 18:42:50 2015 UTC,"Can C be used to write, for example, a solitaire app that you can open up on your desktop?   Yes.  There are lots of applications written in C. In the open source world, it's still sort of popular even as a language for writing desktop-ish apps. Some are vlc, mplayer, and xchat. I think large portions of GNOME are also written in C.  Lots of GNU software are written in C, iirc.   Other kinds of software people write in C include operating system (e.g. Linux), device drivers, embedded software.  I can't really tell where C is mostly used though."
C_Programming,31w981,phao,12,Wed Apr 8 17:37:06 2015 UTC,Quake 3 was made using C!
C_Programming,31w981,angdev,2,Wed Apr 8 18:53:49 2015 UTC,Because John Carmack didn't know C++ :)
C_Programming,31w981,OldWolf2,4,Thu Apr 9 05:12:57 2015 UTC,Because John Carmack didn't know C++ :)   Or he knew better than to use it.
C_Programming,31w981,playaspec,2,Thu Apr 9 22:56:14 2015 UTC,"Well, in 1999 that was probably a valid statement."
C_Programming,31w981,OldWolf2,9,Thu Apr 9 23:02:25 2015 UTC,If you want to have a look at a very interesting example on what can be done in c you should have a look at handmade hero. Its live on twitch and archived on YouTube
C_Programming,31w981,Pendax,5,Wed Apr 8 17:57:30 2015 UTC,"Handmade Hero is C++, not C."
C_Programming,31w981,terremoto,4,Wed Apr 8 22:11:42 2015 UTC,"It is C++, but it's as strictly C as can be. I think with some work, you could do the same in plain C."
C_Programming,31w981,Wiggledan,3,Thu Apr 9 00:30:51 2015 UTC,"It's a general purpose programming language. The limit is your imagination (and coding skills... And hardware...). You could write a small database system for instance, since you say you're interested in storing stuff and in data structures."
C_Programming,31w981,tsahyt,3,Wed Apr 8 19:26:39 2015 UTC,"C is primarily used for OS (specifically *nix) development, utilities, game development and low-level hardware development.  I became more interested in electronics since learning about C. If that interests you, check out http://arduino.cc.  Kernel/OS development is a little higher level and if you use Linux, it's pretty interesting to see how it all works.  By utilities, I mean command-line utilities. If you're not already working at a command line, you should definitely consider switching to it. I almost never touch a GUI when doing C development (I commonly use vim, clang or gcc, git, and ctags all from the command line). I haven't written too many C utilities myself, but I am currently working on developing a compiler.  I've used C for some game development with SDL2, but it's more common to find C++ used in game development. The only disadvantage of using C instead of C++ is the lack of OO in C. If you decide to use C++, just use the OO and stick with common C idioms. I've seen more elegant C than elegant C++."
C_Programming,31w981,charles__l,8,Wed Apr 8 20:50:17 2015 UTC,"Personally to me C is an excellent language to learn both so that you understand better what is going on ""under the hood"" and since most systems software is written in it.  However, I would personally strongly recommend against using C for anything that you don't need the extreme portability and/or performance that C provides."
C_Programming,31w981,mordocai058,3,Wed Apr 8 18:40:37 2015 UTC,"If you use Linux regularly, you begin to realise that a LOT of popular software that is used is written in C.   mpd ncmpc mpv ffmpeg bash grub GNOME The Linux Kernel git iptables nginx apache the coreutils, i.e. ls, cd, man, who, grep, cat, sed, awk, cp, rm, mv...etc.    I could go on."
C_Programming,31w981,Chodrick,3,Thu Apr 9 08:37:50 2015 UTC,"C can be used for anything. However it is mostly used for lower level things such as kernels, device drivers and the like. Having said that a lot of applications, especially on Linux, are written in C. For the past 20 years most desktop applications on Windows are written in C++ although the underlying Win32 API is actually C so any Windows app could be written in C.   Now most people don't want to write a desktop or web app in C because generally it is easier to do it in another language like C++ or C# as they do make it a bit easier to do things like a user interface, networking, etc. with modern libraries.   C is the lingua franca in the computer world though. Almost every library will have a C interface for example."
C_Programming,31w981,bithush,3,Wed Apr 8 19:06:31 2015 UTC,"I like SDL for writing games in C, though it's been a while."
C_Programming,31w981,dtfinch,2,Wed Apr 8 21:09:09 2015 UTC,Angband is written in C and it's pretty nice code.
C_Programming,31w981,OldWolf2,3,Thu Apr 9 05:11:45 2015 UTC,"There isn't much that C can't be used for, to be honest. Personally, though, I use C for programming microcontrollers. My personal opinion is that unless you are doing system programming, or are willing to commit a lot of time to learning C, you might be better off with a higher level language such as Python, C#, Java, or Objective-C, which you'll be able to do a lot with since you're on a Mac."
C_Programming,31w981,rogue780,1 point,Wed Apr 8 18:10:05 2015 UTC,Have you got any good resources on learning embedded programming?
C_Programming,31w981,Always_Question_Time,2,Thu Apr 9 13:07:35 2015 UTC,"http://www.avrfreaks.net/ has really good stuff.  Stick with AVRs when first starting out.  Its fairly well documented and has a great community around it.  From there you can branch out to pic, Motorola, arm or TI msp430 platforms pretty easily.  Its a lot of research but its one of the best self learning experiences you'll ever run across."
C_Programming,31w981,Adhoc_hk,2,Thu Apr 9 13:30:00 2015 UTC,"Honestly, just a lot of googling and messing around."
C_Programming,31w981,rogue780,1 point,Thu Apr 9 14:00:10 2015 UTC,"Most anything you want really.  In the end it's all machine code.  A more useful answer though is that Javascript is designed to run in a scripting engine/virtual machine sand box (eg: the browser) and run consistently on any machine supporting ""javascript"" at the cost of functionality/speed (since it's limited to the VM/scripting engine it runs in).  C however compiles to machine code that runs directly on the target hardware.  This gives you performance and most all of the functionality of the target system at the cost of portability (since you can't pick up the compiled executable and put it on a different target system necessarily).   So anything you want to write you can write in C and run it on a computer (with caveats).  So you can write a program to run in OS/X or Linux or Windows and it can interact with the system as long as you know how to interact with the system.  Easy stuff may run just at the console/command line but more complex stuff can control windows and take over the whole computer.   The catch is, a lot of the libraries and documentation these days will expect you are using C++ and not C so you may have to do some extra work to get things to play nice (Direct X used to tell you exactly what you needed to do to make the C++ calls in C, but I haven't checked if they do lately)."
C_Programming,31w981,BlindTreeFrog,2,Thu Apr 9 02:37:52 2015 UTC,An important thing to remember when programming in C vs Javascript as well...  Javascript holds your hand and protects you from hurting yourself too bad.  C will let you set fire to the system and won't tell you that you shouldn't do that.  Stay away from pointers until you are sure that you understand what is going on.
C_Programming,31w981,BlindTreeFrog,1 point,Thu Apr 9 12:53:03 2015 UTC,"I'm working on a multiplayer OpenGL action shooter game that's procedurally generated, in C"
C_Programming,31w981,deftware,0,Thu Apr 9 01:42:05 2015 UTC,"Can C be used to write, for example, a solitaire app that you can open up on your desktop?   Yep"
C_Programming,31w981,SuperImaginativeName,-8,Tue Apr 14 13:10:11 2015 UTC,Mostly cry... and programming microcontrollers.
C_Programming,31w981,creepybunchofbananas,-5,Thu Apr 9 01:12:13 2015 UTC,C is nothing like JS...
C_Programming,31w981,kitchen_patio,-2,Wed Apr 8 23:58:26 2015 UTC,"The principle advantage of C is that it's the highest-level language that can be used to write a fully functional assembler. Bitwise operators, among other things, allow one to write assemblers and other gate-level code in C."
C_Programming,31w981,someJackass1,1 point,Thu Apr 9 04:29:47 2015 UTC,You can write an assembler in any language.  As long as it can read a text file and output binary you are good to go.   Nothing special about C in that regard.
C_Programming,31x2nj,kieger,3,Wed Apr 8 20:52:40 2015 UTC,"How far have you got so far? Don't worry about the array part to start, just write what you do know. Can you make an application that receives students' scores from the command line? Can you make it keep a rolling average?  Once you've done that the array part should be quite easy. You'll need an array of integers with 10 slots (one for each grade). Do you know how to declare and initialize that? Then, as you receive the individual grades, just increment the appropriate array slot.  If you're really having trouble, do it first without arrays. Use separate variables for each slot - like grade00, grade10, ... grade90. You should then be able to recognize the repeated parts of the code and turn them into arrays and loops."
C_Programming,31x2nj,dragon_wrangler,1 point,Wed Apr 8 21:02:15 2015 UTC,Thank you for the reply!  There are a couple of specific issues I'm having:   The while loop I'm using to feed the grades into the array keeps cycling indefinitely after the first user input and I can't really think of how to get it to pause after each input to accept another. I actually am having trouble initializing the array I'm using to store the grades.
C_Programming,31x2nj,angdev,1 point,Wed Apr 8 21:09:51 2015 UTC,"Also I'm working on putting it together without array right now, I should be able t finish that in a bit if I don't hit any snags. I'm extremely rusty. Thank you again for your reply."
C_Programming,31x2nj,Wiggledan,2,Wed Apr 8 21:28:09 2015 UTC,"If you get stuck at any point paste your code here (or on pastebin, its free) and we can help you out!"
C_Programming,31x2nj,dragon_wrangler,2,Wed Apr 8 21:40:22 2015 UTC,"Yeah, it can feel like defeat to ask someone to look over your code, but sometimes it's better to just ask for help instead of banging your head on the wall attempting to do it on your own."
C_Programming,31x2nj,-Polyphony-,1 point,Wed Apr 8 21:51:50 2015 UTC,It would be very wise of me to head your advice - but i honestly think I'm addicted to banging my head into this wall.
C_Programming,31t869,RetKennedy,2,Tue Apr 7 23:52:24 2015 UTC,"int create_list_no_nodes(   You are missing some of the signature. Since it returns an int it must get passed a list pointer:  int create_list_no_nodes(mylist *m)   This function should initialize an empty list. So it should be a list in every way except it should have nothing in it. The alternate is to make a list starting with some data:  int create_list_from_data(mylist *m, data d); // or int create_list_from_data(mylist *m, data *d);   Note that you could write the from data version first and then make the empty version by calling the from data version with no data (obviously this would have to be a check in your from data version, but you are going to check for lack of data anyway right?...)  note that it's usually much easier to help if you put more of what you have done or written so far."
C_Programming,31t869,crookedkr,1 point,Wed Apr 8 00:50:38 2015 UTC,how do I type my code so it looks formatted like yours?
C_Programming,31t869,crookedkr,2,Wed Apr 8 01:07:31 2015 UTC,"click formatting help for the details but blank line, 4 leading spaces, blank line gives you:  this"
C_Programming,31t869,crookedkr,1 point,Wed Apr 8 01:11:38 2015 UTC,"#include <stdio.h> #include <stdlib.h> #include <string.h>    struct student  {   char firstName[20];   char lastName[20];   int PUID[10];   int age[3];   struct student *next; };  struct student *head = NULL; struct student *curr = NULL; int main() {     return 0; } struct create_list_no_nodes() { root = (struct student *)malloc(sizeof(struct node)); root -> next = 0; }    struct create_list_node(char fName, char lName, int id, int ages) {   printf(""creating list with headnode as [%d]\n"",PUID);   struct student *ptr = (struct student*)malloc(sizeof(struct student));   if(NULL ==ptr)   {     printf(""\n node creation failed \n"");     return NULL;   }   ptr -> fname = firstName;   ptr ->lName = lastName;   ptr ->id = PUID;   ptr ->ages = age;   ptr ->next = NULL;    head = curr = ptr;   return ptr; }"
C_Programming,31t869,crookedkr,3,Wed Apr 8 01:31:54 2015 UTC,"A number of code things then a suggestion. 1) Don't caste malloc calls, it doesn't help anything and can cause problems. 2) What is root? It's not defined nor passed into create_list_no_nodes 3) struct is not a valid return type.  Based on the errors you have i think you could get some syntax help from the compiler. So you should get your code to compile cleanly using:  gcc -W -Wall -Werror --pedantic   also add -g -ggdb -O0 if you want to learn how to use the debugger.  I generally think that data structure assignments are easiest to do in a test based approach. FIrst write a statement that you want your list to support (it can be in main) and tests for pre and post conditions. For example your create_list_no_nodes should return a pointer to a node. If it doesn't fix it before moving forward. Next write another statement, maybe one that adds data to the list. Did the pointer to the head of the list change? should it?"
C_Programming,31t0dl,cas_999,2,Tue Apr 7 22:52:35 2015 UTC,"You getc something into d, but instead of calling ungetc with d when you fail, you ungetc with nc, which was set to 0, and that basically skips the character.  --- maxmunch.c  2015-04-07 17:43:52.349348000 -0700 +++ maxmunch.c~ 2015-04-07 17:43:33.838312000 -0700 @@ -81,7 +81,7 @@                 printf(""%c"", d);             } while (1);             printf(""\t simple numeral \n""); -           ungetc(nc, src); +           ungetc(d, src);         } else if (isalpha(c)) {             int ch;             printf(""\t %c"", c);   BTW, if you're using gcc and gdb, you can compile with gcc -g option and step through your code with gdb."
C_Programming,31t0dl,Nirenjan,2,Wed Apr 8 00:45:48 2015 UTC,"Thank you so much.  I guess that was my only problem because I changed that and it works perfectly now.  And thanks for the tip, I'm still pretty of new to this stuff so little tips like this help a lot."
C_Programming,31t9l5,Pale_Grey,1 point,Wed Apr 8 00:02:49 2015 UTC,What part is confusing? What have you tried?
C_Programming,31t9l5,crookedkr,1 point,Wed Apr 8 01:18:52 2015 UTC,a loop that counts how many adjacent token strings are equal to each other.   I haven't been able to think of a way to loop and count the sorted file. I have thought about if and else loops that would increment a count if the the next word is equal to it but I haven't been able to construct a proper way that works
C_Programming,31t9l5,crookedkr,6,Wed Apr 8 01:24:37 2015 UTC,"if/else isn't a loop it's a conditional. You need a loop: for or while for example. The you are going to read a word, if the previous word is the same increment the count, if it's different start a new counter at 1, if it's the end of the file you are done."
C_Programming,31t9l5,jdonniver,2,Wed Apr 8 01:31:07 2015 UTC,"Take it one step at a time.  How do you make a loop in C?  How do you compare two strings to see if they're equal?  How might you save the previous value to compare it to the current one?  Where might  you store the counts?  If you don't know how to do it in C, do it in psuecode. Write your own English language description of each step of the problem, and the code will then be very easy to implement in any language. Learning to program is about learning to think."
C_Programming,31q5s3,trolluen_work,6,Tue Apr 7 07:57:36 2015 UTC,"If you added a question to your post, I could try to answer it. Threading is highly platform specific, so it helps if you specify what platform you are working on."
C_Programming,31q5s3,FUZxxl,2,Tue Apr 7 11:00:43 2015 UTC,"I am sorry, i am using Windows 7, working in Visual Studio 2008(not that it matters).  I want some form of validation of my design, of some sorts... at least my approach to threads in this case. At this point i'm having problems with the actual syntax of threads, how to create and how/where to tell them to start. I did have some brief encounters with threads but in Java. It's quite overwhelming for me right now, guess i'm looking for a place to start...  A direct question for starters would be : How do i connect 2 independent process ? And how can i make another process change a variable in my current process ? Note that i do have access to the source code of both processes. Another one, a bit more vague, would be : How do i create/stop/join/syncronize threads in C ? Syntax and philosophy. Do i make separate source files for each thread functionality and import them in the main one ?   As a side note i decided to use the main thread as the listener, since i already have an infinite loop there, and will wait for an event there."
C_Programming,31q5s3,raevnos,1 point,Tue Apr 7 11:21:36 2015 UTC,"In C11 (which your compiler obviously doesn't support), this is the preferred thread API. Otherwise, it's OS dependent. pthreads on Linux and Unix. Something else on Windows."
C_Programming,31q5s3,snops,2,Tue Apr 7 15:39:31 2015 UTC,"You can use C11 Threads on Windows with TinyCThread. Its only 2 files, so pretty easy to add."
C_Programming,31q5s3,FUZxxl,1 point,Tue Apr 7 18:51:42 2015 UTC,"I suggest against using C11 threads. They are not widely supported and their interaction with other threading systems is unspecified. If you want to use a portable threading API, use pthreads. C11 threads are mostly a subset of pthreads except for some behaviour that is unspecified for C11 threads and some small differences."
C_Programming,31q5s3,FUZxxl,1 point,Tue Apr 7 20:48:05 2015 UTC,"I agree. C++11 threads have worked, limitedly, for me, but C11, no not really.  Or is it C++14? Can't recall off the top of my head."
C_Programming,31q5s3,FUZxxl,1 point,Wed Apr 8 13:53:32 2015 UTC,"I'm sorry, I'm not familiar with C programming on Windows and the Windows threading model. I hope someone else can help you. Also, it's spelled “syntax” in English (sorry)."
C_Programming,31q5s3,FUZxxl,2,Tue Apr 7 11:59:47 2015 UTC,"No reason to be sorry, point taken. I edited it out. Thanks for the effort and time.  But a general opinion of my proposed solution for my problem ... Do you think the actual design could work ? If no what should i look out for ?"
C_Programming,31q5s3,errorseven,3,Tue Apr 7 12:13:56 2015 UTC,"I would try to see if there is a way for the database to inform you about changes; this is better than repeatedly polling the database. I'm not sure what inter-process communication mechanisms are available on Windows, but on Unix I would use a select call to wait until either five seconds have elapsed or the database tells me something happened. No multi-threading needed.  You don't want to communicate via variables, as you can't read the content of variables while you are sleeping. On Unix, you can send a signal to a thread to interrupt (and therefore, prematurely terminate) its sleep. I think a similar thing is possible on Windows if you want / need to go for a multi-threaded solution.   And how can i make another process change a variable in my current process?   You can use shared memory to do this, but it's not what you want to do (see above).   Do I make separate source files for each thread functionality and import them in the main one?   C doesn't care about how your source code is laid out over multiple source code forms. You can put all the code into one source code form or split it up as you like. There are no constraints like in Java about how source code must be distributed over files."
C_Programming,31q5s3,jdonniver,2,Tue Apr 7 12:27:12 2015 UTC,"Thing is it's not really a proper database. So i can't use any of the traditional methods of communication. If it makes it easier to understand it's more like a CSV file. Where i open the file and read from it, maybe write.    as you can't read the content of variables while you are sleeping   This is actually a problem I am having, this is why i was opting for an independent thread that i can kill and restart. If there is a way to terminate a Threads sleep, that might prove most useful, sadly i haven't found anything specific (yet) for windows.     Thank you so much for the input. Every bit helps."
C_Programming,31q5s3,Chooquaeno,1 point,Tue Apr 7 12:38:17 2015 UTC,"I think there is an API in Windows to notify you when the content of a file changes. If Windows provides something similar to select, you can do this in one thread: Wait until either the file changes or five seconds elapsed. Notice though that you might run into problems if the program that modifies your file isn't done by the time you do your stuff. CSV files aren't suitable for this kind of operation."
C_Programming,31q5s3,raevnos,1 point,Tue Apr 7 12:56:32 2015 UTC,"Years ago, I wrote a program that monitored files being semi-actively written to by another app in Windows. I don't have a solution for you in C but I can perhaps give you some insight on how you will be able to achieve what you trying.   Every file in windows has three time stamped properties: Created, Modified, Accessed. Unfortunately these are not very reliable as Quoted from MSDN GetFileTime Function in C++:   Not all file systems can record creation and last access times and not all file systems record them in the same  manner. For example, on FAT, create time has a resolution of 10 milliseconds, write time has a resolution of 2 seconds, and access time has a resolution of 1 day (really, the access date). Therefore, the GetFileTime function may not return the same file time information set using the SetFileTime function. NTFS delays updates to the last access time for a file by up to one hour after the last access. NTFS also permits last access time updates to be disabled. Last access time is not updated on NTFS volumes by default.   The most reliable of the three properties is going to be the Modified, I found the Access time is just utterly useless. But, as you read in the MSDN the Modified value can be delayed up to 2 seconds, so for faster reading on whether the file has changed, you should also check and compare Filesize and I would strongly consider performing an MD5 Checksum. http://rosettacode.org/wiki/MD5#C   To save the work while allowing for new changes from 3rd party application, I wrote a function that would copy the newly modified file, edit it, delete/copy over the original. This allowed for more error checking, if the file was being accessed/modified I wouldn't be able to write over it, allowing me to discard the changes made from the copy and start the process over again, or use the information in the copy and modify both files. Hope this gives you a better idea of what you are up against."
C_Programming,31q5s3,matjam,1 point,Tue Apr 7 17:05:40 2015 UTC,"There are a few ways you could accomplish this. You could use a mutex or a semaphore to signal your thread after the write operation has completed, or you could use someting like WaitForMultipleEvents with a timeout to see if the file becomes readable. You could also use a shared memory area with mutexes instead of a file.  Your search terms (lots to read!) are: mutex, semaphore, and inter process communication. You might want to look at pipes as well."
C_Programming,31p6ba,secretstamos,7,Tue Apr 7 01:39:37 2015 UTC,"Don't delete the post, even if fixed.  It could prove to be useful for someone in the future!"
C_Programming,31p6ba,khalki,2,Tue Apr 7 07:26:29 2015 UTC,"This might be the result of ""homework paranoia"".  Dude posts homework in a forum.  Gets help, homework solved.  Deletes post so strict instructor won't accuse cheating.  -- Or, to prevent other classmates from gleaning the same solution from his 'work' (of posting).  It would be stupid to say that's for sure what happened here, but...it would also be stupid to say this never happens."
C_Programming,31p6ba,zenkibudo,2,Wed Apr 8 03:05:43 2015 UTC,Please do not remove the problem description when you solved the problem! It might be helpful for others in the future.
C_Programming,31p6ba,degner,1 point,Tue Apr 7 10:10:18 2015 UTC,"Without seeing the caller, 2 things look fishy. First, your for loops should be strictly less than size, not less than or equal to. Second, even after fixing that, your nextPtr will be pointing off the end of the array."
C_Programming,31p6ba,frozenbobo,-1,Tue Apr 7 02:15:48 2015 UTC,"I think you might be right, nextPtr going out of bounds is the probable cause. I'm trying to think of a way to fix it."
C_Programming,31p6ba,raevnos,-1,Tue Apr 7 02:31:45 2015 UTC,"I've managed to cut down the error by half (by removing the equals signs). Currently, I'm only getting one absurd number.  In all the sets I've tested, it seems to be replacing the largest number in the array. For instance, in an array where the largest element is 7, I am getting -1075409764 in the place of 7."
C_Programming,31j3gz,Dijkstra112358,12,Sun Apr 5 16:12:46 2015 UTC,Please do not suffix your own types with _t. The suffix _t is reversed for system types by POSIX. Using it in your own headers might cause conflicts with future POSIX revisions. You don't want to have conflicts with POSIX.
C_Programming,31j3gz,FUZxxl,9,Sun Apr 5 16:38:48 2015 UTC,(s/reversed/reserved/)
C_Programming,31j3gz,demyze,4,Sun Apr 5 17:20:38 2015 UTC,Oops...
C_Programming,31j3gz,FUZxxl,4,Sun Apr 5 17:26:43 2015 UTC,"Is there a common standard other than _t that I should be using? I had not heard of this before, but I dont do much posix targeted work in C."
C_Programming,31j3gz,jahmez,3,Mon Apr 6 05:23:15 2015 UTC,Have a look at this page from POSIX where all the reserved names are listed.
C_Programming,31j3gz,FUZxxl,5,Mon Apr 6 11:20:54 2015 UTC,"I was thinking there was something about the _t, some rule I was forgetting. I'll work on renaming. Thanks!"
C_Programming,31j3gz,geocar,4,Sun Apr 5 17:54:13 2015 UTC,"Some architectures don't allow unaligned loads/saves or if they do it's very slow. Using unsigned long as the size for your cell will be significantly faster everywhere.  That said, I think you should consider what you're actually trying to accomplish: Arithmetic shouldn't look strange to you; just setting a bit is easy:  #define N (sizeof(unsigned long)/8) b[a/N]|=1<<a%N;   The kinds of things where we work with ""big bit arrays"" like bloom filters and (better) stamp hashing don't become more clear with a bunch of bit_array_set_bit(a,b) statements, and contrary to popular belief: Compilers aren't that smart.  If you'll take it I'll offer you further advice: Don't write code that you don't need right now. Chances are you won't need it at all, and if you do something about that need might cause you to write it differently: If I'm going to allocate a 512mb array to use as a bit field for IP addresses, I'm not going to error check between each store."
C_Programming,31j3gz,geocar,1 point,Sun Apr 5 21:25:08 2015 UTC,"I have researched a few  bit arithmetic implementations (Boost, STL, etc.). I realized that I am not gaining much efficiency out of single bit-field setting clearing, but it is still a fundamental piece of each of the libraries. Thank you for the don't write extraneous code tidbit, It definitely makes sense. The fxn's I'm working on currently are string/file to/from bit-field modifiers. I feel those along with bitwise operators and shifts and rotates are the biggest point of my code."
C_Programming,31j3gz,rpi-user,2,Mon Apr 6 00:52:28 2015 UTC,"I think you should rethink whatever causes you to have a bit string made out of ascii 0's and 1's like your bit_array_read_string() reads. Binary files are better in almost every way: You can use mmap() which is pretty portable (and it's fairly easy to implement on Win32 if that's your thing) to demand page your bit array, and simultaneously halve the real memory usage since you only have one copy in memory; i.e. you don't read from the disk into the block cache, and then copy it from the block cache into your program.  If you still really want a textual representation, a table-driven reader will be much faster, and it'll save you a buffered copy in your bit_array_read_file().  Also: You might want to read Notation as a Tool of Thought. I think the value of the Boost and STL bitset is the notation and not the code; that is that you can actually write:  b[a]=1;   and not that someone wrote it for you.  Happy hacking."
C_Programming,31j3gz,DSMan195276,2,Mon Apr 6 20:20:25 2015 UTC,Some older threads you may find of inherest:   http://www.reddit.com/r/C_Programming/comments/v15es/what_is_the_best_way_to_efficiently_pack_bits/ http://www.reddit.com/r/C_Programming/comments/1cp6ak/bit_fields_game_programming_articles_gamedevnet/ http://www.reddit.com/r/C_Programming/comments/1sjeol/bitfields_of_arbitrary_length/
C_Programming,31j3gz,cunttard,2,Sun Apr 5 23:45:56 2015 UTC,"I wrote my own bits.h header specifically for bit manipulation, I think it's pretty effective.  Though somewhat less useful, the 'b8', 'b16', and 'b32' macros allow for 'binary literals', Like the GNU C '0b01010101', you can use 'b8(01010101)' to get that binary value in an 'unsigned char'. Similar ally, you can use 'b16(10101010, 01010101)', where the first set of 8 is the high 8-bits, and the second set is the low 8-bits. 'b32' works the same, but with 4 fields. A 'b64' would be easy to also implement, but I have yet to encounter a use for such a thing and it'd be annoying to write and use with so many fields.  The main part of this header is the 'bit_get' and 'bit_set' macros, which take a 'bitmap', a bit number, and either set that bit in the bitmap to that specific value, or return the value of the bit at that location. The 'bitmap' is an array of any integer type you want (unsigned char, int, long, etc.).  The 'bit_per_entry' macro uses 'sizeof' plus the value of 'CHAR_BIT' (Which is usually '8') to calculate the number of bits in one array entry of the 'bitmap'. So, 'bit_per_entry' would return 32 for an uint32_t array, 8 for a uint8_t array, etc.  The 'bit_get' macro just uses the 'bit_per_entry' to calculate which array entry the bit you want to set is located inside of (Via a division, though of course, since 'bit_per_entry' is basically guaranteed to give a power of two, this will become a simple shift). The bit location inside of that array entry is calculated using '%' with the same values (bit number and 'bit_per_entry'), and then a '1' value is shifted by that number, resulting in a '1' bit at the bit location you want. Then it's just a simple '&' to return the bit. Of course, the return is based on the bit location, returning the value of that specific bit if it's set.  The 'bit_set' macro is a bit more complex. It uses an 'if' statement to decide whether it's going to clear or set the bit, and then (using the same logic as above to figure out where the bit is in the bitmap) either 'or's the correct bit into the bitmap, or uses a 'nor' to clear the bit ('Nor'ing leaves every bit alone in our bitmap except for bits set to '1' in our value, which will only be the bit we want to clear).  Because it works on arrays of integers, it can handle any number of bits you want. You have to make sure there's actually memory backing those bits though, of course."
C_Programming,31j3gz,jaccovanschaik,2,Mon Apr 6 01:36:53 2015 UTC,was wondering how y'all build your solutions to bitlengths larger than 64   These days I'd steal from ccan.
C_Programming,31ktw1,princessJJ,1 point,Mon Apr 6 01:11:04 2015 UTC,"I do tend to over comment, I am always afraid the professors will say something if I don't explain each step."
C_Programming,31ktw1,_jho,1 point,Mon Apr 6 03:28:21 2015 UTC,I'd argue that the comments are fine. Better comments will come with experience. And it's always good to encourage more comments.   (edit) Also when first learning this stuff it's useful to have these extra comments so you can use it as a reference and have your comments explain how the code works to you.
C_Programming,31ktw1,f5f5f5f5f5f5f5f5f5f5,1 point,Mon Apr 6 14:09:45 2015 UTC,"EDIT: I took your advice, I removed some comments and improved others, but most importantly I change it all from if's to two switch statements and a function call, it all runs smoothly now. Thank you for advice:)"
C_Programming,31ktw1,_jho,1 point,Mon Apr 6 09:08:01 2015 UTC,You're mixing normal and Egyptian brace styles. Be consistent. Count your braces. Add one for { and subtract 1 for }. The sum must be 0.  You should define an enumerated type with the characters you are looking for instead of pointers to null terminated character arrays and use a switch instead of a long if/else chain. It goes a long way in preventing the errors you have.
C_Programming,31ktw1,f5f5f5f5f5f5f5f5f5f5,0,Tue Apr 7 00:48:33 2015 UTC,"Null terminated character arrays   Strings  That being said,  an enum type would probably add undue complexity.   However I agree with your thing about switch statements. Maybe a function that contains the switch could be used?"
C_Programming,31ktw1,cunttard,2,Mon Apr 6 02:37:39 2015 UTC,"Enumerated types are very useful for managing complexity. A misspelled enumerator is much more likely to be caught by the compiler than an incorrect literally.   You can use enums to replace magic numbers with symbols that provide meaning to the reader, especially if the literal value is arbitrary.   Because enumerators are integral types, you can use them in switches. You can add cases for each constant.  Enumerator definitions are evaluated at compile time."
C_Programming,31fpcf,pusic007,2,Sat Apr 4 17:23:24 2015 UTC,"Queries will still be executed on server side. So query execution performance doesn't depend on the language you use to call for it.  Perhaps the C version will be slightly faster iterating the results of a query, but that's because of the nature of both languages.  I've used both, but currently I'm using the Go approach with the native third party driver. Mostly because the database/sql package in Go is the one in charge to open and close SQL connections.   This might help you"
C_Programming,31fpcf,simonorono,2,Sat Apr 4 18:13:40 2015 UTC,"There is a difference - in go there is cgo call overhead which is about  ~160ns on 1.4.1 and ~48ns on 1.3.3; there is a recent perf. drop in recent versions due to moving to Go as the runtime... it will probably go back to ~30ns eventually. See issue 9704. Plus, there might be some additional performance loss in driver interface, sql package etc.  Whether 30-160ns matters depends on the application. If it matters in Go, you can reduce the number of calls you make to C by batching. But, most likely some other operation will dominate the performance, e.g. disk IO.  tl;dr; Do you get a performance win = yes; does it matter in the real world = it depends and most likely not."
C_Programming,31fpcf,egonelbre,1 point,Mon Apr 6 06:16:53 2015 UTC,"The actual driver interface is likely the last thing you should be starting to suspect for performance degradation as it is just slinging bits from some interface into memory for you to access. If you are truly concerned measure, measure, measure. This is doubly important if you are calling over the wire and not locally because you need to accommodate measurements of network latency. DBMS's also need to be tuned and a lot of the defaults that ship with them are bad- did you change the buffer pools for postgres? Are you in IO, CPU or memory pressure on your system? Are your queries properly indexed?  In pretty much every circumstance the priority of 'is my sql driver fast' is near the bottom because all of the hard work that would take time is either on the DBMS side or in the application side- the sql driver is basically just a transport layer like TCP (to an extent)."
C_Programming,31fpcf,akmark,1 point,Sat Apr 4 18:24:16 2015 UTC,"Under production circumstances you'd utilize the power of the SQL database and not just utilize it as a dummy memory cache. A Pl/PGSQL function or in any of the other plugin languages you'd do the iteration and updating on server itself, potentially the biggest performance benefit you can hope to receive. Table design and proper offloading to server is in almost always A-X of performance, only Y-Z can be improved on the client software."
C_Programming,31dd3q,NotDescartes,9,Sat Apr 4 00:21:12 2015 UTC,"FYI, ""symmetric"" does not mean what you think it means. What you mean is the word ""square."" Transposing a symmetric matrix is trivial—a symmetric matrix is equal to its transpose, so you don't have to do anything at all to transpose a symmetric matrix."
C_Programming,31dd3q,zifyoip,2,Sat Apr 4 13:47:40 2015 UTC,"Symmetric matrix:       In linear algebra, a symmetric matrix is a square matrix that is equal to its transpose. Formally, matrix A is symmetric if     Because equal matrices have equal dimensions, only square matrices can be symmetric.     Interesting: Skew-symmetric matrix | Pfaffian | Quadratic form   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,31dd3q,autowikibot,4,Sat Apr 4 13:47:53 2015 UTC,"Think how you would iterate through a matrix column by column; then row by row. If you do one way from the source, and the other way into the destination, you have a transpose:  static void transpose( const int * restrict src, int * restrict dst, int w, int h ) {     for( int y=0; y<h; y++ )     for( int x=0; x<w; x++ )         dst[x*h+y] = src[y*w+x]; }  int main( void ) {     int dmat[6];     int smat[6] = {         1, 2,         3, 4,         5, 6,     };      transpose( smat, dmat, 2, 3 );      printf( ""%d %d %d\n"", dmat[0], dmat[1], dmat[2]  );     printf( ""%d %d %d\n"", dmat[3], dmat[4], dmat[5]  ); }   The ""restrict"" is C99, and means that you can't transpose a matrix into itself - the function clobbers values in the destination matrix anyway."
C_Programming,31dd3q,Aransentin,2,Sat Apr 4 00:51:35 2015 UTC,"Thank you for your response. Sadly, I am trying to do it without the built-in transpose function. the functions in the original code are essentially the only functions I can use (this is homework but i have no idea how to get past this point)."
C_Programming,31dd3q,Fylwind,4,Sat Apr 4 01:34:50 2015 UTC,transpose is not a built-in function.
C_Programming,31dd3q,el_micha,2,Sat Apr 4 02:03:57 2015 UTC,"oh ok. Sorry I'm really low level. Thank you though. Upon looking more in-depth, you have helped me solve it. Thank you man!"
C_Programming,31dd3q,FUZxxl,1 point,Sat Apr 4 02:09:24 2015 UTC,You could also do the same in just one for-loop:  for(int i = 0; i < rows*cols; i++)         {             mat2[i%rows][i/cols] = mat1[i/cols][i%rows];         }
C_Programming,31dd3q,el_micha,2,Sat Apr 4 11:28:46 2015 UTC,"hey, thank you for doing the homework of /u/NotDescartes. Now he surely learns something."
C_Programming,31dd3q,FUZxxl,1 point,Sat Apr 4 15:32:31 2015 UTC,"You think his homework consists of 2 lines of code? I doubt it.   If he studies my solution he will indeed learn something. Namely that the problem of matrix transposition could be solved by adressing the original matrix in a slightly different way, without actually copying data around.   Next time, before you review the comments of others, you could provide a better one."
C_Programming,319lz1,ThrowawayTartan,4,Fri Apr 3 02:26:44 2015 UTC,Have a look at the Ceil function in the math library. Round the float up to the nearest Int seems best for you
C_Programming,319lz1,_5__,1 point,Fri Apr 3 02:33:21 2015 UTC,Thank you! I'm such a derp I should have remembered it.
C_Programming,319lz1,crookedkr,2,Fri Apr 3 02:45:02 2015 UTC,"Are you just looking for the next higher power of 2? Assuming that you guard against the user passing negative values or the like you could do something like:  unsigned next_pow2(unsigned x){     --x;     x |= x >> 1;     x |= x >> 2;     x |= x >> 4;     x |= x >> 8;     x |= x >> 16;     ++x;      return x; }   If they can pass you floats you will need to fix that but this should give you the next power. If you for some reason need the offest of the set bit to index into some other array, have a look into intrinsics on your system for finding the number of leading zeros which should give you the set bit's position.   You said this is part of a larger project. If you are going for speed there is no reason to worry about any of this unless you know it's your bottle next so first profile your program before you get all crazy with bit twiddling."
C_Programming,319lz1,DSMan195276,1 point,Fri Apr 3 03:20:53 2015 UTC,"If you're looking for speed, you're probably better off avoiding floating point. Really, all you need to do is find the location of the highest bit in your value. If your value isn't a power of two, then the bit location after the one with the highest bit is your log2 of that number, rounded to a power of two. If it is a power of two, then that location is your log2 of the number.  Ex. Take 6 for example:  6 in binary: 00000110 Highest bit location: 2 (The last bit location with a '1') Is the value a power of two? No Log2 of value rounded: Highest bit location + 1 = 2 + 1 = 3   And 2:  2 in binary: 00000010 Highest bit location: 1 Is the value a power of two? Yes Log2 of the value rounded: Highest bit location = 1"
C_Programming,319454,warriorkitty0,3,Thu Apr 2 23:54:03 2015 UTC,I wouldn't spend money on programming certifications unless it's some checkbox required for a big company job.  Do you have any formal training? Associates/bachelors?
C_Programming,319454,GodOfCode,1 point,Fri Apr 3 01:37:46 2015 UTC,"Thank you for your answer. I'm almost done with college, and have a few years experience (I've started working right after high school). I would say that I ""know"" C, at least I know C at the college level where I was very successful in that field.  I was thinking, since I already know a lot about C, why wouldn't I try and schedule the exam for certification, I mean, I don't have anything to lose (except 295$ :D). Specially after solving all exams on C++ institute over 90%. When I got there, questions weren't easy. Not at all. I needed 17% more to pass."
C_Programming,319454,bames53,3,Fri Apr 3 21:05:54 2015 UTC,"This isn't an answer to your question, but rather just a comment on certification. This sort of certification is really not something that employers in this industry look for. If you learn things while studying for the exam that's great, and that would do more good in an interview than having one of these certifications as a line on your résumé.  If you want something impressive for a résumé as well as some good material to talk about in an interview, find a good open source project that you can contribute to in some significant way. If you just want to learn then I would recommend simply spending a lot of time writing programs, and in particular getting constructive advice on your programs from more experienced programmers. Contributing to an open source project is a great way to ensure that people will want to help you, because when you make good contributions, a project they care about gets better. Contributing to a well run open source project also means you'll learn about some other software development practices which is also useful."
C_Programming,319454,bames53,1 point,Fri Apr 3 01:55:24 2015 UTC,Thank you very much for your answer. I highly appreciate it. What open source projects you find interesting and would like to suggest?
C_Programming,318lfy,Kwbmm,5,Thu Apr 2 21:28:53 2015 UTC,"I haven't gone through the code in detail, but the close(fd); immediately after you mmap is wrong. Keep your file descriptor open until you munmap."
C_Programming,318lfy,OlderThanGif,1 point,Thu Apr 2 21:33:08 2015 UTC,"This, unfortunately, doesn't solve the issue:  .... len = stat_buf.st_size; n = len / sizeof(int); //This is number is wrong!! printf(""%d\n\n"",n); paddr = mmap(NULL,len,PROT_READ | PROT_WRITE,MAP_SHARED,fd,0); if (paddr == MAP_FAILED)   perror (""mmap""); vet = paddr; for(i=0; i < n;i++)   printf(""%d\t"",vet[i]); //Prints rubbish printf(""\n""); close(fd); ....   The output is:  941634360 540221492 540291872 540162080 540225824 540162336 540160800 540225824 540095008 540094752 540226080 540422688 840970292 842473526 540422944 908079409 926294072 540619296 857748024 842407984 859185209 857749302 909647926 840970784 840970801 540620320 540619552 909451315 891301945 840970804 859250745 540488224 924856374 926097460 540555552 824194098 808919093 842407985 840972596 808984625 540423456 908079927 808919090 540424480 891302200 540357152 840971320 909320247 874525984 891302197 909647925 840972085 892936244 857748281 824194356 926294068 540356896 874525750 808788019 540489760 909582392 540555040 540293408 941635640 959586358 960045108 958412338 941635889 943071286 958412598 943005746 959586357 926359606"
C_Programming,318lfy,DownloadReddit,2,Fri Apr 3 09:39:04 2015 UTC,"You start a thread, lets call it A  Your main waits for A to exit.  A does something and starts two more threads B and C  A now exits  B and C are messing with the data at the same time as main is printing data.  Edit: The issue is that you write the numbers to the file in ASCII format (that is human-readable). In the second program you print them out in binary format (That is 4-bytes per int).  mmap is usually used on a binary format, so I would modify the first program to output numbers in binary instead of ascii."
C_Programming,318lfy,DownloadReddit,1 point,Thu Apr 2 22:08:18 2015 UTC,"Here is a program that takes your input file (in.txt) and converts it to a binary number file (bin.txt)  #include <stdio.h> int main(){         FILE* in = fopen(""in.txt"", ""r"");         FILE* out = fopen(""bin.txt"", ""wb"");         int number;         while(fscanf(in, ""%d"", &number) != EOF)                 fwrite(&number, sizeof(int), 1, out);         fclose(out);         fclose(in); }"
C_Programming,317ghm,proboardslolv3,1 point,Thu Apr 2 16:26:58 2015 UTC,"Your post got caught in our spam filter. I approved it now, it was invisible before."
C_Programming,317ghm,FUZxxl,1 point,Sat Apr 4 17:15:45 2015 UTC,Why thank you! Any reason? (so I can avoid in the future)?
C_Programming,317ghm,FUZxxl,1 point,Sat Apr 4 19:18:29 2015 UTC,I have no idea why that happened.
C_Programming,317ghm,FUZxxl,1 point,Sat Apr 4 19:44:52 2015 UTC,Do not use scanf in this case! scanf is strictly for text input. Use a different function for that. I'm not sure what the content of /dev/input/js0 looks like so I can't give you more detailed information.
C_Programming,317ghm,zifyoip,1 point,Sat Apr 4 17:18:38 2015 UTC,"Oh scanf was for a different thing. Im using read() with the Linux joystick API, which defines a struct called js_event"
C_Programming,313a6c,vazoy,10,Wed Apr 1 18:32:18 2015 UTC,"If you look at the man page for fopen, you'll see all the options provided.  http://man7.org/linux/man-pages/man3/fopen.3.html  If you open with the ""w"" mode, it will truncate your file to 0 size before starting.  You should be able to accomplish what you want with the ""a+"" ""r+"" mode and fseek()  EDIT: See response below"
C_Programming,313a6c,dragon_wrangler,7,Wed Apr 1 18:47:39 2015 UTC,fseek is meaningless with respect to writing when the file has been opened in append mode as all writes go to the end of the file. I think you might want to open the file with r+ instead of a+.
C_Programming,313a6c,FUZxxl,3,Thu Apr 2 00:35:51 2015 UTC,"You are, of course, correct."
C_Programming,313a6c,dragon_wrangler,2,Thu Apr 2 00:50:37 2015 UTC,"Even in an appropriate file open mode, you can seek to the 10th character, and write, but you will overwrite everything after the 10th character with the new data, and for the length off bytes written.    In file writing, there is no insert vs overwrite mode like you get when you tap the INSERT key on most any editor -- and it seems this is the process you are after.  To accomplish same in file writing, there a few ways to get it, but the most straightforward way may be with a temp file:   Open your source file with read permission Open/create a temp file with read/write permission Read everything from source file up to 10th char to a buffer Write that buffer to the temp file. Write the text you want to 'insert' from a buffer to the temp file Read all remaining data from source file to a buffer Write that buffer to the temp file. Close and delete the source file Close and rename the temp file to the old source file name.   Text editors that allow insert (vs. over write) are actually doing something like this, but purely in system memory, until you commit the write by invoking the 'save' function.  Later, as experience grows, you may wish to accomplish the same in some more elegant way, such as:     Open your source file read/write permission    Read everything from source file to a buffer   Insert your desired text into the buffer using memmove() and then strcpy() / memcpy()     seek to start of source file   Write the whole buffer to the source file, close.     ...and this 2nd method is how most text editors do the deed."
C_Programming,313a6c,zenCbot,1 point,Fri Apr 3 06:28:00 2015 UTC,...and this 2nd method is how most text editors do the deed.   Not really as this method leads to corruption when the editor crashes in the process. Most editors actually work like this:   Open your source file read/write permission Read everything from source file to a buffer Insert your desired text into the buffer using memmove() and then strcpy() / memcpy() Create a file on the same file system as the file to edit Write the whole buffer to that file Optionally call fsync() on the temporary file Rename the temporary file into the name of the file you edit   This method ensures that “save” is an atomic operation that doesn't lead to corruption if the system crashes
C_Programming,3130d9,GBGamer117,7,Wed Apr 1 17:38:27 2015 UTC,"attempt to write to a position past the end of the file.  You should ftuncate(fd, 4096) first.  If the file existed and had at least 1 byte in it and you weren't using O_TRUNC, this would have worked.  Also, MAP_FAILED should be preferred in place of -1 for the return of mmap. A call to msync should also be used when dealing with maps to files after operations."
C_Programming,3130d9,cQuaid,2,Wed Apr 1 18:00:21 2015 UTC,Thank you! You can see I don't do very much file I/O :)
C_Programming,3130d9,cQuaid,2,Wed Apr 1 18:50:44 2015 UTC,"Well, mmap is a bit weird really.  The man pages really come in handy when programming on linux. When using new functions it may be worth reading through the relevant pages (edge cases and errors particularly)."
C_Programming,312xf2,a_soy_milkshake,2,Wed Apr 1 17:21:59 2015 UTC,"Can I store a pointer to my unique object in say, myArray[2][4]?   Yes, you can. Just write myArray[2][4] = ptrToObject, assuming that myArray has the correct type. If the dimensions of myArray aren't known at compile time, you might want to use a one-dimensional array that is large enough and do index-computations manually.  If you are short on memory, you might want to consider saving a structure with an index into an object array in each location of the array instead of a pointer. If you use bitfields, you might be able to get a structure compromising an index into the object array and the objects attributes down to two bytes.  It is hard for me to answer this question without having further information about your problem."
C_Programming,312xf2,FUZxxl,2,Thu Apr 2 00:42:31 2015 UTC,"This is more of a design problem than a C problem.   You can design a 2D array as a pointer to a pointer to a pointer to a structure, where the structure contains a combination of relevant types and pointers. As you can see, this design can start being cumbersome quickly if you are not careful.  But if you have an embedded system, you may not be able to afford to allocate memory for so many grid locations that contain no information (or duplicate information). You may want to think about how you can design it so that you allocate only memory that you use."
C_Programming,312xf2,f5f5f5f5f5f5f5f5f5f5,2,Thu Apr 2 12:45:14 2015 UTC,"I've been thinking about it and I think I understand the cumbersome way to do it with 2D arrays, but I'm not sure if it will be possible on an embedded platform; I'll need to do some calculations. Conceptually using only memory I allocate makes the problem much harder."
C_Programming,312xf2,f5f5f5f5f5f5f5f5f5f5,2,Thu Apr 2 16:10:11 2015 UTC,"Think about it this way: if you loop through the grid, you have to access a bunch of variables that you have to check to see if you want to use only to ignore many of them.  You can use a different approach where you only think about the grid when you need to. For instance, you can iterate over your structures and do all of your processing. You can store your coordinates as members and process them once you've done everything else."
C_Programming,312xf2,f5f5f5f5f5f5f5f5f5f5,1 point,Thu Apr 2 16:37:02 2015 UTC,"I understand the benefits, but I'm having an issue seeing how exactly to implement it. If I have a static 2D grid that represents my field, I have a lot of unutilized empty space, but that was how I envisioned detecting collisions between objects (aliens and player, bullets, and aliens, etc...).   I don't quite understand your last paragraph. I know there's a way, but I don't see how I can detect collisions etc... if I'm not referencing them to some 2D structure. Sorry I'm having trouble wrapping my head around this, let me know if I need to clarify the source of my confusion."
C_Programming,312xf2,f5f5f5f5f5f5f5f5f5f5,1 point,Thu Apr 2 17:08:14 2015 UTC,"No problem. You're already aware that collision detection is going to be a difficult problem to solve. One approach to managing a difficult problem is to isolate it from other parts of your software. This allows you to work on other parts of the program without worrying about the problem. It also allows you to substitute a better solution later without rewriting the whole thing.  The way that you are thinking about it is fairly intuitive, but it seems like it's the heart of your program. You can write it in a way that you keep a list of moving objects and their coordinates and eliminate unlikely collisions from processing or you can create a char[ ][ ] instead of the (possibly larger) *[ ][ ].  If you find that using a grid of structures works best, you can plug that in without changing the whole program.  There are a lot of possible solutions to collision detection."
C_Programming,312xf2,zenCbot,1 point,Thu Apr 2 18:56:45 2015 UTC,"Ahhh I think I understand. The intuitive way is my first intuition, where we create these objects in memory and track their movement across a 2D structure, because this is actually what is happening.   The alternative as I understand it is to, instead of keeping track of the actual location in the 2D structure, represent it with a pair of coordinates of where it would be. Do this for all my objects so that I end up with a 1D array of all the objects on my field, but I'm calculating their positions and collisions ""numerically"" instead of ""physically"" (The words in quotes may not be the proper words to describe the situation but I think they make clear what I'm saying). Thanks for your help!"
C_Programming,310ovo,Graathor,10,Wed Apr 1 04:51:02 2015 UTC,I'm guessing you're causing undefined behavior in InitializePhone caused by the way you're calling it on line 132. You don't need to multiply by sizeof(phone); that's not how pointer arithmetic works.
C_Programming,310ovo,wgunther,4,Wed Apr 1 05:02:52 2015 UTC,You surely want  fn(myPhones.phoneArr + i);   not   fn(myPhones.phoneArr + (i * sizeof(phone)));
C_Programming,310ovo,sh_,4,Wed Apr 1 05:03:06 2015 UTC,"And as it makes the code more clear, I'd prefer  fn(&myPhones.phoneArr[i]);"
C_Programming,310ovo,ratatask,4,Wed Apr 1 09:07:15 2015 UTC,"phones.phoneArr = &dynamicPhoneArray;   No.  Get rid of that ampersand, you don't need it.  It is probably the cause of your problems. edit: Also what /u/wgunther said.  You want phones.phoneArr to point to the block of memory you just allocated (i.e. be the same value as dynamicPhoneArray, not the address of dynamicPhoneArray).   char * nameBuffer = (char*)malloc(phoneLength + 1 * sizeof(char));   As written, this turns out not to be a problem because sizeof(char) is one byte anyway.  However, something like this would bite you if it were a bigger data type.  Due to the order of operations, the '1 * sizeof(char)' is evaluated first, then added to phoneLen.  What you probably intend here is (phoneLen + 1) * sizeof(char).  It doesn't hurt to make judicious use of parenthesis to get rid of any ambiguity about what gets evaluated first.  Then you do:   memcpy(nameBuffer, name, phoneLength + 1);   The ""+ 1"" in your malloc was, I assume, to make room for the null terminator.  But here, you copy phoneLength + 1 in your memcpy, and don't set a null terminator.  You should do a memcpy of just phoneLength, and then nameBuffer[phoneLength] = '\0';"
C_Programming,310ovo,eyenot,1 point,Wed Apr 1 07:53:23 2015 UTC,"Valgrind is what you would use to diagnose low-level memory issues such as these. Without it, C can be downright hellish."
C_Programming,310bjy,shoobiedoo,3,Wed Apr 1 03:00:03 2015 UTC,"a[N][N] doesn't exist (because a[N] doesn't exist), so you can't say &a[n][n] in inner_matrix when n == N."
C_Programming,310bjy,zifyoip,1 point,Thu Apr 2 00:50:24 2015 UTC,Your post got caught in our spam filter it seems. I approved it now; people weren't able to see it before.  Would you mind formatting the gdb output just like you formatted the source code?
C_Programming,310bjy,sindisil,1 point,Thu Apr 2 00:47:44 2015 UTC,"You're walking off the end of your array in the inner_matrix() function.  Once you process the cell at a[9][9] (i.e., the last valid cell in the array), p == &a[9][9]. Therefore p++ will effectively mean that p == &a[10][0], which is less than &a[10][10] (the terminal value in your predicate), and thus the loop will continue.  You could fix your loop by changing the test to ""p != &a[n-1][n-1]"", but why not just do nested loops? If you had, I dare say you wouldn't have had this problem (given that you got the loops right in main() -- though even there I would have used != rather than <)."
C_Programming,30zcy8,theknight38,2,Tue Mar 31 22:38:57 2015 UTC,What you're effectively doing is taking the log base 2 (plus one).  There's lots of ways of doing this: see this post on Stack Overflow.
C_Programming,30zcy8,boredcircuits,1 point,Tue Mar 31 22:52:31 2015 UTC,"Right. Yes I had already realised that what I'm doing is basically a log2. The linked page was a very useful reading. I was wondering if the particular input data set (basically always an integer log2) allowed for faster optimisation, since I don't actually need log2 of any number (if that makes sense)."
C_Programming,30zcy8,boredcircuits,1 point,Wed Apr 1 06:04:28 2015 UTC,"Flip the problem around and count the number of leading zeros before the single 1.  That turns it into the exact same problem.  The second answer on that page (using >) is my favorite.  Though as long as you don't mind being a bit platform-dependent, the best option is likely __builtin_ctz as has been pointed out in another reply."
C_Programming,30zcy8,angdev,3,Wed Apr 1 15:38:56 2015 UTC,"Make a 16-bit array of size 32,769. Set 1 to 1, 2 to 2, 4 to 3, 8 to 4, etc until 32768 to 15. Then simply:  int bit_location = my_array[""the uint16""];   Look-up tables are often the fastest way to solve problems. It is all a part of the CPU-Memory trade-offs. Waste memory to free up CPU cycles, or waste CPU cycles to free up memory.  Note Some CPU architectures have special CPU instructions for detecting the first or last bit's set, or how many bits are set in total. And sometimes these instructions can execute in less than 1 cycle. So using those specialized instructions would be significantly faster than any C implementation. You can check your C compiler help file to see if they support intrinsic or special macro's for using these instructions."
C_Programming,30zcy8,jotux,4,Tue Mar 31 23:04:24 2015 UTC,"It's actually a pretty funny solution to the problem.  int a[32769]={[1]=1,[2]=2,[4]=3,[8]=4,[16]=5,[32]=6,[64]=7,[128]=8,[256]=9,[512]=10,[1024]=11,[2048]=12,[4096]=13,[8192]=14,[16384]=15,[32768]=16}; main() {     int num = 0x0004;     printf(""%i"",a[num]); }"
C_Programming,30zcy8,dumsubfilter,1 point,Tue Mar 31 23:24:25 2015 UTC,"Given that there will only ever be 1 bit set, according to the rules of the question:  int isset( uint16 v ) {     switch ( v )     {         case 1: return 0; /* returning which bit is set */         case 2: return 1;         ...         default: return -1;     } }   Not a terrible version."
C_Programming,30zcy8,FUZxxl,1 point,Wed Apr 1 06:01:28 2015 UTC,"Very true. Hadn't thought of it, but it's definitely precious advise. If my math is correct that would require 64k, approximately 1/4 of my total memory, but still doable. Thanks!"
C_Programming,30zcy8,proboardslolv3,1 point,Wed Apr 1 06:01:41 2015 UTC,Don't waste that much memory! It's doable in far less without loosing a lot of speed.
C_Programming,30zcy8,jotux,1 point,Thu Apr 2 00:43:24 2015 UTC,"I might try:  #include <math.h>  int main(){          //number you're trying to get the position of the bit of     int number;          //log in math.h is natural log (ln)     printf(""%d"", log(number)/log(2)); }   where [ ] denotes base, and ( ) denotes parameter:  log[y](x) / log[y](n) = log[n](x), and since any number in binary with only a single bit will be an exponent of 2, you can easily find the number place of it by simply doing log base 2.  dont know if this is any faster since I don't know what went into the log algorithm, but this is just one potential solution"
C_Programming,30zcy8,proboardslolv3,1 point,Wed Apr 1 00:10:30 2015 UTC,"You can use    logb and get the same thing:  #include <math.h> main() {     int num = 0x0080;     printf(""%d"",(int)(logb(num) + 1)); }"
C_Programming,30zcy8,raevnos,1 point,Wed Apr 1 02:32:27 2015 UTC,"ah, haven't used much of math header"
C_Programming,30zcy8,proboardslolv3,1 point,Wed Apr 1 03:49:39 2015 UTC,Why not just use log2()?
C_Programming,30zcy8,romcgb,1 point,Wed Apr 1 08:23:30 2015 UTC,Cause I didn't know it exosted
C_Programming,30zcy8,FUZxxl,1 point,Wed Apr 1 13:24:44 2015 UTC,"To count the number of trailing zero, compilers usually have the intrisic __builtin_ctz(n) which relies on specific CPU's instructions.  eg for x86  int f(int n) {     return __builtin_ctz(n); }   compiles to  With ICC 13.0 -O3:  f(int):         bsf       eax, edi          ret   With  GCC 4.9 -O3:  f(int):     xor eax, eax     rep bsf eax, edi     ret   With Clang 3.7 -O3:  f(int):     bsf eax, edi     ret   Note that bsf is not so good on atom https://chessprogramming.wikispaces.com/BitScan#x86Timing"
C_Programming,30zcy8,FUZxxl,1 point,Wed Apr 1 06:49:27 2015 UTC,"If you are on a POSIX-compatible operating system, use ffs() from strings.h (sic! not string.h) for this as it's more portable than a compiler-specific intrinsic. Here is the corresponding page from POSIX."
C_Programming,30zcy8,romcgb,1 point,Thu Apr 2 00:37:55 2015 UTC,Any idea why gcc emits a rep prefix?
C_Programming,30zcy8,autowikibot,1 point,Thu Apr 2 00:44:10 2015 UTC,"Yes, the opcode of bsf is 0F BC while the opcode of tzcnt is F3 0F BC (rep bsf).  It's a backward compatible optimization, rep bsf is decoded into tzcnt if the cpu  has it or the rep prefix is simply ignored.  To emit tzcnt (or rep bsf) with llvm, you must specify a compatible architecture with the option -march"
C_Programming,30zcy8,tffu,1 point,Thu Apr 2 06:38:58 2015 UTC,"Bit Manipulation Instruction Sets:       Bit Manipulation Instructions Sets (BMI sets) are extensions to the x86 instruction set architecture for microprocessors from Intel and AMD. The purpose of these instruction sets is to improve the speed of bit manipulation. All the instructions in these sets are non-SIMD and operate only on general-purpose registers.  There are two sets published by Intel: BMI (here referred to as BMI1) and BMI2; they were both introduced with the Haswell microarchitecture. Another two sets were published by AMD: ABM (Advanced Bit Manipulation, which is also a subset of SSE4a implemented by Intel as part of SSE4.2 and BMI1), and TBM (Trailing Bit Manipulation, an extension introduced with Piledriver-based processors as an extension to BMI1).   AMD explicitly revealed in the description of the patch to the GNU Binutils package that “Zen”, its third-generation x86-64 architecture in its first iteration (znver1 – Zen, version 1), will not support TBM, XOP and LWP instructions developed specifically for the “Bulldozer” family of micro-architectures.      Interesting: Bit manipulation | Find first set | X86 instruction listings   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,30zcy8,FUZxxl,1 point,Thu Apr 2 06:39:13 2015 UTC,"I beleive it has something to do with the undefined scenario when the operand is zero. ""rep bsf"" fills dest with zero when tzcnt is available"
C_Programming,30zcy8,zenCbot,1 point,Thu Apr 2 07:03:10 2015 UTC,"What system are you working on? What's your CPU architecture? If you're programming for a micro-controller, I might be able to write an assembly routine for you that computes the answer to this question reasonably fast."
C_Programming,30zcy8,Lobreeze,1 point,Thu Apr 2 00:38:25 2015 UTC,"Here is (untested) code for finding the bit set on a 16 bit int, and never loops more than 8 times (as opposed to potential 16 loops) by performing one check:  int what_bit_set( uint16 num ) { int iii = 0;   if(num & 0xFF00)  //is the set bit in high byte? {     iii = 8;  //then adapt the counter     num >>= 8;   //..and shift all bits into the low byte }   //discover the set bit... while(num)     {       num >>= 1;       iii++;     }   return iii;      }    EDIT: note that you could add more branches by testing the nybbles after isolating hi/lo byte.  Bitwise AND cks are very inexpensive, and hence you could get your code down to max of 4 loops. ( Less then 4 loops gets very close to bad trade offs from branching and testing vs looping, imo. )  UPDATE:  See fully functional version I take simple ideas too far ?"
C_Programming,30xps6,AbstractedStory,2,Tue Mar 31 15:41:50 2015 UTC,"nom = scan(&count);   nom is of type waffle, but scan returns a waffle*. This should have shown up in your compiler output. However, you don't end up using nom so I'm not sure why you bother getting the return value.  number++;   number is an int*, not a number. You probably want (*number)++;  waffle *syrup; char *buff;   You don't allocate memory for either of these pointers before using them. You should be getting a segmentation fault."
C_Programming,30xps6,dragon_wrangler,1 point,Tue Mar 31 16:05:55 2015 UTC,"Thanks for reply. I typed code fast and didn't check for errors. It's just a sample code of similar problem I have, for my code has variables & function names in foreign language, so I figured I'd just write fast piece that isn't working in English.  Now it's working, but variable counter in main does not get the value of number.  Any idea how to send value of number from function to the main?"
C_Programming,30xps6,dumsubfilter,1 point,Tue Mar 31 16:31:45 2015 UTC,"Pass a pointer to it as an argument and update it within the function.  You could have returned it, but you're already returning something else."
C_Programming,30xps6,dragon_wrangler,1 point,Tue Mar 31 16:41:23 2015 UTC,"My bad, reddit ate a few of my * characters. I'll edit my post above."
C_Programming,30v3az,blebaford,30,Mon Mar 30 23:11:12 2015 UTC,"I think you'll understand it better if I explain why you need header files in the first place. The key to understanding this is that, when compiling, C compilers only look at the specific file of code they're compiling. Thus, if you have two files, file1.c and file2.c, when the compiler is compiling file1.c it has no knowledge of the contents of file2.c, nor that we plan on using the two files together.  So now, imagine we have these two files:  file2.c:  struct bar {     int foo; };  void foo(struct bar *b) {     b->foo = 2; }   file1.c:  #include <stdio.h>  int main() {     struct bar b;     foo(&b);     printf(""%d"", b->foo);     return 0; }   Compilation steps:  gcc -std=c99 ./file1.c -c -o ./file1.o gcc -std=c99 ./file2.c -c -o ./file2.o gcc ./file1.o file2.o -o ./test_exec   (Note, The last gcc line is actually using gcc to invoke the linker. This is handy because gcc knows how to use the linker correctly to make a proper executable out of the object files. Doing this directly with the linker is actually somewhat complicated, and not worth it unless you need to do something special.).  The above is a single program which prints 2 to stdin and exit. Alone however, the compiler will refuse to compile file1.c. If you look at file1.c, it should be obvious why: There is no definition of struct bar and no definition of foo. Obviously you can't expect the compiler to compile code which declares a struct bar object on the stack when you didn't tell the compiler what a struct bar is so it can create one.  The problem is that we defined struct bar in file2.c, but not file1.c. Thus, we could fix it like this:  file1.c:  #include <stdio.h>  struct bar {     int foo; };  extern void foo(struct bar *b);  int main() {     struct bar b;     foo(&b);     printf(""%d"", b->foo);     return 0; }   If you use that file1.c and the above file2.c it should actually compile:  The key here is that we provided file1.c with definitions for struct bar and foo, so when the compiler goes and compiles the file, it then knows how to make a struct bar and how to call foo, and everything is happy (The linker takes care of 'connecting' the call to foo in ./file1.o with the actual definition of foo in ./file2.o).  There's an obvious issue with this approach though: duplication. Imagine if we wanted to add another field to struct bar, and imagine we used struct bar in 15 different program files! We'd have to go manually edit all 15 declarations of struct bar and make sure they match. Worse: Since the compiler only looks at one file at a time, it has no way of knowing that the struct bar definitions don't match, and the linker won't have any idea. Thus, if we mess-up a struct bar definition, the compiler and linker will happily compile the code, and then it will probably seg-fault for no obvious reason when you run it. The same thing can happen with foo. Imagine if we defined foo as void foo(struct bar *b) in one file, and void foo(struct bar b) in another! It's an obvious mess.  Thus, the 'obvious' solution is to have some way of defining stuff like struct bar and foo in some separate location, and then telling each file to go read that file and treat it like it's part of this current file. That way, we could define struct bar in that one file, and then every file is using the same definition. That's what a header file does.  Header files use the #include preprocessor statement. The important part to note about this is that the preprocessor actually runs before the compiler. So if you have a statement like #include ""foo.h"" inside of file1.c, the proprocessor actually opens foo.h and inserts the contents directly into the copy of file1.c that it sent to the compiler. The compiler never even knows that foo.h exists, or that the contents of foo.h wasn't always in file1.c. Thus, you have stages of compiling.  Actual file1.c:  #include ""foo.h""  int main() {     foo(2);     return 0; }   Actual foo.h:  extern foo(int bar);   What the compiler sees:  extern foo(int bar);  int main() {     foo(2);     return 0; }   As you can see, when we get to the compiler it just looks like one big file. This is extremely handy because we can turn the above code into this:  bar.h:  struct bar {     int foo; };   foo.h:  extern void foo(struct bar *);   file1.c:  #include ""bar.h"" #include ""foo.h""  int main() {     struct bar b;     foo(&b);     printf(""%d"", b->foo);     return 0; }   file2.c  #include ""bar.h"" #include ""foo.h""  void foo(struct bar *b) {     b->foo = 2; }   Now, we only have one definition of struct bar that both file1.c and file2.c both use. foo also has it's own definition. Including foo.h into file2.c isn't actually necessary (There's no reason to declare a function without a body right before you declare it with a body), but including it ensures that you never have a type-mismatch on foo, because the compiler will refuse to compile code that has two definitions for the same function with different types. IE. A file with the lines void foo(int) and int foo(int) won't compile. For good reason - The compiler can't handle having two different functions both named foo.  Thus, header files are nothing more then extra source files. The benefit of using headers is that it the definitions inside tell the compiler about symbols and definitions being used by other source files, and thus allows you to use those things in several different pieces of your code. Without them, you'd have to manually repeat compiler definitions in every file you use external functions or global struct definitions to tell the compiler ""Hey! This thing exists in another file somewhere."", or ""This is what this struct is supposed to look like"".  The reason why you don't need to reference the .c file in the .h may be clear to you now: There isn't actually any real relation between the two. One contains various definitions for use in source code, the other contains actual source code. It's common to have a file2.h corresponding to a file2.c, where file2.h is the definitions for all of the things in file2.c, but it's not necessary to keep that convention, nor extremely common to see programs that strictly adhere to that convention. In my example, foo is defined in file2.c, but I put the definition in foo.h. Likewise, struct bar is in it's own header, bar.h, which has no corresponding .c source code. As long as every file that need access to struct bar includes bar.h, and every file needing foo includes foo.h, it doesn't matter where you put these definitions. You're even allowed to declare the more then once. Ex. Have a header which declares the functions foo and baz, and then have a separate header used in other parts of the program that only declares foo and not baz."
C_Programming,30v3az,DSMan195276,25,Tue Mar 31 03:42:39 2015 UTC,"(cont.)  The usage of #ifndef is to fix the issue of including multiple files. To use the above example. imagine what would happen if I say, included bar.h twice, or included foo.h before bar.h. Both cases would result in either an error or a warning. The issue stems from the fact that if I include bar.h twice, then I'll end-up with two definitions of struct bar. And if I include foo.h first, the declaration of extern void foo(struct bar *) is before the declaraction of struct bar and thus it doesn't know what a bar is (This is actually a warning, not an error, but it's still bad and will bite you if you won't pay attention to these issues.)  You're probably then asking yourself, ""why would I ever want to include bar.h twice anyway?"". The answer lies in the problem with foo.h. Imagine if I turned foo.h into this:  foo.h:  #include ""bar.h""  extern void foo(struct bar *);   Now whenever something include's foo.h, it automatically also includes bar.h. In this way, you'll never have the issue of including foo.h without bar.h. But now, if I do this:  file1.c:  #include ""bar.h"" #include ""foo.h""   (Because I'm going to use struct bar and foo), this will complain about two definitions of struct bar. The issue is that I included bar.h once on my own, and then foo.h also included bar.h, resulting in it being included twice. Since in general it's helpful to allow headers to include other headers (So you don't have to keep track of the ordering, or change every file if the header gains a dependency), you can use the #ifndef pattern (called include guards) to guarantee that a header is only ever included once. Thus:  bar.h:  #ifndef INCLUDE_BAR_H #define INCLUDE_BAR_H  struct bar {     int foo; };  #endif   This works by basically 'skipping' over the contents of bar.h if it's included a second time (After the first time bar.h is included, INCLUDE_BAR_H is defined. Because of this,the next time bar.h is included the #ifndef is false and it just skips right to the end of the header). By doing this, you avoid declaring anything a second time (like struct bar). In general this fixes most problems surrounding including files from other include files. In general, using either include guards or something like #pragma once is a must for anything that's not trivial.  About #include, the difference between <> and """" is simply a matter of where the compiler looks for the header. <> is used for ""system"" headers, meaning that the compiler first looks like places like /usr/include for the header. """" means looking in the same directory as the .c file. It's worth noting, it's extremely common to override these settings via the -I parameter to gcc. By using -I parameter, you can give the compiler another location to look for headers. It's common to have a folder called ./include just for header files, and then use -I./include when you compile so that #include statements using """" can include files in the ./include directory. Also worth nothing, since you're doing kernel dev, when you're compiling a kernel you won't ever use the system headers. To that end, you'll probably use the flag -ffreestanding which tells the compiler to not use any of the system headers. Because you explicitly told the compiler you won't use any of the current system's headers, you can use <> to reference headers exactly like you would """", and most OS code does that. Thus, almost specifically in kernel dev land, """" and <> can mean the same thing."
C_Programming,30v3az,DSMan195276,25,Tue Mar 31 03:43:13 2015 UTC,"(cont... Dang this thing got long...)  Talking about .o files, they're actually pretty easy. They're just a 'intermediate' file containing a compiled version of a source file (Ex. a .c file). The .o file isn't a complete program, because the source used to create it isn't a complete program either (A .c file is just part of a bigger program). To that end, .o files contain 'references' to things that it needs from other .o files. In the above example, file1.o contains a 'reference' to foo, because file1.c has a call to foo, but file1.c doesn't contain the code for foo. The linker is the program that takes care of taking in all of our .o files, and turning them all into an executable. This step involves resolving all of the references in the .o files, so when it combines, say, file1.o and file2.o, it combines the compiled code and then inserts an actual call to the foo code where the reference to foo was in the file1.o code.  In this fashion, it's possible to have errors that don't show-up when compiling but do show-up when linking. These are called linker errors. These only deal with things that the compiler had no way of knowing, so mostly just program wide things. For example, if we completely forgot to link the file2.o into our executable, the linker would complain that it can't find the definition of foo, because ./file1.o makes a reference to foo but we have no foo code to go with it in any of our .o files. The linker can't create an executable without resolving all references, so it has to throw an error. The reason the compiler didn't tell us about this is actually because we lied to it. We gave it the definition extern void foo(struct bar *b) in foo.h, but never defined a foo somewhere else.  A cool thing about .o files is that they're nice and generic, because they're just compiled code and various symbols like function names. Because of this, you can compiled different languages all down to .o files, and then link them together with the linker having no idea they came from separate languages and compilers. Assembly is one such language. You usually stick Assembly code into '.s' or '.S' files, and you can compile those assembly files with an assembler into .o files. You can then link the .o file into your program like any other .o file. (As a note, the difference between .s and .S usually is that .S assembly will be run through the C-preprocessor before being compiled, which can be useful).  Another cool thing to show this, you can actually make gcc spit out code at various compilation steps. You could do it separately if you want, but the -save-temps flag will output all the temporary steps. Ex:  gcc -save-temps ./file1.c -c -o ./file1.o   Will generate ./file1.o, the object file containing the compiled code, ./file1.s, the assembly code from gcc that was used to create the .o file, and ./file1.i, which is the code after being run through the preprocessor (And thus, ./file1.i is the actual source file that was compiled).  The steps go in the order:  ./file1.c -> (preprocessor) -> ./file1.i -> C compiler -> ./file1.s -> assembler -> ./file1.o   With that in mind, in general gcc keeps most of those things internal, so it won't save the preprocessor output or the assembler output. Also worth noting, the '-E' file will stop gcc after the preprocessor stage, and give you just the .i file. And '-S' will stop after the C compiler sage, and give you the assembly.  Static and Dynamic linking generally come-up when creating an executable. The idea behind static linking is simple enough. Say we have 'library1', 'library2', and our program 'foo' which uses both library1 and library2. Static linking just means that we directly compile all of the code from library1 and library2 into our 'foo' program. In general, this is done via archive files, .a files, which are nothing but a collection of .o files. Thus you can compile a .a file into your program like you normally would a .o file, and it will (in general) work as expected. So in our example, we'd just do:  gcc ./library1.a ./library2.a ./foo.o -o ./foo   To compile our 'foo' program. In contrast, 'Dynamic linking' is linking our code in a way that it makes use of code that's not in our executable. Thus, if we wanted to dynamically link against a copy of library1, we basically tell the linker ""Hey, there's a copy of library1's code over here. Make my program use that"". The linker and the OS take care of the finer points of actually loading the code from the library into memory when our program is loaded, so from our stand-point a dynamically linked program looks the same as a statically linked program. The main difference is now our ./foo executable has a dependency on a file call something like ./library1.so, where ./library1.so is the file containing the code for library1. When our program is loaded, the OS looks for ./library1.so and loads it into memory for us. Assuming the files ./library1.so and ./library2.so exist, you can compile like this:  gcc ./foo.o -llibrary1 -llibrary2 -o ./foo   The main difference is that, with static linking, you have no extra dependencies on .so files to provide code you need (Because the contents of the .so file is basically compiled right into your program), but with dynamic linking you can recompile the .so files without having to rec ompile your ./foo file. Also with dynamic linking, multiple programs can make use of the same .so file. So there's advantages and disadvantages to each. In general, dynamic linking is the way to go on Linux machines. That's just because libraries can be 'tuned' to different distributions, so by dynamic linking you don't have to worry about compiling the libraries yourself, you can just use the ones provided by the distribution. It's also better for security, because if a security issue is discovered in a library you link against, your program will automatically start using the patched version if they replace the .so. With static linking, your program has to be recompiled with the latest version."
C_Programming,30v3az,DSMan195276,5,Tue Mar 31 03:43:48 2015 UTC,Incredible.. Thank you so much for taking your time responding thoroughly. I read so many articles over the last few days about compiling and linking that were riddled with inaccuracies or just plain errors. The work you put into it is definitely appreciated.
C_Programming,30v3az,raccjoe,3,Wed Apr 1 16:39:46 2015 UTC,That was an absolutely excellent write up. Thank you
C_Programming,30v3az,BulDinoo,4,Wed Apr 1 01:23:07 2015 UTC,You must have compiled these comments with the -v flag.
C_Programming,30v3az,redditthinks,5,Tue Mar 31 17:42:19 2015 UTC,"I'd advise you to check out ""Linkers and Loaders"". Even though I haven't completely read it through I'm sure it's what you're searching for in terms of compilation phases, linking and loading (as the title of the book implies). The unedited original manuscript is available online for free.  More on compilation (even though I'll be using GNU tools as an example): the .c and .h files are source code. In my example they're source code for the C language. What GCC does is translate this into a .s file which is human readable assembly. You can get GCC to only output the .s file by some option like -S or -s. Without specifying GCC to generate the .s file it will actually proceed by calling the assembler. The assembler turns the .s assembly source code into .o object files which basically has the low level instructions (opcodes) embedded into it together with some information which might be necessary for the next step like relocations, symbol definitions, etc. The next step in this compilation chain is the linker which takes all the .o object files and merges the information, fixes the relocations, adjusts the relative addresses and all that to generate a binary or library. That's the general gist of it all but I'm sure I was off on a few things as they're still a bit blurry to me too. If you want to experiment you could try to do everything by hand, so generate the .s assembly source code from GCC, push it into the assembler (as for the GNU binutils) and get object files, push the object files into the linker (ld for the GNU binutils) and check the state of the .o and executable using objdump or anything that shows object or executable information."
C_Programming,30v3az,JustJanek,3,Tue Mar 31 00:10:34 2015 UTC,"A .h file simply contains declarations for variables, types and/or functions that are actually defined in a .c file. For instance, let's say you have a function foo that takes in a char and returns a unsigned int. This function is defined in your .c file as follows  unsigned int foo(char c) {     // Do stuff     return somenumber; }   The corresponding .h file would have the following:  unsigned int foo(char c);   That way, any .c file other than the original one can call foo by simply including the corresponding .h file where it is declared. The compiler uses the declaration in the .h file to identify the function signature, i.e., the number and type of parameters, and the return type.  The #include <blah.h> vs #include ""blah.h"" is unclear to me as well, but the convention I follow is that system header files are included using the angle bracket approach, while application header files use the double quotes. Note that I could still write #include ""stdio.h"", this is just the convention I follow. This SO thread may give you further details.  The include guard (#ifndef _FOO_H, #define _FOO_H, ..., #endif), is a common way to ensure that header files are not doubly included by accident. There are multiple reasons for having one .h file include another, mostly because the included file is something like a common header for the application and declares a whole bunch of stuff that would be used by other parts. It can be the case that a.h includes b.h and c.h, but c.h also includes b.h, so you want to avoid b.h being included twice, so that's why you use the include guard.  When you build your C program, you generally link with some libraries, one of them being the standard C library. The linker basically sets aside space for an object table, which kind-of maps the symbols in the library to the address space of the program. When the program is loaded, the loader will fill these locations with the actual address of the functions, which may be shared across multiple different applications or processes. This is dynamic linking. Static linking simply takes the code for these library functions and bundles it into your executable so there is no concept of shared code. In this way, you can take this compiled application and run it on any (similar) machine without a need for the original libraries. However, it does increase the size of your executable since you are not calling the shared code.  .o files are the result of compiling a .c file. This file is eventually linked into your executable. A .a file is simply a collection of several .o files which form a kind of archive for future static linking."
C_Programming,30v3az,Nirenjan,3,Mon Mar 30 23:44:29 2015 UTC,"When I have problems compiling (multiple includes, etc.) I can fix the issues by trying things until the compiler stops complaining, but I don't have an understanding of what's really going on.   Congratulations on moving on from this method.  Learning what's going on will make everything much easier.   I also never know what I should put in a .c file and what I should put in a corresponding .h file, and I don't really understand the paradigm of doing #include ""blah.h"" in the .c file while making no reference to the .c file in the .h. I'm sure that has a simple answer but this gives you and idea of the area that's hazy to me.   Declarations go in .h files, definitions go in .c files.  Declarations are function prototypes or extern declarations of global variables.  Definitions are actual implementation of these things: the function and its code and the global variables.  One significant exception to this are inline functions, which actually go in header files.  Not all declarations should go in a header file.  You should mostly put things that need to be shared between different .c files in headers.  So, if a macro or function is going to be used in more than one file, put a declaration in a header that the .c files should #include.  As a matter of style, some people think that everything should have a declaration.  If you have a function that is local to a single file (no other .c file uses it), then put a declaration at the top of the file.  Also consider making this entity static.   Is there a difference between #include <blah.h> and #include ""blah.h""? I have read conflicting info.   Yes, there is.  <blah.h> refers to a system header file, while ""blah.h"" refers to a header that belongs to the code you're compiling.  In some compilers, there's not really a distinction, but others enforce this.  What it really comes down to is search path: system header files are located in a specific location, and there's a separate search path to find them.   I would like to understand the tradeoff between using the #ifndef dance vs. being careful to include the files you need just once. - and under what conditions should a .h file include another .h file, and are there reasons to avoid that?   Always do the #ifndef dance.  It's an unfortunate necessity.  While you might be careful now, there's no guarantee someone won't be quite as careful in the future.  With small projects, it's no big deal, but when you have hundreds or thousands of files, you'll be thankful for them.  Please put the header guards in the header file, not around the #include statement.  Hopefully that style dies soon.  As an alternative, #pragma once is a non-standard but commonly implemented extension.  There's some pitfalls to using it (header guards are more robust), but it's much easier to use.   I'd like to understand what static and dynamic linking are, and the tradeoffs between each.   Dynamic linking puts functions and global variables in a file that is linked at runtime, while static linking is all done at compile time.  With static linking, your program consists of a single (possibly very large) file.  With dynamic linking, your file consists of the executable and a set of dynamic libraries as well.  Static linking is simpler by far, and easier to wrap your head around.  Dynamic libraries are great if you have multiple programs that share common code.  You can update the library separately from the programs.  You can reduce the overall memory usage with shared libraries, if that's a concern (the OS only has to load the file once).  Versioning dynamic libraries can be a pain.  But if you want to create a plugin system, dynamic libraries are the way to go.   What's the difference between a .a file and a .o file? Would I ever see a .a file in my working directoy, or do they always live in the system directories?   You can think of a .a file as just a set of .o files bundled together, like a tar or zip file.  Large programs will create them as part of the build process (maybe with a set of modules, each getting a static library)."
C_Programming,30v3az,boredcircuits,1 point,Mon Mar 30 23:48:48 2015 UTC,"So, if a macro or function is going to be used in more than one function,   Nit: replace the second ""function"" with ""file"""
C_Programming,30v3az,brunokim,1 point,Tue Mar 31 03:02:34 2015 UTC,Fixed.  Thanks.
C_Programming,30v3az,boredcircuits,2,Tue Mar 31 03:09:16 2015 UTC,"The C compiler does a lot more file manipulation and macro pre-processing than it does actual compiling.    Generally, the difference between #include <blah.h> and include ""blah.h"" is <>'s are for system libraries and """"'s are for your libraries.  The only technical difference to the compiler is which paths are searched when trying to find <blah.h> (and can be changed via compiler switches).    You should always #ifndef around including the definition multiple times.  If you create a library, it's impossible to 'be careful to include files you need once' since you have no idea how your header files will be used by others.    .o files are object files which is unlinked executable code, and .a files are archive files, which is basically a bunch of .o files tar'd together with some header information.    It's the linker that combines all the .o files into the executable or library file.  Programs are automatically linked with the C library (-lc switch for gcc), so when you #include <stdio.h>, that printf object code comes from that library.  The compiler wouldn't know what printf was or how many parameters it takes unless you told it there is a function called printf with x parameters.  That's why you include <stdio.h>.  After compilation, the linker has your foo.o file, and also /usr/lib/libc.a, and combines the code for printf with the code in your program into an executable with all the codes.  That's static linking.  Dynamic linking is almost the same thing, except the linking doesn't happen until your app is executed instead of at compile time.  Due to how memory is laid out, it's possible to have many processes use the same code for printf across all the processes when using dynamic linking, and is the main benefit. With static linking, each process that uses printf has a copy of the code for printf in it that came out of libc.a.  With dynamic linking, one copy of libc.so is loaded and processes share the read only parts."
C_Programming,30v3az,snarfy,1 point,Tue Mar 31 12:15:37 2015 UTC,"If you have some time, you should read the C standard  Here the part about the includes:   A preprocessing directive of the form #include <h-char-sequence> new-line searches a sequence of implementation-defined places for a header identified uniquely by the specified sequence between the < and > delimiters, and causes the replacement of that directive by the entire contents of the header. How the places are specified or the header identified is implementation-defined.  A preprocessing directive of the form #include ""q-char-sequence"" new-line causes the replacement of that directive by the entire contents of the source file identified by the specified sequence between the "" delimiters. The named source file is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read #include <h-char-sequence> new-line with the identical contained sequence (including > characters, if any) from the original directive.   Note the difference in what they include: ""header"" vs ""source file""."
C_Programming,30v3az,maep,1 point,Tue Mar 31 00:41:48 2015 UTC,"How do I write a function in assembly and link it with C code?   Put a declaration for the function in a header, and include that header in any .c file that is going to call the function.  Put the definition of the function (i.e. the implementation in assembly) in a file ending in .s.  (Use .S if you intend to use the C preprocessor, e.g. for shared #define values.)  Then add a step in your build system to assemble foo.s -> foo.o.  You can actually do this quite easily by calling the compiler driver in the same way you'd compile a .c file, i.e. gcc -c foo.s will produce foo.o, and gcc -c foo.S will similarly preprocess and then assemble.  Then add foo.o to your link command alongside all the other object files.  If you're using make, then there are probably already a built-in rule to handle foo.s -> foo.o, so all you have to do is add the .o file to your list of objects for a given target.  It's also possible to do inline assembly, but that's significantly more complicated because you have to learn gcc's complicated mini-language for specifying the side effects of each asm statement so that its backend doesn't get confused.  Consult the manual for details."
C_Programming,30v3az,Rhomboid,0,Tue Mar 31 05:15:14 2015 UTC,".O files are generally linked to the overall binary (kind of a link in a chain)  Having a ""foo.h"" just tells the compiler to look in the current directory however you can change this by having a -I in the make file and this will tell it to look in the specified directory ""-I foo/bar/baz.h""  And if you want to avoid problems with headers you need to use ""ifndef"" you can also find problems with the ""cpp"" command, this is basically a ""compiler"" for your headers in that it checks for errors."
C_Programming,30xg5h,Shtreimel,2,Tue Mar 31 14:28:59 2015 UTC,It's illegal to divide or take the modulo of 0.
C_Programming,30xg5h,moocat,2,Tue Mar 31 17:06:57 2015 UTC,"Yea, you got it right, thanks mate.   Note for myself: I went full retard, I should NEVER GO FULL RETARD."
C_Programming,30xg5h,Vungtauno,0,Tue Mar 31 17:17:12 2015 UTC,"Does it crash or does the executable close? I forget if C is the one where you have to add a system(""PAUSE""); before return 0; so the executable doesn't close immediately."
C_Programming,30xg5h,dumsubfilter,4,Tue Mar 31 14:53:50 2015 UTC,"It has nothing to do with C and everything to do with where you're running the program from.  You have the right idea though.  He wouldn't be getting any output if it was crashing, because printf wouldn't be executing at all if it was crashing.  Furthermore, since he's said that it's printing the GCD, what's the line immediately after that?  return 0;   It exits main immediately after the printf line, terminating the program."
C_Programming,30xg5h,Vungtauno,2,Tue Mar 31 16:07:10 2015 UTC,"Yeah, I'd assume that OP most likely was using some type of compiler and not using a terminal."
C_Programming,30yrz1,stormedcrow,3,Tue Mar 31 20:12:10 2015 UTC,use a memoization approach  fib(n)  table[0] = 1 table [1] = 1  for (i = 2 to n)  table[i] = table[i-2] + table[i-1]  return table[n]
C_Programming,30yrz1,whats_a_kimball,2,Tue Mar 31 21:38:13 2015 UTC,"without static variables, dinamic/static fields/arrays   incase i  missed something, can you explain it please ?"
C_Programming,30yrz1,madskillsmonk,3,Tue Mar 31 21:39:38 2015 UTC,You can cache the last 1 and 2 values for the function and use them on each iteration
C_Programming,30yrz1,pbhandari,1 point,Wed Apr 1 03:11:44 2015 UTC,Please put four spaces in front of every line of code so it appears in a mono-space font. It's hard to read otherwise.
C_Programming,30yrz1,pbhandari,1 point,Sat Apr 4 17:19:56 2015 UTC,"int fib_helper(int limit, int second_to_last, int last) {     if (limit == 0) { return second_to_last + last; }      return fib_helper(limit - 1, last, second_to_last + last); }   int fib(int limit) {     if (limit < 2) { return 1; }      return fib_helper(limit - 2, 1, 1); }   I used ints cause it's shorter to type.  Remember, to find the nth fibonacci number, you only need to keep track of the n - 1st and n - 2nd numbers.  /u/whats_a_kimball is a good solution if you need them a whole lot(since once you calculate it for one number, you'll never need to calculate it again)"
C_Programming,30xg71,_gh0st_,0,Tue Mar 31 14:29:16 2015 UTC,"You need to open the file, save the return (the file handle), and then read data from the file using the handle. Like this: http://www.cplusplus.com/reference/cstdio/fread/  Once you do that, you'll have the contents of the file to examine and you can keep working from there. Good luck!"
C_Programming,30xg71,frnzpff,4,Tue Mar 31 15:04:03 2015 UTC,Please do not link to C++ documentation for C code. C++ is a different language. Why do you keep doing this?
C_Programming,30xg71,FUZxxl,2,Tue Mar 31 15:13:21 2015 UTC,"Eh, it's not that big of a deal.  C++ inherits the entire C standard library, so it's not as if the documentation is any different.  cppreference.com has C documentation alongside the C++ documentation.  There are minor differences, I suppose.    Since you insist on C documentation, here's the man page for fread."
C_Programming,30xg71,boredcircuits,3,Tue Mar 31 15:23:06 2015 UTC,It is. C++ is different in subtle ways and the C++ versions of C functions can be different from their counterparts.
C_Programming,30xg71,FUZxxl,1 point,Tue Mar 31 17:14:20 2015 UTC,Can you post an example of this? I've never found a case where the C++ version of the standard libraries was different than the C ones.
C_Programming,30xg71,KatsumeBlisk,2,Tue Mar 31 17:56:28 2015 UTC,malloc needing a cast in C++ is an obvious example.
C_Programming,30xg71,snops,1 point,Wed Apr 1 01:54:48 2015 UTC,Let me have a look.
C_Programming,30uz5q,Andynonomous,2,Mon Mar 30 22:41:27 2015 UTC,"This is pretty easy to accomplish using SendInput. However, since you are new to C, and OS programming, it will probably be easier to use mouse_event instead. You should bookmark the Windows API as it contains a list of most functions Windows supports, and how to use them."
C_Programming,30uz5q,angdev,2,Mon Mar 30 23:53:11 2015 UTC,Check out SendInput [https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85).aspx]
C_Programming,30uz5q,Meefims,2,Mon Mar 30 23:50:18 2015 UTC,"Just wondering, why do you want to tell Windows to make the active window think the left mouse button is being held down? It seems like a very curious use case to me."
C_Programming,30uz5q,spurious_interrupt,1 point,Tue Mar 31 07:28:02 2015 UTC,"It's kind of embarrassing, haha. Ok I'm playing minecraft with some friends from work, but I can't stand the tedium.. so I want to be able to toggle 'auto-mining'. The only way I could think to achieve that given my lack of knowledge or experience was to write a program that holds down left click for me. Then I can just move my guy forward periodically and keep mining."
C_Programming,30uqkm,mormreed,3,Mon Mar 30 21:37:56 2015 UTC,You might need to flush the relevant stream or turn off buffering for that stream.
C_Programming,30uqkm,Chooquaeno,2,Mon Mar 30 21:56:07 2015 UTC,"That was it, thank you!!!  I guess I'll have to do some more reading on how C handles file operations and how to work with buffering."
C_Programming,30uqkm,ratatask,2,Tue Mar 31 14:34:26 2015 UTC,"FILE* pointing to an actual file are fully buffered by default, so you'd want to do  fprintf(fp,""Testing""); fflush(fp);"
C_Programming,30uqkm,_gh0st_,1 point,Tue Mar 31 09:10:05 2015 UTC,"That was it, thank you!!!  I guess I'll have to do some more reading on how C handles file operations and how to work with buffering."
C_Programming,30u9jd,howtoc,5,Mon Mar 30 19:33:52 2015 UTC,fopen()  fprintf()  fclose()
C_Programming,30u9jd,dragon_wrangler,3,Mon Mar 30 19:36:56 2015 UTC,"Also keep in mind the main function definition     int main(int argc, char **argv)"
C_Programming,30u9jd,theknight38,1 point,Mon Mar 30 19:56:32 2015 UTC,"Thank you so much! We haven't covered these commands in class yet. Can it be done using just printf() instead of those you list? I don't think my prof would care if I used those, but I think I want to try it out both ways."
C_Programming,30u9jd,dragon_wrangler,1 point,Tue Mar 31 15:57:08 2015 UTC,"No, if you want to print to a file from your program, you need the commands I listed. printf will only print to stdout, which is generally the console that you're in.  There are ways to redirect stdout to a file, but the invocation example you provided won't do it."
C_Programming,30u9jd,ruertar,2,Tue Mar 31 16:00:56 2015 UTC,"Good advice already given.  Also note that C considers two adjacent string literals as part of the same string.  So instead of:  printf(""foo""); printf(""bar"");   you could say:  printf( ""foo"" ""bar"" );   Also know that argc is always at least 1 and that argv[0] is always the name of the program.  The structure of such a program might be something like this:  if argc > 1   e = fopen(""echo.c"")   if (e == NULL)     print(""error: couldn't open echo.c for writing."");     exit    print_top_boilerplate_c_stuff_to_file    for (int i = 1; i < argc; i++)     print_printf_data    print_bottom_boilerplate_c_stuff_to_file    fclose(e)"
C_Programming,30u9jd,ghillisuit95,1 point,Tue Mar 31 09:24:47 2015 UTC,"command line arguments are passed as arguments to main(). i.e.  int main(int argc, char *argv[])   here, argc is the number of command line arguments, and argv is an array of char[]'s that are your command line arguments."
C_Programming,30u9jd,ruertar,1 point,Tue Mar 31 12:44:57 2015 UTC,"So where's your solution?  I'd like to see what you've come up with.  Here's mine:  #include <stdio.h> #include <stdlib.h>  int main(int argc, char *argv[]) {   if (argc > 1) {     FILE *e = fopen(""echo.c"",""w"");     if (e == NULL) {       fprintf(stderr, ""could not open echo.c for writing.\n"");       exit(1);     }      fprintf(e, ""#include <stdio.h>\n"" ""#include <stdlib.h>\n"" ""int\n"" ""main(int argc, char *argv[])\n"" ""{\n"" ""\tprintf(\n""     );      for (int i = 1; i < argc; i++)       fprintf(e,""\t\t\""%s\""\n"", argv[i]);      fprintf(e, ""\t);\n"" ""\texit(0);\n"" ""}\n""     );     fclose(e);   } }"
C_Programming,30u5du,YandereStudios,9,Mon Mar 30 19:05:01 2015 UTC,"Booleans in C are of type _Bool.  If you request the size of _Bool, the compiler will say it takes at least one byte (maybe more), not one bit.  If you really want a 1-bit boolean, you have two options.  You can use a bitfield, or you can use bit shifting to make it work.  C++ has a special version of the std::vector data type that does exactly this.  You can use it to optimize memory use if you have a ton of booleans, at the expense of extra bit twiddling (done behind the scenes).  This tradeoff is rarely worthwhile, IMO."
C_Programming,30u5du,boredcircuits,4,Mon Mar 30 19:37:14 2015 UTC,"There is no boolean type in C, they are ""emulated"" using basic types like char, int. In C++ bool's size is compiler specific and generally is one byte ( 8 bits ).   Now you can pack a boolean using one single bit packed inside a struct or class.  In that case the others 7 bits may or may not be used by others members in that struct/class. It is possible that the bits are ""lost"". It all depends on the size of its members, order and compiler alignement.  Is it worth bothering ? It can be if your program is performance critical, or memory limited. In most other cases i would say it is not."
C_Programming,30u5du,hotfudgegringo,4,Mon Mar 30 19:21:23 2015 UTC,C has a boolean type.
C_Programming,30u5du,raevnos,2,Mon Mar 30 19:39:06 2015 UTC,"My bad, there is a boolean (_Bool) type added with C99,  i just ignored how ""native"" it was."
C_Programming,30u5du,hotfudgegringo,1 point,Mon Mar 30 19:50:36 2015 UTC,Only c99..... Right?
C_Programming,30u5du,dbj1303,2,Mon Mar 30 19:45:03 2015 UTC,And C11.
C_Programming,30u5du,raevnos,1 point,Mon Mar 30 19:48:30 2015 UTC,"To use one bit only in C you will have to do something like that:    #define BOOL_ONE 1   #define BOOL_TWO 2   #define BOOL_THREE 4   #define BOOL_FIVE 8   #define BOOL_SIX 16   #define BOOL_SEVEN 32   #define BOOL_EIGHT 64   Then you can use a char like that:     char bool;     ...     if(bool & BOOL_FIVE)  if you want to see if your fifth 'bool' was true or false.  But that make no sense in a big program, as you might have a lot of booleans and you will get lost quite fast. When does it make sense to do it ? if you have a lot of boolean information from a small group of options. For example:     #define PER_MARRIED 1   #define PER_MAN 2 #define PER_ALIVE 4   #define PER_...     Then you can have an array of chars to represent people. Will it save memory ? yes. Will it make your code more complicated ? maybe, in some cases it might, in others it might make it easier to write conditions, for example: Let say you wanted to check for a married man:     #define MARRIED_MAN 3     if(people[i] & MARRIED_MAN == MARRIED_MAN)    Will it make your code faster\slower ?  it depends how you use it, the logical operators and fast, really fast, &, |, , ~ are fully implemented in the hardware and are really fast. If you use it right you can reduce the number of jumps which will also make your code faster."
C_Programming,30u5du,euovhepiygvqpeiruvn,3,Sun Apr 5 09:59:22 2015 UTC,sizeof(bool) must be at least 1.
C_Programming,30u5du,OldWolf2,1 point,Mon Mar 30 20:24:55 2015 UTC,"Your answer is incorrect. A _Bool (the type is not called boolean) has a size of at least one byte and as the size is part of the platforms ABI, the compiler won't attempt to change it regardless of options."
C_Programming,30u5du,FUZxxl,1 point,Mon Mar 30 22:10:50 2015 UTC,"ISO C:   An object declared as type _Bool is large enough to store the values 0 and 1.   ISO C++:   Values of type bool are either true or false  sizeof(bool) […] are implementation-defined   These are the only limitations set for bool and _Bool. ABI is not covered by either ISO C or ISO C++ and is used only when calling library/external functions, it can be ignored inside program."
C_Programming,30u5du,StenSoft,3,Mon Mar 30 23:07:58 2015 UTC,"Observe ISO 9899:2011 §6.2.6.1:   2 Except for bit-fields, objects are composed of contiguous sequences of one or more bytes, the number, order, and encoding of which are either explicitly specified or implementation-defined.   An object of type _Bool is an object and not a bitfield and thus occupies at least one byte of storage."
C_Programming,30u5du,FUZxxl,2,Mon Mar 30 23:26:07 2015 UTC,"Sorry, I didn't recall this limitation and therefore I now stand corrected"
C_Programming,30qswj,Renorei,8,Sun Mar 29 22:31:31 2015 UTC,"If that's really what you need to do, it sounds as though you need to read them as strings, not as floating-point numbers.  Numbers like 999.999 and 10.3 cannot be represented exactly as floating-point numbers. If you want to keep these numbers exactly as they appear in the input, you need to read them as strings."
C_Programming,30qswj,zifyoip,-2,Sun Mar 29 22:33:05 2015 UTC,I agree. I cooked up a small program that accomplishes just that: http://codepad.co/s/d319da
C_Programming,30q3ur,andrespm_,5,Sun Mar 29 19:03:59 2015 UTC,what's up with that letter spacing?
C_Programming,30q3ur,jWalwyn,4,Sun Mar 29 20:54:25 2015 UTC,The OP is using a proportional font instead of a monospaced font.
C_Programming,30q3ur,terremoto,2,Sun Mar 29 21:28:47 2015 UTC,"For starters, your scanf is wrong.  You need to give it the address of N, not the value of N.  scanf( ""%ld"", &N );   You should really compile with warnings enabled."
C_Programming,30q3ur,dumsubfilter,1 point,Sun Mar 29 19:49:19 2015 UTC,"Thanks, but now it doesn't make the operations in the if part, it shows me useless numbers"
C_Programming,30q3ur,dumsubfilter,2,Sun Mar 29 20:03:30 2015 UTC,"If it doesn't reach the if statements, it won't show you any numbers.  If you are seeing numbers, then it means you are in the if.  So that leaves your formula as being wrong.    I should leave you to figure the math out, but I'll give you one free:  If it is over 10k, divide by 100, mod by 10."
C_Programming,30q3ur,FUZxxl,2,Sun Mar 29 20:26:15 2015 UTC,"Thanks, it was a dumb problem, I was using ""=="" instead of ""="""
C_Programming,30q3ur,CodyChan,2,Sun Mar 29 21:03:31 2015 UTC,You might want to change the font of your editor to an actual mono space font.
C_Programming,30ito1,rebelkmac,2,Fri Mar 27 19:08:40 2015 UTC,Try to produce a minimal test case
C_Programming,30ito1,OldWolf2,2,Fri Mar 27 21:36:53 2015 UTC,That or produce at least a snippet of the source code along with the tracebacks from valgrind with a full leak check.
C_Programming,30ito1,glinsvad,2,Sat Mar 28 13:51:03 2015 UTC,"If you're still stuck by the time you read this I have something you can try, it's a bit of a long shot. There is a quick and simple test to confirm your malloc() implementation is actually thread-safe, just wrap it in a binary semaphore so that only one thread is ever allocating at any given time. You can either install a binary hook on malloc(), or go through your code and temporarily replace malloc() with a wrapper function manually. The wrapper simply acquires the lock, calls the regular malloc(), and then releases the lock. This test can take less than a minute!"
C_Programming,30ito1,angdev,2,Sat Mar 28 18:51:16 2015 UTC,"Did you correctly initialize name[i]?  If that char* doesn't end in a NULL terminator, weird things may happen...  Also, are you closing your fd afterward you're done with it?"
C_Programming,30ito1,james41235,1 point,Fri Mar 27 22:46:04 2015 UTC,yes I do close the file once it's done reading.  name[i] is defined as a static array with the names of the files that it needs to read.
C_Programming,30ito1,raevnos,1 point,Fri Mar 27 23:05:49 2015 UTC,"Is i a number that's a valid index for the array? If it's out of bounds, it could explain the segfaults."
C_Programming,30ito1,jimdagem,1 point,Sat Mar 28 19:29:29 2015 UTC,I've checked the indexing and it seems fine. It goes through this loop completely several times before it crashes.
C_Programming,30ito1,jimdagem,2,Sun Mar 29 23:57:40 2015 UTC,What command line are you using to invoke valgrind? Valgrind --tool=memcheck?  Also make sure buf is large enough to hold the string.
C_Programming,30ito1,geeknerd,1 point,Fri Mar 27 23:35:28 2015 UTC,I am using valgrind -v --leak-check=full --default-suppressions=no and I increased the buf from 200 to 500 and no change.
C_Programming,30ito1,jimdagem,2,Fri Mar 27 23:36:48 2015 UTC,"Hmm. It has been awhile since is used valgrind, but it seems like that would only check for leaks. I think memcheck checks for writing to un allocated memory."
C_Programming,30ito1,disclosure5,1 point,Fri Mar 27 23:39:25 2015 UTC,"You are correct.  Edit: I was incorrect, memcheck is the default tool and does check for more memory errors in addition to leaks. http://valgrind.org/docs/manual/mc-manual.html"
C_Programming,30ito1,chalk46,1 point,Sat Mar 28 11:28:45 2015 UTC,Also are you initializing buf to nulls?
C_Programming,30ito1,spinlocked,1 point,Fri Mar 27 23:40:32 2015 UTC,Yes I have tried to make sure they all are.
C_Programming,30ito1,james41235,1 point,Sun Mar 29 23:56:28 2015 UTC,Have you tried to compile with ASAN? It's usually pretty good at telling you exactly why something segfaulted.
C_Programming,30ito1,spinlocked,1 point,Sun Mar 29 05:11:24 2015 UTC,I will check that out.  Thanks.
C_Programming,30j3tt,Acyss,4,Fri Mar 27 20:28:08 2015 UTC,"int table[5][5];  for (int y=0;y<5;y++) {     for (int x=0;x<5;x++)     {         printf(""table[%d][%d] = %d\n"", y, x, table[y][x]);     } }"
C_Programming,30j3tt,angdev,1 point,Fri Mar 27 20:52:58 2015 UTC,Would that work the same if 5 was another variable?
C_Programming,30j3tt,nunodonato,8,Fri Mar 27 21:24:03 2015 UTC,read about arrays and multi-dimensional arrays
C_Programming,30j3tt,Stat1c19,3,Fri Mar 27 22:41:59 2015 UTC,"Look at some examples regarding your current problem, then go over the concepts and come back to analysing and understanding more examples. Then try coding some of them on your own till you achieve the desired results and you will be good to go :)"
C_Programming,30j3tt,Erno3000,1 point,Sat Mar 28 11:33:27 2015 UTC,"In C, use the nested for loops for 2 dimensional iteration. If you have different table sizes, make sure the branch condition corresponds to these sizes. Consider storing the sizes into a variable to avoid magic numbers in your code."
C_Programming,30j3tt,FUZxxl,3,Mon Mar 30 11:55:28 2015 UTC,Your question is underspecified. Would you mind elaborating?
C_Programming,30j3tt,Stat1c19,1 point,Sat Mar 28 02:44:23 2015 UTC,"I cannot understand the question completely. By a2<a1 (and b2<b1), do you mean that the value of a2 needs to be less than a1?"
C_Programming,30hg6i,mauriciogamedev,2,Fri Mar 27 12:26:28 2015 UTC,"Are you talking about this OOC?  http://ooc-lang.org/  I found these two threads on /r/programming from 5 years ago:  http://www.reddit.com/r/programming/comments/9wj1r/ooc_the_soft_point_between_haskell_python_and_c/  http://www.reddit.com/r/programming/comments/a31jb/ooc_a_modern_objectoriented_functionalish/  Also, it doesn't seem to be very actively developed. Are you sure it's the best option for you?"
C_Programming,30hg6i,dragon_wrangler,1 point,Fri Mar 27 13:11:28 2015 UTC,"I am not so sure. I have seen some people using rust with emscripten as well, but emscripten and rust is in its early stage as well. The syntax on OOC(yeah it is the one that you linked) seems so nice and looks like a more direct path to compile than rust. Thats why i am looking for help here. I think i am going back to regular C/C++... Wich i am not so confident on using. Still, any suggestions on how to do aproach this is welcome."
C_Programming,30hg6i,manvscode,2,Fri Mar 27 13:43:18 2015 UTC,"Wich i am not so confident on using. Still, any suggestions on how to do aproach this is welcome.    Trust me.  Learn C or C++.  It's tough but you will appreciate knowing how computers work."
C_Programming,30eva2,reyaldinho,8,Thu Mar 26 20:21:51 2015 UTC,http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
C_Programming,30eva2,muffinman007,6,Thu Mar 26 20:27:05 2015 UTC,"OP- you definitely want to check out this list.   In addition, I would recommend going to Project Euler https://projecteuler.net/ and trying to solve those problems with your newfound skills in C. It will be challenging, but as a poster said below, the best way to learn C is by doing."
C_Programming,30eva2,owpunchinface,4,Thu Mar 26 21:25:45 2015 UTC,I feel like project Euler becomes more about knowing maths than programming after the first few problems.
C_Programming,30eva2,barnesandnobles,1 point,Fri Mar 27 11:24:12 2015 UTC,It is kind a both. I found implementation most times harder than math and is not as much about math as it is reasoning how to express complex problems to computer and solving them using computer assistance.
C_Programming,30eva2,raluralu,1 point,Tue Mar 31 12:44:28 2015 UTC,"Nice, thank you for mentioning Project Euler! I forgot about that. That site is a very good site to simulate your mind!"
C_Programming,30eva2,muffinman007,1 point,Fri Mar 27 00:16:10 2015 UTC,Thanks for introducing me to projecteuler!
C_Programming,30eva2,zenkibudo,9,Thu Apr 9 03:01:09 2015 UTC,"dont depent on code academy to get good at c. Instead code, code, code and code some more. What to code? Anything become curious of how things work from the most basic algorithm to the most complex. Do research here and on stackoverflow. Use pen and paper to write out what your algorithm does. use lots of printf statement to see the values of your variables at various state.  don't be afraid to ask others to look at your algorithm."
C_Programming,30eva2,muffinman007,3,Thu Mar 26 20:31:20 2015 UTC,"Ditto /u/muffinman007. To learn code you have to keep making programs, no matter how small or big. Just being persistent in doing this makes you learn even if you don't realize it.  I'm new to C programming, and I used to have a problem always forgetting to include libraries and semicolons. But after a week of being persistent in trying to make my own code, it became second nature. I'd still miss a few semicolons here and there, but not as frequently. The point is to be persistent and be practical."
C_Programming,30eva2,shundorbon,2,Fri Mar 27 13:23:42 2015 UTC,And the shear power of playing with pointers! I love pointers. I wonder if void* contains the answer to unlocking the universe.
C_Programming,30eva2,muffinman007,2,Fri Mar 27 15:14:28 2015 UTC,"This, definitely this. No amount of explanation will make up for doing it for yourself."
C_Programming,30eva2,chasesan,2,Thu Mar 26 22:26:32 2015 UTC,Agreed. I learned with Prata's C Primer Plus then just got straight to coding. If you want an online resource you can check out CodeAbbey.com for a broad range of challenge questions compatible with C.
C_Programming,30eva2,muffinman007,1 point,Fri Mar 27 14:19:16 2015 UTC,"CodeAbbey.com that's something new, I need to check that out."
C_Programming,30eva2,WalrusTheSailor,6,Fri Mar 27 15:17:08 2015 UTC,"Learning C is also about getting to know the compiler and linker. Try to understand every bit that you are doing, and if you think you do, recheck it to make sure."
C_Programming,30eva2,Pedantick,5,Thu Mar 26 21:16:54 2015 UTC,The compiler/linker aren't part of learning C. Theyre part of learning compilers.
C_Programming,30eva2,rro99,3,Fri Mar 27 02:38:08 2015 UTC,You're technically correct (the best kind of correct) but while  being familiar when the what your compiler and linker are doing won't help you learn the C standard but will certainly help you become a good C developer.
C_Programming,30eva2,one-oh,5,Fri Mar 27 03:49:10 2015 UTC,"If you want to get your hands dirty, get a hold of Advanced Programming in the UNIX Environment, by Stevens and Rago and work your way through the book. Don't be scared by the word 'Advanced' in the title. It starts off gently with Files and Directories and provides simple examples for implenting common commands; e.g., ls. By the end you will have a better understanding of C and the operating system with which it shares a common history."
C_Programming,30eva2,muffinman007,1 point,Thu Mar 26 21:37:56 2015 UTC,i need to get my hands on that book as well.
C_Programming,30eva2,Bfgeshka,6,Fri Mar 27 00:19:04 2015 UTC,"/r/dailyprogrammer/  Try to solve these challenges with C, it would be very educational for you."
C_Programming,30eva2,nebuchadnezzar277,4,Thu Mar 26 23:14:55 2015 UTC,"https://notabug.org/koz.ross/awesome-c  Check the Learning, Reference and Tutorials section as well as the Physical one.  Also take a look at the Advanced section here: http://learn-c.org/"
C_Programming,30eva2,themadnun,4,Thu Mar 26 22:38:16 2015 UTC,"You should take CS50 on edX. It's mostly C, and very thorough."
C_Programming,30eva2,rro99,3,Thu Mar 26 23:19:31 2015 UTC,"Read some books and get a good foundation, read some other people's code and get a good feel for style then, above all else, just take on a non trivial project.  Its those 'aha!' moments while troubleshooting your program that really teach you"
C_Programming,30eva2,atreayou,1 point,Fri Mar 27 03:53:13 2015 UTC,Look up thenewbostons C tutorials on Youtube. Bucky is hilarious!! https://www.youtube.com/playlist?list=PL6gx4Cwl9DGAKIXv8Yr6nhGJ9Vlcjyymq The later episodes in his tutorials are very useful
C_Programming,30eva2,manvscode,0,Wed Jun 24 14:56:31 2015 UTC,Write code. Read other people's code. Debug code.
C_Programming,30aqq1,EamonRocks,9,Wed Mar 25 21:18:01 2015 UTC,Redirection is handled by the shell.  Your program never sees < or input.txt as arguments.  Standard input is arranged by the shell to be connected to input.txt rather than the terminal.  Read from stdin as usual; your program doesn't change at all.
C_Programming,30aqq1,Rhomboid,2,Wed Mar 25 22:40:06 2015 UTC,Thanks for the answer! I really like the fact that this subreddit is filled with helpful people ^
C_Programming,30aqq1,SlayterDev,9,Wed Mar 25 22:49:58 2015 UTC,"This is called redirection. Basically when you call ./foo datafile.dat < input.txt, the contents of input.txt will be treated as standard input. For example, if input.txt contains:  Hello   and your program has a line like:  scanf(""%s"", buffer);   Buffer will then contain ""Hello"". datafile.dat can be accessed with argv[1]. Hope this helps."
C_Programming,30aqq1,TheHusky11,1 point,Wed Mar 25 22:36:36 2015 UTC,"Thank you for answering, that helped a lot!   one last question if it doesnt bother too much: if i use fgets to obtain the content of the file does it read until the end of the line or does it read till the EOF?"
C_Programming,30aqq1,dumsubfilter,3,Wed Mar 25 22:46:35 2015 UTC,"You need to pass the number of bytes you want to read as an argument to fgets. It will read until (a) the number of bytes you specified is read, (b) a newline is reached, or (c) EOF is reached. Whichever happens first.  edit: If a newline is reached, it is considered a valid character and will be included in the buffer fgets reads into, so you may want to remove it:    fgets( buf, bytes_to_read, stdin ); buf[bytes_to_read -1 ] = '\0';"
C_Programming,30aqq1,TheHusky11,3,Wed Mar 25 22:50:21 2015 UTC,"If you have read bytes_to_read bytes on your fgets call, then you'll wipe out the last byte read with this.  fgets( buf, 3, stdin );  /* ""abcd"" */ buf[ 2 ] = '\0'; printf( ""%s"", buf ); /* ""ab"" */ fgets( buf, 3, stdin ); /* takes the ""d\n"" */ /* oops.... ""c"" is gone */"
C_Programming,30aqq1,dumsubfilter,1 point,Thu Mar 26 17:27:52 2015 UTC,"Only if bytes_to_read is the size of the buffer. I suppose it would be safer to read 1 less than the size of the buffer.      fgets( buf, bufsize - 1, stdin );    buf[bufsize - 1] = '\0';    fgets( buf, bufsize - 1, stdin );"
C_Programming,30aqq1,TheHusky11,2,Thu Mar 26 18:29:14 2015 UTC,"Only if bytes_to_read is the size of the buffer.   That's what I was pointing out; the potential for a minor bug.   buf[ strcspn( buf, ""\n"" ) ] = '\0';"
C_Programming,30aqq1,dumsubfilter,1 point,Fri Mar 27 03:08:52 2015 UTC,"We've both posted some code with bug potential in it. In yours, if there is no ""\n"" in buf, strcspn will return the length of buf, so accessing that index of buf will overrun its bound.  Mine would not remove the ""\n"" if the number of bytes read into buf is less than bufsize-1. I think something like this would ensure that the buffer is both null-terminated and removes any newline characters.  int index; fgets( buf, bufsize - 1, stdin ); // Reads data buf[bufsize - 1] = '\0';          // Ensures the buffer is null-terminated index = strcspn( buf, ""\n"" );     // Finds index of newline, if any if( index < bufsize )             // If newline is found, set it to null character     buf[index] = '\0';"
C_Programming,30aqq1,zehemer,1 point,Fri Mar 27 03:25:54 2015 UTC,"No it won't.  Read what strcspn returns.  Either it will be nul terminated, or it will have a newline.  DESCRIPTION  The strcspn() function spans the initial part of the null-terminated  string s as long as the characters from s do not occur in string charset  (it spans the complement of charset).  In other words, it computes the  string array index in s of the first character of s which is also in  charset, else the index of the first null character.   Pay particular attention to that last line."
C_Programming,30aqq1,SlayterDev,1 point,Fri Mar 27 07:25:29 2015 UTC,"Thanks! All problems solved then, /r/C_Programming saved the day once again!"
C_Programming,30aqq1,rjw57,1 point,Wed Mar 25 22:57:27 2015 UTC,For reference: http://pubs.opengroup.org/onlinepubs/009695399/functions/fgets.html
C_Programming,30dw5c,lproven,3,Thu Mar 26 16:15:35 2015 UTC,wat
C_Programming,30ajvm,BeefSmacker,2,Wed Mar 25 20:29:37 2015 UTC,"Put a condition depending on that global boolean into the signal handler for SIGUSR1. You know, a signal handler can call functions."
C_Programming,30ajvm,FUZxxl,1 point,Thu Mar 26 14:01:04 2015 UTC,beej   Also maybe this example.
C_Programming,3017b2,phrackattack,8,Mon Mar 23 17:35:12 2015 UTC,"Just from a cursory glance, there's a ton of issues with the code.   You don't check errors from any network function, like bind() or read(). If bind fails, (e.g. the port is used by some other software) the program just goes on blissfully unaware that nothing is working. You don't set the SO_REUSEADDR flag on the socket, which means that you have to wait a while before launching the program again after it terminates (so that the port goes out of TIME_WAIT state). You trust the client to give you a proper HTTP request; there's a massive amount of buffer overflows etc. that can happen if it doesn't. If the file requested doesn't have a file extension, you do strcmp() with a null pointer in get_mime_type(), which causes a segmentation fault. The program doesn't check whether DOCROOT_DIR exist, and simply crashes if not. The program can only handle one client at a time, which means that a very slow (or malicious) client will DOS the service. There is no guarantee that read() and write() actually writes the amount of data you give to it; you have to read the return value and then write the remaining data again. This is probably why your images fail, since they are probably too large to fit inside the kernel socket buffer (which is 16KiB on my computer, for example)."
C_Programming,3017b2,Aransentin,7,Mon Mar 23 19:07:52 2015 UTC,Also there are calls to malloc but no calls to free.
C_Programming,3017b2,dreamlax,2,Mon Mar 23 20:35:19 2015 UTC,"Yep, thank you. Do you have any recommendations on how to write this to handle more than a single connection at a time? I'm just learning C."
C_Programming,3017b2,Aransentin,6,Mon Mar 23 19:20:48 2015 UTC,"Do you have any recommendations on how to write this to handle more than a single connection at a time?   You can stick the sockets into an epoll group, and then wait for a socket to be ready for reading/writing or connecting (in the case of the server socket). If you want the program to be cross-platform (since epoll is linux-only), there's e.g. libevent which uses epoll internally (and kqueue on bsd etc. ).   I'm just learning C.   Network programming is kinda complicated, so I imagine it'd be a little overwhelming if you are just starting out. Doing things properly - handling all the edge cases & making sure that it's secure and fast requires quite a bit of code. Don't feel too bad."
C_Programming,3017b2,Aransentin,2,Mon Mar 23 19:41:22 2015 UTC,What about using fork()? I ran across this while researching your recommendations:  http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html
C_Programming,3017b2,dreamlax,-1,Tue Mar 24 00:17:05 2015 UTC,"fork() is Linux only, and would work okay. It's not terribly efficient though, as every created child gets its own copy of the parent memory (and becomes it's own process, which has some overhead). Threads are much quicker, but not nearly as simple to use as fork."
C_Programming,3017b2,disclosure5,5,Tue Mar 24 00:37:50 2015 UTC,"fork() is POSIX  and has been standardised as part of SVID since the beginning (1985). It's also possible that the fork has copy-on-write semantics, meaning only modified memory pages are copied. Process creation on Unix systems tends to be much cheaper than on e.g. Windows, given the number of processes that can be spawned even on a single command-line."
C_Programming,3017b2,Aransentin,2,Tue Mar 24 06:10:34 2015 UTC,Network programming is kinda complicated   I've yet to see a solution to network code that doesn't either produce GCC warnings or silly looking unions.
C_Programming,3017b2,disclosure5,1 point,Wed Mar 25 00:55:53 2015 UTC,"I suppose you could convert all IPv4 addresses to IPv4-mapped IPv6 addresses, and then using IPv6 sockets only with sockaddr_in6 directly. It worked okay when I tried it, but seems to be unsupported on some platforms according to google (i.e. Windows XP and older)."
C_Programming,3017b2,autowikibot,2,Wed Mar 25 01:56:24 2015 UTC,"Another solution that ""does work, but feels like a terrible hack"". I'm surprised there's not more documentation about this around. The same issue has caused I'm not happy with any solution type discussions elsewhere."
C_Programming,3017b2,iwasanewt,1 point,Wed Mar 25 03:48:41 2015 UTC,"Section 31. IPv4-mapped IPv6 addresses of article  IPv6:       Hybrid dual-stack IPv6/IPv4 implementations recognize a special class of addresses, the IPv4-mapped IPv6 addresses. These addresses consist of an 80-bit prefix of zeros, the next 16 bits are one, and the remaining, least-significant 32 bits contain the IPv4 address. These addresses are typically written with a 96-bit prefix in the standard IPv6 format, and the remaining 32 bits written in the customary dot-decimal notation of IPv4. For example, ::ffff:192.0.2.128 represents the IPv4 address 192.0.2.128. A deprecated format for IPv4-compatible IPv6 addresses is ::192.0.2.128.      Interesting: World IPv6 Day and World IPv6 Launch Day | IP address | Site Multihoming by IPv6 Intermediation | IPv6 deployment   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
C_Programming,3017b2,iwasanewt,3,Wed Mar 25 01:56:51 2015 UTC,"you're not checking the return value of   read(comm_fd, recv_header_buffer, HEADER_SIZE);   sometimes you get 0, but continue as if you had received something."
C_Programming,3017b2,bart2019,2,Mon Mar 23 21:14:44 2015 UTC,"That's another bug, thanks. Why would the server ever get null from reading the socket btw? This was one of a few causes for segfaults..."
C_Programming,3017b2,aninteger,3,Tue Mar 24 00:16:23 2015 UTC,"I suspect that it has something to do with the fact that your server  offers a keep-alive connection. If you press (ctrl+F5) in Firefox/Chrome, the browser closes its connection to your server (and tries to start a new one).  On success, the number of bytes read is returned (zero indicates end of file) [...]  Also, stackoverflow."
C_Programming,3001kt,elamre,3,Mon Mar 23 11:14:59 2015 UTC,"The socket is connected to an IP address. To tell the server at that IP which name you want to refer to it by, use an HTTP/1.1 GET request with the Host: field:  GET /mysql.php?sensorValue=12 HTTP/1.1 Host: innoseis.freeiz.com   It's up to the protocol (HTTP, in this case ) to differentiate between host names. Also, it's not a subdomain - it's a host name. One IP address can have several host names hosted on it, even from many different domain names.  It gets really hairy when you start wanting to do HTTPS. Early versions of the HTTPS protocol required a separate IP address for each domain/subdomain."
C_Programming,3001kt,dmc_2930,1 point,Mon Mar 23 11:34:18 2015 UTC,"Thank you kindly for your reply. The get command is completely clear to me now, thanks for that :) However i'm still not quite understanding the host concept. Wouldnt freeiz.com be the host in this case?  This is my output btw: http://www.heypasteit.com/clip/1VKA  It comes down to:   <p>The document has moved <a href=""http://error404.000webhost.com/?"">here</a>.</p>"
C_Programming,3001kt,dmc_2930,1 point,Mon Mar 23 12:10:04 2015 UTC,"There are lots of HTTP error codes and things of that nature.  Are you trying to just make something that works, or do you want to develop a deep understanding of the HTTP protcol?  If the former, use a library like libcurl or any other HTTP libraries to do all of the heavy lifting.  If your goal it to learn how this all works, start reading about the HTTP 1.1 protocol, and response codes. Wikipedia has a pretty good writeup, then you can eventually even read the RFCs. The RFCs can be a bit dense though, if you're not familiar with how to read them.  In the case above, the server is telling you to fetch a different URL. What request did you send?  It should be something like:  GET /r/C_Programming/blah?id=blahblah HTTP/1.1\r\n Host: reddit.com\r\n \r\n\r\n   Change the values as you see fit for your application. If all goes well, the server will reply with:  HTTP/1.1 200 OK\r\n \r\n\r\n Content goes here........."
C_Programming,3001kt,dmc_2930,2,Mon Mar 23 12:17:07 2015 UTC,"As a side note, try it with telnet.  Connect to the web server you want to talk to with telnet, and try sending the request. Type what I showed you above, but just hit 'enter' where you see \r\n. You should be able to play with it and figure things out.  telnet www.myserver.com 80 GET / HTTP/1.1 Host: www.myserver.com Connection: close   HTTP/1.1 200 OK <html>..........."
C_Programming,3001kt,Chooquaeno,1 point,Mon Mar 23 12:18:41 2015 UTC,More than one hostname may map to a single IP address.
C_Programming,3001kt,meegowat,1 point,Tue Mar 24 08:17:36 2015 UTC,"Use libcurl. Seriously, if you really just want the functionality libcurl is nice. If you want to learn HTTP protocol by implementing it yourself, sounds like a neat project, have fun!   For libcurl, this example page has examples of everything you described needing. You should send a GET request to the URL you listed, capture the response using a callback function. Then parse the output you get and put that in the db."
C_Programming,2zvq5w,thinkvitamin,6,Sun Mar 22 05:44:09 2015 UTC,"I dislike statements like ""gcc supports C11.""  Yes, it supports the language features of C11, but gcc is just the compiler, not the standard library.  If you're using gcc on Linux, then your libc is probably glibc, and glibc does not yet support the C11 <threads.h> functionality so if you want to try out some new C11 threading using gcc under Linux, you're going to be quite disappointed, even if you're using a bleeding edge version of gcc built from HEAD.  And you might be a little bit annoyed at whoever told you that gcc supports C11.  The same applies for clang."
C_Programming,2zvq5w,Rhomboid,3,Sun Mar 22 18:13:11 2015 UTC,"<threads.h> is an optional feature though, so technically glibc does support C11. It doesn't need to ever implement it, if they don't deem it relevant."
C_Programming,2zvq5w,jringstad,2,Mon Mar 23 01:16:11 2015 UTC,No Open Watcom compiler?  It's free and open-source.
C_Programming,2zvq5w,PrintStar,1 point,Sun Mar 22 17:54:24 2015 UTC,"Some nice crypto included, but for generating random numbers on a day to day basis I use dSFMT and SFMT, some nicely optimized ""SIMD-oriented fast"" mersenne twisters.  http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/"
C_Programming,2zvq5w,xaveir,1 point,Mon Mar 23 02:39:10 2015 UTC,"Did you intend to include SDL twice, and under different names (SDL under Resources, SDL2 under Graphics)? Otherwise, really awesome, thanks."
C_Programming,2zxn6a,zifyoip,3,Sun Mar 22 19:57:02 2015 UTC,"Just a note about your if/else structure:   if(x<=30) {     /* ... */ } else if(x>30 && x<=60) {     /* ... */ } else if(x>60 && x<=90) {     /* ... */ } else {     /* ... */ }    You don't need to test x>30 in your first else if condition, because you already know that x>30 is true. If x<=30, then the first block is executed, and everything else is skipped!  Likewise, you don't need to test x>60 in your second else if condition, because you already know it's true. If x<=60, then one of the first two blocks would be executed, and you wouldn't even be considering that else if condition."
C_Programming,2zxn6a,Rhomboid,1 point,Sun Mar 22 20:01:22 2015 UTC,I cleaned that up! Thanks!
C_Programming,2zxn6a,Rhomboid,2,Sun Mar 22 20:05:38 2015 UTC,"You need to describe the problem better.   But doesn't transfer any data over to those files.   What does this mean, exactly?  Are you saying that the files are empty?  At least one of them should have at least one value.  Note that you have a return statement as the last line of your while loop, so you're only ever going to process the first score before main() (and therefore the whole program) ends.  The same applies for the code that prints the counts — surely you want to do that after the while loop has finished, not inside of it.  Also, you probably want to use ""%d\n"" when printing to the files (or perhaps ""%d ""), otherwise you'll have all the numbers jumbled together with nothing delimiting them."
C_Programming,2zxn6a,OldWolf2,1 point,Sun Mar 22 20:17:12 2015 UTC,"I fixed that return statement! And also added the  ""%d\n""  I ran the program and it gave me this as the result.  ""range1.txt contains 1 scores from 0 to 30  range2.txt contains 0 scores from 31 to 60  range3.txt contains 0 scores from 61 to 90  range4.txt contains 0 scores over 90  range1.txt contains 2 scores from 0 to 30  range2.txt contains 0 scores from 31 to 60  range3.txt contains 0 scores from 61 to 90  range4.txt contains 0 scores over 90  range1.txt contains 2 scores from 0 to 30  range2.txt contains 1 scores from 31 to 60  range3.txt contains 0 scores from 61 to 90  range4.txt contains 0 scores over 90  range1.txt contains 2 scores from 0 to 30  range2.txt contains 2 scores from 31 to 60  range3.txt contains 0 scores from 61 to 90  range4.txt contains 0 scores over 90  range1.txt contains 2 scores from 0 to 30""  and pretty much 50+ more lines  I only want 4 lines such as  ""range1.txt contains X scores from 0 to 30  range2.txt contains X scores from 31 to 60  range3.txt contains X scores from 61 to 90  range4.txt contains X scores over 90""  Sorry if this is a dumb question but.. how would i fix that?"
C_Programming,2zxn6a,IAmTooOldForThis,1 point,Sun Mar 22 20:25:48 2015 UTC,"Read my comment again, and think about where you're doing the printing."
C_Programming,2zxn6a,OldWolf2,2,Sun Mar 22 20:41:13 2015 UTC,"AH! I got it! haha thank you very much, I didn't realize my printing was in the loop for some reason!"
C_Programming,2zxn6a,ruertar,3,Sun Mar 22 20:47:29 2015 UTC,I didn't realize my printing was in the loop for some reason!   Using proper indentation helps to avoid this sort of problem.   Having a line containing } } is a good sign that something was messed up with indentation.
C_Programming,2zxn6a,sgthoppy,2,Mon Mar 23 00:47:48 2015 UTC,You need to close your files.  fclose(range1) fclose(range2)   and so on..
C_Programming,2zxn6a,dmc_2930,1 point,Sun Mar 22 20:26:15 2015 UTC,I did that.. and still got the same problem with the constant print of info. Or were you just commenting that I needed to do that?
C_Programming,2zxn6a,sgthoppy,1 point,Sun Mar 22 20:33:55 2015 UTC,"This test isn't right: fscanf(in,""%d"",&x)!=EOF  . This is a fairly common error although I can't explain why it is so common.  Instead it should be fscanf(in,""%d"",&x) == 1.  The fscanf function returns either EOF or the number of successful matches. If you only check for EOF then your code will go into an infinite loop if the file contains something that is not an integer.  It's also important to check that your files opened successfully (i.e. the pointers are not NULL)."
