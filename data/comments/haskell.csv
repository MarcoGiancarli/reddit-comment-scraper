haskell,3e383w,tailbalance,4,Tue Jul 21 16:47:23 2015 UTC,Eli5?
haskell,3e383w,BanX,11,Tue Jul 21 17:33:59 2015 UTC,"It's a reference to category theory, a branch of maths that has a lot of applications to type theory. Category theory uses a lot of graphs and diagrams in its illustrations, and such illustrative diagrams are said to ""commute"" if multiple paths between the same source and destination have the same effect or functionality."
haskell,3e383w,kunwoo,2,Tue Jul 21 18:06:00 2015 UTC,This article explains the joke:  https://www.fpcomplete.com/user/bartosz/understanding-yoneda  ...but it's not really for 5 year olds.
haskell,3e383w,safiire,3,Tue Jul 21 18:53:24 2015 UTC,"Or, apparently, someone who's had 4 glasses of wine.  Bookmarked for later tomorrow."
haskell,3e383w,WarDaft,4,Wed Jul 22 00:49:40 2015 UTC,"I like how it pops up '***Exception: prelude.undefined' when you click >>> from the last comic.   I am not sure if that is a joke, or some real error from a bug in their Haskell compiled to JS.  And I love this comic. I laughed at some, and others made me want to learn what the hell they were going on about. Good fun!"
haskell,3e383w,mcapodici,1 point,Tue Jul 21 20:43:49 2015 UTC,"I suspect it's real, but intentional. It may not be Haskell best practice, but it provides a laugh for Haskellers who click the button."
haskell,3e383w,hexbienium,1 point,Tue Jul 21 23:59:00 2015 UTC,"It's not real, just a joke:  <script>function hs_undefined() {alert(""*** Exception: Prelude.undefined"");return false;}</script>"
haskell,3e383w,bsmntbombdood,4,Wed Jul 22 01:46:00 2015 UTC,I wish I was good enough at Haskell to get these jokes. Any good basic monad jokes?
haskell,3e383w,Apterygiformes,11,Tue Jul 21 18:29:40 2015 UTC,We all do...
haskell,3e383w,mkaito,10,Tue Jul 21 18:36:08 2015 UTC,"Yes, we're all in the same bind..."
haskell,3e383w,simonmic,9,Tue Jul 21 18:55:27 2015 UTC,Let us join our forces and return stronger.
haskell,3e383w,Soul-Burn,5,Tue Jul 21 19:41:37 2015 UTC,I see what you did there...
haskell,3e383w,emarshall85,15,Tue Jul 21 18:51:33 2015 UTC,"Three Monads are hanging out with their friend, Jack. They're all pretty bored. ""I know!"", says Jack. ""Let's play a counting game. We'll go one by one, and whoever says the highest number wins. I'll judge.""  They start counting. ""const 1"", ""Just 2"", ""print 3"".  ""I'll pass, I can see where this is going,"" says the first Monad. Maybe and IO keep playing for a while, ""print 91"", ""Just 92"".  Then IO gets an evil gleam in his eye. ""Hey Maybe,"" he says, ""what do I have in my hand here?"" Maybe looks at the empty hand, puzzled. ""Nothing?""   IO smiles. ""print 93"".   Maybe realizes what's happened. ""Nothing,"" he grumbles.  ""All right,"" says Jack. ""Game's over."" IO grins.  ""The winner is Cont, with the high number of 1!"""
haskell,3e383w,jpriestley,3,Tue Jul 21 19:58:30 2015 UTC,"I get the diagram joke, but not this one. :<"
haskell,3e383w,13467,2,Tue Jul 21 21:40:36 2015 UTC,Nothing will short circuit all further Maybe Monad computations.
haskell,3e383w,BanX,1 point,Wed Jul 22 00:16:22 2015 UTC,How does the cont monad come into play? I get the IO and Maybe part
haskell,3e383w,Bollu,1 point,Tue Jul 21 22:33:37 2015 UTC,"Technically Cont should have said ""const 1"" rather than ""1"", but that might have spoiled the punchline.  Cont r a has type (a -> r) -> r. This can be interpreted as: it takes a single argument, which is the ""future"" of the computation. Then, it provides a result for the computation as a whole. Cont can call its argument to produce the result, in which case the monadic computation continues normally, but it can also just ignore the argument and give a final result for the computation. In this case nothing that comes afterwards matters.  Edit: I've updated the original post to use ""const 1"", since it probably won't actually ruin the joke for almost anyone."
haskell,3e383w,jpriestley,7,Tue Jul 21 22:45:36 2015 UTC,Are you having troubling extracting value from this?
haskell,3e383w,snoyberg,5,Tue Jul 21 19:28:06 2015 UTC,I don't get it. I think your joke might be out of context...
haskell,3e383w,emarshall85,2,Tue Jul 21 19:45:38 2015 UTC,"Beginners usually want to extract a from IO a, which they can't do, but don't need to."
haskell,3e383w,wimuan,1 point,Tue Jul 21 20:10:19 2015 UTC,"To be honest, I wasn't sure if my joke applied, but I wanted to join the party anyway."
haskell,3e383w,snoyberg,5,Wed Jul 22 01:49:40 2015 UTC,These puns are pure gold.  Maybe I should just return to my desk? <walks away slowly>
haskell,3e4g6s,Intolerable,8,Tue Jul 21 21:49:47 2015 UTC,"two years, four bots and two extracted libraries later, it's finally ready for hackage!  this is the library that powers /u/intolerable-bot and runs all of the automation on /r/dota2, it's a little clunky but it supports most of the stuff you'd want a reddit bot to do  there's a readme on the github page with a couple of examples, and i'm planning on getting a full tutorial out soon-ish  enjoy"
haskell,3e4g6s,tejon,1 point,Tue Jul 21 22:03:00 2015 UTC,this is the library that powers /u/intolerable-bot and runs all of the automation on /r/dota2   I'll add /u/whatarethebest to that list!
haskell,3e4g6s,tejon,3,Wed Jul 22 01:05:42 2015 UTC,"Been using this (via GitHub) for a little while now. It's a very straightforward library; as a relative Haskell newbie I found it easy to just pick up and use, particularly with the help of sample code via intolerable-bot. Great work, happy to see it on Hackage!"
haskell,3e4g6s,tejon,2,Tue Jul 21 22:05:11 2015 UTC,"thanks for pushing me to get it onto hackage, it was a bit of a waste just stagnating on github honestly  just need to update the bot now for some of the recent changes..."
haskell,3e4g6s,htebalaka,1 point,Tue Jul 21 22:08:12 2015 UTC,"Gonna have to do some updates myself now! My bot is hosted on Heroku, for which Haskell support depends on Halcyon, and that won't pull sources from GitHub -- so I've just had the library duplicated in my source tree, and haven't updated it since some time before this commit. :P  Being able to get it from Hackage now means I can clean that whole situation up, which is a great excuse to make several other improvements I've had on my mind, so yay! That does remind me, tho -- one of the things I tried to do initially was have it forward any PMs it received to me, and IIRC I ran into two issues with that. I think one was the missing ToQuery instance for Message, fixed in the above link, which was preventing me even attempting to send a message from the bot (again, IIRC -- I may not on this). The other problem I'm more sure of, though, because it involved code that actually compiled and ran; I was able to check unread messages, but couldn't make it mark them as read, which would complicate things considerably. Does that sound familiar?"
haskell,3e4g6s,hagda,2,Wed Jul 22 01:31:19 2015 UTC,Are there any small examples included with the API? I couldn't find any.
haskell,3e3x7k,bgamari,5,Tue Jul 21 19:36:57 2015 UTC,GHC 7.10.2 should be the first release which works out-of-the-box with GHCJS   does this mean I don't need to (fail to) build ghcjs in a vm anymore?
haskell,3e3x7k,sambocyn,7,Tue Jul 21 20:21:19 2015 UTC,"Well, as far as we're concerned I think, it means that GHCJS doesn't need any patches to GHC or Cabal anymore for a custom build - so yes, I imagine this will simplify their end-user build process a lot.  (And you can also always join the NixOS side where you don't need a VM for such a thing. :)"
haskell,3e3x7k,aseipp,2,Tue Jul 21 21:34:54 2015 UTC,Haddock comments for GADT constructors   yay
haskell,3e3x7k,sambocyn,1 point,Tue Jul 21 20:23:27 2015 UTC,The second paragraph in the last subsection seems to be truncated.
haskell,3e3x7k,heisenbug,1 point,Tue Jul 21 22:10:49 2015 UTC,Thanks for pointing this out. Fixed.
haskell,3e363b,sibip,4,Tue Jul 21 16:33:20 2015 UTC,"I don't see how the first exercise is true. For example, consider an arbitrary monoid M, and the monoid F with the underlying set {0, 1} with usual multiplication (0*0 = 1*0 = 0*1 = 0, 1*1 = 1). If f : M -> F is 0 on every element of M, then it should satisfy the definition of a monoid homomorphism given in the post, but it won't take the identity in M to the identity in F (which is 1). I don't see how to guarantee that a such a function h : M -> N between monoids takes the identity to the identity unless N is assumed to be cancellative."
haskell,3e363b,makeitraincheck,2,Tue Jul 21 20:58:35 2015 UTC,Good point! The definition in the post is too weak I think -- homomorphisms should map unit-to-unit by definition.
haskell,3e363b,sclv,3,Tue Jul 21 21:29:40 2015 UTC,You are right. It's the monoid isomorphism that preserves the unit. I made the correction in the blog.
haskell,3e363b,DrBartosz,1 point,Tue Jul 21 22:23:17 2015 UTC,"a homomorphism has to take 1_F to 1_G - otherwise it is no homomorphism.  https://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms  Better explained (more general) in the german Wiki: https://de.wikipedia.org/wiki/Homomorphismus (if you can read the math before ""Beispiele"")."
haskell,3e3qoz,clark_poofs,2,Tue Jul 21 18:52:52 2015 UTC,"not yet.  http://stackoverflow.com/questions/4808702/is-there-any-kind-of-statistical-natural-language-processing-library-for-haskell  http://stackoverflow.com/questions/11428601/nlp-parser-in-haskell  However, there is a lot of functionality in different places:  https://hackage.haskell.org/packages/#cat:Natural%20Language%20Processing"
haskell,3e3qoz,spirosboosalis,2,Tue Jul 21 20:38:03 2015 UTC,"Thanks for the sources! I guess I can stick with NLTK for now, but I'll keep an eye out on this.   Do you have any NLP background, or were you able to find all this via Google?"
haskell,3e3qoz,Faucelme,2,Tue Jul 21 21:20:48 2015 UTC,This reminds me that I have yet to read the Computational Semantics with Functional Programming book.
haskell,3e3qoz,bstamour,1 point,Tue Jul 21 21:45:50 2015 UTC,"It's a pretty decent read. I'd also suggest the prolog-based one: Representation and Inference for Natural Language, if you're into computational semantics."
haskell,3e1ky9,erikd,17,Tue Jul 21 06:39:44 2015 UTC,"You think this is slow? I use the iterative crowd feedback model. A version is submitted to public test without formal specification. Over time and with much arguing the mob decides whether the behaviour matches the ideal that is collectively held in the minds of the users. Feature creep means the next version never gets closer to the ideal but changes it and the process restarts. The result is never releasing a product that actually does what it says it does, if it claims to do anything at all."
haskell,3e1ky9,ithika,2,Tue Jul 21 14:49:07 2015 UTC,"I too, have myopic quarterly deadlines."
haskell,3e1ky9,sambocyn,2,Tue Jul 21 21:20:43 2015 UTC,Sounds a lot like Drupal bug fixing. 4+ year old bugs with 60 proposed bug fixes that all fail the automated unit tests are the norm there.
haskell,3e1ky9,beerdude26,0,Tue Jul 21 22:11:07 2015 UTC,"I too, play DayZ"
haskell,3e1ky9,HackScratch,1 point,Tue Jul 21 16:31:42 2015 UTC,What?
haskell,3e1ky9,ithika,1 point,Tue Jul 21 16:33:57 2015 UTC,"It was a jab at the game DayZ, which is in eternal Beta.  Sorry, sometimes I forget which sub I am in because I just browse subscriptions."
haskell,3e1ky9,HackScratch,7,Tue Jul 21 16:39:47 2015 UTC,"I'm curious whether HOL-light is different in this regard, but the style of proofs I see in Agda and Idris makes maintenance really hard.  Let's say you have a function that returns a list. Now you make a change, and for the change to be sound it is required that the returned list be non-empty. It turns out that for the arguments that you pass to that function, its result indeed will always be non-empty, but you have to prove that.  In ""normal"" mathematics, you often prove things by analyzing an object, in this case the function. The proof is detached from the object itself. Remember how in school you defined the Euclid algorithm and then proved, by analysis of the algorithm you already defined, that it terminates and computes the right thing.  But in Agda/Idris-style proofs, it seems hard (or at least uncommon) to do such proofs. Instead, the function is expected to assemble all the proofs about itself. Which is what makes these proofs hard to compose and maintain.  If the author of the function, at the time of writing it, didn't envision some specific property that the function satisfies, you're out of luck."
haskell,3e1ky9,roche,7,Tue Jul 21 16:17:28 2015 UTC,"You can see how this is done in the Coq standard library: the function div_eucl is defined in BinNatDef.v by giving just the computational part, then there are various proofs about it in BinNat.v.  The underlying logic of Coq and Agda are basically the same, so you could write the same proofs in Agda too. I think the main reason that people don't is that Coq has tactics to generate proof terms for inductive proofs, while in Agda you would have to write out the proof term (a recursive function) by hand. The proof then looks quite similar to the function definition (they are both recursive functions), so it's shorter to combine them into a single object.  The main exception is that Coq and Agda don't provide a very nice way to first define a function and then prove after the fact that it terminates. (Although there are various approaches to doing so, e.g. ""Bove-Capretta predicates"". Probably this could be made more smooth)."
haskell,3e1ky9,vilhelm_s,5,Tue Jul 21 20:00:43 2015 UTC,"Thanks, this is pretty awesome. I should pay more attention to Coq.  What do people think of Lean as an alternative to Coq? It has a very good book and was easy to start with, although I've run into a couple of bugs (which were promptly fixed)."
haskell,3e1ky9,roche,6,Tue Jul 21 20:24:56 2015 UTC,"It's not too hard to write functions and proofs separately in Agda. I think we don't often see it because large Agda projects are rare anyway, and for small projects separate proofs are somewhat less convenient than internalized properties because we have to reiterate the function logic in each proof."
haskell,3e1ky9,AndrasKovacs,3,Tue Jul 21 16:38:22 2015 UTC,"Could you show me an implementation of the Euclid algorithm and a separate proof in Agda? And please don't use the benefit of hindsight: write the simplest implementation of the algorithm as if you didn't have to prove it, then add a proof.  You can find the mathematical proof here: https://proofwiki.org/wiki/Euclidean_Algorithm"
haskell,3e1ky9,roche,5,Tue Jul 21 16:57:59 2015 UTC,In Idris there're Provisional Definitions to separate algorithms and proofs.
haskell,3e1ky9,gopher9,10,Tue Jul 21 18:22:44 2015 UTC,"Interesting. Through my mentoring in GSOC I am being exposed to the first step in your process, and it is causing me to rethink the way I do software. I am accustomed, due to commercial time pressures, to get something going as quickly as possible and then move on. I am now thinking that taking the time to do it right at each step can save time in the long run, through having a simpler, smaller, more understandable code base."
haskell,3e1ky9,alan_zimm,1 point,Tue Jul 21 08:56:53 2015 UTC,"I just decided to learn Haskell today. Is learning Haskell as someone with a comp sci degree, but completely incapable of writing a proof going to be a pointless endeavour? I'm not worried that I can't do it. I'm worried that the community will see me as borderline useless and not want to work with me. I had put offs learning Haskell until today for just that reason."
haskell,3e436t,0Il0I0l0,5,Tue Jul 21 20:17:32 2015 UTC,"If I was to rewrite this using Pipes/Conduit I would not be able to make a Consumer/Sink that turned the streaming data from the file into a lazy list and then pass that lazy list to render because that would sort of defeat the purpose of using Pipes/Conduit instead of lazy IO, correct?   Correct   Instead render would need to take a Producer/Source instead of a lazy list of data. Or I could write render as a Consumer/Sink?   If you were to switch to pipes, the equivalent type would probably be:  render :: Monad m => Pipe Data Color m r   I'd have to look at the render function to say for sure."
haskell,3e436t,Tekmo,4,Tue Jul 21 22:59:32 2015 UTC,great! I just wanted to make sure I was heading into the right direction. Also I'm probably going to end up going with pipes because the documentation is unusually good for a haskell library.
haskell,3e436t,Tekmo,4,Wed Jul 22 00:01:20 2015 UTC,"If you need additional help, you can always ask questions on haskell-pipes@googlegroups.com"
haskell,3e436t,hagda,2,Wed Jul 22 00:21:28 2015 UTC,"please implement with both, pipes and conduit, and if possible also with io-streams, and then compare performance and ease of use and tell us :-)"
haskell,3e32i6,gilliss,3,Tue Jul 21 16:07:47 2015 UTC,"I'm also looking for a better way to write the get* functions in Network.Telegram.Base. I'd like to define a sum type for all possible URLs defined in the API. Something like  type Method = GetMe | GetUpdates | SetWebhook ...   Using this I would like to have one function that knows which params data type it should use, based on the Method. Can give me some pointers?   have you taken a look at free monads for this?"
haskell,3e32i6,Intolerable,2,Tue Jul 21 16:27:57 2015 UTC,"I'd look at servant for ""type level sums"".   also Free monads, which should be simpler."
haskell,3e54kl,jP_wanN,2,Wed Jul 22 01:00:03 2015 UTC,"canvas is garbage.  WebGL if you need acceleration, but otherwise should work with just the DOM+SVG as you say.  PureScript is what you should look into, IMHO.  It's very nice."
haskell,3e54kl,singpolyma,2,Wed Jul 22 01:16:15 2015 UTC,"Given your requirement on file size, PureScript seems like a good choice. It has bindings for websockets, canvas, WebGL. In fact, it has at least two of each of the above, so you have some choice in terms of APIs. For plain DOM manipulation, there are also libraries which will help with HTML, CSS and SVG. Our core libraries are documented here, and there are plenty of helpful people on our IRC channel (#purescript) and the subreddit. There are also two games on the project page of our website which you might find helpful."
haskell,3e2pw8,xged,7,Tue Jul 21 14:34:07 2015 UTC,"I prefer defining records. I also pull in a light weight lens library (like lens-family) from the get go. It gives me a lot more options on how to declare my functions, which is valuable to me."
haskell,3e2pw8,kqr,5,Tue Jul 21 15:23:01 2015 UTC,"I also pull in a light weight lens library (like lens-family) from the get go   I'll do the same, except I'll just pull lens."
haskell,3e2pw8,pipocaQuemada,6,Tue Jul 21 15:24:39 2015 UTC,"I would, if only I didn't sometimes try to get people curious about Haskell to contribute, and they get scared when it sits there for half an hour downloading and compiling lens.  I do switch over to lens once I find myself needing the good stuff in it, though."
haskell,3e2pw8,kqr,5,Tue Jul 21 16:06:44 2015 UTC,"I use record notation when I want getter/setter functions. For me, this is the case   if a record has a lot of fields, making pattern matching for a single field cumbersome; if the order of the fields is not obvious from the constructor name, or if I want to derive lenses for the record.   I try to avoid type aliases when values of different aliases would not  be interchangeable.  For example, Code, Comments, and String are not synonyms, so when I see a function f :: Code -> Comments -> a, then I'd wrongly expect that f comments code causes a compile time error.  But choosing a type alias for binary operations type Binop a = a -> a -> a would be ok in my eyes, because a binary operation on a is a synonym for a function from a to a to a."
haskell,3e2pw8,m0rphism,4,Tue Jul 21 15:13:34 2015 UTC,"For example, when I see a function f :: Code -> Comments -> a, then I expect that f comments code causes a compile time error.   For this situation, newtype solves the problem. And there comes my question—that can be seen as an extension of the original post: how often do you use newtype in your code?"
haskell,3e2pw8,guiraldelli,4,Tue Jul 21 15:20:56 2015 UTC,"how often do you use newtype in your code?   For this purpose: I think... not often enough ;)  I like the idea of extra safety, but dislike the  syntactic noise caused by the newtype (un-)wrapping."
haskell,3e2pw8,m0rphism,4,Tue Jul 21 15:31:20 2015 UTC,Personally I go with the vanilla product type when my application is pretty small and 3/4 fields are enough; and switch to records once it get's larger; at which point you're also more likely to bring in the lens package.
haskell,3e2pw8,alt_account10,4,Tue Jul 21 14:54:53 2015 UTC,"The records (clunky as they are). Type declarations exist for documentation purposes, for when you want to express that a certain sort of data is used for some particular purpose. This assumption does not hold for getters in records. Take this:  data Person = Person {name :: String, spouse :: String}   Both name and spouse refer to names of people. Using the 2nd strategy here would be misleading:  data Person = Person Name Spouse type Name = String type Spouse = Spouse   This arrangement suggests that Spouse is somehow different from Name; that it fulfills some different role, whereas, in fact, both fulfill exactly the same role: identifying people. Using Person in conjunction with functions also becomes awkward:  getFirstName :: Name -> Name   At first glance, this looks as if you couldn't pass in a Spouse into this function. With ordinary record, you at least know what you're getting:  getFirstName :: Sting -> String  >>> let p = Person {name = ""Mars Winklebottom"", spouse = ""Snickers Winklebottom""} >>> getFirstName (spouse p) ""Snickers"""
haskell,3e2pw8,ForTheFunctionGod,2,Tue Jul 21 16:46:34 2015 UTC,How about:  data Person = Person Name Spouse type Spouse = Either Name type Name = String  getFirstName :: Name -> Name   or  getFirstName :: Name -> String
haskell,3e2pw8,kqr,2,Tue Jul 21 17:30:33 2015 UTC,At that point you could just newtype it.
haskell,3e2pw8,joelwilliamson,3,Tue Jul 21 17:46:44 2015 UTC,type Spouse = Either Name   I think you need another type there? Spouse has a kind * → *
haskell,3e2pw8,togrof,2,Tue Jul 21 18:40:07 2015 UTC,I would go with the record alternative since at some point you may want to extract a field without going through pattern matching. Also you would get update syntax for free.
haskell,3e10ea,pavelsky,19,Tue Jul 21 03:10:59 2015 UTC,"I'm the creator of http://instantwatcher.com. Yes, I moved it over from Rails to Haskell in the last two months. The stack is Scotty for the web routing, postgresql-simple for database lookups, and blaze-html for templating. I'll try to figure out why Wappalyzer is giving a false negative.  I put the ""Made with Haskell"" notice on the bottom to help raise Haskell's profile as a web application programming language. Thank you for noticing.  The new UI is in flux, so your feedback on that is welcome."
haskell,3e10ea,bashcat,5,Tue Jul 21 12:49:30 2015 UTC,"Could you please briefly elaborate on the migration experience? Was it painful? One shot or gradual? Is there any ruby left now? What about performance, code size, etc? I think I recall that there was a post about it. Has anything changed your view?"
haskell,3e10ea,mallai,15,Tue Jul 21 14:02:03 2015 UTC,"It was a complete ground-up rewrite. But I first built a prototype proof of concept a few months before. So you can say that the current version is the 2nd rewrite.   There is basically no Ruby left, except for small offline data pipeline pieces like Atom feed generation.  The performance, measured in the HTTP response speed, of the Haskell stack is overall about 3-5x faster than the Ruby version. Many pages now render in less than 100ms, almost all render in less than 200ms. The Rails version was typically between 400ms and 1000ms. The Rails version also used fragment caching much more extensively.    The memory footprint also differs. The old RoR site fired up 15 Rails instances. The new Haskell site is just one Scotty process doing multi-threading over 2 cores. I'm roughly guessing that the memory footprint is 10x smaller.  It's certainly not as easy to build a site in Haskell compared to Ruby, just because it's a less traveled road. But all the Haskell libraries I needed existed, and things got easier quickly with experience and experimentation.   Most important, after I had all the pieces in place, I found that refactoring the Haskell code is a completely different world. Refactoring a big Haskell codebase is strolling on a beach; refactoring a big Rails codebase is tippy-toeing around a minefield."
haskell,3e10ea,bashcat,4,Tue Jul 21 14:25:34 2015 UTC,Wow! Thanks!   Refactoring a big Haskell codebase is strolling on a beach   I have the same experience :-)
haskell,3e10ea,mallai,4,Tue Jul 21 15:18:28 2015 UTC,"Refactoring really is the best selling point for ""real world"" Haskell. All code gets refactored at some point unless an organization is too afraid to touch it."
haskell,3e10ea,dukerutledge,3,Tue Jul 21 20:02:48 2015 UTC,I can't figure out what this site is. Do they just serve as a frontend and link to Netflix?
haskell,3e10ea,hiptobecubic,5,Tue Jul 21 03:39:57 2015 UTC,"Yes, it's a front-end to Netflix and Amazon Prime Video.  Here's a recent explanation of http://instantwatcher.com from Consumer Reports:  http://www.consumerreports.org/cro/news/2015/07/a-better-way-to-search-for-netflix-and-amazon-prime-videos/index.htm"
haskell,3e10ea,bashcat,3,Tue Jul 21 13:08:00 2015 UTC,"Yeah, basically. They are able to sort movies by rotten-tomatoes rating, IMDB rating, etc.."
haskell,3e10ea,mr_dude,3,Tue Jul 21 03:43:16 2015 UTC,"I don't like their current UI but they provide all shows that are trending and they also show the newest releases. Netflix usually will show a few new shows in your recommended view but this site pretty much lists all of them when they come out the same day. I guess you can say it's a better/different frontend for the Netflix but it's pretty useful when I want to see a list of all new releases for the day (week, month) ."
haskell,3e10ea,matchi,5,Tue Jul 21 03:44:24 2015 UTC,Yeah I was pleasantly surprised when I found this out about a month ago too.  https://www.reddit.com/r/haskell/comments/3am3qu/should_i_put_a_powered_by_haskell_tag_w_haskell/?ref=share&ref_source=link
haskell,3e10ea,tejon,5,Tue Jul 21 04:57:08 2015 UTC,"Thread there also answers OP's question about the stack:   The site is built with Scotty, postgresql-simple, blaze-html"
haskell,3dzjh2,tailbalance,5,Mon Jul 20 20:18:32 2015 UTC,"This is very cool. I was recently part of a research project that involved running (limited) SQL queries on various hardware; the approach we used was to translate the SQL to a bytecode language of sorts and run that using a hand-coded interpreter for each back-end. Had I known about this (and been able to convince my team to use Haskell :) ), my work might have been a lot easier!"
haskell,3dzjh2,sj-olsen,1 point,Tue Jul 21 06:14:38 2015 UTC,Really interesting and mostly-accessible article! Thanks for sharing.
haskell,3e052c,kwef,10,Mon Jul 20 22:55:28 2015 UTC,"Congrats! Functional Pearls are a rough genre of papers to pull off, and getting one accepted is no mean feat.  I'm not sure when I'll first get to pull this out and use it ""in anger"" but I'm looking forward to finding out."
haskell,3e052c,sclv,6,Tue Jul 21 00:08:08 2015 UTC,"One thing that comes to mind given the definition of ??:  (??) :: Functor f => f (a -> b) -> a -> f b fab ?? a = fmap ($ a) fab   is that  löb ffs = fix (\fa -> fmap ($ fa) ffs)   can be written as  löb ffs = fix (\fa -> ffs ?? fa) löb ffs = fix (ffs ??) löb     = fix . (??)   The paper talks about löb = fix . flip when instantiated with the reader functor in which case (??) = flip so it's not too surprising.  Edit: It can help to define a right-associative version of (??) to see how a spreadsheet gets evaluated:  ghci> import Data.Function (fix) ghci> let infixr ???; fab ??? a = fmap ($ a) fab ghci> let löb = fix . (???) ghci> let spreadsheet = [length, (!!0), \x -> x!!0 + x!!1] ghci> spreadsheet ??? error ""⊥"" [*** Exception: ⊥ ghci> spreadsheet ??? spreadsheet ??? error ""⊥"" [3,*** Exception: ⊥ ghci> spreadsheet ??? spreadsheet ??? spreadsheet ??? error ""⊥"" [3,3,*** Exception: ⊥ ghci> spreadsheet ??? spreadsheet ??? spreadsheet ??? spreadsheet ??? error ""⊥"" [3,3,6]   and spreadsheet ??? (spreadsheet ??? (spreadsheet ??? ...)) is exactly what fix (spreadsheet ???) is."
haskell,3e052c,Iceland_jack,3,Tue Jul 21 05:00:15 2015 UTC,This is a great paper. It's remarkably well-written and presents a neat implementation: a more efficient and principled counterpart of loeb.
haskell,3e052c,conklech,2,Tue Jul 21 05:19:34 2015 UTC,Excellent work! I can't wait to follow up with silly questions.
haskell,3e052c,gatlin,2,Tue Jul 21 03:20:02 2015 UTC,"Suggestive. I hope to unscramble it. The löb theorem and the translation of Dan Piponi  to haskell ever fascinated me in both ways: the haskell translation and the original modal logic formulation. I did this online example of a spreadsheet using the löb expression, although this small Javascript program uses the same recursivity ""allowing each part of a structure to refer to the whole."""
haskell,3e06e9,joehillen,5,Mon Jul 20 23:05:53 2015 UTC,"Just need to get this on melpa.   There is also this for using cabal: https://github.com/flycheck/flycheck-haskell, would it be better to add stack support there instead?  Also, in case anyone doesn't know, if you have a recent haskell-mode, you can set:   (setq haskell-process-type 'stack-ghci)"
haskell,3e06e9,LadenSwallow,3,Tue Jul 21 07:53:32 2015 UTC,"The appearance of stack-ghci raises a question -- since this already causes downstream toolchain fracturing -- how well were alternative options researched?  Why am I asking this -- because I'm a bit scared how people will now have to choose between hacking on stack-ghci and ghci-ng, for example."
haskell,3dytzr,radix,7,Mon Jul 20 17:19:26 2015 UTC,"This is great! For vim users there's vim-ipython, which seems not quite as nice, but has a similar idea; I've heard it works with IHaskell, although I've never tried it myself."
haskell,3dytzr,NiftyIon,5,Mon Jul 20 20:08:20 2015 UTC,"I recently switched to the Atom text editor   Did you try Leksah?  Is there anything we could fix or add that would make it an option for you?   started using the Hydrogen package for evaluating code in-line in my editor   For something similar in Leksah press Ctrl + Enter.   The result goes to Panes -> Log and Panes -> Output. In the Output pane the result is rendered as HTML (using pretty-show and WebKitGTK). If the result is already HTML it will be displayed that way (right click in output pane and select ""Always HTML"" if HTML detection fails). Replays the last expression when you modify the code in your package (you can evaluate main, then change your code and watch the results in the output pane). There is a scratch pad in Panes -> Debug that you can use to write expressions without modifying your code. Supports Haddock embedded code (strips leading -- >). Supports doctest (also strips leading -- >>>). Works with ghci commands as well (except for :set prompt)."
haskell,3dytzr,hamishmack,7,Mon Jul 20 22:03:43 2015 UTC,"Did you try Leksah? Is there anything we could fix or add that would make it an option for you?   I haven't really tried Leksah much. I work in multiple languages, so I much prefer an editor that's general purpose, though I think Leksah has a noble goal :)  Sounds like Leksah has some great features!"
haskell,3dytzr,ghibe,6,Mon Jul 20 22:39:24 2015 UTC,"was going to try leksah but I wasn't able to install it through neither of cabal, yaourt (the arch package manager) or nix.   yaourt -S leksah fails due invalid dependencies already reported on the AUR cabal install -j leksah prints out this http://pastebin.com/f2RW6MhW nix-env -i leksah ends with the error: http://pastebin.com/1HfMj0rS   i have no deep knowledge of any of those package managers so I can't fix the problems myself."
haskell,3dytzr,MastodonFan99,2,Mon Jul 20 23:43:45 2015 UTC,Very similar problems. I stopped at that point in your 1st screenshot since I wasn't interested in breaking my emacs + ghc-mod setup.
haskell,3dytzr,Unknownloner,2,Tue Jul 21 06:12:45 2015 UTC,"I'd love to try leksah,  but every time I've tried to compile it (every couple of months with whatever latest ghc) it's failed. I believe I've seen errors in both dependencies and in leksah on separate occasions,  though it's been awhile so I can't be sure. If a Linux binary is feasible to distribute it'd be very helpful."
haskell,3dytzr,jP_wanN,2,Tue Jul 21 13:37:26 2015 UTC,"I'm in a similar situation. Unfortunately for arch linux users, Leksah is only available in the old AUR that is going to be replaced soon and is also flagged out-of-date. I will have a look at it screenshots though. I've heard of it before but like /u/radix, I just like the idea of general purpose editors more."
haskell,3dytzr,sambocyn,1 point,Tue Jul 21 01:00:06 2015 UTC,"lots of people (like me) get dependency-version (not even OS-specific) build errors. since Leksah is more ""application than library"", why not freeze the dependencies to specific versions, install in a sandbox, and then wrap the executable with ""cabal exec --"" or something?"
haskell,3dytzr,ExternalReality,4,Tue Jul 21 20:02:49 2015 UTC,"Excellent, reminds me of Scala Worksheets. Recently there has been a lot of excitement over the REPL but modern editor feedback techniques almost entirely obsolete the REPL IMHO. Editors like Intellij give an outstanding amount of feedback with contextual options on error/other concerns, Test Driven Development is great for saving contextual test setup and thus is a structured way to optimize feedback loops - although I do use it sparingly and when appropriate since the technique can lead to large, unruly, hard-to-maintain test suites. I do feel that REPL based feedback is a bit throwback and that editor plugins that give in-line feedback (like the post is showing) absolutely optimize feedback cycles when used with complimentary development techniques like Test Driven Development/Type Driven Development."
haskell,3dytzr,TheJonManley,5,Mon Jul 20 18:38:47 2015 UTC,"Looks exciting. As many of us were, I was very inspired by Bret Victor's talk ""Inventing On Principle"", where he talks about minimizing  feedback loops. At first, there was LightTable and it seems that it never matured enough in relation to Haskell to be used productively. I just checked Hydrogen and it looks very promising. How is Atom when it comes to Haskell (any editor performance issues or things to watch out for)? Is it ready for ""production""? How does it compare to other editors like Leksah and Intellij-Haskforce?  I'm afraid of jumping to a new shiny editor and then discovering some fundamental flaw in design of the editor that will force me to then to switch to another editor again. The fact that seem to use regex for parsing grammar and have have strange limitations like 2MB file size limit is a bit worrisome.  On the other hand, as a Vim user I've found that they have Vim bindings, which looks promising."
haskell,3dytzr,hamishmack,3,Mon Jul 20 21:01:21 2015 UTC,"I was very excited about LightTable when it came out. I think Atom pretty much killed it (though there is a little bit of activity still). Chris Granger moved his company onto a more ambitious project and I think they only have one person working on LT part-time.  I don't have a lot of experience using Atom with Haskell yet (in fact I don't have a lot of experience with Haskell period). I did get it set up using ghc-mod and showing me type info, using GHC 7.10 and ghc-mod master. That was a bit of a pain, but then ghc-mod in general has been a pain with 7.10.  I don't find it very difficult to jump between editors. I ""grew up"" on Emacs, and have also used Sublime Text for a significant period of time, but Atom has pretty much obsoleted it as far as I'm concerned (especially since I'm much happier using an open source editor than a proprietary one). My point is I don't know if I'm a very good person to tell you if it's worth it to move from vim to atom. But it's super easy to install and customize, so it's worth playing around with.  Other than Haskell, I do use Atom and Hydrogen ""in production"", and have for the last couple of months. It's been quite solid. It's crashed on me less (read: not at all) than Emacs on OS X has."
haskell,3dytzr,NiftyIon,3,Mon Jul 20 23:11:04 2015 UTC,"On the other hand, as a Vim user I've found that they have Vim bindings, which looks promising.   Can you list the vim bindings you need from most important to least important?  I had hoped Leksah would inherit Yi and CodeMirror's vim support, but it might be a good idea to add something to GtkSourceView for now (since both the Yi and CodeMirror integration work is stalled)."
haskell,3dytzr,hiptobecubic,4,Mon Jul 20 22:12:17 2015 UTC,"As a vim user, I have so many shortcuts and habits that I can't even list how many there are. Vim editing is a language - asking for the top used shortcuts is like asking for your list of top used Python functions.  The real way to get good vim support would be to embed NeoVim. I'm not sure if the project is mature enough for that, but if any IDE implemented that, I'd switch to it from vanilla vim immediately."
haskell,3dytzr,TheJonManley,3,Mon Jul 20 23:04:31 2015 UTC,"Yes. Excellent answer. I always try to explain to people that vim key binding emulation only gets you about 30% of the way there, but it never comes out this nicely."
haskell,3dytzr,sasquatch007,2,Tue Jul 21 03:30:33 2015 UTC,"I think the list will significantly differ depending on a person. For example, for me scrolling shortcuts are not that important, but for somebody with better scrolling habits they might be essential. That being said, this post on Stackoverflow seems to do a good job at demonstrating basic Vim keyboard shortcuts.   As you can see, there is a lot of them. Add to that what /u/NiftyIon said about Vim being like a language. You can combine those shortcuts in many ways like: ""cw"" = change until the end of the word; ""ciw"" = change the whole word under the cursor; ""ci("" change everything inside brackets; ""c2w"" = change next two words; 2w = ""move cursor two words right"". Combinations are endless.   In other words, it might take some work to implement it. So, before adding common Vim bindings to Leksah, perhaps you should try to investigate how many Vim users are currently not switching to Leksah because there are no Vim bindings there.  If I were to name one unintuitively important binding, then one of the most annoying things for me would be the lack of commands like "":wq"" or a scenario where "":q"" does not actually close the current tab / window or closes the whole editor instead of only the currently focused tab."
haskell,3dytzr,ephrion,1 point,Tue Jul 21 01:31:42 2015 UTC,"Can you list the vim bindings you need from most important to least important?   FWIW, I personally am not wedded to the Vim bindings themselves. What I am wedded to is that style of modal editing with composable commands, motions, and textobjects. And keyboard macros and registers.   In other words: I don't need a Vim emulator, but I do need an editor created by someone who understands Vim. I really couldn't care less if :wq and all that works.   (I'm not sure whether other Vim users would agree with me.)"
haskell,3dytzr,mallai,3,Tue Jul 21 21:01:15 2015 UTC,"Atom is ungodly slow and resource intensive. If you're used to the speed and responsiveness of vim, you'll likely be disappointed"
haskell,3dytzr,mjmrotek,4,Mon Jul 20 21:59:22 2015 UTC,That is no longer true. I work on a mid-size code base and everything is instant. It's as fast as Sublime now.
haskell,3dytzr,Darwin226,2,Tue Jul 21 00:29:29 2015 UTC,"It depends on the hardware, I guess. On my laptop it's quite slow compared do Vim, but the poor thing isn't exactly a speed demon."
haskell,3dytzr,codygman,3,Tue Jul 21 16:07:56 2015 UTC,"I haven't had a single problem with it's speed, but then again, starting the editor isn't really a bottleneck in my development process."
haskell,3dyfri,seriousreddit,4,Mon Jul 20 15:39:13 2015 UTC,"Hey, you are doing a lot of amazing stuff, please add a RSS feed to your blog so that i can follow your posts!"
haskell,3dyfri,liberalogica,4,Mon Jul 20 21:09:44 2015 UTC,Thanks so much for the kind words. Working on adding one presently.  For posterity: Just tested and I think the feed is working now.
haskell,3dyfri,liberalogica,1 point,Mon Jul 20 21:30:26 2015 UTC,Added.
haskell,3dyfri,sclv,2,Mon Jul 20 21:51:14 2015 UTC,"Thanks a lot! I cannot manage to have it working, anyway. When i go to your blog, i do not see any button pointing to a feed. In these cases usually RSS metadata are embedded in the post list, so i try to add http://parametricity.com/ to my RSS reader (i am using https://github.com/swanson/stringer which is ridiculously easy to deploy), but i get an error. It could be just a problem of caches, i do not want to take too much of your time about this. Thanks anyway!"
haskell,3dyfri,sclv,3,Tue Jul 21 12:52:59 2015 UTC,"Here is a way to examine if ""T being of fixed size"" is necessary -- just consider the case of a potentially infinite list, equipped with the ZipList applicative and the obvious traversable. Now consider if that works as a transformation for all applicative F.   I sort of suspect that it will work out ok, but I haven't checked?  (also note that fixed size traversable = representable, and in a sense you may be leveraging ""distribute"" as much as ""sequence""...)"
haskell,3dyfri,R0sborn,3,Tue Jul 21 02:13:10 2015 UTC,"Hm, well, my understanding from remarks made here and elsewhere was that any traversable T is equivalent to a so-called ""finitary container"". That is, T is equivalent to a functor of the form  X ↦ Σ (a : A) (X^(c(a)))   where c : A → Nat. The functor for possibly infinite lists is not of this form (and so is not traversable), though it strikes me I can't think of a very simple proof. Here is one though (I think it should work).  Take some kind of typical set theoretic model. I'm cavalier about impredicativity so I don't know if this actually works exactly. The cardinality of Σ (a : A) (1^(c(a))) is the cardinality of A.   The cardinality of L(1) is aleph0. Thus, if the two functors are equivalent, A has cardinality aleph0.   But then Σ (a : A) (2^(c(a))) is still countable while L(2) has cardinality continuum. It's a shame I can't think of a more ""type theoretic"" proof, whatever that means.  I suppose an easier way to see that it's not traversable is to observe that sequence (repeat (\_ -> do {x &lt;- get; put (x + 1)})) doesn't terminate (and I suppose sequence is supposed to be total).  P.S. Is there some way to write in TeX here?"
haskell,3dxxj3,benl23,2,Mon Jul 20 13:12:43 2015 UTC,So many interesting paper titles... So few preprints. :(
haskell,3dxxj3,rpglover64,7,Mon Jul 20 15:15:22 2015 UTC,We've put the University of Kansas FPG preprints on our lab website  http://ku-fpg.github.io/publications/
haskell,3dxxj3,andygillku,2,Mon Jul 20 16:40:05 2015 UTC,The Remote Monad paper looks exemplary. It's very welcome to see a paper analyzing existing code for patterns in the Related Work section.
haskell,3dxxj3,stephentetley,7,Mon Jul 20 21:47:37 2015 UTC,"Searching for paper titles is often quite successful. A Typechecker Plugin for Units of Measure is on my website, such as it is."
haskell,3dxxj3,adamgundry,3,Mon Jul 20 16:31:39 2015 UTC,"A bit late to the show, but here's mine: Déjà Fu: A Concurrency Testing Library for Haskell"
haskell,3dxxj3,Barrucadu,1 point,Mon Jul 20 22:15:15 2015 UTC,We'll forgive you :)
haskell,3dxxj3,jmct,5,Mon Jul 20 22:59:08 2015 UTC,I just put mine up on my webserver: Improving Implicit Parallelism  Let me know if there's any issues/typos/philosophical disagreements.
haskell,3dxxj3,jmct,1 point,Mon Jul 20 15:58:44 2015 UTC,"I managed to find most of them, which one were you looking for?"
haskell,3dxxj3,Lossy,2,Mon Jul 20 15:43:55 2015 UTC,I can't find Embedding a Full Linear Lambda Calculus in Haskell
haskell,3dxxj3,dogodel,2,Mon Jul 20 17:36:09 2015 UTC,http://functorial.com/Embedding-a-Full-Linear-Lambda-Calculus-in-Haskell/linearlam.pdf
haskell,3dxxj3,mutjida,2,Tue Jul 21 18:25:11 2015 UTC,"""Improving Haskell Types with SMT"" ""Guilt Free Ivory"" ""Variations on Variants"" ""Freer Monads, More Extensible Effects"" ""Functional Pearl: Getting a Quick Fix on Comonads""   I looked for these and didn't find them (though I can't say I scoured the farthest corners of the web)."
haskell,3dxxj3,rpglover64,4,Mon Jul 20 18:43:56 2015 UTC,"Guilt-Free Ivory: https://github.com/GaloisInc/ivory/tree/master/ivory-paper Comonads: Kenny's thesis version: http://bir.brandeis.edu/bitstream/handle/10192/30632/FonerThesis2015.pdf?sequence=3   So... Iavor, Trevor, Garrett, Oleg, and Kenny.  I sit next to three of them and can toss a rock at a forth.  EDIT:   Iavor's is on github: https://github.com/yav/type-nat-solver/tree/master/docs /u/kwef (Kenny) put his on github https://github.com/kwf/GQFC Trevor indicated he will post his somewhere, but the raw latex is already available (see above)"
haskell,3dxxj3,tom-md,2,Mon Jul 20 19:53:19 2015 UTC,"Thanks for the poke, /u/tom-md! Here's the camera-ready submitted version of my paper, with literate source code ready for anyone to ""play along"" with the paper text: https://github.com/kwf/GQFC."
haskell,3dxxj3,kwef,1 point,Mon Jul 20 22:50:43 2015 UTC,Thesis version of 'Getting a Quick Fix on Comonads' Related Boston Haskell meetup talk video
haskell,3dxxj3,LionTamingAccountant,1 point,Mon Jul 20 18:59:00 2015 UTC,is Practical probabilistic programming with monads available?
haskell,3dznm2,0Il0I0l0,8,Mon Jul 20 20:47:54 2015 UTC,"It seems to have something to do with the fact that [0..9] has the type Num a => [a]. If I use a concrete type, I don't get this behavior:  > let xs = [1 .. 9] :: [Int] > length xs 9 > :sprint xs xs = [1,2,3,4,5,6,7,8,9]   I have some intuition for why this might happen, but don't know enough about the GHCI internals to be sure."
haskell,3dznm2,carrutstick,4,Mon Jul 20 21:12:43 2015 UTC,The issue is that xs has a polymorphic type. Try this:  let xs = [0 :: Int .. 9]
haskell,3dznm2,sjanssen,3,Mon Jul 20 21:14:43 2015 UTC,"Hmm, at first I though there must be some mistake but I'm seeing the same behaviour, even with ':print' instead of ':sprint'.  I've used this functionality before and had it work. What version of GHC are you using?"
haskell,3dznm2,jmct,1 point,Mon Jul 20 21:03:44 2015 UTC,"The Glorious Glasgow Haskell Compilation System, version 7.10.1"
haskell,3dznm2,jmct,5,Mon Jul 20 21:11:30 2015 UTC,"As the others have mentioned, it has to do with the polymorphic type of the list. I feel silly for not having realised.  Because of the overloading, xs is actually a function that takes the dictionary providing the Num operators for the type.  Edit: See Oleg's tutorial on ""Demystifying Typeclasses"""
haskell,3dznm2,briennetarth,4,Mon Jul 20 21:25:10 2015 UTC,"It's not what's going on in your example but I'm pretty sure that :sprint is buggy.  Or I don't understand how it's supposed to work.  >let a = [1+0, 1+1, trace ""hi"" $ 1+2] :: [Int] >:sprint a a = [_,_,_] >let b = [chr 42, chr 43, trace ""hi"" $ chr 44] :: String >:sprint b b = ""*+hi ,"" >--wtf >"
haskell,3dycc2,creichert,6,Mon Jul 20 15:13:33 2015 UTC,Are there any plans to integrate with the hackage-security project?
haskell,3dycc2,cocreature,9,Mon Jul 20 16:12:37 2015 UTC,"Not currently. Without getting into the details or merits of the hackage-security implementation of TUF, the essential point is that while conceptually pretty close to what stack already does, the channels for distributing trust are completely different. Stack uses GnuPG keys, relies on Git to disseminate signatures born from those keys, and leverages all the existing infrastructure (e.g. key servers) for disseminating trust in those keys. hackage-security uses its own key type using (AFAIU) its own format, with key signatures disseminated using a custom mechanism specific to Hackage and trust in those keys also disseminated outside of GnuPG's existing infrastructure for building webs of trust.  So ultimately we're talking about adding two completely different implementations to stack, if security is done end-to-end using hackage-security. Independent of the relative merits of each approach, we're talking about a lot of extra code to support both. And when it comes to security, the most secure code is the code that wasn't written. For this reason, it's unlikely that stack will include two implementations of the same conceptual model.  hackage-security could in theory be used for the mirroring part. This would be a good idea I think, and would increase the authenticity guarantees of the data that gets mirrored into the git repo that stack uses. But that's not an answer to whether stack itself could use hackage-security."
haskell,3dycc2,mboes,7,Mon Jul 20 17:38:54 2015 UTC,"I can't speak for the stack authors but here are the obvious options:   have stack use the hackage-security library so that stack can read hackage format repositories natively, including the security features and automatic use of mirrors. have the tool that mirrors from the upstream repository (in hackage format) to the stack mirror (in stack repository format) use the hackage-security library to ensure security between hackage and the stack mirror.   Currently stack uses a different repository format based on a git repository. The first option would allow stack to read not just the central hackage repo directly, but also other repos that people set up (e.g. using the cli tools available to create secure hackage format repos to serve using plain http file servers)."
haskell,3dycc2,dcoutts,2,Mon Jul 20 17:03:16 2015 UTC,"I'd be surprised, as that would violate the NIH principle... 😈"
haskell,3dycc2,hagda,1 point,Tue Jul 21 09:24:39 2015 UTC,"Who invented what where, and when?  And if we can get an answer to ""why,"" that will cover all 5 Ws :-D"
haskell,3dxwyh,Helios337,22,Mon Jul 20 13:07:19 2015 UTC,"I would argue most non-programmer's first programming language is...the spreadsheet, which is actually at a high level very much like a functional programming language.  We have all had the experience of starting with data in one column and mapping that data through a series of operations to transformed data. And all the operations are immutable just like a pure functional programming language.   When you think of it this way, is it a coincidence that the words Excel and Haskell sound so much alike? (I keed, I keed)"
haskell,3dxwyh,thecity2,4,Mon Jul 20 15:19:26 2015 UTC,That's a really interesting way of looking at that. Thanks for the input!
haskell,3dxwyh,dohaqatar7,3,Mon Jul 20 15:20:54 2015 UTC,Putting it like that makes me really want a version of Excel that uses Haskell for formulas.
haskell,3dxwyh,Tekmo,1 point,Mon Jul 20 17:22:39 2015 UTC,You can come pretty close with this.
haskell,3dxwyh,kqr,2,Mon Jul 20 18:46:57 2015 UTC,"And even now, with 10+ years experience, I've been prototyping algorithms in Excel because it gives me convenient access to visualisation tools."
haskell,3dxwyh,Vetii,9,Mon Jul 20 23:36:45 2015 UTC,"Interesting question. Isn't Haskell taught in introductory programming course in many universities (Oxford, etc.)?   I suppose the type system would be beneficial for non-programmers. The ""always make it a function"" approach has been very beneficial for me, even in imperative languages."
haskell,3dxwyh,ocramz,6,Mon Jul 20 13:40:44 2015 UTC,"Honestly, this is the first time I hear about Hs being taught as a first language. What other examples do you know of?"
haskell,3dxwyh,cies010,13,Mon Jul 20 14:06:02 2015 UTC,I was also the introduction to programming in UoT. But they switched to Java...  It pissed Dijstra off to the extend that he wrote an memorable letter: http://chrisdone.com/posts/dijkstra-haskell-java
haskell,3dxwyh,ocramz,6,Mon Jul 20 14:56:23 2015 UTC,"we are presently having the same discussion within my research group, but I come across as the weird one. ""Haskell has no support! no libraries! you'll be alone if you use it!"""
haskell,3dxwyh,cies010,6,Mon Jul 20 15:02:45 2015 UTC,"Sad, sad. There are some pictures that show different:  1) Across the threshold of immortality  http://www.quora.com/What-do-you-think-is-impeding-Haskell-from-getting-mainstream-adoption-Will-it-ever  2) Everybody talks about it (on reddit), and it is more ""high level""  https://github.com/Dobiasd/programming-language-subreddits-and-their-choice-of-words  3) Right on the heels of the big guys  http://www.dataists.com/2010/12/ranking-the-popularity-of-programming-langauges/"
haskell,3dxwyh,gilmi,3,Mon Jul 20 15:15:17 2015 UTC,Even though it has one of the bigger communities on reddit related to programming and one of the bigger irc channels on freenode?
haskell,3dxwyh,hexbienium,4,Mon Jul 20 15:20:20 2015 UTC,"The University of Chicago's ""Honors Introduction to Computer Science"" starts with Haskell."
haskell,3dxwyh,Drezil,3,Mon Jul 20 14:32:47 2015 UTC,Bielefeld University in Germany
haskell,3dxwyh,Feminazgul1,2,Mon Jul 20 16:48:32 2015 UTC,"I study cs in Sweden, we learn haskell as a first language. I think a big reason for this though is that it is sort of unknown, so even students who have programmed a lot previously is new to it."
haskell,3dxwyh,theonlycosmonaut,1 point,Tue Jul 21 11:28:13 2015 UTC,Pretty sure UNSW and ANU do or did use Haskell in introductory classes. That's just anecdotal though.
haskell,3dxwyh,kamatsu,2,Mon Jul 20 22:01:32 2015 UTC,"UNSW did, but now uses C (and this may change again to Python :(), ANU still does IIRC."
haskell,3dxwyh,Crandom,0,Tue Jul 21 04:44:43 2015 UTC,Basically every university in the UK.
haskell,3dxwyh,ocramz,2,Mon Jul 20 14:36:46 2015 UTC,"Great news! Now, let's restrict the scope to non-CS schools. How many of these do you know of that even mention Haskell? E.g. up until my MScEE there was no mention whatsoever of even the word ""functional"". C, Java, Matlab, you name it, even bloody TCL, but no functional. I arrived at it by myself by first using a simulator that's scripted in Scheme, then getting real high on Common Lisp for a while."
haskell,3dxwyh,Crandom,1 point,Mon Jul 20 14:42:47 2015 UTC,"Are you outside the UK by any chance? My experience is UK universities are very functionally focused, where as other countries (particularly in the US) have more focus on C and other low level imperative stuff (with a couple of notable exceptions, like CMU).  EE seems like it would go for a lower level approach, as you normally need low level access to ports/code that will work on an embedded system (I guess?). I did CS, but did a reasonable amount of simulation of hardware which was all done in haskell."
haskell,3dxwyh,mu_mu_lambda,1 point,Mon Jul 20 15:41:10 2015 UTC,Derby definitely doesn't and I'm pretty sure neither does Notts Trent. Or Liverpool and Sheffield. Those are the only ones I'm fairly sure of. Most places use C#/Java. The only ones I know of that do Haskell as a first choice are Oxford and Uni of Nottingham
haskell,3dxwyh,JS1011,4,Mon Jul 20 16:24:42 2015 UTC,"Just finished first year at Uni of Nottingham, we did C, Haskell and Java. For anyone interested I had Graham Hutton as my course leader and he was a brilliant teacher and the course was based on his book, which I would thoroughly recommend to anyone who wants to get started with Haskell."
haskell,3dxwyh,mcapodici,1 point,Mon Jul 20 20:37:12 2015 UTC,"+1 for Graham Hutton, albeit I took his course in 2000 :-)"
haskell,3dxwyh,mu_mu_lambda,1 point,Mon Jul 20 20:42:32 2015 UTC,"Yeah I've met some of the Nottingham staff/students at various user groups, they all seem ridiculous smart. Bastards. He wrote Programming in Haskell too"
haskell,3dxwyh,Crandom,2,Mon Jul 20 20:59:17 2015 UTC,"Oxford, Cambridge, Imperial, Edinburgh, Glasgow, St Andrews, Warwick, Southampton and Nottingham are the ones I know of. They are a good selection of the top universities for CS, at least."
haskell,3dxwyh,bradley_hardy,2,Mon Jul 20 16:48:00 2015 UTC,"Cambridge doesn't, we do SML instead."
haskell,3dxwyh,DujekR,2,Mon Jul 20 19:25:20 2015 UTC,St Andrews doesn't
haskell,3dxwyh,Crandom,1 point,Mon Jul 20 19:42:39 2015 UTC,"Really? Tbf, I'm going off by what I was told at open days now more than 6 years ago."
haskell,3dxwyh,ozgurakgun,1 point,Mon Jul 20 19:48:50 2015 UTC,"St Andrews doesn't start with Haskell, but there is a module for 3rd years which introduces Haskell and Python."
haskell,3dxwyh,jamlothar,9,Mon Jul 20 21:29:42 2015 UTC,"Functional programming is super easy for total beginners. I taught Lisp to both children and adults with no prior knowledge of programming and it was very easy for them. We used an approach based on this book: http://realmofracket.com/  Now, Haskell is of course far more complex than Lisp. For me, the very sophisticated type system make it more difficult for beginners. Moreover, the type system solves problems they are not yet aware as total beginners. This might confuse them to have to think with types while they still don't understand the value of doing it."
haskell,3dxwyh,ocramz,2,Mon Jul 20 13:53:56 2015 UTC,"I want to believe you are right. Instead, one that first learns  imperative langs must be de-wired to think functionally.   Still I think that introducing in order GHCi through :t , lambda expressions and partial evaluation can build up a solid base and in few pages to a total beginner.   I am writing a 20-page tutorial that includes this, plus pattern matching and recursive functions, datatypes as functions, pure vs IO, and Monad as ""datatype of chainable computations"".  No pictures but the beginning is written as a GHCi type-along thing, the bare minimum of formal definitions, program reductions etc., just tons of REPL and a half-page ""database"" program to showcase most of the stuff mentioned before.    Wrote it in .lhs, but it would be cool to turn it into an iHaskell notebook or even better a ""live"" format for the browser."
haskell,3dxwyh,Tayacan,8,Mon Jul 20 21:42:35 2015 UTC,"This is an interesting testimonial.  My university has so far taught Standard ML as the first language, although some students have programming experience - often in Java - when they start. This seems to have been working well - DIKU produces competent people. They're changing the introductory course to use F# this year, though, which will be interesting."
haskell,3dxwyh,tejon,3,Mon Jul 20 13:54:24 2015 UTC,"This is an interesting testimonial.   Note also that she went on to teach Haskell to her 10-year-old, and is now the co-author of this book (the other author being Chris Allen of bitemyapp fame)."
haskell,3dxwyh,gilmi,7,Mon Jul 20 21:12:33 2015 UTC,"That depends. I don't think learning Haskell by oneself is going to be easy, not because of the language, but because of the available resources. With a proper teacher/mentor it might be easier.  Also, for beginners I think that being able to do a lot with a programming language, especially visually, is important. That's why I don't think C is a good fit either. (also, there are too many bad resources to learn C from).  Today, I would probably recommend Racket. It has a fairly simple core, you can do a lot with it and it has great resources to learn from (HtDP, Racket docs, etc.). It also has a pretty good GUI IDE."
haskell,3dxwyh,cies010,7,Mon Jul 20 14:58:37 2015 UTC,"There's also CodeWorld, written in Haskell and provides a  language that is in some ways close to Haskell (but explicitly targets beginners).  https://codeworld.info   main   = pictureOf(forest) forest =   translate(tree, -5, 5)          & translate(tree,  0, 0)          & translate(tree,  5,-5) tree   = color(leaves, green) & color(trunk, brown) leaves = sector(0, 180, 4) trunk  = solidRectangle(1, 4)"
haskell,3dxwyh,pbvas,7,Mon Jul 20 14:59:52 2015 UTC,"Is Haskell a good choice as a first programming language?    One of the problems with this question is that answering depends on what you assumptions are about what should be taught/learned in a first programming course.   Some people take a more mathematical view and place the emphasis on logic, functions, algebraic reasoning  and will answer ""yes"". This is indeed what you have in many UK CS courses and in textbooks such as Richard Bird's ""Thinking Functionally"". This can work well with Haskell (or SML or maybe even Scheme).  Others will say that an operational view of computer should be taught first; they will argue for some for of (real or toy) assembly language/C combination.   A third alternative is the ""object's first"" approach, which will start with Java (or maybe something like Python). This is in my opinion the least desirable choice because it combines the distance from the hardware with the lack of any mathematical precision..."
haskell,3dxwyh,jlimperg,4,Mon Jul 20 16:47:43 2015 UTC,"One issue to be aware of is that there aren't many (if any) books teaching Haskell as a first language. Rather, most assume that readers have some sort of imperative programming background, which I imagine would make them very difficult to follow for a complete novice without a personal instructor."
haskell,3dxwyh,_AndrewC_,2,Mon Jul 20 14:47:21 2015 UTC,Bird and Wadler don't assume any programming knowledge.
haskell,3dxwyh,rdfox,4,Mon Jul 20 15:52:40 2015 UTC,"Maybe if I could go back and unlearn programming, I could finally master haskell."
haskell,3dxwyh,Denommus,6,Tue Jul 21 01:53:31 2015 UTC,"I think a functional language might be a good choice as a first language, but not Haskell. Maybe Standard ML would be better."
haskell,3dxwyh,jmite,13,Mon Jul 20 13:09:20 2015 UTC,"I'd reccomend Elm, it specifically tries to be beginner friendly, and it's easy to try out in the browser. It's close to ML as a language (strong types, strict)"
haskell,3dxwyh,cies010,4,Mon Jul 20 14:09:08 2015 UTC,"I second this. And the ""all in the browser"" experience is also great for starters:  http://debug.elm-lang.org/edit/Mario.elm  I don't know how hard elm is for those not knowing HTML/CSS. I know elm allows one to do with HTML/CSS, but still it helps me a lot knowing what it compiles to."
haskell,3dxwyh,ocramz,2,Mon Jul 20 14:54:09 2015 UTC,"Hey, what about http://ghc.io ? Safe haskell, all in browser."
haskell,3dxwyh,tejon,4,Mon Jul 20 15:03:32 2015 UTC,"Welcome to GHC.IO! Prelude> import Diagrams.Prelude Could not find module `Diagrams.Prelude' It is not a module in the current program, or in any known package.   ...and in the other one, I get to make Mario jump."
haskell,3dxwyh,ocramz,1 point,Mon Jul 20 20:59:18 2015 UTC,"yeah, you have a point. So what's missing to making a live in-browser game dev bench? Editor, REPL to the left, game on the right. One of those reactive thingies from the FRP Zoo, would it render e.g. to javascript?"
haskell,3dxwyh,tejon,2,Mon Jul 20 21:28:34 2015 UTC,Paging /u/ryantrinkle :)
haskell,3dxwyh,ryantrinkle,1 point,Mon Jul 20 21:46:36 2015 UTC,"Thanks, /u/tejon!  To /u/ocramz's question: it sounds a lot like http://markup.rocks/, which was built by /u/meegee using Pandoc and Reflex-Dom.  I think it's a great model, especially for helping beginners get into Haskell."
haskell,3dxwyh,gilmi,2,Mon Jul 20 23:13:47 2015 UTC,Why SML but not Haskell?
haskell,3dxwyh,Denommus,2,Mon Jul 20 15:07:32 2015 UTC,"Haskell has a lot more complexity than the fact of being pure. Lazyness, lots of syntax sugar, among other things.  SML is very, very simple. I also think that functors are more approachable than typeclasses, and of course they're more general."
haskell,3dxwyh,kamatsu,0,Mon Jul 20 17:22:19 2015 UTC,A lot easier to teach abstraction when you actually have it ducks
haskell,3dxwyh,kqr,4,Tue Jul 21 04:47:49 2015 UTC,"Based on the few samples I have observed myself: it depends.  Some people find it much easier to pick up declarative languages like Haskell, Prolog or Erlang. Others find it easier to pick up imperative languages like Java or Python. The difference is striking, really."
haskell,3dxwyh,0Il0I0l0,3,Mon Jul 20 13:38:20 2015 UTC,Anecdotal:  My CS professor uses Standard ML to teach a class for non-cs majors because he thinks they learn it much better (he teaches python in the Intro to CS class). He also used to teach Haskell in the Intro to CS class in the 90s before Java got big and Haskell was changed to Java because students thought it was more relevant to getting a job.
haskell,3dxwyh,sasquatch007,3,Mon Jul 20 16:33:34 2015 UTC,"I just have a hard time seeing how functional programming would be good to learn for a first language.   Functional programming has always seemed much more natural to me, even though my first languages were C and Python. I've never quite understood what people find so strange or difficult about functional programming. For most people, I suspect they find it difficult just because it's not what they're used to and it's hard to change. There's no reason they would have found it harder to start with a functional language than an imperative one.   Whether Haskell itself is a good first choice: that's another question. But under the right circumstances, yes, I think so."
haskell,3dxwyh,leitimmel,1 point,Mon Jul 20 19:32:08 2015 UTC,"For me the problem has never been the concept of FP, but how to apply it: How do I parse command line arguments? Or actually get anything done? Most examples are like one short introductory paragraph and then you get [advanced|obfuscated] monad operations without further explanation."
haskell,3dxwyh,PM_ME_UR_OBSIDIAN,2,Tue Jul 21 23:01:38 2015 UTC,"Haskell has this ""final boss"" quality to it. I think it would be usable as a first language, but only within a suitable execution harness and with ""adult supervision"". At that point though, any language would do.  I'd recommend an ML like F# or Standard ML instead."
haskell,3dxwyh,zarazek,3,Mon Jul 20 16:12:39 2015 UTC,"Yes. If you are non-programmer, it doesn't matter in which particular language you are going to non-program. Feel free to use Haskell."
haskell,3dxwyh,twistier,1 point,Tue Jul 21 10:58:22 2015 UTC,"I'm not trying to make too strong of a point with a mere anecdote, but my non-programmer wife thinks it's absolutely bonkers that people use programming languages with uncontrolled mutation. She doesn't understand how to think about a program where this thing you defined might not have the same definition later."
haskell,3dxwyh,twistier,1 point,Mon Jul 20 23:44:09 2015 UTC,Could you give me an example? I can't think of a time where that has happened to me.
haskell,3dxwyh,ephrion,1 point,Mon Jul 20 23:45:34 2015 UTC,"I'm not sure what you are asking, really. Are you looking for an example of mutation?"
haskell,3dxwyh,ephrion,2,Tue Jul 21 00:38:20 2015 UTC,"Oh, I'm sorry, I misunderstood what you meant. I haven't slept all day, I need my coffee."
haskell,3dzip9,baguasquirrel,10,Mon Jul 20 20:13:11 2015 UTC,"Use the Applicative instance of (a ->)!  liftA2 (||) f g = \x -> f x || g x   For longer argument chains you can use Traversable,  fmap or (sequence [f,g,h]) = \x -> f x || g x || h x"
haskell,3dzip9,quchen,3,Mon Jul 20 20:50:53 2015 UTC,"Does anyone actually find these applicative/traversable versions easier to work with?  They look hideous to me.  FWIW, in SubHask, the (||) and (&&) operators are overoaded to work on any Lattice.  This lets you write things like f || (g && h) directly, with no syntactic overhead."
haskell,3dzip9,PokerPirate,4,Mon Jul 20 23:59:33 2015 UTC,"The applicative style I don’t mind [edit: even when it comes to the arrow instance], the liftA* HOFs I like a little bit less. As for Traversable I don’t like the loss of static information when turning a finite number of things into a sequence of 0 or more—esp. when that sequence is immediately consumed anyway.  And of course lists-as-tuples breaks down for actual tuples, i.e. when the elements are not necessarily homogeneous. You can  ((!!) <$> const ""Hello"" <*> const 0) ()   but you can’t  (fmap (!!) $ sequence [const ""Hello"", const 0]) ()"
haskell,3dzip9,dashend,2,Tue Jul 21 00:41:06 2015 UTC,Applicative in general is nice; I just don't think it makes any sense for the OP.
haskell,3dzip9,PokerPirate,8,Tue Jul 21 00:45:48 2015 UTC,"I usually do  or . sequence [f,  g,  h]    but I don't see anything too bad with   \x -> any ($ x) [f, g, h]   if you want to use Alternative (or MonadPlus) just for funsies, you can do  isJust . asum . mapM mfilter [f, g, h] . Just"
haskell,3dzip9,mstksg,3,Mon Jul 20 21:36:59 2015 UTC,I love the ($ x) trick.
haskell,3dzip9,joehillen,1 point,Tue Jul 21 06:52:25 2015 UTC,I have also use the second one.
haskell,3dzip9,codygman,8,Tue Jul 21 16:35:33 2015 UTC,"> let f = (>4) :: Int -> Bool > let g = (<10) :: Int -> Bool  > import Control.Applicative > let fAndG = liftA2 (&&) f g > filter fAndG [0..100]     [5,6,7,8,9]"
haskell,3dzip9,gelisam,6,Mon Jul 20 20:26:02 2015 UTC,"As others have mentioned, the Applicative instance for a -> can be used for this. I sometimes define a lifted version in a where:  f = x ^||^ y   where     (^||^) = liftA2 (||)"
haskell,3dzip9,cameleon,7,Mon Jul 20 21:11:45 2015 UTC,"I prefer <||>, in analogy with <$> and others."
haskell,3dzip9,kqr,2,Tue Jul 21 10:24:50 2015 UTC,"I agree, that's a better choice."
haskell,3dzip9,cameleon,3,Tue Jul 21 13:04:05 2015 UTC,"You can always use Monoid instances (specifically the instance for a -> Any:  combineWithOr :: [a -> Bool] -> a -> Bool combineWithOr = combineWithOr = (getAny .) . mconcat . map (Any .)   Probably not exactly what you're looking for here, but I thought it would be worth bringing up."
haskell,3dx522,hamishmack,8,Mon Jul 20 07:04:23 2015 UTC,Is it stack-aware?
haskell,3dx522,cies010,4,Mon Jul 20 11:52:56 2015 UTC,and them they ask what is wrong with 10 tools doing the same thing…
haskell,3dx522,tailbalance,1 point,Mon Jul 20 20:26:35 2015 UTC,i dont get yr point.
haskell,3dx522,cies010,2,Tue Jul 21 07:57:12 2015 UTC,Not yet.
haskell,3dx522,agocorona,3,Mon Jul 20 22:45:56 2015 UTC,Great  The  bug eating memory and CPU  has been solved?
haskell,3dx522,agocorona,3,Mon Jul 20 09:24:20 2015 UTC,"Maybe.  I did fix a race condition that could result in multiple builds running at once.  I also have observed the OS X version getting into a state where it cannot terminate cabal with an INT signal.  I got it to output the process ID to the console and tried to use kill on it and only TERM seemed to work.  Very odd, not sure what could change in Leksah that could cause the child process to ignore INT.  I was tempted to turn the code that polls the state of open files on disk (as I suspect that might be related to the memory issue).  Instead I tried to make it less frequent.  I'll add an option to switch it on and off next weekend (that should make it easier to test)."
haskell,3dx522,SirWanksALot,1 point,Mon Jul 20 10:19:02 2015 UTC,Ok.   I will check it out as soon as I can have a good internet connection.
haskell,3dx522,danielsmw,3,Mon Jul 20 14:08:08 2015 UTC,A bit offtopic. Are there an easier way to install it in archlinux instead of using AUR? (don't want to install the 20+ aur packages it needs..)
haskell,3dx522,SirWanksALot,2,Mon Jul 20 11:34:17 2015 UTC,"Well this doesn't solve the problem right now, but you could always vote for it on the AUR! Do you want to avoid the dependencies because it's a hassle to install them all or because you don't want to clutter your system? If the former, you could always use pacaur or some other AUR interface."
haskell,3dz599,glimming,4,Mon Jul 20 18:37:03 2015 UTC,"Broken link: ""Not authorized for job posting 60296037"""
haskell,3dz599,gelisam,2,Mon Jul 20 20:10:21 2015 UTC,"Same here, and I'm logged in to LinkedIn."
haskell,3dz599,radix,3,Mon Jul 20 23:19:25 2015 UTC,"Hi folks,  There are openings at Functor, Sweden, including also remote work, except for Scala consultants who must immediately relocate:  Do you want to be part of the journey as the Functor startup research spin-off innovates the future of software engineering? Do you want to make a difference? Do you want to devote your talents where it can have incredible impact on the entire software industry? Functor, Sweden, is again looking for brilliant minds, essentially co-founders as a generous equity program will after a certain threshold time make sure developers, building the company indeed, also own what they are building.  Please apply on LinkedIn, closing soon take action if interested: https://www.linkedin.com/jobs2/consumer/overview/60296037   We use Haskell, OCaml, LLVM and our tools are closely tied to the C programming language and indeed to functional programming.  Embedded software market is one target market, and skills in compiler design, type systems and operational semantics is key to our teams though we look for optimised teams as a whole, and your particular skill set may or may not include a PhD, but surely industrial experience. We have openings for Research Engineers and  have some renown Research Engineers already. Research collaboration is key to our success and projects planned including a large EU project CONSTRUCTOR next year. We have strong industrial partners and some very high-profile customers internationally. The customer-driven journey is still at an early stage, while founded in 2011, and your contributions would be key to our success.  Scala consultants will be sent straight from the top down into projects at Ericsson for very challenging work. For these three consultants we require an exceptionally strong background with Scala projects as we team up with Typesafe and secure projects that can only be matched by exceptional Scala developers. Our Functor Scalor™ is oriented somewhat differently than Scala, see www.domainspecific.org for some initial information on that products that appeals to very large companies at this stage, while Functor Prevent™ is suitable for just about any software development projects, currently doing static analysis with dependent types and automatic testing for C code, such as the Erlang code base, Twitter’s MySQL branch or embedded software at large, see www.functorprevent.com or www.static-analysis.org, and also the standalone tool www.functor.se/prevent which secures systems including a project at a customer with a range of 100 MEUR/each equipment investments, all relying on the VxWorks C code where our Functor Prevent™ delivers its value to prevent up to 50% of the bugs in certain projects, already with its current R1 feature set!  Instructions and information, please read carefully the last paragraph on what we need to evaluate candidates adequately: https://www.linkedin.com/pulse/openings-functional-programmers-swedish-startup-johan-glimming   Read up with links above to our webpages (last link), and postings on LinkedIn and Facebook: https://www.linkedin.com/pulse/future-software-engineering-johan-glimming?trk=mp-reader-card  Facebook eg: http://www.facebook.com/functor  Webpage has more information, linked to one the main posting above for some key webpages to check: www.functor.se   Welcome to apply and be part of an exciting journey ahead with a very important mission to turn software engineering into a discipline at last, backed by industrial productification for years and R&D that have never reached the software industry due to its inherent complexity, now mature, and now with proven market fit with Functor Prevent™ and Functor Scalor™ being used in heavy duty projects but much more to come! It’s Martin-Löf / dependent type theory inside our tools.  Yours Sincerely, Johan Glimming  PS. Contact details included, but please follow the application procedure if you are an applicant, rather than leaping ahead already. Give us a little bit of time and we'll get there! :-)  —   Dr Johan Glimming  Chief Executive Officer at Functor AB, Chairman at Functor Group AB  Request a meeting or schedule a call: www.doodle.com/glimming  Mobile:  +46-76-7646000 Direct: +46-8-55005505 Main:  +46-8-55005500 Assistant: +46-8-55005501  Skype:  glimming Twitter:  @glimming  LinkedIn:  se.linkedin.com/in/glimming   Functor AB, Box 7070, 164 07 Kista, SWEDEN  Web:  www.functorgroup.com Twitter:  @functors  UK tel:  +44-1223-911400 US tel:  +1-(415)-513-0090"
haskell,3dxqqs,ocramz,5,Mon Jul 20 12:07:10 2015 UTC,"The mutation is inevitable, but you can wrap it in a function that allocates new memory, passes it in, and then returns that mutated result"
haskell,3dxqqs,singpolyma,2,Mon Jul 20 12:16:29 2015 UTC,"I'd rather not copy systematically stuff around as the underlying structures might become quite big and these functions might be called from within loops (the above example represents a single linear solve). However, let's say I write withA = bracket createA destroyA (of type (A -> IO A) -> IO ()), and in the body of withA I do the mutations, allocate memory for the result, copy it there and return it. Does escaping the bracket garbage collect for the A right away? Were you referring to such a setting?"
haskell,3dxqqs,gelisam,6,Mon Jul 20 12:32:39 2015 UTC,"Let's start from the beginning. What do you mean by ""How can I improve this, in order to achieve purely-functional signatures""? I thought you wanted something without any IO, IORef or other mutable stuff, but the fact that you mention the type signature (A -> IO A) -> IO () makes me think that you might mean something else."
haskell,3dxqqs,gelisam,1 point,Mon Jul 20 15:25:04 2015 UTC,"Yes, sorry, let me rephrase. Now I'm returning in IO just to test the orchestration of groups of calls, but I'd like datatypes that encapsulate my representation of pointers (newtype A = A (Ptr A) deriving Storable with GNT on), and carry around other properties as well, such as the fact that data has changed across a function, the possibility of logging (which here would imply making copies of MPI-distributed arrays, potentially very large) along with some algebraic properties of the operands, for the pure subset of FFI calls. I guess this should be a stack of monad transformers?"
haskell,3dxqqs,gelisam,2,Mon Jul 20 22:05:00 2015 UTC,"I still don't understand the difference between what you want and what you have. Are you using newtype A = A (Ptr Int) and you would like to use something else instead, or are you using A and you don't like the fact that you have to run Ptr-related operations in the IO monad?   I guess this should be a stack of monad transformers?   Will you still be happy if the innermost layer of your monad stack is IO?"
haskell,3dxqqs,gelisam,2,Mon Jul 20 22:39:50 2015 UTC,"No I don't have to do Ptr operations anymore. I used with , withPtr etc throughout and the types are mapped with an inline-c Context, so now I am passing newtypes around.  I'm afraid I can't do without the innermost IO layer, but surely I'm missing something here. Could you give an example please?"
haskell,3dveyb,sdroege_,13,Sun Jul 19 21:13:36 2015 UTC,This was a helpful post; I wish I had it on hand when using conduit for a small project a few months back. The conduit/conduit-combinators distinction was definitely confusing.
haskell,3dveyb,MaxGabriel,23,Sun Jul 19 23:26:03 2015 UTC,"This comment encouraged me to add some comments to the READMEs for the relevant projects (conduit, conduit-extra, and conduit-combinators) explaining the breakdown among those three, which is essentially:   conduit: core abstraction, minimal dependencies conduit-extra: light-dependency helper functions conduit-combinators: the fully-powered abstraction, which I recommend using, when you can handle having quite a few extra dependencies   EDIT I'm posting this to Reddit before just modifying the READMEs in the hope that someone will ask me some clarifying questions that will help me improve the text I'll end up writing. So fire away!"
haskell,3dveyb,snoyberg,3,Mon Jul 20 04:14:05 2015 UTC,"This kind of general overview would be really helpful for someone starting out (I still count myself as on of those). Often times it is not at all clear which seemingly equivalent module to use.   One suggestion (in case this is not what you were going to write anyway): for beginners it is perhaps helpful to say something like ""light dependency helper functions allowing you to simply do xyz, for example."" Or ""fully powered such that 123 is possible"" I know this can get out of hand and by browsing all the functions explicitly I would obtain that info, but as an (non-exhaustive) overview I think it would make life much easier for many.  Either way, thanks a lot!"
haskell,3dveyb,kyxxx,4,Mon Jul 20 09:54:59 2015 UTC,"I have a proposed new README for the conduit project as a whole at:  https://github.com/snoyberg/conduit/tree/include-tutorial#readme  I think it gives enough of this information, but suggestions are welcome. /u/MaxGabriel and /u/ndmitchell may be interested as well."
haskell,3dveyb,snoyberg,2,Mon Jul 20 16:49:44 2015 UTC,"The new REAMDE looks great. The only comment I have is that the School of Haskell markup doesn't work in the README; stuff like ""@@@ SHOW SOLUTION"" should probably be deleted, and the code samples would be better with comments showing their return value (since School of Haskell isn't evaluating the code for you anymore)."
haskell,3dveyb,MaxGabriel,1 point,Mon Jul 20 20:19:32 2015 UTC,"Good comments, agreed on all fronts. I'll try to get to that tonight or tomorrow and then merge it in to master."
haskell,3dveyb,snoyberg,1 point,Mon Jul 20 22:00:14 2015 UTC,"That is indeed a very nice doc/tutorial. A little thing: knowing how I got hung up/delayed by such things in the past, perhaps it is worthwhile mentioning this:  **Primitives** await will take a single value from upstream, if available, that is *wrapped in Maybe*.   This is a not very elegant phrasing, but the reason is that in the preceding section the idea was introduced that ConduitM passes on the ""underlying monad"", which in the example is IO. Yet, there appear Justs in the example. Of course one could check the type signature of await, but I guess it might help making it clear in the description of await?"
haskell,3dveyb,kyxxx,8,Tue Jul 21 07:32:38 2015 UTC,"I've been looking for a Conduit/Pipes api to reading tar files, but all of the code I can find prefers using Codec.Archive.Tar and lazy IO.  Even the stack source has a comment which implies that using lazy IO provides some advantages over ResourceT (link).  There is also this github repo: https://github.com/jhance/tar-conduit  but I'm not sure what condition it's in."
haskell,3dveyb,mn-haskell-guy,10,Mon Jul 20 02:05:05 2015 UTC,Sounds like I need to finish and release http://github.com/ocharles/pipes-tar...
haskell,3dveyb,ocharles,4,Mon Jul 20 08:32:23 2015 UTC,"Actually, the comment was meant to imply the opposite: I didn't use ResourceT there like I should have, instead just using normal lazy I/O. Thus the caveat emptor: you can leak file descriptors if something goes wrong. In the case of stack, that's somewhat irrelevant though, since stack is (generally) not used in a long-running process.  I'd love some kind of incremental tar processing library that could be used by conduit and pipes. I don't think the tar-conduit package is production quality, though I'd love to be proven wrong."
haskell,3dveyb,snoyberg,2,Mon Jul 20 04:12:43 2015 UTC,"I defined tarballReadFiles in https://github.com/ndmitchell/hoogle/blob/master/src/General/Util.hs and then just sourceList it. It works nicely, although isn't resource safe and uses lazy IO - but if you immediately convert to conduit that doesn't seem to matter in practice."
haskell,3dveyb,ndmitchell,7,Mon Jul 20 06:10:39 2015 UTC,"I am curious if all Pipes users get asked ""Why not use Conduit?""   Probably not, because pipes users don't seem to feel the urge to publicize they're using them... =))  But nevertheless, I think it's a valid question to ask in order to learn about the relative merits (and maybe pipes can steal some of the good parts of conduits it hasn't yet... =), but so far I am quite happy with the pipes API which feels much more consistent than conduit with its traces of historic cruft )   I realise pipes are billed as the more ""principled"" choice for this type of programming, but I've yet to see anywhere Conduit seems fundamentally unprincipled.   This can be said about many concepts in Haskell can't it? The question for me is rather what the cost of being more principled with pipes is relative to using the ""unprincipled"" conduit... so far the additional cost I notice with pipes is that there's a bit less packages with pipes support than with conduit (and even on the package naming side pipes seems to be more principled: the pipes- package name prefix is used consistently), so this seems mostly a network-effect issue to me. But network effects haven't kept us from using Haskell in the first place... so... :-)"
haskell,3dveyb,hagda,13,Mon Jul 20 07:51:23 2015 UTC,I think of his post as publicising streaming IO libraries - I suspect Conduit vs Pipes is a small difference compared to either vs Lazy IO.
haskell,3dveyb,ndmitchell,4,Mon Jul 20 08:24:54 2015 UTC,"Pipes seem to have much less caveats, as in the ""Things to know about Conduit"" list. On the other hand, the Pipes ecosystem also includes pipes-parse and pipes-group with new abstractions, so there's more to learn. I guess it's the waterbed theory at work."
haskell,3dveyb,mjmrotek,3,Mon Jul 20 09:15:30 2015 UTC,"The things to know about conduit are mostly a result of it having changed over time, and not fundamental. They are certainly annoying, but if Michael was happy to break everyones code they could be fixed quite easily - so I don't think its Waterbed theory here."
haskell,3dveyb,ndmitchell,1 point,Mon Jul 20 12:09:49 2015 UTC,"I admit I've only used pipes so far. Did anyone write a comparison between the recent versions of conduit and pipes? I'm mostly interested in whether =$= is the one operator to rule them all like >-> in pipes, what would be the conduit analog of the fancier pipe libraries libraries like pipes-parse, pipes-group, pipes-safe, is bidirectional communication available, when can the violation of category laws bite you in the bottom, etc."
haskell,3dveyb,mjmrotek,3,Mon Jul 20 20:58:52 2015 UTC,"=$= is the one operator you need, yes, the others are convenience (and occasionally help the RULES rewriter make things faster) pipes-parse, pipes-group, and pipes-safe are- I believe- all subsumed under the core abstraction of conduit itself Bidirectional communication is specifically not included in conduit: it makes the type signatures and error messages much more intimidating, and IMO for not enough value. It could be added in without changing things much, and there are workarounds without changing the library. I've yet to hear a complaint about it If you rely on finalizer ordering, then you're in trouble. If you don't understand how leftovers work, you may be surprised when they disappear. I'm unaware of any other cases where the ""violation of category laws"" pop up"
haskell,3dveyb,snoyberg,1 point,Mon Jul 20 22:03:19 2015 UTC,thanks!
haskell,3dveyb,mjmrotek,7,Tue Jul 21 08:50:33 2015 UTC,"maybe pipes can steal some of the good parts of conduits it hasn't yet...   Does pipes have full support for leftovers now?   The question for me is rather what the cost of being more principled with pipes is relative to using the ""unprincipled"" conduit...   You missed Neil's point. This was a gentle way of calling out those who incorrectly label conduit as ""unprincipled"". Not only is conduit completely principled - it's built on essentially the same principles as pipes. There was even talk of potentially merging the two at some point.  Last I heard, the only real difference was with regard to leftovers. Conduit provided a full-featured leftover function, with the law that users of this function must ensure that it is called only on a conduit that has already returned data. Pipes did not provide this.  The issue lurking behind that difference is that if you use leftovers without following the law, conduit will exhibit behavior that is a violation of the monad laws. That is reasonable, because anyway the monad laws themselves are not checked by the compiler and rely on human verification. So Conduit is still a bona fide monad in the same sense that the Haskell class Monad actually represents monads.  It's possible to change the types and APIs of conduit to enforce this law at the type level, but /u/snoyberg determined that this would make it significantly more complex to use conduits in practice, so he decided against it. /u/Tekmo also decided against this (at least in the past, not sure what pipes does now), and instead omitted support for leftovers from the library, with whatever limitations that entails in practice.  If you prefer the latter approach, just never use leftovers. You can even create a module which re-exports all of Conduit except leftovers - but no need for that, because if I understand correctly, that already exists, and it's called ""pipes""."
haskell,3dveyb,yitz,4,Mon Jul 20 10:17:20 2015 UTC,"Does pipes have full support for leftovers now?   IIRC, it's impossible to handle leftovers and follow the various laws that conduits / pipes claim (e.g. the monad laws). So, they are not in the core pipes library.  However, pipes-parse has a law-abiding approach to leftovers, but there's some essential complexity there that makes things more awkward to compose.  Having dabbled in both, I found /u/Tekmo's approach harder to get surprising results out of, so the principle of least surprise had me preferring pipes now.  I don't use either everyday, though.  I do use leftovers and I want law-abiding behavior.   So Conduit is still a bona fide monad in the same sense that the Haskell class Monad actually represents monads.   That's an abuse of vocabulary, if I've ever seen one.  Not all Monad instances form a monad, only the law-abiding ones, and that's made pretty clear in a multitude of places.  Now, different people want different things, and sometimes a Monad is enough, but I want a monad."
haskell,3dveyb,bss03,4,Mon Jul 20 11:56:16 2015 UTC,What laws are broken by leftovers? I am surprised if it's actually the monad laws.  I think the answer to this might depend on if leftover support is implicitly baked into the composition operation or is a separate step that you need to perform before composing.
haskell,3dveyb,twistier,5,Mon Jul 20 12:35:32 2015 UTC,"This post summarizes the issues.  Basically you have to use a different type of composition in order to guarantee that they won't get dropped.  It's not an issue of whether or not the implementation is law-abiding, but more of an issue of whether or not the implementation can drop leftovers or not.  The pipes-parse library is where leftovers-handling is addressed.  This approach leads to some surprisingly cool tricks.  For example, you can restrict a parser to a subset of the input while still streaming by using zoom (the same zoom from the lens-family-core/lens libraries):  -- Restrict a parser to the first 10 elements zoom (splitAt 10) parser  -- Restrict a parser to elements that satisfy some predicate zoom (span (< 5)) parser"
haskell,3dveyb,Tekmo,4,Mon Jul 20 13:55:07 2015 UTC,I've verified that conduit obeys the monad laws and published those results. I don't know what you're trying to imply about conduit here.
haskell,3dveyb,snoyberg,3,Mon Jul 20 13:09:34 2015 UTC,"I think the current ""word on the street"" is that Conduit is less principled, for example https://twitter.com/GabrielG439/status/623020897926942720 and https://twitter.com/GabrielG439/status/623023446000205825. I am not knowledgeable enough to say for can be done with Conduit, but I kinda thought it could be, or at least an approximation. Perhaps you need a blog post to clearly say why conduit is different, since all previous comparisons were done before Conduit changes."
haskell,3dveyb,ndmitchell,8,Mon Jul 20 13:20:01 2015 UTC,"It's a conversation I'm trying not to reopen to be honest. I'll say it briefly here:  Conduit has first class support for leftovers, detecting end of steam, and finalizers. It loses finalizer ordering during composition and has no left identity that can't throw away leftovers, but provides alternative composition functions to recapture those leftovers. Nonetheless, these two points do technically constitute a violation of the category laws, which conduit had never claimed to follow.  The business here about the monad laws, though, was just completely wrong, which is why I responded to it."
haskell,3dveyb,snoyberg,3,Mon Jul 20 13:26:29 2015 UTC,"@GabrielG439   2015-07-20 06:45 UTC  @ndm_haskell No, but here is one such transformation:  let p1 = forever (yield x)  p1 >-> (p2 >> p3)  = (p1 >-> p2) >> (p1 >-> p3)     @GabrielG439   2015-07-20 06:55 UTC  @ndm_haskell The (~>) and ""for"" operators and bidirectional support are the killer pipes-only features     This message was created by a bot  [Contact creator][Source code]"
haskell,3dveyb,TweetsInCommentsBot,3,Mon Jul 20 13:20:07 2015 UTC,Where have you published them?
haskell,3dveyb,Tekmo,4,Mon Jul 20 13:56:21 2015 UTC,"It's ancient, so I don't know if it's still accurate (or even was back then). This is the first thing I found: https://gist.github.com/snoyberg/2827896"
haskell,3dveyb,snoyberg,0,Mon Jul 20 14:01:12 2015 UTC,"They weren't always, but perhaps you've addressed the issue."
haskell,3dveyb,bss03,5,Mon Jul 20 20:20:58 2015 UTC,"I am curious if all Pipes users get asked ""Why not use Conduit?""   Probably not, because pipes users don't seem to feel the urge to publicize they're using them... =))   Which would imply there are no pipe users, only pipe supporters ? :) There are certainly a lot of people clamoring for pipe. I suspect that most of them entertain the idea that conduit is just pipe without the Haskell bingo (principled! proven! categories! small core!).  The conduit ecosystem is battle tested, has a great API, and solves problems. Yet, if you use it, somebody will goad you into using pipe instead. Or you will get offered the opinion that ""pipe is just better""."
haskell,3dveyb,bartavelle,4,Mon Jul 20 14:26:48 2015 UTC,"The Java ecosystem is battle tested, has a great API, and solves problems. Yet, if you use it, somebody will goad you into using Haskell instead. Or you will get offered the opinion that ""Haskell is just better"".   Sound familiar? I could have replaced for any other combination of enterprisey-gets-things-done-thingie (or maybe New-Jersey-style thingie) vs. thing-that-tries-to-improve-on-status-quo (or MIT-style thingie)..."
haskell,3dveyb,RedLambda,2,Mon Jul 20 20:45:14 2015 UTC,"It is familiar, but not in the way that you paint it.  I believe that Haskell is much better than Java, but not that it is just better. There are things in the JVM that I wish I had in the GHC runtime. And when you need these things, you can't use Haskell.  When I need a streaming library with a resource finalization story, I will use conduit. I admit as a user I don't really know why conduit is better than pipe in that aspect, but this seems to be something that is agreed upon by both authors.  So when I am being told I should just use pipe instead, without even considering what my use case could be, I file the person in the Dunning–Kruger folder."
haskell,3dveyb,bartavelle,3,Tue Jul 21 06:15:31 2015 UTC,"When I need a streaming library with a resource finalization story, I will use conduit. I admit as a user I don't really know why conduit is better than pipe in that aspect, but this seems to be something that is agreed upon by both authors.   Fwiw, there's pipes-safe:  Use pipes-safe for production code where you need deterministic and prompt release of resources in the fact of exceptions or premature pipe termination. pipes-safe lets you safely acquire resources and handle exceptions within pipelines.   So when I am being told I should just use pipe instead, without even considering what my use case could be, I file the person in the Dunning–Kruger folder.   Fair enough ;-)"
haskell,3dveyb,RedLambda,1 point,Tue Jul 21 14:45:55 2015 UTC,"I suppose I also fit in that folder, I never realized there was a pipes-safe package !"
haskell,3dv9ll,stelleg,31,Sun Jul 19 20:27:44 2015 UTC,The derivative of regular bookshelves is bookshelves of one-hole contexts.
haskell,3dv9ll,twistier,3,Sun Jul 19 20:30:28 2015 UTC,"I get your joke, but not the original one..."
haskell,3dv9ll,Peaker,6,Sun Jul 19 20:57:11 2015 UTC,"I think the joke is that Haskell is not a derivative of Java, and whoever organized the books didn't know that."
haskell,3dv9ll,sccrstud92,6,Sun Jul 19 21:02:05 2015 UTC,"Oh, thanks! I totally missed the text on the shelf itself :)"
haskell,3dv9ll,Peaker,2,Sun Jul 19 21:08:09 2015 UTC,"I'm so glad that I just read the post this refers to and am able to get the joke. Bravo, /u/twistier."
haskell,3dv9ll,hexbienium,1 point,Mon Jul 20 04:16:55 2015 UTC,Wouldn't it instead be a bookshelf with a single hole?
haskell,3dv9ll,PM_ME_UR_OBSIDIAN,11,Mon Jul 20 16:13:47 2015 UTC,Don't tell them that Haskell is older than Java.
haskell,3dv9ll,dagit,5,Sun Jul 19 21:05:39 2015 UTC,Wot? No C# books on that shelf?
haskell,3dv9ll,mcapodici,4,Sun Jul 19 23:23:41 2015 UTC,Erlang's in there too -- and both are alphabetical with the other titles (ignoring the misplaced Camel book) so this was probably done by an employee.
haskell,3dv9ll,tejon,1 point,Mon Jul 20 00:06:27 2015 UTC,"Realistically: how much ""action"" can one get with a Java library? It's only business programming, not bare-handed bear-murder."
haskell,3dv9ll,ForTheFunctionGod,1 point,Mon Jul 20 13:37:49 2015 UTC,What the actual fuck.
haskell,3dvjac,agrafix,5,Sun Jul 19 21:49:49 2015 UTC,"I really like how straightforward this is, but I'm curious what the benchmarks look like if you only want some fraction of the source data. I have existing Aeson code where this is the case; the JSON coming from an API call (Algolia search) contains tons of info that's irrelevant to what I'm doing, and I probably discard 75% of it or more by simply ignoring it in parseJSON. Here I'd actually have to parse it all, and pick out the useful bits once it's native (though of course I could do that immediately, so the rest of my code doesn't have to change).  Presumably the actual parsing operation is strict, to get raw JSON out of memory ASAP, right? So I guess it comes down to whether the compiler sees that the intermediate form is never used? And of course it might be negligible anyway. Plus I don't really care that much about performance in my application. It's just the only concern that comes to mind. ;) I hope to see this un-WIP'd soon!"
haskell,3dvjac,tejon,2,Mon Jul 20 00:35:10 2015 UTC,"Thanks for your feedback! I'm curious about that benchmark too, I'll see if I can come up with something like that. Currently the parser still has to parse unused keys (see here) to know when the next key-value pair starts. This can probably be implemented more efficiently because the real json structure does not matter (e.g. just counting open and closing {} for objects). If you'd like lazy parsing for needed keys - I can look into that, but in the current environments I work every Type is strict by convention so this would not be high priority for me."
haskell,3dvjac,eegreg,4,Mon Jul 20 12:33:26 2015 UTC,reminds me of this much more type-safe style of JSON parsing: https://github.com/gregwebs/aeson-applicative Unfortunately it is probably slow but a TemplateHaskell function could compile the definition down to efficient code.
haskell,3dvjac,imz,2,Mon Jul 20 01:34:02 2015 UTC,I'm curious whether there is something like this to analogously define Show/Read instances from one applicative definition...
haskell,3dvjac,eegreg,2,Mon Jul 20 05:17:45 2015 UTC,You should be able to use this pattern for any inverse typeclass pair (or inverse method pair on a single typeclass).
haskell,3dvjac,lpsmith,2,Mon Jul 20 07:08:59 2015 UTC,"Cool, I didn't know your package! One of my goals was to make something that's fast and easy to use without TemplateHaskell and Generics."
haskell,3dvjac,lpsmith,3,Mon Jul 20 12:27:34 2015 UTC,"Hey, I'll definitely have to take a closer look at this sometime hopefully this week,  but it may be what I was looking for as a complement to my own json-builder!  (Which itself is definitely in need of some work...)"
haskell,3dvjac,codygman,3,Mon Jul 20 06:33:55 2015 UTC,"Cool, maybe the serialization part of highjson can be implemented on top of json-builder. But only if it's fast of course... ;-)"
haskell,3dvjac,dhjdhj,2,Mon Jul 20 12:35:25 2015 UTC,"Well, back when I last worked on json-builder (which was a few years ago) my goal was to be able to serialize aeson's json syntax tree as quickly as aeson itself,  except in a data structure agnostic way.   And in that I was successful,  and even improved a few corner cases which made their way back into aeson.  Since then, aeson's serialization has seen further work I haven't kept up with,  and there's also BufferBuilder which takes a very similar approach as json-builder,  except faster and with not quite as nice of an API.  Also,  depending on how the review goes,  I might be perfectly happy to abandon json-builder in favor of a merger of highjson with a ""native"" json-builder/bufferbuilder type of interface."
haskell,3dvjac,lpsmith,1 point,Mon Jul 20 17:18:23 2015 UTC,Sounds good! Looking forward to your review.
haskell,3dvjac,dhjdhj,6,Tue Jul 21 07:24:25 2015 UTC,What don't you like about aeson and/or what are your inspirations for making this library?
haskell,3dts1j,BoteboTsebo,9,Sun Jul 19 11:31:49 2015 UTC,"Are you particularly set on Vinyl? It's worth pointing out the extensiblity isn't completely free, if you're not already aware of the associated costs.  If you're just trying to solve more straight-forward record woe, perhaps the records library might be more suitable. You can find the introduction here."
haskell,3dts1j,brnhy,5,Sun Jul 19 12:27:01 2015 UTC,"I'm trying to move away from record, or at least investigate the alternatives.  I like Vinyl because it is very powerful, and seems like it will actually stick around. Already I have been burned by the change from record 0.3 to 0.4.  What is the current state of Haskell libraries which solve the overloaded record fields' issue? Maybe that would have been a better question..."
haskell,3dts1j,jonsterling,10,Sun Jul 19 13:18:08 2015 UTC,"If you are worried about API churn, I would urge caution when using Vinyl (speaking as the author of Vinyl). I don't know of any big API change that we intend, but if you look at what we have done in the past, we had to make two very disruptive changes to the API before we arrived at the current one.  Vinyl is intended to support use cases that are a bit more advanced than the standard ""I need proper ML-style records in Haskell"" requirement. I'm not familiar enough with Nikita's library to comment on it...  With regard to your request for a simple example, I am sorry about the state of our tutorial. I do not currently have time devoted to working on my Haskell projects, since I am no longer being paid to do so—and I am in the middle of a very large endeavor (the JonPRL proof assistant) which demands all my free time. Vinyl will continue to be maintained for the foreseeable future (as long as anybody is using it) unless it is obviated."
haskell,3dts1j,echatav,4,Sun Jul 19 15:15:43 2015 UTC,"the JonPRL proof assistant   OMG, best icon ever!"
haskell,3dts1j,conklech,2,Sun Jul 19 23:37:01 2015 UTC,"The vinyl benchmarks seem to be using version 0.4.* (with Universe), which has a rather different implementation than the current series. In particular, rLens is now much easier for GHC to inline and monomorphize at compile-time.  If you're using vinyl primarily for API purposes, e.g. as a substitue for tuples when returning or passing multiple values, the new typeclass-based lens accessors may allow GHC to inline away intermediate records entirely.  Edit: Monomorphic vinyl records should be isomorphic to nested strict pairs, which in turn should be isomorphic (under optimization) to strict flat tuples. When I was last experimenting, back in 7.6, neither of those was quite true. I don't know if GHC has yet gotten wiser about this kind of GADT."
haskell,3dts1j,brnhy,1 point,Sun Jul 19 19:11:26 2015 UTC,"Ah, I see you're actually already using record, apologies for not checking the code first."
haskell,3dts1j,conklech,5,Sun Jul 19 12:33:47 2015 UTC,"This is not directly in response to your question, sorry.  I think vinyl is most valuable as a model implementation of extensible, higher-kinded records implemented in Haskell. As /u/jonsterling notes in another comment, it's not really targeted at end-users (i.e. library implementers) at the moment, but it's a great introduction to type-level programming in modern Haskell. Focus on Rec and RLens to start, before getting into the higher-kinded operations like rmap.  Unlike record solutions that rely on Template Haskell, preprocessors, or one-off language extensions, vinyl is a very straightforward implementation within the language itself. As GHC Haskell gets more powerful dependent type support, and as Haskell programmers get more comfortable with that, I think vinyl will get more and more useful."
haskell,3dts1j,conklech,2,Sun Jul 19 19:38:59 2015 UTC,"Can you perhaps suggest any end-user record solutions, besides record and Vinyl? Really I just need something that's usable and maintained. :-)"
haskell,3dts1j,conklech,4,Mon Jul 20 11:46:57 2015 UTC,"You could also look at the Template Haskell functions in lens, particularly makeFields."
haskell,3dts1j,mallai,3,Mon Jul 20 16:02:40 2015 UTC,"That actually looks pretty good. I was avoiding including lens at first but I have since decided to use it, and it looks like it provides a simple records' solution, too.  Thanks. :-)"
haskell,3dts1j,Tekmo,2,Tue Jul 21 10:32:33 2015 UTC,"You may know this, but it's possible to include those lenses without incurring a lens dependency, which a number of library authors prefer. The vinyl lenses, for instance, are fully compatible with lens.  I'm certainly not advocating that, though; it'd add a lot of boilerplate, and many/most of your consumers will be including lens anyway to actually make use of the lenses. (In traditional cabal sandbox usage, pulling in lens adds a huge overhead to each project using it. stack reduces that overhead significantly.)"
haskell,3dts1j,mjmrotek,4,Tue Jul 21 18:46:42 2015 UTC,"There's also the new version of the record by Nikita Volkov, which could help you."
haskell,3dts1j,jonsterling,2,Sun Jul 19 12:56:47 2015 UTC,"I tried it briefly and could not get the preprocessor to work as a simple dependency. Maybe I didn't try hard enough, but I don't want to have to tell the users of my library to first install another library before using mine -- I would like it if Cabal could manage all this itself."
haskell,3dts1j,mjmrotek,8,Sun Jul 19 13:19:59 2015 UTC,Have you reported the issue?
haskell,3dts1j,mjmrotek,4,Sun Jul 19 13:39:23 2015 UTC,"For example, why is he defining the =:: operator myself?    You need this to support your custom field type. Basically, the first parameter of Rec has kind k -> *, where k is the data kind made from your field data type (though there are also other possibilities, for example parametrize the Rec with Identity and use it as a heterogeneous list), so you need a newtype to map between the field labels and concrete types:  data Field = Foo | Bar | Baz type family ElF (f :: Field) :: * where ... newtype Attr a = Attr (ElF a)  (=:) :: ElF a -> Attr a   Previous versions of Vinyl used a type family as an additional parameter, but this was dropped in 0.5   What's all this Singletons stuff?   Since your field labels are types, and Haskell doesn't allow passing types as arguments directly, singletons are used as a representation of a type at the data level."
haskell,3dts1j,sambocyn,3,Sun Jul 19 14:40:04 2015 UTC,"Why is this not all included in the library? That is, I want to use Vinyl to write applications, not to roll my own records' solutions."
haskell,3dts1j,_AndrewC_,6,Sun Jul 19 14:55:01 2015 UTC,"Vinyl is essentially oriented toward providing the basis for ""records solutions"" as you say, and not as much toward application development. The reason for this is that I found it difficult to design a system that was both sufficiently general and immediately usable, so I opted to focus on generality.  There is included in Vinyl a built-in record family called ElField which lets you use strings as labels, and includes a built-in (=:) operator: http://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Derived.html"
haskell,3dten7,nicheComicsProject,9,Sun Jul 19 07:26:20 2015 UTC,"Hummm, I'm not 100% clean on what you're asking. I'm afraid I'm also not the best person to ask about performance in Haskell but I'll try and give some sort of answer.  Personally, I would advise against rolling your own date representation because dates can be pretty complicated (leap years, leap seconds, etc, etc) and you surely have better things to do than spend time solving a hard problem that has already been solved.  The most common way to represent dates and times in Haskell would probably be UTCTime. You can see the source code here. It's basically a tuple of day and time, which makes sense.  If you're sure you just want the day part then we can see that Day is just an Integer under the hood. Integer is implemented with the GNU's GMP and I understand that GHC is pretty good at interacting with GMP performance wise.  Performance wise, it would appear that Haskell's representation is a little more safe than the more typical single Int32 or Int64 unixtime, as there is a very high degree of precision available and dates will never roll over, but might be ever so slightly less performant because of integer overflow checking. I don't see it being a huge difference though.  As for your question, which I'm not 100% clear on, I'm assuming that what you want to avoid is this:       struct {         int day;         int month;         int year;     }   In C that would be packed and would probably all end up loaded on the same CPU cache line.  Everything would be contiguous if put in a Array of Vector<>. In Java, of course, each individual field is a primitive and so there is no pointer chasing but if you put that kind of object in a collection then it would be impossible to avoid pointer chasing to get the instance. But well, you can't put an int in an array, only an Integer, so you can't get away from pointer chasing even encoded as an int32. I wonder aloud what language was your library in."
haskell,3dten7,multivector,1 point,Sun Jul 19 08:24:57 2015 UTC,"Personally, I would advise against rolling your own date representation because dates can be pretty complicated (leap years, leap seconds, etc, etc) and you surely have better things to do than spend time solving a hard problem that has already been solved.   Have they been solved in Haskell?  The last time I tried to do anything with dates and times I found the Data.Date/Data.Time to have absolute bare minimum functionality compared to things like e.g. Joda Time."
haskell,3dten7,alien_at_work,8,Mon Jul 20 13:39:01 2015 UTC,"I probably wouldn't try to compact a data structure, like a date, into a bitfield to reduce memory unless I was working on a system that had very little memory, or there was going to be millions of this structure.  There is no point in optimizing for space that aggressively in most circumstances.  Just create a structure with day month year."
haskell,3dten7,safiire,5,Sun Jul 19 08:38:51 2015 UTC,"Usually optimizing space is optimizing for speed, because memory accesses (cache misses) are much more expensive than most kinds of computation."
haskell,3dten7,Peaker,7,Sun Jul 19 11:28:22 2015 UTC,Still: get it correct first. Optimize (on a low level) only if needed.
haskell,3dten7,kraml,3,Sun Jul 19 14:20:20 2015 UTC,"If you have day month year side by side in memory, a chunk of memory including probably all three, and surrounding contiguous memory will get moved into the cache at once upon your first access.  Is this not correct?  If you are using linked lists, or other non-contiguous parts of memory, then yes, that could slow down access through cache misses.  Edit: Better wording."
haskell,3dten7,safiire,2,Sun Jul 19 21:26:59 2015 UTC,"Even if your date structure fits in a cache line, bloating it means less of it fits. More useful stuff has to be evicted to make room for it.  Loading multiple adjacent cache lines is usually much faster than random access (though the processor doesn't always have the ability to predict adjacent access), but it's still noticeably slower than one cache access.  Bit operations needed to access bit fields are absolutely negligible compared to the downside on cache behavior."
haskell,3dten7,Peaker,4,Sun Jul 19 21:37:41 2015 UTC,"Interesting, thanks for the info.  I have worked on a lot of really tiny systems, video game consoles and Atmegas for example, where you constantly squish multiple datas into into bitfields to save space and time, so I do agree with you.    However, on a modern computer I save my optimizations until there is an obvious issue, and I don't optimize every little thing for space at first writing.  Edit: Trying to layout data contiguously in memory is somewhat more important to me these days than compacting stuff into bitfields."
haskell,3dten7,safiire,3,Sun Jul 19 21:48:07 2015 UTC,"I agree as well :)  In a language like c, though doing these kinds of ""premature optimizations"" is so easy and cheap you just say why not and err on the side of more optimizations rather than less."
haskell,3dten7,Peaker,1 point,Sun Jul 19 21:55:31 2015 UTC,"This is not true. Most experienced programers shoot for correctness and clarity of expression. Optimization follows as it becomes and empirical exercise between your profiler/instrumentation tools and you to optimize accordingly with hard cold facts instead of silly conjectures on how the computer/CPU, memory, primary/secondary caches, network latencies, etc., are going to behave with lines of cold that your can fit into your mind.  It's also not true that ""premature optimization"" is cheap. That's just unadulterated nonsense. It's the reason behind Fowler's article: http://www.martinfowler.com/ieeeSoftware/yetOptimization.pdf"
haskell,3dten7,abaquis,1 point,Mon Jul 20 17:14:04 2015 UTC,"Premature optimization usually isn't cheap.  What I said was ""these kinds of premature optimization are cheap"":  struct Date {   uint8_t month : 4;   ... };   The 4-bit size that makes the Date struct smaller is a ""premature optimization"" (if we haven't profiled it), but it is cheap.  One could say it aids in clarity of expression, because it makes it clear month fits in 4 bits (it can be even clearer if we make the type even more precise)."
haskell,3dten7,Peaker,6,Mon Jul 20 19:35:32 2015 UTC,"Bitwise operations are very fast on all processors, so this is unlikely to be a performance problem.  Definitely not something to worry about. I don't really see the connection with lazyness.  Lazyness in general is less compact, since you don't need to store just the data, but also the thunks. I would just convert the representation from your library to something that is useful in haskell, for example a new datatype, or something from an existing library (for example dates)."
haskell,3dten7,kuribas,3,Sun Jul 19 08:58:36 2015 UTC,"Bitwise operations are very fast on all processors   In particular, bitwise operations on data you already have are far more efficient than waiting for an access to main memory or even cache - branch-free arithmetic/logic operations in registers are just about perfect for speed. That said, a thunk-free flat data record would be very close to the same speed - Haskell (or at least GHC) supports ""unboxing"", and using normal pattern matching on ADTs is certainly simpler and more readable than bitwise operations.  Using unboxing of components in an ADT would encode the data in a larger block of data (probably three int32 chunks rather than one) and compactness can be important, but probably not that important.   Lazyness in general is less compact   Also having the components of the date be separately lazy (so you can use the year without paying to compute the month) is unlikely to be useful IMO, but maybe there's some special case out there."
haskell,3dten7,ninereeds314,6,Sun Jul 19 12:29:54 2015 UTC,"[...] from another language to Haskell [...]   I think we need to know what this other language is. If it is highly optimised compile-to-native code, then using the proper Data.Time and Data.Date in Haskell might be less efficient.  If you are coming from a dynamic language then would suggest first go with the properly typed modules (because I assume you came to Haskell in part because of strong typing), and then optimize you work later (probably to find out that you can best spend you optimization effort in another area).  Just my .02"
haskell,3dten7,cies010,5,Sun Jul 19 09:40:50 2015 UTC,"TL;DR I managed to smack myself in the face with the fact that premature optimisation to bit-twiddling is premature.   This was more than 15 years ago, so certainly ymmv, but I was doing some very heavy data crunching, and decided to bit-twiddle instead of using an algebraic data type, to save time and space, or so I thought.   It was as fiddly and error-prone as you might expect. I can't remember why I decided to reimplement it from scratch using an algebraic data type, probably to compare them, but I did.   I found to my surprise that all that effort with the bits wasn't gaining me anything, and the real bottleneck in my code was writing to disk.  Of course I then abandoned the pointlessly complicated, gain-free premature optimisation version and developed the easy-to-understand-and-maintain algebraic version.   I've done my best to avoid the premature optimisation strategy fail since then, and wait for stuff to be slow before wasting time trying to outsmart the compiler, but most importantly, I try to find out what, if any, the performance problem is before solving it!"
haskell,3dten7,_AndrewC_,3,Sun Jul 19 18:21:20 2015 UTC,"These days we can make use of lenses to hide the bit-twiddling in one place where we can afford the effort to get it right.  That said, avoiding the effort until profiling shows it's worth it is the way to go, and Haskell is pretty friendly to refactoring when you need to."
haskell,3dten7,jpnp,1 point,Sun Jul 19 20:14:44 2015 UTC,"re lens, do you mean like view patterns? because if your manipulations all use lenses rather than bit twiddling, you won't gain any speed, right?"
haskell,3dten7,sambocyn,2,Sun Jul 19 20:33:32 2015 UTC,I think /u/jpnp refers to this.
haskell,3dten7,AlpMestan,11,Mon Jul 20 08:26:24 2015 UTC,Is there any reason why you don't use Data.Time or Data.Date?
haskell,3dten7,NobbZ,3,Sun Jul 19 08:20:23 2015 UTC,"I don't really understand your question, but consider that the required bit-fiddling will take less than a clock cycle on a modern CPU (SHR 0.5 cycles on nehalem and sandy bridge, ivy bridge, and haswell. AND as little as 0.25 cycles on haswell!), while accessing memory, even the L1 cache will take more time.  Extracting a field from an int32 takes basically no time at all compared to anything else you can imagine."
haskell,3dten7,hastor,2,Sun Jul 19 21:08:36 2015 UTC,"If the library use case involved bulk operation on date values, then a tighter encoding would lead to a more efficient data cache usage.  From what you say, though, it's not clear if bulk operation is in the picture, although I'm inclined to guess negative.  Had it been, you'd indeed want to involve unboxed integers, which are untagged, most bare representation."
haskell,3dten7,_deepfire,2,Sun Jul 19 11:02:37 2015 UTC,"The library I'm working from represents dates with an Int32 with the fields bit encoded.   Wouldn't it be better to just use Unix time? 32 bits gets you up to 2038, If you use 64 bits you reach higher that the age of the universe."
haskell,3dsdi5,NorfairKing,5,Sun Jul 19 00:14:19 2015 UTC,"Awesome, I always appreciate a dotfile manager, and the last one tried I wasn't really fond of. Next time I have a need to sync across computers, I'll remember this."
haskell,3dsdi5,drwebb,1 point,Sun Jul 19 01:00:52 2015 UTC,is there an embedded version of the DSL?
haskell,3dsdi5,sambocyn,1 point,Sun Jul 19 17:57:38 2015 UTC,Embedded into what?
haskell,3dsdi5,Magnap,1 point,Sun Jul 19 20:08:19 2015 UTC,"Haskell, I would guess."
haskell,3dsdi5,sambocyn,1 point,Sun Jul 19 20:15:25 2015 UTC,"Haskell. like XMonad. not necessary, but it's nice when you can write ""macros"" for a DSL, i.e. host language functions."
haskell,3drgl3,asaltz,19,Sat Jul 18 19:13:38 2015 UTC,"The very loose notion you want to start with is to be aware of the category ""Hask"" which is not precisely on the nose with Haskell (there are issues with laziness and non-total computations) but coincides in that case when we only look at total terminating functions.  It is a category that is ""very like set"" where we take objects as types, and the set of haskell functions between two types A and B as Hom(A,B). It is also ""very like set"" in that it is cartesian closed and has lots of limits and colimits (though we cannot represent all, such as equalizers and coequalizers as internally as we might like).  In this, functors may be read as endofunctors, monads are monads, etc.  A typeclass such as Monoid can be loosely thought of as an ""induced subcategory"" just as Set has subcategories which equip its ""stuff"" with various ""structure"". Note that we don't typically manage to enforce laws (properties) internally, and just impose them on our typeclasses by fiat.  This is not the ""road to a full mathematical understanding of Haskell"" (that's much richer) -- but it provides a good ground set of intuitions to map to basic category theory.  If you look at all the ""algebra of programming"" stuff, this comes into play fairly immediately and in a more advanced way. I have recently become aware of Olivera's ""Program Design by Calculation"" (http://www4.di.uminho.pt/~jno/ps/pdbc_part.pdf) which promises to be a more introductory textbook in this flavor.  Depending on which sort of math you study, this may or may not be of interest -- for different branches of math, different connections are interesting and come into play.  If you are interested in combinatorial problems, you probably, for example, would find very neat Brent Yorgey's work on combinatorial species (and his comprehensive haskell library for them): https://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf  If you are interested in producing mathematical diagrams programmatically, brent's diagrams library is also well worth exploring."
haskell,3drgl3,sclv,7,Sat Jul 18 21:23:51 2015 UTC,Thanks!  When I started it took me a bit to understand that Functor wasn't just an analogy -- there was actually a category (mostly) underlying stuff.  I'll take a look at Olivera's book.  I work in geometric topology so I'm definitely interested in diagrams.
haskell,3drgl3,jmct,3,Sun Jul 19 00:03:50 2015 UTC,"Any pointers on where one could read about what makes the category of types (or is it just Haskell types?) ""very like set"" but not set?"
haskell,3drgl3,sclv,5,Sun Jul 19 00:22:56 2015 UTC,"Here's a sloppy answer -- others can hopefully cleanup my rough terminology.  The basic observation is that Hask if you squint looks a lot like an elementary topos (https://en.wikipedia.org/wiki/Topos#Formal_definition).   In the above i captured this by describing cartesian closedness and most limits [from an external standpoint, perhaps all?]. Along with that there's a way to give something that looks like a subobject classifier, again if we ignore issues of laziness and nontermination.  So one should not think of an elementary topos as a ""generalized set"" but it is fine to think of it as ""a place where logical operations can happen"" and even ""something where, in most definitions, we can swap it in for set, and get generalized constructions.""  Alternately:  In fact, for many uses of Set, one needs only any cartesian closed (or even just monoidal closed) category. In particular, enriched category theory lets us consider categories where the hom-set is not just ""set"" but any monoidal category. By virtue of being monoidal closed, Haskcan be viewed as ""a category enriched in itself"" -- i.e. where the hom object ""outside"" and ""inside"" the category are the same.   Many of the interesting constructions in Set arise solely from this ""self-enrichedness"" which lets us create many interesting categories as subcategories, and from the fact that other standard categories can be seen as ""categories enriched in set"". So now we can look at other standard categories either as subcategories of Hask rather than Set or alternately as categories enriched in Hask.  This is why we can construct so many basic categorical ideas internally to Haskell.  In general, it isn't just Haskell types where you can perform such constructions, but really any typed language with higher-order functions. (And perhaps, where you have parametricity, as we can get constructions related to ends and coends by reading them as ""forall"" and ""exists"")."
haskell,3drgl3,philipjf,4,Sun Jul 19 02:06:32 2015 UTC,"what is the sub object classifier in Hask?  Also, how do you construct equalizers?"
haskell,3drgl3,sclv,2,Sun Jul 19 02:13:01 2015 UTC,"Remember, we're in the ""ideal Hask"" where everything terminates and we have no bottom. So, in that case, Bool?  And I observed above that we don't have an internal construction for equalizers that I know of. But externally, we can observe that they exist. That is to say, fix a and b as types and consider f, g : a -> b.  Now the equalizer is just by definition something like a predicate a -> Bool that is true iff f a = g a.  Bear in mind again, this isn't Haskell itself, and it isn't all internal. It is just structure that is ""almost there"" when we round off the rough edges, and can be ""good enough for government work"" as the saying goes."
haskell,3drgl3,philipjf,4,Sun Jul 19 02:38:02 2015 UTC,"I am very suspicious of the idea that Hask should be a boolean topos.  Even in an idealized setting, functions to Bool have to be computable.  But there are many subtypes whose membership is not computable.  It is easy to imagine a dependent type theory that is really a topos (indeed, I am pretty sure at one point Coquand constructed a dependnet type theory which, when viewed as a category, is initial in the category of topoi).  But then, your subobject classifier should look more like Coq's Prop rather than Bool."
haskell,3drgl3,sclv,3,Sun Jul 19 04:07:08 2015 UTC,"Again, I'm not saying Hask is a boolean topos -- rather I'm saying that if you squint enough, it is almost one. My sketch is meant to be evocative of a way to see why Hask is very set-like, and thus to blur over all the important fine distinctions you are raising.  That said, I'm not sure about the ""computable"" issue you're raising. Certainly, an internal specification of certain functions would not be possible -- in which case we just, in a sense, would ""not have"" those subobjects in our topos?  What am I missing? Perhaps we're thinking of different things..."
haskell,3drgl3,maxiepoo_,2,Sun Jul 19 06:53:18 2015 UTC,"I think, based on my limited understanding of what a topos is, that /u/philipjf is right that Bool definitely is not a subobject classifier for Haskell because of decidability issues.  What we need is a mono f : A -> B such that is no computable function chi : B -> Bool such that chi b = True if and only if there is some a such that f a = b right? I think that is equivalent   A --------> () |           | | f         | const True /           / B --------> Bool       chi   But if we take A to be something like ""Fully annotated System F terms"" (use a GADT and existential) and B to be untyped lambda calculus then the fact that Bool is a subobject classifier would mean that type reconstruction for System F was decidable.  (Sorry I couldn't come up with a simpler example of an undecidable subset that I was sure could be encoded in Haskell)"
haskell,3drgl3,philipjf,1 point,Mon Jul 20 02:24:13 2015 UTC,"But if we take A to be something like ""Fully annotated System F terms"" (use a GADT and existential) and B to be untyped lambda calculus then the fact that Bool is a subobject classifier would mean that type reconstruction for System F was decidable   I'm not sure if this example works exactly (since I'm not sure the erasure function can be made monic) but the idea is certainly along what I was thinking.  And it is close enough to working: specifically, if Hask were a topos we could construct something just as bad using the epi mono decomposition of the erasure map.  For example, if we use A' to be the type of lambda terms together with type derivations in the intersection typing system (which types exactly the SN programs) and set B to be the type of untyped lambda terms (note specifically that both of these are real Haskell types and should therefore be objects in idealized Hask) and then use the epi-mono decomposition of the erasure map to construct an A, which, up to isomorphism contains exactly the strongly normalizing lambda terms, Bool being the subobject classifier would make chi a function which decided if a term was strongly normalizing.  Something which is clearly not computable.  Having these not computable properties would make ""Hask"" basically useless, IMO.  You would lose any of the nice properties you get from knowing that all functions are computable (like knowing all real valued functions are continuous).  And, it just seems like nonsense.  However, there is a more fundamental reason why Hask can't be a topos.  If it were, then it would serve as a model for Girard's System-U (since Haskell has polymorphic types, and polymorphism is not just restricted to ""some universe"" but really ranges over all types) or at the very least System-U-.  But, we know that these systems are inconsistent and so therefore we would have that in Hask the initial and terminal objects coincide--which is very bad when you are dealing with a topos!"
haskell,3drgl3,sclv,1 point,Mon Jul 20 04:22:16 2015 UTC,"use the epi-mono decomposition of the erasure map    What exactly are you trying to demonstrate in what logic? it seems like you're trying to derive a constructive taboo. but you need to only use constructive logic to do so, and I think that this might sneak in choice already...  With regards to ""serving as a model for system U"" I am confused for a different reason. We've specified we're only dealing with the total, terminating fragment, which is strongly normalizing. But we know system U is not strongly normalizing.  So you seem to really be arguing that haskell's impredicative polymorphism leads to inconsistency. But it doesn't, because Haskell's type system is very restricted and stratified.  That said, I have no idea what this discussion is about, since nobody has claimed Hask is actually a topos, just that it shares many qualities with one.  So I'm sure there is some actual reason Hask isn't a topos, and we'll probably find it looking at some size issue such that the power object doesn't work right. But that's sort of neither here nor there except in a ""challenge accepted"" sort of way."
haskell,3drgl3,apfelmus,14,Mon Jul 20 05:23:28 2015 UTC,"I think Richard Bird's textbooks and Functional Pearls will be a great introduction for you. Also check out automatic differentiation and lazy power series. :-)  You will probably have smooth sailing with Haskell, if my experience is any indication. The more ""computer things"" might come less natural to you -- installing libraries, building executables, writing files, working with the current directory, etc."
haskell,3drgl3,echatav,2,Sat Jul 18 20:10:48 2015 UTC,"Thank you, I'll definitely check those out."
haskell,3drgl3,sclv,7,Sun Jul 19 17:30:56 2015 UTC,"Hi, I was in your position a couple years ago. I was a mathematics PhD with very little programming experience. All I can say is that there are not a whole lot of resources for people with our kind of background. The most common assumption for beginning Haskell programmers is that they have experience with programming but will be terrified by monads. I started with Learn You a Haskell for Great Good which I loved because of the writing style and fun illustrations. I'd say I probably learned the most from reading blog posts and papers. Check out blogs by Edward Yang and Gabriel Gonzalez. But while these resources helped me to get ""advanced"" in some areas, I'm still pretty novice at things most programmers take for granted, the ""computer things"" as /u/apfelmus called it, and honestly it's extremely difficult to find good resources to learn that stuff. There are very good communities to participate in to learn Haskell including here on Reddit, on IRC and on Facebook."
haskell,3drgl3,iqtestsmeannothing,5,Sat Jul 18 21:24:09 2015 UTC,"It would be really interesting to take a survey of people from that background and see what they might find important.  The idea of focusing on ""basic tooling"" such as I suppose the REPL, etc. as more important than ""advanced things"" like what the heck an ""algebraic structure"" is is interesting to me.  I'm interested in what you (and the OP) among others would make of starting with something like ""The Haskell Road"" for example: http://www.amazon.com/Haskell-Programming-Second-Edition-Computing/dp/0954300696"
haskell,3drgl3,bitmadness,3,Sat Jul 18 21:36:08 2015 UTC,"I definitely agree that blogs and papers were the most helpful; once I was past the very beginning stages of learning Haskell, I found dedicated resources like tutorials and Haskell books much less useful than seeing innovative ways that people used Haskell to solve problems in practice. The first blog you mention I can recommend as well, the second I do not know."
haskell,3drgl3,Tekmo,8,Sun Jul 19 19:16:16 2015 UTC,"Hi! I'm an applied math grad student at Caltech, and I've used Haskell for several years. I really like it. Dan Piponi has a blog post (http://blog.sigfpe.com/2006/01/eleven-reasons-to-use-haskell-as.html) which I highly recommend. Happy hacking!"
haskell,3drgl3,sasquatch007,1 point,Sat Jul 18 21:36:33 2015 UTC,I think I read this when I started with Haskell.  Definitely interesting to read it now and see how much I agree with.  Thanks!
haskell,3drgl3,Tekmo,7,Sun Jul 19 17:32:47 2015 UTC,"When I was first learning Haskell I had the exact opposite problem: everything seemed like it was written for a mathematical audience.  For example, the first hit for free monad used to be this article which pointed to this article on free structures."
haskell,3drgl3,13467,6,Sat Jul 18 23:53:09 2015 UTC,"Those articles aren't necessarily great resources for a mathematician either. The algebra and category theory is not a problem, but figuring out what it has to do with programming in Haskell is a different story."
haskell,3drgl3,iqtestsmeannothing,3,Sun Jul 19 00:09:02 2015 UTC,I definitely understand why most learning materials are pointed the other way!  Probably a good sign for the language that I'm having this problem rather than the other way.  Your blog has been really helpful too.  Thanks!
haskell,3drgl3,drwebb,3,Sun Jul 19 00:06:15 2015 UTC,You're welcome! :)
haskell,3drgl3,eccstartup,10,Sun Jul 19 00:49:17 2015 UTC,"Much of the advice you're citing is right: you really don't need to know what those things are to make Haskell programs! Your mathematical background will help a lot, and you'll be much faster at recognizing the overarching patterns, but in the end, you might as well just go through the same resources recommended to everyone else. Skimp on the stuff that waxes lyrical about what a monoid is abstractly, and just read on about how to use them in code."
haskell,3drgl3,_AndrewC_,4,Sat Jul 18 20:18:11 2015 UTC,"I had a strong mathematical background before I first used Haskell (although not grad school; I only knew the basics of category theory at the time). While I found the style of Haskell very mathematical, I don't feel that the mathematical knowledge I had benefited me when it came to learning Haskell. In comparison, my experience in programming in other languages was massively helpful.  You might get some use out of looking for resources targeted at functional programming in general, instead of Haskell in specific. It sounds like your concern is less ""what does this command do in Haskell"" and more ""how do I design my code well"". Chris Okasaki's book Purely Functional Data Structures (written in ML, I think?) is superb, and while it's not exactly the kind of material you are looking for, it provides many examples of how to approach problems (especially data structure related problems...) in a ""functional"" way."
haskell,3drgl3,jeandem,3,Sun Jul 19 19:29:59 2015 UTC,"I come from a bit of a mathematics background myself, though I've always been into computers. Learn You a Haskell was my beginning book and I loved it. After that you'll want to dive into Monad Transformer Stacks so you can write an actual program, pick up a paper like http://www.cs.indiana.edu/~sabry/papers/exteff.pdf and get your hands dirty."
haskell,3drgl3,rpglover64,2,Sat Jul 18 23:55:27 2015 UTC,Take a look at this and this.
haskell,3dprvu,codygman,15,Sat Jul 18 06:57:34 2015 UTC,I've made one using Scotty+Persistent and one using Servant+Persistent. The former one is already listed on the todobackend site.   Actually I planned to extract the model part in an extra lib and add more implementations with other frameworks reusing it.
haskell,3dprvu,jhedev,6,Sat Jul 18 11:56:49 2015 UTC,The former one is already listed on the todobackend site.   I wonder why there is no Haskell icon nor filter? I assume their absence it the reason the poster assumed there was no Haskell implementation.
haskell,3dprvu,gelisam,3,Sat Jul 18 12:13:54 2015 UTC,Good catch. I think there needs to be an entry in this file. Just forgot to change it when submitting my implementation.
haskell,3dprvu,jhedev,1 point,Sat Jul 18 12:18:47 2015 UTC,"Awesome, will be great to see your Haskell implementations listed!"
haskell,3dprvu,phodgson,1 point,Sun Jul 19 21:53:38 2015 UTC,If anyone wants to submit a quick Pull Request to get that Servant+Persistent implementation listed I'd be very happy to merge it in. Doesn't need to be the original implementor; you just need to make an edit to a YAML file.
haskell,3dprvu,lukerandall,8,Sun Jul 19 21:34:57 2015 UTC,There's one using Scotty & Persistent: https://github.com/jhedev/todobackend-scotty-persistent
haskell,3dprvu,jhedev,3,Sat Jul 18 09:05:23 2015 UTC,Looks like tests just need to be added as per the contribution instructions and I see an issue for it.
haskell,3dprvu,cies010,2,Sat Jul 18 09:44:01 2015 UTC,"Well, it should pass the tests provided by the todobackend guys, which you can find here.  I just wanted to add some Haskell specific tests on my own :)"
haskell,3dqp2s,stasiana,7,Sat Jul 18 15:05:43 2015 UTC,"Once there, there is no reliable way download the latest executable.   Do you mean that while it is easy for a human to click on the binary for the platform of their choice, you wouldn't be able to tell curl or wget to download the latest release because the filename is v0.1.2.0/stack-0.1.2.0-x86_64-linux.gz, not latest/stack-latest-x86_64-linux.gz?   It'd be nice for it to be like homebrew, where you issue a single command and it figures it out for you.   That command is a bash+ruby script. In your script, you can easily include a bit of logic to find the URL of the latest release using the github api:  $ curl -i ""https://api.github.com/repos/commercialhaskell/stack/releases/latest"" |   grep '""browser_download_url"": .*-x86_64-linux.gz""' |   sed 's/^ *""browser_download_url"": ""\([^""]*\)"".*$/\1/g' https://github.com/commercialhaskell/stack/releases/download/v0.1.2.0/stack-0.1.2.0-x86_64-linux.gz"
haskell,3dqp2s,gelisam,1 point,Sat Jul 18 15:34:07 2015 UTC,I see that solution as fairly hacky.
haskell,3dqp2s,gelisam,2,Sun Jul 19 06:17:51 2015 UTC,"Which part? There idea of adding logic to your script to figure out what is the URL of the latest version, or the fact that I'm using grep and sed instead of parsing the JSON?"
haskell,3dqp2s,hiptobecubic,2,Sun Jul 19 12:35:54 2015 UTC,"I'd say both, but given the context I'm not sure you can do much better."
haskell,3dqp2s,conklech,5,Sun Jul 19 14:52:54 2015 UTC,There's an issue on Github related to this.
haskell,3dqp2s,Ancipital,2,Sat Jul 18 15:50:24 2015 UTC,"I've only seen this with Ruby's 'rvm' tool. In fact, I was just searching for something like this, because Debian Jessie comes with GHC 7.6, sadly enough."
haskell,3dqp2s,borsboom,4,Sat Jul 18 20:58:18 2015 UTC,You can get a .deb for Jessie from the apt repo.  See instructions here: https://github.com/commercialhaskell/stack/wiki/Downloads#debian
haskell,3dqp2s,Ancipital,1 point,Sun Jul 19 03:20:54 2015 UTC,Thank you!
haskell,3do3tj,jkarni,25,Fri Jul 17 21:17:58 2015 UTC,To stir up the discussion: I liked the part where he suggests rephrasing some common FP terms to things that have a more direct meaning  pure function --> stateless function easy to reason about --> easy to refactor safe --> reliable XYZ monad --> use concrete names that don't mention the monad abstraction upfront
haskell,3do3tj,smog_alado,12,Sat Jul 18 00:05:56 2015 UTC,"As a beginner, I feel particularly strongly about the ""monad"" one. Take the IO Monad. My current understanding (which is very diffuse, and I'm still not sure if my understanding is correct) is that functions of the type IO a' returns instructions. When I though of that, everything made much more sense, the paradox of a pure function performing side effects disappeared. Then one can begin to think about how one is to go about doing that, in other words the beginner will understand that a problem is even being solved. The talk about ""monads"" seemed like smoke and mirrors. If a tutorial just said concretely what it was doing it could save lots of time, even mentioning that ""monads"" exists can be problematic, because the beginner will feel like he doesn't really understand, like, is there more than meets the eye?"
haskell,3do3tj,SmartViking,16,Sat Jul 18 02:57:20 2015 UTC,"I didn't understand monads at all until I saw them explained in terms of unit and join instead of return and bind. Once I had seen the List monad described in those terms, it all clicked: informally, a monad is just a way of wrapping ""stuff"" (whether data, semantics, structure, or whatever) around data in such a way that you can merge layers of wrapping and poke around at the stuff being wrapped.  For me, the ideal flow of introduction to monads would have been like this:   Briefly explain the way Haskell treats values, functions, and constructors Introduce the List type Introduce the Maybe type Introduce the IO type, explicitly explaining that a value of type IO a is a description of a program returning a value of type a Explain fmap for the above three types and, more generally, the concept of a functor Introduce the term ""monad"" as meaning roughly a datatype which can be composed and its contents manipulated in situ Give the precise formulation in terms of fmap, unit, and join, and put the monad laws in a footnote Give the definition of unit and join for Maybe and List Finally, explain that unit for IO describes a program that simply returns the value supplied to unit; and that join x describes a program that executes the programx, then executes the result of executing x, then returns the result of that   And possibly the most important thing: leave bind and do for after the beginner has formed some sort of intuition about what a monad is. They are very information-dense constructs in comparison to unit and join, and are probably the biggest thing that got in the way of my understanding monads."
haskell,3do3tj,Archaeanimus,6,Sat Jul 18 06:58:25 2015 UTC,"I agree that tutorials shouldn't attack readers with jargon from the beginning, but giving it up entirely seems to me like asking OO programmers to give up the word ""object""."
haskell,3do3tj,mjmrotek,5,Sat Jul 18 08:26:04 2015 UTC,"No, I think it is rather like '+' in some other languages works for both integers and strings: you can just say what >>= does for IO, and then say what >>= does for Maybe, and then much later introduce that there is a common set of laws that they all share and that you can implement this for your own types."
haskell,3do3tj,pycube,2,Sat Jul 18 09:39:02 2015 UTC,"This is indeed a good approach for tutorials, and I'm all in for explaining abstract concepts with concrete examples. But by ""rephrasing some common FP terms"" I understand replacing the terms with something else in regular discussion among users above tutorial level. Sure, we can call monads ""warm and fuzzy things"" or ""things that can do >>= and are also appl... err, I mean, can do <*> and pure and fmap"", but what for?"
haskell,3do3tj,mjmrotek,4,Sat Jul 18 10:00:55 2015 UTC,"But he addresses just that in the talk saying that you should obviously keep calling the pattern a ""monad"". His argument isn't against that, but against naming the pattern when you talk about a specific application of it, and honestly, that's mostly the case."
haskell,3do3tj,Darwin226,5,Sat Jul 18 10:21:19 2015 UTC,"Well okay, when mentioning IO alone, or List and Maybe, which do have their counterparts in other languages (implicit io, list comprehensions). Perhaps in the same spirit in which C++ tutorials hide that iostreams are classes with overloaded operators. But when I find myself saying for example ""you can replace dynamically scoped global variables with the Reader monad or State monad"", changing that to just Reader and State makes it seem like they're disjoint concepts, rather than something almost plug-compatible. It's not like JS is free of jargon either, it's just that a greater portion of JS jargon is common to other imperative languages and thus familiar to JS beginners."
haskell,3do3tj,mjmrotek,2,Sat Jul 18 10:53:50 2015 UTC,"But the very fact that you can replace something with either Reader or State implies their connection. In fact, connecting them further and calling them monads doesn't really help anything since now you've involved everything else that's also a monad but has nothng to do with your situation."
haskell,3do3tj,Darwin226,3,Sat Jul 18 11:01:59 2015 UTC,"But the very fact that you can replace something with either Reader or State implies their connection.    There are other ways to replace global variables in question, for example reflection, or, well, unsafePerformIO + IORefs, which don't have much in common with Reader or State. I don't bring in every monad that there is by just mentioning the concept, just like I don't bring every single class with overloaded operators by saying ""you can use the << operator to send text to cout or some fstream"". It's not like OO got worldwide acceptance by shying away from their jargon. It's perhaps unfortunate that Haskell-specific terms often do make newcomers think that they should learn category theory to understand them, while they're not really different from ""method"" or ""object""."
haskell,3do3tj,mjmrotek,5,Sat Jul 18 11:28:06 2015 UTC,"Ask your grandma if she knows what an object or what a method is. Then ask her if she knows what a monad is. Even worse she does know what a group is, or what a ring is yet that does the opposite of helping her understand what they are in a mathematical sense.  Now don't get me wrong. I understand what you're saying and we probably agree for the most part. It's just unfortunate to use names that people can't connect with anything, or connect to a completely useless idea."
haskell,3do3tj,Darwin226,4,Sat Jul 18 15:07:26 2015 UTC,"I think the comparison with OO terminology is misleading here.  The terminology there is basically trivial.  It works because people start out inferring a basically correct notion of what an object is, and then they can spend literally five minutes listening to a description of what ""object"" precisely means in OO, and understand everything there is to know about the definition, including the motivation for defining it.  That's not the situation with the more precise and abstract language we use.  There is a good idea for eventually talking about monads, though: in Haskell we routinely abstract over monads.  You can introduce any number of examples of monads without using the word; but to abstract over them, you pretty much have to understand what they are.  I don't think (from his comments on a similar question in the talk) that Evan would object to introducing the concept at that point.  But that point isn't near the beginning of learning the language."
haskell,3do3tj,cdsmith,3,Sat Jul 18 15:28:39 2015 UTC,The word Monad is not fundamental to Haskell programming in the same way that objects are to object-oriented programming.  Just read my turtle tutorial which teaches new Haskell programmers how to use IO without using the word Monad.
haskell,3do3tj,Tekmo,3,Sat Jul 18 19:30:20 2015 UTC,"If you are sick of having type liftIO everywhere, you can omit it. This is because all subroutines in turtle are overloaded using the MonadIO type class   ;)  But seriously, it's a nice tutorial, and of course for an introductory text like this you can omit the explanation of ""why does do notation work both for subroutines and streams (and also Managed resources and lists and whatnot), in a somewhat similar but not entirely the same way"" or ""what does that ""Monad"" in ""MonadIO"" stand for"", but the issue is going to lurk, and sooner or later the beginner is going to be confronted with monads by GHC, as in ""could not deduce (Monad m) ..."" so I figure it's better to at least give a throwaway mention (as you did with MonadIO) than to omit the issue entirely."
haskell,3do3tj,mjmrotek,3,Sat Jul 18 20:02:46 2015 UTC,"Yeah, earlier versions of the library and tutorial did not use MonadIO for exactly this reason.  However, enough users requested the generalization to MonadIO so I relented."
haskell,3do3tj,Tekmo,2,Sat Jul 18 20:56:05 2015 UTC,"IO a is essentially an effectful function (closure) with no arguments (or equivalently, an argument of type (), if the idea of a function with no arguments bothers you) which returns a result of type a. The trick is that Haskell doesn't let you call it,  you can only transform them and combine them in various opaque ways using pure functions, such as the ones in the Monad interface. And then you have main :: IO () which is the entry point into the program and gets called by the runtime."
haskell,3do3tj,glaebhoerl,6,Sat Jul 18 10:48:36 2015 UTC,"IO a is essentially an effectful function (closure) with no arguments (or equivalently, an argument of type (), if the idea of a function with no arguments bothers you)   I think this is getting off on the wrong foot, though, because what you're saying isn't actually even true at all.  A value of type IO a is not a function.  And it very clearly doesn't take any parameters of type ().  Sure, if you ignore bottoms, there is an isomorphism from IO a to () -> IO a, but that doesn't make them the same type.  Better to say flat-out that a value of type IO a is an action that produces an a, and it's not a function."
haskell,3do3tj,cdsmith,2,Sat Jul 18 15:20:51 2015 UTC,"I do not disagree with you that IO is not a function in the Haskell sense and that teaching it as a function is probably wrong. However, the runtime representation of IO is as far as I understand really like a function of 0 arguments in imperative languages: (like void some_function() in C++): it's just some code in memory with an associated memory structure for the closures that gets jumped to when the IO action is executed, at least in GHC."
haskell,3do3tj,pycube,6,Sat Jul 18 18:50:20 2015 UTC,"However, the runtime representation of IO is as far as I understand really like a function routine of 0 arguments in imperative languages [...]   FTFY.  Procedure works as well, as does the archaic subprogram."
haskell,3do3tj,sacundim,2,Sun Jul 19 00:28:51 2015 UTC,"It is the same thing as a zero-argument or ()-argument closure in any language that doesn't track side effects: std::function<T ()> in C++, for instance, or unit -> 'a in ML; IO () is also the same thing as the Runnable class that some languages have. In those languages you could write all of the same combinators for the zero-argument closure type as which Haskell provides for IO a.  Sure, IO a is not literally a function... if by that we mean something like that the Haskell type IO a doesn't unify with the Haskell type b -> c. But that's so obvious that it's scarcely worth mentioning. (And even then: IO a is actually implemented as an abstract newtype wrapper over a function in GHC.) But it does behave just like a zero-argument (or ()-argument, again, whatever) effectful closure in every way except for being directly callable.   Better to say flat-out that a value of type IO a is an action that produces an a, and it's not a function.   Ah, but the challenge, when trying to explain a new thing to someone, is that you do, eventually, need to tie it back into something which they already know. (The brain is like a purely functional data structure, in this sense.) This is why the ""a monad is just a monoid in the category of endofunctors, what's the problem?"" joke has some bite. Here you've just generated a fresh variable: now you need to explain what ""an action"" is.   I frequently encounter this sense that drawing analogies between things which are not precisely the same is dangerous, because the person on the receiving end might be lead astray by the difference. But it's rather seldom the case that a new thing is precisely the same as an old one. Establishing a way in which two things are the same, even if they are not the same in all ways, is the whole point of an analogy or a metaphor. In this instance, IO a in Haskell and zero-argument effectful closures in other languages are the same in the ways in which they can be manipulated, combined, and transformed, and different in that IO a in Haskell can't be called directly. (Which is also an imprecise claim that nonetheless gives a useful intuition, if we were to notice the existence of unsafePerformIO.)"
haskell,3do3tj,glaebhoerl,6,Sat Jul 18 19:38:01 2015 UTC,"Here you've just generated a fresh variable: now you need to explain what ""an action"" is.   Indeed, that's absolutely necessary.  Fortunately, an action is something most people - programmers or not - already have a good intuition for.  An action is just something that can be done: reading a file, sending an email, creating a window, etc.  Of course computers need to perform actions.  Nothing confusing or scary about that.   you do, eventually, need to tie it back into something which they already know.   I'm deliberately rejecting ""function"" as the thing to relate it back to, for a reason.  In some sense the most important thing to really learn about Haskell's computational model is that actions and functions are both types of first-class values, but they are not the same thing.  Functions are not actions - which is a very important idea to internalize in a lazy language, unless you want to spend your life in a constant battle over evaluation order.  The other side of the coin is that actions are not functions.  If someone doesn't get that point, then they will forever be a bit uncomfortable with the whole model, and feel that it's unnecessarily complicated and arbitrary.  Sort of like the elderly person who gets a smartphone, only uses it to make phone calls, and wonders what idiot made a phone that needs navigating through menus just to get to the buttons to make a call.  If IO b should be thought of as a ""function"", what about Kliesli arrows, like a -> IO b, which are now a mix of multiple kinds of so-called ""functions""?  I've seen people try to say it's some kind of ""impure function"" that's separate from normal ""pure functions"".  So that's just awkward, and we're now telling people that there's some whole different parallel set of rules for understanding IO types.  Yuck.  When really, it's a very simple thing: a function whose result is an action, and you can see that by looking at the domain and range, and noting that the range is an IO type, so it's an action.  I have noticed you seem to be referring to ""closures"" a lot.  I'd like to understand what you're saying there, but your notion of a closure seems to be different from mine.  As far as I can tell, closures (i.e., runtime data structures generated by the compiler to implement static nested scope) don't have much to do with IO types in particular.  In applicative order languages (i.e., not Haskell), there's is a strong connection between closures and functions; but in Haskell, the analogous situation is that closures are associated with expressions, regardless their type.  In any case, they are an implementation technique for compilers, and don't have much to do with the semantics of the language.  Do you mean something different there?"
haskell,3do3tj,cdsmith,1 point,Sat Jul 18 20:52:05 2015 UTC,Technically a value of type IO a is a function (wrapped in a newtype). This is of course an implementation detail. See for example here.
haskell,3do3tj,seriousreddit,10,Mon Jul 20 15:54:11 2015 UTC,"Nice suggestions! I am not sure I agree about renaming ""pure function"" (since there are effects other than state effects!). But for the other ones, I pretty much agree.  ""easy to reason about"" is often used (esp. in the Haskell / Scala communities) in such a way as it makes me question whether people saying it have really understood what it means to ""reason about"" something. In some cases, the meaning might be ""easy to refactor"", and in others, it might be something different. But I support saying what we mean, rather than using an old crutch phrase that sounds smart.  ""Safe"" in the sense of ""type safe"" and safe in the sense of ""reliable"" are often conflated, to the extent that I often see an API described as ""type safe"" (which is nonsense!). (I often see folks saying that partial functions are not type safe, for instance.) If you are using a language that has the type safety property (sadly, many dialects of Haskell do not qualify for this distinction; ML and some intersections of Haskell features do), then anything you write in it is inherently type safe, so this is not a very strong claim. So I'd love to see folks say things like ""reliable"" or ""fine-grained"" or something instead of ""safe"", to avoid confusion."
haskell,3do3tj,jonsterling,13,Sat Jul 18 00:43:13 2015 UTC,"I often see an API described as ""type safe"" (which is nonsense!)   Really?  According to the definition on Wikipedia type safety is relative to some semantics.  Thus it seems perfectly reasonable to say that head :: [a] -> a is not type safe with respect to a total semantics despite it being type safe with respect to the usual semantics which contains _|_.  Correspondingly, I claim my Opaleye API for composable Postgres queries is type safe in the sense that well-typed expressions built up from the Opaleye combinators always generate well-formed SQL.  This is a much stronger claim than just saying it's ""type safe"" in the usual Haskell sense and I don't think it's a nonsense claim at all."
haskell,3do3tj,tomejaguar,6,Sat Jul 18 08:40:41 2015 UTC,"This relativeness of the meaning of ""type safe"" is precisely why Evan thinks its preferable to use more direct expressions, such as ""easier to refactor"""
haskell,3do3tj,smog_alado,4,Sat Jul 18 13:52:29 2015 UTC,"Type safety is a technical property of a language, relative to that language's semantics. Usually it is defined in terms of progress and preservation, but there are other options.  I don't really agree that ""type safe"" is the term you want for describing this query thing. ""Precise"" or ""fine-grained"" or ""correct by construction"" all sound a bit better to my mind, but I'm not here to tell you what you can and cannot say.  In the past, I had written a fine-grained very typed library for DynamoDB (not released), and I had been calling it ""type safe"" for reasons similar to those you bring up... But now, I regret it."
haskell,3do3tj,jonsterling,5,Sat Jul 18 17:05:51 2015 UTC,"Type safety is a technical property of a language, relative to that language's semantics.   Isn't an API basically an embedded sub-language? Under that interpretation ""type safe"" makes sense to me."
haskell,3do3tj,sccrstud92,4,Sat Jul 18 21:24:17 2015 UTC,"If you are using a language that has the type safety property (sadly, many dialects of Haskell do not qualify for this distinction; ML and some intersections of Haskell features do), then anything you write in it is inherently type safe, so this is not a very strong claim.    I'm kind of surprised to see you of all people write this.  Of course you can internally to a module use non type safe parts of the language and still be observationally type safe.  Indeed, by Rice's theorem, for every sound decidable type system there are modules which behave as if they were type safe but which do not type check.  Also, Haskell is pretty close to type safe.  Specifically, the newtype problem has finally been fixed."
haskell,3do3tj,philipjf,5,Sat Jul 18 06:34:54 2015 UTC,"I hope it is not too surprising that I feel this way :)  I think the Rice theorem corollary that you mention is a pretty strong indictment of decidable type systems... which partly explains my preference for semantic type systems like Nuprl's, which are based on a computational meaning explanation of Brouwerian truth, rather than on proof-theoretic derivability. My perspective is that a decidable type system is only adequate for mere matters of grammar (well, to be precise, it is exactly what you want for matters of grammar). For instance, Epigram's type system was a very elegant ""grammar of derivations"".  Using unsafeCoerce as a kind of benign effect is of course possible, as you mention—in a semantic type system, it is not even necessary (another way to look at it is, this is what you always do when programming in Nuprl, since there is no type checker to subvert—you must always demonstrate well-typedness).  Haskell is indeed ""pretty close to type safe"", whatever that means. In practice, you will never accidentally implement unsafeCoerce—that's not really the point though, since type safety is not a measure of your likelihood of getting into trouble, but rather a technical property which may hold (or not). One of the disadvantages of the proliferation of extensions that has made Haskell so much fun to play with is that statements about Haskell must be made relative to some slice of extensions. I think there is still some case where Haskell+typeable is type safe only in case there are no collision in MD5 (I can't remember the ticket, but it was an interesting thread!)  So my perspective is that for ""practical purposes"", Haskell is basically type safe. But in an adversarial scenario, there have been numerous ways to implement unsafeCoerce over the years, using combinations of ""locally reasonable"" extensions. Anyway, I don't want to argue about Haskell being type safe—I just brought it up in my previous comment, because I'm being me."
haskell,3do3tj,jonsterling,3,Sat Jul 18 17:13:27 2015 UTC,A language can be useful without requiring unsafe primitives.  I feel like Haskell's approach to IO under the hood is not the correct approach.  The correct approach should be for the language to build a syntax tree describing planned effects and then the backend code generator translates that tree.  Such an approach does not require any language backdoors.
haskell,3do3tj,Tekmo,4,Sat Jul 18 19:26:09 2015 UTC,"I agree with you that Haskell's approach to IO is not a good one. But my perspective is that the solution you offer is not desirable (however, it may be all we can afford!).  Turning stuff into ""functional programming"" by reducing the activity to generating codes (which will be interpreted by some backend into effects) is kind of a cop out, since it is only FP in the most boring sense (i.e. functionality/extensionality is preserved trivially because codes have the discrete/uninteresting equivalence).  I wrote a bit about this in my post on functionality and non-determinism in type theory (I'd link, but I'm using a frustrating phone to type this). EDIT: link here  I spoke with Conal a while back about what IO should look like, and we both agreed that it is unclear---but one thing we know is that it should be direct and denotative. Writing out interaction trees that simulate imperative programs is neither of these things... In my opinion we should start from the standard tools of type theory and meaning explanations: computational justification and PER semantics.  I think one thing to be inspired by is Conal's unamb operator, which is a very nice example of how direct use of a computational effect can be sensible: it is also a very clear demonstration that benignity of an effect can only be understood with respect to a type, since the equivalence differs at different types. What can we do to give a similar treatment to other use cases of IO?"
haskell,3do3tj,jonsterling,2,Sat Jul 18 19:43:23 2015 UTC,"I don't think it is possible to tackle both denotation and type safety at the same layer.  I believe that denoation should be the sole responsibility of the backend, and type safety should be the sole responsibility of the front-end.  When you conflate the two within the same layer you invariably end up incorporating unsafe operations into your language.  Don't take that to mean that I disagree with you.  I agree that the denotational half (i.e. the backend) is incredibly valuable, but I don't think you should mix the denotational layer with the type safety layer.  I am just frustrated that it is 2015 and we don't have a single secure programming language because every single language makes this mistake and ends up with some sort of escape hatch that defeats any safety guarantees."
haskell,3do3tj,Tekmo,2,Sat Jul 18 20:53:00 2015 UTC,What do you mean by unsafe? Do you mean non-benign?
haskell,3do3tj,jonsterling,2,Sun Jul 19 15:42:48 2015 UTC,"By unsafe I mean anything other than pure evaluation.  I view the sole purpose of the front-end language as type-checking and normalization and the sole purpose of the backend is interpretation.  In other words, there needs to be a language separation between type checking and interpretation."
haskell,3do3tj,Tekmo,1 point,Sun Jul 19 15:48:27 2015 UTC,"Ah, OK. That's a pretty nonstandard use of the term ""unsafe"", but I see what you are saying. I don't really agree with your perspective on this, but thanks for explaining it!"
haskell,3do3tj,jonsterling,3,Mon Jul 20 01:39:08 2015 UTC,What is the difference between what you are describing and what GHC actually does?   I can't see how there would be an observable difference.
haskell,3do3tj,tomejaguar,2,Sun Jul 19 05:35:40 2015 UTC,You can observe the difference using unsafePerformIO
haskell,3do3tj,Tekmo,2,Sun Jul 19 13:36:33 2015 UTC,"I'm not sure what you mean.  Why couldn't unsafePerformIO exist with IO as ""syntax tree describing planned effects""?"
haskell,3do3tj,tomejaguar,3,Sun Jul 19 14:24:10 2015 UTC,"The whole point of the syntax tree approach is that everything unsafe is isolated to the backend language, which is a completely separate language.  This makes it impossible to express unsafePerformIO in the front-end language.  Imagine Haskell where you used a free monad to express side effects and there was no way to interpret the tree within Haskell.  Instead, the backend interprets the tree."
haskell,3do3tj,Tekmo,3,Sun Jul 19 15:45:25 2015 UTC,"what it means to ""reason about"" something   What does it mean?"
haskell,3do3tj,tomejaguar,12,Sat Jul 18 06:35:29 2015 UTC,"""Easy to reason about"" is not the same thing as ""easy to refactor"".  The actual correspondences are:   ""Strong and static types"" => ""Easy to refactor"" ""Easy to reason about"" => ""Leak-proof abstractions""   You can have a messy code base with lots of leaky abstractions that is difficult to reason about but still easy to refactor thanks to types.  Vice versa, you can have code that is algebraically easy to reason about in a weakly typed language that is difficult to refactor."
haskell,3do3tj,Tekmo,4,Sat Jul 18 16:01:32 2015 UTC,"Genuine question: Are there non-trivial examples where the laws/categorical abstractions are helpful in reasoning about the systems. I watched your recent talk about how so many things are actually monoids. I get that this gives you the ability to compose things to get bigger things with the associative law guarenteeing that the order doesn't matter. I don't quite see how it is non-trivial.  I think Evan's talk kind of touches the point with the example of addition without introducing group theory etc.  To explain fully: Here's an example of a non-trivial thing that I found while looking at the book ""Conceptual mathematics"". In the book, there is a categorical proof of Brouwer fixed-point theorem that you can reason about just by categorical arguments and diagram chasing. (Its been a while so I am quite hazy on the details, but at that time it was quite an epiphany).  I haven't really seen similar kind of non-trivial examples in programming/haskell.   I understand that non-trivial examples aren't quite easy to convey through this medium and it may take months or years of working to fully grasp the essence of it, but if there is any example systems at all where I can study carefully that might help.  FYI: I am a newbie in Haskell."
haskell,3do3tj,erasmas,4,Sat Jul 18 16:19:48 2015 UTC,Here's a more sophisticated example that I blogged about: composable spreadsheet-like updates.  The Updatable type from my mvc-updates library is built from three smaller algebraic types:   Controller FoldM Managed   ... and they are combined in such a way that the resulting Updatable type is automatically a correct Applicative.
haskell,3do3tj,Tekmo,9,Sat Jul 18 16:39:42 2015 UTC,"There was a discussion on haskell-cafe which was triggered by a blog post from a ocaml programmer. In this post the author claims that the naming in Haskell is too complicated and suggests to use appendable instead of monoid. The problem with this is, that appendable is an instance of monoid, but monoid is a more general concept than that.   I don't think that the precise vocabulary should be altered. It's difficult to learn, precisely because it is so precise. The problem is more that it takes ages to get people started to actually do something. It took me a year before I could claim with some confidence that I can do anything useful in Haskell. People who write tutorials love the narrative ""you could have invented X yourself"", where you start with simple assumptions and derive the abstract concept X. The rationale behind this narrative is to  make people not scared about abstract concepts and show every simple steps to arrive at X. The problem is that the beginner just wants to implement a web-server, a game or something fun and doesn't care about X at all. So we need more ""you want to build Y"" tutorials which use the fancy terms but just don't discuss them at all. Maybe a central resource where this problematic is discussed could be linked in every ""you want to build Y"" tutorial so the author doesn't have to put effort into explaining abstract concepts and the reader can use the central resource where pointers to explanations are given."
haskell,3do3tj,quiteamess,11,Sat Jul 18 08:31:02 2015 UTC,"The problem is that the beginner just wants to implement a web-server, a game or something fun and doesn't care about [abstract concept] X at all   Not only beginners.   People who are not (and don't want to be) Computer Scientists are much more interested in getting stuff done than in exploring the nethermost implications of a school of programming. At least in the first instance. Unfortunately, far too much introductory haskell material ends up seeming inside out and upside down and back to front for the working programmer who'd like to see if it's true that they can do better work in haskell. This is because that material tries to lead the reader down a path to enlightenment (with the agreeable side-effect that they might be able to write a useful program) rather than explaining how to get stuff done.   I've found with many of the libraries that I've tried to use in my haskell experiments that the code I eventually end up with really is simple and clean and clear and all that—which is great!—but getting to that point is very frustrating. And this is because the tutorials (if there are any) and especially the reference material for the library leave me utterly bewildered and make library seem very hard to use. They create this impression by devoting far, far too much space to an exegesis of the intellectual adventure and subtle Apollonian beauty of the implementation and sort of assume that anyone who gets it will then see clearly how to apply the library to their problem. That's not the way it happens for us working stiffs. If anyone really wanted haskell to be “mainstream” they'd have to become comfortable with programmers who love the way that code written using applicative functors (for example) ends up but will learn how that works and why and what the relationship to monads is later.   Maybe much later. Maybe never. For “mainstream” success, haskell advocates need to get comfortable with that.  Edit: typos"
haskell,3do3tj,keithb,5,Sat Jul 18 12:10:22 2015 UTC,"This is because that material tries to lead the reader down a path to enlightenment (with the agreeable side-effect that they might be able to write a useful program) rather than explaining how to get stuff done.   Exactly. That is why I would like to have a disclaimer on every tutorial or book which either states ""I will guide you to enlightenment""  or ""I will show you how to do stuff"". I enjoy both kinds of tutorial, but it is often mixed up. ""Real world Haskell"" has the clear intention to show how stuff is done, but there are many passages which have a suspending buildup and conclude with ""and now my friends, we have again found a monad!""."
haskell,3do3tj,quiteamess,4,Sat Jul 18 13:11:24 2015 UTC,"RWH is pretty good, a lot of the time they do just launch into showing how to do things with an illuminating example. But there is still that zealous tendency to say “and we can do $TASK that much more easily using a FooBar. Here's how FooBar is defined … and here's the rules that FooBar follows … and here's the standard implementation of FooBar … and having learned all that now we can easily do $TASK in a few fewer lines of code … but then we can abstract like this! … and then apply that new abstraction in these other cases! …” and $TASK gets a bit lost."
haskell,3do3tj,keithb,6,Sat Jul 18 15:52:17 2015 UTC,"Then again, the function is called mappend."
haskell,3do3tj,Darwin226,2,Sat Jul 18 10:24:30 2015 UTC,"And that is the problem with Monoid, not the name of the type class."
haskell,3do3tj,mjmrotek,9,Sat Jul 18 12:13:34 2015 UTC,"These are mere word play tricks in the wider situation which is that we are a community of programmers, and programmers on the whole have little history, reputation or incentive for being interested in thinking pedagogically or empathetically (as in many other fields)."
haskell,3do3tj,chrisdoner,2,Sat Jul 18 14:19:55 2015 UTC,"I disagree. Its more about replacing those technical terms in the introductory materials in order to make the language have a more intuitive user interface. Whenever you needlessly use terminology that the user doesn't know about, you tax their limited attention span (humans can't pay attention to more than one thing at once) and you present an opportunity for the user to give up and change his mind on what he was doing. For example, the ""monad"" term makes you ask yourself if you have to learn category theory before learning Haskell. Of course you shouldn't but by this point you already confused the user more than you need."
haskell,3do3tj,smog_alado,10,Sat Jul 18 14:26:58 2015 UTC,"pure function --> stateless function   This at least doesn't make much sense. ""Pure function"" is a well-known term and is used even outside FP. Heck, you can even use it in C as gcc has __attribute__((pure)), and THAT language is certainly not functional! Trying to change something so established is bound to just confuse people."
haskell,3do3tj,Coffee2theorems,11,Sat Jul 18 00:22:24 2015 UTC,"I don't think this point is really a big deal. But ""stateless"" reinforces the reason we care about pure functions to begin with: state is hard to reason about.   When discussing Haskell with a non-funcitonal programmer, there's a tendency to bring up the phrase 'mathematical function'... as if that was any more enlightening to someone who wasn't already immersed in the culture. But the point that the functions are stateless is meaningful to programmers, even if they haven't developed a hesitation towards statefulness yet."
haskell,3do3tj,tactics,2,Sat Jul 18 00:43:30 2015 UTC,"I don't think your assertion that state is the reason we care about purity is correct, either historically or in practice. As I understand it, the historical origins have more to do with laziness, which I suppose is ""state"" in a sort of abstract sense, but not really what you're talking about. And in practice, my concern at least is usually not about state per se but rather the unbounded range of ""side effects"" or rather untracked semantic relationships implied by IO () or anything in a (straw-man) non-pure language.  For instance, I've just written an installer in nsis, which is a perfectly admirable binding to a pretty ridiculous language. It's a thin-ish binding, though, so most of the semantics of the program are not captured in the types at all: you define the order of events in one place, and then define the various events somewhere else; in one place you say ""make an uninstaller"" and somewhere else you write the uninstaller. It's confusing not because it's stateful--which it isn't, actually--but because the pieces fit together in a manner completely divorced from their types."
haskell,3do3tj,conklech,3,Sat Jul 18 06:31:55 2015 UTC,"Historical, it goes back to Euler. Evaluation order isn't specified at all in a mathematical context.   This has been discussed and even SPJ has claimed laziness isn't the central feature of Haskell. It's the barring of uncontrolled side effects. In other words, statelessness."
haskell,3do3tj,tactics,7,Sat Jul 18 11:41:13 2015 UTC,http://conal.net/blog/posts/the-c-language-is-purely-functional
haskell,3do3tj,shift_reset,3,Sat Jul 18 01:40:57 2015 UTC,"I agree. Searching ddg for stateless function I did not get to very good resources right away, where as searching for pure function I got wikipedia as the first result which defined the term quite nicely.  Also, I do not think that talking about state and stateless functional to a non-functional programmers (at least the beginner/intermediate ones) does not have a better affect. If you need to explain both terms, might as well pick the more correct one."
haskell,3do3tj,gilmi,1 point,Sat Jul 18 08:00:58 2015 UTC,I thing you're hugely overestimating how many people are familiar with the term.
haskell,3do3tj,Darwin226,5,Sat Jul 18 10:28:18 2015 UTC,"To make monads less scary, I like the idea of referring to them as ""computational contexts"", which is how they're called in much of the Idris documentation and seems like a good choice.  Of course that's mostly orthogonal to Evan's main point that you should avoid presenting the general concept at first, but focus on the specific example at hand."
haskell,3do3tj,BlackBrane,3,Sat Jul 18 08:44:10 2015 UTC,"I never understood the ""computional context"" analogy when I read LYAH. List monad as ""computional context""? Maybe as a ""computional context""? I just had no idea what ""computional context"" even was."
haskell,3do3tj,pycube,7,Sat Jul 18 18:57:45 2015 UTC,"Someone asked regarding Elm on server-side, but I would be more interested to aks on Elm coordination with server-side Haskell: are there ways to share data-structures? Functions? What is the current state of interoperability? Thanks."
haskell,3do3tj,k-bx,4,Sat Jul 18 13:35:57 2015 UTC,I think that for achieving similar goals it would be better to try Haste or GHCJS
haskell,3do3tj,liberalogica,1 point,Sat Jul 18 16:20:32 2015 UTC,"Yes, you would definitely achieve goals of sharing code, but you'd lose your main goal – using Elm on Front-end :)"
haskell,3do3tj,k-bx,2,Sat Jul 18 16:28:11 2015 UTC,"Considering Haskellers are not the target audience of Elm, I doubt much work will be done in that direction."
haskell,3do3tj,gilmi,11,Sat Jul 18 18:00:46 2015 UTC,"I think the general spirit of ""let's not make things needlessly complex or obtuse for newcomers"" is really good. OTOH, when I look at Elm, which is the result of Evan's philosophy, I'm more skeptical. Elm is just way way too limited a language, and those limitations are deliberate. Maybe that will help make Elm more mainstream. But then again, Javascript is pretty mainstream... so maybe that shouldn't be the goal. :)"
haskell,3do3tj,pchiusano,5,Sat Jul 18 13:39:11 2015 UTC,"Also my concern, but i am not totally sure about the main differences between Elm and Haskell. Off the top of my head the main differences are:   lazy versus strict evaluation typeclasses   Is this all?"
haskell,3do3tj,liberalogica,7,Sat Jul 18 16:18:59 2015 UTC,"Elm has extensible records with pretty nice notation Haskell has do notation Elm has FRP built-in as /u/maxlepoo_ said, Elm doesn't have higher-kinded types (yet) Haskell has all these fancy extensions imports in Elm are qualified by default   TBH, I'm much more excited about PureScript at the moment than Elm."
haskell,3do3tj,gilmi,2,Sat Jul 18 18:09:01 2015 UTC,"I had a look at Purescript again, it is indeed very interesting! Too bad for the many small differences from Haskell. I guess that all those small things might drive a programmer mad, if he/she tries to go back and forth from Haskell to Purescript on a daily basis"
haskell,3do3tj,liberalogica,2,Sun Jul 19 12:28:53 2015 UTC,"I think most of those differences are justified - like extensible records, IO vs Eff, lazy vs strict, etc. But some differences will probably change in the future."
haskell,3do3tj,gilmi,1 point,Sun Jul 19 13:32:47 2015 UTC,"There are a few gotchas - Eff vs IO, record syntax, and row polymorphism are probably the biggest. Once you know them, though, your Haskell knowledge should mostly transfer over"
haskell,3do3tj,ephrion,9,Mon Jul 20 13:54:56 2015 UTC,"Not having typeclasses is a pretty huge difference since they're so pervasive in Haskell.  Add ""no higher-kinded types"" and ""no higher-rank polymorphism"" and you see that you can't abstract over Functors/Monads etc, which means every time you come up with a special purpose Monad you need to reimplement everything from Control.Applicative/Control.Monad etc that you need."
haskell,3do3tj,maxiepoo_,2,Sat Jul 18 17:55:30 2015 UTC,"Sure, typeclasses make a big difference, but Evan says in the video that they are going to be added eventually. At that point, the two languages might become very similar"
haskell,3do3tj,liberalogica,3,Sun Jul 19 12:12:57 2015 UTC,I'll believe it when I see it.
haskell,3do3tj,maxiepoo_,3,Sun Jul 19 15:33:05 2015 UTC,Last time I used elm you couldn't create a new input from a signal. Idk if mailboxes solved this but until you can do that elm is just a toy. A fun toy but just a toy.
haskell,3do3tj,DiegoNola,1 point,Sun Jul 19 07:10:39 2015 UTC,"I see Mailboxes as Observers in OO languages. it's a record with two fields: address and signal. you can ""subscribe"" to a mailbox signal to get the updates and send messages to a mailbox address, which will update the mailbox signal, which will ""notify"" the ""subscribers"". Is this the functionality you were looking for?"
haskell,3do3tj,gilmi,5,Sun Jul 19 19:46:14 2015 UTC,Phil Wadler's presentation was also good: https://www.youtube.com/watch?v=FiflFiZ6pPI
haskell,3dqekz,bitrates,14,Sat Jul 18 13:05:09 2015 UTC,This is one of the reasons why I think Unicode designers will be the first against the wall when the revolution comes.
haskell,3dqekz,mjmrotek,5,Sat Jul 18 14:30:49 2015 UTC,I liked the original. Any tool can be abused.
haskell,3dqekz,tejon,1 point,Sat Jul 18 22:55:50 2015 UTC,@aisamanra   2015-03-20 22:02 UTC  I have made a wonderful discovery about the conjunction of Haskell and Unicode.   [Attached pic] [Imgur rehost]     This message was created by a bot  [Contact creator][Source code]
haskell,3dqekz,TweetsInCommentsBot,2,Sat Jul 18 22:55:58 2015 UTC,suggestive
haskell,3dqekz,liberalogica,2,Sat Jul 18 15:10:29 2015 UTC,This is surely what haskell feels like for beginners.   I recommend watching the BBC's In the Night Garden if you want to know what it's like to not understand many nouns.
haskell,3dpum1,gilded_honour,6,Sat Jul 18 07:38:44 2015 UTC,"I don't think anything has changed regarding this. I see a couple of options:   Rename the values in Foo, e.g. fooA = A.foo and export the renames. Don't export the clashing values and have qualified imports at the use site. If the values are somehow related, put them in a type class Rename the original values not to clash."
haskell,3dpum1,cameleon,4,Sat Jul 18 09:48:17 2015 UTC,And if the clash is due to a constructor use PatternSynonyms.
haskell,3do3ny,jkarni,9,Fri Jul 17 21:16:54 2015 UTC,"It's a bit strange to see Philip promoting quotation.  Unless F#'s quotation is orders of magnitude better than Template Haskell that's just going to mess with composability and type safety.  On the other hand, SQL fits neatly into the well-known Applicative abstraction (and can be extended neatly to an Arrow) which really lets you manipulate your queries in a generic and first-class way.  Promoting ""it only issues one query if you check a few properties"" also seems a bit of a stretch.  Why not just define an Expr that can only issue one query?!  Then you've got nothing to check."
haskell,3do3ny,tomejaguar,4,Sat Jul 18 06:50:24 2015 UTC,"I think the point is that you can use the same syntax as the host language to write SQL queries, as if the database was an ordinary data structure in your heap."
haskell,3do3ny,julesjacobs,4,Sat Jul 18 09:48:59 2015 UTC,But using an Applicative is using the syntax of the host language.
haskell,3do3ny,tomejaguar,3,Sat Jul 18 11:10:46 2015 UTC,In F# you have for loops to iterate over collections. This work translates those loops into SQL queries. Using applicative in F# would be very different. The analogous Haskell would be list comprehensions that translate into database queries.
haskell,3do3ny,julesjacobs,3,Sat Jul 18 11:35:14 2015 UTC,"I've always wondered if that was what the -XTransformListComp and -XMonadComprehension extensions were all about, e.g. see https://ocharles.org.uk/blog/guest-posts/2014-12-07-list-comprehensions.html"
haskell,3do3ny,mn-haskell-guy,4,Sat Jul 18 14:40:30 2015 UTC,"I think Phil is trying to pave the way for homoiconicity to be embedded into strongly typed languages.  It is a grand endeavor, if so."
haskell,3dnrpl,jocomoco,64,Fri Jul 17 19:44:49 2015 UTC,JVM.
haskell,3dnrpl,SixBitProxyWax,16,Fri Jul 17 19:46:57 2015 UTC,You mean JVM+JAVA Libraries ?
haskell,3dnrpl,SixBitProxyWax,22,Fri Jul 17 19:52:57 2015 UTC,"I mean the JVM and all that comes with it. This includes libraries, JVM features, easy interop with other JVM languages, acceptance in the industry, etc.  I think acceptance is a huge issue for the industries like finance and really trumps the other aspects in many cases. If I write some financial software with Scala and you write some in Haskell, you will have a huge uphill battle in many organizations, because they already have a certified, supported java stack that can be used without any concerns for compliance, security, training for support. Even if this isn't a real problem, they are likely to prefer a JVM based solution so that they don't have to worry about any of those complications.  On a smaller scale, this is even true for individuals. If you know how to work with Java in general, then jumping to Scala is much less of an issue than jumping to Haskell."
haskell,3dnrpl,bartavelle,20,Fri Jul 17 20:53:47 2015 UTC,"I don't really care for the libraries. The JVM is awesome, and it is great for instrumenting your production."
haskell,3dnrpl,bartavelle,29,Fri Jul 17 20:25:41 2015 UTC,"Just to expand on this terse answer, with the your production JVM (no special build / configuration) you can :   send a signal, and have it spit a stack trace of all threads, with their status (especially what they are waiting for) make it dump a core that you can then analyze with many tools to see all objects in memory (freezes your program) make it dump that core on OOM have it spit a breakdown of the memory usage at any time (freezes things though)   These features are incredibly useful. And I don't even mention how remote debugging can be useful. I don't miss it too much with Haskell because there are less bugs in my programs, but well ..."
haskell,3dnrpl,anacrolix,11,Fri Jul 17 20:32:29 2015 UTC,Why the fuck am I using Go?
haskell,3dnrpl,lyinsteve,17,Sat Jul 18 14:03:28 2015 UTC,Why is anyone?
haskell,3dnrpl,bartavelle,1 point,Sat Jul 18 14:16:49 2015 UTC,Can't help you here ...
haskell,3dnrpl,jsantos17,1 point,Sat Jul 18 20:29:44 2015 UTC,Now that's a real mystery.
haskell,3dnrpl,Soul-Burn,1 point,Sun Jul 19 04:38:24 2015 UTC,"Well, it compiles an order of magnitude faster than Scala. Other than that, no idea."
haskell,3dnrpl,tactics,8,Sun Jul 19 07:38:41 2015 UTC,Scala has better marketing. And it's similar enough to existing languages that it's not seen as a risk. The same can't be said for Haskell.
haskell,3dnrpl,Drezil,8,Fri Jul 17 23:26:33 2015 UTC,why then not Frege?
haskell,3dnrpl,SixBitProxyWax,18,Fri Jul 17 22:57:25 2015 UTC,"Because most people have no idea it exists and, accordingly, it lacks the necessary community for a lot of companies to take it seriously."
haskell,3dnrpl,stormcrowsx,3,Fri Jul 17 23:01:47 2015 UTC,Mostly just lacks the necessary marketing.   If it had a Rich Hickey going to conferences it'd probably start catching on.
haskell,3dnrpl,geggo98,23,Sat Jul 18 08:16:16 2015 UTC,"For me there are several reasons:   The JVM has excellent tooling: IDEs, test automation, profiler, debugger, coverage analysis, static code analysis, several good build tools You can find a Java library for nearly everything Scala mixes functional with imperative: You can go back to stateful programming for performance reasons or for clarity if needed The JVM is usually quite fast and you can tune it when needed (e.g. choose between different implementations for the garbage collector or even the whole VM) For several important tasks there are proven and well supported Scala solutions: GUI programming, database access, actor framework, data crunching, machine learning There is a backup plan: You can go back to plain Java when needed"
haskell,3dnrpl,tdammers,15,Fri Jul 17 20:46:02 2015 UTC,"Scala mixes functional with imperative   Don't want to spoil the party, but so does Haskell, and IMO Haskell does it better. Other points are perfectly valid though."
haskell,3dnrpl,PM_ME_UR_OBSIDIAN,8,Fri Jul 17 21:10:12 2015 UTC,"I've never done imperative in Haskell, but whenever I've seen it done it looked extremely obfuscated."
haskell,3dnrpl,Kaidelong,7,Fri Jul 17 21:47:35 2015 UTC,"Are you absolutely sure you mean ""obfuscated"" and not just ""verbose?"" My experience has been that it is basically the same as the PASCAL pseudocode you see in books but with things like writeIOVar rather than terse things like :=."
haskell,3dnrpl,ysangkok,4,Sun Jul 19 01:02:30 2015 UTC,Did you check out Turtle? I can't think of anything more imperative than shell scripts.
haskell,3dnrpl,_deepfire,3,Fri Jul 17 22:45:34 2015 UTC,"There's also Hell, for an example of extremely thin embedding of shell into Haskell."
haskell,3dnrpl,codygman,3,Sat Jul 18 10:43:31 2015 UTC,Examples? I feel like we could learn a lot more by presenting/dissecting examples and maybe even come to a consensus! :)
haskell,3dnrpl,geggo98,2,Sat Jul 18 04:34:44 2015 UTC,"You don't spoil the party, I am a big Haskell fan. In fact I have learnt Haskell before Scala even existed.  But regarding state, Scala is easier (although much dirtier) than Haskell. In Scala I just change val to var and can work stateful. In Haskell I would need a state monad and probably some monad transformers (usually you can take IO as given in any reasonable complex program).  Especially when you have a team with not so experienced developers, the Scala approach can help you to let your developers handle state better (you start to structure imperative code with functional constructs). In Haskell such a team would not be able to deliver anything at all."
haskell,3dnrpl,tdammers,3,Sat Jul 18 09:11:27 2015 UTC,"Well, if ""getting shit done (right now)"" is your top priority, sure. I don't think it should be, though."
haskell,3dnrpl,geggo98,3,Sun Jul 19 13:48:57 2015 UTC,"To go meta: You seem to be a big Haskell fan. I can understand this. But in my opinion the gains in stability going from Scala to Haskell (you gain a little bit) is not worth the loss in tooling (you loose a lot). I guess you have a different opinion. Unfortunately we don't have much data to prove our respective point, so we are both only guessing (although with an ""educated guess"").  So we probably just should wait and look how things turn out. Perhaps Oracle kills Java and so Haskell ""wins"". Perhaps open source F# will take over. Perhaps Haskell can't improve its tooling enough to gain traction in the industry, and Scala becomes the de-facto standard for functional programming. Perhaps even Typed Clojure makes the race. We'll see."
haskell,3dnrpl,Taladar,1 point,Sun Jul 19 17:07:19 2015 UTC,"I don't think Scala will ever gain much more traction than it currently has, mostly because it is a syntactically very messy language that is hard to read even to people familiar with concepts from both ends (OO and functional ones)."
haskell,3dnrpl,geggo98,1 point,Mon Jul 20 09:10:26 2015 UTC,Are you sure that syntax correlates with traction?
haskell,3dnrpl,Taladar,1 point,Mon Jul 20 11:15:04 2015 UTC,Considering the many languages which are wildly different in semantics but similar in their C- (or Algol if you prefer) like syntax and all successful in part because of that I would say it is more important than most people would imagine.
haskell,3dnrpl,tdammers,1 point,Mon Jul 20 11:25:48 2015 UTC,"You seem to assume that Haskell has no industry traction, and that there can only be one functional language in widespread use - but I believe this is quite untrue, seeing how today languages like C# and Java, or PHP, Python and JavaScript coexist within very similar problem domains, and without either clearly crushing the ""competition"".  Also, while I am convinced that making effects explicit at all times is the way to go, I also believe that not doing it is often a better choice, especially when you have people on your team for whom functional thinking isn't natural yet. It's a tradeoff between theoretical superiority and practical limitations."
haskell,3dnrpl,geggo98,1 point,Mon Jul 20 12:41:33 2015 UTC,"Haskell has some traction, but unfortunately much less than the alternatives (especially Scala and F#). The most prominent user of Haskell I know of is Standard Charted, having a full Haskell stack in production for some of their core services. Other companies seem to have some niche projects, probably trying to get some experience with Haskell (see this list). So if Haskell would go away (hypothetically), only Standard Charted would get seriously hurt (in other words: They are the only ones having a strong buy-in to the Haskell platform).  Usually with big platforms you have some network effect. This leads to one or two big platforms and many quite small occupying the same niche. Usually in one niche you don't have the medium sized players.  So while Haskell and Scala could coexist, it will be hard for them to be both big in the same niche. It is more likely that one cannibalizes the other due to the network effect.  It would be nice if Haskell would get big. But for the moment the tooling is lacking (language and type system are already excellent, the libraries and the documentation are good enough).  A very cool move would be to bring Haskell to the JVM. Then Java, Scala and Haskell could complement each other and would all three benefit from the network effect. But I doubt that this will be possible in a reasonable time frame."
haskell,3dnrpl,tdammers,1 point,Mon Jul 20 14:15:02 2015 UTC,"Haskell has less traction than F# or Scala in sheer numbers, but the quality and stability of the community are superb. I wouldn't exactly consider those languages ""alternatives"" or ""competition"" either, they're not exactly competing for the same niche - their use cases are ""reasonably close to typed functional programming while being able to run on JVM/.NET with minimal friction"", whereas Haskell's use case is ""typed functional programming without compromise"". The latter is certainly more niche still, and probably will be for the foreseeable future, but it has a certain aesthetic to it, and some really interesting benefits for some use cases.  Haskell is not going to get big IMO, and it wouldn't be a good thing if it did; the unofficial motto ""Avoid success at all cost"" is, I believe, spot-on. If Haskell wanted to become more mainstream, concessions would be required, and that would require loosening some of the principles that make Haskell what it is. Haskell has not one string-like data type, but at least 5 of them; that's confusing for beginners, but it is the right thing to do, and reducing these types to one or two would make Haskell weaker in some of its strongest areas. And pretty much everything about Haskell that makes it less palatable for people coming from an imperative background and needing results sooner rather than later, is like that. And for exactly the same reasons, Scala isn't going to take Haskell's niche either: it will never be the ""no concessions made"" functional-programming language that Haskell can be.  Bringing Haskell to the JVM; well, that could work, but there are two obstacles here that make this unlikely. The first one is that the number of people skilled enough to pull something like this off is very small, and they're all tied up in more pressing needs. And the second one is that the JVM itself, despite all its impressive merits, is somewhat at odds with the Unix philosophy, making it kind of a hot iron in the Haskell community.  But then again, Haskell doesn't need to become mainstream; it is already quite successful in terms of being influential and attracting a good user base. It acts as a breeding ground for cutting-edge programming concepts, and as a safe harbor for those seeking sanity away from the trenches of day-to-day enterprise programming."
haskell,3dnrpl,geggo98,1 point,Mon Jul 20 20:44:55 2015 UTC,"The problem is: They are competing. On funding and on brains. The amount of money put into research is limited. And the people capable of language development on that level even more so. So it would be nice if we could transform ""compete"" into ""complement"".  Regarding the JVM backend: Purescript seems to work on this. Let's see if they can optimize lazy evaluation for the JVM. If they can, this will be huge leap.  Regarding the Unix principle of doing one thing well: Some of my most favorite projects oppose this principle: The Linux kernel, the Emacs (although I am more a vi user...), C++, the KDE desktop, IntelliJ, Excel. It's a nice principle but it has it's limitations. I think it should be used with caution.  And regarding the ""Enterprise programmers"": Most of them aren't using Scala either. I think the communities for Scala, Haskell, Clojure and Purescript are quite similar in their behavior and their goals. It would be great if they could cooperate even more and inspire each other with their ideas."
haskell,3dnrpl,tdammers,1 point,Tue Jul 21 07:32:01 2015 UTC,"The problem is: They are competing. On funding and on brains.   In part, yes. OTOH, ""number of brains"" is a silly metric, and the kind of funding that goes into either has quite different motivations behind it - Haskell is first and foremost a research vehicle, Scala's goal is to build a hands-on language that brings some FP insights to the JVM in a practical way. The brains that are good at and attracted to one aren't necessarily interested in the other; I believe if Haskell didn't exist, neither Scala nor Clojure would be the thing they'd end up with. Likewise, I doubt Microsoft Research of FP Complete would go after Scala if Haskell weren't an option. In fact, I believe Haskell owes its existence in the first place to the fact that ""typed pure functional programming"" is a small but valuable niche.  Re Unix principles: sure, many popular open source projects violate ""Do One Thing Right"", and often, there are good arguments. Still, using the JVM means giving up a lot of the things you can normally take for granted on Unix (or Linux, as the case may be), the benefits being rather questionable (particularly in a situation where Haskell is a given), and my observation is that this goes against the grain of many Haskellers."
haskell,3dnrpl,yokohummer7,7,Tue Jul 21 15:18:17 2015 UTC,"In a Haskell sense, imperative programming is all about mixing implicit state changes. This cannot be done in Haskell because its type system forces you to separate various kinds of operations into various kinds of types. You need to lift things up and down. This is not necessarily a bad thing, but is also never a typical imperative programming. Using imperative style in Haskell is just as ugly as using functional style in imperative languages."
haskell,3dnrpl,srhb,7,Fri Jul 17 22:03:51 2015 UTC,"I think that's a myth, or at the very least an extremely niche opinion amongst people who actually do imperative stateful programming in Haskell.   Most people who actually do this are, obviously, probably Kool-aid Haskellers, but I think open-minded, modern imperative programmers would certainly prefer the explicit imperativeness (hah) of stateful, mutable Haskell."
haskell,3dnrpl,tdammers,3,Fri Jul 17 23:22:18 2015 UTC,"No, I meant that Haskell does mixing functional and imperative better, not that it does plain imperative better."
haskell,3dnrpl,Taladar,1 point,Sun Jul 19 13:49:46 2015 UTC,"What exactly is ""plain imperative""? Even the most imperative program usually has parts that are purely functional, e.g. every expression that doesn't use a pre- or post-increment operator."
haskell,3dnrpl,agocorona,2,Mon Jul 20 09:08:31 2015 UTC,That is a problem related with the use of a stack of monad transformers. I think that mt's are not a good idea for general programming scenarios and there are better alternatives
haskell,3dnrpl,codygman,2,Sat Jul 18 14:17:04 2015 UTC,"I think that mt's are not a good idea for general programming scenarios and there are better alternatives   Can you go into detail on this or present some examples? It was my understanding that monad transformers are the best way to use Haskell most of the time.  Also, what are the better alternatives? Do you mean like Purescript's effects?"
haskell,3dnrpl,agocorona,3,Sun Jul 19 06:20:08 2015 UTC,"Yes. Extensible effects are better than monad transformers. Transformers complicate the understanding of what´s going on, complicate the type signatures in the errors making them hardly understandable and are not commutative. But there is more;  When I was a beginner the monad transformers was the thing that most intimidated me. 90% of the problems use the same effects, so it is surprising that there is no standard monad that has all these effects included as well as many others necessary, instead of reconstruct the same stacks again and again. This makes practical programming for beginners much much more difficult.  I know that this is not popular to say among haskellers since  proficiency in the management of monad transformers is the first commandment of haskellness. so to say. But this shouldn't be mandatory for everyone."
haskell,3dnrpl,sambocyn,2,Sun Jul 19 09:09:34 2015 UTC,"the argument I've read is that effects shouldn't commute because they don't i.e. Cont can't have a MonadState instance or something, so you must explicitly pick the order. honestly I've never used either so I wouldn't know though."
haskell,3dnrpl,continuational,17,Sun Jul 19 18:08:39 2015 UTC,"I work for a startup where we use Scala. The reason is two-fold:   All the programmers came from the same company and already had experience with Scala. It was possible to introduce Scala in that company due to its great JVM interopability and its ""learn as you go"" transition from Java. Scala has a much better record system than Haskell, and we tend to use a lot of records when programming.   Most of all, Scala is a compromise that lets Java programmers be somewhat productive while they learn the full language. With Haskell, it's a much harder sell: ""Can we have a few month of zero productivity, while we take some time to learn a language you haven't heard of, and which won't work with any of our existing code?"""
haskell,3dnrpl,tdammers,3,Fri Jul 17 20:07:45 2015 UTC,"What do you mean by "" record system"" ?"
haskell,3dnrpl,mcjohnalds45,16,Fri Jul 17 20:44:01 2015 UTC,Records. Arguably one of Haskell's biggest pain points.
haskell,3dnrpl,jsantos17,6,Fri Jul 17 20:52:59 2015 UTC,"Just throwing it out there, Elm has a neat record system. You can do all the usual haskell stuff along with accessing fields with foo.bar. It also lets you declare a function that takes any record that contains specific fields, e.g  getNextPosition : {a | position : Vector2, velocity : Vector2} -> (Float, Float) getNextPosition object =     (object.position.x + object.velocity.x, object.position.y + object.velocity.y)"
haskell,3dnrpl,kyllo,2,Sat Jul 18 09:27:33 2015 UTC,Row polymorphism FTW.
haskell,3dnrpl,k-bx,12,Sun Jul 19 04:40:29 2015 UTC,Guessing where /u/continuational is going with this is the well-known issue that Haskell record fields are namespaced at the module level so you can't reuse field names across different records in the same module. Scala doesn't have the problem.
haskell,3dnrpl,rdfox,12,Fri Jul 17 20:54:25 2015 UTC,I guess we're all waiting for next major GHC 7.12 with OverloadedRecordFields
haskell,3dnrpl,continuational,7,Fri Jul 17 22:46:55 2015 UTC,Fingers crossed.
haskell,3dnrpl,ysangkok,4,Fri Jul 17 22:51:27 2015 UTC,"Exactly. It's a shame, because Haskell beats Scala in so many other areas."
haskell,3dnrpl,Tekmo,2,Fri Jul 17 21:28:15 2015 UTC,What is the typical workaround for this?
haskell,3dnrpl,kyllo,3,Fri Jul 17 22:47:16 2015 UTC,One module per record or prefix field names with the type name
haskell,3dnrpl,kraml,0,Sat Jul 18 00:48:22 2015 UTC,Just give all your records' fields globally unique names
haskell,3dnrpl,kyllo,3,Sat Jul 18 03:12:40 2015 UTC,"Not global, only in the module."
haskell,3dnrpl,kraml,1 point,Sat Jul 18 10:47:28 2015 UTC,"Sure, but then if you import that module into another module you have to import qualified or you could have a name clash again."
haskell,3dnrpl,edwardkmett,2,Mon Jul 20 15:04:28 2015 UTC,"I always import qualified, regardless. Not knowing where something is coming from without sophisticated dev tools is something I do not like.   Just as bad as 'from foo import *' in Python."
haskell,3dnrpl,tailbalance,29,Mon Jul 20 15:40:05 2015 UTC,"Scala runs on the JVM.  You can reuse and uptrain your existing Java developers, increasing interest in the work place and employee retention. Saying you're doing Scala is a great way to hire good high end people, people who are perceived at least as far more likely to still willing to work in Java and the like to help support the existing code base. It is also easier to sell to management as a way forward for your existing investment in technology, when you can just link your old code in and migrate gradually.  There is a lot to be said for a language that doesn't make you change your course 180 degrees all in one high-G turn from an ease of sale perspective. You can preserve a lot of your teams' existing momentum.  On the other hand, one might argue that it doesn't matter how fast you are going if you are going in the wrong direction.  There are also a ton of applications where a strict language with good interop is more valuable than a lazy language with its own peculiar way to view the world."
haskell,3dnrpl,CharlesStain,14,Fri Jul 17 20:22:32 2015 UTC,And many-many-many use Scala just as a little nicer Java. And that’s still counted as Scala!
haskell,3dnrpl,hagda,2,Fri Jul 17 21:40:25 2015 UTC,True story.
haskell,3dnrpl,sideEffffECt,9,Sat Jul 18 09:30:38 2015 UTC,"So would it be any good to have something like ghcjs but insteadof targetting JS engines,  targetting the JVM?"
haskell,3dnrpl,recursion-ninja,6,Fri Jul 17 22:27:17 2015 UTC,Why isn't GHC available for .NET or on the JVM?
haskell,3dnrpl,Taladar,4,Sat Jul 18 10:20:52 2015 UTC,"Yes, we should target many architectures, including the JVM"
haskell,3dnrpl,tdammers,1 point,Sat Jul 18 00:35:12 2015 UTC,The JVM is not a traditional architecture though. It has a lot of assumptions from the high level Java language built into the low level instructions which is the reason most alternative languages on the JVM are such a mess of features drawn from clean designs on the one hand and Java on the other.
haskell,3dnrpl,ForTheFunctionGod,11,Mon Jul 20 09:13:46 2015 UTC,"In a nutshell, JVM, and risk aversion.  As terrible as Java is as a language, the JVM is actually quite impressive, and is probably one of the most battle-proven application platforms out there. It's not the most programmer friendly platform, but sysops and IT managers alike love it.  As far as risk aversion goes; if you switch from Java to Scala, you exchange one part of your system, and you can do it gradually, replacing one component at a time, whenever it seems feasible. No new libraries, no new configuration tools, your existing deployment pipeline just works; the risk can be made as small as you want to. With Haskell, the only way to get something comparable is if you already have a language-agnostic modular development pipeline set up, which is possible, and a very good idea, but quite uncommon in practice."
haskell,3dnrpl,codygman,9,Fri Jul 17 21:07:37 2015 UTC,"Disclaimer: I programmed Scala for 1.5 years and had a very bad time.  Two reasons:   Compatibility with the JVM. Scala can natively make use of Java-libraries, which is a huge boon, both in terms of code-base and continuity with legacy applications. On the other hand, I think that people have a false sense of security when it comes to interacting with legacy Java-applications: most are written in a thoroughly imperative style and do not fit well with Scala's functional combinators. map and fold are all well and good, but you can't use them if you have ApplicationControllerObjects and BusinessProcessStep34Interfaces that take no parameters and send hidden TCP requests everywhere. Lack of safety. Outside of the Haskell community, things like (strict) type systems, theory, purity, formal semantics, proofs, etc. are viewed in a dim light. They are equated with being opinionated and close-minded, and programmers regard them as impediments to ""getting the job done"". We here may see the dangerous unpredictability induced by putting every function into an implicit IO & State monad, but the overwhelming majority - already used to that - just likes the power afforded thereby. The danger is dismissed with ""I know what I'm doing"". Mind the popularity of PHP.   The first point makes it appealing to management, the second appealing to programmers. Incidentally, I think that it is these two that irredeemably corrupt and cripple the language. The JVM is not made for running functional programs (and it shows); the lack of a strictly adhered-to paradigm makes reasoning about programs nigh impossible. Consider that Scala has   hidden side-effects (IO), hidden variable mutation (State), hidden failure via null (Maybe), strict evaluation (Strict).   These features give even the simplest Scala function the following context:  def function (A1, A2,..., An) : B -- Scala function :: (A1,A2,...,An) -> StrictT (StateT GlobalState (MaybeT IO b)) -- Haskell   Imagine reasoning about an abomination like this in Haskell. Imagine if every single function were like this. Contrary to popular opinion, not being able to do certain things is very important in a programming language. Nothing in our historical or recent experience suggests that people can do things without fault; it would thus be very beneficial to software quality to protect programmers from the idiocy they always want to shove into the compiler. I fear, however, that Scala is not ""opionated"" enough to restrict them in such a manner, though.  Ultimately, Scala is no more a functional language than C# is. They both have casts, hidden IO, global state, variable mutation, nulls, and while-loops. On the other hand, they both have lambdas, combinators (LINQ), and partial application. You could implement Scala's useful features as a language extension and as a library on top of Java, but I suspect that there'd be a lot less consulting-money in that.  What Scala has in addition to C# is an extremely obtuse syntax that drowns you in a sea of curly braces and a basket of confused and needlessly complicated features: traits; 2 kinds of subtype constraints, of which only one works with traits; 2 kinds of partial application, companion objects, implicit casts, object meaning ""singleton"" (!!!),... And don't get me started on the standard libraries. List inherits from 43 classes/traits. Sure, [] implements a lot of stuff in Haskell too, but what the hell does GenericTraversableTemplate do? How is it different from GenTraversableLike?"
haskell,3dnrpl,syrig,8,Sat Jul 18 14:30:32 2015 UTC,One of my previous positions did Android work. It was much easier to use Scala than Haskell for Android.
haskell,3dnrpl,pythonista_barista,5,Fri Jul 17 20:15:09 2015 UTC,"Another thing I'd like to mention is that Scala allows pretty sophisticated OO way of compositing traits/class, which allows you to do some fancy things that you can't do with traditional OO languages like Java and C++.  People who pick up Scala don't simply regard it as a functional programming language."
haskell,3dnrpl,cies010,6,Fri Jul 17 20:52:45 2015 UTC,"JVM interop. Businesses have a lot invested, and frankly there's more people that know it. We use clojure at work for that reason."
haskell,3dnrpl,reaganveg,5,Fri Jul 17 21:34:18 2015 UTC,"It has been mentioned in a thread somewhere, but I want to have it on the top level as well. There is a mostly-Haskell language on the JVM called Frege. I think it should be part of this discussion as the JVM is mostly quoted as the main reason for using Scala over Haskell."
haskell,3dnrpl,cies010,3,Sat Jul 18 10:19:25 2015 UTC,"It runs on the JVM, but does it make it easy to work with existing Java libraries?  The Haskell language itself, it seems to me, kind of works against that.  But maybe there is some clever way of making things fit."
haskell,3dnrpl,reaganveg,1 point,Sun Jul 19 01:37:16 2015 UTC,How would this be harder then calling C from Haskell? The data moving over language boundries needs to be properly typed in both cases.  I think there is some work by Frege to make it easy in simple cases.
haskell,3dnrpl,cies010,2,Sun Jul 19 02:46:22 2015 UTC,"Calling Java from Haskell like calling C from Haskell would be a big burden.  It would be just like having to call into a C++ library through exported C interface -- you're losing functionality.  With Java you have the OOP type system, with subtypes and runtime dispatching.  Then you have the Java generics stuff, which (I don't really know, but would presume) probably does not cleanly map onto Haskell polymorphism.  You need to somehow map all that onto Haskell to make working with Java convenient and accessible.  That to me seems very hard to do (but NB. I'm not claiming it's impossible).  But Scala can do it much more easily because it was designed to work with Java from the ground up."
haskell,3dnrpl,gelisam,3,Sun Jul 19 03:06:10 2015 UTC,"Sure easier with Scala, but then you also have the burden of a multi-paradigm language. To be honest, from what I know about Scala land, they don't like to break out into using Java much. They prefer to move the Java interactions to the ""edges"" of the application, much like in Haskell land we like to move IO and FFI to the edges."
haskell,3dnrpl,hagda,4,Sun Jul 19 09:35:18 2015 UTC,"My understanding is that it's easier to transition from Java to Scala than to switch to a completely different language. I would thus assume that new companies would be more likely to start with Haskell than with Scala, while existing Java companies would be more likely to transition to Scala than to Haskell."
haskell,3dnrpl,jamlothar,8,Fri Jul 17 19:52:04 2015 UTC,"Maybe because they haven't seriously tried Haskell? The devs I know that have used both, Scala and Haskell prefer Haskell hands-down and mostly complain about Scala being so incoherent and unecessarily complex..."
haskell,3dnrpl,gantabhacht,3,Fri Jul 17 22:21:17 2015 UTC,"Would be interesting to ask the opposite question: why did you choose Haskell over Scala?  (maybe in another thread?)  Of course, we could expect far less answers with experience reports. Nevertheless, those answers would be interesting IMHO"
haskell,3dnrpl,hagda,4,Sun Jul 19 07:41:30 2015 UTC,"As someone who primarily works in Scala and has recently been working on Haskell, I think there are a few main reasons:   You can (basically) write Java in Scala, and it still works. Syntax-wise, the language is very approachable for someone coming from a java/algol-esque background. You can use all the (lovely) JVM libraries out there, and can interact with a legacy java codebase pretty easily.   Although I doubt that they're highly relevant for companies, there are a few nice things about Scala that are worth mentioning:   Subtyping is pretty cool, when you also have type parameters and variance Access modifiers are fairly nice, and Scala has fairly fine grained ones"
haskell,3dnrpl,gantabhacht,6,Fri Jul 17 21:15:52 2015 UTC,Isn't subtyping the reason you can't have all that cool advanced type-inference in Scala that Haskell has?
haskell,3dnrpl,zoomzoom83,2,Fri Jul 17 22:23:16 2015 UTC,"It is the reason you can't have guaranteed fully automatic type-inference, but the (admittedly less powerful) type inference works most of the time."
haskell,3dnrpl,der_luke,2,Fri Jul 17 23:25:29 2015 UTC,"For us, we started with Scala as a ""better Java"". It was a few months before the FP bug really took hold.   Scala also has the advantage of being on the JVM and having great integration with Java. If we hit a roadblock with pure FP Scala, we can either trivially revert to an imperative style or just use Java.  This also means I can hire a Java developer and have him productive on day one, spooling him up on FP gradually.   Haskell is unquestionably a better language on paper, and if I was starring a new project I'd seriously consider it. But Scala with Scalaz, Wartremover, and a little discipline gets you pretty far and is a safer bet commercially.   Tl;Dr On a personal project, I'd use Haskell. When a few million dollars of venture capital is on the line, I'd use Scala."
haskell,3dnrpl,PhineasRex,2,Sat Jul 18 07:47:36 2015 UTC,the scala api for spark is much better than the python or java ones.
haskell,3dnrpl,eriksensei,2,Sat Jul 18 11:48:50 2015 UTC,"The company I work for switched to Scala from PHP a few years ago. Nobody had heard of Haskell and the switch to Scala was based largely on their ""The Next Java"" marketing.  As a result of using Scala, we've switched to a more functional programming style and Haskell is well-known among developers but switching languages is expensive."
haskell,3dnrpl,precium,2,Sat Jul 18 16:39:52 2015 UTC,"In addition to what others mentioned, I would say because of availability of jobs and, ironically, developers. I believe a lot of managerial types like to think of developers as a homogeneous mass of interchangeable sprockets."
haskell,3dnrpl,SixBitProxyWax,1 point,Sat Jul 18 22:22:33 2015 UTC,"You are correct based on a rational analysis, Haskell clicks far, far more boxes than Scala. But people and especially enterprises don't act rationally.  Over the last 5-8 years, it would have been a reasonable (many did) for a company to introduce Scala, but enough has been learned that net-net one would be far better starting to introduce Haskell these days or just staying pat with Java and ignore Scala.  Similarly, say 5+ years ago Haskell would not have been a been a reasonable choice to attempt to introduce into the Enterprise.  Today however, Haskell is the better choice.    I'll go ahead and say it, there are enough learnings these days from actual Scala adoption efforts in the Enterprise to reasonably state that introducing Scala these days, for most companies, would be a mistake."
haskell,3dnrpl,precium,5,Fri Jul 17 21:43:43 2015 UTC,"Today however, Haskell is the better choice.   For some definitions of ""better."""
haskell,3dnrpl,codygman,1 point,Fri Jul 17 22:59:58 2015 UTC,"OK... For the preponderance of definitions of better, Haskell is more likely than not, the correct choice, today, then Scala."
haskell,3dnrpl,clrnd,2,Fri Jul 17 23:49:27 2015 UTC,I'll also say that Typesafe Activator is really awesome.
haskell,3dnrpl,absence3,1 point,Sat Jul 18 05:34:42 2015 UTC,JVM+JAVA Libraries
haskell,3dnrpl,thecity2,2,Fri Jul 17 20:05:48 2015 UTC,"Scala is similar to the latest versions of Java, C#, and C++ in that they're imperative and mostly object oriented languages with constructs that fascilitate a somewhat functional style. I suspect answers are similar as to why Java is preferred over Haskell."
haskell,3dnrpl,thecity2,-7,Fri Jul 17 20:33:16 2015 UTC,IRL
haskell,3dnrpl,autourbanbot,2,Fri Jul 17 20:31:55 2015 UTC,what is IRL ?
haskell,3do8hd,gallais,5,Fri Jul 17 21:54:51 2015 UTC,I'm honored to find that this was posted by someone other than me :o
haskell,3do8hd,psygnisfive,3,Sat Jul 18 00:32:29 2015 UTC,Nice post. Hopefully I can steal some aspect of it for implementing display forms in JonPRL.
haskell,3do8hd,jonsterling,1 point,Sat Jul 18 09:41:37 2015 UTC,You'd better! We need those display forms to look nice! :)
haskell,3dmu7t,pchiusano,9,Fri Jul 17 15:34:29 2015 UTC,Why do you want a QUIC implementation?  Are you hoping to use it in conjunction with a haskell web server library/framework?
haskell,3dmu7t,tom-md,6,Fri Jul 17 16:59:25 2015 UTC,"I was considering it for the Unison inter-node protocol, which is totally sessionless. This means that TCP (and definitely TLS) handshaking is a lot of overhead. A UDP-based protocol with no handshaking would be great. Of course, we could write our own, but that might be a lot of work."
haskell,3dmu7t,aseipp,4,Fri Jul 17 22:02:28 2015 UTC,"I don't know of any other implementations of QUIC outside of the Chrome codebase (there's an extracted copy here with minimal dependencies - nice since Chrome code is normally all tangled together), but I don't think there's a lot of momentum yet so I haven't seen much deployment or other specifications of it currently.  It's not quite the same thing, but another protocol in the same ballpark I've been rooting for is Noise, which has a lot of great ideas, although at the moment it's TCP. It's worth mentioning it also doesn't do stream multiplexing or anything like QUIC/SPDY do, although I admit I admire Noise precisely because it's simple and low level.  I feel like I'm advertising, but I do have an implementation of it here I cobbled together a while ago, and it's okay (even with a good tutorial IMO) but it implements an older revision of the draft spec. It's also not clear when a first revision will be published or when it will include things like stream resumption (so then UDP can be used for mobile applications, if you did something like congestion control or whatever yourself).  For now, unless you want to write some adaptor C++ code for libquic and a Haskell wrapper, I'd say you're probably better off keeping your eggs in the TLS basket I suppose."
haskell,3dmu7t,hastor,1 point,Fri Jul 17 21:34:28 2015 UTC,"Thanks, that is helpful! And Noise looks pretty interesting."
haskell,3dmu7t,tom-md,2,Fri Jul 17 23:45:37 2015 UTC,Now that we have a socket library that supports UDP I guess it would be possible to implement this protocol.
haskell,3dmu7t,hastor,4,Fri Jul 17 20:26:22 2015 UTC,"Your comment confuses me.  'network' has had UDP support, via rather raw bindings to traditional berkley sockets, for many many years, dating back to the beginning the packaging in Haskell ~2007."
haskell,3dmu7t,tom-md,2,Fri Jul 17 22:24:55 2015 UTC,Read this thread: https://www.reddit.com/r/haskell/comments/2o5558/is_network_library_poorly_implemented_or_am_i/cmjtvxd
haskell,3dmu7t,hastor,1 point,Sat Jul 18 21:33:30 2015 UTC,So bugs exist.  We all know the network library could use more love.
haskell,3dmu7t,kolmodin,1 point,Sun Jul 19 07:38:13 2015 UTC,Seems more like design issues.
haskell,3dlz6b,absence3,7,Fri Jul 17 10:13:15 2015 UTC,"Trying get a feeling for these objects; from the article, we need a set M and two monoids over M with multiplicative identity and distributive product (see below)  (M, ⊗, e, ⊕, z) where both (M, ⊗, e) and (M, ⊕, z) are monoids for the same set M; moreover, the following laws relate both structures: z ⊗ a = z  (a ⊕ b) ⊗ c = (a ⊗ c) ⊕ (b ⊗ c)  Here ⊗ is the multiplication of the near-semiring, ⊕ is the addition, e is the unit, and z is the zero.  Why the ""near-"" label? Because of the absence of a commutative operation?   Also, the implications for search strategies seem intriguing, I'd like to understand more"
haskell,3dlz6b,ocramz,2,Fri Jul 17 12:45:55 2015 UTC,"A near-semiring is a semiring, except that the 2nd operation doesn't have an identity. Maybe it's because Alternative doesn't have a unit?"
haskell,3dlz6b,ForTheFunctionGod,9,Fri Jul 17 13:16:29 2015 UTC,"Not just that, it only has one of the two distributive laws.  MonadPlus has at least a left unit. Alternative is a bit more murky."
haskell,3dlz6b,edwardkmett,2,Fri Jul 17 15:14:59 2015 UTC,"If (M, ⊕, z) is a monoid, isn't z the identity for ⊕?"
haskell,3dlz6b,rampion,3,Fri Jul 17 14:38:31 2015 UTC,"Yes, but a commutative monoid and a monoid give you a semiring, not a near-semiring. I don't know whether the statement in Section 2.2 of the paper uses different terminology from what I know, but by my reckoning, it's wrong:  https://en.wikipedia.org/wiki/Near-semiring"
haskell,3dlz6b,ForTheFunctionGod,5,Fri Jul 17 15:28:26 2015 UTC,"The problem is that roughly half of the instances we have for MonadPlus and Alternative today do not satisfy the oidification of the right-seminearring laws mentioned here.  There are really two or more families of MonadPlus instances. There are those satisfying ""left catch"" and those with ""left distribution"" -- some satisfy both.  Maybe, IO, and almost anything that doesn't use a list or other source of non-determinism fails these law and fails them badly.  Most monad transformers preserve the ""sense"" of what MonadPlus law they inherit from the base monad, but then things like EitherT e, or variations on ListT change the meaning of (<|>)  It gets worse when you move to Applicative vs. Alternative, because then things like Backwards have a right unit instead of a left one, and the extra structure afforded by Applicative makes the type enforced left unit law we had in MonadPlus becomes an arbitrary imposition, even less likely to hold as we can see with Backwards. =(  So this is definitely the essence of something nice to have, it just isn't the essence of the MonadPlus or Alternative classes we have today."
haskell,3dlz6b,edwardkmett,5,Fri Jul 17 15:24:20 2015 UTC,"I think you misunderstand the paper. It takes great pains to explain that this generalization is not the only one, and it does not seek to provide a new law for Alternative or MonadPlus.  Rather, given one set of laws, it provides new constructions for the free Alternative and the free MonadPlus arising from a functor generalizing the constructions of the free Applicative and the free Monad arising from a functor."
haskell,3dlz6b,sclv,3,Fri Jul 17 17:03:21 2015 UTC,"The objection I took comes from an early statement in the paper:   This paper provides a new algebraic understanding of the operations of the MonadPlus type class.  We establish that both MonadPlus (Section 4) and Alternative (Section 5) are instances of this generalised notion, and we specialise the constructions for both cases.   Both of these claims seem to be stating something very broad about the actual class we have today.  It isn't until more or less a footnote at the end of section 6 that the paper even alludes to the fact that this isn't connection isn't about ""the class we have today"" but rather that   A MonadPlus instance satisfying equations 6, 7, 8, 11, and 12 is an instance of a generalised near-semiring, and we call it a non-determinism monad.   and then the old MonadPlus reform proposal is mentioned and the dirty laundry is aired at all. By then they've been talking about MonadPlus and Alternative unambiguously for several pages.  Perhaps my issue is more with the order of the presentation. If you read it with sufficient care you may be able to tease out truth from the contents, but its written in such a way that I find it very hard to see that they are claiming this about a new class rather than describing the existing state of affairs in the existing class."
haskell,3dlz6b,edwardkmett,8,Fri Jul 17 18:11:08 2015 UTC,"They get to it very clearly in the conclusion.  As you well know, the correct order to read a paper is intro, citations, conclusion, related work, and then maybe the middle bits :-P"
haskell,3dlz6b,sclv,4,Fri Jul 17 19:52:02 2015 UTC,Touché
haskell,3dlz6b,edwardkmett,6,Fri Jul 17 20:14:10 2015 UTC,"A few years ago, I was working on a monad package (abandoned when transformers came out) which provided distinct mplus (distributive) and orElse (catch) operations. Nondeterminism monads could provide both, and there were wrappers to recover the monoids.  class (Monad m) => ZeroMonad m where     mzero :: m a  class (ZeroMonad m) => MonadPlus m where     mplus :: m a -> m a -> m a  class (ZeroMonad m) => AlternativeMonad m where     orElse :: m a -> m a -> m a     ifZero :: m a -> m b -> (a -> m b) -> m b  class (MonadPlus m, AlternativeMonad m) => ChoiceMonad m where     msplit     :: m a -> m (Maybe (a, m a))     interleave :: m a -> m a -> m a     (>>-)      :: m a -> (a -> m b) -> m b     once       :: m a -> m a   This might need some rethinking now that Applicative => Monad, but I think it's a design worth considering."
haskell,3dlz6b,davemenendez,1 point,Fri Jul 17 17:36:17 2015 UTC,"I hope the linked exposition on MonadPlus / Alternative doesn't become a widely spread factoid, like Arrows = Categories + Applicative."
haskell,3dlz6b,danharaj,2,Fri Jul 17 16:51:28 2015 UTC,Arrows = Categories + Applicative   What's wrong with that?
haskell,3dlz6b,tomejaguar,1 point,Sat Jul 18 07:14:38 2015 UTC,It's not true.
haskell,3dlz6b,danharaj,1 point,Sat Jul 18 14:15:43 2015 UTC,Why not?
haskell,3dlz6b,tomejaguar,1 point,Sat Jul 18 15:32:35 2015 UTC,"Well, for one, the blog post that popularized the idea never finished, and ended up having to add coherency laws between Category + Applicative to get far as it did.   It's a close attempt though. The catchiest way of thinking about arrows is as strong monads in the category of endo-profunctors. This is very similar, but not quite Category + 'Monoidal functor in the covariant argument' (Applicative)."
haskell,3dlz6b,danharaj,1 point,Sat Jul 18 15:56:52 2015 UTC,"If you simplify Exp f g x to just f x -> g x, the double cayley representation is exactly the same as LogicT, with success and failure continuations.  (I'm guessing Exp has Yoneda applied just to make it a functor?)"
haskell,3dlz6b,sjoerd_visscher,-5,Sun Jul 19 00:12:52 2015 UTC,Is this a spam post? Why linking to a blog summary instead of the original paper?
haskell,3dlz6b,BanX,6,Fri Jul 17 17:29:08 2015 UTC,The post is by one of the authors of the paper.
haskell,3dlz6b,edwardkmett,0,Fri Jul 17 18:12:05 2015 UTC,"I understand, but I think that it would be more fruitful to link directly to the original paper instead of redirecting the traffic to a summary blog."
haskell,3dlz6b,BanX,5,Fri Jul 17 20:22:30 2015 UTC,Linking to the blog post by the author gives us access to any comments that may get made there on his page and makes it easier to find all the related papers they've been writing recently.  There are enough pros and cons to both approaches for me to chalk it up to personal preference and shrug.
haskell,3dn1hu,ocramz,6,Fri Jul 17 16:30:03 2015 UTC,"An interesting variant on this theme is to look at something like an ""update monad"".   class Monoid u => Action s u where   act :: s -> u -> s  with    act s mempty = s  act (act s m) n = act s (mappend m n)   Then you can make a monad transformer:  newtype UpdateT s u m a = UpdateT { runUpdateT :: s -> m (a, u) }   With this you can ensure that the monoidal values you use to update your state can't just 'go to any state' but rather offer a limited vocabulary. This avoids (some of) the rollback problems that usually arise with state.  I used the update monad construction in  https://www.fpcomplete.com/user/edwardk/heap-of-successes if you want a longer winded explanation of the idea."
haskell,3do1x5,ThrowawayTartan,1 point,Fri Jul 17 21:03:18 2015 UTC,"Think of the problem recursively.  What are all the codes of length 1?  Given all the codes of n-1, how do you create all the codes of n?  I don't want to give too much away, but if this is too vague, I'll try to give a more detailed hint."
haskell,3do1x5,neilthecoder,1 point,Fri Jul 17 21:10:12 2015 UTC,"Hey there! :) So if I had to ""hard-code"" all the lengths of it, I think it would be like this   allCodes 0 = [] allCodes 1 = [""red"", ""Green"", ""Blue"", ""Yellow"", ""Orange"", ""Purple""]  allCodes 2 = take each element of the Colors, and append it to independent values of allCodes 1 (Meaning R-R, R-G,...R-P, G-R,...G-P,....P-R,...P-P)  and so on?  I think I understand how to do it or at least on a human level and in an imperative way. But I'm not sure how one would do it in an FP way."
haskell,3do1x5,AlmostProductive,1 point,Fri Jul 17 21:20:18 2015 UTC,Go back to the hint. Think about how to approach the problem if you restrict the type of concatMap to this:  concatMap :: (Code -> [Code]) -> [Code] -> [Code]
haskell,3dngke,rpglover64,3,Fri Jul 17 18:22:16 2015 UTC,"For me, the first step from translating from a recursive definition to a recursion scheme is writing separately what a single step of the recursion is doing. From there you can try to match that against an existing pattern."
haskell,3dngke,Manwichs,2,Fri Jul 17 18:36:47 2015 UTC,"That's usually my approach too. I just got stuck on the local part; I'm saddened that as far as I could come up with, the solution is to not use Reader there."
haskell,3dngke,sccrstud92,3,Fri Jul 17 19:04:16 2015 UTC,"Here are two new ways to do it, in main2 and main3.  {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE TupleSections #-} import Data.Maybe (fromMaybe) import Control.Monad.Reader import Data.Functor.Compose import Data.Functor.Foldable  gl =   [ (0, [0, 1, 4])   , (1, [0, 2])   , (2, [3, 4])   , (3, [2, 1])   , (4, [])   ]  g x = fromMaybe [] $ lookup x gl  echo x y = liftIO $ putStrLn $ x ++ show y  dfs graph start =   asks (elem start) >>= \b ->     if b       then echo ""Cycle detected involving: "" start       else do         echo ""Visiting: "" start --      Use of `local` below --      vvvvv         local (start:) $ do --        Explicit recursion below --               vvv           mapM_ (dfs graph) $ graph start         echo ""Done with: "" start  main = runReaderT (dfs g 0) []   g2 :: ([Int], Int) -> (Int, Maybe [([Int], Int)]) g2 (path, s) = if elem s path     then (s, Nothing)     else (s, Just $ map (s:path,) $ g s)  f2 :: (Int, Maybe [IO ()]) -> IO () f2 (start, foo) = case foo of     Nothing -> echo ""Cycle detected involving: "" start     Just actions -> do         echo ""Visiting: "" start         sequence_ actions         echo ""Done with: "" start  main2 = hylo (f2 . getCompose . getCompose) (Compose . Compose . g2) ([], 0)   g3 :: Int -> (Int, [Int]) g3 s = (s, g s)  f3 :: (Int, [ReaderT [Int] IO ()]) -> ReaderT [Int] IO () f3 (start, actions) = asks (elem start) >>= \b -> if b     then echo ""Cycle detected involving: "" start     else do         echo ""Visiting: "" start         local (start:) $ sequence_ actions         echo ""Done with: "" start  main3 = runReaderT (hylo (f3 . getCompose) (Compose . g3) 0) []   I think main2 is like close to a solution using State, while main3 is closer to your solution, using Reader. As far as I can tell, they all produce the same output."
haskell,3djeaj,rorriMnmaD,26,Thu Jul 16 19:19:19 2015 UTC,"This is a repo that has worked well for me. The author is in the process of writing a book. I got the early access version, and it is really good so far. At the moment, they've just covered up to folds, so it isn't comprehensive quite yet, but I found it to be much more useful/helpful than eg Learn You A Haskell."
haskell,3djeaj,ephrion,10,Thu Jul 16 19:51:11 2015 UTC,"Bitemyapp's ""Learn Haskell"" has worked well for me too. If you are an absolute beginner, definitely check out the book he recommends, ""Haskell: the Craft of Functional Programming"". It's a really good introduction to recursion and the basic language. The best part of the book are all the great exercises."
haskell,3djeaj,nootloop,12,Thu Jul 16 20:20:42 2015 UTC,"Price is rather steep, and especially so for early access. It's going for $59 dollars from what I can tell. Richard Bird's ""Thinking Functionally with Haskell"" is only $39.99, and he's well established in the computer science community."
haskell,3djeaj,emarshall85,6,Thu Jul 16 22:01:45 2015 UTC,"I'm a newb, and I have all three (Learn You a Haskell; Haskell, the Craft of Functional Programming; and Thinking Functionally with Haskell).  LYAH is great for being an approachable text, but also has more detail on monads than the other two (although it includes no exercises).  HCFP is more mathematical and thorough, and the exercises are very good.  TFH is even more mathematical, slightly less thorough, but has exercises INCLUDING answers.  My method has been as follows: I read LYAH twice to get the lay of the land, then read HCFP once and now I'm working through the exercises.  Once I do that I'll do TFH (which by then I will mostly breeze through).  It's worth noting that I personally looked through bitemyapp's recommended links and even spent a lot of time on the Yorgey CIS194 course -- for whatever reason, that stuff felt like it was moving too fast for me.  With the books, I've had no problems and am making good progress. Everyone is different.  Good luck!  (BTW, I also first got LYAH and HCFP from the library for free before buying, I strongly recommend that -- I'm guessing that a major city library should have them.)"
haskell,3djeaj,HaskellOpenBSD,2,Fri Jul 17 03:04:04 2015 UTC,"The book is great, but as has been said it isn't done yet. I'm sure the guide covers this, but #haskell-beginners on Freenode is a great place to get help with CIS194 and NICTA."
haskell,3djeaj,colonelflounders,21,Fri Jul 17 10:59:38 2015 UTC,"In my opinion, no. There are a lot of OK books for beginners, but they all have their own approaches and none is suitable for all. There's basically no books on Haskell techniques more advanced than the dated ones in Real World Haskell."
haskell,3djeaj,danharaj,4,Thu Jul 16 19:42:12 2015 UTC,"That's exactly what I was worried about  So everyone here just ""hacked it out"" to get to their level?  Don't get me wrong, I see the value in learning this language (plus there's something very satisfying about it that I can't quite put my finger on) but I'm amazed a 20 year old language is lacking ""gurus"""
haskell,3djeaj,ephrion,23,Thu Jul 16 19:47:01 2015 UTC,"Oh, we have tons of gurus. If anything, we have too many!  Most Haskell stuff out there is for an advanced Haskell audience. Academic papers, blog posts with more category theory than code, etc. And I love that this stuff is out there -- but there's a lack of material that's accessible for beginners."
haskell,3djeaj,htebalaka,10,Thu Jul 16 20:29:04 2015 UTC,Don't be afraid to ask questions on IRC (and also don't be afraid to ask people to slow down if it's over your head). There's a very wide range of expertise on IRC.
haskell,3djeaj,julesries,4,Thu Jul 16 20:25:44 2015 UTC,"Both #haskell and #haskell-beginners are great resources. People there tend to be very patient, and the channels are very active compared to much of IRC. I'm consistently amazed at the patience and devotedness of bitemyapp, monochrom, and a few other users."
haskell,3djeaj,_AndrewC_,1 point,Sat Jul 18 20:14:37 2015 UTC,"That's a joy to read, thanks.   I've always found the Haskell community on SO more patient and helpful than average, and certainly here on reddit too."
haskell,3djeaj,danharaj,7,Sun Jul 19 15:27:22 2015 UTC,"Oh, there are definitely gurus. They just haven't written the great haskell tome yet.  I learned using this: https://www.haskell.org/tutorial/  That was 7 years ago. There's definitely not a single place where all of my accumulated knowledge is written down pedagogically. And I wouldn't consider myself a guru."
haskell,3djeaj,singpolyma,4,Thu Jul 16 19:55:26 2015 UTC,"Oh, there are definitely gurus. They just haven't written the great haskell tome yet.   Because books about programming topics are basically not worth writing (except maybe for the money).  Get outdated way too fast."
haskell,3djeaj,ocramz,2,Thu Jul 16 20:42:29 2015 UTC,"This might be true for ""Potato.js for Dummies"", but the basics of Hs deserve a textbook. A ""live"" format such as the online version of RWH, with slots for (moderated) reader annotations, would be quite optimal, I think .."
haskell,3djeaj,singpolyma,2,Fri Jul 17 12:18:42 2015 UTC,"So everyone here just ""hacked it out"" to get to their level?   Um. Yes?"
haskell,3djeaj,codygman,9,Thu Jul 16 20:41:38 2015 UTC,I personally found Beginning Haskell to be a very good and comprehensive book.
haskell,3djeaj,ignorantone,2,Thu Jul 16 19:36:39 2015 UTC,"I liked it too. One plus is that it covers up to date libraries, like lens. The motivation for using various libraries is presented well. Real World Haskell is behind in the library aspect, through no fault of its own (the passing of time). One minus of Beginning Haskell is a large number of typos, and (a little more concerning) some errors in the code examples & exercises. I was able to get over the errors and still learn plenty from it.  I read it as a beginner."
haskell,3djeaj,ocramz,1 point,Thu Jul 16 22:43:08 2015 UTC,Did you read it as a beginner?
haskell,3djeaj,johnbokma,6,Thu Jul 16 19:57:14 2015 UTC,"Some of LYAH but yes it's a bit too light after a while, then the wikibook ( https://en.wikibooks.org/wiki/Haskell ), then all FP101x videolectures by E. Meijer (w00t!), ""the essence of functional programming"" by P. Wadler, as many Functional Pearls as you can, then RWH as suggested above, then Marlow's ""Parallel and Concurrent Programming in Haskell"", then the stars !  :) enjoy the ride"
haskell,3djeaj,ocramz,3,Thu Jul 16 20:06:14 2015 UTC,"I also did https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0 . I am not really in ""instruction videos"" but at 1.5 speed it was actually fun to watch. The book, Programming in Haskell, it follows is also very good, IMO.  If you want an academic(-ish) approach pick either ""Programming in Haskell"" or ""Thinking Functionally with Haskell"". If you want a lighter read, ""Learn You a Haskell for Great Good"". I have all three (and some more)."
haskell,3djeaj,johnbokma,2,Fri Jul 17 00:22:05 2015 UTC,"calling FP101x ""instruction videos"" is a bit reductive; Erik knows the language inside out (and tons of other languages for comparison, to boot) and knows how to convey it (including, most importantly, what not to include, e.g. the intimidating terminology, vs. showing how to build up the complicated concepts)."
haskell,3djeaj,codygman,5,Fri Jul 17 12:14:01 2015 UTC,"With ""instruction videos"" I mean YouTube videos that have someone show how to do something. I don't mean that in a belittling way, and my apologies if it comes over like that; English is my second language, I am Dutch, like Erik. I often have a hard time watching such videos; in general I prefer to read about something, probably also because I can control both speed and direction. So I was very pleasantly surprised how much I enjoyed Erik's fp101x videos. What helped me was the ability to speed videos up to 1.25x or 1.5x. And it's funny to hear someone talk English somewhat like how I do it :-).  I am aware of who Erik is in the Haskell community, and most of his work I can't read yet. The course was a great experience, and I sincerely hope a Category Theory 101 is going to happen."
haskell,3djeaj,nootloop,1 point,Fri Jul 17 17:29:52 2015 UTC,Short answer: kind of  I'll write a more detailed answer when I'm at a keyboard.
haskell,3djeaj,clrnd,13,Thu Jul 16 20:04:08 2015 UTC,"This is one thing I feel like the Haskell community is missing. We really need a book that covers design principles and some more advanced concepts in Haskell. For instance, I don't think there is a single book that covers free monads, which is a popular design pattern for implementing DSL's. How many books talk about comonads? I think a book about good Haskell practices is sorely needed."
haskell,3djeaj,Crandom,3,Thu Jul 16 19:44:49 2015 UTC,"Definitely.  We have many nice introductory books, bot nothing even close to Effective C++.  It's a question of time, I'd say. We are still coming up with lots of new ideas and deprecating old ones. Exciting times, nevertheless."
haskell,3djeaj,singpolyma,2,Fri Jul 17 18:26:25 2015 UTC,I think this is partly because all those things have been invented/put to practical use relatively recently. There just hasn't been time for interest/practices to build up enough to make books on those topics viable.
haskell,3djeaj,WarDaft,2,Fri Jul 17 08:34:19 2015 UTC,What are these things???  I'm pretty convinced Haskell is superior in many ways but it's comments like this that are so demoralizing (not your fault)
haskell,3djeaj,ithika,7,Thu Jul 16 19:56:30 2015 UTC,"What are these things???   It's important to note that you can get lots (everything the working programmer needs) done without learning any of these ""advanced topics"".  I mean, I love them, but I know people who freeze up on the ""I'll never learn arrows and free monads and FRP and fancy new technique mark 67"", and the truth is that to get things done you don't need to.  Each topic has value, but only in some particular design space."
haskell,3djeaj,htebalaka,5,Thu Jul 16 20:45:22 2015 UTC,"Comonads are actually simpler than monads, or Free, in my opinion.  A comonad is like fmap, except you can use the whole structure to determine the result, and still be guaranteed that the structure doesn't change. Generally you only inspect the neighbourhood of the element you're working on, but you don't have to restrict yourself like that.  An example would be something like data Grid k a = Grid k (Map k a), where the Map must contain the key k. You then have a Map with one specific element singled out. If the key type k can be navigated by a left and right function, then a function to add up the local neighbourhood:  localSum (Grid k m) = sum <$> mapM (`M.lookup` m) [left k, k, right k]   can be applied to a whole grid by grid =>> localSum and the result will be every element replaced by Just the sum of itself and the elements to its left and right should both such elements exist, and otherwise Nothing. The keys and number of elements will be totally unchanged.  There are other things you can do with them, but personally, I started out just thinking of them as mapping but with access to more information."
haskell,3djeaj,ocramz,4,Thu Jul 16 21:19:49 2015 UTC,It seema odd that you think you should know these things but are looking for a beginner haskell book.
haskell,3djeaj,0Il0I0l0,3,Thu Jul 16 21:32:51 2015 UTC,"These two links are decent introductions to free monads. They essentially take a functor (like a list) and make it recursive:  Free [] a <=> data Tree a = Tree [Tree a] | Leaf a Free ((->) e) a <=> data PolyArgFn e a = Arg (e -> PolyArgFn e a) | Done a Free IO a <=> data PausableIO a = DoMoreIO (IO (PausableIO a)) | Finished a  --general form data Free f a = Free (f (Free f a)) | Pure a   Provided the first argument to Free (the [], (->) e, or IO) is a Functor then the Free version of it is a monad. It's possible to create a functor which represents a set of instructions, and then the Free version of that Functor can be used to represent (a peculiar type of) abstract syntax tree, which those links explain in more detail.  Comonads are probably best left for later. They seem a lot less common than free monads.  EDIT: Though if you're just starting out it's not terribly important until you've already got monads (and monad transformers) under your belt I think."
haskell,3djeaj,oneandoneis2,0,Thu Jul 16 20:07:50 2015 UTC,"True, but the OP was asking for a beginner introduction :)"
haskell,3djeaj,johnbokma,13,Thu Jul 16 20:10:09 2015 UTC,Learn You a Haskell for Great Good in my opinion is the best introduction to Haskell and also has 4.5/5 stars on amazon.
haskell,3djeaj,singpolyma,4,Thu Jul 16 19:36:03 2015 UTC,"I found LYAH to be an excellent intro to Haskell and the concepts - immutability, functors, monads, etc.  But I can't say that I reached the end of it and thought ""yup, I could now sit down and write a useful app in Haskell"" - more ""yup, I now understand the basics... How do I apply them?""  Brilliant intro.. But it's not enough to get you all the way to, say, quickly writing out a new command line app the way you could with a basic knowledge of Perl, ruby, etc"
haskell,3djeaj,jeremyjh,5,Thu Jul 16 20:16:00 2015 UTC,"What makes Haskell hard for me is that the documentation of modules often misses some simple examples of how to use it. Most Perl modules have a synopsis with some practical examples.  Another thing I bumped into twice this week was a ""deprecated module"". Ok, cool, but which module replaces it? The feeling I am (currently) getting is that by the time I can read the documentation of most modules I can write them myself. And I am far from that point, so it's a bit of chicken-egg problem; to make something useful without reinventing the wheel I want to use modules, but it's hard to figure out which ones, and how to actually use them."
haskell,3djeaj,dhjdhj,1 point,Fri Jul 17 00:30:09 2015 UTC,Really?  What would you say is missing?  I definitely started writing apps after LYAH.
haskell,3djeaj,singpolyma,2,Thu Jul 16 20:49:00 2015 UTC,"Well it does not even mention monad transformers for example, but that is one of the most basic concepts you need to understand in order to use many useful libraries, not to mention structure your own programs."
haskell,3djeaj,beerdude26,3,Fri Jul 17 01:04:21 2015 UTC,That's been the biggest problem for me. The books go so far but they just don't give me some of the real knowledge I need to do anything really significant.  I still think the biggest inhibitor is the lack of help/examples in the packages stuff. There are some great libraries available but I find it far too difficult to figure out how to use them because you just need to have a much deeper understanding of Haskell than essentially any other language with which I've ever worked to do anything.
haskell,3djeaj,sclv,2,Fri Jul 17 01:32:05 2015 UTC,I've been going through the web version but it still seems very superficial compared to any books I have on other languages  Other books I read and I immediately feel like I have a new toolset   LYHFAGG feels like a course for high schoolers (i.e. A lot of time spent of teaching stuff like recursion compared to time spent teaching WTF is Haskell in a real world concept)
haskell,3djeaj,singpolyma,15,Thu Jul 16 19:52:10 2015 UTC,"You would have no idea how many times I try to introduce experienced programmers to recursion, and I blow their minds so much that I have to stop and stay there for awhile to help them get it before moving on.  I run a workshop from time to time for experienced developers that starts with ""this is recursion, get it?"" and originally I thought that would be a do-nothing-and-move-on slide, but it turns out not so much..."
haskell,3djeaj,jocomoco,1 point,Thu Jul 16 20:48:21 2015 UTC,This has been my experience as well.
haskell,3djeaj,mcandre,3,Sat Jul 18 18:38:44 2015 UTC,"The https://www.haskell.org/documentation page has attempted to assemble a list of suggested resources.  None of them are like ""effective c++"". That book is not a first book, but a second book. One that presumes you know the language, and now teaches you best practices for working with it.  The issue is that the ""best practices"" for Haskell have been under quite a bit of evolution.  If you want a short dense read that spares no detail, something like Yet Another Haskell Tutorial or the Gentle Introduction is a classic to way to go through the core language.   But as always it depends what you want. Do you want to write webapps? Do you want to write number-crunching? Data-centric algos? Services? Do you want deep results in how to think about even basic functional programs? Depending on your ""angle"" there are better and worse resources for any given approach."
haskell,3djeaj,mcandre,4,Fri Jul 17 00:34:39 2015 UTC,Learn You a Haskell for Great Good is the best book for beginners.  It's really good.  It is how I learned.
haskell,3djeaj,ephrion,2,Thu Jul 16 20:46:01 2015 UTC,"I learned a lot of insight (as a beginner) from these lectures : https://www.youtube.com/watch?v=oLO34_5SMqU it really explains the most fundamental parts in great detail.  (Only part of the lecture series is available on youtube, the rest has to be downloaded from the original website, given in the comments.) I personally think, that these lectures are really underrated."
haskell,3djeaj,ocramz,5,Sat Jul 18 13:15:24 2015 UTC,Real World Haskell
haskell,3djeaj,andrewthad,1 point,Thu Jul 16 19:31:10 2015 UTC,"I was going to buy it, but some of the reviews make it sound really... Intimidating"
haskell,3djeaj,hsnoob,8,Thu Jul 16 19:33:14 2015 UTC,"Not at all! Also, it's available for free online! http://book.realworldhaskell.org/"
haskell,3djeaj,the_great_ganonderp,6,Thu Jul 16 21:13:17 2015 UTC,"It's available for free online. I found it to be a difficult read, and sufficiently outdated that trying to figure out why code wasn't working was getting in the way of actually learning."
haskell,3djeaj,Kaidelong,3,Thu Jul 16 19:45:56 2015 UTC,I agree I wouldn't recommend it as a beginner resource either. Great to have it bookmarked though.
haskell,3di7cs,_skp,35,Thu Jul 16 13:59:49 2015 UTC,"This blog post didn't comment on the main use of Default. Specifically, I almost always see Default used in complex settings initialization cases, like this:  data Settings = Settings {   settingsFoo :: Foo,   settingsBar :: Bar,   settingsBaz :: Baz   }  instance Default Settings where ...  runFloopWith :: Settings -> Floop a -> IO a runFloopWith settings floop = ...  runFloop :: Floop a -> IO a runFloop = runFloopWith def   Then user code can use it like this:  main = runFloopWith def {     settingsBar = newBar   }   I'm not saying that the blog post is wrong or even that I disagree with it – I just think that in order to make this point, you have to address the most common use of Default. (Or, at least, I think that's its most common use.)  One answer to this is to just suck it up and write full variable names, e.g.  main = runFloopWith defaultFloopSettings {     settingsBar = newBar   }   And I actually think that is preferable, because then defaultFloopSettings is a documented identifier that's easy to inspect and find the source of via Hackage; in comparison, Hackage docs for instances tend to be a little bit less accessible in my experience. The loss of convenience is not very large – you just need to find the right identifier to replace def."
haskell,3di7cs,NiftyIon,20,Thu Jul 16 15:07:49 2015 UTC,"For those settings things I usually make my settings some kind of monoid where mzero is the default values. It's quite convenient to be able to append settings: for example, configFile <> commandLineOverrides is quite a useful idiom."
haskell,3di7cs,kamatsu,5,Thu Jul 16 15:19:45 2015 UTC,"Or define monoidal builder / Dual Endo, and apply it on default settings. Like in optparse-applicative for example."
haskell,3di7cs,phadej,2,Thu Jul 16 16:13:52 2015 UTC,"But then you have to write a fairly complex Monoid instance for the settings type, right?  Another approach is to exploit the fact that a product of monoids is also a monoid, and use types like this:  import Data.Monoid (Monoid(..), Last(..))  data Settings =     Settings { setting1 :: Last Int, setting2 :: [String], ... }  -- Is there a library that allows you to use Generic or TH to derive this? instance Monoid Settings where     mzero = Settings mzero mzero ...     a `mappend` b =         Settings (setting1 a <> setting1 b) (setting2 a <> setting2 b) ...    Now defaults work like this:  data FullSettings =     FullSettings { setting1 :: Int, setting2 :: [String], ... }  applyDefaults :: Settings -> FullSettings applyDefaults settings = ...     In the end, however, I think all these approaches are more or less equivalent.  For example, /u/phadej mentions Endo, but note that the following functions relates my use of Last to Endo:  -- | Law: -- -- > lastToEndo (a <> b) == lastToEndo a <> lastToEndo b lastToEndo :: Last a -> Endo a lastToEndo (Last (Just a)) = Endo (const a) lastToEndo (Last Nothing) = mempty   One difference here is that the way I'm doing it we decide what the defaults are at the end instead of the beginning, so we could apply different default values in many situations.  But of course we could also very easily just abstract over the default value inthe"
haskell,3di7cs,sacundim,3,Thu Jul 16 17:29:20 2015 UTC,"Sorry, I meant Dual (Endo Settings), exactly to reverse the order of function composition to something you'd like to have when appending settings transformations."
haskell,3di7cs,phadej,1 point,Thu Jul 16 18:47:06 2015 UTC,"Generic Monoids for product types whose elements are all instances of Monoid can be derived with the generic-deriving package, which is incidentally a great way to learn Generics. Unfortunately a tiny bit of boilerplate is required:  data T a = C a (Maybe a) deriving Generic  instance Monoid a => Monoid (T a) where   mempty  = memptydefault   mappend = mappenddefault   Note that the Haddocks are a potentially confusing, in that GMonoid is totally unrelated to memptydefault and mappenddefault."
haskell,3di7cs,conklech,11,Fri Jul 17 18:27:42 2015 UTC,"yeah, I prefer defaultFloopSettings over def"
haskell,3di7cs,Platz,9,Thu Jul 16 15:25:29 2015 UTC,"I prefer defaultFloopSettings over def from the Default type class, because the type class has no laws and it's also one less dependency and one less import."
haskell,3di7cs,Tekmo,3,Fri Jul 17 03:33:17 2015 UTC,"Blog post also seems to assume Default is used for defaulting function parameters, but I have no idea how it could be used for this."
haskell,3di7cs,aemxdp,1 point,Thu Jul 16 15:34:23 2015 UTC,"Just that you can type def instead of one of the arguments, probably."
haskell,3di7cs,_AndrewC_,6,Fri Jul 17 07:28:59 2015 UTC,"I also dislike the Default typeclass. Not enough to write a blog post about it though. I would way use a monomorphic approach: defManagerConfig, defPortSettings, etc."
haskell,3di7cs,andrewthad,7,Thu Jul 16 15:41:25 2015 UTC,"I'd imagined Default as being more like a default constructible type in C++, than a default argument to a function."
haskell,3di7cs,shift_reset,5,Thu Jul 16 15:56:25 2015 UTC,This reminds me - why can't we put these kinds of discussions where they belong - with the documentation for Default on hackage.org so users can get some useful context.
haskell,3di7cs,hastor,6,Thu Jul 16 23:06:07 2015 UTC,"What about for protocol buffers, thrift, etc, where there isn't an obvious monoidal instance for a struct but there is a semantically meaningful default value?"
haskell,3di7cs,the_abyss,2,Thu Jul 16 17:33:30 2015 UTC,"You mean an empty value? Well, empty is already very different than def. :)"
haskell,3di7cs,the_abyss,2,Thu Jul 16 20:17:18 2015 UTC,"No, a default value - see https://developers.google.com/protocol-buffers/docs/proto#optional  If you have a protobuf  message M {   optional int32 f = 1 [default = 5]; }   then are you suggesting you codegen   defaultM :: M   instead of    instance Default M where   def = M { f=5 }   ? I don't really understand why Default isn't appropriate here."
haskell,3di7cs,tsahyt,6,Fri Jul 17 11:43:11 2015 UTC,"I Monoid instance would be more appropriate, because you’re not only defining a default, you’re also defining value overriding – which is the binary semigroup operation."
haskell,3di7cs,mjmrotek,5,Fri Jul 17 11:59:49 2015 UTC,"The Default typeclass is evil. It’s shipped with default instances, like one for [a], which defaults to the empty list – []. It might be clear for you but why would I want to default to the empty list? Why not to [0]?   Because [] is the only value that all [a] can default to. [0] is not of type [a], but [0] :: Num t => [t]. Just like Nothing :: Maybe a is the only possible default values that works for all as."
haskell,3di7cs,rpglover64,5,Fri Jul 17 08:40:49 2015 UTC,"Yeah, but this reasoning breaks for datatypes with fields of concrete types."
haskell,3di7cs,Tekmo,1 point,Fri Jul 17 08:47:49 2015 UTC,"You’ve forgotten a point. If you have Default [a], how can I have my def = [0] with (Num a) => a? I cannot. So, it’s insane stating that all lists should default to []. It depends."
haskell,3di7cs,rpglover64,3,Fri Jul 17 08:50:42 2015 UTC,It sounds to me like you're presenting the same argument as the parent post and coming to the opposite conclusion.
haskell,3di7cs,Tekmo,1 point,Fri Jul 17 12:30:19 2015 UTC,"Yes, but in these cases where there is an obvious default value, there's also an obvious combining operation, in which case the Alternative or Monoid type class is more appropriate with empty or mempty as the default value.  For the two examples you gave the Alternative type class suffices:  class Alternative [] where     empty = []      (<|>) = (++)  class Alternative Maybe where     empty = Nothing      Nothing <|> x = x     x       <|> _ = x"
haskell,3di7cs,chrisdoner,5,Fri Jul 17 19:09:18 2015 UTC,"As /u/NiftyIon said, the common use of default is for a library to provide it for a custom type, usually a settings record of some sort, and for the user to override some (but usually not all) fields to tweak the configuration. One example of using this to great effect is the diagrams library.  Now, it's true that Default is a type class with no laws. This means that, as the user of the def method, your only guarantee about the value is that it is of the correct type (and it's reasonable to assume that it doesn't contain bottoms). This means that you should only use def when you want someone else to pick the value you receive without having to fully understand it; i.e. you want someone else to pick a sensible default for their library.  Using a Monoid doesn't work for many configurations because it requires every optional field to be a Maybe type (or similar) and for functions using the configurations to have the default built in (I'm reminded of the Python convention of setting None as the default, but that's to work around its particular mutability semantics).  The builder pattern (or the related pattern of relying on the Endo monoid) require the library writer to provide functions to modify the configuration and doesn't seem to me to provide any advantage over just using a record without a Default instance.  In many libraries, I could reasonably see using a plain record like that, but in bigger libraries with many configuration types, it begins to feel redundant, more like a design pattern than an abstraction: e.g.  doThingNumberOneWith thingNumberOneDefaults{ fizz = 1, buzz = ""hello"" } ""more"" ""args"" ""here"" doThingNumberTwoWith thingNumberTwoDefaults{ foo = ""something"", bar = Nothing } ""yet"" ""more"" ""args""   as opposed to  doThingNumberOneWith def{ fizz = 1, buzz = ""hello"" } ""more"" ""args"" ""here"" doThingNumberTwoWith def{ foo = ""something"", bar = Nothing } ""yet"" ""more"" ""args""   I guess the recommendations I would give:   End users: Default is a way for someone (usually not you) to choose an arbitrary value; don't use it except when the library recommends it. Library authors: consider having a default arguments record that isn't an instance of Default, especially if you only have one configuration type."
haskell,3di7cs,reaganveg,4,Fri Jul 17 12:53:21 2015 UTC,I wrote a post on defaults which expands on the issues with the Default type class.  The #1 issue is that you can't really sensibly define what it means for a value to be a default value (i.e. mempty) in the absence of some combining operations (i.e. mappend).  That is why people recommend either using the Monoid class (if possible) or to just use a named non-type-classed value (i.e. defaultConfig).
haskell,3di7cs,mcapodici,5,Fri Jul 17 03:35:57 2015 UTC,The problem with monoids is most configs in practice end up being difficult to define as monoids and I often see ones that don't satisfy the laws. It's cleaner to just have the defaultConfig value.
haskell,3di7cs,gelisam,3,Fri Jul 17 10:18:39 2015 UTC,"Yep. That’s also my point of view. :) That’s especially true with my new zero package, which adds zero – vs. mempty."
haskell,3di7cs,Die-Nacht,1 point,Fri Jul 17 08:51:12 2015 UTC,The combining operation can just be record update syntax though.  I guess it could also be lens operations.
haskell,3di7cs,rpglover64,3,Sun Jul 19 03:20:50 2015 UTC,"Thanks for the point of view. It will make me think hard before I reach for defaults.   Sometimes I see OO code that relies on numbers being defaulted to 0, booleans being defaulted to False etc. Often as a placeholder value in lieu of being able to null a value type. e.g. (if x==0 { ... oh it is still the default, lets treat that as a special case as though nothing happened). I try to avoid that myself in OO programming but I do see it sometimes.  I saw that default package and thought it may be useful for 'something' in the future but couldn't quite think of what. I will be cautious when considering it :-)"
haskell,3di7cs,tejon,2,Thu Jul 16 22:24:19 2015 UTC,"Well, despite what people say, I’m still waiting for a good use of that package. I think there’s none. It’s way more rigorous and practical to reason about Monoid or Zero instead of Default. The empty case – Data.Vector.empty, Data.Map.empty – might be the exception, but in that case, def is not a good name, and we’re talking about something very different. :)"
haskell,3di7cs,mjmrotek,1 point,Thu Jul 16 22:59:56 2015 UTC,"It’s way more rigorous and practical to reason about Monoid or Zero instead of Default. The empty case – Data.Vector.empty, Data.Map.empty – might be the exception   Why? Both have a Monoid instance whose mempty is the empty value.  mempty :: Vector a -- http://hackage.haskell.org/package/vector-0.11.0.0/docs/src/Data-Vector.html#instance%20Monoid%20(Vector%20a) mempty :: Ord k => Map k a -- http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html#instance%20Monoid%20(Map%20k%20v)"
haskell,3di7cs,mbruder,1 point,Fri Jul 17 19:19:01 2015 UTC,Then use those. ;)
haskell,3di7cs,mcandre,3,Sat Jul 18 23:12:10 2015 UTC,"Never heard of this class, and I don't see why any one would want it."
haskell,3di7cs,jeremyjh,6,Fri Jul 17 01:44:39 2015 UTC,"diagrams uses it to fake optional keyword arguments, to good effect."
haskell,3dh9ou,cocreature,27,Thu Jul 16 06:58:13 2015 UTC,"Something I think that's really lacking with GHCi is the ability to reload single top-level definitions, rather than entire modules. Frequently, when I try and work on projects, I end up having some test data in scope - the contents of a file, or a database handle. I make changes to my source code, reload, and all that lovely state is gone. It can feel like I spend more time hitting Up+Enter than I spend time making progress!  In Lisps, we have the ability to evaluate single defuns, which in Haskell would be like sending a single top-level definition to the REPL. That should retain state, and might give a better experience."
haskell,3dh9ou,ocharles,18,Thu Jul 16 09:22:02 2015 UTC,"Could I entice you to give IHaskell with its notebook interface a try?   A common workflow is to have a bunch of modules and then have what you're currently working on in the notebook. Iterate on your current task, then stick it in a module. Since everything is in cells, you can re-evaluate one cell to get back all the state you need – or if you aren't reloading source files, you never even lose that state.  If you've tried it and had issues or find that it's not quite what you're looking for, let me know :) My eventual goal is for IHaskell to provide as close to this sort of experience as we can get in Haskell with GHC, and I think we're fairly close, although there may still be some rough bits."
haskell,3dh9ou,NiftyIon,2,Thu Jul 16 14:50:43 2015 UTC,You forgot try.jupyter.org :)
haskell,3dh9ou,sumitsahrawat,1 point,Thu Jul 16 19:19:51 2015 UTC,"two things   the project says IHaskell is    a kernel for IPython   that means it depends on IPython to run, no? I'd hope that the official ghci would be pure Haskell.   it looks great :) I need to give this a try. I've used IPython for Python and forgot what the standard interpreter even was. do you talk about how you picked this ""architecture"" somewhere? (rather than say an Emacs mode).   thanks!"
haskell,3dh9ou,sambocyn,8,Fri Jul 17 00:21:49 2015 UTC,"I believe haskell-mode supports that to some degree, however, if you update a function definition, then other functions that already bound against the old definition won't be able to see the new definition, and keep calling the old one (unless they get redefined as well)"
haskell,3dh9ou,hvr_,2,Thu Jul 16 09:38:35 2015 UTC,"Indeed, that's the hard part."
haskell,3dh9ou,chrisdoner,1 point,Thu Jul 16 11:16:12 2015 UTC,"keep calling the old one (unless they get redefined as well)   Yeah, but is is a simple matter of programming hunting those stale uses down (including the inlined bits and traces) and continue recompiling."
haskell,3dh9ou,heisenbug,2,Thu Jul 16 10:57:17 2015 UTC,That's not a simple matter IME. Ideally you would have some find-uses editor support that could automatically update definitions containing use-sites.
haskell,3dh9ou,chrisdoner,3,Thu Jul 16 11:28:56 2015 UTC,"http://www.catb.org/jargon/html/S/SMOP.html    A piece of code, not yet written, whose anticipated length is significantly greater than its complexity. Used to refer to a program that could obviously be written, but is not worth the trouble. Also used ironically to imply that a difficult problem can be easily solved because a program can be written to do it; the irony is that it is very clear that writing such a program will be a great deal of work. “It's easy to enhance a FORTRAN compiler to compile COBOL as well; it's just a SMOP.” Often used ironically by the intended victim when a suggestion for a program is made which seems easy to the suggester, but is obviously (to the victim) a lot of work. Compare minor detail."
haskell,3dh9ou,taejo,5,Thu Jul 16 21:12:55 2015 UTC,I like to think of a doctest as a REPL session stored in the code. It would be fantastic to be able to open a REPL session from a doctest. This way you can preserve all the setup you have.  UPDATE: submitted a new feature for doctest.
haskell,3dh9ou,mallai,5,Thu Jul 16 12:50:15 2015 UTC,"HBC by Lennart used to do this I think (paging /u/augustss for confirmation), so fundamentally there's nothing truly stopping us here I think, other than the usual technical nonsense."
haskell,3dh9ou,aseipp,10,Thu Jul 16 17:59:15 2015 UTC,"Hbc did this, and our Mu interactive top level also keeps the state after reloading (it also doesn't require you to reload, it just does it). Or at least as much of the state as is type correct.  It's easy to implement."
haskell,3dh9ou,augustss,1 point,Thu Jul 16 22:08:50 2015 UTC,"doesn't require you to reload, it just does it   when?"
haskell,3dh9ou,tailbalance,2,Fri Jul 17 11:20:04 2015 UTC,Every time you evaluate an expression or enter a definition.  It takes no perceptible time (since it only recompiles if anything has changed).
haskell,3dh9ou,augustss,6,Fri Jul 17 16:29:36 2015 UTC,foreign-store can help a little with that.
haskell,3dh9ou,Faucelme,5,Thu Jul 16 10:30:18 2015 UTC,"Yes, the hack for that is like this:  $ stack ghci λ> import Foreign.Store λ> :!echo 'x = 123' > X.hs λ> :l X [1 of 1] Compiling Main             ( X.hs, X.o ) Ok, modules loaded: Main. λ> chars <- readFile ""X.hs"" λ> chars ""x = 123\n"" λ> newStore chars Store 0 λ> :!echo 'x = 456' > X.hs λ> :r [1 of 1] Compiling Main             ( X.hs, X.o ) Ok, modules loaded: Main. λ> x 456 λ> chars <- readStore (Store 0) :: IO String λ> chars ""x = 123\n""   As opposed to updating function definitions in place, you could alternatively implement ""pinning"" which would pin a structure generated from an IO action and keep it around inbetween loads like this. With IDE support this could be transparent. Although it gets funky when types change. Segfaults are possible."
haskell,3dh9ou,chrisdoner,2,Thu Jul 16 11:25:52 2015 UTC,λ> chars 123   That's spooky - or a typo.
haskell,3dh9ou,yitz,1 point,Thu Jul 16 13:19:18 2015 UTC,Woops. I forgot to evaluate chars in my example so I added it manually. Fixed.
haskell,3dh9ou,chrisdoner,3,Thu Jul 16 13:25:12 2015 UTC,"I like to keep a module full of test resources handy for this situation. It's one more module to load, but then every resource I play around with gets a name. Then when I terminate my session and come back the next day I still have access to that resource."
haskell,3dh9ou,hans2504,2,Thu Jul 16 19:50:21 2015 UTC,"That, and an incremental compilation would be a dream!"
haskell,3dh9ou,tailbalance,10,Thu Jul 16 09:45:45 2015 UTC,"I have to admit, despite having worked in Python and several Lisps, I don't get what's so great about developing with a REPL.   ""Test work-in-progress implementations in the REPL"" seems to be the whole idea, I think? But rather than writing ad hoc, one-off tests in a REPL, why not put them in a file, using your testing framework, where you can easily edit them as you develop your code?"
haskell,3dh9ou,sasquatch007,16,Thu Jul 16 11:30:49 2015 UTC,"The two aren't mutually exclusive. I regularly write a test in the REPL to confirm a function does what I want and then copy that into my test suite. I also run the test suite (or parts of it) in the REPL, too. It's REPLs all the way down. :-)  The part you don't get is probably why a REPL is more productive than writing things in a file and then running the file. The UNIX shell is a REPL. If you use that, consider why you do instead of writing the actions you want to perform in a file in your text editor and then running that file. It's an unnecessary level of indirection; human beings like to be direct as possible, I don't think that needs explaining."
haskell,3dh9ou,chrisdoner,10,Thu Jul 16 11:58:45 2015 UTC,"It's being able to instantly see what happens to your compositions of functions. What does sqrt (sum (map (\c -> read [c]) ""1234"")) really evaluate to? What is the type of sqrt . sum? Is it something useful to me? It would be silly to write a whole program, compile it and execute it just to figure that out.  Of course, you could also just have REPL integration in your editor so you write those expressions in your editor and press a key to send them to the REPL and get a result back, but that's also using a REPL, just indirectly.  That said, I find a REPL to be much more useful in Haskell than in Python and various Lisp-inspired languages because of the referential transparency and controlled side effects. There's simply a larger number of functions that are feasible to work with within the REPL."
haskell,3dh9ou,kqr,4,Thu Jul 16 12:13:25 2015 UTC,"Yep, I prefer writing actual unit tests to test the feature. But in actually exploring the code that will make the unit test pass, I find the repl to be super useful. It allows you to quickly see what functions you have available and their types. Maybe if there were better ide support this would not be a problem."
haskell,3dh9ou,Crandom,4,Thu Jul 16 11:55:45 2015 UTC,"repl allows you to ""WRITE"" code faster. comparing this to unit test is irrelevant. here is why: let us assume you write a function that supposed to match some pattern through regular expression and it does not work. your unit test will catch it. you fix and run unit test again. but it does not work again. and you fix it again and run it again and wait again. and so on... in repl loop you do not exit you interpreter. you just source and run your code again and again until  it work. After that you test it using your testing framework...  More important example - let us assume your app is working this way:  some slow taks->data in memory->new code->other tasks...  in this case - testing will be at as slow as your slow task. in repl loop you can do your slow task in interpreter -> and write/check your code again and again until it work..."
haskell,3dh9ou,marglexx,3,Thu Jul 16 12:53:38 2015 UTC,"I think you raise a good point, there should be an easy bridge from your REPL to your test file."
haskell,3dh9ou,joelthelion,3,Thu Jul 16 11:41:10 2015 UTC,Is there not? I run hspec on my tests in the repl when I'm developing them.
haskell,3dh9ou,dukerutledge,2,Thu Jul 16 16:01:29 2015 UTC,"It's great in video game development, for example. While the game is running you can change your 'update' function a bit and see the new logic."
haskell,3dh9ou,nikki93,3,Thu Jul 16 12:58:55 2015 UTC,"Only if you write some crazy live reloading code, in which case you get that whether you are using ghci or not.  Just using ghci doesn't get you that."
haskell,3dh9ou,I4dcQsEpLzTHvD1qhlDE,3,Thu Jul 16 13:20:54 2015 UTC,"Yeah I meant more in the Pythons and Lisps as sasquatch007 was saying above. In Lisps (I've only done CL, Clojure) it basically works out of the box.  It'd be sweet to have something of the sort in haskell but it could get messy if you change types (add/remove a record field for example). CLOS handles it pretty well."
haskell,3dh9ou,nikki93,9,Thu Jul 16 13:35:13 2015 UTC,"Many Haskellers come from C++ and “stop program, edit file, re-run compiler, re-run whole program” cycles and don’t have much awareness or interest in it. If you are such a person, the above probably won’t come naturally, but try it out.   Actually, after learning Haskell and embracing the REPL development style, I started to dread the ""C++"" style of development. The pace at which I do my iteration feels much slower."
haskell,3dh9ou,jrk-,3,Thu Jul 16 09:00:14 2015 UTC,"Many Haskellers come from C++   While it's important not to miss an opportunity to bag on C++, keep in mind C++ does offer an advanced interactive experience:  Gdb. Can your REPL trap system calls? Single-step? Peek and poke registers? Disassemble machine code? Jump between stack frames? Reanimate a crashed program?  Cling. Here is almost your hot-code-reloading, interactive C++ experience. If only she could escape pre-alpha after 5 years.  Don't get me wrong I love GHCI and racket."
haskell,3dh9ou,rdfox,9,Thu Jul 16 12:03:36 2015 UTC,"At least in my limited experience, a lot of C/C++ programmers don't actually use gdb the way we mean when we talk about REPLs. And to be fair, it doesn't have the most friendly interface for that either."
haskell,3dh9ou,kqr,2,Thu Jul 16 12:18:59 2015 UTC,I use C and I truly miss the power of gdb (and perf record -g) in my Haskell experience :(
haskell,3dh9ou,Peaker,-4,Thu Jul 16 20:41:54 2015 UTC,No True Scotsman
haskell,3dh9ou,rdfox,9,Thu Jul 16 13:17:29 2015 UTC,"Not applicable in this case. Chris Done wasn't saying that C++ people don't have something that works like a REPL, all he was saying was that they're not using it that way, which is indeed true in my experience.  If you're going to claim a fallacy, it should rather be something about anecdotal evidence. ;)"
haskell,3dh9ou,kqr,3,Thu Jul 16 13:24:16 2015 UTC,It's not clear to me how to use setup/teardown helpers with ghci. A link to an example project where this workflow is used would make it much more clear.
haskell,3dh9ou,vimes656,3,Thu Jul 16 08:20:16 2015 UTC,"it is not directly linked in the post but I found this live reloading demo project in this post, which was linked in the post above."
haskell,3dh9ou,MaxDaten,3,Thu Jul 16 10:08:49 2015 UTC,"they often launch threads without any clean-up procedure; in this way the REPL makes you think about cleaner architecture.   Then please tell me how I can reliably detect that the GHCi repl has returned control to the user and I need to stop the background threads. Especially if I run :main, where it's not uncommon to just let the OS clean up all resources."
haskell,3dh9ou,rstd,5,Thu Jul 16 12:22:02 2015 UTC,"You receive an asynchronous exception. When you receive that exception, you can kill the threads that you launched via killThread, which sends the same exception type to them.   λ> catch getLine (\(SomeException e) -> print (""Exception"",typeOf e,e) >> throw e) (""Exception"",SomeAsyncException,user interrupt) Interrupted. λ>"
haskell,3dh9ou,chrisdoner,3,Thu Jul 16 12:31:38 2015 UTC,"Haskell’s lucky to have a small REPL culture, but you have to work with a Lisp or Smalltalk to really know what’s possible when you fully “buy in”.   I agree with you that Haskell is lucky for this, and this amazed me about Haskell since for the very beginning ... very few compiled, strongly typed languages are smooth like this on the interpreter, try Java.  That said, give some credit to Python as well! It has such a strong culture of using the interpreter, that they invented doctests, and doctests are some of the most user friendly things you could find in any programming language, ever, and they lead to writing great code"
haskell,3dh9ou,liberalogica,2,Thu Jul 16 23:01:55 2015 UTC,"Lets say i'm not interested in live reloads with preserving state, i just want to reload running yesod web server as quickly as possible in ghci.  What would be an example .ghci file and or haskell-mode configuration tweaks to achieve this in haskell-mode?"
haskell,3dh9ou,vagif,3,Thu Jul 16 14:37:11 2015 UTC,"As for yesod, I only know of a few options (which might not be exactly what you're looking for):  The DevelMain functionality is already built into emacs haskell-mode via haskell-process-reload-devel-main and has very fast reload times:   https://github.com/yesodweb/yesod-scaffold/blob/postgres/app/DevelMain.hs#L3-L29   There are some convenient GHCi setup/tear-down functions in the scaffold site you might be able to reuse but they don't leave the server running necessarily; they just make it very simple to test handlers:   https://github.com/yesodweb/yesod-scaffold/blob/postgres/Application.hs#L169-L174  You might be interested in reserve (it's live reloading but lean, though):  https://github.com/sol/reserve. I have primarily used it with wai/scotty."
haskell,3dh9ou,creichert,2,Thu Jul 16 21:40:57 2015 UTC,This may be an answer to your question:  https://www.reddit.com/r/haskell/comments/3d9i9q/why_is_yesod_so_slow/ct3495s
haskell,3dh9ou,Hamilcar98,2,Thu Jul 16 16:11:31 2015 UTC,"How can I make something like this http://chrisdone.com/posts/ghci-reload but with ATOM, It'll be good a tutorial for this on the yesod site or it be default in the scaffolding"
haskell,3dh9ou,mrkaspa,2,Thu Jul 16 18:08:51 2015 UTC,What kind of interface does ATOM have to GHCi? I use emacs and the DevelMain combination for web apps. You basically need to be able to send certain commands directly. If you're will to do some research here are the links:  https://github.com/yesodweb/yesod-scaffold/blob/postgres/app/DevelMain.hs#L10  https://github.com/yesodweb/yesod-scaffold/blob/postgres/Application.hs#L151-L174  it might even be worth it to check out emacs haskell-mode for some ideas on how to implement it.
haskell,3di17w,rorriMnmaD,47,Thu Jul 16 13:04:14 2015 UTC,I read it as basically plural. The list matches an x and a bunch more x's.
haskell,3di17w,dougmcclean,14,Thu Jul 16 13:08:17 2015 UTC,"That's also exactly how to pronounce it: One x, multiple xs (similar to ""axis"")."
haskell,3di17w,lrich,2,Thu Jul 16 14:24:55 2015 UTC,"ex (as in ""export"") - ez (as in ""fez"")"
haskell,3di17w,PM_ME_UR_MONADS,1 point,Fri Jul 17 16:03:23 2015 UTC,"I say it xs as in ""all my ex'es live in Texas""."
haskell,3di17w,nicheComicsProject,19,Sun Jul 19 16:32:03 2015 UTC,"It's just the plural version of x: if you had some foo, you'd call them plurally foos."
haskell,3di17w,lw9k,12,Thu Jul 16 13:08:33 2015 UTC,"It's the same as (apple:apples). The rest of the apples.  What continues to irk me is what to call the entire thing when using the ""as pattern"". For example xz@(x:xs).  Is there an accepted way to name the xz?"
haskell,3di17w,stasiana,8,Thu Jul 16 14:23:06 2015 UTC,Is there an accepted way to name the xz?   I usually go for xxs. In Agda I tend to use x∷xs but some find it confusing (and it would not be a valid identifier in Haskell anyway).
haskell,3di17w,gallais,2,Thu Jul 16 14:53:52 2015 UTC,I usually go for xxs. In Agda I tend to use x∷xs   I'll second both of these.
haskell,3di17w,Archaeanimus,1 point,Fri Jul 17 05:17:41 2015 UTC,But... you can already use just x:xs.
haskell,3di17w,SrPeixinho,1 point,Fri Jul 17 05:26:04 2015 UTC,"What, specifically, are you referring to?"
haskell,3di17w,Archaeanimus,2,Fri Jul 17 05:35:18 2015 UTC,Just pointing you can use x:xs as the name of the whole:   foo (x:xs) = 3 : x:xs   Which is obvious so I don't know why I posted
haskell,3di17w,SrPeixinho,3,Fri Jul 17 05:42:50 2015 UTC,"that's not the name of the whole tho. that's a pattern match on the left, with a reconstruction of the cons on the right. in-memory, it's building a whole new cons node on the right. the point of using @ is so that you can write this:  foo xxs@(x:xs) = 3 : xxs   and it will reuse the exist cons node in memory rather than creating a new one."
haskell,3di17w,psygnisfive,1 point,Fri Jul 17 09:09:52 2015 UTC,I thought GHC could optimize these
haskell,3di17w,evohunz,1 point,Fri Jul 17 17:32:46 2015 UTC,maybe! but that doesn't make x:xs the name of the whole
haskell,3di17w,psygnisfive,1 point,Sat Jul 18 00:33:30 2015 UTC,"Will the compiler deconstruct the list and re-cons the x and xs, or be smart here ?"
haskell,3di17w,mosha48,1 point,Fri Jul 17 06:27:11 2015 UTC,Not sure... GHC is particularly bad at CSE so I'd guess it would reconstruct it.e
haskell,3di17w,SrPeixinho,1 point,Fri Jul 17 06:57:37 2015 UTC,"I really want to say no, because you've asked it to construct a new list, but there's a chance ghc is the sufficiently smart compiler that with -O2 it spots the common subexpression."
haskell,3di17w,_AndrewC_,1 point,Fri Jul 17 08:08:48 2015 UTC,Spotting it is not so much of a problem... But deciding if it is a good idea to eliminate it is much more so !! There's plenty of case where you don't want CSE and GHC often has to assume you didn't do it yourself intentionally because doing otherwise might wreck the performance in a common case in your application !
haskell,3di17w,Jedai,1 point,Sat Jul 18 10:17:55 2015 UTC,Neat. I think I'll start doing this.
haskell,3di17w,duplode,1 point,Thu Jul 16 16:18:57 2015 UTC,"Yeah, I like this."
haskell,3di17w,stasiana,7,Thu Jul 16 16:45:22 2015 UTC,I'd probably go for something more meaningful if you need to work with the whole list. list@(x:xs). there's like a 90% chance I'll misread/mistype xz for xs and be wondering why my code isn't working.
haskell,3di17w,ephrion,4,Thu Jul 16 14:49:47 2015 UTC,I usually end up with something like xs@(x:xs')
haskell,3di17w,etrepum,3,Thu Jul 16 18:35:28 2015 UTC,Why not ys@(x:xs)?
haskell,3di17w,lrich,3,Thu Jul 16 14:24:03 2015 UTC,"Presumably ""x"" names the thing. I'd rather not have to think of two different names for the same thing,"
haskell,3di17w,stasiana,1 point,Thu Jul 16 14:36:03 2015 UTC,"Why not ys@(x:xs)?   The normal use case for ys is in code like compare (x:xs) (y:ys) = ... and I would rather not confuse the two.  I think the suggestion of xxs above is fairly elegant, with the final result looking like:  setmerge [] ys = ys setmerge xs [] = xs setmerge xxs@(x:xs) yys@(y:ys) = case compare x y of   LT -> x : setmerge xs yys   GT -> y : setmerge xxs ys   EQ -> x : setmerge xs ys"
haskell,3di17w,kazagistar,1 point,Thu Jul 16 23:58:39 2015 UTC,"because ys would be of type [b], but here it's meant to be [a], obviously."
haskell,3di17w,badzergling,2,Thu Jul 16 22:36:05 2015 UTC,I'll often write xs@(x:ys) for this.
haskell,3di17w,lpsmith,1 point,Thu Jul 16 15:24:31 2015 UTC,I often naming it by just repeating plural form twice: xss.
haskell,3di17w,mr_konn,3,Thu Jul 16 14:27:53 2015 UTC,I use that for ((x:xs):xss).
haskell,3di17w,anvsdt,1 point,Thu Jul 16 17:02:46 2015 UTC,"FYI, you can drop a pair of parentheses: (x:xs:xss)"
haskell,3di17w,emarshall85,2,Thu Jul 16 17:16:06 2015 UTC,Probably not - that is likely a list of lists.
haskell,3di17w,duplode,1 point,Thu Jul 16 17:27:01 2015 UTC,"Ah, you're right. My mistake."
haskell,3di17w,emarshall85,2,Thu Jul 16 18:04:40 2015 UTC,"x :: a, xs :: [a], xss :: [[a]]."
haskell,3di17w,anvsdt,1 point,Thu Jul 16 17:39:30 2015 UTC,xxs
haskell,3di17w,kamatsu,1 point,Thu Jul 16 15:16:36 2015 UTC,LambdaCase sometimes is a nice way of not having to name the xz.
haskell,3di17w,duplode,1 point,Thu Jul 16 16:16:50 2015 UTC,"When I need to split a list into more pieces than just x and xs, I like to use numbers to indicate the indices into the list. Since there is no largest number, I like to use Z for the last index. In that context, lists are indexed by a pair of indices. So:  xs1Z@(x1:x2:xs3Z)"
haskell,3di17w,gelisam,1 point,Thu Jul 16 18:52:24 2015 UTC,xs@(x:rest)
haskell,3di17w,nicheComicsProject,1 point,Thu Jul 16 22:05:33 2015 UTC,"I name variables a, b, etc. and elements x, y, etc.  This leads to this  a@(x:xs)"
haskell,3di17w,basdirks,1 point,Sun Jul 19 16:35:19 2015 UTC,I use x@(y:ys).
haskell,3di17w,pchiusano,1 point,Tue Jul 21 11:44:43 2015 UTC,"I like hd:tl. Works great no matter what your type parameters are called! If you've got two lists, hd1:tl1 and hd2:tl2."
haskell,3di17w,tejon,1 point,Thu Jul 16 18:58:37 2015 UTC,"Your answer is my favorite here as a beginner. Also I don't like specifically ""hd"" and ""tl"" as much as ""head"" and ""tail"" but I guess those aren't options"
haskell,3di17w,conklech,1 point,Thu Jul 16 19:37:11 2015 UTC,"Well, you could hide head and tail in your prelude import. There are arguments for this already, since they're icky. :)"
haskell,3di17w,thraya,1 point,Thu Jul 16 20:19:46 2015 UTC,"The terse style common in Haskell may start to make more sense to you as time goes on. (Or maybe not; people are different.) As I see it, when x is polymorphic, calling it x rather than giving it a real ""name"" like head helps to emphasize or clarify that there's no meaning to x; it's just some thing, and xs is the rest of the things.  This style makes the most sense when the scope of x or whatever is very short, e.g. in the implementations of the function in Data.List. There, the only function of the variable names is to link the left-hand and right-hand sides of the equation, and you can see everything at once. In longer or more complicated definitions, where a variable is used several lines away from its definition, descriptive names serve a more important role reducing cognitive overhead. Likewise when the variable really has some extrinsic meaning, like firstName or what have you."
haskell,3di17w,vitalijzad,1 point,Fri Jul 17 18:22:38 2015 UTC,"I think it was an OCaml text that taught me to use xx and yy instead of xs and ys, and the habit persists to this day:  interleave (x:xx) yy = x : interleave yy xx somefunction xxx@(x:xx) = ...   I like the purity of the repeated glyphs."
haskell,3di17w,gallais,1 point,Fri Jul 17 18:31:35 2015 UTC,"That is confusing. I would much prefer a syntax like ""element:list"""
haskell,3di17w,vitalijzad,6,Thu Jul 16 14:20:08 2015 UTC,What if you have a list of lists? as:ass is quite a lot shorter than list:listlist.  What if you have two lists? a:as and b:bs is quite a lot shorter  than element1:list1 and element2:list2.
haskell,3di17w,creichert,1 point,Thu Jul 16 14:51:22 2015 UTC,Shorter does not always mean better. Longer symbol names could be easier to read.
haskell,3di17w,vitalijzad,13,Thu Jul 16 15:05:21 2015 UTC,Which do you find more readable?  map _ []     = [] map f (x:xs) = f x : map f xs   or  map _ []     = []  map f (element:elements) = f element : map f elements
haskell,3di17w,mightybyte,2,Thu Jul 16 15:30:16 2015 UTC,"Maybe I am a bit biased, coming from Java, where you can have a ConnectionFactoryAwareAspectInstanceFactoryBeanInfoAssembler. :-)  But I still find more clear to read the version with element and elements."
haskell,3di17w,sacundim,8,Thu Jul 16 15:35:03 2015 UTC,"In Haskell often scanability and visual pattern matching is more important than readability.  I discussed this in a blog post awhile back.  In a function like the one above the scope of the name is small and it's easy to see all the necessary context at a glance, so I think (x:xs) is better in this situation.   The word ""element"" tells you no more than ""x"" and all the other important information comes from the context."
haskell,3di17w,mcapodici,4,Thu Jul 16 19:03:10 2015 UTC,"Ah, but that's a type.  The variables of that type would have much shorter names (like assembler), because the type conveys much of its meaning.  This sort of thing often applies in Haskell; the types and the pattern matches tell us that x is the element at the head of the list and xs is the tail of the list."
haskell,3di17w,Taladar,3,Thu Jul 16 16:42:46 2015 UTC,"The thing about haskell is the tight scope of variables. So you can call something x and know that all references to x will probably be withing view in your editor at the same time.  In Java, C# etc. where you have code 'more spread out' calling something x (unless it is a coordinate) is probably bad for future maintainers.  Also in Haskell the x:xs thing is idiomatic, you will see it everywhere and so it will not surprise other coders. They will be used to scanning it when reading your code.  Of course record naming in Haskell is different and needs super-verbose names to get around lack of namespacing plus needing to come up with a descriptive name anyway."
haskell,3di17w,vitalijzad,2,Thu Jul 16 21:53:40 2015 UTC,"The problem with that approach is that you often have very abstract functions in Haskell and x:xs is about as meaningful as element:list when you are familiar with the idiom. Often in abstract code you can not find a better description than a generic name like that.  That is a problem Java, with its almost completely lack of abstractions, does not really have when naming variables."
haskell,3di17w,want_to_want,1 point,Fri Jul 17 10:45:54 2015 UTC,"But I guess usually there are various level of abstraction in the code, if it is not a library. Some functions will be very abstract, while others could be concrete.  For example, when you have to do some IO you are very concrete: there is a file somewhere, etc."
haskell,3di17w,srhb,2,Fri Jul 17 10:58:22 2015 UTC,"Personally, I'd love something like this:  map(function, List.Empty) = List.Empty map(function, List.Node(value, tail)) = List.Node(function(value), map(function, tail))"
haskell,3di17w,want_to_want,3,Thu Jul 16 18:01:00 2015 UTC,"You can have this!  module List where  data List a = Empty | Node (a, List a)   Now you can import this module qualified and get  import qualified List   map'(function, List.Empty)             = List.Empty map'(function, List.Node(value, tail)) = List.Node(function(value), map'(function, tail))   foo = map'((+1), List.Node(1,List.Node(2,List.Empty)))   And now you've made your Haskell 9000 percent uglier, and your code no longer composes nicely! :-)"
haskell,3di17w,mjmrotek,1 point,Fri Jul 17 13:47:59 2015 UTC,Whee! Thank you :-)
haskell,3di17w,gallais,3,Fri Jul 17 14:09:22 2015 UTC,"It's just an argument name. I think it doesn't hurt for arguments and local variables to have short names, as their scope is small and there are types forming a safety net outside."
haskell,3di17w,dogodel,3,Thu Jul 16 15:24:56 2015 UTC,"Yes, I agree that's why despite having written ""better"" originally, I edited my message to ""shorter"" instead. But the idea is to have short variable names carrying a lot of information:   the degree of nesting (for lists it's going to be multiple s but for a functor, you may write fa or ffa, for a function aTob, etc.) the relationship in terms of types (an a can be pushed onto an as, an aTob can be fmapped on an fa, an as and a bs cannot be interleaved because a /= b, etc.)   It's a matter of a taste, I guess."
haskell,3di17w,vitalijzad,2,Thu Jul 16 15:33:07 2015 UTC,"I might be biased, but I'm going to argue that it's not ""just taste"", and there is a best choice for particular cases.  In languages like java, expressive names are preferred because they give additional information about the expected behavior of the arguments. In Haskell, it's not so much needed because the types strongly constrain the behavior already.  Particularly, in the case of parametric functions on containers, there's really nothing more to say about the arguments other than what's already provided by the types and the shape of the constructor. Using short names in this case makes the structural  where you can think of the names (x,xs, etc.) as shorthand for ""wires"" and the whole function as a compact notation for a (structurally determined) ""circuit"".  On the other hand, in particular cases where the ""real type"" of the data is not fully specified by it's type annotation, an expressive name can be useful.  Another issue that's not a matter of haskell vs java or whatever, is structural vs nominal for inductive vs coinductive types. Inductive types (data) are defined structurally and deconstructed by pattern matching. On the otherhand, coinductive types (codata, of which OO Objects are a special case) are defined by pattern matching and deconstructed by views, which can be thought of as labeled fields.  Since everything in haskell acts like both data and codata (with Bottom discriminating the true difference), the choice should be made based on if you intend it to be used as data or codata."
haskell,3di17w,gelisam,1 point,Thu Jul 16 16:14:22 2015 UTC,Where can I find a book or an article that explains Inductive and coinductive types?
haskell,3di17w,chibro2,2,Thu Jul 16 16:37:03 2015 UTC,Here's one I like: http://blog.sigfpe.com/2007/07/data-and-codata.html
haskell,3di17w,evohunz,4,Thu Jul 16 18:54:54 2015 UTC,"There's a culture of making code as succinct as possible in the Haskell community. In the beginning I thought x:xs and y:ys were confusing too, but overtime they became very natural and I actually carried the idiom to other languages."
haskell,3dhp00,ysangkok,6,Thu Jul 16 10:40:29 2015 UTC,"I've been interested in the series of blog posts that appeard on School of Haskell about this technology, but I'm afraid I can't make head of tail of it."
haskell,3dhp00,tomejaguar,3,Fri Jul 17 08:43:27 2015 UTC,I am the author and in some way I'm the first one that is trying to understand it. For haskellers this paragrap may be the best summary
haskell,3dhp00,agocorona,3,Fri Jul 17 10:16:06 2015 UTC,"I found the README.md a bit confusing to read.  The examples at the end are good, so I'd move those further up.  Then explain clearly what is wrong with async or other approaches.  I'd also like to understand how you deal with exceptions, as this is an important topic in async.  Also whether there is any semantics wrt deadlocks, as IVars are supposed to give deterministic behavior.  I understand that you are focusing on inversion of control, but to put your library into the design space it would be good to know how you deal with other aspects of the design space."
haskell,3dhp00,hastor,3,Fri Jul 17 08:11:10 2015 UTC,"hastor, thanks for the suggestions.  Unchecked exceptions kill the thread where the exception appears and all its child threads, unless freeThreads is used. In this case the threads do not die when the parent finishes.  Most of the real processing is done in IO computations, since in the Transient monad only the skeleton of the program is defined.  The transient primitives have IO computations as parameters, so how you deal with your blocking concurrency inside your IO actions is up to you.   For example, async, mentioned in another example here, will de-block your blocking IO.    async :: IO a -> TransientIO a   To  implement asynchronous keyboard IO, I have a single getLine that updates a TVar. Then many IO processes watch the TVar.  By lifting each blocking IO with async to the Transient monad, all IO computations execute in parallel when combined with (<|>) or (<*>) so the one that find what it is waiting for, executes the rest of the monadic sequence:   waitInput :: TransientIO ()  waitInput= do      r <- async (blockedExpecting ""hello"") <|> async (blockedExpecting ""world"")      liftIO $ putStrLn $  ""input entered: ""`++ r   blockedExpecting represent any IO computation that may use any kind of blocking interprocess communication. But it may be a long download or anything that block for a certain time.  async executes the IO expression a single time.  waitEvents execute it forever in a loop. Both are variants of parallel. They finish the current thread after forking a new thread, that executes the IO computation and then executes the  (closure>>= continuation)."
haskell,3dhp00,agocorona,2,Fri Jul 17 10:38:53 2015 UTC,"How does this improve over GHC's IO run-time? My understanding is that forkIO is pretty fast as-is, and uses select() and friends under the hood?"
haskell,3dhp00,tathougies,2,Thu Jul 16 22:57:40 2015 UTC,maybe /u/agocorona can answer...
haskell,3dhp00,agocorona,6,Thu Jul 16 23:04:08 2015 UTC,"it uses forkIO, no performance improvement, but makes the threading composable:  The problem with threading is that threads are threads and they tend to be like spaghetti and spaghetti code is the problem to overcome.  Threading is necessary for making the application responsive while performing IO since the IO primitives block the execution of a thread.  Ideally it would be very nice to program multithreaded programs like a single thread. Single threaded programs are easy to understand, are easy to debug etc. An alternative is using non blocking IO with callbacks in the style of Node.js. That is even worst.  But imagine that we have a magic combinator ""async"" that makes a synchronous IO call, like readFile asynchronous, so that in this code:  twoIO :: String -> String -> TransientIO () twoIO file url= do      r <- async (readFile file) <|>  async (dowloadURL url)      liftIO $ putStrLn ""something read: "" ++ show r   readFile does not block downloadURL neither vice versa, so that the second statement is executed when each one of the two IO operations finishes.  The transient monad has such an async. This monad manages implicitly the threading for the programmer.  It creates implicitly there threads:   the thread that execute the <|> in the first statement, launch the other two threads and finishes the thread that execute the first async and second statement when the first async finished and  the thread that execute the second async and the second statement when the second async finishes.   The second statement is executed two times, as expected.  So the programmer can create responsive multithreaded programs without explicitly programming threads.  The advantage is that it looks single threaded and it is composable.  in fact, it is possible to combine twoIO with itself:      fourIO  file file'  url url'= twoIO file url  <|> twoIO file' url'   So in general, using Transient, whole multithreaded programs can be composed, with monadic combinators (>>=) (<*>)  (<|>)  (<>)  etc."
haskell,3dhp00,Tekmo,7,Fri Jul 17 00:04:18 2015 UTC,You can simplify your presentation by explaining a couple of things:   What are the core type(s) of your library? What algebraic operations do those types obey?   If you have that then it's easier to fit this into a larger context.
haskell,3dhp00,agocorona,5,Fri Jul 17 03:39:08 2015 UTC,"Gabriel Thanks for your suggestion. I´m trying to polish the concept and the types. It works, but it is possible that the types are not the best possible. Transient is an state monad that store closures and continuations and this forces to use existentials and a kind of type erasure.  The thing closer to the description you recommed is in this paragrap.  It is based on the realization that the continuation is the second parameter in the bind operation. That simplify a lot the management of continuations.  Perhaps the zipper concept, mentioned in the paragraph is a good analogy"
haskell,3dhp00,Tekmo,3,Fri Jul 17 09:23:00 2015 UTC,The onUndo operation looks similar to the orElse operation of STM.  Is there a similarity between TransientIO and STM?
haskell,3dhp00,agocorona,3,Fri Jul 17 13:19:17 2015 UTC,"Not much, since onUndo add his second parameter to a list of computations that will be executed in reverse order when undois called.  Each onUndo can stop the execution of further onUndo and resume the execution forward from this point on. it is intended that a onUndo can either perform a compensation (to undo a transaction) or to fix some problem, so that the computation can restore execution forward from that point on.   A web navigation can use onUndo to check if the user has pressed the back button and has sent a form corresponding to a previous page. if a page does not match, it can trigger an undo, so the previous pages can verify the response. the one that match will restore the flow forward.  It is even possible to use the backtracking mechanism to close resources when the computation has finished  It is possible to create publish-subscribe variables: EVars (from Event vars). I have the module EVars, but currently does not work with the last changes.  it is something more close to STM.    Modifying an Evar with writeEVar trigger the execution of all the continuations that are executing  readEVar."
haskell,3dhp00,tejon,1 point,Fri Jul 17 13:57:19 2015 UTC,"The second statement is executed two times, as expected.   Well, there goes my intuition of <|>..."
haskell,3dhp00,agocorona,1 point,Fri Jul 17 19:21:23 2015 UTC,"Yep, it is a bit surprising, but think that the expression is ""overloaded"" with two threads executing two different things. In each thread  one side of the expression succeed and the other do not. Since there are two threads running, the second statement is executed two times with the two different results. Maybe this can be used for the simulation of quantum computing"
haskell,3dhp00,tejon,2,Fri Jul 17 20:41:08 2015 UTC,"Okay, I guessed it must be something like that... similar to the []-monad nondeterminism. Cool!"
haskell,3dhp00,agocorona,1 point,Fri Jul 17 21:13:42 2015 UTC,"Indeed. Using <|> and asyncis possible to do non-determinism in the style of the List monad, but in this case, each result is computed by a different thread:  choose  xs = foldl (<|>) empty $ map (async . return) xs  solveConstraints :: TransientIO (Int,Int) solveConstraint=  do       x <- choose  [1..10]       y <- choose  [1..10]       guard $ x  == 2 * y         return (x,y)  main= keep $ do       s <-  solveConstraint       liftIO $ print s   Will show the same result than the list monad, not in a list, but as the result of a different thread.  More information in this article"
haskell,3dhp00,tathougies,1 point,Sat Jul 18 08:08:51 2015 UTC,Ah now I understand what's going on here... Pretty cool! Thanks for the explanation!
haskell,3dhp00,agocorona,1 point,Sat Jul 18 23:18:27 2015 UTC,You are welcome ;)
haskell,3dhuug,vtan_,5,Thu Jul 16 11:58:58 2015 UTC,"Good job! I was able to make this work with ghc 7.10 by changing ""gloss >=1.8 < 1.9"" to ""gloss >=1.8"" in cabal and switching makeColor8 -> makeColorI, rawColor -> makeColor. I'm not an expert in AFRP yet, so cannot say anything conceptually interesting about code, sorry. But I'd like to notice performance characteristics: it's pretty nice and smooth except every N seconds there is a little lag. Typical GC thing. Would be interesting to know, have you tried anything to improve memory consumption, and/or do you any ideas what could be improved here."
haskell,3dhuug,aemxdp,2,Thu Jul 16 12:58:14 2015 UTC,"Yes, unfortunately you have makeColor8 with base 4.{6,7} and makeColorI with base 4.8. But it's nice to know that otherwise it can be built with GHC 7.10.  I haven't done any profiling or optimizing yet -- not even basic stuff like making record fields strict --, but I do plan to."
haskell,3dhuug,hans2504,4,Thu Jul 16 16:20:17 2015 UTC,"Great work! FYI, This installed and ran cleanly with stack:  $ git clone https://github.com/vtan/spanout.git $ stack init --solver $ stack install $ stack exec spanout   I've been meaning to write some graphical games in Haskell for a while. This looks like a good starting point template.  Edit yes, stack exec spanout is the correct command."
haskell,3dhuug,citicada,1 point,Thu Jul 16 20:59:36 2015 UTC,"That's convenient, I'll have to check out stack."
haskell,3dhuug,jaybee,1 point,Thu Jul 16 21:26:03 2015 UTC,"stack   Stack made it a pleasure.  On Mac OS X (usually a challenge for stuff like this), I just had to make sure that it was GHC 7.8.4 that was in my path.  Also, I think that last line should be:   stack exec spanout"
haskell,3dhcei,vittusormi,22,Thu Jul 16 07:34:03 2015 UTC,"In short, coming from CL to Haskell is shocking for a few reasons: the development environment (or lack of it), no live image update (Haskellers call it ""hotswapping"", pfft, muggles), lack of homoiconic macros (no syntactic abstraction) and symbolic quotation, abrasive and line-noisey heterogenous syntax, slow compilation (GHC's codegen is very slow). It was upsetting to not have these things that CL is better at, I almost turned back a number of times in dismay. The good news is the static type system, purity and cleaner standard functions make up for it, to the point I wouldn't want to develop any substantial application in CL any more.  Long version, answered a few months ago."
haskell,3dhcei,chrisdoner,1 point,Thu Jul 16 13:06:00 2015 UTC,"no live image update   1) well, no well-defined standard way, I agree. But people do it.  2) LISP has neither, when real life with threads comes.   homoiconic macros   Thank God SPJ! And we do have quasi-quotation in TH if absolutely needed.   (no syntactic abstraction)    Seriously????   abrasive and line-noisey   Depends of person I guess, many will take Haskell’s syntax over lisp  any time.   slow compilation   The only one I completely agree with."
haskell,3dhcei,tailbalance,1 point,Fri Jul 17 09:39:43 2015 UTC,"abrasive and line-noisey   Compared to C-style syntax, haskell is clean and uncluttered, but lisp has an extremely simple syntactic structure, and most lisp you read will just be words and round brackets. By comparison, haskell has a world of operators and layout rules to get used to.  Personally, I love it a great deal, and prefer whitespace layout to brackets of any kind, but if you're new from lisp you could well find the syntax both constraining and confusing."
haskell,3dhcei,_AndrewC_,19,Sun Jul 19 09:30:35 2015 UTC,"I went from Scheme to Haskell, not CL.   Right off the bat I want to know if Haskell has generic setters, structs, multiple return values and good macro system.   Basically no. Haskell's functions are all unary, but you can return a tuple. Lenses feel like the Haskell answer to generic setters. Our macro system (template haskell) sucks quite a bit, mostly just due to lack of homoiconicity, but we don't need it for as many things as you might think, seeing as we have lazy evaluation to help us define our own control operators. Monads are also helpful here as the distinction between evaluating a monadic value and executing its effects allows you to introduce the same sort of phase distinction you want with CL macros. We also have some lightweight syntax and overloading features for DSLs that make life a bit easier in that respect."
haskell,3dhcei,kamatsu,6,Thu Jul 16 07:47:49 2015 UTC,"Haskell's functions are all unary, but you can return a tuple.   What's the difference? I don't think I've ever used a language with 'real' multiple return values."
haskell,3dhcei,theonlycosmonaut,4,Thu Jul 16 08:00:37 2015 UTC,You can catch and process multireturns in CL with value bind. Implicitly only first return value matters and it doesn't die if nothing is done to arbirtary amount of following values. For example hashes return value first and t/nil second to indicate it was/wasn't found. Then you can explicitly bind to that boolean and do something like it. Handy in some cases.
haskell,3dhcei,Peaker,3,Thu Jul 16 08:33:35 2015 UTC,Sounds like hashes return value AND error instead of value OR error?
haskell,3dhcei,Taladar,2,Thu Jul 16 08:46:01 2015 UTC,"Uhm... it returns two atomic types, value that can be anything the hash was AND boolean telling if it was there or not. It's not error."
haskell,3dhcei,Peaker,5,Thu Jul 16 08:59:40 2015 UTC,"Haskell tends to solve this kind of use case by ensuring via the type system that you can not access the value unless there really is a value. Something like the lookup function on a hash would have a type  lookup :: Hash key value -> key -> Maybe value   with  data Maybe a = Nothing | Just a   This way you only get a Nothing which does not contain a value at all if there wasn't one in the hash for the given key.  You can use pattern matching to extract the value or even just make the boolean distinction between Just or Nothing if you don't care about the value, just its existence. Of course there are utility predicates for the latter case to turn that into a boolean value."
haskell,3dhcei,htebalaka,2,Thu Jul 16 09:12:15 2015 UTC,"Value was there -> have value Value was not there -> have nothing   In Haskell, you model this with the standard Maybe type:  data Maybe a = Nothing | Just a  lookup :: k -> Map k a -> Maybe a   (I've simplified the type a bit to get rid of an irrelevant constraint).  This means you have to write code for the case the value wasn't there.  Something like:  case lookup key someMap of Nothing -> .. handle key not found Just val -> .. we have 'val' which is the key.   If you know for sure the value will be inside the map, you can use:  (!) :: Map k a -> k -> a   which is the same as lookup but asserts that the value is there (will crash with a runtime error if it isn't).  val = map ! k"
haskell,3dhcei,theonlycosmonaut,2,Thu Jul 16 09:09:01 2015 UTC,"Note that if you don't (immediately) care about whether the key is missing there are control flow operators that behave like exceptions, which allow you to compose multiple fail-able values in a type safe way."
haskell,3dhcei,mjmrotek,1 point,Thu Jul 16 10:39:30 2015 UTC,"Kind of like in Go? Okay, makes sense."
haskell,3dhcei,theonlycosmonaut,2,Thu Jul 16 11:48:24 2015 UTC,"Or perhaps like in Matlab, where a function can check how many return values are actually consumed, and change its behavior accordingly. Kind of like combined lazy evaluation / dispatch on the return value, but without all the guarantees that Haskell provides."
haskell,3dhcei,tikhonjelvis,1 point,Thu Jul 16 13:18:17 2015 UTC,"Oh right, and I'm pretty sure R does something like that, too. That freaked me out the one time I brushed against it :p"
haskell,3dhcei,theonlycosmonaut,1 point,Thu Jul 16 22:31:30 2015 UTC,"I guess the performance characteristics are different? Like, returning a tuple allocates on the heap while multiple return parameters can just be on the stack or in separate registers? I'm not sure.  And if you really need that, we always have unboxed tuples in Haskell."
haskell,3dhcei,tikhonjelvis,1 point,Thu Jul 16 22:36:11 2015 UTC,Good point. Might GHC choose to use the stack? Or even inline the tuple away completely? I guess that's relying on voodoo though.
haskell,3dhcei,hastor,3,Thu Jul 16 22:39:40 2015 UTC,"Well, Haskell is inherently a high-level language, and this is clearly just a performance optimization. The Haskell (or at least GHC) design philosophy would be to rely on the compiler by default but give you an escape hatch if you really need it. (Which is exactly what we get with unboxed tuples.)  To me that seems like a really solid choice, but it's different from the philosophies of languages like C and C++."
haskell,3dhcei,redxaxder,7,Thu Jul 16 22:46:27 2015 UTC,"I have.  Multiple return values:  Haskell supports patten matching of the return value, so you get something like destructuring-bind on the return value, and you can easily ignore the return value you don't like.  let (value, _) = someHashLookup table key if the second return value is not interesting.  Types are very light weight in Haskell.  Ignoring parts of the return value is frowned upon in haskell-land, OTOH, lots of the Prelude consists of non-total (i.e. unsafe) functions.  The Haskell community is moving towards more use of total functions but it takes a long time to change the Prelude.  Lenses are generic setters.  Structs are similar.  Your defparameter is often the bottom layer in a monad stack, a Reader.  This reader gives access to global configuration information.  You'd often create some sort of hierarchy in the data structure that represents the set of global configuration information in order to modularize this."
haskell,3dhcei,beerdude26,3,Thu Jul 16 09:57:23 2015 UTC,"I'm sure there are dark corners of Haskell-land where partial functions rule, everything is an instance of Typable, and the codebases are awash in a sea of toDyn calls."
haskell,3dhcei,tailbalance,1 point,Fri Jul 17 06:22:59 2015 UTC,"All we know, is that he's called The Stig PHP."
haskell,3dhcei,olzd,14,Sat Jul 18 18:47:43 2015 UTC,"This may sound harsh, but those are the wrong questions. You’ll have a hard time with Haskell with “my language has A,B,C and Haskell  should has them too”.  Example: we don't normally use macros because you can just write eDSLs in normal code, thanks to purity and laziness."
haskell,3dhcei,kyllo,3,Thu Jul 16 09:43:27 2015 UTC,"Example: we don't normally use macros because you can just write eDSLs in normal code, thanks to purity and laziness.   Do purity and laziness really help? Serious question. I get that laziness is useful to implement your own control-flow operators."
haskell,3dhcei,kyllo,5,Thu Jul 16 14:52:35 2015 UTC,"If you want laziness, you need purity too. If you have lazy functions with side effects you will have a really hard time reasoning about when your side effects will happen. This is a huge pain point for Clojure developers because that language is impure but makes extensive use of lazy data structures."
haskell,3dhcei,olzd,3,Thu Jul 16 16:16:02 2015 UTC,"But the example was macros. Laziness is exactly why you don't need a macro in Haskell to do a lot of the things you would need a macro for in Lisp.  As for ""questionable""--I see it like this: a language/compiler can default to strict evaluation or lazy evaluation, and both approaches have pros and cons. You want a strict strategy for some problems and a lazy strategy for others. We just haven't yet invented a compiler smart enough to automatically figure out when we want strictness or laziness for us. So we have to make it default to one strategy and tell it explicitly when we want the other strategy."
haskell,3dhcei,olzd,2,Thu Jul 16 14:54:46 2015 UTC,"It's laziness that's the questionable part.   Why, if you don't mind me asking?"
haskell,3dhcei,tailbalance,2,Thu Jul 16 16:12:12 2015 UTC,Thank you. But don't you still need laziness if you want to choose what to evaluate and when? Unless you have macros.
haskell,3dhcei,reaganveg,1 point,Thu Jul 16 15:54:28 2015 UTC,Laziness is a (pretty obvious) requirement
haskell,3dhcei,minipump,2,Thu Jul 16 17:47:03 2015 UTC,"Laziness doesn't get you that far though, for example you can't programmatically generate data types and typeclasses, or implement something like do notation, or idiom brackets that support infix, without patching the compiler (or using TH, which is legit macro support, but sucks to use)."
haskell,3dhcei,mjmrotek,0,Thu Jul 16 18:33:08 2015 UTC,Haskell should has them too   I can has macros?
haskell,3dhcei,htebalaka,8,Thu Jul 16 18:39:55 2015 UTC,"I did several years ago, though I'd never written anything serious in CL, just toy projects. I remember at first it was quite annoying (for example that lists can only contain values of the same type, or having to declare data types instead of just using a symbol), but I came to like it.    generic setters   Setters in a Lisp sense technically don't even exist in Haskell because of its pure and immutable nature, but you may want to have a look at lenses - lens-family-core, or the bigger library lens. All in all they can be used like this, so I think it's not only quite close, but actually more capable.   structs   Abstract data types are kind of the most basic thing in Haskell. And you can not only have structs, or product types, but also sum types (multiple variations of the same type), like:  data Foo a = Foo {foo :: Int, bar :: a} data Bar = None | Bar Double   I know it may not sound like much when coming from a dynamically typed language, but I do think that documenting what forms can a given variable take greatly helps in refactoring or even just understanding the code later. Though Haskell does have an (almost) all-encompassing Dynamic type in the standard library, if you'd ever need it.   multiple return values   Only tuples or composite data types.   good macro system   There is Template Haskell, and I think it is just as capable as CL macros, but its not used as often. Haskell's syntax is fairly complicated when compared to s-expressions, and the resulting macros are IMHO quite ugly. Though there are libraries that use TH a lot, like yesod.  Haskell has also a different method of code generation, namely functions that are polymorphic in the return value, or just polymorphic values. Then the type, and consequently the value of an expression may depend on the context of its use. There are also Generics that allow one to break up a data type into simple pieces, that allows to write data type agnostic functions. With libraries like vinyl or hlist one can recurse over the types to make functions that work over an Rec or HList, regardless of the actual types. I think that static typing helps a lot in this respect.   defparameter   I think the best alternative to dynamically scoped variables is the reader monad:  foo :: Num a => Reader a a foo = return.(+1) =<< ask  bar :: Num a => Reader a a bar = do   a <- foo   b <- local (+a) foo   return $ a + b  main = print $ runReader bar 3 + runReader bar 0   If you want the called functions to be able to modify the value seen by the calling function, then there's the state monad:  increment :: Num a => State a a increment = do   a <- get   put $ a + 1   return a  foo :: Num a => State a [a] foo = do   a <- increment   b <- increment   c <- increment -- there are functions in the standard library to loop like this, of course   d <- get   return [a,b,c,d]"
haskell,3dhcei,mjmrotek,4,Sun Jul 19 05:13:04 2015 UTC,"There's also Data.Reflection as an alternative to the Reader monad, though it involves more advanced type machinery."
haskell,3dhcei,theonlycosmonaut,2,Thu Jul 16 22:29:19 2015 UTC,"That was a comprehensive reply, thanks. You said you came to like it ultimately? For what reasons? More than CL? How long did the transition process last? Just the thought of lists where only one datatype is allowed makes me shiver lol."
haskell,3dhcei,dukerutledge,5,Thu Jul 16 09:38:25 2015 UTC,"Well first of all Haskell doesn't require you to pull in the whole compiler to just write a ""hello world"", and developing stand-alone applications was a concern to me. Of course it does make it less flexible (no eval), but there are some programs written in Haskell that try to have the cake and eat it too (for example xmonad is configured by writing a replacement main module that imports XMonad as a library, which is then recompiled)   You said you came to like it ultimately? For what reasons? More than CL?    Yes, I really just came to like writing code that stays where I leave it, where I can put a lot of assumptions into the types which are checked by the compiler, instead of keeping elaborate structures in my head or having to write them down in comments.   How long did the transition process last?   I don't really remember now. I didn't use Haskell all that often at first, sometimes bouncing off some difficulties that I couldn't overcome. I ended up using Haskell in a program for my thesis (I'm not studying computer science, it was a data analysis program), and having deadlines on my head apparently helped me make the transition from still struggling with the language itself (though I'm not sure whether things mentioned in the Typeclassopedia count as ""language"" or ""library"") and some more advanced libraries (like lenses or pipes) to releasing some first packages to Hackage.   Just the thought of lists where only one datatype   Comfortable programming style in Haskell is way different than in Lisp. If you want a ""different lisp"" you might be better off trying Racket (I don't have much experience in it, I'm just namechecking because I saw some people mentioning it here, and it does look nice ;)). It's not that Haskell prevents you from writing code in a particular way, you can do this if you want:  foo :: [Dynamic] -> Dynamic foo [] = toDynamic ""end"" foo (d:ds) = case fromDynamic ds of                          Just lst -> toDynamic $ fst : lst                          Nothing -> case fromDynamics ds of                                                  Just ... -> ...     where fst = case fromDynamic d of ...   it's just pretty awkward. I don't really use lists all that much in Haskell, for example whenever I'd use a list with complicated structure in Lisp I'd use a data type in Haskell, especially that I can have constrained sum types, instead of just throwing everything in the Dynamic bucket implicitly. I honestly think that static typing is more flexible than dynamic typing (Dynamic is perfectly legal Haskell, but I can't dispatch on return value in a dynamic language, for example) in the end."
haskell,3dhcei,theonlycosmonaut,4,Thu Jul 16 15:50:19 2015 UTC,"Just the thought of lists where only one datatype is allowed makes me shiver lol.   I'm really curious as to what you do with lists containing multiple types! Where do they occur in your code, and how do you use them? I mean, I know in Lisp everything is a list, but ignoring the obvious cases that might be replaced by syntax in another language."
haskell,3dhcei,dukerutledge,5,Thu Jul 16 10:28:45 2015 UTC,In a dynamically typed language heterogeneous lists are often used where a homogeneous list of a sum type is really what is sought.
haskell,3dhcei,theonlycosmonaut,1 point,Thu Jul 16 11:14:43 2015 UTC,I don't know if I've ever had to use one of those in Haskell so I'm curious to know what Lispers are doing with them all the time!
haskell,3dhcei,kyllo,3,Thu Jul 16 11:58:40 2015 UTC,"The simplest example I can think of is Maybe vs nil.  In scheme you might want to represent a list of strings that exist and don't exist. You'd do this with a heterogeneous list of string and nil.  (list ""bar"" #nil "" ""foo"")   In Haskell you'd use a homogenous list of the sum type Maybe String:  [Just ""bar"", Nothing, Just ""foo""]"
haskell,3dhcei,conklech,1 point,Thu Jul 16 17:48:32 2015 UTC,"Hmm, okay. I think I've just become too familiar with implicit nullability - to me thinking about a list of strings and nils isn't a heterogeneously typed list, just a list of pointers."
haskell,3dhcei,nikki93,3,Thu Jul 16 22:33:48 2015 UTC,"It's easy, you just define an existential or algebraic data type, which itself can hold values of multiple types, and you put those in a list.  http://chrisdone.com/posts/existentials"
haskell,3dhcei,dagit,2,Thu Jul 16 22:49:45 2015 UTC,"That avoids the question, though: when are multi-typed lists needed and appropriate?  We've had the existential-list argument a recently here; I think a lot of the confusion/disagreement boils down to use-case ambiguity. For people coming from other languages and trying to write native Haskell, I think the correct response to ""heterogeneous list?"" is almost always ""sum type!"" as /u/dukerutledge pointed out. But I'm willing to believe there are exceptions.  Edit: I see now that you said ""... or algebraic data type."""
haskell,3dhcei,htebalaka,2,Fri Jul 17 03:21:38 2015 UTC,"When you learn a language with a very different paradigm, you should try dropping how you think for a bit and rebuilding it in a new way. Then after some experience with the new form you will subconsciously mix the two modes of thought in an interesting way. So try haskell while forgetting about setters/structs/macros in the CL way for a bit, and start thinking in applicatives/monads or whatever. haskell is closer to scheme than CL too, I'd say.  By trying to recreate CL-like programming in haskell, you will simply add more accidental complexity rather than remove it.  The parts of CL-like development I'd like to see recreated in haskell would actually be the live coding type stuff (changing behavior and types while your program is running)."
haskell,3dhcei,chrisdoner,5,Thu Jul 16 16:04:00 2015 UTC,"About 10 years ago I was doing a lot of Common Lisp programming. I started checking out Haskell because I had a class that made me use it. I hated it. So many type errors. Not only that, but the type errors kept pointing out when I had done something dumb. I already knew how to do functional programming, why did I have to relearn so much? Why did I need to memorize a new standard library? Why??  Fortunately that class didn't last forever and I was able to go back to Common Lisp. That's when I realized a few upsetting things:   First, I continued to write programs that didn't make sense, but now the language did nothing to help me figure that out statically. Second, instead of having things evaluate as needed, I was back to inserting quote to delay computation as needed. This was brittle and I often get it wrong. I hate finding out about my stupid mistakes at run-time.   Basically, Haskell ruined lisp for me. So I gave Haskell a second try with an open mind and that time it stuck. I had a period of time in grad school where I was doing Haskell for fun and lisp for my professor. Now I'm about 10 years into this Haskell-for-the-second-time experiment and the only lisp I write is when I'm configuring emacs. I don't miss CL at all, but I still have tons of respect for it.  You won't need macros as much as you do in lisp because laziness allows normal run of the mill data structures to serve as control flow structures. No macros needed for that class of problems. Haskell has a template system and generic programming for the other cases.  The lack of side-effects is great. I had to retrain myself a bit to write code correctly in that style, but it forces you to separate concerns early and that always pays off long term, as far as I can tell.  One thing to be warned about, in Haskell you probably don't want to convert everything to tail-call form all the time. I'm referring to the transformation where you add a parameter to a function so that you can pass in an accumulator value (the result of the computation, thus far) and when you're done you just return it.  That form still makes sense in Haskell (sometimes), but due to laziness you usually don't need it (you can think of every function call in Haskell as already being a tail call), and there are documented cases where it's actually worse than not doing it. Haskell doesn't need a normal function call stack, but in GHC some computations are reduced using a stack (as an optimization). When you do the above tail call optimization you can sometimes put too much pressure on that stack and cause performance problems.  Overall, keep an open mind and I think you'll be happy you gave Haskell a shot even if you don't stick with it ultimately."
haskell,3dhcei,htebalaka,2,Fri Jul 17 20:43:28 2015 UTC,"I was just yesterday wondering about the opposite. For someone who has written almost exclusively Haskell for the last few years, and doesn't have any plans to stop using the language, would learning Lisp be worthwhile? I'm a little interested in macros (though mostly think Haskell removes the need. Mostly I'm interested in the more powerful REPL features in lisp (the story of debugging spacecrafts after a crash was interesting), though I can't seem to find if that limits me to common lisp, or if another variant would be better to try.  Unfortunately it seems like anything being advertised as a functional language is never written for people who are already familiar with one."
haskell,3dhcei,chrisdoner,4,Thu Jul 16 13:04:14 2015 UTC,"Learning Common Lisp is worthwhile for the same reason Smalltalk is, because they have impeccably good live development environments and inspection/debugging facilities, and knowing that they can be this good lends to a healthy dissatisfaction with the state of Haskell's. Restarts are also cool and quite more advanced than Haskell's exception system, they're used for development control flow and everything is ran in the Lisp image, including the package manager.  Also writing a non-trivial project in Lisp is worthwhile to know what it's like to work in a language whose syntax doesn't actively work against being easy to edit. Anyone who has done substantial development with Paredit will tell you that it's heavenly. People who tried to edit Lisp in editors that don't do what Paredit does will tell you that s-expressions aren't that great. These people swam in a puddle. You have to dive into the pool to know what swimming is like.  Don't underestimate homoiconic macros in Lisp, they solve problems that you can't in Haskell, such as defining a lambda-case or multi-way if; this is something you could define in a few lines in Lisp and move on. In Haskell it took years and discussion and compiler modification and tooling update just to support it. Related this-plt-life GIF. If you wanted unification or pattern synonyms in your pattern matching, you could do yourself."
haskell,3dhcei,physicologist,2,Thu Jul 16 21:08:24 2015 UTC,"Would you say Common Lisp is preferable to Scheme/Clojure/Racket in the teach-a-Haskeller-something-different sense (assuming you know enough about the others to compare)? I don't really have a pressing need to learn another language right now, which makes the paradox of choice feel a little stronger."
haskell,3dhcei,chrisdoner,7,Thu Jul 16 10:34:45 2015 UTC,"The reasons for learning each are different IMO:   Scheme is a tiny toy language, it's pretty much only worth learning as an example of a minimal language. It doesn't teach anything particularly interesting for a Haskeller. Clojure is probably the cleanest designed Lisp and closest to functional programming, and practical because it can use Java libraries. I don't think it has restarts or a particularly good development environment, though. Its answer to SLIME, nrepl is kind of new and less established. Racket is Scheme with extra stuff that tries to be everything with different dialects. I don't know that there's anything new in it, probably not its development environment. (One of the Racket authors is likely to read this and come reprimand me, but I'll live.) Common Lisp has a mature development environment and mature compilers, along with a culture of using them, with restarts and spitting out assembly and all that. SBCL is a fascinating compiler to me. I think you get a genuine ""Lisp"" experience with CL. It's also the oldest of the non-toy Lisps and as such has a lot of cruft in the standard library. Emacs Lisp is another alternative you didn't mention. It comes with a native development environment and self-documenting standard library. It's not a great Lisp but it at least gives you the image-based development model and you can use it to enhance your development environment.   But I've only learned Scheme (although my Scheme of choice was PLT Scheme, the predecessor to Racket) and CL."
haskell,3dhcei,physicologist,1 point,Thu Jul 16 12:56:02 2015 UTC,"I'm surprised that you'd call Emacs Lisp an image based development model, but I've always suspected that I never understood the whole image system properly.  As I understood it, I would have though Emacs Lisp is a file based system, since only what is physically written in my .emacs file is preserved between sessions, while all of the remaining state is cleared.  Have I misunderstood emacs or have I completely failed in comprehending images?"
haskell,3dhcei,reaganveg,3,Thu Jul 16 13:14:12 2015 UTC,"It's probably just mincing words. An image indeed tends to mean image-based persistence. Rather, I meant the environment, the thing that you update. Usually that's a running image in Lisp parlance, but indeed, Emacs has no way to persist the image to disk."
haskell,3dhcei,chrisdoner,1 point,Thu Jul 16 13:40:27 2015 UTC,"That makes sense.  Someday, I'll have to look into image-based persistence again - I know that I've probably missed something."
haskell,3dhcei,mjmrotek,1 point,Thu Jul 16 22:42:50 2015 UTC,"Emacs has no way to persist the image to disk.   Emacs actually can do that, and it is done during the build process of the emacs binary:  http://www.emacswiki.org/emacs/DumpingEmacs"
haskell,3dhcei,satsujinka,1 point,Thu Jul 16 23:50:09 2015 UTC,Sort of; you have to run in batch mode and specify a file to load and that always gave a segfault for me. Far and away from CL or Smalltalk where this is part of the development process and you can just take your current image and persist it safely and resume later.
haskell,3dhcei,chrisdoner,2,Thu Jul 16 23:53:56 2015 UTC,"Anyone who has done substantial development with Paredit will tell you that it's heavenly.   Oh yes, jumping around the syntax tree is one things I really miss in Haskell."
haskell,3dhcei,tailbalance,2,Sun Jul 19 04:59:11 2015 UTC,"Multi-way if:  if :: [(Bool, a)] -> Maybe a if [] = Nothing if ((True, a)::_) = Just a if (_:xs) = if xs  -- a, b, and c have to be the same type -- but that's no different then regular if-then-else if [(a < b, a)    ,(a > b, b)    ,(True, c)    ]   Not hard at all. :p"
haskell,3df66x,sclv,9,Wed Jul 15 20:05:38 2015 UTC,"Thanks to /u/hdgarrood for all his hard work on this project, and thanks to the Haskell GSOC committee for allocating us slots for PureScript this year. This is going to be a really valuable tool for PS developers."
haskell,3df66x,paf31,2,Wed Jul 15 20:33:51 2015 UTC,Great job!   All types in documentation are links pointing to the documentation for that type.    Can we have this in hackage?
haskell,3df66x,emarshall85,2,Thu Jul 16 01:17:37 2015 UTC,"Thanks :)  Does hackage not already do this?  Also, I've just realised that this is actually a bit of a lie: if your bower dependencies are not set up properly, when you run the tool to generate the data, you can end up with links not working for types in your dependencies. The tool does warn you when this happens, though."
haskell,3df66x,hdgarrood,2,Thu Jul 16 01:25:09 2015 UTC,"I guess it does. I could have sworn I checked a package and only internal types were linking properly. I just checked pipes though, and the signatures seem to be properly linked.   update: Yep, I'm just crazy.   On another note, I do appreciate the more modern styling, so kudos there as well."
haskell,3dfbyu,bdesham,10,Wed Jul 15 20:46:28 2015 UTC,"I have a reliable build set up for a windows dll now using Shake!  C++ files are built something like this:  cd src/cpp/; gcc -c -m64 --std=c++0x -O2 -g -Wall <file>.cpp -o ../../build/cpp/<file>.o   Grab the cabal sandbox using a batch file called with ""cabal exec""  @ECHO %GHC_PACKAGE_PATH%   A makefile mapping dependencies is   ghc -package-db <result> -M -no-user-package-db -dep-suffix . dep-makefile ./<make> MyMain.hs   Using http://hackage.haskell.org/package/shake-0.15.4/docs/Development-Shake-Util.html#v:parseMakeFile , individual haskell files are built using:  ghc -c -static -threaded -O2 -ibuild/dll -outputdir ""build/dll/"" src/<file>.hs -package-db <result>   Using the data from the makefile, I build a call to dlltool.exe that looks like  dlltool.exe -z build/dll/dll.def -D MyDll.dll --export-all-symbols build/dll/<file1>.o build/dll/<file2>.o ...   That gives me a .def file which exports all the symbols (you can filter them if needed).   Then the final dll is built with:   ghc -static -shared -O2 -threaded -outputdir ./ -ibuild/dll:build/cpp -package base -package containers -package ... -o MyDll.dll -package-db <result> build/cpp/<file.o> ... build/dll/<file1>.o build/dll/<file2>.o ... build/dll/dll.def -lstdc++   Let me know if you have other questions. I highly recommend Shake!  Edit: actually, there is nothing top secret about this, so if you want to look at my actual build file, it's here: https://gist.github.com/oconnore/7d874f23dc4a825f5bc4 Bonus points if you clean it up and send it back :)   Edit 2: now I feel guilty about not writing anything up... sorry!"
haskell,3dfbyu,focuskids,3,Thu Jul 16 05:21:43 2015 UTC,Can you put this on this Haskell wiki?
haskell,3dfbyu,fruitbooploops,2,Thu Jul 16 19:04:02 2015 UTC,https://wiki.haskell.org/Windows#Generating_Dynamically_Linked_Libraries_.28DLL.27s.29
haskell,3dfbyu,focuskids,1 point,Tue Jul 21 18:30:36 2015 UTC,Ah ok
haskell,3dfbyu,fruitbooploops,1 point,Tue Jul 21 19:04:17 2015 UTC,"(I mean: yes, I just put this up on the wiki, good idea)"
haskell,3dfbyu,focuskids,1 point,Tue Jul 21 19:44:47 2015 UTC,Ah good then
haskell,3dfbyu,fruitbooploops,5,Wed Jul 22 01:31:21 2015 UTC,"The next version of Cabal will have native support for this, in the form of ""foreign-library"" sections in your .cabal file.  It can build Windows dlls, Linux .so and OSX .dynlib. On windows these are self-contained dlls, on Linux and OSX they depend on the other Haskell shared libs. (This is a limitation of how ghc currently ships libs on each platform)"
haskell,3dfbyu,dcoutts,3,Thu Jul 16 13:30:53 2015 UTC,cool!  when might this version be released?
haskell,3dfbyu,spirosboosalis,4,Thu Jul 16 15:09:37 2015 UTC,You can try out the branch now if you like: https://github.com/haskell/cabal/pull/2540
haskell,3dfbyu,edsko,3,Thu Jul 16 20:49:40 2015 UTC,"I'm not the release manager so I can't tell you for sure, but you can try out the dev version and give feedback. This feature hasn't actually hit HEAD yet but it should ""RSN""tm."
haskell,3dfbyu,dcoutts,5,Thu Jul 16 20:06:22 2015 UTC,"You can do this with recent versions of Cabal.  You'll want to be familiar with this GHC tutorial.   As GHC's tutorial shows, you need a StartEnd.c Add -shared and StartEnd.c to ghc-options.   Cabal 1.22 and prior will issue a warning when building, but you will still end up with HSdll.dll and HSdll.dll.a in the same directory as your cabal project. You will find a <MyProject>_stub.h file in cabal's build tree.  [It's still quite crude, as you can't easily rename the DLL via cabal (you can, but it's messy) and you can't have it place the output in  any other folder.]  In your C++ code, include the _stub.h file and link in the .dll.a like a .lib file.  I have done this with both cabal-install and stack, on GHC 7.8.4 and GHC 7.10.1, both 32 and 64-bit compilers.  Since you ask, I might try to write up a blog post about it actually. I answered your SO question instead."
haskell,3dfbyu,eacameron,2,Thu Jul 16 15:29:50 2015 UTC,"libm is the math-library of C.  It is not part of Haskell or GHC. It rather comes with glibc under unix. I don't know where the math-stuff under windows is - but the functions implemented in it are stuff like sin, cos, exp, pow, ... so there should be a similar library under Windows - preferably shipped with the windows-version of C++.  hth"
haskell,3dfbyu,Drezil,2,Wed Jul 15 21:55:53 2015 UTC,Under MinGW most math functions are in libmingwex.a. Sadly only static version of that library comes with MinGW which leads to some interesting hacks if you need to use those functions in GHCi.  https://ghc.haskell.org/trac/ghc/ticket/3242#comment:10
haskell,3dfbyu,wrvn,2,Thu Jul 16 21:28:46 2015 UTC,My project is a binding to C++ from Haskell and I have it building on Windows using CMake . Not sure if this helps because it's Haskell calling C++ and not the other way around.
haskell,3dfbyu,deech,1 point,Thu Jul 16 03:01:08 2015 UTC,"Thanks, but those seem to be two different beasts."
haskell,3dfbyu,dmjio,3,Thu Jul 16 15:27:41 2015 UTC,This might be relevant: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/win32-dlls.html
haskell,3ddn1b,atzeus,7,Wed Jul 15 13:21:55 2015 UTC,How does this compare with reflex?
haskell,3ddn1b,andrewthad,17,Wed Jul 15 14:26:34 2015 UTC,"If somebody would be kind enough to contribute a reflex implementation and an FRPNow implementation to the frp-zoo, we'd be able to answer that question for a large number of pairs of FRP frameworks. There are so many, I haven't been able to keep up and to add either of them to the zoo myself!"
haskell,3ddn1b,gelisam,8,Wed Jul 15 16:45:04 2015 UTC,"With all these FRP libs in Haskell the Zoo is a necessity. I would not mind if there was also a bigger example in the Zoo, a bit like what TodoMVC has become for JS frameworks."
haskell,3ddn1b,cies010,5,Wed Jul 15 17:39:54 2015 UTC,"Although there isn't an frp-zoo implementation for reflex yet, we do have a TodoMVC implementation: https://github.com/ryantrinkle/reflex-todomvc Hopefully we'll have an frp-zoo implementation soon, too!"
haskell,3ddn1b,ryantrinkle,4,Wed Jul 15 18:33:08 2015 UTC,"I would not mind if there was also a bigger example in the Zoo   Maybe once we manage to port the small example to all the relevant libraries! Which things are missing from the small example which you would like to see in a bigger example?   a bit like what TodoMVC has become for JS frameworks.   My goal was indeed for frp-zoo to become the TodoMVC of FRP frameworks, but unfortunately the zoo is not yet ubiquitous enough for new framework authors to bother contributing an implementation in their new library."
haskell,3ddn1b,gelisam,3,Wed Jul 15 18:25:06 2015 UTC,"TodoMVC is relevant to FRP precisely because it illustrates a familiar, simple model that can be very tricky to express understandably in an FRP idiom."
haskell,3ddn1b,conklech,6,Wed Jul 15 19:50:12 2015 UTC,"The goal of the FRP zoo is to compare FRP frameworks with each other, not to compare FRP to other techniques (although it does contain a few non-FRP techniques). Looking at an FRP implementation of TodoMVC sounds like it would be a good way to do the latter.  I don't know if that's what you're trying to suggest, but I don't think that it would make sense for the FRP zoo to use the same example as TodoMVC. One reason is that while an FRP implementation of the problem is going to look different from a non-FRP implementation, the implementation for different FRP libraries is likely to be relatively similar. Worse: the problem is large enough that the differences between the implantations are more likely to be due to design decisions by the implementer than to true differences between the libraries, therefore making those differences harder to spot. By choosing a very trivial problem, I allow the focus to be on the library, not on the application's architecture.  Since TodoMVC focuses on frameworks, it makes sense for them to use a problem in which you can show off the architecture."
haskell,3ddn1b,gelisam,5,Wed Jul 15 22:56:30 2015 UTC,"As a sample-size-of-one anecdote, I've been trying to use a minimal todo app to try things out with different FRP libraries.    I've been focusing on event-and-behaviour based FRP - so reactive-banana and sodium - and so far the todo use case has lead to interesting intersections of dynamic switching and event handler registration.    Normally that part is pretty painful for me relative to everything else in the app - to the point that I'm not sure I could sell it to others.  It's entirely possible that I'm just massively misusing those libraries so far.  I've got FRPNow in my queue, and am optimistic - it looks like it might have an API that removes that pain point."
haskell,3ddn1b,dalaing,2,Thu Jul 16 03:58:49 2015 UTC,"I agree with your comments. I'm not sure the different FRP libraries are liable to have particularly similar implementations, though; it would tend to expose the libraries' (and authors') concepts of division of view and model, for instance.  Edit: I didn't mean to suggest that the FRP zoo should use TodoMVC; they're different projects with different goals, as you note. I do like that various FRP and non-FRP projects have been doing TodoMVC implementations."
haskell,3ddn1b,conklech,2,Wed Jul 15 23:09:58 2015 UTC,"Hope you don't mind me piggybacking here to link the Slant topic as well, which is good for sharing the less quantifiable aspects of working with the various libraries. (And still needs a lot more sharing...)"
haskell,3ddn1b,tejon,8,Thu Jul 16 02:01:17 2015 UTC,"Good question! Honestly, I'm a bit unsure. I do not know what the exact model is of reflex, or if there is something you can do with this and not with reflex (or vice versa). Does anyone know what (if any) the denotational model of reflex is (Ryan Trinkle mentions a denotational model in one of his talks, but I do not know if it is done yet)? This would make a comparison easier...  Currently the only thing I can say is that the interface is different :) Reflex makes a distinction between push-based and pull-based computations in the interface, whereas with frpnow this is left to the implementation (currently pull-based with sharing, but a push-based implementation should also be possible). It is not possible to be notified when a behavior changes in reflex, this is possible in frpnow."
haskell,3ddn1b,ryantrinkle,5,Wed Jul 15 14:37:40 2015 UTC,"There's a concise, pure implementation of the Reflex semantics available here: https://github.com/ryantrinkle/reflex/blob/develop/test/Reflex/Pure.hs While it's not quite a denotational semantics, it's a step in that direction.  There's a test suite that verifies that this implementation operates equivalently to the primary implementation (""Spider"").  With respect to detecting when Behaviors change, a common pattern in Reflex is to use an Event and a Behavior together - called a Dynamic - to achieve this."
haskell,3ddn1b,zorasterisk,1 point,Wed Jul 15 17:31:57 2015 UTC,Maybe you have a good view of the difference? Are you coming to ICFP? I would like to have a chat :)
haskell,3ddn1b,snoyberg,3,Thu Jul 16 09:30:24 2015 UTC,Too bad gloss slipped out of stackage.  Speaking of -- will you attempt to fold frpnow into stackage?
haskell,3ddn1b,dagit,7,Wed Jul 15 14:08:28 2015 UTC,Uhh maybe :)
haskell,3ddn1b,codygman,7,Wed Jul 15 14:12:48 2015 UTC,"If you get it into Stackage, then stackage.org will build and host the docs for you too."
haskell,3ddn1b,dagit,5,Wed Jul 15 17:54:26 2015 UTC,"How hard would it be to add a GLFW-b backend?  I have a simplistic pong-like game that I like to use for testing out FRP libraries. In particular, restarting the ball and calculating the position tends to show me how much I'll actually enjoy using a particular FRP implementation :)  I like to use GLFW-b as the backend for my pong game. Here is the source code: https://github.com/dagit/1GAM/tree/master/pong  The most complete version is the yampa version. I had to give up on the reactive-banana version because I couldn't resolve all the space leaks I was seeing with integrating the ball's position. You can find example code in there for how I hooked up yampa and reactive-banana to work with GLFW-b.  I haven't compiled any of that in a long while, so it may have bitrotted."
haskell,3ddn1b,apfelmus,7,Wed Jul 15 18:29:33 2015 UTC,I had to give up on the reactive-banana version because I couldn't resolve all the space leaks I was seeing with integrating the ball's position.   Did you submit a bug report to reactive-banana? That sounds like the kind of bug reports I'd be looking for if I were the reactive-banana author.
haskell,3ddn1b,dagit,3,Wed Jul 15 19:33:23 2015 UTC,"We had a few email exchanges. I don't remember everything that happened now, but I recall trying some newer version to see if it fixed the problem. It didn't. That's when I tried other frameworks."
haskell,3ddn1b,apfelmus,5,Thu Jul 16 00:52:46 2015 UTC,"I dimly remember. The problem should be fixed in version 0.8. If it's not, then I'd like to hear about it again. :-)"
haskell,3ddn1b,gelisam,2,Thu Jul 16 10:35:22 2015 UTC,Thanks. No promises that I will look at it any time soon though :)
haskell,3ddn1b,tom-md,2,Thu Jul 16 15:52:27 2015 UTC,"Thank you, rather. And no worries. :-)"
haskell,3ddn1b,togrof,2,Thu Jul 16 21:51:57 2015 UTC,"How hard would it be to add a GLFW-b backend?   Since gloss is supported and gloss has a GLFW-b backend, I guess GLFW-b is already indirectly supported?"
haskell,3ddn1b,dhjdhj,3,Wed Jul 15 23:02:04 2015 UTC,Sort of the wrong level of abstraction at that point.
haskell,3ddn1b,eegreg,2,Thu Jul 16 03:11:58 2015 UTC,Should be fairly easy. A simple modification of the Gloss hookup code should suffice. It's now on my list of stuff to do :)
haskell,3ddn1b,dhjdhj,2,Thu Jul 16 08:36:54 2015 UTC,"Great!  Also nice that you have made gloss and gtk interop packages. Have not tried them yet, but looking forward to it."
haskell,3ddn1b,sccrstud92,2,Wed Jul 15 16:05:20 2015 UTC,"Installed and tried to build the gloss example directly from the sample and got the error   Simple.hs:30:59:    Couldn't match type ‘Set Key’ with ‘[Key]’   Expected type: Behavior [Key]     Actual type: Behavior (Set Key)      In the second argument of ‘(<$>)’, namely ‘keys’      In the expression: (SpecialKey KeySpace `elem`) <$> keys"
haskell,3ddn1b,dhjdhj,2,Thu Jul 16 01:09:01 2015 UTC,Perhaps it requires ghc 7.10 ?
haskell,3ddn1b,arianvp,1 point,Thu Jul 16 02:58:39 2015 UTC,I was running 7.8.3.  I'll install latest version. I'd still like to understand why it doesn't work under 7.8....is the language still that fluid? How does one recognize this kind of error?
haskell,3ddn1b,rpglover64,3,Thu Jul 16 03:36:07 2015 UTC,My guess is they changed from a list to a Set and didn't change elem to member. I don't think that it is related to GHC version.
haskell,3ded39,togrof,18,Wed Jul 15 16:45:08 2015 UTC,It's called ExceptT.  I think that name was a giant mistake exactly because you're asking about it and obviously are expecting EitherT.  But unfortunately that's the situation we're stuck with.  I would say that the definitive answer to this question will always be found in the errors package.  It just made the switch to ExceptT in errors-2.0.  :(
haskell,3ded39,mightybyte,3,Wed Jul 15 17:12:44 2015 UTC,Maybe EitherT was avoided because Either's  fail method is weird?
haskell,3ded39,hagda,6,Wed Jul 15 18:36:42 2015 UTC,"ExceptT is built around Either, so I don't see how that matters.  The point is that ExceptT is not the name that users expect, and this post is proof."
haskell,3ded39,mightybyte,6,Wed Jul 15 18:49:30 2015 UTC,"I wrote the package precisely to get avoid the constraints that having a ""less weird"" fail forced on every single user of ErrorT in the first place.  If you want the error-like behavior we have ErrorT for that. Right up until Ross finishes deprecating it, then God only knows what will happen."
haskell,3ded39,edwardkmett,3,Wed Jul 15 21:35:31 2015 UTC,Apart from the name I am not very comfortable with the Monoid constraint on MonadPlus and Alternative for ExceptT because mappend does not make sense for error types with a single error value.
haskell,3ded39,edwardkmett,4,Wed Jul 15 22:23:31 2015 UTC,"The constraint lets us smash together several errors across (<|>).  That said, it should be a Semigroup constraint, not a Monoid constraint."
haskell,3ded39,mightybyte,2,Wed Jul 15 22:46:22 2015 UTC,"The errors package is not the answer. It may be semanticaly similar, but I mean we should have an EitherT in transformers as a companion to Either. The name is half the point."
haskell,3ded39,Tekmo,9,Wed Jul 15 17:16:56 2015 UTC,"Oh, I agree with you, but the maintainer of the transformers package doesn't.  And unfortunately he has more power in this area.  The whole point of the errors package is to unify all this stuff.  It does a fantastic job of it.  Gabriel will make sure he is always doing the Right Thing with this stuff, so I think it is what the community should use as its definitive guide."
haskell,3ded39,codygman,5,Wed Jul 15 17:20:21 2015 UTC,"Yes, as much as I dislike the name ExceptT, I figured it would fragment the library ecosystem less to just standardize on it and to get over the terrible name.  transformers is installed by default with all GHC installations, which is why I prefer to use the transformers version.  I would still like to eventually see a separate EitherT type added to transformers for people who wish to use it for non-error-handling purposes.  I agree with a lot of other people here that most beginners have difficulty discovering ExceptT because they expect it to be named EitherT."
haskell,3ded39,mightybyte,3,Wed Jul 15 22:01:23 2015 UTC,I can say that I was confused to not find EitherT.
haskell,3ded39,Tekmo,2,Wed Jul 15 23:46:08 2015 UTC,"One thing you could do about the situation is make errors provide an alias:  type EitherT e a = ExceptT e a   I'm not sure whether this is a worthwhile thing to do or not, but it would serve as documentation for beginners to point them in the right direction, which might be better than having the deprecated either package come up in Google searches."
haskell,3ded39,LukeHoersten,3,Wed Jul 15 23:22:42 2015 UTC,"Generally I try to avoid type synonyms because they don't survive type inference and error messages.  Also, the specific goal of the errors library is error-handling so ExceptT is actually a more appropriate name in that particular context.  If there were an EitherT type synonym it should belong in another library (or transformers)"
haskell,3ded39,edwardkmett,2,Fri Jul 17 01:01:10 2015 UTC,"I'd ideally like an EitherT in transformers and an ExceptT in errors. Naming-wise that's the most logical. As Doug pointed out, it would avoid the confusion that caused this thread in the first place."
haskell,3ded39,TheCriticalSkeptic,10,Fri Jul 17 16:20:06 2015 UTC,"The EitherT package was deprecated in favor of the much wider used either package in a consolidation pass a while back.   (I know about Control.Monad.Except etc but those are besides the point)   Ross Paterson decided to bikeshed the name of EitherT when he brought it into mtl, renaming it ExceptT.   So ExceptT is precisely the point!  Why?  I'm not meaning to put words in his mouth, but from what correspondence I've had with him on the topic it had always bothered him that We had ErrorT, but Error wasn't ErrorT e Identity, but rather a class that related to supporting Error and he wasn't a fan of the fact that MaybeT and Maybe didn't have the same relation as the rest of the StateT and State like classes in the mtl.  I lobbied hard that we duplicate the MaybeT pattern, but he decided to do otherwise.  So he renamed the data type and colored other bits of the bikeshed different colors.   I don't doubt those are all good, but it is kind of overkill to pull all of them just to get an either transformer.   ExceptT is EitherT, and the reason we moved it upstream was precisely to avoid this need for a ton of package dependencies.  Unfortunately between the bikeshedding and the fact that transformers is very very hard for folks to upgrade due to it being a boot package has rendered it almost impossible for people to move to it in the meantime. With 7.10+, we can finally start to see some migration to ExceptT and in theory the either package can start to dissolve over time as more and more code can finally start to use transformers to get ExceptT rather than either for EitherT.  As for either depending on the mtl. It has to. Otherwise I have to maintain two packages, one of which just contains orphan instances for the mtl classes, which is not acceptable, and leads to a worse user experience and potentially to a loss of coherence of instance resolution. For what?"
haskell,3ded39,edwardkmett,4,Wed Jul 15 21:32:30 2015 UTC,"Ok, so this is were we are now:  We do not have an EitherT in transformers because it would not match the pattern of the StateT, ReaderT, WriterT types, while at the same time we do have MaybeT that does'nt.  Instead we got ExceptT which gives the impression that it is dealing with exceptions or at least exceptional values, which may not be the case. We can ofcourse use ExceptT just like if it was named EitherT, but that does not feel quite right.  Anyway, thanks for the background info on this. :)"
haskell,3ded39,int_index,3,Wed Jul 15 23:09:12 2015 UTC,"This might seem like a silly question, but is there a reason that we don't have a MonadMaybe and MonadEither class in mtl?  It would be nice if for example we could have lookup :: (MonadMaybe m) => k -> Map k v -> m v. That way you wouldn't need to lift Maybe a into a MaybeT m a. And similar for things that work with Either."
haskell,3ded39,hiptobecubic,5,Wed Jul 15 23:14:18 2015 UTC,"Let's think about the operations of MonadMaybe.   You need return for Just, and empty or mplus for Nothing. There isn't anything missing.  lookup :: MonadPlus m => k -> Map k v -> m v   works just fine.  On the other hand, EitherT and the like could benefit from having a thing for emitting the left hand side and to handle it.  class Monad m => MonadError e m | m -> e where    throwError :: e -> m a    catchError :: m a -> (e -> m a) -> m a   is precisely that... and the instance already exists. The naming of stuff is goofy, historical, not terribly symmetric or nice, but its all there when you think it through."
haskell,3ded39,edwardkmett,3,Thu Jul 16 03:27:56 2015 UTC,"That's because MonadMaybe is just MonadError (), and MonadEither is MonadError (the one from Control.Monad.Except). Overall I find the MaybeT transformer quite useless because it's equivalent to ExceptT () up to isomorphism but its name is clearer and you also can replace () with an actual error type with less refactoring.  We could indeed add many more classes to mtl, but this would come at a great cost (remember, O(n2 ) instances, and we can't really have less for fundamental reasons), so if you can emulate one class with another (like MonadMaybe with MonadExcept ()) -- that's a better solution."
haskell,3ded39,hiptobecubic,2,Wed Jul 15 23:55:42 2015 UTC,O(n²) when?
haskell,3ded39,LukeHoersten,2,Thu Jul 16 03:26:33 2015 UTC,"Given n different ""features"" and m different monad transformers we wind up writing up to n instances for how to lift each of the features over each of the m transformers, so that is O(nm) chunks of code. If each transformer is associated with a feature then that is O( n2 ).   We have to write all these data points because occasionally the features can't lift over particular transformers, so the absence of an instance often tells us as much as its presence."
haskell,3ded39,edwardkmett,1 point,Thu Jul 16 03:31:23 2015 UTC,"Ah. We're talking about developer time. OK. I thought that some kind of overhead of function lookup depended in the number of instances, which didn't make sense to me."
haskell,3ded39,singpolyma,1 point,Fri Jul 17 05:30:29 2015 UTC,"As I mentioned elsewhere, I'd ideally like an EitherT in transformers and an ExceptT in errors. Naming-wise that's the most logical. As Doug pointed out, it would avoid the confusion that caused this thread in the first place."
haskell,3ded39,hdgarrood,1 point,Fri Jul 17 16:22:29 2015 UTC,"Alas, that isn't the naming convention that Ross elected to go with.  Now there really isn't a transition plan or a will to change that that would get us there, so we're stuck with what we've got."
haskell,3ded39,edwardkmett,7,Fri Jul 17 16:28:29 2015 UTC,type EitherT = ExceptT
haskell,3ded39,int_index,3,Wed Jul 15 20:09:15 2015 UTC,Why is Except besides the point?
haskell,3ded39,int_index,12,Wed Jul 15 16:54:19 2015 UTC,"Because it is named ExceptT and not EitherT.  Edit: I would not expect MaybeT to be named PerhapsT or something other than MaybeT, and the same goes for Either."
haskell,3ded39,tailbalance,3,Wed Jul 15 17:14:05 2015 UTC,"I happen to agree with you, but the maintainer of the package decided otherwise, and we have a policy that while many can contribute suggestions, patches and proposals, ultimately the maintainer decides.  The person you'd need to convince to go back and revisit that decision is Ross Paterson, not any of us in here."
haskell,3dfcyo,davikrehalt,7,Wed Jul 15 20:53:21 2015 UTC,"LiquidHaskell has indeed no runtime performance loss. For compile time, most time is spend on the SMT solver. But, the syntax of refinements in liquidHaskell's types constraints the logical language to decidable theories (like linear arithmetic, uninterpreted functions, etc) for which SMT solvers have efficient procedures.   In practice (from our benchmarks*) compilation time is around 1s / 10 lines of code, and it does depend on the complexity of your specifications.   *http://goto.ucsd.edu/~nvazou/real_world_liquid.pdf"
haskell,3dfcyo,nikivazou,2,Wed Jul 15 22:50:44 2015 UTC,So around 100KLOC would take 3 hours to compile?
haskell,3dfcyo,Peaker,3,Thu Jul 16 10:07:04 2015 UTC,Are we talking LOC of Haskell of Liquid Haskell annotations?
haskell,3dfcyo,ueberbobo,2,Thu Jul 16 13:56:35 2015 UTC,I thought he meant typical Liquid Haskell code (including annotations). Are they compiled/timed/measured separately?
haskell,3dfcyo,Peaker,7,Thu Jul 16 14:05:07 2015 UTC,"It is 1s for 10 lines of Haskell code without comments.  Until now we write all the liquidHaskell annotations in special comments of the form {-@ liquidHaskell annotation @-}. These kind of special comments are interpreted from LiquidHaskell.  So, we can count the Haskell code and the required annotations separately.  Btw, I am a ""she"":)"
haskell,3dfcyo,nikivazou,1 point,Thu Jul 16 18:00:27 2015 UTC,"Really cool paper, thanks! So, did you submit your annotations/patches to the upstream packages? for example, knowing that bytestring is safe seems like it would be very valuable!  BTW, in the interface with external interfaces (FFI, input, etc), are runtime tests generated for precondition about input, as in the recent work on gradual verification in coq?"
haskell,3dfcyo,danielv134,1 point,Fri Jul 17 17:45:09 2015 UTC,"Thanks!  We haven't yet submitted a patch to bytestring and text because many times verification required code modifications that harm runtime. A usual case is addition of ghost variables, or the need to inline recursive functions with complicated or too specific specifications. All these modifications harm the runtime of the library, and specifically for bytestring runtime is super important. We would like to fix that though and it seems a promising and feasible future work.  LiquidHaskell's library provides a function liquidAssume that can be seen as a runtime test generator and that we use when we want to assume conditions for external interfaces. liquidAssume takes a boolean b, a value x and returns x and also inserts into the logical environment the fact that b is true.  {-@ liquidAssume :: b:Bool -> a -> {v: a | (Prop b)}  @-} liquidAssume b x | b =  x                  | otherwise = error ""die"""
haskell,3dfcyo,nikivazou,4,Sat Jul 18 03:02:41 2015 UTC,"Liquid Haskell is an extension of haskell's type system. The SMT solver is only run at compile time to check type annotations, so there is no runtime performance loss. (there could be a performance gain when liquid types allow to remove some runtime checks)"
haskell,3dfcyo,Rafbill,3,Wed Jul 15 21:00:12 2015 UTC,that's good to hear. But my limited programming knowledge and a quick wikipedia read leads me to think that the SMT solver is going to be NP-complete. So does this lead to impractical compile times?
haskell,3dfcyo,tom-md,3,Wed Jul 15 21:15:56 2015 UTC,"Not typically in practice, but it could (so I thought, other comments indicate my thought is wrong).  I've seen LiquidHaskell used to good effect and without any significant performance issues.  Perhaps you should pull last year's Symposium paper / code and see how that performs?"
haskell,3dfcyo,rpglover64,2,Wed Jul 15 23:44:41 2015 UTC,"On the one hand, the fact that a problem is NP-complete means that there is some pathological, intractably slow example for any algorithm you use.  On the other hand, that same fact (especially if your problem is SAT or SMT) means that fast solutions for common cases are well-studied."
haskell,3ddcrw,tmnt9001,81,Wed Jul 15 11:32:25 2015 UTC,"Do you have slow iteration (complie+test+run) times?   No.   Do you find it negatively affects your productivity when the compile+test+execute cycle take longer?   Yes, it drives me nuts. I can't work like that, I'd rather spend a day making the environment fast than 2 hours with an enraging development cycle.   What are your solutions?   Use the REPL, Luke.  I do everything in the REPL. Here are some tips:   The first thing you want to do before writing anything for your project is make sure you can load your code in the REPL. Sometimes you have special configuration options or whatnot (cabal repl and stack ghci make this much easier than in the past). The sooner you start the better. It can be a PITA to load some projects that expect to just be a ""start, run and die"" process, they often launch threads without any clean-up procedure; in this way the REPL makes you think about cleaner architecture.  Learn how to make GHCi fast for your project so that you don't hit a wall as your project scales. Loading code with byte-code is much faster than object code, but loading with object code has a cache so that in a 100 module project if you only need to reload one, it'll just load one. Make sure this is happening for you, when you need it. Dabble with the settings. Code that is good for unit tests is code that is good for the REPL. Write small functions that take state as arguments (dependency injection) rather than loading their own state, then they can be ran in the REPL and used in a test suite easily. Regard functions that you can't just call directly with suspicion. While writing, test your function in the REPL with typical arguments it will expect, rather than implementing a function and then immediately using it in the place you want to ultimately use it. You can skip this for trivial ""glue"" functions, but it's helpful for non-trivial functions. Write helpful setup/teardown code for your tests and REPL code. For example, if you have a function that needs a database and application configuration to do anything, write a function that automatically and conveniently gets you a basic development config and database connection for running some action.  Make sure to include Show instances for your data types, so that you can inspect them in the REPL. Treat Show as your development instance, it's for you, don't use it for ""real"" serialization or for ""user-friendly"" messages. Develop a distaste for data structures that are hard to inspect. Use techniques like :reload to help you out. For example, if I'm working on hindent, then I will test a style with HIndent.test chrisDone ""x = 1"", for example, in the REPL, and I'll see the output pretty printed as Haskell in my Emacs REPL. But I work on module HIndent.Style.ChrisDone. So I first :load HIndent and then for future work I use :reload to reload my .ChrisDone changes and give me the HIndent environment again. Consider tricks like live reloading; if you can support it. I wrote an IRC server and I can run it in the REPL, reload the code, and update the handler function without losing any state. If you use foreign-store you can make things available, like the program's state, in an IORef or MVar. This trick is a trick, so don't use it in production. But it's about as close as we can get to Lisp-style image development. Make sure you know about the .ghci file which you can put in your ~/ and also in the project directory where GHCi is run from. You can use :set to set regular GHC options including packages and extensions.   Haskell's lucky to have a small REPL culture but you have to work with a Lisp or Smalltalk to really know what's possible when you fully ""buy in"". Many Haskellers come from C++ and ""stop program, edit file, re-run compiler, re-run whole program"" cycles and don't have much awareness or interest in it."
haskell,3ddcrw,chrisdoner,17,Wed Jul 15 12:17:59 2015 UTC,I'm really surprised by how few people seem to work with GHCi based on responses to this post.
haskell,3ddcrw,klaxion,11,Wed Jul 15 13:46:50 2015 UTC,"I think it's partly because the Yesod website still recommends using yesod devel: http://www.yesodweb.com/page/quickstart  I understand from /u/snoyberg that work is being done to make yesod devel faster, but in the meantime since reading this I've switched to using ghci and DevelMain.hs in my yesod project and my reload times immediately dropped from ~20 seconds to ~2 seconds."
haskell,3ddcrw,kyllo,2,Wed Jul 15 18:17:15 2015 UTC,It works for you? I'm having compile errors with ghc 7.8.4 and 7.10. Are you using the code from https://github.com/chrisdone/ghci-reload-demo?  Are you using specific versions of wai/warp?
haskell,3ddcrw,codygman,2,Thu Jul 16 04:06:16 2015 UTC,"I'm using ghc 7.8.4 (Stackage LTS Haskell) with recent versions of yesod-bin and its dependencies, installed with stack, on Ubuntu 14.04. Here are some version numbers:  yesod-bin 1.4.9.2  wai-3.0.2.3  wai-extra-3.0.7.1  wai-logger-2.2.4.1  warp-3.0.13.1  warp-tls-3.0.4.1  I'm using stack ghci with stack 0.1.2.0  I just cd into my yesod project dir and type:  stack ghci :l DevelMain DevelMain.update   It compiles my app and starts serving. If I make a code change I just re-enter DevelMain.update and it recompiles the changed files very quickly. It just works.  What compile errors are you getting?"
haskell,3ddcrw,kyllo,2,Thu Jul 16 05:47:25 2015 UTC,"I'm getting:  Prelude Foundation> :r [2 of 2] Compiling DevelMain        ( src/DevelMain.hs, src/DevelMain.o )  src/DevelMain.hs:25:29:     Couldn't match type ‘IO b0’                    with ‘(wai-3.0.3.0:Network.Wai.Internal.Response                           -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived)                          -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived’     Expected type: IO Application                    -> (Application -> IO b0)                    -> (wai-3.0.3.0:Network.Wai.Internal.Response                        -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived)                    -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived       Actual type: IO Application -> (Application -> IO b0) -> IO b0     In a stmt of a 'do' block: handler <- readIORef ref     In the expression:       do { handler <- readIORef ref;            handler req }     In the second argument of ‘runSettings’, namely       ‘(\ req           -> do { handler <- readIORef ref;                   handler req })’  src/DevelMain.hs:26:29:     Couldn't match expected type ‘IO b0’                 with actual type ‘(wai-3.0.3.0:Network.Wai.Internal.Response                                    -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived)                                   -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived’     Probable cause: ‘handler’ is applied to too few arguments     In a stmt of a 'do' block: handler req     In the expression:       do { handler <- readIORef ref;            handler req } Failed, modules loaded: Foundation. Prelude Foundation>    Trying to run the code from the linked repo:  https://github.com/chrisdone/ghci-reload-demo"
haskell,3ddcrw,codygman,2,Thu Jul 16 18:07:17 2015 UTC,"I've also tried creating a new site from scratch with Yesod which runs the site, but doesn't seem to update on any changes :S  Here is a link to it:  https://github.com/codygman/spawncamping-octo-cyril  EDIT: Does this method not reload templates?  EDIT: I must have forgotten to do something haskell-mode's haskell-process-reload-devel-main works fine."
haskell,3ddcrw,codygman,2,Thu Jul 16 18:09:21 2015 UTC,"Yeah it looks like that DevelMain file is incompatible with your version of wai. Using the one that comes with yesod should work.   You do need to :reload or :l DevelMain and then DevelMain.update each time, the emacs function does that for you."
haskell,3ddcrw,kyllo,2,Fri Jul 17 04:55:21 2015 UTC,"Hey, I decided to try this after seeing these threads. It works, but there is a small difference, I first need to do :reload then DevelMain.update in order to see the changes. If I just re-enter DevelMain.update, it keeps serving the old version of the page. It isn't a big deal, but am I missing something? My setup is pretty much same as yours, stack 0.1.2.0, yesod-bin 1.4.11, ghc 7.8.4."
haskell,3ddcrw,SeriousBug,3,Thu Jul 16 18:31:48 2015 UTC,"Yeah you're right, my mistake. In my actual workflow I use emacs M-x haskell-process-reload-devel-main and it looks like that calls :l DevelMain and DevelMain.update every time:  (defun haskell-process-reload-devel-main () ""Reload the module `DevelMain' and then run `DevelMain.update'. This is for doing live update of the code of servers or GUI applications. Put your development version of the program in `DevelMain', and define `update' to auto-start the program on a new thread, and use the `foreign-store' package to access the running context across :load/:reloads in GHCi.""   (interactive)   (with-current-buffer (get-buffer ""DevelMain.hs"")     (let ((session (haskell-session)))         (let ((process (haskell-process)))         (haskell-process-queue-command          process          (make-haskell-command           :state (list :session session                        :process process                        :buffer (current-buffer))           :go (lambda (state)                 (haskell-process-send-string (plist-get state ':process)                                              "":l DevelMain""))           :live (lambda (state buffer)                   (haskell-process-live-build (plist-get state ':process)                                               buffer                                               nil))           :complete (lambda (state response)                      (haskell-process-load-complete                        (plist-get state ':session)                        (plist-get state ':process)                        response                        nil                        (plist-get state ':buffer)                        (lambda (ok)                          (when ok                            (haskell-process-queue-without-filters                             (haskell-process)                             ""DevelMain.update"")                            (message ""DevelMain updated."")))))))))))"
haskell,3ddcrw,kyllo,2,Thu Jul 16 19:46:46 2015 UTC,"Ah okay, thanks a lot. I should look into setting up Emacs, then."
haskell,3ddcrw,SeriousBug,3,Thu Jul 16 20:08:46 2015 UTC,"Cool, you should check out chrisdone's emacs config for haskell, it has some handy stuff in it:  https://github.com/chrisdone/chrisdone-emacs/blob/master/config/haskell.el"
haskell,3ddcrw,kyllo,10,Thu Jul 16 23:19:40 2015 UTC,"This should be recorded somewhere more permanent. The Wiki, perhaps? These are all excellent practices. Additionally, developing libraries that work with this procedure will make your users' lives easier."
haskell,3ddcrw,conklech,6,Wed Jul 15 15:19:11 2015 UTC,For other languages (read: Python) I am really loving working with the Atom editor and the Hydrogen package. It gives you in-editor evaluation of code for any language that has a Jupyter kernel (which Haskell does). I haven't yet set up the IHaskell kernel (it seems quite an undertaking) but it's on my todo list.  https://atom.io/packages/hydrogen  In-editor evaluation beats working with the REPL any day. Hopefully it'll be easier to use soon. Maybe stack can help :)
haskell,3ddcrw,radix,3,Wed Jul 15 17:04:39 2015 UTC,"Amazing, thank you."
haskell,3ddcrw,WarDaft,2,Wed Jul 15 15:31:03 2015 UTC,Using ghcid with -fobject-code is good stuff. Instant type feedback on saves even if you're literally just using Notepad.
haskell,3ddcrw,Peaker,5,Wed Jul 15 16:39:25 2015 UTC,"But that feedback requires manually feeding the filename/line number back to your editor. I just press a key in my emacs and chrisdone type-checks my file very quickly (by proxy, of course), while also generating useful information that lets me directly jump to errors, jump to the definitions of stuff, etc."
haskell,3ddcrw,chrisdoner,11,Wed Jul 15 17:06:28 2015 UTC,"Peaker's telling the truth, I sit next to him and check his files. Unification with pencil and paper."
haskell,3ddcrw,eriksensei,3,Wed Jul 15 18:17:36 2015 UTC,That doen't sound particularly scalable.
haskell,3ddcrw,WarDaft,3,Thu Jul 16 00:46:48 2015 UTC,"I tile a narrow ghcid window beside my editor, it's not a very fancy setup. The point is, forall editors x, there are people who do not like x. ghcid doesn't actually integrate with any editor at all, and so can be used with every local editor. Convincing people to switch editors for a feature is distilled frustration. Saying ""this will work with basically anything you want it to, and make your life easier without any additional cognitive overhead"" is much easier."
haskell,3ddcrw,Roboguy2,2,Thu Jul 16 20:57:48 2015 UTC,Do you mean -fno-code? -fobject-code would make it take longer to compile. I don't think you need -fno-code with ghcid though.
haskell,3ddcrw,WarDaft,2,Thu Jul 16 05:52:00 2015 UTC,"I do not. -fobject-code trades a linear factor for a constant (ish) factor. It'll be slower on small projects where it's so fast that it won't make a difference, and faster on large projects where it's slow enough to make a difference."
haskell,3ddcrw,Roboguy2,1 point,Thu Jul 16 20:54:55 2015 UTC,"Oh, you're talking about program runtime speed, not type checking/compilation speed? I was thinking you meant for compilation speed and faster type checking."
haskell,3ddcrw,tomejaguar,2,Thu Jul 16 23:13:34 2015 UTC,"No, I'm pretty sure WarDaft means compilation speed.  If you use -fobject-code it compiles the the first time but uses them from the cache subsequently, so it's faster for larger projects (or so I am led to believe)."
haskell,3ddcrw,WarDaft,1 point,Fri Jul 17 14:07:05 2015 UTC,"See point 2 in chrisdone's comment, the link explains things."
haskell,3ddcrw,hagda,2,Sat Jul 18 04:30:14 2015 UTC,You should turn this into a full-blown blog post...
haskell,3ddcrw,dukerutledge,2,Wed Jul 15 20:00:19 2015 UTC,"-fobject-code is totally key when working with a large library or executable. Though in general you should try to limit the size of your projects, break them in to sub projects where possible and relevant, this will greatly improve compilation time."
haskell,3ddcrw,codygman,1 point,Thu Jul 16 04:53:58 2015 UTC,"Is this compatible with ghc 7.8.4? I'm getting a type error:  Prelude> :l src/DevelMain.hs [2 of 2] Compiling DevelMain        ( src/DevelMain.hs, src/DevelMain.o ) [flags changed]  src/DevelMain.hs:25:29:     Couldn't match type ‘IO b0’                   with ‘(wai-3.0.3.0:Network.Wai.Internal.Response                          -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived)                         -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived’     Expected type: IO Application                    -> (Application -> IO b0)                    -> (wai-3.0.3.0:Network.Wai.Internal.Response                        -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived)                    -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived       Actual type: IO Application -> (Application -> IO b0) -> IO b0     In a stmt of a 'do' block: handler <- readIORef ref     In the expression:       do { handler <- readIORef ref;            handler req }     In the second argument of ‘runSettings’, namely       ‘(\ req           -> do { handler <- readIORef ref;                   handler req })’  src/DevelMain.hs:26:29:     Couldn't match expected type ‘IO b0’                 with actual type ‘(wai-3.0.3.0:Network.Wai.Internal.Response                                    -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived)                                   -> IO wai-3.0.3.0:Network.Wai.Internal.ResponseReceived’     Probable cause: ‘handler’ is applied to too few arguments     In a stmt of a 'do' block: handler req     In the expression:       do { handler <- readIORef ref;            handler req } Failed, modules loaded: Foundation.   EDIT: Not trying to be lazy, just only had about 5 minutes before dinner to spare debugging this. EDIT: Tried on GHC 7.10 as well and it didn't work. I got it to compile a few different ways... but then it didn't actually do anything :S  It seems that handler should be of type Request -> Application but is type of Application. I'm a bit fuzzy with how to do all of this so having trouble figuring out how to fix it."
haskell,3ddcrw,itsuart2,8,Thu Jul 16 00:23:48 2015 UTC,"Yes. I start new/continue on old C project, where I bang out a ton of code without much thinking, enjoy fast compilation times and curse crashes/hangs/memory corruption. Few days after I get fed up with this and return back to Haskell with love levels at 11. Compiling is slower but debugging is nearly non existent. They cancel each other. See #2. Also SSDs, few gigs of RAM and fast CPU."
haskell,3ddcrw,mallai,8,Wed Jul 15 12:26:54 2015 UTC,"cabal configure --disable-optimization cuts the build time by 50%.  Use a shared sandbox with Haskell LTS or Stackage nightly to avoid rebuilding the same deps. all the time.  Use an editor which works with ghc-modi. For example, with Atom and ide-haskell plugins, every time you save you get instant incremental recompilation and errors/warnings highlighted in the editor instantly (together with types showing on mouse hoover). Another alternative for the same is ghcid, which reloads GHCi on each save.  Finally, use doctests - it's like having a permanent GHCi session ready inside your code which is automatically run. I recently started using that and it's fantastic!"
haskell,3ddcrw,sclv,4,Wed Jul 15 14:04:46 2015 UTC,"Like everyone else says, I use ghci.  Essentially when working on a unit of functionality I bang out some code, then load it up in ghci. A bunch of type errors come up. I fix them and hit :r. Then a bunch of type errors come up, and I fix them and hit :r.  And soforth.  Eventually there are no type errors. I then exercise my code a bit, until I am satisfied, then I consider that portion of functionality ""done"", start work on the next, lather, rinse, repeat.  When the whole thing fits together, of course things are harder. I find that ghc's incremental builds are really not bad here unless I am changing something very near the root of the dependency tree in a significant (i.e. ~200 module) project.  In any case, by the time I get something compiling, I find I need to do very little ""look and feel"" iteration, and if that look and feel code is near the final edge of the dependency tree, rebuilds can be fast.  The worst/slowest part of builds of significant projects are all about the linker, but that is largely out of the hands of the GHC dev team -- although there are reports when people have gotten things working with the gold linker on occasion, it improves things massively."
haskell,3ddcrw,edwardkmett,3,Wed Jul 15 22:00:55 2015 UTC,"1.) Not really.  2.) I hack up cabal a little bit to disable the building of profiling builds and tell it not to build documentation by default. This rather dramatically cuts my build times. After that builds are typically on the order of seconds for me. Factoring my code so that I don't have things that change a lot in big common modules upstream that would force lots of rebuilding helps a great deal as well, but that is just basic software engineering.  3.) Definitely."
haskell,3ddcrw,tel,5,Thu Jul 16 18:49:00 2015 UTC,"For anything which can be reflected in types: no, it has near instantaneous iteration speeds. If you can take advantage of this well then it will change everything."
haskell,3ddcrw,kqr,5,Wed Jul 15 12:35:05 2015 UTC,"My Haskell iteration cycles are faster than my Python iteration cycles, at least. I don't know whether Python counts as fast or slow. Compilation sometimes takes longer with Haskell (obviously, since Python barely gets compiled), but run times and test times are so much quicker. A full, optimised build is significantly slower, but I generally don't do those when I'm working. I work on parts of applications in isolation, either as executables or in the REPL. Since I design my application as just a thin wrapper around ""library style"" code, I can make many of those thin wrappers for different parts of my application as I'm writing it. After a few days of working on an application I might have made 15 different executables, each one for a very specific view in my application. I throw them away when I'm done, but they're useful for testing things in isolation. Yes, and it's not even a linear relationship with the non-interactive parts. A non-interactive cycle that takes twice as long might make me lose four times the productivity, because when I know it's going to take a while I tab over to check my email or whatever while it does its thing. Bringing down the waiting time is essential for me. Isn't this just question #2 with different words?"
haskell,3ddcrw,Alyte,3,Wed Jul 15 13:10:24 2015 UTC,"Isn't this just question #2 with different words?   Yes. But people seem to be giving different answers to both, which is nice."
haskell,3ddcrw,robertmeta,2,Wed Jul 15 15:30:18 2015 UTC,"Not really saying anything new here, but...GHCi. It's great. It takes a few sec to start, but after that it's surprisingly fast for what it is and most of the time it just works. My iteration times are on par or perhaps even better than when scripting Lua (:r vs. lua -opts file), which I'd say is pretty damn good. Disclaimer: I've never had any huge projects, so it might be anywhere from a little slower to a lot slower to load something big in GHCi, but either way I'm sure it's a big improvement over an entire recompilation."
haskell,3ddcrw,nicheComicsProject,2,Wed Jul 15 15:26:50 2015 UTC,"Yep.  I weep quietly, buy better hardware, overclock, water cool.  Weep marginally less.  Absolutely and horrifically."
haskell,3ddcrw,ForTheFunctionGod,2,Wed Jul 15 17:51:53 2015 UTC,I don't have slow iteration times. I use eclipseFP and compile as I go. I get instant feed back for type errors so I feel like the cycle time is probably faster in Haskell than any other language once you get going.
haskell,3ddcrw,Crandom,3,Wed Jul 15 18:37:22 2015 UTC,"Do you have slow iteration (compile+test+run) times?   The compile times are OK, especially when compared to Scala. Dear Christ, Scala... my gut tenses up every time I think about it. It used to take 30 seconds on a Linux machine to compile a single, 5-module package - with the zinc server and everything. The experience's frustrating nature was only compounded by the atrocious type-checker's proclivity to spit out spurious errors.  Debugging is another issue. ghci's CLI is crude an inconvenient when used for interactive debugging. IDE-style graphical inspection and breakpoints in the code would be a significant productivity boost.   How do you deal with that?   I write many modules and many small functions that are individually testable.   Do you find it negatively affects your productivity when the compile+test+execute cycle take longer?   The unavailability of graphical debugging does, but its manageable.   What are your solutions?   Testing functions in the REPL."
haskell,3ddcrw,Alyte,2,Wed Jul 15 13:30:19 2015 UTC,"For me, Haskell has super fast iteration times, in that you get compile errors (or red underlining in your IDE) for stuff that would be test failures in other languages. The compile times do not seem that bad compared to other languages, but I've never made a massive application, only mid-sized ones (and I've had to use Scala before).  Yesod has known perf problems that are being worked on, but that's yesod-specific.  Edit: Also, I do a lot of my work (including running tests) through GHCi, which loads modules ridiculously fast making it a non-issue."
haskell,3ddcrw,Peaker,2,Wed Jul 15 11:59:48 2015 UTC,Sorry nobody ever told you about GHCi. Better luck next time perhaps?
haskell,3ddcrw,Peaker,2,Wed Jul 15 12:55:32 2015 UTC,"I've been using it for the last 6 months or so, and it's boosted my productivity and fun in Haskell greatly.  Before that, I could have tried out OCaml, I was really frustrated with the build times of my growing projects.  However, just reading OCaml tutorials (< vs <., wuuut?) makes me sad."
haskell,3ddcrw,Peaker,4,Wed Jul 15 15:22:49 2015 UTC,"Impurity of OCaml is also ugly. The ""object system"" seems like a useless complication. The syntax is ugly.  The ""value restriction"" makes simple things like generic function composition hard (which is, afaik, the reason OCaml doesn't even have a standard operator for function composition in its libraries).  Haskell has big problems, but I just couldn't go back to impure, no-type-class type system with a ""value restriction"" after having experienced Haskell..."
haskell,3ddcrw,Peaker,2,Wed Jul 15 16:04:30 2015 UTC,When is the object system useful? Prominent OCaml users basically tell you to ignore it.  Value restriction makes function composition monomorphize unnecessarily.  Modules are very useful when programming in the large. But type classes are very useful in the small. I can't program in the large if I can't program in the small..
haskell,3ddcrw,Alyte,3,Wed Jul 15 17:08:48 2015 UTC,"All the time, that's why it is used all the time.   According to ""Real World OCaml"":   In fact, many seasoned OCaml programmers rarely use classes and objects, if at all.   And according to people I've talked to IRL, ""use OCaml but ignore the object system"".  The open-recursion it is used for seems very rarely useful, and may as well use ordinary fix-points for that.   What problem does this cause as a programmer?   You have to eta expand everything.   Nobody else has a problem programming in the small.   How can you tell? Many of us who had a problem programming in the small just use Haskell."
haskell,3ddcrw,sclv,2,Wed Jul 15 23:15:11 2015 UTC,"What 'special code' are you talking about? And if, for anybody, build times are big enough of an issue to switch languages I'm sure they'd stumble upon whatever they could be doing to speed up build times after some googling. As for Chris's work (I'm guessing you mean /u/chrisdoner), most of that should be common knowledge, or at least for relatively new Haskellers coming from Real World Haskell/Learn You a Haskell.  Whatever the case, with such a radical ""fix"" (switching languages entirely), whether or not you were joking, that's a lot of work and I'm confident learning a little about GHCi is a better solution, even if it's a bit tedious to get it working smoothly."
haskell,3ddcrw,sclv,1 point,Wed Jul 15 23:24:14 2015 UTC,You only need it for yesod.
haskell,3de4gp,phadej,4,Wed Jul 15 15:42:38 2015 UTC,We had a conversation about Haskell being encrypted by large amount of weird infix operators. I tried to list them all (which are in base package). There aren't that many after all!  Omitted numerical ones and Text.ParserCombinators.ReadP though.
haskell,3de4gp,Peaker,3,Wed Jul 15 15:44:43 2015 UTC,"Fortunately for your point, Control.Lens.Operators is not in base :)"
haskell,3de4gp,bheklilr,3,Thu Jul 16 20:45:33 2015 UTC,I actually want to use this for when I'm playing around in GHCi... Are all of the extra typeclasses like Arrow and Category exported as well?
haskell,3de4gp,RyanGlScott,10,Wed Jul 15 16:38:15 2015 UTC,"You may be interested in base-prelude, which attempts to export as many things from base as possible (without introducing conflicts)."
haskell,3de4gp,bheklilr,2,Wed Jul 15 17:00:30 2015 UTC,"Only operators. Otherwise this could be actually usable, not only for documentation purposes."
haskell,3dfe6v,elbiot,1 point,Wed Jul 15 21:01:37 2015 UTC,"ctypes is pretty old and busted, and Python's cffi is the new hotness (and actually much better in many ways); maybe that's relevant, maybe not. Have you tried this? https://github.com/nh2/call-haskell-from-anything - commits as of May I also see a HaPy-ffi library that seems to be pip-installable - released as of late last year   I seem to recall hearing news about Python/Haskell interop pretty recently but I'm not really sure where. Maybe some of these references can help you."
haskell,3dfe6v,radix,1 point,Thu Jul 16 06:00:02 2015 UTC,"Thanks.  I know about haskell from anywhere, but my interest is in performance, and serializing numpy arrays is the slowest damn thing ever.  Numpy already provides statically typed, efficient data structures that can be passed with pointers to and from other c libraries, so converting that to a string and back makes haskell a toy.  I'll look at the other ideas you posted though.  Thanks."
haskell,3dfe6v,singularai,2,Thu Jul 16 06:11:55 2015 UTC,"HaPy is the best way to call haskell from python. If you want to go the other way, look into pyfi (I wrote it though so slightly biased).  https://github.com/Russell91/pyfi"
haskell,3dcidp,NiftyIon,18,Wed Jul 15 04:58:38 2015 UTC,Classic.
haskell,3dcidp,Ramin_HAL9001,8,Wed Jul 15 06:11:00 2015 UTC,"I've been wondering about this for a while: the PhD version is obviously fugly, because why would we use built-in algebraic data types, when we can define I, K, sum and product as in McBride's Clowns and Jokers and get functor instances for free? Brilliant, but the problem is that we don't get functor instances for stuff like:  type List a = Fix (One :+: (Const a :*: Id))   Well, we can graduate to bifunctors and get functor instances for free, but aww, then we'll miss out on bifunctor instances, so it looks like turtles all the way down. I wonder whether there's some clever trick to work around that? The end result would be utterly impractical I'm sure, but it's interesting from theoretical standpoint."
haskell,3dcidp,pbl64k,12,Wed Jul 15 08:58:26 2015 UTC,"1, 2, 4, 8, time to exponentiate! Slicing It"
haskell,3dcidp,pigworker,1 point,Wed Jul 15 11:16:35 2015 UTC,"Thank you, much appreciated. I'll need time... to... digest that."
haskell,3dcidp,pbl64k,3,Wed Jul 15 11:35:39 2015 UTC,fac  0    =  1 fac (n+1) = (n+1) * fac n   Is this an old syntax? I seem to remember Wadler saying something about it.
haskell,3dcidp,D_duck,15,Wed Jul 15 07:29:41 2015 UTC,It uses deprecated (n+k) patterns that were originally put into the language for analogy with mathematical definitions. They were removed because they were clunky syntactic sugar.  https://ghc.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
haskell,3dcidp,ForTheFunctionGod,12,Wed Jul 15 07:44:36 2015 UTC,"Yes. This is called an ""n + k"" patterns. It is deprecated.  The idea behind it was that it matched the way induction is done over the natural numbers. (data Nat = Z | S Nat). Writing functions in this way is, in principle, good practice. Something like factorial becomes:  factorial :: Nat -> Nat factorial Z = 1 factorial (S n) = (S n) * factorial n   Notably, you do not need to perform subtraction on the argument, and so it's more obvious that the function is structurally recursive. The function can't get stuck in an infinite loop for the simple reason that each recursive call strips off an S constructor, and each Nat can only have so many before they run out.  That said, they were removed from Haskell (or deprecated?) because they are essentially a hack to make it look like that's what's going on. It is the only time, as far as I know, where a (non-constructor) function can appear in a pattern. They also fail to serve their purpose related to ""obvious termination"", as the above definition will still get into an infinite loop when you call fac (-1)."
haskell,3dcidp,tactics,4,Wed Jul 15 07:51:09 2015 UTC,"It is deprecated.   No, it is not:  Prelude> :set -XDatatypeContexts  <no location info>: Warning:     -XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language   Prelude> :set -XNPlusKPatterns  -- everything is fine"
haskell,3dcidp,dtellerulam,7,Wed Jul 15 09:57:33 2015 UTC,"It's not deprecated in the same way DatatypeContexts is.  Rather, n+k patterns were formerly standard Haskell; see section 3 of the Haskell 98 Report. They're now downgraded to a language extension that must be explicitly turned on.  They're informally deprecated in that when you use them people will make comments on Reddit saying that they're old syntax and shouldn't be used."
haskell,3dcidp,conklech,7,Wed Jul 15 15:28:35 2015 UTC,"Huh. I get the same thing, but sources, along with other comments, seem to indicate that they really are deprecated. A ""bug"" in GHC's warnings, perhaps?"
haskell,3dcidp,danielsmw,4,Wed Jul 15 11:06:39 2015 UTC,"Hey u/EyeBleachBot, it seems you looked inside a URL for the ""NSFL"" string, and it was inappropriate in context... maybe a bug? You should probably look for white space around ""NSFL"" for positive identification.  Edit: Awesome pic though.  Edit 2: I guess you want to look for ""non-word characters"" rather than whitespace, really."
haskell,3dcidp,danielsmw,4,Wed Jul 15 11:06:59 2015 UTC,Thanks partna!   For your troubles
haskell,3dcidp,EyeBleachBot,3,Wed Jul 15 11:08:56 2015 UTC,Won't product [1..n] lead to a space leak?
haskell,3dcidp,ForTheFunctionGod,8,Wed Jul 15 12:47:16 2015 UTC,"It has linear space usage in theory, but in practice the list will probably be garbage collected.  If you don't want an intermediate structure, you can use Data.Vector:  product (enumFromN 1 n).  The vector will be eliminated by stream fusion."
haskell,3dcidp,kuribas,5,Wed Jul 15 07:55:00 2015 UTC,"How hard is it to avoid the intermediate structure in product [1..n]?  Using the techniques from the paper ""from lists to streams to nothing at all"", it's easy. Too bad you have to explicitly opt in for that better behavior everywhere manually."
haskell,3dcidp,Peaker,1 point,Wed Jul 15 09:45:56 2015 UTC,"No, why would it?"
haskell,3dcidp,gelisam,3,Wed Jul 15 10:25:04 2015 UTC,"Because product is defined in terms of foldl which builds up thunks because it is lazy in its accumulating parameter.  It won't cause a space leak; it also doesn't seem to cause a stack overflow like sum does, but that's because it gets really slow for larger numbers."
haskell,3dcidp,rpglover64,6,Wed Jul 15 10:46:32 2015 UTC,"ghc is able to optimize that. For   product = foldl (*) 1   here's the core it generates:  Rec { $wlgo [Occ=LoopBreaker] :: Int# -> [Int] -> Int# [GblId, Arity=2, Caf=NoCafRefs, Str=DmdType <L,U><S,1*U>] $wlgo =   \ (ww :: Int#) (w :: [Int]) ->     case w of _ [Occ=Dead] {       [] -> ww;       : x xs -> case x of _ [Occ=Dead] { I# y -> $wlgo (*# ww y) xs }     } end Rec }   As you can see, it uses a strict, unboxed accumulator."
haskell,3dcidp,roche,4,Wed Jul 15 12:47:47 2015 UTC,"According to the source, it's implemented using foldr:  foldMap = foldr (mappend . f) mempty product = getProduct #. foldMap Product   According to my knowledge, foldr is only tail-recursive if the folding function is a data constructor (e.g. (:)) - hence my question."
haskell,3dcidp,ForTheFunctionGod,7,Wed Jul 15 22:38:48 2015 UTC,"That's the default implementation for Foldable, not the actual implementation for lists. The actual one is in terms of foldl, which is in turn implemented via foldr, to enable foldr/build fusion."
haskell,3dcidp,AndrasKovacs,2,Wed Jul 15 13:20:24 2015 UTC,"I don't get it - is this funny because this is really scary. I have just started programming in Haskell and I don't think that I will evolve (or will want) to anyone beyond ""interpretive"" guy. Even the assembly code is easier to read and probably write. Why would anyone go down there so deep? Is there some advantage in writing such codes?"
haskell,3dcidp,swarmparticle,3,Wed Jul 15 14:36:37 2015 UTC,"I think it depends what you want to get out of Haskell.   If like me you want to write simple programs that are maintainable then readability and sometimes performance will be the main concerns.  So I would go for  fac n = product [1..n]   My philosophy is keep it simple and avoid explicit recursion unless you really have to do it. Use built ins like product, or failing that, foldl' or foldr. Any answer > 1 line for this I wouldn't do but may look at for curiosity or educational interest."
haskell,3dcidp,mcapodici,3,Fri Jul 17 01:56:08 2015 UTC,"it's like readability-performance tradeoff is underlying every language.. one cannot remove it as though it was quantum uncertainty in position and momentum  (I am generalizing though, I just know some python)"
haskell,3dcidp,swarmparticle,3,Fri Jul 17 05:01:01 2015 UTC,"I felt exactly the same way six years ago. Turns out, this crazy stuff is all about some very deep patterns important both for implementation of programming languages and for reasoning about programs. And while it's highly unlikely you'll ever write anything quite as strange as that in production code, one day you might find yourself reading through that joke page -- or the papers that inspired it -- simply because you'll want to know more, because you'll want to better understand the fundamental math underlying our trade.  That's been my experience so far, anyway, and I'm quite glad it worked out that way."
haskell,3dcidp,pbl64k,2,Fri Jul 17 20:56:00 2015 UTC,Hopefully I'll  get the joke in some time.. years maybe ;)
haskell,3dcidp,swarmparticle,1 point,Fri Jul 17 11:14:30 2015 UTC,The continuation passing one sort of made my day.  Super rad.
haskell,3dcidp,skatenerd,1 point,Fri Jul 17 20:50:15 2015 UTC,See the very bottom of the page for the Evolution of the Evolution of a Haskell Programmer.
haskell,3ddjo0,andrewthad,6,Wed Jul 15 12:48:47 2015 UTC,"ReadS returns a list of possible parses of the string, along with any leftover part of the string. readMaybe requires the whole string to be consumed. So, readsMaybe should pick a parse with no leftover value.  readsMaybe :: ReadS a -> String -> Maybe a readsMaybe f s = case filter (null . snd) (f s) of         ((a, _):_) -> Just a         _ -> Nothing"
haskell,3ddjo0,joeyh,1 point,Wed Jul 15 14:02:52 2015 UTC,Well that was just awesome. I had looked around at the implementation of some of the function in Text.Read and did not realize it would be that simple. Now added to my collection of random helper functions.
haskell,3ddjo0,mightybyte,4,Wed Jul 15 14:24:10 2015 UTC,"I created the readable package precisely to unify this stuff.  It is built around the parsing functions in text and provides both a Text and ByteString interface.  If you want more convenient conversion from other string types, I'd recommend using the string-conv package."
haskell,3ddjo0,hagda,2,Wed Jul 15 17:15:20 2015 UTC,How efficient/performant is readable compared to e.g bytestring-lexing?
haskell,3ddjo0,mightybyte,3,Thu Jul 16 07:25:43 2015 UTC,I haven't benchmarked it.  I assumed the parsing functions from text would be respectable.  I'd certainly be open to a pull request switching if it was accompanied with a benchmark showing the performance difference.
haskell,3ddjo0,gclichtenberg,2,Thu Jul 16 13:41:49 2015 UTC,What's the rationale for this? https://github.com/mightybyte/readable/blob/master/src/Data/Readable.hs#L73-L85
haskell,3ddjo0,mightybyte,2,Fri Jul 17 00:33:27 2015 UTC,"It's something I've wanted multiple times.  There doesn't seem to be a single pair that is obviously canonical.  I also can't recall a situation where I wanted to parse one particular pair (say t/f) but fail on the others.  If you do want a function like that, it will be easier to write than the one here, so it seemed to me that this one provides the most benefit to users."
haskell,3ddjo0,yitz,1 point,Fri Jul 17 04:49:57 2015 UTC,Thats pretty handy. You learn something new every day.
haskell,3de47y,ThreeFreeTrees,5,Wed Jul 15 15:40:45 2015 UTC,"This is just to make it a more general function, yes.  You don't always need to be as general as possible, even with numeric types.  In some cases it can help you to leave the function very generalized, even in your own code, because then it composes with potentially more functions, and it can't make it compose with fewer functions.  However, I wouldn't say it's common practice to make every numeric argument or return type as general as possible, you end up just spending an unnecessary amount of time and effort for not much gain.  Generally if you see something like  f :: [a] -> [b] f = map someFunc   Then you can easily abstract this to work with functors:  f :: Functor f => f a -> f b f = fmap someFunc   This is a simple and contrived example, of course, but the idea is that if you see map being used, instead use fmap.  Similarly if you see a code block like  doSomething :: (Int -> Maybe Int) -> [Int] -> Maybe Int doSomething f vals = do     results <- Control.Monad.mapM f vals     return $ sum results   Then you should generalize this function to be  doSomething :: (Monad m, Traversable t) => (Int -> m Int) -> t Int -> m Int doSomething f vals = do     results <- Data.Traversable.mapM f vals     return $ Data.Foldable.sum results   because this can now b used for all sorts of data structures, it is much more general than before.  It's especially handy to already have code written like this (although without the pesky fully qualified imports) in case you do end up changing an underlying data structure, something which has happened to me quite a lot in Haskell.  This makes refactoring much simpler."
haskell,3de47y,bheklilr,2,Wed Jul 15 16:35:02 2015 UTC,"While it can compose with more functions, it can't always do so automatically. Consider print . toEnum. Type checks fine. Produces a run-time error for all input."
haskell,3de47y,WarDaft,2,Wed Jul 15 17:02:29 2015 UTC,(print . toEnum) 0 works.
haskell,3de47y,htebalaka,1 point,Wed Jul 15 18:10:47 2015 UTC,"Thanks, that was very helpful :)"
haskell,3de47y,andrewthad,2,Wed Jul 15 20:12:22 2015 UTC,"In code that I personally write, I never write any functions with Integral or Num constraints. I basically use Int, Double, and sometimes Rational. Making functions more polymorphic than they need to be can make things harder to read and can cause type errors when GHC can't decide a type (although for numeric types, there are some defaulting rules, which helps)."
haskell,3dczvo,anler,4,Wed Jul 15 08:33:40 2015 UTC,You can express foldl in terms of foldr.
haskell,3dczvo,augustss,2,Wed Jul 15 10:32:18 2015 UTC,You could have a read of this paper on folds by Graham Hutton.
haskell,3dczvo,jaybee,1 point,Wed Jul 15 15:42:18 2015 UTC,"I'll take a look, thanks!"
haskell,3dczvo,SrPeixinho,1 point,Thu Jul 16 13:53:26 2015 UTC,"Thank you! I already seen that, I also read that in strict-order of evaluation you can implement foldr as a foldl, that's why I was trying to see if ""in the essence"" both abstractions are the same... but so far they're not. I need to read the paper by Graham Hutton to clear my mind further."
haskell,3dcnge,komplete,13,Wed Jul 15 05:53:44 2015 UTC,"https://www.reddit.com/r/haskell/comments/3bqy5h/survey_which_haskell_development_tools_are_you/  TLDR, Emacs+haskell-mode is one of the most popular and mature solutions for editing Haskell code  PS: See also https://www.reddit.com/r/haskell/comments/3c5383/development_tools_survey_results/"
haskell,3dcnge,hagda,8,Wed Jul 15 07:18:11 2015 UTC,I use spacemacs and haskell-mode works after adding it to your layers in your .spacemacs file.
haskell,3dcnge,codygman,5,Wed Jul 15 07:10:38 2015 UTC,"I started with a very involved vim setup, then moved to a very involved emacs setup, and I moved to spacemacs the other day.  It's fantastic.  Great documentation, very sensible defaults, a nice help system.  I already had the various tools installed with cabal, so adding haskell support involved:   pressing SPC f e d adding ""haskell"" to the list of layers pressing SPC f e R   I've since added a variable to customize hindent, but that's about it.  I do Scala at work, that layer worked out of the box with something similar, as did git (magit is great), org (also great) and markdown.   Now I just need to write a layer for Proof General and company-coq..."
haskell,3dcnge,dalaing,1 point,Wed Jul 15 08:12:23 2015 UTC,"It works. And that's great. But it does not deliver the best IDE'ish experience currently possible. As AFAIK it lacks integration with one of hsdevtools, ghc-mod, ide-backend or stack-ide. On top of that I think that structured-haskell-mode on spacemacs is broken.  Writing Haskell, being strongly typed, can be greatly supported with IDE'ish tooling; a default spacemacs only delivers a small part of that.  Edit: according to reply it does work fine with ghc-mod. I should try it again I guess. Sorry for the misinfo."
haskell,3dcnge,cies010,3,Wed Jul 15 10:34:12 2015 UTC,It works fine with ghc-mod.
haskell,3dcnge,dalaing,1 point,Wed Jul 15 11:38:37 2015 UTC,"Emacs has the best support for all the editor tools. Vim is currently lacking IDE backend, but I hope to fix that soon"
haskell,3dcnge,ephrion,8,Wed Jul 15 18:29:27 2015 UTC,I want to mention that a few libraries are easier to install on unix-like systems
haskell,3dcnge,dramforever,3,Wed Jul 15 07:38:24 2015 UTC,I admit to feeling like I'm in a minority group for using haskell on windows.
haskell,3dcnge,_AndrewC_,4,Wed Jul 15 08:06:14 2015 UTC,"No bad vibes intended, but you probably are. Most haskellers I've met are using a linux distro."
haskell,3dcnge,andrewthad,3,Wed Jul 15 12:53:10 2015 UTC,"I'm doing so. There are a few others. The popularity of OSX among the, uh, creative industries has led to a sudden dominance of POSIX-type systems even in traditional Windows bastions.  MSYS2 and stack are making things a lot easier."
haskell,3dcnge,conklech,7,Wed Jul 15 15:38:46 2015 UTC,"It'd be really great if someone wrote a tutorial about using Haskell from zero. Talking about where to get Haskell and how to install it, how to use stack to build, create and test programs and libs, and how to install an editor like spacemacs for Haskell."
haskell,3dcnge,gilmi,8,Wed Jul 15 07:46:27 2015 UTC,"I was actually intending to do so. But I found that a Haskell's tooling is a bit in a transitional stage. Stack seems like something beginnners really want to start of with. Proper IDE'ish features in the editor also really help newcomers. The stack-ide package should help with that, bringing IDE features in a Stack environment. But stack-ide currently needs GHC 7.10, which is not yet in an LTS release on Stackage (it is used for nightly builds though).  Currently stack-ide (a ""backend"") is used by the stack-mode package for Emacs, and both of these packages are fairly young. I also argue that Emacs is not something that should be a mandatory thing to learn in order to get into Haskell, as it comes with quite a learning curve of it's own.  Editors that have proven to be more beginner friendly are, imho, Atom and SublimeText. Atom has IDE'ish features though the not-Stack-aware ghc-mod backend. Sublime has the stack-ide-sublime package. This package is young (17 days old at this point), but seems to work well.  TL;DR: In this transitional stage of Haskell tooling it is hard to pick beginner friendly tools. If I'd have to research a simple way to get an editor with IDE'ish features up and running for a newcomer I'd look into Sublime + Stack + stack-ide-sublime. It is quite a young set of tools, but likely to mature quickly."
haskell,3dcnge,cies010,1 point,Wed Jul 15 10:54:45 2015 UTC,"This is on my list. I have a few ""0 to"" videos I'm trying to create."
haskell,3dcnge,codygman,1 point,Wed Jul 15 15:18:03 2015 UTC,"The Haskell Wikibook already starts from absolute zero, no programming experience expected."
haskell,3dcnge,wolftune,1 point,Wed Jul 15 15:20:24 2015 UTC,"unfortunately it does not cover how to (use stack) to create, build and test programs and libs, and how to install and configure an editor."
haskell,3dcnge,gilmi,1 point,Wed Jul 15 17:41:59 2015 UTC,stack is only weeks old! and it's a WIKIbook… we can quickly go ahead and add that information to it! Let's do it!
haskell,3dcnge,wolftune,-11,Wed Jul 15 18:40:39 2015 UTC,"This is wrong in so many levels. Please, use Vim instead.  http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/  http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/"
haskell,3dcnge,oik3htio213h,1 point,Wed Jul 15 09:15:32 2015 UTC,I have learned vim and used it for 8+ years. What's wrong with spacemacs?
haskell,3dcnge,codygman,1 point,Wed Jul 15 15:20:43 2015 UTC,"When I notice haskell community supports emacs, https://www.youtube.com/watch?v=siwpn14IE7E"
haskell,3dcnge,oik3htio213h,2,Sun Jul 19 18:48:35 2015 UTC,I don't follow. What are you trying to say?
haskell,3dcnge,codygman,3,Sun Jul 19 18:52:15 2015 UTC,Can the mods put links to earlier discussions of this frequently asked question in the sidebar please?
haskell,3dcnge,jaybee,4,Wed Jul 15 09:59:07 2015 UTC,Since the situation changes so fast the information of discussion tend to go off the expiry date really quick.
haskell,3dcnge,cies010,1 point,Wed Jul 15 14:25:33 2015 UTC,"Agreed, but I was just thinking of linking to the most recent discussions on tools, what to do after you learned the basics, etc."
haskell,3dcnge,jaybee,3,Wed Jul 15 15:43:35 2015 UTC,"Haskell tooling is a wasteland. A lot of people swear by Atom + plugins, or highly customized Vim environments.  Good luck!"
haskell,3dcnge,PM_ME_UR_OBSIDIAN,8,Wed Jul 15 06:06:53 2015 UTC,"Haskell tooling is a wasteland   Given the amount of hard work that I see being put into tooling lately (stack, ide-backend, stack-ide, ghci-ng, etc.), I prefer to call it a ""transitional stage"" instead of a wasteland."
haskell,3dcnge,cies010,3,Wed Jul 15 10:57:13 2015 UTC,"I got that impression from having played around with it so far! For the time being, I'm going to try and get a Vim environment up and running with it (on Windows).  Later this week, I think I'll repeat the process with a Linux VM, and compare the two.  Atom looks really interesting, I'll give it a shot if it has a Vim key bindings plugin (something similar to VsVim for Visual Studio)."
haskell,3dcnge,merijnv,2,Wed Jul 15 06:12:27 2015 UTC,"highly customized Vim environments.   tbh, I don't really use haskell specific plugins, the only thing I use for haskell is syntastic (not haskell specific error/warning highlighting), which uses hdevtools to do on the fly checking of compilation."
haskell,3dcnge,danielsmw,2,Wed Jul 15 09:54:56 2015 UTC,"Same here. For now, at least, it's really just easiest to have vim open in one terminal and ghci open in the other."
haskell,3dcnge,5outh,2,Wed Jul 15 11:12:04 2015 UTC,Atom + plugins is pretty easy to set up. That's my preferred way of doing things as someone who isn't hardcore enough for vim/emacs (yet) :P
haskell,3dcnge,sbergot,1 point,Wed Jul 15 10:15:08 2015 UTC,"I am trying a few things at the moment to prepare a presentation in my shop.   custom emacs works very well, but requires some learning for people who are not familiar with it emacs spacemacs works well and is easy to setup. But when I add the autocompletion layer, it hangs when I open a file without giving me an error message haskforce seems broken with cabal 1.22 (https://github.com/carymrobbins/intellij-haskforce/issues/124) eclipsefp has been discontinued after a few minutes using leksah, it seems that a lot of effort has been put into this project, and it looks mostly usable to me (I did not try it on big projects) fpcomplete works really well but is a webapp   That said, a lot of haskell devs are using emacs. It is likely the most stable ""ide"". With other tools, you are never sure if they are going to work with the next cabal/ghc version :-("
haskell,3dcnge,kyllo,1 point,Wed Jul 15 11:14:24 2015 UTC,"I use emacs with this .emacs.d file as my starting config because it includes everything I need for Haskell (and Clojure and Ruby and Python and Javascript), and I want to write as little emacs Lisp as possible:  https://github.com/purcell/emacs.d"
haskell,3dcqwj,klaxion,7,Wed Jul 15 06:32:35 2015 UTC,stack does all the sandboxing automatically so you don't need to worry about it at any point. as long as you are working on separate projects things will not get into their way. It doesn't use the standard cabal sandboxes for this afaik so you can't mix them.
haskell,3dcqwj,cocreature,3,Wed Jul 15 07:04:46 2015 UTC,Does this mean Stack has its own sandbox implementation?
haskell,3dcqwj,hagda,3,Wed Jul 15 07:12:59 2015 UTC,"Yes, it creates a .stack-work directory, which is like a project sandbox."
haskell,3dcqwj,cameleon,2,Wed Jul 15 08:14:14 2015 UTC,How does this work since stack doesn't have awareness of my projects?   Also how do I point GHC / GHCi / cabal repl to point to stack directories for their packages?
haskell,3dcqwj,cocreature,1 point,Wed Jul 15 13:38:07 2015 UTC,I am not sure what makes you think that stack doesn't know about your projects. You declare what packages your project consists of in stack.yaml For ghc/ghci see stack ghc or stack ghci.
haskell,3dcqwj,gelisam,1 point,Wed Jul 15 13:53:40 2015 UTC,"I don't have a stack.yaml file, but I am receiving bug reports from users who are apparently able to build my code with stack anyway (the bug report is about what happens at runtime afterwards). Does stack use the .cabal file if it cannot find a .yaml file?"
haskell,3dcqwj,kqr,2,Wed Jul 15 18:36:35 2015 UTC,"Yes, Stack uses both the .cabal file (for the project information including dependency list and build options) and writes its own configuration to the .yaml file (which includes which stackage snapshot to fetch packages from). When you first run Stack on a non-stackized-but-cabalized project it will generate the .yaml file based on the .cabal file."
haskell,3dcqwj,cocreature,1 point,Wed Jul 15 19:44:49 2015 UTC,While that is true it looks to me like they tried a global install which fetches the package from stackage and installs using the most recent lts by default. So it doesn't create a separate stack.yaml.
haskell,3dcqwj,snoyberg,2,Wed Jul 15 20:27:33 2015 UTC,"You may be able to read the HASKELL_PACKAGE_SANDBOXES environment variable at compile time via template Haskell to get a more accurate idea of where the libraries come from. It's late and I'm on my phone right now, but if you have questions about that ping me on the stack mailing list."
haskell,3dcqwj,gelisam,2,Thu Jul 16 05:45:50 2015 UTC,Thanks! That approach is much more future-proof than my current strategy of guessing which kind of sandbox was used based on the installation path given by cabal's autogenerated Paths file. I wish cabal supported this as well.
haskell,3dcqwj,Shun_Y,2,Sun Jul 19 15:21:06 2015 UTC,"It might be a bit different category though, does anyone know how to do cabal install --enable-tests using stack?"
haskell,3dcqwj,dpwiz,5,Wed Jul 15 08:39:47 2015 UTC,"It's just stack test. It will reconfigure the project, install testing deps and run the thing."
haskell,3dcqwj,Shun_Y,1 point,Wed Jul 15 09:43:53 2015 UTC,That did the trick. Thank you!
haskell,3dad59,gallais,7,Tue Jul 14 19:06:52 2015 UTC,"Wow, this is great. I didn't realize you could do so much with so little code with GHCJS and React-Haskell.  I've been incredibly hesitant about using Haskell on the frontend, but I'll definitely give it a try at some point after seeing this."
haskell,3dad59,NiftyIon,5,Wed Jul 15 04:38:02 2015 UTC,"Author here. Some updates from the six months since publishing this:   I no longer recommend doing animation work in Haskell. The potential performance problems scare me off. In fact, I've moved most of my layout work to javascript so I can take advantage of tools like react-hot-loader to tweak styles in realtime. The javascript community is much larger than ours and they've built a lot of great tools. I'm trying to take advantage of as many as I can. I now tend to do logic in Haskell and layout in JavaScript. This is possible to do because react-haskell can now import foreign react classes (example). I'm not happy with the API yet - suggestions welcome. In fact, I've been doing quite a lot of react-haskell work. You now define real react classes, which improves performance and debugging (hello react-devtools!). Animations are no longer built in to classes and transitions, though there's nothing stopping you from using them. I gave up on the React monad and decided to use RebindableSyntax. My stance is now, if it isn't a monad it shouldn't pretend to be one. Additionally the code is much simplified and clarified (much more suited to external contributions, I'd say)."
haskell,3dad59,joelburget,3,Thu Jul 16 06:22:58 2015 UTC,GHCJS is looking more and more appealing. Awesome blog post!
haskell,3dad59,ephrion,3,Tue Jul 14 20:12:44 2015 UTC,Hey the link to the Github repo seems broken
haskell,3dad59,liberalogica,2,Wed Jul 15 04:36:31 2015 UTC,ping /u/joelburget
haskell,3dad59,joelburget,1 point,Wed Jul 15 08:29:07 2015 UTC,Sorry about that! I recently rewrote react-haskell and those examples are the one thing I haven't gone back to update. Will try to fix within a couple days.
haskell,3dad59,liberalogica,1 point,Thu Jul 16 06:06:54 2015 UTC,"This is great, well done! Looking forward to try it myself and for your next post. Front end dev with Haskell is still a rough territory and posts like this will make it a reality"
haskell,3dad59,joelburget,1 point,Wed Jul 15 03:38:34 2015 UTC,Forgot that I promised another post until I saw this comment. Oops!
haskell,3dchh3,Grantselrich,5,Wed Jul 15 04:49:29 2015 UTC,With the DataKinds extension you can pass a list of types as a parameter. See vinyl for example.
haskell,3dchh3,mjmrotek,1 point,Wed Jul 15 05:28:17 2015 UTC,"Also, more directly what they are looking for, hlist."
haskell,3dchh3,andrewthad,4,Wed Jul 15 14:28:36 2015 UTC,"data type that can take any number of type parameters  type constructor can take any number of values   There is two questions, depending on what exactly you need:   data constructor taking any number of value parameters; type constructor taking any number of type parameters;   The first one can be easily modeled in Haskell. Try looking into e.g. this link.  The latter one involves some more sophisticated approaches, but I think you don't need it for your task."
haskell,3dchh3,dima_mendeleev,2,Wed Jul 15 06:33:26 2015 UTC,None of the approaches mentioned give you polyvariadic constructors (at least not as written).
haskell,3dchh3,rpglover64,2,Wed Jul 15 12:55:27 2015 UTC,"I think your question is worded a bit poorly. Haskell doesn't really have dependent types, so you can't have a type constructor which accepts values as arguments. I am assuming you mean something else.  If you are asking about type constructors which can take any number of types as arguments, then mjmrotek's answer is probably going to point you in the right direction.  If you are asking about data constructors which can take any number of values as arguments, you could look at the way Text.Printf handles overloading, or you could use type families. Either way, you will need a smart constructor for your vectors."
haskell,3d9z57,snoyberg,19,Tue Jul 14 17:32:42 2015 UTC,"It's easily searchable when using the phrase (which I mentioned from the beginning) ""Haskell tool stack"". As it turns out, now even ""Haskell stack"" is sufficient to get good results on most search engines   Now, I realise I'm shooting myself in the foot a bit here by not having an actual good example at hand, so take it for what it is: My experience has been that googling for ""haskell stack"" is not the problem.  The trouble starts when I'm trying to google for ""haskell stack <action>"" or ""haskell stack <problem>"", and get a bunch of irrelevant hits on how to create a stack data structure, or what web stack to use, or people who have blown their memory stack.  Maybe this sorts itself out when Stack gains more traction and people start having more problems with it and ask about how to do things with it, but for the time being I feel like there's a few questions about stack spread out there, but I can't reach them for all the other stacks around."
haskell,3d9z57,kqr,18,Tue Jul 14 18:38:47 2015 UTC,"Yeah, I think the issue you're having isn't so much with the name as with the lack of material on the net. There's pretty much just the GitHub wiki and a smattering of blog posts.  I notice that some people are using the haskell-stack tag on StackOverflow, which sounds like a good idea.   http://stackoverflow.com/?tags=haskell-stack"
haskell,3d9z57,radix,8,Tue Jul 14 18:44:22 2015 UTC,"I agree, it is a good idea. I've added a comment about it to the README."
haskell,3d9z57,lukewarm,8,Tue Jul 14 18:53:59 2015 UTC,"This.  The problem is not so much in insufficient searchability of the project itself, as in conflation with other frequent searches. If Google learns to show more of Stack the project, it would mean more irrelevant hits for people who wanted to find haskell web stack or explanation of stack overruns."
haskell,3d9z57,yitz,2,Tue Jul 14 20:38:17 2015 UTC,"Even before Stack gains more traction, Google will soon learn that you really do already know about the stack data structure, and that your are currently not interested in changing your Haskell web stack."
haskell,3d9z57,kqr,11,Tue Jul 14 18:43:24 2015 UTC,Somehow I don't feel like this is a satisfactory solution. Maybe it's because I do also use DDG quite a bit.
haskell,3d9z57,yitz,1 point,Tue Jul 14 19:01:30 2015 UTC,I agree that it's not satisfactory. Sometimes I wish Google would just mind their own business.
haskell,3d9z57,Faucelme,18,Thu Jul 16 08:27:53 2015 UTC,It appears that Wadler's Law of language design also applies to tooling...
haskell,3d9z57,conklech,10,Tue Jul 14 20:40:59 2015 UTC,"It's also reasonably easy to type. It's a short, ordinary English word with no awkward letter clusters."
haskell,3d9z57,drwebb,7,Tue Jul 14 17:53:08 2015 UTC,"And, it just rolls off the fingers if you are one of the dozen people who use the Colemak layout."
haskell,3d9z57,yitz,12,Tue Jul 14 18:02:06 2015 UTC,I may consider switching to the STACKYUIOP layout.
haskell,3d9z57,Jurily,4,Tue Jul 14 18:44:13 2015 UTC,Now that would be a good name.
haskell,3d9z57,wiiittttt,2,Tue Jul 14 19:25:24 2015 UTC,Don't leave us Workman people out!
haskell,3d9z57,drwebb,3,Tue Jul 14 22:42:05 2015 UTC,"Okay, and the two Workman people! And that strange guy in the corner who uses Norman!"
haskell,3d9z57,kqr,1 point,Wed Jul 15 02:25:24 2015 UTC,To be fair the idea of Colemak is that regular words should roll of the fingers. ;)
haskell,3d9z57,turtil,5,Tue Jul 14 20:42:19 2015 UTC,"Go (Golang) had/has the same issue with its name, in that when you search for Go, it took a very long time for it to appear anywhere near the top of the page.  With time, content, issues, questions, etc it started to rise. Also as a minor point, when people would refer to Go in publications, there was always a suggestion to use the term Golang, as some of the suggestions have pointed out, when searching use Haskell Stack.   It will sort it self out, Go's users were new once, and the language survived; Stack is new, and it will (hopefully) survive too :)  Personally I like the name."
haskell,3d9z57,protestor,6,Wed Jul 15 00:30:07 2015 UTC,"Go also, unfortunately, displaced the Go! programming language from Google searches. The problem here is that Google does not understand the ""!"" is significant, and simply erase it, even with quotes."
haskell,3d9z57,smog_alado,6,Wed Jul 15 02:44:02 2015 UTC,"Maybe its too late for me to join the discussion but something I don't like about the name ""stack"" is that its often used in a ""framework"" sense in other contexts. The ""LAMP stack"", the ""Java stack"", etc. It implies a bunch of things stacked on top of each others. On the other hand, haskell's ""stack"" has more to do with package management."
haskell,3d9z57,haskman,3,Wed Jul 15 03:08:28 2015 UTC,"As the person who started the original conversation on this topic, I still wish it were named something different. But I really do appreciate the unambiguous response which, I guess, settles the matter for now!  Edit: I take it back. stkg suggested by /u/kqr (https://www.reddit.com/r/haskell/comments/3d9z57/about_the_name_stack/ct3d6rv)) is the perfect name and a big improvement over stack!  It's short (a letter shorter than ""stack""), unique, easily pronounceable, easily searchable, retains the ""stack/stackage"" heritage. It is neither a pun, nor an acronym. It just garners familiarity points for sounding similar to dpkg and leaves no doubt that it manages haskell packages!"
haskell,3d9z57,drwebb,4,Wed Jul 15 11:34:59 2015 UTC,"The ""stack is a package manager"" conception is something we want to move away from. Nix is a package manager, and stack is a build tool.  See: https://github.com/commercialhaskell/stack/issues/569"
haskell,3d9z57,eacameron,3,Wed Jul 15 16:36:52 2015 UTC,"Not everyone is familiar with Linux tooling and the ""beauty"" of this name is lost on them, let alone how it is ""easily pronounceable""."
haskell,3d9z57,Jurily,3,Wed Jul 15 19:28:09 2015 UTC,"I'm mostly concerned for new users, especially since stack aims to be the first point of contact. For someone who doesn't care about Haskell and just wants to install pandoc because /r/technology told them it's the best tool for converting documents, taking more than two Google searches is likely a deal breaker.  On the other hand, nobody ever got lost on the internet trying to find instructions for Apache Hadoop."
haskell,3d9z57,mallai,3,Tue Jul 14 19:21:13 2015 UTC,"The name of the project should be distinctive and the name of the executable should be convenient. For example, the stk name for the stackage executable was very very nice. And the name of the project could be haskell-stack, hastack, whatever. I see nothing wrong with haskell stack with or without the hyphen and it is natural for people to write and Google will work out the associations. Now, for Hackage, the name stack can remain unchanged but the docs should use a qualified name with haskell."
haskell,3d9z57,mallai,4,Tue Jul 14 19:33:21 2015 UTC,"Who exactly will be helped by this? When you say ""the project,"" what does that mean? You mean the stack repository name should be changed to haskell-stack, because the commercialhaskell organization it belongs to isn't sufficient to indicate ""Haskell?"" Or if it's about search results, how will using ""haskell-stack"" throughout the docs force people in blog posts and such to use ""haskell-stack"", and how will it convince people doing a search ""oh, I better make sure I search for haskell-stack, even though the executable is called stack?""  As I see it: the project is ""the Haskell tool stack."" The repo name is stack. The package name is stack. The executable name is stack. And it's a Haskell tool."
haskell,3d9z57,kqr,3,Tue Jul 14 19:40:50 2015 UTC,"I suppose only search engines will be helped by it. Having the phrase ""haskell stack"" appear frequently in plain text documentation will give it more weight and make it distinct from ""stack overflow"" and others. That's it.   I am not suggesting github repo name change, nor hackage name change, nor executable name change. For people it's distinguishable enough from the context."
haskell,3d9z57,kqr,2,Tue Jul 14 21:28:13 2015 UTC,"If that's the case, maybe the name change you're looking for already happened :). I do strongly recommend when discussing stack to try to get at least the word Haskell, and preferably the word tool as well, in close proximity. But people will still use whatever name they want (e.g., I get emails to ""Michael Snoyberg"" fairly regularly ;))."
haskell,3d9z57,haskman,3,Tue Jul 14 21:42:01 2015 UTC,"Out of curiosity, how did Snoyman turn into snoyberg?"
haskell,3d9z57,kqr,3,Wed Jul 15 12:22:27 2015 UTC,Highschool nickname as a reference to Dr. Zoidberg.
haskell,3d9z57,mosha48,1 point,Wed Jul 15 13:03:41 2015 UTC,"For example, the stk name for the stackage executable was very very nice.    Haha, it just hit me how nicely stkg would rhyme with dpkg on Debian-based systems.  This is not a serious suggestion. It's just the kind of cute pun that I assume we're not going for."
haskell,3d9z57,dysinger,1 point,Tue Jul 14 20:45:20 2015 UTC,But... but.. That's the perfect name! Why can't we have nice and fun things? :(
haskell,3d9z57,mosha48,1 point,Wed Jul 15 12:19:57 2015 UTC,Haha by all means. If people like it I don't have anything against it. I just don't think it should be chosen primarily because it rhymes nicely with dpkg.
haskell,3d9z57,alexeyr,1 point,Wed Jul 15 12:32:38 2015 UTC,I've spent way too much time trying to find a recursive acronym matching stack. I'm stuck at the letter k.
haskell,3da39p,akurilin,5,Tue Jul 14 18:00:21 2015 UTC,"Nice! The RFC also describes how HTTPS works over TLS in HTTP/2. Is that also supported by this PR, or is more work needed?"
haskell,3da39p,yitz,5,Tue Jul 14 18:24:47 2015 UTC,Given that it mentions WarpTLS in there and that HTTP/2 doesn't even have an unencrypted client implementation as far as I know I would assume it does support TLS.
haskell,3da39p,Taladar,2,Tue Jul 14 18:54:26 2015 UTC,The RFC definitely has separate specifications for connection startup for HTTP vs. HTTPS. So just using WarpTLS is not enough - there is special logic that needs to be implemented for HTTPS to be supported in HTTP/2.
haskell,3da39p,yitz,4,Thu Jul 16 10:30:23 2015 UTC,"Ahead of the curve, no? Congratulations!"
haskell,3d9i9q,mrkaspa,42,Tue Jul 14 15:35:24 2015 UTC,"With GHCi, Yesod development is fast. It's yesod-devel that's currently a sluggish dev cycle. I recorded a video (just for you!) demonstrating using Yesod with GHCi for haskell.org's codebase: https://www.youtube.com/watch?v=1akOBGihKNs  I used this same technique on stackage.org, fpcomplete.com, all my other sites.  See this file in the scaffold, which you should have in your own.   Also /u/eegreg is a user of this too, last I checked."
haskell,3d9i9q,chrisdoner,4,Tue Jul 14 17:15:32 2015 UTC,That should be the default behavior of the framework
haskell,3d9i9q,yitz,3,Tue Jul 14 19:22:08 2015 UTC,"This looks very cool.  How can I get a DevelMain for an existing app? We have devel.hs, which doesn't have an update function."
haskell,3d9i9q,chrisdoner,7,Tue Jul 14 17:42:32 2015 UTC,"If you have a fairly recent Yesod, this recent scaffold file may work, but I see it uses getApplicationRepl which may be too recent for you. Alternatively, this older one just requires getApplicationDev to run.  In any case I made a small demo project here describing the idea: https://github.com/chrisdone/ghci-reload-demo See the safer way section.   The trick is using foreign-store to keep hold of a thread ID inside GHCi, between :load which usually wipes the context, then you can later kill that thread and start a new thread. That's the magic sauce that was always missing."
haskell,3d9i9q,yitz,2,Tue Jul 14 17:49:53 2015 UTC,"Thanks! I'll have a look. Our scaffolding is very old, but we do try hard to keep Yesod itself quite fresh. We just finished a painful few days of work to get past the system-filepath barrier, company-wide."
haskell,3d9i9q,codygman,3,Tue Jul 14 18:33:41 2015 UTC,How can I do it with other IDE rather than EMACS
haskell,3d9i9q,codygman,2,Tue Jul 14 19:36:07 2015 UTC,"What IDE?  You need a way to send ""DevelMain.update"" to the ghci context that has your project loaded."
haskell,3d9i9q,codygman,3,Wed Jul 15 03:10:24 2015 UTC,Ok and how can I do that ?
haskell,3d9i9q,chrisdoner,1 point,Wed Jul 15 06:54:26 2015 UTC,That depends on the IDE.
haskell,3d9i9q,Bzzt,1 point,Wed Jul 15 07:14:51 2015 UTC,I'm using atom
haskell,3d9i9q,chrisdoner,2,Wed Jul 15 07:43:02 2015 UTC,Looks nice I'll give it a look
haskell,3d9i9q,kyllo,2,Tue Jul 14 18:10:24 2015 UTC,"Maybe yesod init's scaffolded project supporting this by default would be a good idea.  Actually I'm curious, do you use this for other stuff at all? I've always been interested in being able to patch changes to ghci for more interactive development like this."
haskell,3d9i9q,mightybyte,3,Wed Jul 15 03:46:17 2015 UTC,"I've used it for running xmonad in ghci. I tried to use it with SDL/GLUT, but neither are able to run in GHCi anymore on my Linux. Weird linker errors beyond my motivation to diagnose. Otherwise we could have live update of renderers on the fly; just reload the code and update an IORef to the rendering function."
haskell,3d9i9q,chrisdoner,2,Wed Jul 15 09:42:38 2015 UTC,"This is great - wish I'd known this six months ago.  Got it working on yesod 1.4, but with a few caveats.  Had to use   :l app/DevelMain.hs   instead of plain DevelMain.hs.  Also needed to add these lines to the file:  import System.IO import Control.Monad import Data.Function import Data.Maybe   Is this something that could work in Stack as well?"
haskell,3d9i9q,kyllo,3,Wed Jul 15 04:26:07 2015 UTC,stack ghci should be fine.
haskell,3d9i9q,Hamilcar98,1 point,Wed Jul 15 09:40:06 2015 UTC,Yes I use stack ghci as my reply command in emacs and DevelMain works.
haskell,3d9i9q,snoyberg,6,Wed Jul 15 13:12:54 2015 UTC,"It might be fast for small sites, but you're still going to see significant slowdowns as projects get larger.  The example in your video is 2300 lines of code.  That is not at all a ""substantial codebase"" in the grand scheme of things.  I'd like to see what that reload cycle is like on a 30,000 line app."
haskell,3d9i9q,vagif,8,Tue Jul 14 19:34:30 2015 UTC,"See my other reply. I have used GHCi on work projects which have equaled or exceeded 30K (the point of incremental recompilation is that it doesn't matter), since around 2010."
haskell,3d9i9q,snoyberg,1 point,Tue Jul 14 23:35:06 2015 UTC,"Thanks so much for explaining this, I didn't even know about it!"
haskell,3d9i9q,codygman,1 point,Wed Jul 15 00:41:42 2015 UTC,Thanks for the blog post and video. I was able to achieve fast project reloading as you demonstrated after only a few minutes of fiddling with an existing project.
haskell,3d9i9q,tauli,33,Thu Jul 16 17:56:18 2015 UTC,"Yes, yesod devel is too slow. There's a gsoc project to rewrite it using ide-backend, which should speed things up considerably."
haskell,3d9i9q,vagif,3,Tue Jul 14 15:52:22 2015 UTC,is there a write up or anything on how to use yesod devel with non scaffolded projects? I'm talking about the minimal yesod startup code like helloworld example.
haskell,3d9i9q,codygman,6,Tue Jul 14 18:25:13 2015 UTC,"No, but the goals of the new yesod devel include making it work for any Haskell web project, not just a Yesod (or even Warp) application, so we'll necessarily be giving instructions on how to do so."
haskell,3d9i9q,kqr,2,Tue Jul 14 18:45:30 2015 UTC,Cool! That's definitely something I'll be looking out for.
haskell,3d9i9q,pycube,4,Tue Jul 14 16:13:03 2015 UTC,"While I'm not an expert on Yesod, I'd guess that there is some recompiling going on. Even if you just modify templates, since they are also compiled. I can relate to your impression, that this feels slow and ""unproductive"" if you come from a more dynamic language. Rest assured though, that this comes with benefits.    The type system gives you more guarantees than most other languages, meaning you will spend less time debugging. In my experience, you'll be much faster overall if you care about correctness and/or security of your code. You get a native binary that runs much faster than what implementations of languages like Perl, Python, Ruby, JavaScript, etc. are  able to provide. Also once compiled Yesod typically runs crazy fast, even compared to other statically compiled languages."
haskell,3d9i9q,I4dcQsEpLzTHvD1qhlDE,7,Tue Jul 14 15:45:34 2015 UTC,"As a yesod user, i can assure you that once you have around 10 templates the compile cycle becomes unbearable.  I completely eliminated all yesod templates from my projects."
haskell,3d9i9q,get-your-shinebox,3,Tue Jul 14 16:33:22 2015 UTC,"I'm trying with Go compiles so fast that even seems interpreted, I know it's not so high level as Haskell but is compiled, fast and productive."
haskell,3d9i9q,ben7005,6,Tue Jul 14 15:52:21 2015 UTC,"This is something nice about Go, but you also have to give up many nice optimizations, Generics, referential transparency, and more when using Go instead of Haskell.  I have some production experience with both and I much prefer to use Haskell."
haskell,3d9i9q,codygman,5,Tue Jul 14 16:19:17 2015 UTC,"Does your Go framework compile and type-check your templates? (Not saying that should take particularly long, just curious if it is that advanced.)"
haskell,3d9i9q,arpunk,5,Tue Jul 14 16:28:08 2015 UTC,"That is not so surprising, considering that one of Go's design goals was fast compilation :)"
haskell,3d9i9q,orbitalfox,8,Tue Jul 14 16:01:00 2015 UTC,"Which it failed at.  The go compiler is much slower than ocaml's compiler, despite ocaml being a significantly more advanced language."
haskell,3d9i9q,mightybyte,5,Tue Jul 14 17:53:10 2015 UTC,"One day there's going to be a good language with a good ecosystem.  edit:  I'm not sure how much faster ocaml's compiler could really be, Go's is certainly very fast.  I think it's succeeded at being fast enough to not feel like you're wasting time compiling."
haskell,3d9i9q,imalsogreg,5,Tue Jul 14 20:00:01 2015 UTC,HAHA that's funny  :'(
haskell,3d9i9q,AlpMestan,2,Tue Jul 14 20:31:43 2015 UTC,I'm going to have to checkout ocaml sooner than I thought if this is true.
haskell,3d9i9q,yitz,6,Wed Jul 15 03:51:03 2015 UTC,I think this highly depends on your definition of productivity.
haskell,3d9i9q,mightybyte,1 point,Tue Jul 14 15:54:46 2015 UTC,But is it not the future.
haskell,3d9i9q,chrisdoner,11,Wed Jul 15 08:47:49 2015 UTC,"To some extent, this is inherently what you signed up for when you chose Haskell and Yesod.  The main reason Haskell is so good is because the compiler is doing a TON of stuff for us.  I'm sure there is plenty of room for improvement in compile speed, but fundamentally you have to expect that a compiler doing more stuff for you is always going to be slower than other compilers (especially with languages like go that were designed to make compilation efficient).  So, with that in mind, we have to then move on and examine the rest of the factors.  Yesod follows the philosophy of taking maximum (or close to it) advantage of the amount of type safety Haskell has to offer.  The shakespeare package says right up front in its synopsis: ""A toolkit for making compile-time interpolated templates"".  What does this mean?  It means that you're going to have to recompile every time you make a change to your templates.  My experience is that if your app gets big enough, these dynamic recompiling features will eventually become unusable.  Some have mentioned here that you can get faster development with ghci.  But as app size increases, I've found that eventually ghci becomes unusable as well and you're stuck with long compile times.  Again, maybe the situation can be improved, but at the end of the day you have to conclude that longer compile times are a pretty much unavoidable tradeoff for using Haskell.  Most of the people here will agree that it is totally worth it, but it's still there.  With this in mind, the next thing to think about is what parts of your app really need type safety.  This is one of the reasons that Snap chose not to go down the compiled template road.  Is it less type safety?  Yes.  But we thought that it was the right tradeoff.  Here's a blog post and screencast I wrote that highlights the difference pretty clearly:  http://devblog.soostone.com/posts/2013-06-17-snap-template-reloading.html  As with so many things in software, this is a tradeoff.  I can't tell you what point on the spectrum is right for you, but if rapid template reloading is important to you, then you might consider giving Heist and Snap a try.  EDIT: My statement above about GHCI becoming unusable was made being unaware of -fobject-code, which sounds like it may help.  My overall point about compiled templates being inherently more expensive than non-compiled templates is still valid, but -fobject-code might make the difference much smaller."
haskell,3d9i9q,sopvop,10,Tue Jul 14 18:09:29 2015 UTC,"+1 for giving snap a try. As an author of pretty modest-sized web apps I've found the compile time to be nice and quick. There was a time with ghc-mod that type-checking was less than half a second. Full recompile more like 10 seconds as in the OP's case, but when I'm working on the html I'm using Heist and usually not recompiling anyway, just re-starting the app.  I'd been doing this the dumb way - killing and restarting the server - which was instantaneous but took an extra Ctrl-C for every html edit. I can't wait to try this fswatch thing!"
haskell,3d9i9q,chrisdoner,3,Tue Jul 14 20:41:35 2015 UTC,I'm definitely looking forward to use that with servant too.
haskell,3d9i9q,mightybyte,7,Wed Jul 15 08:23:32 2015 UTC,"Actually, the work of /u/chrisdoner with GHCi shows that this is not an inherent limitation of compile-time type-safe templates, but rather just an implementation detail of devel mode. /u/snoyberg posted elsewhere in this thread that he looking into fixing it."
haskell,3d9i9q,sambocyn,8,Tue Jul 14 18:38:02 2015 UTC,"This is not about devel mode.  It's a fundamental fact that reloading compiled templates will always be slower than concatenative templates that just have to read bytes and fill in holes.  As I said, I've found that for large apps, GHCI reload time is also unbearable.  It might not be visible with smaller apps, but it's still there and in a large enough app the issue is simply unavoidable.  EDIT:  The project in /u/chrisdoner's video is 2300 lines of code.  And because the templates are compiled, that includes the markup.  The app in my video is 30,000 lines of code not including the templates.  And I can tell you that GHCI is nowhere near that responsive on an app of that size."
haskell,3d9i9q,chrisdoner,11,Tue Jul 14 19:03:57 2015 UTC,"As I said, I've found that for large apps, GHCI reload time is also unbearable.   For this see Making GHCi scale better and faster.   The project in /u/chrisdoner[1]  's video is 2300 lines of code.   It's also a recognizable open source project that I am allowed to demonstrate.   And because the templates are compiled, that includes the markup. The app in my video is 30,000 lines of code not including the templates. And I can tell you that GHCI is nowhere near that responsive on an app of that size.   The fpcomplete.com codebase is 25K~ of Haskell files (excluding templates) and I can reload any module in it in a second (which includes loading hamlet dependencies). I develop all my codebases like this (loading the whole thing in GHCi and using :load to type check modules I'm working on).   It's a fundamental fact that reloading compiled templates will always be slower than concatenative templates that just have to read bytes and fill in holes.    The question is how slow reloading a compiled template is on a real industry-sized project, and the fact is that it's not a problem (under or at about a second) with the right configuration.   (Actually, part of the delay is that I use ghci-ng, which generates a complete database of all types of all spans in your code every time you load a module; it's much faster on regular GHCi)."
haskell,3d9i9q,sambocyn,3,Tue Jul 14 23:31:13 2015 UTC,:set -fobject-code helps a lot! I wonder why haskell-mode does not set it by default.
haskell,3d9i9q,hvr_,4,Wed Jul 15 09:37:18 2015 UTC,"Due to this caveat:   After that, you may notice that loading some modules gives less type information and general metadata than before."
haskell,3d9i9q,boywiththegoldenmind,2,Wed Jul 15 09:46:08 2015 UTC,Holy shit!  How in the world did I not know about -fobject-code?  I'll have to give it a try.
haskell,3d9i9q,vagif,1 point,Thu Jul 16 18:02:00 2015 UTC,"re ghci-ng, it provides type information on every subexpression? no way!  btw, looking at the package, is it an early-access ghci? or just a fork that may or may not be merged? also, has it been merged into 7.10's ghci? thanks."
haskell,3d9i9q,ignorantone,3,Wed Jul 15 03:00:53 2015 UTC,"There's a hackage bug which prevents me from uploading my version here: https://github.com/chrisdone/ghci-ng The current one on Hackage is rather old and doesn't support this type info. It was maybe-gonna be merged into GHCi, but I'm more likely to redouble my efforts on ide-backend."
haskell,3d9i9q,get-your-shinebox,1 point,Wed Jul 15 09:45:17 2015 UTC,can the :uses command be made to work for all uses (in other modules too)? or should one try to filter :all-types for that?   FindUsages in IntelliJ (for Java) makes reading code much easier. the functionality is probably  also called by the refactoring command.  thanks again.
haskell,3d9i9q,pbvas,3,Wed Jul 15 16:38:54 2015 UTC,"Well, the original intent of ghci-ng was to serve as incubation area/experimentation playground for new GHCi features. I still hope that some new features may be ready to be merged for GHC 7.12... looks at /u/chrisdoner expectantly"
haskell,3d9i9q,I4dcQsEpLzTHvD1qhlDE,3,Thu Jul 16 09:49:19 2015 UTC,I think thak the main reason is compiling time. All compiling languages have the same problem. Play some time with yesod config i think that there is an option fo improve this time (maybe run app with specyfic param).
haskell,3d9i9q,mightybyte,3,Tue Jul 14 15:47:18 2015 UTC,I migrated to SPA (single page apps) where html and javascript are static files and completely eliminated yesod templates.  Although this was not the reason i moved away from yesod templates it definitely helped me with recompile time of yesod devel.
haskell,3dav9h,Darwin226,2,Tue Jul 14 21:10:03 2015 UTC,"Correct me if I'm wrong, but wouldn't this break pure code in some cases?"
haskell,3dav9h,mbruder,3,Tue Jul 14 21:40:50 2015 UTC,This might be of interest: https://stackoverflow.com/questions/14710928/is-spoon-unsafe-in-haskell
haskell,3dav9h,tel,2,Wed Jul 15 01:39:06 2015 UTC,I'm assuming in the same cases where spoon breaks pure code. I didn't look to much into the actual mechanism that catches the exceptions. Just extending it to functions.
haskell,3daj3o,andrewthad,3,Tue Jul 14 19:46:48 2015 UTC,"I'd recommend being flexible with the model/update/view pattern.  Although it can be a useful model, there are often better models that you can build depending on your specific data model.  It's hard to say definitively without taking a look at your code, but it seems reasonable in your situation to keep some of that state local to the individual UI elements, update it in-place, and then collect it up into a model later.  In my experience, FRP is great at expressing a wide variety of data flow models, so there's no need to try to fit everything into a predetermined flow like MVC/MVVM/etc. - just follow your appplication's needs.  One last thing: reflex-dom will not rebuild elements of your list unless their keys (presumably, in this case, list indexes) have changed.  If you'd like to talk in more depth about your specific situation, feel free to hit me up on #reflex-frp on irc.freenode.net, or send me a PM here on reddit."
haskell,3daj3o,ryantrinkle,2,Wed Jul 15 05:32:34 2015 UTC,"Also, can I get you to clarify to part where you talked about reflex-dom not rebuilding the elements of the list? If I sample a Behavior and then use forM/mapM to iterate over the results and build the DOM from that, I can't see how reflex-dom could be smart enough to caching, even if we're only considering the situation of updating an item at a particular index.  If you have [Behavior t a], then it seems possible, but with Behavior t [a], it seems like caching couldn't be happening. Were you describing the former situation, or does your statement apply to both?"
haskell,3daj3o,ryantrinkle,3,Wed Jul 15 13:50:04 2015 UTC,"Yes, that's correct; if you're using forM/mapM, then the whole list will be redrawn when the value changes.  However, there are a variety of list drawing functions in Reflex.Dom.Widget.Basic, all of which diff their updated inputs against their previous inputs, which gives them better performance (they only create and destroy widgets when necessary, and otherwise notify existing children that their inputs have changed)."
haskell,3daj3o,heisenbug,1 point,Wed Jul 15 16:37:01 2015 UTC,"Thanks. I appreciate hearing that it's alright to deviate from the MVC approach (especially from you). What you've described is more or less what I'm doing at the moment, and it's been a pretty good strategy so far."
haskell,3d9fs4,martingalemeasure,3,Tue Jul 14 15:17:26 2015 UTC,I love the docs for this library.
haskell,3d9fs4,andrewthad,7,Tue Jul 14 17:12:32 2015 UTC,"The mix of ""color"" and ""colour"" in Data.Colour.Palette.ColorSet is killing me."
haskell,3d9fs4,int_index,3,Tue Jul 14 20:02:57 2015 UTC,And Kolor
haskell,3d9fs4,andrewthad,4,Tue Jul 14 20:19:33 2015 UTC,"The documentation is beautiful - however have to agree with some of the comments here, you really need to choose between Color/Colour and Kolor (wut) in your naming scheme - personally I would use Color (even as a brit) as this seems to fall in line with the naming in most other libraries."
haskell,3d9fs4,Mattiemus,1 point,Tue Jul 14 21:07:21 2015 UTC,"Note that the insistence on Colour comes from the colour library, which is written by someone else.  Some libraries expose synonyms for en-uk and en-us sellings. I'm not sure whether that's an improvement or not."
haskell,3d9fs4,conklech,2,Wed Jul 15 15:42:30 2015 UTC,I wrote this a while back to help us make the examples in our diagrams library have more interesting colors. Check out the haddocks for example for http://hackage.haskell.org/package/palette-0.1.0.2/docs/Data-Colour-Palette-BrewerSet.html
haskell,3d9fs4,sambocyn,1 point,Tue Jul 14 15:18:27 2015 UTC,"the docs are very good (an enum of images!), but I wanted to point out that documenting ""synonym for Colour Double"" above ""type Kolor = Colour Double"" is annoyingly redundant. if it's to maintain coverage, I'd just explain why this type is common enough to deserve an alias (why Doubles over Ints or something)."
haskell,3d8kh6,Bollu,23,Tue Jul 14 10:08:51 2015 UTC,"I was also wondering if there are any noob friendly Haskell open source projects.   Sure! I'm the maintainer for Hawk, a command-line tool for manipulating text via Haskell expressions. As my CONTRIBUTING.md file explains, I have tagged some of the issues with ""easy"", ""medium"" and ""hard"", specifically to allow contributors of different levels to contribute. Here are the definitions I give for the three difficulty tags:   ""Easy"" means you should be able to find a solution just by finding the appropriate place in the code (presumably with our help) and making a small local change.  ""Medium"" issues will require you to link a few pieces together, either by getting familiar with an outside library, an unusual Haskell feature, or some other part of Hawk's codebase.  ""Hard"" issues may require the code to be refactored in order to create a place where the new feature can be added. Ideally, the refactoring and the addition of the feature should be in separate commits.   So if you want to contribute to our project in a way which will make you learn new things, you should probably take a look at the medium issues. There are only two right now, but that's mostly because the contributions I receive are always about new issues contributors have encountered themselves, never about fixing existing bugs, so I haven't been super motivated to properly tag the existing bugs."
haskell,3d8kh6,gelisam,2,Tue Jul 14 12:30:12 2015 UTC,"Thanks a lot, I'll definitely check this out :)"
haskell,3d8kh6,bflyblue,9,Tue Jul 14 14:35:14 2015 UTC,I also had a similar experience to you once I felt I understood the basics. What I found useful was picking a library or GHC extension and trying to understand the problem it was trying to solve and what possibilities it opened up for me. I would recommend reading 24 days of Hackage and 24 days of GHC Extensions: https://ocharles.org.uk/blog/
haskell,3d8kh6,mightybyte,1 point,Tue Jul 14 10:19:43 2015 UTC,Thanks for the links :) I'll read through them.
haskell,3d8kh6,mjmrotek,9,Tue Jul 14 14:35:52 2015 UTC,"The two most important things at your stage are:   Work on a more substantial and longer term project that you have strong intrinsic motivation for. Work with other people who have more Haskell experience than you.   Learning to program in a new language well is a very deep endeavor.  Because of this, it can be quite difficult to stick with it, so point #1 is really important.  Secondly, no matter how smart you are, there are guaranteed to be areas of the domain that you just haven't thought of.  That is why it's crucial to work with other people so you can cover more of the search space by virtue of their experience."
haskell,3d8kh6,gelisam,2,Tue Jul 14 14:39:31 2015 UTC,"Yes, exactly. Which is why I wanted to contribute to an open source project - for the more experienced devs who can help me learn. Plus, I enjoy programming so win-win :)"
haskell,3d8kh6,get-your-shinebox,10,Tue Jul 14 14:55:20 2015 UTC,"Here are some links:   http://dev.stephendiehl.com/hask - What I Wish I Knew When Learning Haskell http://www.haskellforall.com - Gabriel Gonzalez's blog (the author of pipes) http://bartoszmilewski.com - Bartosz Milewski's blog. Contains a big section about category theory if you're interested in that. https://www.fpcomplete.com/school - FP Complete School of Haskell   edit:   I was also wondering if there are any noob friendly Haskell open source projects.   Well you can start by sending fixes or upgrades to whatever project you feel needs them, worst thing that can happen is that they won't merge your changes. You can also try releasing your own packages that extend existing libraries."
haskell,3d8kh6,mjmrotek,5,Tue Jul 14 11:37:24 2015 UTC,"Yes, but, which libraries? I've looked at Lens and Parsec, and they're both huge. Like, I don't even know what, say    forall a. a -> a   means, while stuff like that seems to be a common pattern. That and TemplateHaskell.  So, are there any intermediate ish libraries that are looking for contributors?"
haskell,3d8kh6,gelisam,3,Tue Jul 14 14:37:01 2015 UTC,"Like, I don't even know what, say  forall a. a -> a   means   That's quite basic and important. I would advise to learn how to decipher these kinds of type signatures before trying to learn more complicated things like lens and category theory. The keyword to search for is ""parametric polymorphism""."
haskell,3d8kh6,heisenbug,3,Tue Jul 14 15:21:06 2015 UTC,"I've gotten quite far without really understanding RankNTypes.  htebalaka's answer above was super helpful though.  @Bollu, if you're into web dev http://snowdrift.coop/ is written in haskell (with Yesod), actively looking for volunteers, and explicitly trying to be noob friendly.  Edit:  Oh, I see @wolftune replied below and you already talked to them, nice:)"
haskell,3d8kh6,Darwin226,2,Tue Jul 14 20:08:58 2015 UTC,"I know what it means as a standalone. But, I don't know how to interpret it when it is part of a function parameter to another function  f :: forall a. a -> a Just introduces a type variable a.  What trips me is something like  g :: a -> b -> (forall c. c -> c) So now, what is the forall inside the brackets? Why can't it be ""pulled out"" ?"
haskell,3d8kh6,htebalaka,5,Tue Jul 14 15:35:26 2015 UTC,"/u/htebalaka has answered you in more length above, but just as an example:  foo :: (c -> c) -> Int -> Int foo f = (+1) . f   In this case, GHC will complain that it can't unify c with Int. The argument function is apparently defined for some, but unknown, c, and the compiler has no idea what would that be. In contrast:  {-# LANGUAGE RankNTypes #-} foo :: (forall c. c -> c) -> Int -> Int foo f = (+1) . f   compiles correctly and works as expected. In this case, the compiler is told that the argument function must work for all types, and this all obviously includes Int. Of course this is a rather pointless use, especially that the only legal Haskell function of type forall c. c -> c is id (also const undefined or even just undefined, including all other such evilness like error ""boom"", but that's not the point here). For example, the ST monad uses such a type as a compile-time tag, to make sure that separate executions of a state thread can't touch each other's variables.  For some more explanation:   https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/explicit-forall http://blog.mno2.org/posts/2012-04-06-what-is-rank-n-types-in-haskell.html"
haskell,3d8kh6,wolftune,3,Tue Jul 14 16:24:14 2015 UTC,"What trips me is something like g :: a -> b -> (forall c. c -> c) So now, what is the forall inside the brackets? Why can't it be ""pulled out"" ?   In the example you gave, it can! As the documentation for RankNTypes explains, a forall on the right of an arrow can be pulled out, but a forall to the left of an arrow cannot."
haskell,3d8kh6,wolftune,2,Tue Jul 14 16:38:03 2015 UTC,It is best understood as a game. Your adversary can call your function g with any type a and b. You are responsible passing back a function that can be called with any type c and must basically give that thing back. A more interesting situation arises when the forall thingy is an argument. Then g has the right to choose the c type.
haskell,3d8kh6,kqr,2,Tue Jul 14 17:01:28 2015 UTC,"You know how in languages like C# you have to name your type parameters after the name of the function? Like DoStuff<T>(T something)? Well, you don't in Haskell. You just use the T as if you did name it before hand. The forall lets you explicitly introduce a type variable but with the advantage that you get to choose at which ""scope"" it gets introduced in. This has various benefits like ability to simulate existential quantification https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types  Template Haskell is ugly, but simple. Basically Haskell functions running at compile time in a monad that allows you to generate code and put it in the place of that function call."
haskell,3d8kh6,clrnd,1 point,Tue Jul 14 15:06:21 2015 UTC,"Yes, I've used C++ moderately and I know how it works :)  But, what I don't get is when there's a forall introduced in the middle of a function definition  Something like  f :: Int -> (forall a. a -> a) -> ... how does forall in the middle work? what does it do?"
haskell,3d8kh6,gilmi,5,Tue Jul 14 15:17:32 2015 UTC,"In that example it's saying the function has to work not for a particular a, but for all types. So say your function is like this:  f :: Int -> (a -> a) -> a -> a f 0 _ x = x f n g x = f (n-1) g (g x)   This function applies another function a certain number of times, so I could call it like f 5 (succ :: Int -> Int) (3 :: Int), and in the type signature for f, the type a gets unified to Int. But now if I change the type signature to:  f :: Int -> (forall b. b -> b) -> a -> a   and call f 5 (succ :: Int -> Int) (3 :: Int) things will no longer type check, since I'm passing a monomorphic function, and we're requiring a polymorphic function. succ has the type (Enum a) => a -> a, or more verbosely forall a. (Enum a) => a -> a, which has more constraints than what we're asking for.  I could still call f 5 (id :: forall b. b -> b) (3 :: Int), because id works any type. This gets more useful if you also have constraints, for instance if we compare:  f :: Int -> (a -> a) -> a -> a g :: (Enum a) => Int -> (forall b. (Enum b) => b -> b) -> a -> a   In the first example, we could call it like f 5 (factorial :: Int -> Int) 3, to call factorial 5 times on 3, and again a unifies to Int, and everything typechecks. In the second example, the function we can pass can only use the fact that a is enumerable, and no other information about a. So to define factorial, we generally need a type that is an instance of Eq, but even though Int is if we try to call g 5 factorial 3 we get a type error because the function argument isn't allowed to use that information.  Quantification basically provides a form of encapsulation. Also, there's ScopedTypeVariables, which is another use of the syntax.  tl;dr: A function which takes an argument with a type like forall a. (Constraint a) => a -> a requires the provided function to only use the interface provided by the Constraint class, even if the caller knows more about what the type a is. If we have no constraints (forall a. a -> a) then we can really only supply the identity function."
haskell,3d8kh6,gelisam,8,Tue Jul 14 15:40:36 2015 UTC,"My project, Snowdrift.coop aims to be as welcoming to new volunteers as possible. We have thoroughly documented build process, and very welcoming and helpful community. It's a Yesod-based website, so basically all Haskell, and there's tons of little starting ways to contribute. We're definitely a very real-world project hoping to make a real difference to funding and support of free/libre/open projects.  I had no other programming experience and got pulled into learning Haskell just to help with the code… Others in the community have substantial Haskell experience and also are happy to help newcomers."
haskell,3d8kh6,sclv,2,Tue Jul 14 14:51:44 2015 UTC,Thanks a lot! I registered and I'm looking for projects. Let's see how this goes :)
haskell,3d8kh6,k-bx,2,Tue Jul 14 14:55:05 2015 UTC,"Oh yeah, I saw your volunteer application last week now that I realize it! I sent you an email after that following up, did you get it?  I'm hoping the @snowdrift.coop email isn't getting marked as spam or something…"
haskell,3d8kh6,htebalaka,3,Tue Jul 14 15:25:09 2015 UTC,"Libraries like lens and pipes and all that?   Yes! Those are what you'll use to create a real application so much faster later on, so well worth learning. Keep in mind a lot of the things you might traditionally think of as almost ""language features"" in other languages are distributed as third-party libraries in Haskell."
haskell,3d8kh6,ocramz,2,Tue Jul 14 15:46:25 2015 UTC,"Why not make something?  Make a simple game (lens!), or a REST API for some weird niche (aeson!), or a CLI tool for processing .. I dunno, shp/shx files (pipes?)."
haskell,3d8kh6,ocramz,2,Tue Jul 14 13:04:27 2015 UTC,"I am doing that :) Writing a lisp interpreter, plus I solve HackerRank questions using Haskell just for the experience. But, well, I'm working on my own. So, I'd like to work with some ""real world Haskell"" for a change"
haskell,3d8kh6,hissi-hiss,1 point,Tue Jul 14 14:37:45 2015 UTC,Any advice on game making in Haskell? (graphics-wise)
haskell,3d9ebr,ThrowawayTartan,2,Tue Jul 14 15:06:26 2015 UTC,"Also, does Haskell have the Some(x) and None like in SML and OCAML? I tried Googling and the closest I could find was ""Just"" and ""Nothing"" Is that the same? It doesn't seem to be ""built in"" in that it needs to be defined as a datatype first."
haskell,3d9ebr,ephrion,1 point,Tue Jul 14 15:08:06 2015 UTC,"Yes, the Maybe a data type is what you're looking for. One of the neat things about Haskell is that very little is actually built into it. Most things are done in the standard libraries in regular Haskell."
haskell,3d9ebr,Roboguy2,1 point,Tue Jul 14 15:18:04 2015 UTC,"Sorry, coudl you elaborate on    One of the neat things about Haskell is that very little is actually built into it   How is that a neat thing exactly? Genuinely curious. For example, I like coding in Python a lot because there's a lot built into it, whereas I don't really like C as it feels like (for school assignments at least) I need to implement a lot of things from the ground up"
haskell,3d9ebr,Roboguy2,2,Tue Jul 14 15:51:17 2015 UTC,"You don't need to implement it, it is defined in the standard library. The cool part is that you can define things like that, instead of needing them to be builtin to the language itself.  A lot of things are implemented in the standard library rather than as a part of the language itself."
haskell,3d9ebr,mjmrotek,1 point,Tue Jul 14 15:59:20 2015 UTC,"Wait so its power comes from the fact that it leaves you free to implement it yourself or you can just use it from the library?  Why not just overload a function (not sure if I'm using the term correctly) as in Python?  Sorry, could you elaborate further? I'm still not really seeing how it's necessarily a good thing.   Edit: Perhaps I'm confusing the difference between a standard library and having something built into the language itself...."
haskell,3d9ebr,Roboguy2,0,Tue Jul 14 16:07:52 2015 UTC,"I'm not sure where overloading comes into play here.  The nice thing is that the language is powerful enough that you can define things like this, which is why it doesn't need to be builtin to the language. The point isn't that specifically that you can define Maybe or any of the other standard library things, but that Haskell allows you to define other more powerful things that would need to be builtin in many other languages.  For one example of this, take the Swift language. The equivalent of Maybe (optional) is actually built into the language. It also has builtin language constructs for dealing with optionals (if let, ? and !). The Haskell standard library has a set of constructs that are used, among other things, to deal with Maybes (Functor, Applicative and Monad). They are extensible though, so they are more general than the Swift approach. In fact, even in the standard library, there is support for using those constructs with things other than Maybes as well as the possibility for the programmer to add support for new types.  In this particular case, it allows us to easily write general code that works for optionals but that can also work for other sorts of types.  This also means that Maybes are first class values that can be manipulated the same as any other algebraic datatype value: those constructs I mentioned above are implemented as ordinary functions."
haskell,3d9ebr,ephrion,1 point,Tue Jul 14 16:21:46 2015 UTC,"I don't really get this discussion. How on earth is Haskell's Maybe less ""built in"" than OCaml's Option? I don't have much experience with OCaml, but last time I've checked it did have algebraic data types..."
haskell,3d9ebr,dramforever,1 point,Tue Jul 14 18:15:38 2015 UTC,"Oh, sorry, I didn't mean to say that at all. I wasn't trying to say that that contrasts with OCaml, just that there are some things you can implement in the standard library (rather than as a language feature) in Haskell that you can't in some other languages, not specifically OCaml.  I wasn't really trying to say anything about OCaml at all."
haskell,3d9ebr,ephrion,2,Tue Jul 14 23:59:14 2015 UTC,"Haskell as-a-language is pretty small and simple. The standard libraries are pretty nice, and Hackage has a quite good library selection, so there's a lot of code you can bring in.  A lot of what seems built in to the language is actually just regular old function application with functions that anyone can define in Haskell. Syntax like Alternative and the lens operators comes to mind."
haskell,3d9ebr,ephrion,1 point,Tue Jul 14 16:10:38 2015 UTC,"Yeah, I once saw someone asking ""What do the separators . and $ mean?""  ""separators""??!!"
haskell,3d9ebr,dramforever,1 point,Wed Jul 15 07:43:52 2015 UTC,"Actually, my code for the actual function is also broken and I'm not sure why. I tried using the built in debugger (break points and such) and I'm kind of stuck. Anyone willing to take a look? Not sure if I'd be causing any trouble posting my code up here"
haskell,3d9ebr,ephrion,1 point,Tue Jul 14 15:34:33 2015 UTC,"Go for it! I'd be glad to help. If you can also post the provided code that defines the Code data type, that'd be helpful too"
haskell,3d9ebr,ephrion,1 point,Tue Jul 14 16:24:46 2015 UTC,"It's not short so I thought it might be better to post it where there's syntax highlighting. Ignore the print statement haha.  As you can see, I didn't know how to progress with countColors (the original reason why I posted) but it looks like my matches is also broken.  The code  the test cases"
haskell,3d9ebr,ephrion,3,Tue Jul 14 17:04:51 2015 UTC,"I'm not really following what is happening with matches. It refers to exactMatches xs y but that doesn't appear to be defined?  For countColors...  First we want to find an element in a list. I did a hoogle search for a -> [a] -> Maybe a, and the top result took me to Data.List, which has all the list functions. elemIndex looks like we can use it to figure out how to determine the count of colors, but elemIndices (right below it) looks like precisely what you need. It returns a list of ints where each int is an index where the element occurred.  The function countColors takes a Code which is a [Peg]. We have a term colors :: [Peg] which has all of the colors in order. And we have the following pieces of the puzzle:  colors :: [Peg] elemIndices :: (Ord a) => a -> [a] -> [Int] countColors :: [Peg] -> [Int]   If we have a list of indices that an element occurs at in an array, then the size of that array is how many times the element occurs. length (elemIndices Red xs) will tell you how many times Red occurs in xs.   Since we're trying to transform a list of one type into a different list, we probably want to use map. And since the Code passed as a parameter to countColors won't be a complete list of pegs, we'll start by mapping over the colors list:  countColors pegs = map f colors     where       f color = ...   And you should be able to figure out the rest out for that function.  Now, for matches, you're given two lists. Usually, when you've got two lists, you want to zip them together, so that's what I'll start off with:  matches xs ys = undefined     where       zipped :: [(Peg, Peg)]       zipped = zip xs ys   So we have a list of pairs, and we want to identify which ones are equivalent. Haskell has the uncurry function, which is useful for applying a function that takes two arguments to a function that takes a single pair of elements:  add x y = x + y uncurry add (3, 5) == 8   So we can map over a list of pairs with map (uncurry f) listOfPairs.  Now, we want to check to see if the pairs are equal. So map is just map (uncurry (==)) zipped, and we can put that in:      zipped = zip xs ys     pairsEqual :: [(Peg, Peg)] -> [Bool]     pairsEqual = map (uncurry (==))     pegsEqual = pairsEqual zipped   So how many of the pegs were equal? We can filter out all the false ones with filter id (id is a function a -> a which always returns its argument), and then we can just take the length of that list.  onlyTrue = filter id numberOfTrue = length (onlyTrue (pegsEqual))   Wrapping that all up and omitting some of the intermediate steps, you've got:  matches xs ys = length (filter id (map (uncurry (==)) (zip xs ys)))   But I want to clean that up a bit!  So Data.List provides zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]. zipWith lets you specify a function to use to zip two lists together. You could write zip as:  zip xs = zipWith (\a b -> (a, b) ) xs   We can replace the map f (zip xs ys) with a single zipWith f xs ys.   matches xs ys = length (filter id (zipWith (==) xs ys))   Much nicer :) All of those parentheses make me feel like I'm in a lisp or something, so if you're feeling ambitious, you could remove them and use $ instead:  matches xs ys = length $ filter id $ zipWith (==) xs ys   When you have a pattern like f x = h $ g x, you can change the $ to a . and remove the variable name. Haskellers love doing this, so you can also express the above as:  matches xs = length . filter id . zipWith (==) xs   A more experienced Haskeller would see length . filter id and want to turn that into a single foldr. Give that a shot"
haskell,3d8j1c,haskman,10,Tue Jul 14 09:49:56 2015 UTC,"The goal of the game usually is to write your code against a MonadFree f m constraint, meaning the code can work with Free as well as the church-encoded version, F. You get to pick which one by simply using functions from Control.Monad.Free or Control.Monad.Free.Church in the end to run and inspect your computations in the free monad for f.  Edit: of particular interest is improve which takes computations that are not tied to a particular free monad implementation, just the generic interface, and runs those computations against the church-encoded version, to finally hand you back a value in the ""standard"" Free f monad."
haskell,3d8j1c,AlpMestan,5,Tue Jul 14 10:01:45 2015 UTC,"An alternative to using improve is to use liftF to lift computations in your functor into your Free Monad (be it church-encoded or not; anything with an instance of MonadFree works).  To interpret computations in your free monad you can then use one of the iter, iterT, and iterTM methods, which have signatures like:    iterT :: (Functor f, Monad m) => (f (m a) -> m a) -> FT f m a -> m a   This allows you to pattern match on your functor to produce a method like f (m a) -> m a which you give to iter/iterT/iterTM to interpreter programs in the church-encoded free monad."
haskell,3d8j1c,aaronlevin,4,Tue Jul 14 11:55:25 2015 UTC,It seems you want to pattern match or reflect on terms of the free construction. Perhaps you can use an alternative to Free in the line of reflection without remorse or smart views on datatypes which are meant to solve this problem you find with the Church encoding.
haskell,3d8j1c,mcz45,3,Tue Jul 14 15:34:58 2015 UTC,You can have a look at https://github.com/jeffreyrosenbluth/static-canvas/blob/master/src/Graphics/Static/Interpreter.hs#L44 it's pretty simple.
haskell,3d8j1c,martingalemeasure,3,Tue Jul 14 12:31:06 2015 UTC,This just uses the Free datatype. My question is how to use the F type from Control.Monad.Free.Church.
haskell,3d8j1c,martingalemeasure,3,Tue Jul 14 13:22:21 2015 UTC,No it actually uses F: https://github.com/jeffreyrosenbluth/static-canvas/blob/master/src/Graphics/Static/Types.hs#L28
haskell,3d8j1c,RyanGlScott,4,Tue Jul 14 15:20:13 2015 UTC,I think they meant that evalScript converts F into Free so that eval doesn't use the Church encoding.
haskell,3d8j1c,tel,3,Tue Jul 14 16:07:51 2015 UTC,"Yup exactly. As I noted in the original post, I did manage to simply use toF and fromF to get things to work. However I am interested in (now mostly for pedagogical reasons) to implement this function without converting to/from Free."
haskell,3d8j1c,tel,4,Tue Jul 14 17:55:42 2015 UTC,"Others have spoken generally to what you need, but here's a direct answer for interest's sake.  matchF :: Functor f => (a -> r) -> (f (F f a) -> r) -> (F f a -> r) matchF ar fr = go where go f = runF f ar (fr . fmap go)"
haskell,3d55qw,jfredett,72,Mon Jul 13 16:38:41 2015 UTC,Thank you :)
haskell,3d55qw,evanrelf,12,Mon Jul 13 16:53:18 2015 UTC,oh wow this is really gorgeous
haskell,3d55qw,psygnisfive,18,Mon Jul 13 18:31:55 2015 UTC,"The new styling is a lot less compact than the old one.  I dislike that.  Otherwise, it looks nice."
haskell,3d55qw,augustss,16,Tue Jul 14 08:30:41 2015 UTC,"Looks great, but a quick request -- can we turn off the ""new messages"" css popup in the bottom left?  I like to keep somethings in my inbox as ""reminders"" and so now on every page that thing bounces up."
haskell,3d55qw,sclv,6,Mon Jul 13 18:02:22 2015 UTC,I second this. Orange icon in the top right is perfectly enough.
haskell,3d55qw,cies010,1 point,Mon Jul 13 21:11:02 2015 UTC,If you use the Stylish browser extension (Chrome/Firefox/Safari) I'm willing make you a custom style to remove the popup. Let me know if you're interested.
haskell,3d55qw,evanrelf,10,Mon Jul 13 19:11:54 2015 UTC,"I'd rather the popup just be removed for everyone, as it feels gratuitous to me :-)"
haskell,3d55qw,sclv,4,Mon Jul 13 19:47:13 2015 UTC,"To be honest, I really like the popup :) And doing it for you isn't hard or time consuming.   Unfortunately there's no way for me to add an option to toggle it because I can only adjust styling; it has to either be on or off :/  I'd be interested to hear from others how they feel about it. If the majority of people don't like it then we should disable it."
haskell,3d55qw,evanrelf,7,Mon Jul 13 19:54:00 2015 UTC,"I'm a fan of opt-in rather than opt-out, perhaps we can advertise on the sidebar a Stylish extension for the 'directors cut' version of the style?"
haskell,3d55qw,evanrelf,2,Mon Jul 13 22:38:23 2015 UTC,"Yeah, that sounds better. I just wasn't sure if many people would want to install an extension.   I don't want to ask for too much, but would it be possible to add a link in the sidebar to my GitHub repo for the design? Just something small really at the bottom, so people know where to report bugs or feedback once the sticky post is gone."
haskell,3d55qw,evanrelf,2,Mon Jul 13 23:55:40 2015 UTC,"Yah, remind me in the morning / send a modmail, someone will get to it (I'm headed to sleep now)."
haskell,3d55qw,cies010,2,Tue Jul 14 05:22:18 2015 UTC,Sounds good
haskell,3d55qw,Lossy,1 point,Tue Jul 14 06:09:48 2015 UTC,I second this. Orange icon in the top right is perfectly enough.
haskell,3d55qw,gallais,14,Mon Jul 13 21:11:05 2015 UTC,Is there any way to reduce the vertical spacing a bit?
haskell,3d55qw,tomejaguar,3,Mon Jul 13 18:45:32 2015 UTC,^ this  This is #1 reason why I turn off most subreddit styles. Not everyone has a massive screen which can accommodate for extra vertical spacing whilst still displaying a good number of links. I get 60% extra links by turning the style off...
haskell,3d55qw,noteed,17,Tue Jul 14 10:33:23 2015 UTC,I think it looks great too!
haskell,3d55qw,evanrelf,7,Mon Jul 13 16:56:17 2015 UTC,"Well, it's broken for me. My browser (Firefox, Ubuntu) takes the left half of my screen. The different boxes that make the new design overlap a bit and the comments are pushed below the right column (so it was confusing as I saw there were 13 comments but couldn't see any of them before I scroll past the right column)."
haskell,3d55qw,noteed,1 point,Mon Jul 13 18:14:36 2015 UTC,"Despite running Safari on OS X, I am able to reproduce the issue you're describing by resizing my browser window into the corner. Once the window is small enough, all the comments go below the bottom of the sidebar. I also tried this with the theme disabled (default reddit styling) and it still happened, albeit with a slightly smaller window.  I was able to fix this issue by zooming the page to 90% in my browser. Let me know if zooming out fixes your issue."
haskell,3d55qw,togrof,1 point,Mon Jul 13 18:58:37 2015 UTC,"Yes it does solve the issue. Actually the page was zoomed in a bit (I did it in the past and the browser retain the zoom factor per domain). So I guess it's pretty ok for me (although the text is a bit smaller than I would like), thanks. B.t.w. the theme is pretty neat."
haskell,3d55qw,tejon,7,Mon Jul 13 19:48:24 2015 UTC,"Awesome!  And I really like that the ""Constructive"" label has been removed from the upvote, because many things can be constructuve without an upvote."
haskell,3d55qw,sclv,22,Mon Jul 13 17:33:32 2015 UTC,"Is there any chance we can get rid of the flashy upvote animation?  Also, copying in my comment on the proposal thread, since it's all still relevant:   I probably shouldn't have the mod mail icon in the upper right.  Also, the last two icons there are nonstandard and have no tooltips explaining what they are. Wrench-and-screwdriver is probably okay (though that's not a very well-rendered screwdriver), but I was like ""WTF is this power button for?"" and then I was like ""where did it go, why did the UI change?"" and then I figured it out, but that wasn't pleasant. IMO the ""logout"" text is preferable there.   No other complaints, I love the general style!  Edit: okay, one more complaint. :) The contrast between a visited link and regular text is entirely too subtle now, I think."
haskell,3d55qw,tejon,16,Mon Jul 13 18:39:49 2015 UTC,"I like the flashy upvote animation, and like that you don't get it with a downvote. A little psychological push towards more positive rather than negative reinforcement :-)"
haskell,3d55qw,fruitbooploops,3,Mon Jul 13 22:00:07 2015 UTC,"See, that's exactly my problem with it. It's gaudy, unsubtle endorphin bait. I don't want to see it for the same reason I don't want to read ""Could one of these 11 metaphors explain monads? You won't believe #8!""  Collateral damage perhaps, but the loathing is deeply ingrained."
haskell,3d55qw,evanrelf,1 point,Tue Jul 14 02:54:42 2015 UTC,I really don't understand your criticism of them. Is it just that they're not subtle enough?
haskell,3d55qw,tejon,5,Tue Jul 14 03:26:13 2015 UTC,How does this look? I tried adding a light dotted underline to all links: http://i.imgur.com/eSHxVJv.png
haskell,3d55qw,evanrelf,2,Mon Jul 13 19:17:27 2015 UTC,"Huh... actually, your font's different. Looks like the same typeface, but everything's just a hair thicker in your screenshot, which helps immensely -- I can see why you wouldn't have noticed a problem.  That being said, yeah, I think the underlines are great.  Edit: definitely a tiny bit larger, you've got better definition on the permalink/embed/etc. link text too. For reference I'm on Chrome-Win64, all default settings."
haskell,3d55qw,5outh,2,Mon Jul 13 19:35:33 2015 UTC,I'm using Safari 9 on OS X El Capitan.  I'll submit an updated version soon to the mods with underlined links.
haskell,3d55qw,evanrelf,3,Mon Jul 13 19:57:23 2015 UTC,"Looks great, thank you /u/evanrelf!"
haskell,3d55qw,mattygrocks,1 point,Mon Jul 13 20:01:19 2015 UTC,Thanks :) I really appreciate it
haskell,3d55qw,martingalemeasure,6,Mon Jul 13 20:25:04 2015 UTC,It's lovely! Great job!
haskell,3d55qw,clumsyfeet,7,Mon Jul 13 17:21:15 2015 UTC,"awesome job, thanks"
haskell,3d55qw,alt_account10,7,Mon Jul 13 17:48:02 2015 UTC,"The low contrast text is really hard to read, especially with non-ideal screens or lighting conditions. I've been really confused by the trend away from high contrast text (see: Solarized or Zenburn) in recent years."
haskell,3d55qw,lostman_,3,Mon Jul 13 22:03:31 2015 UTC,"Too much space wasted, disabled for me."
haskell,3d55qw,singpolyma,2,Wed Jul 15 10:21:16 2015 UTC,"If it ain't broke, don't fix it! The old theme was just fine."
haskell,3d55qw,lukerandall,8,Tue Jul 14 22:12:23 2015 UTC,Why does Reddit allow these themes?  So confusing.
haskell,3d55qw,singpolyma,16,Mon Jul 13 17:58:19 2015 UTC,You can turn off subreddit themes by going to preferences and unchecking allow subreddits to show me custom themes.
haskell,3d55qw,evanrelf,3,Mon Jul 13 18:14:51 2015 UTC,Thanks!  So much better!
haskell,3d55qw,peargreen,7,Mon Jul 13 20:11:14 2015 UTC,"Adding on to what /u/lukerandall said, if you have Reddit Gold or you have the Reddit Enhancement Suite browser extension installed, you can disable custom styling on a subreddit-to-subreddit basis if you like some themes but dislike others."
haskell,3d55qw,evanrelf,3,Mon Jul 13 19:01:47 2015 UTC,The downward arrow looks weird for me (it displays as “â–¼”) both in Chrome and Firefox:   http://imgur.com/6boxpI3 http://imgur.com/6tqpvFE
haskell,3d55qw,drb226,4,Mon Jul 13 17:20:40 2015 UTC,"hmm, I'm getting that too. paging /u/evanrelf -- what's going on there?  EDIT: Hmm, looks like it might be a copy/paste error on my end. that weird text is in the stylesheet proper.  EDIT2: Found and fixed, a hard-refresh should clear it. (Control + Shift + R, or Command + Shift + R if you're on a mac)."
haskell,3d55qw,drb226,7,Mon Jul 13 17:22:31 2015 UTC,"I think it might be a good idea if I set up a GitHub repo with the stylesheet and images, so that we have a more central place to track issues, and people can contribute if they want to.  EDIT: https://github.com/evanrelf/r-haskell-theme"
haskell,3d55qw,PM_ME_UR_OBSIDIAN,1 point,Mon Jul 13 17:53:43 2015 UTC,"Excellent, I'll add it to the OP."
haskell,3d55qw,evanrelf,3,Mon Jul 13 22:38:57 2015 UTC,"Same. This is what I see in the chrome inspector for ""sorted by"":  .commentarea .menuarea .dropdown.lightdrop .selected:after {   content: ""â–¼"" }"
haskell,3d55qw,ocharles,2,Mon Jul 13 17:26:36 2015 UTC,"should be fixed, looks like some unicode got mangled during my copy-pasting"
haskell,3d55qw,Kah0ona,2,Mon Jul 13 17:28:25 2015 UTC,"That was fast!  .commentarea .menuarea .dropdown.lightdrop .selected:after {   content: ""▼""; }"
haskell,3d55qw,clrnd,1 point,Mon Jul 13 17:29:41 2015 UTC,It looks like shit in RES night mode :/
haskell,3d55qw,Zapman,2,Mon Jul 13 23:33:26 2015 UTC,"If you have the Stylish browser extension installed, you could create a style that uses the stylesheet from /r/NautNight"
haskell,3d55qw,DisregardForAwkward,2,Tue Jul 14 02:59:50 2015 UTC,Fantastic work! Thank you /u/evanrelf!
haskell,3d55qw,yitz,1 point,Mon Jul 13 18:39:03 2015 UTC,Looks good!
haskell,3d55qw,eccstartup,1 point,Mon Jul 13 20:16:45 2015 UTC,applauds
haskell,3d55qw,begriffs,1 point,Mon Jul 13 20:35:01 2015 UTC,"Interesting. So this is based indirectly on Material Design, right? Looks good."
haskell,3d55qw,bitmadness,1 point,Mon Jul 13 20:58:05 2015 UTC,"This look amazing, great job!"
haskell,3d55qw,cies010,1 point,Mon Jul 13 21:45:11 2015 UTC,"Toto, I've a feeling we're not in Kansas anymore."
haskell,3d55qw,tailbalance,1 point,Mon Jul 13 22:09:12 2015 UTC,Great!
haskell,3d9qp5,nulloid,5,Tue Jul 14 16:34:40 2015 UTC,"Weird! To figure out what going on, I'd use cabal -v2 build to see which flags cabal is passing to ghc. This way, you can reproduce its build sequence without having to go through cabal. You should then be able to compare cabal's build sequence with yours and figure out which difference is causing the runtime behavior to be different."
haskell,3d9qp5,gelisam,3,Tue Jul 14 16:56:43 2015 UTC,"Found it! It's the -O flag (same happens with -O2 and -O3). Now I need to track it down. Thanks for your help, you saved me a lot of time! :)"
haskell,3d9qp5,gelisam,1 point,Tue Jul 14 19:01:37 2015 UTC,How I didn't think of that... thank you!
haskell,3d9qp5,sclv,4,Tue Jul 14 17:23:27 2015 UTC,"However, if you use ghc -O main, it won't write out anything, and you have to kill the process through Task Manager.   Try using yield instead of return (). As the documentation for forkIO explains, this forks a lightweight thread, not a system thread, so I guess you need some kind of collaboration between threads in order to ensure that they all make progress. I think the yield usually happens when the stack gets checked for overflow or something like that, which happens at every function call, but that your runForever $ return () has been optimized to a busy loop which does not call anything and therefore never checks the stack nor ever calls yield."
haskell,3d6008,Lossy,16,Mon Jul 13 20:10:03 2015 UTC,"Smart views are faster.. but only assuming the structure is used linearly, that you inspect the monad once,  ephemerally.   If you inspect the structure multiple times they have the wrong asymptotics, which was the problem that the Reflection without Remorse paper set out to solve.  Yes, they pay much worse constant factors 1.5x to 4.6x for that privilege on the benchmarks here, but depending on the usage mode the difference can be asymptotic, and the deque used by the Reflection without Remorse paper isn't, currently, optimal. That said, the efforts folks from the #haskell-lens channel have made to make a usable more optimal Tarjan-Mihaesçu deque have failed to win on the wall clock so far. We need a fast optimal catenable output-restricted deque."
haskell,3d6008,edwardkmett,3,Mon Jul 13 20:47:02 2015 UTC,"for noobs like me:   An output-restricted deque is one where insertion can be made at both ends, but deletion can be made from one end only.   https://en.m.wikipedia.org/wiki/Double-ended_queue"
haskell,3d6008,sambocyn,2,Tue Jul 14 20:28:43 2015 UTC,"That's said in the paper. The goals they mention are providing a fast mechanism if you only care about ""single threaded"" use, but one that's also simple so you can implement it in other use cases."
haskell,3d6008,Darwin226,6,Tue Jul 14 06:00:12 2015 UTC,"It is a reasonable assumption.   It is worth noting, however, this is the exact same approach we used inside the scalaz free monad around 2010 or so. This is mostly a consequence of the fact that we had to use the separate operational-style constructor for binds there to avoid blowing the stack. We wound up forced into this model by the exigencies of working in a strict language without proper tail call optimization.  I guess I'm struggling to see what is ""new"" here beyond formalizing what you want to allow the user to extract out of the data structure with a view."
haskell,3d6008,edwardkmett,9,Tue Jul 14 06:12:04 2015 UTC,It is a functional pearl. This means it does not have to be new from a research point of view.  If you are looking for earlier uses of this approach: Hinze already used a :>>= constructor in his 2000 Deriving Backtracking Monad Transformers.
haskell,3d6008,tschrijvers,3,Tue Jul 14 10:47:21 2015 UTC,Good point.
haskell,3d6008,edwardkmett,7,Tue Jul 14 12:06:56 2015 UTC,When was this written?  Serious sub-question: Why don't people date their articles?
haskell,3d6008,chreekat,3,Tue Jul 14 14:16:53 2015 UTC,"The footnote suggests it's for ICFP 2015.  It'd be nice for papers to at least have an explicit ""draft as of"" date in a prominent location."
haskell,3d6008,conklech,6,Tue Jul 14 17:59:25 2015 UTC,Dammit I should write some fluff paper on PatternSynonyms to reap the sweet citation karma...
haskell,3d6008,gergoerdi,5,Tue Jul 14 05:21:16 2015 UTC,"Write one about using PatternSynonyms to make ""Datatypes a la Carte"" less intrusive!"
haskell,3d6008,rpglover64,5,Tue Jul 14 14:10:26 2015 UTC,Oh my god I can't believe I just found out about PatternSynonyms.
haskell,3d4u3x,DrBartosz,7,Mon Jul 13 15:12:38 2015 UTC,This is great! It's a subject that is quite fascinating and that I am only recently getting familiar with. I started writing a Lens tutorial (https://github.com/ajnsit/haskell-tutorials/blob/master/lenses-from-scratch.md) after watching Edward's talk (http://www.youtube.com/watch?v=cefnmjtAolY) which follows a similar course. I hope you won't mind if I borrow some bits from your writeup (with attribution of course).
haskell,3d4u3x,haskman,7,Mon Jul 13 17:31:53 2015 UTC,I only understood lenses after Simons Talk for Humans .. :)  https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
haskell,3d4u3x,Drezil,2,Mon Jul 13 19:37:42 2015 UTC,/u/haskman Typo?  in the From traverse to Setter part of the Setter section:  type Setter s t a b = Applicative m => a -> m b -> s -> m t   Should read   type Setter s t a b = Applicative m => (a -> m b) -> s -> m t
haskell,3d4u3x,_AndrewC_,2,Tue Jul 14 19:19:13 2015 UTC,"Thanks, fixed!"
haskell,3d4u3x,haskman,2,Tue Jul 14 19:48:29 2015 UTC,Thanks for the good read.
haskell,3d4u3x,_AndrewC_,3,Wed Jul 15 00:54:10 2015 UTC,"At a high level, lenses allow you to write APL style functions where they bind at the appropriate sub-object of the data type?"
haskell,3d4u3x,crb002,3,Mon Jul 13 19:42:57 2015 UTC,"I love these articles, thank you, and I have a special fondness for the hand - drawn diagrams."
haskell,3d4u3x,_AndrewC_,2,Tue Jul 14 19:23:00 2015 UTC,This is very nice.  So what is right adjoint to Flapp b?
haskell,3d4u3x,roconnor,2,Wed Jul 15 04:30:20 2015 UTC,"I have no idea. One would think it should have something to do with prism. But I don't think it does.  Lens has this nice factorization property:  Lens s t a b = s -> IStore a b t, which makes IStore a ""root"" of lens . But its dual, prism, doesn't factorize:  Lens:            Prism: s -> a           a -> s (s × b) -> t     t -> (s + b)   There's no cute algebraic identity for s^a × (s + b)^t, like the one for lens:  a^s × t^(s × b) = (a × t^b)^s = (IStore a b t)^s"
haskell,3d4u3x,roconnor,2,Wed Jul 15 15:18:42 2015 UTC,"The answer seems to be PCont, the parameterized continuation monad, is right adjoint to Flapp  newtype PCont a b x = PCont (x -> b) -> a   If I've done my math right, then Flapp b f -> a should be isomorphic to forall x. f x -> PCont a b x which you can argue using CoYoneda.  This is interesting because PCont came up in implementing a version of sec using the profuctor version of SECs.  I was kinda hoping this would yield prisms, but I agree with you that it doesn't seem to."
haskell,3d5im6,mightybyte,3,Mon Jul 13 18:09:44 2015 UTC,Something went wrong with the generated Haddocks; there are no type links except to base and within the package.
haskell,3d5im6,conklech,2,Mon Jul 13 21:17:38 2015 UTC,"Hmmm, I'll take a look when I get a chance.  Thanks for the heads-up."
haskell,3d3e95,haskman,12,Mon Jul 13 05:07:27 2015 UTC,"+10 for changing the name.   +1 for hastack - seems most unique to me.   -1 for haystack  But actually, I really liked the name stackage and the stk short for the executable was very convenient."
haskell,3d3e95,mallai,12,Mon Jul 13 13:51:29 2015 UTC,"Maybe its because I use Google, maybe its because of how it has personalized my search, but my search engine seems to know exactly what stack is and has it as the top several links (https://www.google.com/search?q=haskell+stack)"
haskell,3d3e95,sseveran,29,Mon Jul 13 05:59:27 2015 UTC,"The problem is not searching for ""haskell stack"" – which is something you presumably do only one time. The problem lies in searching for ""haskell stack <problem>"" where the stack hits has to compete with the stack hits and the stack hits, making solving the problem harder."
haskell,3d3e95,kqr,24,Mon Jul 13 07:01:53 2015 UTC,"It's a collision that doesn't need to exist. There are numerous examples of where things could go wrong -  What if I wanted to get search results for how haskell manages the function call stack? Or how about searching for the ideal web development stack using haskell? What if searching for ""transformer stack"" starts getting stack-the-tool references. Or what if the user wants to search for a stack config file to work with the ""transformers library"", and gets only monad-transformers references?"
haskell,3d3e95,sseveran,5,Mon Jul 13 06:28:15 2015 UTC,I agree in theory. I was going to be working on something called hake which was very much like stack when Michael told me about stack and we dropped it. For me the name was not the right thing to optimize for.
haskell,3d3e95,tejon,16,Mon Jul 13 06:32:14 2015 UTC,Likewise.  Also I am deeply offended that none of my fantastic suggestions here made it into this post! The nerve!
haskell,3d3e95,tejon,24,Mon Jul 13 06:17:51 2015 UTC,"Ha ha I do like ""plz"". ""plz build"", ""plz install"", is what actually goes through my mind when I am trying to compile."
haskell,3d3e95,get-your-shinebox,3,Mon Jul 13 06:30:11 2015 UTC,"plz was probably my favorite too, followed by mo just because it demands an auxiliary tool called nad.  /u/yitz's dude suggestion also seems popular. I had thought of that, but ""haskell dude"" seemed like a search that should be left pristine. On the other hand, if nobody else cares about that aspect, I think I'd vote for it. :)"
haskell,3d3e95,leperLlama,1 point,Mon Jul 13 14:07:32 2015 UTC,also can the plz use the narwhal logo?  http://images.uncyclomedia.co/uncyclopedia/en/8/85/NarleyYeeaaahh.jpg
haskell,3d3e95,arianvp,5,Mon Jul 13 23:25:47 2015 UTC,"If it's because google has personalized your results then beginners without personalized results will be the ones missing out on it. For what it's worth I also get haskell-stack results first, although I have downloaded and played with it already.  I also am in favor of some kind of name change if only because I don't want to ever have to clarify myself when discussing this, e.g. ""No haskell stack for function calls, not the tool""."
haskell,3d3e95,cocreature,19,Mon Jul 13 09:24:22 2015 UTC,Stack is indeed too generic to my taste.  Name it to something category theoretic?
haskell,3d3e95,sclv,32,Mon Jul 13 06:45:13 2015 UTC,costack?
haskell,3d3e95,arianvp,13,Mon Jul 13 06:57:17 2015 UTC,"Stacks are a categorical concept, and a pretty fancy one at that! Sort of a higher sheaf, or generalized scheme..."
haskell,3d3e95,pharpend,26,Mon Jul 13 07:22:31 2015 UTC,so... A stack is just a pile in the category of endodependencies?
haskell,3d3e95,kqr,1 point,Mon Jul 13 07:26:55 2015 UTC,*endocodependencies
haskell,3d3e95,sclv,7,Tue Jul 14 17:36:50 2015 UTC,"""Sheaf"" would not be a bad name for Stack, actually."
haskell,3d3e95,jonsterling,13,Mon Jul 13 12:33:16 2015 UTC,"Delightfully, a sheaf itself can arise over a bundle. So this is a... not terrible metaphor?"
haskell,3d3e95,sclv,6,Mon Jul 13 15:03:09 2015 UTC,LOVE love love this idea  edit: but I would be so damned depressed if I started seeing Haskell nonsense in the results when I searched about sheaves.
haskell,3d3e95,kqr,5,Mon Jul 13 15:25:45 2015 UTC,"as opposed to, say, pictures of wheat? :-P"
haskell,3d3e95,geggo98,2,Mon Jul 13 18:01:19 2015 UTC,"It can also be pronounced similar to ""chief"", which is not too bad."
haskell,3d3e95,_AndrewC_,6,Mon Jul 13 15:08:10 2015 UTC,"Hm, this might be a hylomorphim. But this term is already taken in Haskell and it is really hard to type."
haskell,3d3e95,beefsack,5,Mon Jul 13 07:27:50 2015 UTC,Irrelevant anecdote: The hylomorphism I'm most proud of was this stack overflow answer to parsing Karva notation in linear time without using mutation.   I'll know I've arrived when I've written a zygohistomorphic prepromorphism I can be proud of.
haskell,3d3e95,cies010,17,Mon Jul 13 09:06:42 2015 UTC,Hastack.
haskell,3d3e95,kaukau,14,Mon Jul 13 08:19:04 2015 UTC,Stack 216M hits and Haystack 7M hits on google. Hastack only 27k hits.
haskell,3d3e95,gmfawcett,6,Mon Jul 13 09:41:02 2015 UTC,Hastack   It's too close to happstack in my opinion.
haskell,3d3e95,quiteamess,1 point,Mon Jul 13 16:47:03 2015 UTC,"Similar names; but each would be perfectly searchable, without ambiguity.  I like Hastack, but I'll throw out some unpronounceable alternatives:   Haskstack Stackskell Haskstackskell shaskelltack instance BuildTool Stack   And one not-so-bad one:   stacktool"
haskell,3d3e95,evohunz,8,Mon Jul 13 17:25:59 2015 UTC,"It should rather be called ""needle""."
haskell,3d3e95,radix,7,Mon Jul 13 07:44:43 2015 UTC,https://duckduckgo.com/?q=haskell+stack  Results:   Stack overflow - HaskellWiki - http://www.haskell.org/haskellwiki/Stack_overflow Stack - HaskellWiki - https://wiki.haskell.org/Stack Abstract data type - HaskellWiki - http://www.haskell.org/haskellwiki/Abstract_data_type MonadStack - Hackage - https://hackage.haskell.org/package/MonadStack AUR - haskell-stack - https://aur.archlinux.org/packages/haskell-stack/ Newest 'haskell' Questions - StackOverflow - http://stackoverflow.com/questions/tagged/haskell stack - Hackage - https://hackage.haskell.org/package/stack
haskell,3d3e95,ephrion,1 point,Mon Jul 13 16:05:51 2015 UTC,"It'll get there eventually.  By the way, this is exactly why I stopped using DDG in general: it was always far behind the times when it comes to relevance. Stack is not unique here. Even if you compare it to un-personalized google."
haskell,3d3e95,emarshall85,7,Mon Jul 13 22:37:17 2015 UTC,"It's important to consider that the name of the executable does not need to be the name of the tool. leiningen's executable is lein. Bundler's executable is bundle. If the name of the tool/project is easy to google and unique, then the name of the executable doesn't have to be as much"
haskell,3d3e95,reaganveg,13,Mon Jul 13 15:14:00 2015 UTC,"Please don't. Haystack is already well-known in the python community (indeed, we use it here at work).  Even if I think the name is a  bit generic, a) it's as many letters as cabal, so just as easy to type, and b) searching for ""haskell stack"" yields the first 4 results as relevant (as of7/13/15)."
haskell,3d3e95,Ancipital,1 point,Mon Jul 13 12:06:02 2015 UTC,"I clarified the searchability point in my post above. Haystack has no haskell connotations and does not collide with any known haskell concepts.  The command line tool may be shorter (say ""hstk""), but that's a matter of personal preference."
haskell,3d3e95,kraml,5,Mon Jul 13 13:24:28 2015 UTC,"Well, this was also my reaction at the time of the release.  It's a poorly chosen name for search results.  However, ""haystack"" is no good.  The idea behind the name ""stack"" is that it provides the complete stack (both GHC and libraries) for the programmer.  ""Haystack"" implies search, which has nothing to do with stack.  So, that name is even worse.  Although, perhaps it could be nick-named ""needle"" because it's so hard to find the search results ;)"
haskell,3d3e95,kaukau,2,Mon Jul 13 11:00:30 2015 UTC,'plz' is still my favorite.
haskell,3d3e95,reirob,2,Mon Jul 13 19:58:17 2015 UTC,"I don't think the meaning of the word matters. There is apt, yum, and even cabal out there, names I have no clue how they came about, which is no problem whatsoever.   Just pick something more unique with a good two or three letter shortcut."
haskell,3d3e95,codygman,1 point,Mon Jul 13 21:50:48 2015 UTC,"I understand the reasoning behind stack. However a less generic name can be picked for the same concept. How does hstack sound to you?  Also as an example, ""cabal"" has a meaning which has nothing to do with package management, however it works pretty well because it's distinct."
haskell,3d3e95,maninalift,6,Mon Jul 13 13:33:03 2015 UTC,"I like stack, it's sounds quite good IMO. I had not problem Googling it, but as suggested that might not be always the case. Alternative name: sinc (accronym of sinc is not cabal :)  Why not staying in the same (or opposite) connotation than cabal?   myst conspire light illum (or better hylum)   BTW, I'm interested in knowing where does the name cabal comes from :)"
haskell,3d3e95,jaredtobin,1 point,Mon Jul 13 17:13:19 2015 UTC,What about complot?
haskell,3d3e95,herbadah,4,Mon Jul 13 23:08:25 2015 UTC,"I prefer something short like stack or cabal personally, even though it's harder to Google. Though, checkout the SERP (search engine results page, haven't used that acronym in a while!) for Google and you'll see that it gets mostly the right results.  How relevant is the searchability of stack after the news about moving stack into the Haskell platform?"
haskell,3d3e95,_AndrewC_,6,Mon Jul 13 08:37:31 2015 UTC,"I like it.... short for ""haskell-functional-stack""? with ""functional"" being written as a lambda, spun 180 so it appears to be a ""y"".  Indeed I agree it seems worth the pan of renaming at this early stage to avoid the pain of searching for related information, which even if it is slight will be multiplied by many users and many years."
haskell,3d3e95,herbadah,3,Mon Jul 13 12:37:52 2015 UTC,IMO the collision 'issue' is not actually an issue in this case.  I think 'stack' is fine.
haskell,3d3e95,chrisdoner,18,Mon Jul 13 17:52:35 2015 UTC,"""st4ck"" is way better and is wicked leet.  feckin right buddy, those google searches will be so relevant my bitcoin startup will write itself."
haskell,3d3e95,kraml,8,Mon Jul 13 06:39:29 2015 UTC,"I think you mean it will rite itself, don't you?"
haskell,3d3e95,hiptobecubic,0,Mon Jul 13 07:07:16 2015 UTC,"I'm just giving him or her the needle, that's all.  Someone's got to do it. rite. oi."
haskell,3d3e95,jaredtobin,17,Mon Jul 13 07:25:13 2015 UTC,That ship has sailed.
haskell,3d3e95,hiptobecubic,4,Mon Jul 13 08:13:05 2015 UTC,No way it has sailed. The project is still very young and not that widespread. Scattering some permanent redirects should help the transition.
haskell,3d3e95,jimpeak,1 point,Mon Jul 13 21:52:58 2015 UTC,Can you elaborate?
haskell,3d3e95,MileyCylon,5,Mon Jul 13 13:11:14 2015 UTC,He thinks it's too late to change it now. Which is pretty unlikely if there were buy-in from the stack folks themselves.  edit: typo
haskell,3d3e95,agumonkey,5,Mon Jul 13 13:51:12 2015 UTC,Pretty sure he's one of the stack folks.
haskell,3d3e95,tejon,3,Mon Jul 13 17:48:23 2015 UTC,Sure. I'm just saying that renaming the tool is not impossible if they were to decide that they want that. You just do it and people will get used to the new name because they will want new features.  It's not like we're talking about a mission critical piece of software that's been in production for years in systems no one understands.
haskell,3d3e95,agumonkey,3,Tue Jul 14 06:01:56 2015 UTC,"Google named their own language Go and it's thriving despite being unsearchable at first. I think Haskell will survive having one of its tool's name being too generic (of which Go doesn't have any, pun intended)."
haskell,3d3e95,Aoi32,7,Mon Jul 13 14:06:51 2015 UTC,"That’s partly mitigated by the fact that you can search for “golang” instead of “go”. What qualifiers can we add to “stack” to avoid getting results for e.g. monad transformer stacks?  I just feel that with stack so early in its life right now, there’s no reason to accept a name that’s so inconveniently generic."
haskell,3d3e95,ilmmad,1 point,Mon Jul 13 17:26:12 2015 UTC,"""Go"" is a remarkably generic name. I almost always search for ""golang"". The name ""go"" was also quite unpopular (https://code.google.com/p/go/issues/detail?id=9), but Google decided to stick to the name for reasons unknown."
haskell,3d3e95,drwebb,5,Tue Jul 14 08:53:01 2015 UTC,I propose kcats  ps: surprisingly common
haskell,3d3e95,sseveran,1 point,Mon Jul 13 06:15:13 2015 UTC,"That's... not bad, heh."
haskell,3d3e95,mallai,3,Mon Jul 13 06:19:42 2015 UTC,or skat ~_~;
haskell,3d3e95,alan_zimm,2,Mon Jul 13 06:41:10 2015 UTC,No small part of me wants to tell a new Haskell developer to plz install. I don't think they would take me seriously.
haskell,3d3e95,RedLambda,3,Mon Jul 13 16:28:20 2015 UTC,Right now the problem is that people thing Haskell is too serious :P
haskell,3d3e95,theonlycosmonaut,3,Tue Jul 14 04:25:57 2015 UTC,"Well ""haystack"" conjures up images of farmers tending their crops in my mind. I don't think it's worth renaming a growing project at this point, it's just going to confuse people."
haskell,3d3e95,leperLlama,15,Mon Jul 13 05:45:21 2015 UTC,Although if it was going to be renamed this would be the best time. The smallest number of people would be confused.
haskell,3d3e95,jrk-,10,Mon Jul 13 05:57:40 2015 UTC,The best time was a month ago. The second best time is now.
haskell,3d3e95,tomejaguar,2,Mon Jul 13 06:30:58 2015 UTC,definitely before it gets into haskell platform....
haskell,3d3e95,emarshall85,8,Mon Jul 13 16:25:03 2015 UTC,"To me it immediately brings the word ""needle"" to mind, and the needle in the haystack is the one install plan that actually works."
haskell,3d3e95,smog_alado,3,Mon Jul 13 07:13:23 2015 UTC,"So hackage is the haystack and stack should rather be called needle, and then the invocation could be needle find yesod..."
haskell,3d3e95,emarshall85,5,Mon Jul 13 08:39:39 2015 UTC,This metaphor is rapidly becoming untenable.
haskell,3d3e95,smog_alado,2,Mon Jul 13 09:22:41 2015 UTC,"haystack find yesod works also. This would imply you were looking for yesod within the haystack, not looking for a needle called yesod."
haskell,3d3e95,emarshall85,-6,Mon Jul 13 09:26:36 2015 UTC,"Edit: Ok, sorry, I apologize. This was inappropriate."
haskell,3d3e95,rdfox,1 point,Mon Jul 13 09:47:01 2015 UTC,"Err, what?  Get this off Haskell Reddit please."
haskell,3d3e95,trezor2,1 point,Mon Jul 13 12:14:49 2015 UTC,"Just noting the irony of trying to redeem yourself of being considered racist by using ""servant"" as a ""non-offending"" term to replace ""nigga"".   Only thing worse might have been ""slave"". That said, had you not made the original joke in poor taste, I don't think servant would have been offensive.   It is, however, already taken."
haskell,3d3e95,MileyCylon,-1,Mon Jul 13 12:14:21 2015 UTC,"In the internet, no one knows you are white.  So its not actually racist."
haskell,3d5kdm,ecognium,2,Mon Jul 13 18:21:31 2015 UTC,"Here is my Stack Overflow post: http://stackoverflow.com/questions/31359894/catching-an-exception-from-rundb. I was not sure if I put my link on my original post, whether it will be get flagged or not."
haskell,3d5kdm,roche,2,Mon Jul 13 18:23:58 2015 UTC,The standard try works in pure IO. You may want try from the lifted-base package.
haskell,3d5kdm,sccrstud92,2,Mon Jul 13 19:54:51 2015 UTC,I am using try from the lifted base package (Control.Exception.Lifted). I don't really understand what the error message is telling me.
haskell,3d5kdm,sccrstud92,2,Mon Jul 13 20:18:45 2015 UTC,What is LiftIO?  EDIT: In fact an import list would be helpful to see where you are getting your functions from.
haskell,3d5kdm,sccrstud92,2,Mon Jul 13 22:15:53 2015 UTC,"sorry/u/sccrstud92  that was a typo (the issue of manually typing it here to simplify things).  I am getting liftIO from here:  Control.Monad.Reader  All the stuff inside runMaybeT are Persistent statements specific to my model. If any of them returns a Nothing I want to throw an exception so runDb will rollback the transaction.    This code works fine without exception handling. Of course, it will not send any meaningful error message back to the client as to why it failed (could be a form validation failure or db unique constraint failure).  I am trying to distinguish between these two failures. If there is an exception, I want to check for the validation errors list and if it is empty, I know it is a db failure (these types of errors should be rare and will happen only when someone tried bypassing the client interface and post to the api directly   I have added import specific to the functions used."
haskell,3d5kdm,sccrstud92,1 point,Mon Jul 13 23:08:25 2015 UTC,"You're getting liftIO from Control.Monad.Reader? I don't see than anywhere.  EDIT: Oh I see, it's a re-export from Control.Monad.Trans, and from there it's from Control.Monad.IO.Class."
haskell,3d5kdm,hdgarrood,1 point,Mon Jul 13 23:16:00 2015 UTC,"Okay, I think the problem is the top-most liftIO.  liftIO :: (MonadIO m) => IO a -> m a   liftIO can only be applied to IO actions. You are applying it to an action that uses runDb. runDb obviously runs in something more complicated than IO. The error is saying that IO is not an instance of MonadReader Config. It thinks you are in IO because of liftIO (and probably your type signature), and it needs an instance of MonadReader Config because of asks in runDb.   My proposed solution to fix this specific error is to not use liftIO and get rid of your IO (Either MyException Auth signature. If you need the Either MyException Auth bit for some reason, you can stick that in the case expression."
haskell,3d5kdm,sccrstud92,1 point,Mon Jul 13 23:28:40 2015 UTC,"Thanks, /u/sccrstud92. I will try removing the liftIO and let you know what happens.  I added the type annotation because  GHC was complaining the Exception was ambiguous.   I did not realize I could do case (eauth :: (Either MyException Auth)) of so I will try it there to see if it helps."
haskell,3d32li,hamishmack,15,Mon Jul 13 03:18:50 2015 UTC,"Theres still lots to do, but I think this version is a big step up from 0.15.0.0, so I am posting it here.  A big thanks to all those who contributed (directly or indirectly)!  As well as some new contributors to the code, we had some good feedback from users on features to add and some really excellent bug reports.  I have switched on the threaded RTS.  This makes Leksah faster, but in the past has contributed to some stability problems relating to using Gtk+ on multiple OS threads by mistake.  I think most of these have been sorted, but if Leksah crashes and gives you a stack trace, that trace is like gold dust to us (please file an issue).  If you can reproduce the crash you can be a hero!"
haskell,3d32li,schellsan,6,Mon Jul 13 03:33:38 2015 UTC,Does Leksah support plugins? Also - does it provide a vim-mode? I'm hamstringed without my vim movement.
haskell,3d32li,cies010,5,Mon Jul 13 16:34:15 2015 UTC,"Does Leksah support plugins?   No. Leksah is written in Haskell, so for plugins also written in Haskell, a plugin interface might just get in the way.  It would be possible to add one though using something like hint or the JavaScriptCore engine included in Leksah and GHCJS.   Also - does it provide a vim-mode?   Only via Yi and the Yi integration is currently broken and needs someone to rescue it."
haskell,3d32li,cies010,6,Mon Jul 13 16:52:46 2015 UTC,Interesting: I just found out Leksah depends on some packages of the Yi editor :)  I did not know that...  Question: what does Leksah currently use integrating with the GHC? (what many Emacs users accomplish with ghc-mod)
haskell,3d32li,agocorona,5,Mon Jul 13 14:10:08 2015 UTC,Interesting: I just found out Leksah depends on some packages of the Yi editor :) I did not know that...   Sadly the Yi integration just a proof of concept.  It would be great if someone had time to make it usable.   Question: what does Leksah currently use integrating with the GHC? (what many Emacs users accomplish with ghc-mod)   It has its own system (leksah-server) that uses Haddock and GHC-API.  Before it starts it cabal unpacks the source for everything in you your ghc-pkg list then indexes it.
haskell,3d32li,agocorona,2,Mon Jul 13 16:59:56 2015 UTC,Thanks for this!
haskell,3d32li,pythonista_barista,4,Mon Jul 13 17:01:49 2015 UTC,Thanks a lot. I had some problems with the refreshing speed on Windows and some task in the background that slow down everything after some time running it. But still is the best IDE. I hope that some of these problems have been alleviated now.
haskell,3d32li,pythonista_barista,5,Mon Jul 13 14:11:46 2015 UTC,I had some problems with the refreshing speed on Windows and some task in the background that slow down everything after some time running it.   Yeah I think we might have a space leak somewhere.  I suspect it might be related to the background build.  I find if I leave Leksah running over night it sometimes seems broken in the morning.  I'm off to bed now so I will repeat that test now.
haskell,3d3uco,sammecs,9,Mon Jul 13 08:31:40 2015 UTC,"I'm not totally clear on what the idea is, maybe you can clarify? I can see some situations in which countdowns would be cool in an environment like twitter, but I can't really picture them as the core datatype of social media network. It sounds like what you're describing is isomorphic to a calendaring service that allows subscriptions to other users calendars, is that right?  If you only mean to write this thing to practice your Haskell, that's definitely cool and I support you. I just don't understand the end-user experience from a product perspective, if you're serious about taking it live eventually."
haskell,3d3uco,danielsmw,3,Mon Jul 13 08:39:25 2015 UTC,"Yes, it is like a calendaring service. I think the difference is that, like leperLlama pointed out, it is not really for personal organisation, but for group events. It isn't really oriented on making money, it's just a fun project... for now, at least. We'll see what the future brings."
haskell,3d3uco,tejon,5,Mon Jul 13 10:25:33 2015 UTC,Maybe make a github repository so the interested-but-not-committed can star/watch it?
haskell,3d3uco,cynede,3,Mon Jul 13 18:44:24 2015 UTC,only if js level will be ghcjs or purescript or anything like that :) and css is by something alike clay
haskell,3d3uco,boywiththegoldenmind,2,Mon Jul 13 10:06:02 2015 UTC,great idea!. I think that it could be great oportunity for increase popularity of purescript and web solutions in haskell.
haskell,3d3uco,leperLlama,2,Mon Jul 13 11:27:46 2015 UTC,"I've actually been thinking about something like this recently. The way I've been phrasing it is as a matchmaking system like for video games, or a non-regular meetup.com.  The motivation is that without a matchmaking system video gamers that want to play but don't know about each other still cannot play. The matchmaking system enables collaborative activities that otherwise would not have occurred. These systems exist for video games but not for most other activities. The key use case I had in mind for my own use was, in your words, a countdown to watching a movie or reading a book, so that other people could join in and we'd have people to discuss the activity with.  In short, trying to enable the network effect.  If you're creating some sort of mailing list or other online meeting ground feel free to send me a link. I can't promise I'll code but I'd be happy to help discuss ideas."
haskell,3d3uco,autowikibot,2,Mon Jul 13 09:33:45 2015 UTC,"Network effect:       In economics and business, a network effect (also called network externality or demand-side economies of scale) is the effect that one user of a good or service has on the value of that product to other people. When a network effect is present, the value of a product or service is dependent on the number of others using it.   The classic example is the telephone. The more people who own telephones, the more valuable the telephone is to each owner. This creates a positive externality because a user may purchase a telephone without intending to create value for other users, but does so in any case. Online social networks work in the same way, with sites like Twitter and Facebook becoming more attractive as more users join.  The expression ""network effect"" is applied most commonly to positive network externalities as in the case of the telephone. Negative network externalities can also occur, where more users make a product less valuable, but are more commonly referred to as ""congestion"" (as in traffic congestion or network congestion).    Image i - Diagram showing the network effect in a few simple phone networks. The lines represent potential calls between phones.     Relevant: Internet exchange point | Transport network | Reed's law | List of network theory topics   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3d3uco,dbushenko,1 point,Mon Jul 13 09:35:43 2015 UTC,Do you have your technologies stack already chosen or we may discuss that? Anyway I like the idea and will consider joining after you publish your next steps.
haskell,3d3uco,itkovian,1 point,Mon Jul 13 08:48:10 2015 UTC,Sounds like a cool idea. Please continue.
haskell,3d3uco,theonlycosmonaut,1 point,Mon Jul 13 08:55:11 2015 UTC,That's kind of a cool idea. Best of luck!  Have you considered countdowns which might have geographical variation? Like anything related to satellites/astronomy?
haskell,3d3uco,SeriousBug,1 point,Mon Jul 13 09:34:36 2015 UTC,"Sounds nice. Do you have any frameworks or libraries in mind? I don't have much experience with Haskell, but I'd love to contribute if it is going to be open source."
haskell,3d3uco,Ankhers,1 point,Mon Jul 13 11:17:36 2015 UTC,This could be interesting. Send me a message when you are getting started.
haskell,3d3uco,mcapodici,1 point,Mon Jul 13 15:50:00 2015 UTC,I would be interested in helping. Experienced C#/web dev. Quite new to Haskell but keen to learn. Feel I have learned enough about Haskell to write some lines of production code.  I will send you a PM with my contact details.
haskell,3d3uco,dllthomas,1 point,Mon Jul 13 23:34:44 2015 UTC,"Reading the subject, I envisioned a p2p social network configured by compiling Haskell (like xmonad), and was intrigued.  Disappointed on reading the fuller post, though I'm not sure I have any right to be.  I certainly wish y'all the best of luck :)"
haskell,3d3uco,mrkaspa,1 point,Tue Jul 14 06:22:17 2015 UTC,"Yesod takes about 15 seconds per reload even if you only modified a template, honestly I think haskell is not suited for agile development."
haskell,3d3uco,codygman,1 point,Tue Jul 14 14:40:27 2015 UTC,Just use ghci and live reloading:  http://www.reddit.com/r/haskell/comments/3ddcrw/does_haskell_have_slow_iteration_times_are_those/ct420d5  I was wondering the same thing before this post.
haskell,3d3qnz,aviaviaviavi,6,Mon Jul 13 07:40:56 2015 UTC,"I've rewritten a CakePHP app with yesod. It was a good experience, and I would do it again (but at this point in time I only work on haskell apps, so there are none left to rewrite). Since you've only got 1500 LoC, it's probably still possible at this point. If it's important to use heroku, that might be some sort of barrier. I've never deployed a haskell web app to heroku, but it seems a little tricky. My deployment usually involves these:   Server in the cloud (at rackspace) running Ubuntu nginx (for reverse proxy and SSL termination) upstart job   The Deploying your Webapp page in the yesod book gives an example of how to do the latter two. If heroku isn't as important to you, then things will be much easier."
haskell,3d3qnz,andrewthad,1 point,Mon Jul 13 12:57:12 2015 UTC,"haskell-on-heroku is still on GHC 7.8.4 and requires some minor hoop-jumping to build things -- it assumes a heroku build session time limitation which as far as I can tell no longer exists, so you have to override some defaults to make it just build everything instead of trying to run in stages; but it's all documented and works fine. Currently powering the /u/whatarethebest bot."
haskell,3d3qnz,tejon,6,Mon Jul 13 18:49:53 2015 UTC,"Swapping out a live server for a new one just seems plain tricky. That one is not a Haskell related fear.   Yeah that sounds tricky in general, especially with a managed environment like Heroku. I suppose, if you have a domain name for the app, that you could keep running the current application, deploy a new version that operates on the same database etc., then point the domain name at the new one, and users would gradually switch over as their DNS resolution caught up...  ...I might be making that up, but it makes sense in my head."
haskell,3d3qnz,theonlycosmonaut,4,Mon Jul 13 09:28:26 2015 UTC,"Firs of all, try to think of it as a gradual change. If you have several subdomains for your service, migrate one at a time for example.  I'd code a functionality, deploy it in a heroku thing (and check how halcyon manages that), redirect the domain and test it.  Then repeat for other parts.  I also agree that 1500 lines is not a lot, it'd be a great exercise to learn real world haskell.  About the hash lib, you probably have the same one already in a hackage library, if not coding it yourself is not that hard. Remember that this things take into account some global variables, like a salt maybe. And you can always test this yourself.  Regarding your last point, I've rewritten CLI tools in haskell (previously written in python) and always ended up very happy about my choice (which as a haskell fan may not be a great deal anyway)."
haskell,3d3qnz,clrnd,5,Mon Jul 13 13:10:03 2015 UTC,"1500 lines of Python is not a lot of code to rewrite, especially if done by the person who originally authored the project.  1000 lines of code is usually the sweet spot for rewriting a Python program, because that's roughly the point where the code starts to become difficult to maintain.  The longer you wait to rewrite the more difficult it will be to fix later.  I've rewritten a similar amount of Python code to Haskell so I'm speaking from experience."
haskell,3d3qnz,Tekmo,2,Mon Jul 13 13:23:24 2015 UTC,happy cake day!
haskell,3d3qnz,mstksg,1 point,Tue Jul 14 04:31:02 2015 UTC,Thank you! :)
haskell,3d3qnz,Tekmo,3,Wed Jul 15 22:07:29 2015 UTC,"Switching to a new library without making everyone reset their passwords seems like a potential pain point   If you're using a standard hash function, it's probably implemented in Haskell already. If it's nonstandard, you can reproduce it in Haskell."
haskell,3d3qnz,ignorantone,3,Mon Jul 13 09:19:00 2015 UTC,"It's likely that you can use openssl at the terminal and just play around with the hashing algorithms to make sure you can get the same hash. In my experience, I've found that it's easier to do this first and then play with haskell's crypto libraries."
haskell,3d3qnz,andrewthad,5,Mon Jul 13 17:37:55 2015 UTC,Heroku looks like a solved problem at least: https://haskellonheroku.com/
haskell,3d3qnz,b00thead,5,Mon Jul 13 13:14:28 2015 UTC,"I've been in a similar situation, migrating a cronjob script built with PHP to Haskell. Although using a selfmanaged VPS instead of Heroku, and the app was not a realtime service like yours.  For building and deployment I'm using Docker. Using a separate container to build the binaries with cabal, then copying the resulting binaries to a clean Docker debian image, with just a few libs installed with apt-get (mysqlclient, etc), to reduce imagesize. Probably could be optimized by using a base image with all haskell libaries, and a small dynamically linked image. For now I'm just optimizing for build time and ease of use.  As for the codebase, it took about a year time to build the Haskell version due to being a complete newbie, and working a few days on it, then getting stuck and needing to learn more about haskell and the differences in building software compared to PHP (which is based on OOP, variables, loops, dynamic typing, using printf to check if your function is called with the right values, etc). There was no pressure/deadline so it wasn't a real big problem, it's just part of the process I guess.  My takeaway from the PHP -> Haskell conversion:   In the process I've discovered a few bugs in the original PHP codebase while comparing output from both versions. Most of them having to do with unexpected side-effects and mutability. The typesafety of Haskell makes me feel more confident about the quality of the new version. It has been running for a few months without any problem. I've only had a bug that could probably have been avoided by using more strong typing (just plain lists were used and got mixed up, instead of giving each their own newtype to avoid). The Haskell version runs faster with less memory usage. The PHP version uses the Doctrine2 ORM and so it starts executing DB queries whenever you access an unloaded property on an entity. In Haskell all necessary data is loaded once with Esqueleto/Persistent to be passed around later, and then the processing is done in pure functions. (Probably should be using the Reader Monad here, still learning about that :-)) Refactoring / adapting existing code is more easy. When making changes the typechecker will let you know if you forgot to adapt some parts of your code, or what doesn't make sense. Some background: The original PHP script came in two variants, each working on a different dataset, but with a big overlap in processing steps. It was easy to adapt the Haskell version to support both variants of the data. It was a matter of changing the Esqueleto/Persistent entities, and then fixing all type errors. When it compiled it just worked. So refactoring isn't a suicide mission as it is in big PHP projects. (One exception though is a few places where I just used strings to create some database queries, and haven't got around yet to using/understanding the right types/helpers that Persistent provides). Using Haskell for a real world project lets you experience the piece of mind you get from strong typing, purity, immutability and some other Haskell features that are foreign concepts when coming from PHP/Ruby/Python. Feels good knowing that all kinds of weird bugs can just not be there, because the program typechecks and your (pure) code can't have side-effects.    On the long term I think it's good to learn Haskell because most languages are taking on FP concepts, and I think FP will become more popular over the years, because users of those languages will see benefits. So why not start now :D   Last point, not really a plus for Haskell, but by using Haskell with Docker it's easy to start from scratch when you made mistakes with cabal, it's like doing a fresh install of your OS everytime you rebuild your container. And it'll be easy to switch to using stack or whatever, as you just deploy a docker container which exposes an HTTP interface to nginx.  Hope this helps! [edit: list formatting]"
haskell,3d0vb0,MtnViewMark,27,Sun Jul 12 16:11:00 2015 UTC,sorry can't comment too busy doing the happiest Haskell dance
haskell,3d0vb0,ephrion,18,Sun Jul 12 16:37:33 2015 UTC,"Can't wait until ghcjs works with stack. Then the way to download ghcjs will be ""just download it from haskell.org and do stack build""."
haskell,3d0vb0,Crandom,16,Sun Jul 12 20:46:15 2015 UTC,"To quote /u/chrisdoner: ᕕ( ᐛ )ᕗ  EDIT Just to clarify, Chris introduced me to this Unicode-art a few months ago, and I use it at any opportunity I can find since I like it so much ;)"
haskell,3d0vb0,snoyberg,6,Sun Jul 12 16:39:44 2015 UTC,He has a truly remarkable collection of such smileys.
haskell,3d0vb0,quchen,15,Sun Jul 12 20:34:32 2015 UTC,"Mark and I were debating putting this on Reddit, since this is still at a very early phase. On the other hand, the discussion likely would have ended up on Reddit anyway, so may as well kick it off early :)"
haskell,3d0vb0,snoyberg,10,Sun Jul 12 16:12:07 2015 UTC,"Does this include/preserve the ""idealized"" tutorial Windows (it's not an issue for Linux) experience where you can click next a couple times and have all the batteries installed, including network and maybe something that lets you draw shapes in a window?"
haskell,3d0vb0,clumsyfeet,9,Sun Jul 12 17:02:50 2015 UTC,"Gershom brought up the point of binary packages for Windows, which I answered on the mailing list. The tl;dr is:   This plan as stated would not include those binary builds I'm in favor of augmenting this going forward to allow for binary packages, though I don't want that to become a blocker for other improvements I think even on Windows the situation won't be too bad, since once we add in msys, installing things like network will become much easier on Windows (we already have that experience from MinGHC)"
haskell,3d0vb0,snoyberg,3,Sun Jul 12 17:21:24 2015 UTC,"With MSYS2 and the appropriate packages, you can even build the GTK bindings from source on Windows without difficulty. (Once an issue with gtk2hs gets resolved.)  We're pretty close to eliminating the myth that Windows needs binaries except for the same reason as on other platforms, i.e. saving cycles and time."
haskell,3d0vb0,conklech,2,Mon Jul 13 17:10:02 2015 UTC,"With MSYS2 and the appropriate packages, you can even build the GTK bindings from source on Windows without difficulty.   Cool.  Which version of Gtk+ can you build with MSYS2?  Does it build WebKitGTK+ too?"
haskell,3d0vb0,hamishmack,1 point,Tue Jul 14 03:22:35 2015 UTC,"Thanks for getting that pull request merged.  I haven't tried webkitgtk+ yet. I'll try to write up new instructions for the wiki soon. With the pacman package mingw-w64-i686-gtk3 3.16.4-1 and using stack in the MingW32 shell, I was able to build and run gtk2hs and gtk2hs-hello. I don't think I needed anything else; tomorrow or the next day I'll test on a clean machine. I think I can get the installation instructions down to four or five steps."
haskell,3d0vb0,conklech,1 point,Tue Jul 14 03:41:13 2015 UTC,I was able to build and run WebKitGTK+ as well. I made an example hello-world project that should compile and work as long as the appropriate C libraries are installed.  I'll write up the from-scratch MSYS2 installation instructions this evening.
haskell,3d0vb0,conklech,1 point,Tue Jul 14 21:37:20 2015 UTC,That is great news! Do you know if JavaScript works in it?  I have been using the mingw64 WebKitGTK+ package from Fedora 22 and I have not been able to get JavaScript to work in it.
haskell,3d0vb0,hamishmack,1 point,Wed Jul 15 03:58:32 2015 UTC,I haven't tried any JS. What would be a simple test?
haskell,3d0vb0,conklech,1 point,Wed Jul 15 04:34:02 2015 UTC,"Well, until that stuff gets worked out I'd say it remains a fact rather than a myth :-P"
haskell,3d0vb0,sclv,1 point,Mon Jul 13 22:55:05 2015 UTC,"It's a two-line patch. If you want to build on Windows, you can substitute in my fork using stack's git support.  (Pinging /u/hamishmack or another maintainer to review #113.)"
haskell,3d0vb0,conklech,5,Tue Jul 14 00:12:14 2015 UTC,"First of all: good to see some joining of forces.  This announcement made me think what other software might be fit for inclusion in HP. HP used to easy to pain of getting things to build yrself while providing a stable ground for other libs/tools to build on top of. Personally I'd really like to see this happen for two pieces of software: (1) GHCJS and (2) GHC editor/IDE integration. Both of these have cause me severe headaches, and would (imho) benefit from having a standardized release. Instead of inclusion in HP I can also imagine they come as an HP-extension.  Maybe I'm completely missing the point though. If you think so please let me know why."
haskell,3d0vb0,cies010,7,Sun Jul 12 20:22:04 2015 UTC,Hopefully when stack-ide becomes available IDE support will be as easy as:  1) Install haskell platform  2) Make stack project  3) Install plugin for ide of choice that just uses stack ide under the covers  GHCJS should be supported by stack at some point.
haskell,3d0vb0,Crandom,4,Sun Jul 12 21:25:36 2015 UTC,"So stack-ide shall be shipped with HP as part of Stack?   GHCJS should be supported by stack at some point.   So how's HP looking to GHCJS? I understand it is premature, but could it at some point also be (optionally) installed by HP?"
haskell,3d0vb0,cies010,3,Sun Jul 12 22:07:19 2015 UTC,I was assuming this proposal would use stack to download the correct version of ghc for the user (rather than have HP install one itself). I assume it would do the same for ghcjs.
haskell,3d0vb0,Crandom,3,Sun Jul 12 22:40:24 2015 UTC,Then I dont know what HP is more then manually running 3-4 CLI commands involving a lot of stack.  I always thought of HP as something that distributions can incorporate in their package repositories.
haskell,3d0vb0,cies010,3,Mon Jul 13 08:27:59 2015 UTC,"yeah, I've tried and failed to install both GHCJS and Leksah (and ghc-mod) multiple times and they wouldn't build. I try again every few months ;)"
haskell,3d0vb0,sambocyn,6,Mon Jul 13 19:49:37 2015 UTC,"How does this differ from minghc? The included stack tool? I'm sorry to say that haskell platform does not have my confidence. The upcomming section has been a mess for a long time, no releases and no information on when releases is comming.   I still don't understand why any package should be in the global database, this has only caused me pain in the past."
haskell,3d0vb0,SeriousJope,11,Sun Jul 12 19:14:42 2015 UTC,"Stack either is, or very soon will be, included with MinGHC. I can't see any significant deviations from MinGHC, which I consider to be a good thing, as MinGHC meets my needs. If HP ends up doing exactly what MinGHC does, and does it well, MinGHC may stop. If it doesn't, MinGHC will continue.  You want base in the global database as its intrinsically tied to the GHC version. You don't particularly want much else."
haskell,3d0vb0,ndmitchell,1 point,Sun Jul 12 19:57:19 2015 UTC,"Could you comment on the intersection, if any, between MinGHC and stack's auto-installed GHC? Both systems allow multiple GHC versions to live happily alongside each other."
haskell,3d0vb0,conklech,1 point,Mon Jul 13 17:14:27 2015 UTC,"I think the Stack windows code was taken from MinGHC originally, so they are pretty similar. Stack avoids putting everything on PATH since it can tweak that at runtime."
haskell,3d0vb0,ndmitchell,7,Tue Jul 14 14:12:35 2015 UTC,"I would like to have at least the option for binary builds. First, I don't really trust that building locally won't go haywire (they always go wrong, also different people's systems are not exactly homogeneous), also, building all the libraries can take a long time, especially on slower machines. I can even imagine that on some smaller machines it will go out of memory (try to link bigger packages with 512 megs of ram - hint: it will fail, and that's just the system linker, not even GHC)"
haskell,3d0vb0,fridofrido,9,Mon Jul 13 12:07:36 2015 UTC,Will there still be reasons to use Stack after Nix-like features added to cabal?  I'm talking about this Google Summer of Code project https://gist.github.com/fugyk/37510958b52589737274 https://www.google-melange.com/gsoc/project/details/google/gsoc2015/vishal4556/5634387206995968
haskell,3d0vb0,alex-v,5,Sun Jul 12 20:07:58 2015 UTC,"Yes, as it happens Greg just wrote a response to this thread mentioning two features that are in stack and not likely to arrive in cabal-install in the near term (first-class multi-package projects and curated package sets).  That's not to say this Nix-based stuff isn't exciting work. I spoke with Ryan Trinkle (who's mentoring the project) about it a week ago and how it might relate to stack, and it certainly looks like this will address some important pain points with cabal-install."
haskell,3d0vb0,snoyberg,6,Mon Jul 13 01:48:55 2015 UTC,"First-class multi-package projects are a rather minor thing and I don't think a strong reason for including a very young package in a repository of things the community has deemed its most fundamental and stable.  This is not something that affects the ""get haskell experience"".  People who need that feature are likely to be savvy enough to get the right tools anyway.  Curated package sets are definitely planned for cabal-install from what I understand.  It sounds like the nix cabal work is coming along nicely, and frankly I think that could solve the vast majority of user cabal hell complaints.  All said, I think it's too early to put such a new tool into a place of this much significance and fragmenting the ecosystem when we have several promising developments coming up in the standard tools.  I'm not opposed to putting stack in in the future if the situation warrants it, but let's not make that decision now."
haskell,3d0vb0,mightybyte,11,Mon Jul 13 03:54:09 2015 UTC,"I like how you suggest that experienced  people can ""get the right tools anyway"". For most companies this means building your own build systems and processes for maintaining packages sets which is frankly insane.   Stack is solving real problems that people are having in the real world and building features that teams, not individuals, need to be successful. Cabal had its bite at the apple and until it was clear that a competitor would emerge frankly did little to improve the situation. Stack is really not going to replace cabal, rather all the internal build systems that exist in organizations that use haskell."
haskell,3d0vb0,sseveran,3,Mon Jul 13 06:07:36 2015 UTC,"For most companies this means building your own build systems and processes for maintaining packages sets   I don't know which ""most companies"" you are speaking for. I would say we are one of the more mature commercial Haskell development shops around. We have three active major products based on Haskell. All of them are evolving very dynamically, and all are gaining significant traction in their targeted enterprise markets. Besides that, we complete enterprise-scale projects in Haskell on a regular basis.  cabal-install works great for us. Period.  Not that we're not interested in stack. We are very interested. It looks like a great tool, and we're watching it closely. But frankly, we are too busy with real work to waste time on switching to a new and much less proven build tool. I sincerely hope that the next HP release will not force us to do so prematurely.   Cabal had its bite at the apple and until it was clear that a competitor would emerge frankly did little to improve the situation.   That is totally unfair to the stellar Cabal team. Build management for a Haskell compiler that is a package-based separate-module compilation system turned out to be far more complex than anyone imagined, and cabal has stepped up to the task. With help from the community, the cabal team has worked tirelessly to pound out release after release and add feature after feature continuously for the past several years.  Newbie hell is not yet solved, but calling it ""cabal hell"" at this point is wrong. While there is still plenty more we can do to improve our tools, the build problems commonly experienced by newcomers are most often no longer caused by lack of capability of cabal. They are caused by outdated and wrong information about cabal. Or by well-meaning ""helpful"" members of our community who advise them to change the way Haskell build tools are installed on their computer and eventually get them into an inconsistent state, instead of just showing them the right cabal commands."
haskell,3d0vb0,yitz,1 point,Mon Jul 13 21:52:55 2015 UTC,"how did GHC being package-based complicate things?  (also, yeah cabal is a great tool, tools should keep improving, but I wouldn't imagine writing haskell without it)"
haskell,3d0vb0,sambocyn,2,Mon Jul 13 23:14:09 2015 UTC,how did GHC being package-based complicate things?   It is the interrelationship of separate-module compilation with pervasive inlining and static typing that is tricky. Especially in the presence of a very dependency-rich ecosystem.
haskell,3d0vb0,sclv,3,Tue Jul 14 17:49:06 2015 UTC,Curated package sets are definitely planned for cabal-install from what I understand.   This is news to me. Are there issues or mailing list discussions you could point me to?
haskell,3d0vb0,drb226,1 point,Mon Jul 13 06:32:24 2015 UTC,"From How we might abolish Cabal Hell, part 2, the last sentence of the conclusion:  ""Nix-style package management and curated package collections are mostly complementary and we want both.""  I've also seen core devs mention on IRC and elsewhere that they specifically want to enable support for curated collections in a general way so anyone can point cabal to whatever custom curated set they might want to use."
haskell,3d0vb0,mightybyte,10,Mon Jul 13 06:47:48 2015 UTC,"I'm not convinced it's a good idea including stack in the HP distribution unless cabal is being officially deprecated. Why? Because then new users gets faced with the decision of whether to use stack or cabal, and if we can tell new users with a good conscience that cabal is the legacy option (maybe cabal could even print a ""please use stack instead"" on startup?), and stack is the future, then it's all fine.  On the other hand, if cabal is still being actively developed and gaining features from stack together with other features exclusive to cabal, then stack would merely constitute a tech-preview, which may ultimately become a legacy tool. Is it sensible to include an alternative tool as a temporary kludge in the HP which is supposed to provide a single recommended mature API/tooling for each task, when we already know it may be removed again?"
haskell,3d0vb0,RedLambda,11,Mon Jul 13 06:46:02 2015 UTC,"This is a summary of my journey with Haskell tooling:   Downloaded Haskell Platform Learned some Haskell Tried a bunch of editors / IDEs, gave up and went with SublimeText Got into trouble with dependencies in Cabal Learned the situation is so bad that we've coined the phrase Cabal Hell Reconsidered continuing with Haskell Nuked everything Haskell related on my machine and installed GHC on its own Learned about sandboxes Found MinGHC - nuked Haskell again and tried that to simplify things Found that various packages won't install with the latest GHC (including ghc-mod) Decided to use Stackage - working out how to use Stackage was surprisingly confusing Hated having to rebuild packages like lens in every new sandbox Occasionally I'd install a package globally by accident (forgot to initialise a sandbox) and would have to nuke everything again Tried Stack - seemed cool but was confused about how to configure it Realised I needed to get SublimeText to build using Stack instead of Cabal - and went back to cabal init and sandboxes   Though to be fair my experience with learning Java and Maven wasn't necessarily much better. Thought it more than made up for it on the IDE front. And dependency problems on Ruby gems (working with SASS for web) was pretty painful. So it's not like Haskell is alone in this.  But the handful of times I've helped someone who was newer than me - my first advice was ""uninstall HP and get MinGHC"". I think that's a pretty sad state of affairs.  TL;DR - how soon can we get this? :)"
haskell,3d0vb0,TheCriticalSkeptic,6,Mon Jul 13 00:10:13 2015 UTC,"Just a small remark, you can put a line ""require-sandbox: True"" into your global cabal config, so you'll never install a package globally again :)"
haskell,3d0vb0,quyse,1 point,Mon Jul 13 12:44:18 2015 UTC,That is good to know :). Thanks
haskell,3d0vb0,TheCriticalSkeptic,3,Mon Jul 13 23:07:02 2015 UTC,"Tried a bunch of editors / IDEs, gave up and went with SublimeText   I would love to know how you got on with Leksah.  Were there any particular things you think we should be working on?"
haskell,3d0vb0,hamishmack,3,Mon Jul 13 16:34:51 2015 UTC,"I am not the author of the parent comment, but can give my answer to your question.  I was turned off by Leksah because, if I remember correctly (I may have this mixed up with another editor I have tried over the years), Leksah was one of those ""you must start a project before you can write any code"" IDEs. In fairness, I wanted an ""editor"" and Leksah is an ""IDE"". Ultimately, I never found a way to start writing code in Leksah, though I did not look very long. I know I didn't give Leksah much effort, but this was my initial turn-off, since you asked."
haskell,3d0vb0,Buttons840,2,Mon Jul 13 22:21:41 2015 UTC,"Leksah was one of those ""you must start a project before you can write any code"" IDEs   Yeah that is Leksah.  We try to make it easy to create a .cabal file (Package -> New) but there is no support for a .hs file on its own.  Also when you install leksah it comes with a ""welcome"" package that you can mess with straight away.  In the past I had hoped we could create a temporary .cabal files for .hs files that lack them.  But cabal does not allow more than one .cabal file in a directory, so that might not work well."
haskell,3d0vb0,hamishmack,2,Tue Jul 14 00:08:06 2015 UTC,"I've mentioned a few things in a Reddit comment before. But I actually really liked Leksah. In fact because of Leksah I was almost oblivious to how Cabal worked because it took care of so much of it for me.  My problem was performance. It would freeze, crash and lag. I stuck with 12.something for ages because v13 and v14 pretty much wouldn't work. Within a few minutes of using it (with auto-build turned off) there would be a massive delay between typing and the text appearing on screen. With an i7 and 16gb of ram this was pretty bad. Also - Eclipse FP was having exactly the same problem.  I only abandoned Leksah v12 because my need for sandboxes outweighed my want for an IDE.  I saw the v15 post the other day and I've been meaning to give it a try. GHC 7.10.1 means no ghc-mod, so Sublime is basically just a text editor at the moment. Will the latest Leksah work with the latest GHC?"
haskell,3d0vb0,TheCriticalSkeptic,2,Mon Jul 13 23:15:55 2015 UTC,"My problem was performance. It would freeze, crash and lag. I stuck with 12.something for ages because v13 and v14 pretty much wouldn't work. Within a few minutes of using it (with auto-build turned off) there would be a massive delay between typing and the text appearing on screen. With an i7 and 16gb of ram this was pretty bad. Also - Eclipse FP was having exactly the same problem.   It would be great to track this down (if it still happens).  Quite a few performance issues have been fixed so it might not happen any more.  If it does though please let us know.   I only abandoned Leksah v12 because my need for sandboxes outweighed my want for an IDE.   Leksah has some support for sandboxes.  It foes not currently index packages only installed in the sandbox though.   Will the latest Leksah work with the latest GHC?   Yes 7.10 is supported."
haskell,3d0vb0,hamishmack,7,Tue Jul 14 00:12:40 2015 UTC,can we please rename stack to something more sensible  while it's still cheap to do so? like eg cabal2
haskell,3d0vb0,hagda,7,Sun Jul 12 23:26:07 2015 UTC,"I agree, stack is a terrible name, because it is so generic and widely used in programming to mean different things. I have no good suggestions, but haystack jumped out to me as an okay meld of haskell and stack that's distinct enough."
haskell,3d0vb0,haskman,3,Mon Jul 13 04:43:31 2015 UTC,"I agree with renaming, but disagree with cabal2, though I don't have any constructive suggestions for alternatives...  Edit: hack?"
haskell,3d0vb0,theonlycosmonaut,7,Mon Jul 13 00:21:07 2015 UTC,boop edit: whee yow plz gosh mo
haskell,3d0vb0,tejon,12,Mon Jul 13 02:46:05 2015 UTC,dude
haskell,3d0vb0,yitz,11,Mon Jul 13 09:08:35 2015 UTC,dude install yesod
haskell,3d0vb0,codygman,1 point,Mon Jul 13 10:11:00 2015 UTC,I want this so much.
haskell,3d0vb0,pbl64k,2,Mon Jul 13 11:27:19 2015 UTC,hsck
haskell,3d0vb0,theonlycosmonaut,4,Mon Jul 13 08:17:40 2015 UTC,"No, facebook's typed php superset is called hack. At the very least calling it haskell-stack would be an improvement."
haskell,3d0vb0,leperLlama,6,Mon Jul 13 01:29:17 2015 UTC,"I don't see the point. If you google ""haskell stack"", you already get stack."
haskell,3d0vb0,radix,2,Mon Jul 13 04:43:49 2015 UTC,But a lot to type out.  EDIT: I just realised that you don't have to name the thing after it's command-line alias :p.
haskell,3d0vb0,theonlycosmonaut,2,Mon Jul 13 08:16:58 2015 UTC,labac
haskell,3d0vb0,AlpMestan,2,Wed Jul 15 13:00:38 2015 UTC,I think you got it all backwards... :)
haskell,3d0vb0,hagda,2,Wed Jul 15 14:10:34 2015 UTC,absolutely yes. I look forward to the day when trying out Haskell on your box won't be harder than surfing to ghc.io
haskell,3d24xa,cies010,5,Sun Jul 12 22:27:36 2015 UTC,He could automate the process by contributing to my MetaFun compiler (transpiler?) to implement whatever missing language features he'd be using.
haskell,3d24xa,gergoerdi,2,Mon Jul 13 02:26:46 2015 UTC,"I've even went and fixed its most annoying shortcoming: that pattern matching was not done in order, i.e. if you had  f x y = True f True False = False   then MetaFun would compile f True False into something that evaluates to False. It now generates the correct code so that f True False matches the first alternative instead, thereby evaluating to True."
haskell,3d24xa,gergoerdi,2,Tue Jul 14 12:45:04 2015 UTC,"A little bit of explanation what NsName, QName, ns1, ln1, etc. are might have helped with understanding what ""contains"" actually does and what it can be used for. Other than that, pointing out the similarities of Haskell and C++ Metaprogramming is great (for me), since I am familiar with one, and want to learn the other.  Ah and btw.: Compile-time validated XML writer? Awesome!"
haskell,3d24xa,dalbuschat,3,Mon Jul 13 04:09:16 2015 UTC,"pointing out the similarities of Haskell and C++ Metaprogramming is great (for me), since I am familiar with one, and want to learn the other.   Have you read Bartosz Milewski's famous post on the subject? It's called ""What Does Haskell Have to Do with C++?""."
haskell,3d24xa,gelisam,2,Mon Jul 13 12:30:11 2015 UTC,"Not yet, will do! Thanks"
haskell,3d1rzv,rogue203,6,Sun Jul 12 20:42:58 2015 UTC,"If you want to try writing some bindings yourself to mp4v2, here are some resources:  http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html  https://en.wikibooks.org/wiki/Haskell/FFI  The only part that I didn't find immediately obvious was the need to sometimes block the Haskell RTS.  example in mysql library  https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals  Here's the effect of not blocking the Haskell RTS in FFI code:  http://stackoverflow.com/questions/15226806/importing-c-delay-function-into-haskell-using-ffi  Some more resources on Haskell/FFI:  https://wiki.haskell.org/IO_inside#Interfacing_with_C.2FC.2B.2B_and_foreign_libraries_.28under_development.29  Haskell ffi basics presentation"
haskell,3d1rzv,codygman,2,Mon Jul 13 01:30:45 2015 UTC,I just found the video of that presentation on youtube: https://www.youtube.com/watch?v=TP0ApVPLc24
haskell,3d1rzv,get-your-shinebox,1 point,Wed Jul 15 06:50:13 2015 UTC,Awesome! I'll definitely have to watch it tomorrow.
haskell,3d1rzv,codygman,1 point,Wed Jul 15 07:14:23 2015 UTC,Thanks. I've been reading up on FFI a bit. I'll give it a shot if I don't another option.
haskell,3d1rzv,codygman,1 point,Mon Jul 13 01:59:52 2015 UTC,You might have fun ;)  It only took me about 10 minutes to do the sin example from wikibooks.
haskell,3d1rzv,waldheinz,3,Mon Jul 13 02:59:15 2015 UTC,"I currently have a pull request open for the ffmpeg-light library, which seems to do what you want: https://github.com/acowley/ffmpeg-light/pull/13"
haskell,3d1rzv,acow,2,Mon Jul 13 15:50:20 2015 UTC,And it's merged!
haskell,3d19jf,lithiumdeuteride,5,Sun Jul 12 18:12:23 2015 UTC,"Maybe try the linear package instead and use Linear.Matrix  If you look in the repo for the bed-and-breakfast package there is an outstanding issue about it not compiling with the latest versions of GHC.  Trying to fix it by commenting out an instance is probably not a good idea.  Also instead of trying to copy code from a library into your editor and modifying it, you should be downloading the package from hackage directly. Check out the How I Start article on Haskell. That will give you a good understanding of how to setup projects including managing external packages."
haskell,3d19jf,TheCriticalSkeptic,1 point,Sun Jul 12 23:54:59 2015 UTC,"Thanks for the advice.  I will try linear, and look into proper package management instead of cobbling junk together."
haskell,3czsbs,evanrelf,18,Sun Jul 12 07:09:16 2015 UTC,Looks nice! I like that you made it based on the looks of haskell.org.
haskell,3czsbs,togrof,8,Sun Jul 12 07:25:52 2015 UTC,Overlapping time frames in sort by top  http://imgur.com/oQt1W2S
haskell,3czsbs,fruitbooploops,4,Sun Jul 12 07:50:08 2015 UTC,Ironically that bit looks good until some Javascripty thing kicks in and wrecks it!
haskell,3czsbs,kqr,5,Sun Jul 12 08:50:33 2015 UTC,I really like it! Nice to have a unifying theme. How do we make it official?
haskell,3czsbs,bitmadness,3,Sun Jul 12 07:38:22 2015 UTC,"I'm pretty new here, but I assume if we get enough people wanting it, maybe the mods will change it?  I'm predicting that some tweaks might need to be made before switching though."
haskell,3czsbs,tejon,6,Sun Jul 12 07:41:42 2015 UTC,"I probably shouldn't have the mod mail icon in the upper right.  Also, the last two icons there are nonstandard and have no tooltips explaining what they are. Wrench-and-screwdriver is probably okay (though that's not a very well-rendered screwdriver), but I was like ""WTF is this power button for?"" and then I was like ""where did it go, why did the UI change?"" and then I figured it out, but that wasn't pleasant. IMO the ""logout"" text is preferable there."
haskell,3czsbs,peargreen,17,Sun Jul 12 11:59:48 2015 UTC,"It does look nice, but I still wish everyone would stop changing themes of their subreddits. Having to spend even 30s to figure out how to use every new subreddit is kinda annoying.  Also, please please please remove this animated fade-in of the list of posts.  Edit: apparently it was already requested here and will be removed soon.  Edit #2: was already removed."
haskell,3czsbs,kqr,3,Sun Jul 12 11:15:28 2015 UTC,I like the visual distinction because when I'm following my orangereds I don't always keep track of where I've ended up.
haskell,3czsbs,peargreen,1 point,Sun Jul 12 13:30:20 2015 UTC,"I don't want to do it because I don't want to miss funny moments like “what amusing image did this subreddit choose for an upvote button”, so having a “Show this subreddit's theme” checkbox is enough for me (I did suffer before having bought gold, tho)."
haskell,3czsbs,Magnap,1 point,Sun Jul 12 15:06:18 2015 UTC,Animated fade removed!
haskell,3czsbs,TumbleSteed,11,Sun Jul 12 14:02:57 2015 UTC,"I'd suggest changing the title to Haskell :: SubReddit, with the case as you see fit. Subreddit seems like a better type than just Reddit."
haskell,3czsbs,kqr,1 point,Sun Jul 12 20:34:46 2015 UTC,"Right now I'm just trying to mimic the current /r/haskell, but I think that makes more sense."
haskell,3czsbs,kqr,4,Sun Jul 12 09:57:17 2015 UTC,"Ooh, this looks nice.  My only nitpick would be that the ""Save"" button on the comment page doesn't have a shadow on the left when scrolled over.  I also prefer slightly darker vertical bars indicating indented comment levels since I find light ones hard to read, but that's just personal preference, not an actual issue."
haskell,3czsbs,kqr,3,Sun Jul 12 20:37:14 2015 UTC,To me it's an actual issue. Peoples monitors are different and on some monitors those bars will be completely invisible. Definitely make the bars more contrasty.
haskell,3czsbs,kqr,1 point,Sun Jul 12 09:50:22 2015 UTC,"Funnily enough, the background of the child comments on my design is the same as the current design at /r/haskell (#F7F7F8). But I'll try adding borders to make it stand out a bit more.  EDIT: typo"
haskell,3czsbs,kqr,1 point,Sun Jul 12 10:21:01 2015 UTC,/r/haskell has #ddf
haskell,3czsbs,LiveRanga,1 point,Sun Jul 12 20:50:25 2015 UTC,#DDF is the color of the background when you click on a comment or move to it with arrow keys. That's why it turns a shade of light blue instead of the normal gray.
haskell,3czsbs,dsfox,1 point,Sun Jul 12 21:02:23 2015 UTC,"No, the image I linked to specifically says the border-left (i.e. the tree line) is #ddf. Ready to believe me?"
haskell,3czsbs,Lossy,2,Sun Jul 12 22:07:46 2015 UTC,"Actually you're totally right, I apologize. I'm using the Reddit Enhancement Suite browser extension which changes the styling of nested comments, so I didn't see how it looked without it, but from now on I'll continue development without the extension.   How it looks without RES (default) How it looks with RES   Now that I see it without RES I agree that the lines are way too thin and light. I'll darken them right away! :)"
haskell,3czsbs,TotesMessenger,1 point,Sun Jul 12 22:10:28 2015 UTC,"Oh, yeah, that's a huge difference! I had forgot how much RES does. I should probably install it again..."
haskell,3czsbs,codygman,1 point,Sun Jul 12 22:38:52 2015 UTC,I make the lines a lot darker. Is this better?  I can also make the line solid or dashed if it's still not bold enough (right now it's dotted).
haskell,3czsbs,clrnd,1 point,Sun Jul 12 22:40:19 2015 UTC,Looks good to me! Nice work. :)
haskell,3czsbs,martingalemeasure,2,Sun Jul 12 22:48:53 2015 UTC,"Looks good, it's got my vote!"
haskell,3d0fgf,dalaing,3,Sun Jul 12 13:23:39 2015 UTC,"What is the category-theoretical concept behind the ""pairing"" method?"
haskell,3d0fgf,Faucelme,3,Sun Jul 12 16:29:45 2015 UTC,pair looks kind of like zapWithAdjunction to me. I'm not sure whether zapWithAdjunction is as general though.
haskell,3d0fgf,Roboguy2,5,Sun Jul 12 18:10:17 2015 UTC,"Sadly ""Pairing"" as a class in a more general setting is ill defined. If you have a functor g with adjoints on each side f -| g -| h, then you can ""pair"" g with both f and h.  The closest thing to a motivation is to say that you can 'zap' or 'pair' functors that can be decomposed into adjoint pairs.   This is why the adjunctions package used to supply tools for zapping functors as data types not class instances. http://comonad.com/reader/2008/zapping-strong-adjunctions/ talks about the non-uniqueness problem some.  Even with that you have permutation problems, as you can distribute left adjoints over other left adjoints and right adjoints over other right adjoints. This extra level of concern is more palatable, however, as they are at least equivalent up to isomorphism.  Ultimately to ""zap"" or ""pair"", you can see that every ""locked chest"" (right adjoint) on one side has to be paired with a ""key"" (left adjoint) on the other, and you have to unlock the chest containing a key before you can use the key. This means you can zap/pair even more things. The intuition behind the ""Pairing"" class is that he's trying to talk about structures that perfectly cancel.   You could allow the use of a key on multiple locks, but you wont get the ability to extract every bit of information from each Functor using its mirror image that way. Some parts of the structure or states become inaccessible.  What saves things in terms of allowing this actual implementation is that there is only one adjunction from Hask -> Hask, which is the (,) e -| (->) e adjunction, every other adjunction from Hask -> Hask is isomorphic to an instance of this.   The only ""three-way"" adjunction we can find that lives entirely within Hask then is Identity -| Identity -| Identity -- which is boring. This claim doesn't generalize to a broader category-theoretic setting, however."
haskell,3d0fgf,edwardkmett,1 point,Sun Jul 12 21:43:57 2015 UTC,"A couple of us stepped through your first article in the series at BayHac. I have nothing to show for it, really, but I learned some stuff and it was fun. Thanks!"
haskell,3d0fgf,chreekat,1 point,Mon Jul 13 05:00:46 2015 UTC,Excellent! I'm glad it was useful (or at least entertaining).
haskell,3d0fgf,mcapodici,1 point,Mon Jul 13 05:13:30 2015 UTC,Thanks for posting this. I saw the talk and was intrigued but found it hard to keep up to the pace. It would be nice to experiment with the zipper in my own time.  Quick question so I can play: where is the maximumDef function defined?
haskell,3czwdz,bitmadness,7,Sun Jul 12 08:13:23 2015 UTC,There's a release candidate out including GHC 7.10.
haskell,3czwdz,cameleon,3,Sun Jul 12 08:58:04 2015 UTC,"Similar discussion 3 months ago, and 4 months ago."
haskell,3czwdz,ignorantone,4,Sun Jul 12 08:41:13 2015 UTC,"The next HP will come out shortly after 7.10.2 is officially released.  In the mean time, as /u/cameloen mentioned, there is a release candidate based on 7.10.2 RC2 available for Linux and OS X."
haskell,3cyoyl,TheCriticalSkeptic,20,Sat Jul 11 23:56:49 2015 UTC,You might like the ad package and Conal Elliot's Beautiful Differentiation.  Lots of good stuff on that front.
haskell,3cyoyl,dalaing,7,Sun Jul 12 00:41:18 2015 UTC,Both of those look excellent. It didn't occur to me that there'd be a phrase like Automatic Differentiation - which seems rather obvious now.   Thanks!
haskell,3cyoyl,edwardkmett,15,Sun Jul 12 00:47:17 2015 UTC,"Calculating derivatives is rather pleasant. There is an algorithm available there. Forward and reverse mode AD have different comparatively minor trade-offs, etc.  The process of calculating integrals comparatively sucks. We get stuck with numerical quadrature schemes typically for one dimension, or playing around with Padé approximants and Taylor models. As the dimension of the problem starts to rise Monte Carlo  and quasi-Monte Carlo techniques dominate in terms of just crunching numerical results."
haskell,3cyoyl,LanceArmBoil,8,Sun Jul 12 01:09:19 2015 UTC,"The process of antidifferentiation doesn't necessarily entail numerical schemes or polynomial approximations. The Risch algorithm is the basis for computer algebraic techniques for exact antidifferentiation. Pretty neat stuff, actually."
haskell,3cyoyl,edwardkmett,13,Sun Jul 12 01:23:09 2015 UTC,Except it breaks down the moment you add abs. Richardson's theorem is a cruel master.
haskell,3cyoyl,augustss,6,Sun Jul 12 01:29:53 2015 UTC,"That's true, but for most of the integrals you'll find in calculus text book the algorithm is likely to work. :)"
haskell,3cyoyl,edwardkmett,7,Sun Jul 12 10:58:27 2015 UTC,"True. You can definitely work your way through Spivak with it and pass with an A if nobody checks your work. =)  The main issue I have with Risch's algorithm is that folks trot it out like it works in a meaningful fraction of the situations that arise in practice, and it just doesn't.  It is great when it does work, but my experience is that there are vanishingly few situations that arise in the ""real world"" where Risch's algorithm applies in a way you could implement it in code rather than just offer it to the programmer as an aid to help them write the program in the first place.   In that setting it isn't an algorithm so much as a search tool, and plays approximately the same role in my programming process as googling for the answer, or asking Wolfram Alpha or Mathematica to see if there is a nice closed form for something. Since the latter exists, has had way more effort piled into it than any Risch variant I can code, and I can't turn it into a usable algorithm that can solve more than a tiny fraction of the cases that arise anyways, I just let Mathematica fill that niche for me."
haskell,3cyoyl,LanceArmBoil,3,Sun Jul 12 17:14:10 2015 UTC,"Yup, I just thought the OP might not know about the CA techniques for antidifferentiation (as opposed to approximation techniques), which always seemed a bit magical to me."
haskell,3cyoyl,autowikibot,5,Sun Jul 12 02:53:53 2015 UTC,"Richardson's theorem:       In mathematics, Richardson's theorem establishes a limit on the extent to which an algorithm can decide whether certain mathematical expressions are equal. It states that for a certain fairly natural class of expressions, it is undecidable whether a particular expression E satisfies the equation E = 0, and similarly undecidable whether the functions defined by expressions E and F are everywhere equal (in fact E = F if and only if E - F = 0). It was proved in 1968 by computer scientist Daniel Richardson of the University of Bath.     Relevant: Constant problem | Risch algorithm | List of theorems | Turbulence   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3cyoyl,autowikibot,3,Sun Jul 12 01:30:42 2015 UTC,"Markov chain Monte Carlo:       In statistics, Markov Chain Monte Carlo (MCMC) methods are a class of algorithms for sampling from a probability distribution based on constructing a Markov chain that has the desired distribution as its equilibrium distribution. The state of the chain after a number of steps is then used as a sample of the desired distribution. The quality of the sample improves as a function of the number of steps.  Random walk Monte Carlo methods make up a large subclass of MCMC methods.    Image i - Convergence of the Metropolis-Hastings algorithm. MCMC attempts to approximate the blue distribution with the orange distribution     Relevant: Reversible-jump Markov chain Monte Carlo | Sylvia Richardson | Metropolis–Hastings algorithm | Hybrid Monte Carlo   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3cyoyl,5outh,9,Sun Jul 12 01:10:27 2015 UTC,"This is a pretty old blog post of mine, but I ran through one way of doing symbolic differentiation in Haskell here: http://kovach.me/posts/2013-05-01-symbolic-calculus.html  It's nowhere near as fancy as automatic differentiation, though :)"
haskell,3cyoyl,so_just,3,Sun Jul 12 02:04:51 2015 UTC,Automatic differentiation is pure magic when you first discover it.
haskell,3cyoyl,idontgetoutmuch,3,Sun Jul 12 11:56:55 2015 UTC,"This sort of question arises from time to time. You might like to look at a previous discussion: https://www.reddit.com/r/haskell/comments/1xwbb8/what_is_the_type_of_the_derivative_operator/  Another approach is to use Chebyshev polynomials such as is done in Matlab http://www.chebfun.org and Julia https://github.com/ApproxFun/ApproxFun.jl. I think laziness could help in Haskell as the representations could be infinite lists of coefficients; in both the Matlab and Julia implementations, I believe there is an algorithm to decide the length of the representation (although I also believe there is some part of the Julia implementation that allows for infinite representations)."
haskell,3cyoyl,ocramz,3,Sun Jul 12 13:24:15 2015 UTC,"to summarise the first link: /u/jhinkle wrote this differential geometry library, with a notion of approximate identity for floats, https://bitbucket.org/jhinkle/haskell-diffgeom ; it includes a module for gradient-based optimization ( https://bitbucket.org/jhinkle/haskell-diffgeom/src/c9f0b09f7c4f2a382ad987ed19a1d54598b6bd7f/src/DiffGeom/Algorithms/Optim.hs?at=master ) that employs this notion of differentiable function:  newtype (Smooth r) => DiffableFn r = DiffableFn (r -> (Double, CoTangentType r))  However there are no tests covering this and from the comments there seem to be some gaps in the guarantees offered by the library."
haskell,3cyoyl,echatav,3,Mon Jul 13 12:23:24 2015 UTC,"If you're content to work with power series representations of analytic scalar functions, then there's a neat little 10-liner called power serious that can do differentiation and integration."
haskell,3cyoyl,gbaz1,3,Sun Jul 12 17:17:54 2015 UTC,You may also be interested in this old draft I worked on regarding a first-class representation of (approximate) differential equations: http://gbaz.github.io/slides/ode-draft-2009.pdf
haskell,3cyoyl,serg_foo,3,Sun Jul 12 17:42:17 2015 UTC,You may find this blog post about forward mode automatic differentiation (similar to yours DxDt t x) useful: https://vandreev.wordpress.com/2006/12/04/non-standard-analysis-and-automatic-differentiation/
haskell,3cyoyl,ocramz,2,Sun Jul 12 19:20:17 2015 UTC,"EDIT: I know not enough of CT to comment on bifunctors etc </edit>, but, well, if you can guarantee that a function is analytic (can be represented as a ratio of power series), then it can be identified with its Taylor series around a point, to arbitrary accuracy.  There's of course a whole zoo of non-analytic functions ( https://en.wikipedia.org/wiki/Non-analytic_smooth_function ) with various kinds of singularity. On the other hand, there's also a rich literature on non-smooth optimization (see e.g. F. Clarke et al. ""Nonsmooth analysis and control theory"" ) and distributional differentiation (e.g. G. C. Pflug, ""Optimization of stochastic models"") but these tend to be numerical techniques. It is worth noting that Automatic Differentiation isn't a completely symbolic technique either, but it's handy because it returns function value and gradient at the requested point, with just a small overhead wrt function evaluation alone.  Multivariate symbolic integration is definitely harder and has many more special cases, however some packages (GNU Maxima etc.) just manage to Make It Work. For non-textbook cases, or when the dimensionality of the problem is large, the two most common camps (in fact, the two only available options) are variational and sampling approaches. Both are approximations (the former implies fitting a simpler distribution or another, which is the source of its bias, whereas the latter is only exact for infinite samples) with complementary pros and cons.  EDIT: I realize now that my freewheeling on numerical methods brought me off topic, but I just wanted to say that there are no general algorithms to do either differentiation or integration symbolically for arbitrary functions and problem sizes."
haskell,3cyoyl,tactics,1 point,Sun Jul 12 11:49:02 2015 UTC,"As long as you're bringing up non-analytic smooth functions, I find it interesting that there is seemingly no analog (to my limited knowledge) of the notion of a radius of convergence."
haskell,3cyoyl,eccstartup,2,Tue Jul 14 03:08:11 2015 UTC,"What I think is very cool is the finite element package(if available). Besides finite element, there are some other things useful. Matrix multiplication, inverse of matrices, SVD, time stepping problem, etc."
haskell,3cyoyl,ocramz,2,Mon Jul 13 06:07:40 2015 UTC,we're on it ;)
haskell,3cyoyl,eccstartup,1 point,Tue Jul 14 09:38:17 2015 UTC,Can you describe what it is you are working on? I am very interested.
haskell,3cyoyl,ocramz,2,Wed Jul 15 03:47:02 2015 UTC,"I am writing the Hs bindings for the PETSc library ( http://www.mcs.anl.gov/petsc/ ), which offers matrix-vector algebra, linear and nonlinear solvers, ODE integrators etc. It has separate support for spectral representations (SVD etc.) through SLEPc, which has a similar API. The questions I'm facing now are how to represent the class hierarchy (e.g. what to do when a matrix has high condition number i.e. is close to being non-invertible? do we fall back to semigroup? perhaps /u/idontgetoutmuch has some input on this ), so I'd like to understand more of e.g. /u/jhinkle 's work linked above. What do you work on instead?"
haskell,3cyoyl,eccstartup,2,Wed Jul 15 09:21:20 2015 UTC,"That is awesome! I use PETSc for the computation of partial differential equations(PDE), however, I do not like the C style functions. Matrix with high condition number are sometimes get from discretization of PDEs. We either try to modify the way of discretization to make it better, or use some stable numerical schemes to get over it. Singular matrix is really bad. I am not sure how to define this, but you can ask people in the user-groups of PETSc."
haskell,3cyoyl,eccstartup,2,Wed Jul 15 23:51:50 2015 UTC,"Besides, there is a technique called preconditioning. https://en.wikipedia.org/wiki/Preconditioner"
haskell,3cyoyl,ocramz,1 point,Thu Jul 16 02:50:15 2015 UTC,":) I do numerical PDE work too (in the context of optimization in particular), so I'm quite aware of preconditioning. What I was trying to say is that Hs typeclasses allow a very formal representation of the ""grammar"" of a problem, but in this case a continuous parameter gives a very different meaning to a linear operator (and the set of operations that it can represent), so how do we represent this behaviour? Cool that we have similar thoughts btw :)"
haskell,3cyoyl,idontgetoutmuch,2,Thu Jul 16 10:42:22 2015 UTC,I only meant to draw attention to the fact that this subject had had some previous discussion. I don't know anything about /u/jhinkle's library. There are some nice bindings to LAPACK https://hackage.haskell.org/package/hmatrix-0.16.1.5/docs/Numeric-LinearAlgebra-Static.html which give static guarantees about e.g. matrix multiplication. It might be possible to use the same interface on top of PETSc (although PETSc seems a very extensive library).
haskell,3cyoyl,ocramz,1 point,Mon Jul 20 01:34:37 2015 UTC,"It certainly is; so far I have completed the lowest-level interface to the linear algebra parts (i.e. Mat, Vec, KSP) (and it helps that the syntax of the rest of the C api is quite uniform). One challenge I'm facing is mutable data, how to represent that in classes? /u/edwardkmett pointed me to a generalization of StateT to an ""update monad"", still have to look at that in detail.  I'm also thinking of studying the ipopt-hs bindings, which have to deal with mutable data as well.   Speaking of HMatrix, what does the following mean? Namely, the ""bijective"" fundep  class Indexable c t | c -> t , t -> c   where     infixl 9 !       (!) :: c -> Int -> t"
haskell,3cyoyl,ocramz,1 point,Mon Jul 20 08:59:49 2015 UTC,I wrote a bit about my progress on this here: https://www.reddit.com/r/haskell/comments/3dxqqs/representing_mutable_variables_and_nonpure/
haskell,3cyoyl,crb002,1 point,Mon Jul 20 12:10:46 2015 UTC,I shell out to SymPy for symbolics. I recommend reading McIlroy's Music of Streams and his Power Series Power Serious articles.
haskell,3cyez3,stimpflj,18,Sat Jul 11 22:23:40 2015 UTC,This is the operational monad.  You've discovered a form of the Yoneda lemma with Wrapped.
haskell,3cyez3,edwardkmett,4,Sun Jul 12 00:06:42 2015 UTC,Thanks for the pointers.
haskell,3cyez3,aaronlevin,3,Sun Jul 12 00:54:41 2015 UTC,"You mention that your construction is too class heavy. I don't see why you need both Interpreter and WrappedInterpreter. They are identical classes.  Thanks for writing this up, btw. It was really cool to see Yoneda sneak in there so naturally!"
haskell,3cyez3,aaronlevin,2,Sun Jul 12 02:41:28 2015 UTC,They are not identical. Look closely at the type constraints. It's important that the GADT need not be a functor.  But I don't think classes for Interpreter / WrappedInterpreter are warranted. There should be more than only one sensible instance given any f and m.
haskell,3cyez3,markandrus,1 point,Sun Jul 12 09:27:53 2015 UTC,Good call. I think where my mind went was that the way you use them makes the WrappedInterpreter redundant; it seems like its just a class used to make an Interpreter instance for any type f :: * -> * using Wrapped.
haskell,3cyez3,dalaing,2,Sun Jul 12 16:37:08 2015 UTC,"Nice article! Though with this formulation, it looks like you lose the ability to define GADT constructors that would terminate the computation (what ""Why free monads matter"" calls ""abort"" semantics)."
haskell,3cyez3,twistier,3,Sun Jul 12 03:01:16 2015 UTC,That difference is discussed a bit here (and in a few other places as well).  There seem to be many interesting rabbit holes to burrow into in this space :)
haskell,3cwv5i,quchen,29,Sat Jul 11 13:58:15 2015 UTC,You can use the type system to eliminate IO when you want to enforce that code has no side effects
haskell,3cwv5i,Tekmo,21,Sat Jul 11 17:54:01 2015 UTC,Maybe start a Wiki page now or after the discussion has taken off?
haskell,3cwv5i,chrisdoner,8,Sat Jul 11 14:37:23 2015 UTC,"Something like that was the plan, yes."
haskell,3cwv5i,alexander_b,6,Sat Jul 11 15:38:04 2015 UTC,"I agree with this. It could discuss the various clear-cut chases of a potential bug being eliminated. It should furthermore talk about what this effectively leads to -- e.g. ""[i]f [a] program passes the type checker, then it is guaranteed to not crash at runtime."""
haskell,3cwv5i,alexander_b,15,Sat Jul 11 15:36:28 2015 UTC,"what this effectively leads to   This ""effectively"" is very hard to define. A typechecking program can and will be able to crash. We still have deadlocks, accidential non-termination, error, and so on.  I think we should be very careful with the ""if it compiles then it works"" statement, and all its siblings."
haskell,3cwv5i,everybodyhatesclowns,6,Sat Jul 11 15:39:33 2015 UTC,"""The term 'crash' here has a formal definition that includes hard crashes like 'segmentation fault', but not things like pattern-matching failure. The non-crash guarantee can be subverted by using certain unsafe language features, such as the Foreign Function Interface."""
haskell,3cwv5i,sqrt2,7,Sat Jul 11 15:51:46 2015 UTC,"So from a programmer's perspective, what's the difference? I get the same guarantee in Java, don't I?"
haskell,3cwv5i,Archaeanimus,6,Sat Jul 11 16:40:29 2015 UTC,"Partial functions are a part of any Turing-complete programming language, so the type system cannot save you from them, but GHC can warn you that you are producing them (-fwarn-incomplete-patterns)."
haskell,3cwv5i,sqrt2,7,Sat Jul 11 17:22:34 2015 UTC,"Partial functions are a part of any Turing-complete programming language   I don't think that's correct. Agda, for example, is Turing-complete (if you use the Coinduction module), and it has no partial functions."
haskell,3cwv5i,gelisam,3,Sat Jul 11 21:34:59 2015 UTC,"I'm not familiar with Agda, but how can that be? I can build a Turing machine that loops forever on certain input, so an equivalent Agda function must also not terminate for certain arguments and therefore be partial.  (I've heard of the concept of productive functions, used to add a specific kind of nontermination to theorem provers, but Turing machines are capable of other nontermination also.)"
haskell,3cwv5i,tailcalled,10,Sat Jul 11 21:54:42 2015 UTC,"To simplify, let's ignore the details of Agda and focus on how a language could simultaneously be Turing-complete and have no partial functions.  All Haskell functions are pure, even those which return an IO computation, right? Because a value of type IO a is not a function which causes side-effects when it is called, but rather a value which represents a computation. At the same time, at runtime the program does perform side-effects, because our main is a pure expression whose value is a computation describing all the side-effects which we want to see at runtime. This way, we can have our cake and eat it too: the language is pure, but the runtime is effectful. One important way in which the language separates the two worlds is by preventing pure functions from depending on the result of an IO computation. Only other IO computations can depend on that. (except if you use unsafePerformIO)  Similarly, in our hypothetical Agda-like language, all functions are total (terminating on all inputs, without ever throwing an exception), even those which describe an infinite IO computation. Because a value of type IO a is not a function which might not terminate when it is called, but rather a value which represents a possibly non-terminating computation. At the same time, at runtime a program simulating a Turing machine might loop forever, because our main is a total expression whose value is a possibly non-terminating computation. This way, we can have our cake and eat it too: the language is total, but the runtime may be partial. One important way in which the language separates the two worlds is by preventing total functions from depending on the result of a possibly non-terminating IO computation. Only other IO computations can do that. (except if you disable the termination checker)"
haskell,3cwv5i,Archaeanimus,6,Sat Jul 11 23:46:47 2015 UTC,Coinduction. Turing-completeness monad:  codata Partial a = Done a | Later (Partial a)
haskell,3cwv5i,mjmrotek,2,Sat Jul 11 22:56:11 2015 UTC,"I'm not familiar with Agda, but how can that be?   Now that I've thought a bit about it, it can't, but just barely. You need one ""partial"" (in the sense of ""non-terminating"") function, and that's run : ∀ {a} {A : Set a} → IO A → Prim.IO A from the standard library. If that were a top-level built-in, or main were just of type IO ⊤ instead of Prim.IO ⊤, you could simulate any Turing machine without partial functions."
haskell,3cwv5i,sqrt2,2,Sat Jul 11 22:56:47 2015 UTC,"Isn't that Turing-completeness is more related to the possibility of infinite loops that are provably undetectable by another program like a type checker, than to failed pattern matches which are trivial (modulo GHC choking on some GADT matches) to detect?"
haskell,3cwv5i,mjmrotek,3,Sat Jul 11 19:12:44 2015 UTC,"Yes, GHC can never reliably detect partiality due to nontermination because of the undecidability of the halting problem. (However, Turing completeness is not just about nonterminating programs, by the way, because there are total but non-primitive-recursive functions -- the canonical example being the Ackermann function -- and primitive recursive functions are exactly those computable in languages with only finite loops.)  Practically, and that's what I was responding to, I wouldn't downplay the problem of partiality due to failed pattern matches. After all, erroneously not matching on Nothing is pretty much the same thing as java.lang.NullPointerException."
haskell,3cwv5i,gelisam,6,Sat Jul 11 20:48:53 2015 UTC,The first thing I add to a new .cabal file is   ghc_options: -Wall -Werror
haskell,3cwv5i,ryani,4,Sat Jul 11 21:17:36 2015 UTC,"not matching on Nothing is pretty much the same thing as java.lang.NullPointerException.   You are much more likely to forget to check for null than to forget to pattern-match on Nothing! The type system forces you to distinguish between Maybe a and a, so when you receive a Maybe a but need an a, there is a conversion step at which you need to decide what to do if your input is Nothing. If I decide to only pattern-match on Just, it means I have decided that due to reasons I am aware of but the compiler isn't, the input can never be Nothing. I may be wrong about that, but at least I was forced to think about it."
haskell,3cwv5i,mjmrotek,2,Sat Jul 11 23:29:10 2015 UTC,"I agree with you, but I think you need a bit more motivation as to why it's correct.  In C, you have one pointer type: Foo *, which always contains NULL as a possible value.  Semantically, large parts of the program expect those pointers to not contain NULL, but there's no way to know for sure which is which, so code evolves to contain more and more checks for NULL.  Similarly in Java and C#, all reference types implicitly can be null and there's no way to create a 'reference type variable but guaranteed not to be null'.  Even in C++, where references are guaranteed* not to be null, they aren't first class variables--storing a guaranteed-non-null reference in a structure type is annoying enough that it may as well be impossible.  On the other hand, in languages where non-nullness is built into the type (Haskell, Scala, Rust), there's a definite point where the conversion happens.  One function takes a Maybe Foo, and if it wants to call a function that takes a Foo it needs to do the conversion there, so there's no ambiguity over which function's responsibility the ""null-check"" is.     * not actually guaranteed by the runtime, assigning a null pointer to a reference is undefined behavior and every runtime I've seen treats a reference as just a pointer. You therefore won't ""fail a pattern match"" at that conversion the same way converting Just a to a does."
haskell,3cwv5i,mjmrotek,18,Sun Jul 12 02:55:02 2015 UTC,"At the risk of sounding like a broken record, these, for example. Longs story short, wanton cruelty to the common memory.   ""What are the legal values of this parameter"" is usually trivial to answer   Unfortunately, ⊥ is always one of the answers."
haskell,3cwv5i,mjmrotek,10,Sat Jul 11 14:56:30 2015 UTC,"Bottom is different from null though. It may lurk inside any type, but we do not use it to structure program flow (and we couldn't even if we wanted to). This situation is the same across all popular programming languages, so I don't think we should separately mention it."
haskell,3cwv5i,_AndrewC_,15,Sat Jul 11 15:43:40 2015 UTC,"Well Haskell is a bit different, as the bottoms may lurk in unevaluated values, while in a strict language they would at the very least have the decency to crash/hang a program immediately, I remember reading Robert Harper's posts about this. Though I admit I never cared about it that much, the last time I had to hunt an exploding variable throughout a program it was royally broken anyway and I had to ""fix"" it by just scrapping the offending part and starting again ;)  EDIT: Sorry, that would be ""strict functional language"", I think. Mutable pointers and NullPointers in particular could be considered to have the same effect as lazy evaluation here."
haskell,3cwv5i,mjmrotek,4,Sat Jul 11 15:54:32 2015 UTC,"Did you ever have a bottom inside a thunk? I certainly avoid bottoms as much as in strict languages, so for me it's been a non-issue so far."
haskell,3cwv5i,hiptobecubic,2,Sat Jul 11 16:08:10 2015 UTC,"Well just like I wrote in that post, I still remember one case of debugging just as heroic as ultimately unnecessary. Other than that, well, in Haskell I'm obviously more eager to use infinite data structures, which can cause this, though it could be considered a side effect of more power."
haskell,3cwv5i,mjmrotek,7,Sat Jul 11 16:32:16 2015 UTC,"Robert Harper's posts about haskell may be constructed with a great deal of thought and a good deal of knowledge,  but objective, fair, balanced and unbiased are adjectives I'm increasingly unable to use for them. He does seem to find many creative ways to conclude that haskell is Wrong and Broken."
haskell,3cwv5i,Archaeanimus,7,Sat Jul 11 23:09:20 2015 UTC,"I admit it's my guilty pleasure that after reading some of his criticisms (for example claims that using unsafePerformIO is rampant in Haskell) I feel like my language of choice is so pragmatic, unsafely powerful and dirty, kind of like a Lisp of the future. Feels much better than being accused of sitting in an ivory tower ;)"
haskell,3cwv5i,psygnisfive,2,Sun Jul 12 10:56:09 2015 UTC,Having bottom not crash the program immediately is a feature. Then you can write code like (not (null x) && foo (tail x)) without it exploding.
haskell,3cwv5i,Archaeanimus,2,Sat Jul 11 16:45:56 2015 UTC,"To be honest I don't think I ever wrote code like this. There are pretty specific circumstances at work here, that && will always short-circuit on the first argument, and that apparently you need to apply some ([a] -> Bool) function. Both in this and in any other case I can imagine right now, a pattern match would be more readable anyway, perhaps in a list or monad comprehension to let the MonadPlus instance short-circuit on failed matches in a more, in my opinion, principled way.  EDIT: Okay, sorry, apparently I'm so used to lazy evaluation that I forgot that >>=, <|>, and the like also depend on it. So nevermind then ;)"
haskell,3cwv5i,psygnisfive,2,Sat Jul 11 16:57:18 2015 UTC,"Does Haskell have some special meaning for ⊥? Because everywhere else, that denotes the empty type, which would only be a legal argument to a function with argument type *."
haskell,3cwv5i,mjmrotek,9,Sat Jul 11 21:43:37 2015 UTC,"⊥ is a value, not a type. The empty type is usually called Void in Haskell, defined via data Void without any constructors. The only value of type Void is ⊥ of course."
haskell,3cwv5i,Archaeanimus,12,Sat Jul 11 23:05:02 2015 UTC,"This is all a question of orthography, so let's be clear:  1) In Haskell, there is no ⊥. There are various things that mean roughly the same thing as that, but there's no symbol that means ⊥. At best, undefined, but that's just one particular terminating flavor of ⊥.  2) ⊥ is used two different ways in the literature, either as a computational value or as a type, as follows:  ⊥-the-type is the empty type (roughly equivalent to Haskell's Void type), which has no elements. It's the nullary disjunction.  ⊥-the-value is the value corresponding to non-termination, implicit errors, undefinedness, etc.  This reuse of the symbol is actually quite reasonable, if you look at the history. ⊥-the-value comes from the mathematical community, where it's often used as the symbol for the least element of a lattice (hence why ⊥ is pronounced ""bottom""). In languages like Haskell, the semantics of the language has to be given in terms of lattices, so that each type A corresponds to a lattice of values of varying amounts of definedness (see here).  The usage of ⊥-as-type comes from the logic community. You see, one particularly important lattice is the lattice of propositions, and in that setting, the least value is the proposition of falsity. So in a logic setting, ⊥ means false, and as a type of course false is Void, since there are no proofs (ie no elements).  When Haskellers write ⊥ when talking about Haskell, they almost certainly mean ⊥-the-value."
haskell,3cwv5i,gelisam,1 point,Sat Jul 11 23:39:30 2015 UTC,"⊥ is used two different ways in the literature, either as a computational value or as a type, as follows   In which particular topics within the literature is it used to denote the value? I've seen it used to denote the empty type many times, occasionally the initial object of a category, and of course the bottom element of a lattice. I've never seen the lattice-of-values interpretation of types before (and I'm not convinced every type corresponds to a lattice; Either for example has no top element)."
haskell,3cwv5i,psygnisfive,3,Sun Jul 12 01:43:29 2015 UTC,"Denotational semantics. See the link I gave, which is a good intro. The poset semantics has to be a lower semi-lattice, iinm. Usually people talk about Complete Partial Orders."
haskell,3cwv5i,Archaeanimus,2,Sun Jul 12 04:38:31 2015 UTC,"It's indeed the empty type forall a. a, except it's not empty in Haskell because of   undefined let x = x in x error ""boom"" etc."
haskell,3cwv5i,psygnisfive,3,Sat Jul 11 21:49:16 2015 UTC,"forall a. a isn't the empty type, though. It's the type of dependent functions Π(a : *), a (which happens to be uninhabited, however). The ""empty"" type in Haskell is Void.  But I know about Haskell having terms of type Void or forall a. a; what I'm asking is whether, when one refers to ""⊥"" or ""bottom"" in the context of Haskell's type system, are they referring to the empty type, or a term of that type."
haskell,3cwv5i,want_to_want,4,Sat Jul 11 22:10:53 2015 UTC,"when one refers to ""⊥"" or ""bottom"" in the context of Haskell's type system, are they referring to the empty type, or a term of that type.   Neither, ⊥ is the name for the ""value"" which is ""returned"" when a function doesn't actually return, but prefers to loop forever or to throw an exception.  It's from denotational semantics, which explains the behaviour of programming languages by mapping their programs to mathematical functions. That is, even though Haskell is based on pure functions which are supposed to be super close to mathematical functions, there is still the important difference that Haskell's pure functions are allowed to loop forever or to throw an exception, while mathematical functions are not, they always return a value no matter what. So to explain the fact that a function f will throw an exception if its argument throws one, we say that f ⊥ = ⊥. There isn't an actual bottom value at runtime, it's just a mathematical abstraction to represent a bunch of different failure cases.  When we want to talk about the empty type in Haskell, we say Void or Empty, never ""Bottom"" or ""⊥""."
haskell,3cwv5i,gelisam,3,Sun Jul 12 00:03:04 2015 UTC,forall a. a and Void are equivalent. But see my reply to quchen below.
haskell,3cwv5i,mjmrotek,3,Sat Jul 11 23:40:15 2015 UTC,"I wouldn't say they're equivalent. Well, equivalent, maybe, but not interchangeable. They're both uninhabited in consistent type systems (by which I mean there is no term of the empty type/no proof of false), but they're propositionally distinct; Void corresponds to propositional falsehood, while forall a. a more closely corresponds to the proposition that all propositions are true, which is of course false -- but not judgmentally so."
haskell,3cwv5i,Peaker,3,Sun Jul 12 01:16:11 2015 UTC,"They're provably isomorphic. To be really precise, forall a. a is the type of the partially-applied case function for Void. Or equivalently, forall a. a is the Church-encoded variant of Void."
haskell,3cwv5i,mjmrotek,2,Sun Jul 12 04:36:22 2015 UTC,"BTW, can someone explain why ""bottom"" serves double duty as failure and non-termination? Why not make it always mean non-termination, and handle failure with sum types in the usual way?"
haskell,3cwv5i,Peaker,4,Sat Jul 11 22:59:00 2015 UTC,"There are multiple ways to give a denotational semantic to a given programming language, depending on what you want to understand about the language. In Haskell we care a lot about strictness, and the denotational semantics which maps pure functions A -> B to mathematical functions (A ∪ {⊥}) → (B ∪ {⊥}) is the one which allows us to talk about that, because if you are strict in a given argument then you will both loop iff your argument loops and throw an exception iff your argument throws an exception. When talking about strictness, separating non-termination and exceptions only makes things more messy without allowing you to say more interesting things.  If you do want to talk about the difference in behaviour between exceptions and non-termination, then by all means, do choose a different semantics, such as mapping pure functions A -> B to mathematical functions (A ∪ {⊥} ∪ E) → (B ∪ {⊥} ∪ E), for some set E of exceptions. In fact, if you want to talk about the behaviour of functions like bracket and catch, you'll have to use such an alternate semantic. Just be sure to mention the fact that you're using a different semantic, because the default semantic is very entrenched by now.  After writing all this, it occurs to me that since you mention sum types, you might not be asking about denotational semantics, but about why Haskell supports exceptions at all. If that's the case, see my rant on the subject elsewhere in this discussion."
haskell,3cwv5i,mjmrotek,3,Sun Jul 12 00:13:46 2015 UTC,"Sum types can be only used to handle expected failure. When the program has to bail out because of a failed pattern match, asynchronous exception, some condition that indicates that the program has been miswritten and there's no way to recover from it, etc, it has to use an ""all-encompassing"" value like bottom."
haskell,3cwv5i,Nebu,1 point,Sun Jul 12 10:17:56 2015 UTC,"Depends on what ""legal"" means..."
haskell,3cwv5i,gelisam,3,Sat Jul 11 15:21:14 2015 UTC,... that what passes the type checker?
haskell,3cwv5i,Nebu,2,Sat Jul 11 15:27:15 2015 UTC,That's one possible meaning.  But I'd usually expect it to mean valid (with application-level validity) inputs.  That is to contrast with weaker type systems whose type checker allows many more illegal inputs than just ⊥.
haskell,3cwv5i,gelisam,2,Sat Jul 11 16:14:46 2015 UTC,"Well okay, I think I misunderstood the question. I thought it meant ""what can I expect from inside a function"", when apparently it was supposed to mean ""what can I pass to the function""."
haskell,3cwv5i,PhineasRex,15,Sat Jul 11 16:21:08 2015 UTC,"I'm assuming based on the wording of this post that you intend to present these arguments to skeptics of Haskell. If so, then I think using absolutes like ""null pointers are impossible"" is setting yourself up for failure.  Consider Scala's approach to this: When I develop in Java in a serious/non-toy project, I encounter an NPE (NullPointerException) at least once a week, and sometimes multiple times a day. In Scala, I've never encountered an NPE in a serious/non-toy project. And yet, we do not say NPEs are impossible in Scala. So what gives?  NPEs are not impossible in Scala. But there is a culture in the Scala community that pushes you towards a specific way of handling the absence of data (namely the Option/Maybe monad) such that in practice, you just never (or so rarely that it's effectively never) end up dealing with nulls.  On the one hand, this ""cultural"" concept is much more complex that a black-and-white ""X is impossible in Haskell"", and thus it will take more effort to convey to someone who is unfamiliar with Haskell.  On the other, I think it is much closer to the true reason Haskell is a much safer language than many others, and I think that truthfulness will be appreciated when the skeptic digs into your argument to see whether it really holds or not."
haskell,3cwv5i,hnerixh,7,Sat Jul 11 18:58:14 2015 UTC,"I am very interested in this comment, as it is not sufficient to simply list Haskell's advantages, we must also express them in a convincing way. Could you please expand on why a skeptic would not be convinced by our claim that NPEs are impossible? Is it because it sounds like it would be too good to be true? Is it because it is stated as an absolute, and so when they find out that there are ways a program could mishandle the conversion from Maybe a to a, they will just assume that Haskell programs suffer from just as many missing Nothing branches as Java programs suffer from NPEs?   And yet, we do not say NPEs are impossible in Scala.   Why not? From your story, it sounds like Scala does a really good job helping programmers deal with the nuisance that are NPEs. Do you make weaker, more realistic claims about NPEs, or do you simply not mention the subject until the skeptic is already convinced through other means?   this ""cultural"" concept is much more complex that a black-and-white ""X is impossible in Haskell"", and thus it will take more effort to convey to someone who is unfamiliar with Haskell.   I think that ""NPEs are impossible in Haskell"" is a very good approximation to this messy truth, and that this kind of useful lie is very common when teaching something which is new to your audience. For example, when I learned about the Bohr atomic model in school, the teacher didn't begin by saying that the model was only a convenient approximation, we were taught the model as if it was the definitive truth, and it's only the students who bothered to take the more advanced class who learned that there existed more complicated, more accurate models.  So in terms of being morally truthful, I'd have no problem claiming that NPEs are impossible in Haskell. However, in terms of being not only truthful but also convincing, I'd really like to know what I should claim instead!"
haskell,3cwv5i,mindless_null,6,Sun Jul 12 00:38:20 2015 UTC,"I don't think we set us up for failure like this. Things made impossible make cultural requirements unnecessary. For example, we cannot ensure a function is total in Haskell, but the culture says to avoid these partial functions if at all possible. I would thus never claim that partial functions are impossible. Nulls/uninitialized stuff on the other hand is."
haskell,3cwv5i,vagif,5,Sat Jul 11 20:45:43 2015 UTC,"I suspect that a skeptic might say something along the lines of ""You just renamed 'null' to 'bottom' and then declared 'therefore null is impossible'."" and then if you try to explain the difference between null and bottom, they'll just ask ""Can you assign bottom to any value? If you 'dereference' (or did you rename that to 'evaluate'?) bottom, does your program crash?"" and by then you will have lost a lot of credibility which will make your further explanations sound suspect."
haskell,3cwv5i,mindless_null,3,Sun Jul 12 08:05:09 2015 UTC,"I see! So which words should we use to convey the advantage of Maybe over nulls, then? How about this:   Haskell uses a different type for values which can be null and values which cannot. This has two advantages:   The type-checker will stop you if you should have done a null check but didn't, and You no longer have to pollute your code with defensive null checks everywhere.    For the record, here is what I would reply to the skeptic who thinks Haskell renamed null to bottom:   That is true, any value can evaluate to bottom, and evaluating bottom does raise an exception. But the exception it raises is closer in spirit to a StackOverflowError than to a NullPointerException. Haskell doesn't claim to solve the halting problem -- any expression can still get stuck in an infinite loop! In Java, both kinds of exceptions could be thrown by any code, but in the case of nulls, you're able to check whether the expression is null, and a NullPointerException is what happens when you forget to do that. In Haskell, you can't forget, because the compiler will remind you. With infinite loops, whether you're in Java or Haskell, there is just no way to check whether a given call will loop forever or not, you just have to hope it won't."
haskell,3cwv5i,tdammers,1 point,Sun Jul 12 15:35:40 2015 UTC,"People don't say NPEs are impossible in Scala because they are quite possible. null is built right into the langauge.  Even though it's use is discouraged, Java interop brings it back in.  Even if you don't use Java or null, you still encounter NPE due to initialization order errors. Don't even talk to me about the reflection API!"
haskell,3cwv5i,koalillo,11,Mon Jul 13 01:33:07 2015 UTC,"As op requested, one short paragraph.  For larger systems Haskell's type system allows the developer of an API, library or even module, to enforce a certain way of using said API, library or module, unlike other languages where it is trivial to use a library in a stupid way. In Haskell it simply won't typecheck.  Of course this ""enforcement"" also scales down to individual functions.  (edit: remove C++ bashing) (Apparently I missed that one paragraph per argument thing...)"
haskell,3cwv5i,tdammers,10,Sat Jul 11 15:00:01 2015 UTC,"Can't misspell a variable, function, or field.  The last one's the worst, especially when assigning, where in for example javascript I won't get any sort of error except that things are mysteriously not working.  Or, worse yet, they will work for awhile and then stop in the future, making it all the more difficult to find the origin."
haskell,3cwv5i,koalillo,5,Sat Jul 11 16:58:06 2015 UTC,That's more of a static vs dynamic typing and has nothing to do with haskell.
haskell,3cwv5i,tdammers,4,Sat Jul 11 17:38:21 2015 UTC,"I dunno, I think it meets the qualifications put out - ""...kinds of bugs people found in other languages that would have been impossible in reasonably written Haskell code.""  Sure, it might also be impossible in other classes of languages as well, but the same can be said for the other points given."
haskell,3cwv5i,koalillo,6,Sat Jul 11 18:08:47 2015 UTC,"Not really; you could have a dynamically typed language where assigning to a property that hasn't been declared on an object causes a loud failure, instead of silently adding the property."
haskell,3cwv5i,beerdude26,4,Sat Jul 11 18:14:22 2015 UTC,Many dynamically typed languages do this- the point is that static languages detect this at compile time. What you propose still gives you a malfunctioning program at execution- a bug.
haskell,3cwv5i,tdammers,1 point,Sat Jul 11 18:43:02 2015 UTC,"No, the point here is whether the detection happens at all. In Python, assigning to a variable that doesn't exist silently creates it; but some other dynamic languages (e.g. Perl or JavaScript in strict mode) will raise an error when you do this. Of course failing loudly at compile time is better than failing loudly at runtime, but failing loudly at runtime is still orders of magnitude better than not failing at all and instead silently producing incorrect behavior, and the benefit of static vs. dynamic is much smaller in this scenario than that of detecting the typo and not detecting it.  It is pretty hard to design a static language that has this problem (because in order to resolve identifiers at compile time, you have to, well, resolve them, and when that fails, it's easier to throw than to retroactively introduce a new variable), and it's very tempting to design a dynamic language that has it (""for convenience""), so virtually no static languages has this problem, while many dynamic languages do, so maybe that's where the confusion stems from."
haskell,3cwv5i,sccrstud92,1 point,Sun Jul 12 14:48:01 2015 UTC,"Yes, it is better to err at runtime than to continue. Still a bug. If it fails at compile-time, it is not a bug."
haskell,3cwv5i,vagif,2,Sun Jul 12 15:49:17 2015 UTC,"Disagree. Checking in code that doesn't compile is a bug. Checking in code that fails automated tests is a bug. Checking in code that produces incorrect results is also a bug.  class Foo {     int bar; };  def foo = new Foo(); foo.baz = 23; // <- THIS IS A BUG.   That last line is a bug one way or another; the difference is when you are going to catch it - at compile time, when the code itself runs, or maybe much later when it turns out that you've been saving wrong values to the database for months, and have lost large amounts of mission critical data, and then your manager comes to your desk and asks how this is possible and you don't really have a good explanation and neither does your team lead, and you all get fired and then you spend your days building Drupal websites for people who shouldn't be allowed anywhere near electronic devices or useful information of any kind, or teaching Microsoft Word and Outlook Express to unmotivated long-term unemployed fellow citizens who only take your class because it's free and they'd be cut on their welfare if they didn't, and it doesn't really matter whose fault it was anyway because that information you lost was so critical that the whole company goes down the drains and everyone is laid off except for the boss who gets fired just in time to give him what's left of the company's value as a golden handshake and to cash his equity shares and book a flight to the Bahamas.  Anyway, wrong code is a bug one way or another, the question is when and how you find out that it's wrong, and in that regard, finding out earlier is strictly better."
haskell,3cwv5i,TheCriticalSkeptic,1 point,Sun Jul 12 16:06:42 2015 UTC,"Checking in code that doesn't compile is a bug. Checking in code that fails automated tests is a bug   I have never ever seen anyone refer to those things as a bug, and never seen a definition that includes that. A bug strictly refers to a defect that causes a program to behave incorrectly. A runtime error instead of undefined behaviour can minimize the impact of a bug (that is, the code aborts and does not continue causing more damage), but it rarely eliminates it (it can eliminate it in some cases, but I really cannot think of a non-contrived example. In the vast majority of cases, the code does not do what it was intended to do- hence a bug. However, the detection at run-time prevents further bad things from happening- hence minimizes damage).  When people say that Haskell prevents bugs, one of the things they mean is the type system is so powerful that many programming errors which would happen at execution time in other languages are compile time errors in Haskell- thus preventing bugs (by turning them into compilation errors).   The good thing about compile-time errors is that it's global. Runtime errors are only detected if code is run, so if something is a compile-time error in a language, it will always be detected before it falls into customer hands, whereas if it is a runtime error in another language, it won't be detected until it's hit in execution, possibly in customer hands. Testing increases the code hit before getting into customers' hands, so it helps weed out bugs, of course."
haskell,3cwv5i,Stratege1,1 point,Sun Jul 12 21:42:36 2015 UTC,"That last line is a bug one way or another; the difference is when you are going to catch it - at compile time, when the code itself runs, or maybe much later when it turns out that you've been saving wrong values to the database for months, and have lost large amounts of mission critical data, and then your manager comes to your desk and asks how this is possible and you don't really have a good explanation and neither does your team lead, and you all get fired and then you spend your days building Drupal websites for people who shouldn't be allowed anywhere near electronic devices or useful information of any kind, or teaching Microsoft Word and Outlook Express to unmotivated long-term unemployed fellow citizens who only take your class because it's free and they'd be cut on their welfare if they didn't, and it doesn't really matter whose fault it was anyway because that information you lost was so critical that the whole company goes down the drains and everyone is laid off except for the boss who gets fired just in time to give him what's left of the company's value as a golden handshake and to cash his equity shares and book a flight to the Bahamas.   Please, no! Not Drupal! I have kids!"
haskell,3cwv5i,mjmrotek,1 point,Fri Jul 17 11:57:54 2015 UTC,Yes. That's why you will accept that job.
haskell,3cwv5i,phadej,2,Fri Jul 17 17:17:57 2015 UTC,Are you saying that we should only point out classes of bugs that only haskell prevents?
haskell,3cwv5i,mjmrotek,1 point,Sat Jul 11 23:50:21 2015 UTC,But this specific bug is prevented by java and c# as well. So it does not help to answer the question how is haskell better than those 2 industry leaders.
haskell,3cwv5i,Bzzt,7,Sun Jul 12 02:45:07 2015 UTC,"I think it might also be fair to talk about entire classes of bugs which Haskell introduces. This is not to sound negative but Haskell does have academic roots, so we should look for academic honesty.    Data constructors with different accessors / different numbers of elements. So calling baz function on a Bar constructor for a Foo data type. Space leaks caused by lazy evaluation building up Thunks Libraries that violate the laws of a type class, e.g. A Monad that's not associative.   In terms of bugs I found Haskell does eliminate is largely around mutation. But consider that Rust forces explicit pass by reference / pass by value along with typing of mutable variables. It can also help eliminate these bugs while giving the flexibility of mutation when needed.  But no other language I've used is as good as managing side effects. Every side effect needs to be encapsulated. And the type system will keep track of them. It reduces the chance that you will miss something during refactoring."
haskell,3cwv5i,mjmrotek,1 point,Sat Jul 11 22:06:18 2015 UTC,"Data constructors with different accessors / different numbers of elements. So calling baz function on a Bar constructor for a Foo data type.   Can you please elaborate what you mean with that? From your statement there I can see no issue with calling baz on that. Is baz a partial function or what exactly is the issue?   Space leaks caused by lazy evaluation building up Thunks   Not exactly so much a bug (your program will still reach the correct result at the end of evaluation, after all) as it is a (sometimes extremely nasty) performance problem. Which is btw sort of where I see Haskell's biggest downside: How increadibly unreasonably hard it can be at times, for me atleast, to reason about performance in Haskell.   Libraries that violate the laws of a type class, e.g. A Monad that's not associative.   That is not really unique to Haskell in any way, apart from using Typeclasses perhaps, in any OOP system I can create an implement an Interface in a dishonest way (that is, in a way which violates the intention and documentation of the interface). Replace Interface with whatever the language's equivalent is."
haskell,3cwv5i,dgonyeo,3,Sun Jul 12 12:32:29 2015 UTC,"Can you please elaborate what you mean with that? From your statement there I can see no issue with calling baz on that. Is baz a partial function or what exactly is the issue?   I think he means  data Foo = Bar {foo :: Int, bar :: String} | Baz {baz :: Double}   then  > baz $ Bar 0 """" *** Exception: No match in record selector baz.   Not only this is legal Haskell, there's actually code like this in GHC itself."
haskell,3cwv5i,Peaker,1 point,Sun Jul 12 18:39:33 2015 UTC,"You can omit the names of the fields, so functions aren't defined. Yet they are handy with RecordWildCards (and for updates) and when dealing with huge sums of products as in the linked example. OTOH some advice to define separate record types for the sum:  data S = A A' | B B' | C C' data A' = A' { ... } data B' = B' { ... } data C' = C' { ... }"
haskell,3cwv5i,lw9k,1 point,Mon Jul 13 20:44:25 2015 UTC,"I generally use vinyl whenever I need row-polymorphics records. I guess it wouldn't be the best solution for GHC code, but it's fine for applications."
haskell,3cwv5i,Peaker,5,Tue Jul 14 08:45:28 2015 UTC,"Automatic type conversion problems.  For instance:  object.SetValue(3445);  But unfortunately for the class of which object is an instance, SetValue is overloaded and only has string and bool implementations.  C++ converts your number to a bool and parties on."
haskell,3cwv5i,joeyadams,1 point,Sat Jul 11 18:16:37 2015 UTC,"I think it's important even in the supposedly more benign case of conversions between numeric types. Haskell seems to get flak for all the fromIntegral etc functions that have to be used constantly, but I think that when writing some numeric code it's nice not to have to worry about some implicit truncations that might happen if there were automatic conversions."
haskell,3cwv5i,pigworker,9,Sun Jul 12 10:50:29 2015 UTC,"I actually recently hunted down a bug at work that couldn't have existed in Haskell. I work in Go, and we had a global level struct that we intended to never change. It mostly just contained some special values in its fields to make looking up a specific thing easy. The type of this struct is used extensively in our codebase, and is often mutated to track changes in things. Long story short, it ended up getting passed into a function somewhere that ended up modifying the values of the struct, and breaking a lot of things. In Haskell, this global value would have been immutable, thus preventing it from being modified in unexpected ways."
haskell,3cwv5i,chromaticburst,7,Sat Jul 11 18:50:53 2015 UTC,"Perhaps ironically, it'd also be immutable in c.."
haskell,3cwv5i,yokohummer7,3,Sat Jul 11 21:47:42 2015 UTC,"Well, you'd probably pass it as a pointer so you'd have to explicitly label it const T*, and that won't actually stop you from casting the const-ness away (as silly as that is, many C programmers do this, and C++ even has const_cast<T> for it.)"
haskell,3cwv5i,chromaticburst,1 point,Sun Jul 12 03:12:07 2015 UTC,"If you declare the global variable as const, then it is undefined behavior to modify it.  If you pass it by pointer, it doesn't have to be a global variable, and it can be passed from some function after having computed it while still being const.  Casting away const is a huge red flag, and typically you'd ban it except in very well-justified cases."
haskell,3cwv5i,Tickitata,1 point,Sun Jul 12 16:26:29 2015 UTC,"Don't forget that the code that modifies that ""read-only"" struct was committed a year ago, so you can't simply fix it without breaking some other piece of the software that was relying on the buggy behavior."
haskell,3cwv5i,gelisam,9,Mon Jul 13 18:25:12 2015 UTC,Be careful not to fall into the trap of advocating type systems on the basis of what they are against. Remember what they are for: communicating exploitable structure to other humans and to the computer.
haskell,3cwv5i,yokohummer7,4,Sun Jul 12 10:56:28 2015 UTC,"It's easier to just list deficiencies in other languages, which could go on indefinitely - not because Haskell is perfect, but because there are so many lowest common denominator languages like Javascript.   No more switches with missing cases  (especially when enums get updated and you have to hunt down code) Java / runtime type checking - no more using Object and ""instanceof"" checks in an attempt to fake sum types. Missing checks if classes get added. Javascript / duck typing - if you want to do the equivalent of a typeclass between several objects, you just have to hope you remembered to implement them all. Javascript - since all arguments to a function are optional no way to force calling a function ""correctly"". Have to throw a runtime error instead."
haskell,3cwv5i,MethodOverDrive,6,Sat Jul 11 16:20:23 2015 UTC,"No more switches with missing cases (especially when enums get updated and you have to hunt down code)   Haskell doesn't have exhaustive pattern matching. Missing cases won't produce compiler errors. You can work around this issue by turning on compiler warning, but the same thing can be done with C compilers."
haskell,3cwv5i,yuuko273,5,Sat Jul 11 20:20:54 2015 UTC,"You're definitely right, I don't know what I was thinking. I could have sworn there was a language that enforces exhaustive-ness if there is no default/otherwise in the match?"
haskell,3cwv5i,Nebu,3,Sat Jul 11 21:44:34 2015 UTC,Swift enforces exhaustive switch statements - surprised it's not in Haskell
haskell,3cwv5i,Chris_Newton,1 point,Sun Jul 12 02:40:48 2015 UTC,"Haskell does check for exhaustiveness, you just have to enable warnings. I don't know why warnings are not enabled by default, I think they should be.  Here is a program in which the False case is missing:  module Main where  boolToInt :: Bool -> Int boolToInt b = case b of     True -> 1     -- missing case for False!  main :: IO () main = print $ boolToInt False   By default, we don't get any warning, so we only get an error at runtime:  $ ghc Main.hs $ ./Main  Main: Main.hs:(4,15)-(5,13): Non-exhaustive patterns in case   The sane thing to do is to turn on at least the default warnings:  $ ghc -W Main.hs Main.hs:4:15: Warning:     Pattern match(es) are non-exhaustive     In a case alternative: Patterns not matched: False   It's a good idea to enable ""all"" the warnings (which in reality is more warnings than the default but still not everything), and maybe even to turn warnings into errors:  $ ghc -Wall -Werror Main.hs Main.hs:4:15: Warning:     Pattern match(es) are non-exhaustive     In a case alternative: Patterns not matched: False Failing due to -Werror."
haskell,3cwv5i,mcandre,2,Sun Jul 12 16:02:32 2015 UTC,"Haskell doesn't do so, GHC does. Differentiating this is important, because if one says Haskell can do exhaustive matching, the same can be said for C. Both GCC and Clang do this trivially.  int main(void) {     enum { Red, Green, Blue } color = Red;      switch (color) {         case Red:             break;         case Green:             break;     }      return 0; }   Compiling:  $ clang test.c test.c:4:13: warning: enumeration value 'Blue' not handled in switch [-Wswitch]     switch (color) {             ^ 1 warning generated.   As you can see Clang enables this warning by default, which is arguably safer than what GHC does.  However, no one claims C has exhaustive matching. Neither does Haskell.  Rust and Swift are the examples of languages that truly support exhaustive matching."
haskell,3cwv5i,rstd,3,Sun Jul 12 19:34:26 2015 UTC,"Psh, you oughtta be using the ""composite pattern"" to fake sum types in Java. For example, write an interface representing the top-level ""datatype"" (e.g. List) and classes representing the constructors (e.g. Cons, Nil), and then put all of the functions that should just be a successful pattern match on Cons onto the Cons class, etc. You end up having to put all of the functions related to each constructor right on the class involving it (if you want to truly avoid all the ""instanceofs"") but according to some proponents of OOP, this would be an organizational benefit somehow. (The user knows all of the useful List functionality is right in the List class and doesn't need to concern themselves with other functions about lists that the original implementer - you, in this case - didn't think of). Anyway, I'm not actually being facetious about this pattern being a good way to fake sum types - I use it all the time if I have to use Java, and the lack of explicit runtime type checks makes the control flow much simpler."
haskell,3cwv5i,yitz,3,Sat Jul 11 19:25:22 2015 UTC,"There are two systems at work here - Haskell's type system, and the language semantics. You can think of these roughly correlating to the rules governing types and terms. Haskell's type system only catches type errors, but what makes it useful is the ability to encode information in the types in such a way that many programming errors will present themselves as type errors at compile time (wrong argument order/count, using Maybe to encode the possibility of failure, type-safe vectors, pure mutation with ST (mutable cells cannot escape ST, so runST is pure), homogenous lists, etc).  The other system is the semantics of the rest of Haskell, which is pure, so functions cannot keep state (except for those in IO), and also doesn't know anything about pointers (so null pointers are impossible), memory management (it does it all for you so you can never double free, use after free, etc), or allow access to arbitrary memory, so things like segmentation faults should be impossible without a bug in the compiler itself.  That all being said, the guarantees that the the type/runtime system give you are not absolute - there is the possibility of bugs, which might invalidate some guarantees (an error in the garbage collector could give you a runtime error, things of that nature), but also there are some holes in the type system: usage of ""unsafe"" things such as unsafeCoerce and unsafePerformIO basically means all bets are off, and certain kinds of recursion* can mean that the typechecker cannot always catch all kinds of type errors.  * ie:  data False false :: False false = false   will not result in a type error, even though it is obvious that it is impossible to produce a term of type False."
haskell,3cwv5i,Vektorweg,3,Sat Jul 11 15:26:16 2015 UTC,"ertain kinds of recursion* can mean that the typechecker cannot always catch all kinds of type errors. * ie:   data False false :: False false = false    will not result in a type error, even though it is obvious that it is impossible to produce a term of type False.   IMHO, that isn't a type error, and isn't necessarily an error in general, without knowing the greater context of what the programmer's intent is. It seems similar to foo x = x + 1, which may or may not contain an error in it, depending on what the programmer intended when they wrote that."
haskell,3cwv5i,chrisdoner,3,Sat Jul 11 18:45:57 2015 UTC,"I work on a program with a pipeline-style architecture that applies a graph of transformations to systematically convert the input data into a different form of output data. Most of the transformations along the way only make a modest, incremental change, so their input and output types can be quite similar. However, the data passed between stages is mostly highly structured — lists of maps from enumerated values to records containing more lists, and the like.  The previous version of this program was written in a language with a very dynamic type system. It was perilously easy to confuse the input and output types. You could have some edge case in a transformation function clone part of the input data within the output, without applying the full transformation as intended, and either silently cause incorrect final output as the error propagated through the system or cause a visible failure but only in code far away from the root cause. Even worse, erroneous code might not clone the data but alias it because of the reference semantics typical of the popular dynamically typed languages, leading to subtle corruption if that particular data was an input to multiple transformation stages. Any sort of refactoring that rearranged the transformations so they applied in a different order or changed series/parallel relationships would also be extremely difficult to get right.  With a type system like Haskell’s, where you can name and distinguish all the types, you can be explicit about the expected structure at each interface from one stage to the next, and mutability can’t sneak in unnoticed, such errors are much harder to overlook."
haskell,3cwv5i,Vektorweg,3,Sat Jul 11 19:58:49 2015 UTC,"Haskell has no null type or value. An integer must be an actual integer, a string must be an array of zero or more characters. There are plenty of types for representing non-data, such as Nothing or Left ""<error message>"", but no Haskell function can be passed a null value. The programmer never has to guess at types. Haskell has especially strong type signatures, even typing for side effects like I/O and random number generation. You get a solid sense of how a function behaves based on the input / output signature alone. Again, strongly typed languages catch many kinds of invalid function parameter errors. Something Erlang, a dynamic language similar to Haskell, cannot do very well. Erlang only valides the number of arguments, not the types. As a pure functional language, Haskell is quite excellent at caching/memoization/idempotence. Simon Peyton Jones likes to say that in Haskell, functions can't accidentally fire a missile too many times due to multiple function calls.   Read Learn You A Haskell and Real World Haskell, two excellent free ebooks on introductory Haskell programming."
haskell,3cwv5i,mjmrotek,4,Sat Jul 11 21:54:47 2015 UTC,"Null pointers are impossible   Haskell has partial functions, a few even in Prelude. So that pretty much nullifies that argument. You can't have null pointers because Haskell has no pointers, but you have a whole other class of bugs which are possible.   ""What are the legal values of this parameter"" is usually trivial to answer   There is a fine line between a legal value and one that makes sense: threadDelay (-1). Furthermore, in particular in IO APIs, passing a legal value to a function can make it throw an exception (which are in most cases completely undocumented). The compiler won't warn you and when reviewing the code the behavor may not be obvious.   Wrong argument order is likely to cause type errors   Only if you newtype everything. But if you do that then the API becomes cumbersome to use. And even then sometimes not. Example: (-). (I hope some crazy Haskell proponent won't get the idea to newtype both arguments to (-)).   Calling a convenience function never changes that function (e.g. a ""validate"" function that resets some counters, which I've recently seen)   Can't make that statement in general. You need to inspect the function type, otherwise it's just an assumption."
haskell,3cwv5i,gelisam,6,Sat Jul 11 16:13:57 2015 UTC,"Haskell has partial functions, a few even in Prelude. So that pretty much nullifies that argument.   I don't see how. Null and Bottom are two very different concepts. In addition to that, using head/tail/... is very much frowned upon by the community. Java on the other hand is full of nulls, and they're seen as ""sometimes necessary"", ""part of the language"" and what not."
haskell,3cwv5i,sambocyn,1 point,Sat Jul 11 20:48:20 2015 UTC,"""What are the legal values of this parameter"" is usually trivial to answer   You can usually construct your program so that ""What are the legal values of this parameter?"" is both trivial to answer by a human reader and automatically verified throughout your program by the compiler."
haskell,3cwv5i,gelisam,1 point,Sun Jul 12 11:47:16 2015 UTC,Null pointers are impossible   This point isn't clear. The Haskell type system doesn't have much to do with pointers. But the type system prevents the use of e.g. integer as a pointer.
haskell,3cwv5i,mjmrotek,16,Sat Jul 11 14:25:31 2015 UTC,"The ""null pointer"" case is just an example of bad language attached to a legitimate concept, the real thing it's trying to say is ""no implicit nulls"", but Java's NullPointerException's infamy appeals to the imagination of developers better than ""implicit null"".  I always add the caveat that Haskell has implicit exceptions (any value can just explode when you try to use it, breaking abstraction barriers), which is actually worse than nulls per se. The bad news can be qualified with the fact that people don't use exceptions as a form of data like null is used, so it's much rarer."
haskell,3cwv5i,gelisam,1 point,Sat Jul 11 14:32:56 2015 UTC,Thank you. I didn't got that point.
haskell,3cwv5i,mjmrotek,1 point,Sat Jul 11 14:51:39 2015 UTC,"Yeah, I think non-monadic exceptions are an evil part of Haskell, and I'm glad people tend not to use them."
haskell,3cwv5i,gelisam,4,Sat Jul 11 14:59:58 2015 UTC,"I disagree. I think there are two different kinds of runtime errors, and that it is a good idea to have two separate mechanisms for handling them.  Consider the two functions below:  lookup :: Key -> IntMap a -> Maybe a (!) :: Vector a -> Int -> a   The two functions are very similar: they both take a particular type of container, a key of type Int, and their happy path is that they find and return a value corresponding to that key. However the functions differ in the error mechanism they use for the unhappy path: lookup returns Nothing, while (!) returns bottom. Why?  Because the first kind of error is an expected error, while the second one is an unexpected error.  An IntMap contains some keys and not others, and when you're looking up a key, you're also asking whether the key exists. You need to deal with the case in which the key doesn't exist, and you want the compiler to remind you if you forgot to do so.  A vector contains a value for all indices from 0 to length - 1. Typically, you iterate over every value in that range, or you binary search through it, and every single index you use with the vector lies within the required range. You do not intentionally use an index which lies outside of the range, and if you get a number from somewhere else, you don't try to use it to index into the array in order to find out if your number is greater than the range or not.  Of course, mistakes happen, and sometimes we do write code which indexes outside of the vector. But what's the proper way to handle this? This is an unexpected error, and so by definition, we don't know what happened and we don't know how to handle it. The only thing we can do is to cleanup any resources and to pass the bad news up the stack. Which is what bracket and exceptions are for.  About using Either or Maybe as a monadic way to pass the bad news up the stack. This would make a lot more sense in a language like Agda, in which you can use mathematical proofs to explain to the compiler why you're so certain that the key is already in the map or that your algorithm terminates. In Haskell, we can't prove everything (and IMO proving everything is too much work for little return), especially not termination, so pretty much every single piece of code would have to run in the ""unexpected failure"" monad, which would make that type distinction meaningless. So instead, we have language-level support for unexpected failures via exceptions, and we reserve the Either and Maybe monads for expected failures.  About fromJust. Some people hate fromJust and other partial functions because they ""lie"". I disagree: fromJust is a convenient shortcut for the programmer to convert between an expected failure and an unexpected failure. Sometimes you have a key and you know that the key is in your map, because you put it there earlier. You can pattern-match on the Maybe and throw an exception in the Nothing branch to tell the compiler that you ""know"", or at least don't expect, the key to be missing in this particular call. Or you can call fromJust, it's the same thing. I do wish it was called unsafeFromJust or partialFromJust though.  I also wish that fewer system libraries were reporting their failures via exceptions. openFile's documentation lists three different exceptions which it could throw. Well, it they are documented, then those errors are clearly not unexpected! If the file doesn't exist, it's not a programmer error, it's a user error, and those errors are precisely the kind of corner cases which I am likely to forget to write code for, and which the compiler should remind me about."
haskell,3cwv5i,mjmrotek,1 point,Sat Jul 11 23:15:22 2015 UTC,"if you know the index is less than the length, you can often just use a V.map and V.fold, right?"
haskell,3cwv5i,everybodyhatesclowns,2,Sat Jul 11 23:39:29 2015 UTC,"The situations in which we ""iterate over every value in that range"" can probably be rephrased in terms of maps and folds, yes. I'm talking about the situations in which (!) is used anyway, for example in the implementation of those mapping and folding functions, when implementing binary search, etc."
haskell,3cwv5i,ryani,1 point,Sun Jul 12 02:09:47 2015 UTC,"Because the first kind of error is an expected error, while the second one is an unexpected error.   To be honest, putting something like  error: ""Impossible, because this and that""   seems a much more polite way of indicating that you're sure that something shouldn't happen, so that if the impossible does happens, it's easier to find the source. Of course this might too cumbersome for some situations like for example binary search you've mentioned (though vectors seem to be a special case as they're guaranteed to contain all consecutive indices up to their length, so there's no need to check the bounds more than once, since Haskell does guarantee that the vector won't shrink on you unexpectedly). I still think that using constructions that provide information to the compiler, like pattern matches instead of boolean comparisons or high order functions instead of manual indexing, is an important strength of functional languages that shouldn't be given up easily.   monadic exceptions   Are you referring to my ""non-monadic exceptions are evil"" post? If so, I actually meant that throwing exceptions off pure code is much more misleading to the users that throwing them off IO. (of course, there are still exceptions which technically aren't asynchronous but appear so because of Haskell's high level nature, such as an out of memory exception, but I think it's no excuse to create more of them)   I also wish that fewer system libraries were reporting their failures via exceptions. openFile's documentation lists three different exceptions which it could throw.   +1, this is my pet peeve about the standard libraries."
haskell,3cwv5i,nico159,1 point,Sun Jul 12 06:59:30 2015 UTC,"[using an explicit error message] seems a much more polite way of indicating that you're sure that something shouldn't happen   I agree. Note that since error is itself throwing an exception, we are now discussing best practices for using exceptions, which is a much more nuanced question than whether exceptions are ""evil""."
haskell,3cwv5i,ryani,1 point,Sun Jul 12 14:34:57 2015 UTC,"I agree with the wiki page on errors and exceptions, IMO exceptions thrown by 'error' are best used for programming errors (like ""this should not happen, please report a bug""), and should not generally be caught (unless in some mission critical stuff). Like it says in the docs:  error :: [Char] -> a error stops execution and displays an error message.   I don't think that typed (""typed"" as in ""of some special type meant for a particular kind of an exception, not just String"") exceptions thrown through IO are evil. I see them as a nice way to halt doing IO declaring that some input is irredeemably broken / IO is impossible the way it was set up / whatever, so that any (IO a) value that happen not to be an exception contains a well-formed value of 'a', that is safe to be passed to pure functions without any more surprises. I have mixed feelings about exposing them to library users, though; as they're not documented in types, they feel more like an implementation detail to me, that should be dealt by the library itself, and the failures reported with something more explicit like Either, Maybe, or some custom sum type."
haskell,3cwv5i,Bzzt,1 point,Sun Jul 12 15:52:13 2015 UTC,"the wiki page on errors and exceptions   Thanks for the link, I had not encountered this page before. To clarify, what I call an ""unexpected error"" corresponds to what this wiki page calls an ""error"", while an ""expected error"" corresponds to what this wiki page calls an ""exception"".  What I call an ""exception"" includes anything which bypasses the type system to wind up the stack and release resources via bracket, and therefore include both error and throw. I think this corresponds to what the wiki page calls an ""IO exception"" and to what you call ""non-monadic exceptions"".  What I call ""failure monads"" includes things like Maybe and Either, which implement the propagation of failure as a monadic effect. I think this corresponds to what the wiki page calls ""exception monads"" and to what you call ""monadic exceptions"".  The wiki page claims, if I understand correctly, that errors and exceptions may be propagated using any mechanism including error codes, IO exceptions, and exception monads. The difference is that exceptions should be documented and callers should handle them, while errors should not be documented nor handled. What I am claiming instead is that errors should be propagated using IO exceptions, while exceptions should be propagated using exception monads. I do agree that errors should not be documented nor handled.  I personally find the wiki page's nomenclature more confusing than either mine or yours, but if it's standard, I'll try to adopt it. Do you know of any document advocating it which was not written by Henning Thielemann?"
haskell,3cwv5i,everybodyhatesclowns,1 point,Sun Jul 12 17:11:29 2015 UTC,"What I call an ""exception"" includes anything which bypasses the type system to wind up the stack and release resources via bracket, and therefore include both error and throw. I think this corresponds to what the wiki page calls an ""IO exception"" and to what you call ""non-monadic exceptions"". What I call ""failure monads"" includes things like Maybe and Either, which implement the propagation of failure as a monadic effect. I think this corresponds to what the wiki page calls ""exception monads"" and to what you call ""monadic exceptions"".   Sorry for the misunderstanding, by ""non-monadic exceptions"" I meant anything that returns a bottom of sorts, so undefined, throw, and error. And these I personally consider evil, unless used to pull the handbrake in some desperate situation. By ""monadic exception"" I meant these that occur within a monad, so throwIO, throwM, etc, though Left and Nothing would also qualify, I guess. It's arguable whether any bypassing of the type system occurs with the former, as you certainly could imagine IO as something like  IO a ~ StateT RealWorld (Either Dynamic) a   even though it's not really implemented like that. When using Control.Monad.Catch from exceptions, the same throwM can be either an error or an exception in your nomenclature, depending on what monad is at the bottom of the stack (IO or Catch, the latter being ~ Either SomeException), so I don't think it's a valid distinction."
haskell,3cwv5i,hiptobecubic,0,Sun Jul 12 17:59:35 2015 UTC,"I think the null pointers thing is false. There is bottom in Haskell and it inhabits every type. That's even worse than null pointers in eg. C++: there, I KNOW that a reference (Foo&) will never be null, same for a stack value (Foo). The only things that can be null are pointers (Foo*, std::..._ptr<Foo> and the like).  That being said, I think that haskell's purity...   ...makes it easier to keep focused on separating concerns: I'm more likely to do the difficult algorithm in one reusable function and then wrap it into some monad later. In other languages it might happen that I end up with IO in my algorithm or state that it doesn't need -- all limiting reuse. ... allows me to not care about execution order. Purity is lazy and eager evaluation leading to the same result.   Handling complicated stateful operations in haskell is wonderful: I can run some stateful computation, but roll back the state changes if I don't like the result. For doing that, I don't have to know what those state changes are! This would be very tricky in traditional languages (you'd need to implement some form of book keeping or try to find ways to recognise when not to run a computation in the first place)."
haskell,3cwv5i,SrPeixinho,9,Sat Jul 11 16:38:05 2015 UTC,I KNOW that a reference (Foo&) will never be null   int main() {     Foo* p = 0; // null     DoTheThing(*p); // this line doesn't crash?     return 0; }  void DoTheThing(Foo& you) {     you.DoThatThingYouDo(); // crash doesn't happen here either }  class Foo { public:     int mValue;     void DoThatThingYouDo() {         mValue++; // crash happens here?!?!?!     } };   WHERE IS YOUR GOD NOW?
haskell,3cwv5i,_AndrewC_,1 point,Sat Jul 11 17:19:42 2015 UTC,"Your code contains undefined behaviors and so is not standard-conforming program code. You can critics C++, but is not nice bashing it with examples that are not valid"
haskell,3cwv5i,gelisam,3,Sun Jul 12 03:04:49 2015 UTC,"Standards-specified undefined behaviors are not useful when they can (1) be caused by code far away from the site of said behavior and (2) no major compiler contains code to insert runtime checks for that behavior.  See my other comment about this guarantee.  Real code contains bugs, including bugs like this which, according to the standard, can cause demons to fly out of your nose.  I've had to debug a ""null pointer inside a reference"" many many times.  I'm tired of arguing with C++ official standards pedantics about this issue when every major compiler treats code with this problem exactly the same way.  This discussion is about common bugs in code which Haskell prevents, and ""assigned a pointer that I thought wasn't null to a reference when it really is"" is exactly the kind of bug that C++ encourages you to shoot yourself in the foot with.  Basically everywhere the standard specifies ""undefined behavior"" they mean ""this will cause your code to segfault or trash memory in unknown ways"", and this is one of the ways that can happen.  TL;DR: C++ doesn't help you write ""standard-conforming program code"", so nobody actually does.  Most buggy C++ programs are buggy because they contain undefined behavior."
haskell,3cwv5i,SrPeixinho,1 point,Sun Jul 12 06:19:02 2015 UTC,This reminds me of pedestrians who walk into crosswalks without looking.  The fact that the law says traffic must stop for pedestrians in crosswalks will not accomplish a miraculous resurrection if you get hit by a bus.
haskell,3cwv5i,SrPeixinho,0,Sun Jul 12 14:31:29 2015 UTC,"haha, editing above for correctness! Btw, please don't think my god is anywhere near C++ ;)"
haskell,3cy6rw,AisRauli,2,Sat Jul 11 21:10:29 2015 UTC,"FYI, similar to Djinn, but different is https://github.com/lspitzner/exference    (I'm not the author)"
haskell,3cy6rw,ignorantone,2,Tue Jul 14 07:24:31 2015 UTC,What IDE do you want showcased?
haskell,3cy6rw,sccrstud92,8,Sat Jul 11 21:33:19 2015 UTC,"I'm not looking for an IDE, emacs is perfectly fine for me. What I'm looking for is for a tool that can make searches like:  ""code"" -> ""CODE""   Gives me:  map toUpper   ~~~  Or:   ""!@#$%^&*"" -> ""!%40%23%24%25%5E%26*""   Gives me:  urlEncode   ~~~  Or:  ""code"" -> ""code!""   Gives me:  (++ ""!"")   ~~~  Better yet:  ""code"" -> ""Code!""   Gives me:  (\(a:as) -> toUpper a : as) . (++ ""!"")"
haskell,3cy6rw,neilthecoder,13,Sat Jul 11 21:43:01 2015 UTC,http://nautilus.cs.miyazaki-u.ac.jp/~skata/MagicHaskeller.html
haskell,3cy6rw,theonlycosmonaut,4,Sat Jul 11 22:36:04 2015 UTC,University of Miyazaki    Didn't know that was a place :3
haskell,3cy6rw,rakatan,3,Sun Jul 12 05:54:19 2015 UTC,Wow this one looks awesome!
haskell,3cy6rw,sccrstud92,2,Sun Jul 12 10:37:37 2015 UTC,Beautiful! This needs to get much better advertising than its getting!
haskell,3cyfcx,int_index,3,Sat Jul 11 22:27:10 2015 UTC,The explanation/motivation you wrote here should probably be copied to the hackage package introduction.
haskell,3cyfcx,ignorantone,2,Sat Jul 11 22:49:06 2015 UTC,A motivation is still missing. I don't need a typeclass just because some functions obey some laws. What is a practical use of the typeclass?
haskell,3cyfcx,kraml,7,Sun Jul 12 07:20:48 2015 UTC,"Added missing lifting functions. I personally use this library to drastically cut the amount of lifting instances in Ether. Not only it simplifies my code, now if you want to make your monad transformer Ether-compatible, you don't need to depend on it, just depend on the minimalistic transformers-lift package. Other libraries of monad classes (such as mtl, monads-tf) could use transformers-lift in a similar way, though I don't think I can convince mtl authors to depend on my lib.  You can abstract over any transformer that is able to lift operations you're insterested in. Not doing so is code smell. Like using addInteger, addFloat, addDouble, addInt etc. instead of polymorphic +."
haskell,3cyfcx,phadej,1 point,Sun Jul 12 10:50:59 2015 UTC,"I don't get it, how https://hackage.haskell.org/package/transformers-lift-0.1.0.0/docs/Control-Monad-Trans-Lift-CallCC.html is different from https://hackage.haskell.org/package/mtl-2.0.1.0/docs/Control-Monad-Cont.html#g:1  Didn't they solve the same problem?"
haskell,3cyfcx,phadej,1 point,Tue Jul 14 14:36:23 2015 UTC,"No, liftCallCC' in my library is what mtl could have used to implement some of their instances for callCC. Instead they write the instances by hand (see here: https://hackage.haskell.org/package/mtl-2.0.1.0/docs/src/Control-Monad-Cont-Class.html)"
haskell,3cy5hf,maxptr,6,Sat Jul 11 20:59:25 2015 UTC,"Another great way to get some experience is to contribute to open source projects. I know that a lot of open source projects are incredibly open to contributions from new users, and sometimes will be happy to provide mentorship, suggestions, code review, etc.  (For example, a shameless plug: I am always happy to help onboard new contributors to IHaskell; there's a tag in the issue tracker with tasks for newcomers.)"
haskell,3cy5hf,NiftyIon,4,Sun Jul 12 02:33:55 2015 UTC,"We at Snowdrift.coop are a volunteer-based community cooperative non-profit, the site is basically entirely in Haskell, and we aim to be the most beginner- and volunteer-friendly project we can possibly be. We have thoroughly documented stuff, lots of tiny ways to help, and everyone is really encouraging and helpful.  We've even taught Haskell basics to people who support our mission and started Haskell just to help us.  We mostly chat at #snowdrift on freenode, our code docs are at https://git.gnu.io/snowdrift/snowdrift#tab-readme (which has links to appropriate pages on the site, tickets, etc.)"
haskell,3cy5hf,wolftune,3,Sun Jul 12 17:01:16 2015 UTC,"I have an idea for a project: Social organization / ""countdowns"": It's not about small talk, but actual information, the time being the most important. People would have their own countdowns and would be able to follow the countdowns of the others. This project would contain: - web development - database management - internet communication BUT: - needs server (for more comfort) - no complex Haskell algorithms, however: interesting IO mechanisms (""real world Haskell"")"
haskell,3cy5hf,sammecs,1 point,Sat Jul 11 21:43:10 2015 UTC,"For some reason i've always been crazy about IRC. I've been working on an IRC bot, casually. My idea is to model it somewhat like eggdrop, which has been written in C. In fact,  18 years ago, eggdrop was how I learned about the existence of Linux - I was a young kid, and when someone told me about eggdrop I wanted to try it. Initially in Windows 95, but I had to use cygwin, and then I discovered the OS it was actually written for.  But I digress. The reasons I enjoy IRC are for example that the protocol is easy to learn, the  commands sent to the server and received from the server are relatively easy to understand, and the features on modern servers are also fun to play with.  Whati nterests me related to Haskell, and what I still need to figure out, is how to maintain states of awareness about itself, its environment, chatrooms, server capabilities, known users, event handlers... there are just so many aspects, it can potentially be very elaborate.  Unfortunately shortly after I started my own adventures in Haskell, and worked on the first stages of my plan, I got into some medical troubles - a spontaneous pneumothorax followed by a botched surgery. I'm still recovering and for that reason I could not pick up the pace I had when I started. My will to continue is still there, and meanwhile I've been following the fantastic writings from members in the community. But I'm not back to my old self yet.  Anyway, to wrap this up, if you'd like to have a chat about this project and want to see the stuff I did already make, send me a line and maybe we can make it combined effort. If it excites you, that is.  If it doesn't, that's fine too ofc. In that case I do hope you can keep us posted in this thread when you have found something worth checking out."
haskell,3cy5hf,Ancipital,1 point,Sun Jul 12 06:23:22 2015 UTC,"I've been awash in other priorities, but a couple of weeks ago I made a repository for a project to make a reflex binding for sdl2 (specifically the new-api branch), with additional goals to follow. Ultimately I'd like it to be something like helm meets reflex-dom, but one step at a time. :)  I've still done zero work on it so far, but it's first among my back-burner items, and frankly if someone else were contributing I'm sure I'd wind up more aggressively making time for it myself."
haskell,3cy5hf,tejon,1 point,Sun Jul 12 11:28:41 2015 UTC,"If you're into Python, I'm currently building a library for writing Haskell to generate Python. It's my first Haskell project. I haven't put it up on github yet but I will when I get my computer back and update this with a link.   Edit: GitHub link as promised https://github.com/rnikoopour/Python.HS"
haskell,3cy5hf,rnikoopour,2,Sun Jul 12 19:54:36 2015 UTC,I would be interested in that. Send me a message when you drop a release.
haskell,3cy5hf,sseveran,1 point,Mon Jul 13 06:08:56 2015 UTC,"https://github.com/rnikoopour/Python.HS  There's the link.  Right now I have no git ignore so pardon the compilation related files.  Also, the only thing implemented is some primitive arithmetic types."
haskell,3cy5hf,rnikoopour,1 point,Mon Jul 13 08:01:33 2015 UTC,"PureScript is always looking for contributors, and we have some beginner issues marked on the issue tracker."
haskell,3cwa09,bitmadness,17,Sat Jul 11 08:40:44 2015 UTC,The #1 resource on this topic is Chris Okasaki's book Purely Functional Data Structures. His earlier thesis with the same name is available online: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
haskell,3cwa09,julesjacobs,3,Sat Jul 11 10:44:41 2015 UTC,Somewhat shorter intro: Making Data Structures Persistent.
haskell,3cwa09,adaszko,14,Sun Jul 12 06:03:22 2015 UTC,"As far as I understand, sharing is done automatically. It's probably more difficult to avoid it than to have it. For example, if you get the tail of a list and cons a new element, the whole tail won't be copied. Any algebraic data type you make will behave like this. Say you have a record of 3 lists, if you ""update"" one of them, the only thing that needs to be recreated is the record itself so it points to the two old lists, and the new one you created, and that new list will also share as much as possible with the old one.  The more you deconstruct the original object before updating it, the less is shared. That's why, for example, reversing a list breaks sharing and creates a new one.  Also, there's no complicated mechanism in place that lets you do this, no explicit storing of ""changes needed to produce the new one"". It's just how pointers work. A list [1,2,3] is basically 1 -> 2 -> 3 if you cons the number 4 to the tail of that list you get 4 -> 2 -> 3 but the original 1 isn't gone, it still points to the same 2 so you have this kind of implicit tree that looks like  1 -> 2 -> 3      ^      |      4   and depending on which head you're currently observing you get a different traversal of the same tree."
haskell,3cwa09,Darwin226,5,Sat Jul 11 09:02:48 2015 UTC,"I'm a little confused about what the question is exactly asking... mutation is extremely explicit in Haskell, and requires using things such as IORef or STRef -- you should be very much aware when you're doing destructive updates. If you're not using those things, then any ""updates"" you're doing to structures are actually just constructing new structures. If you're not using anything like writeIORef, writeSTRef, putMVar, or the like, and your update operations don't require IO or ST, then the data structures you're creating are almost certainly immutable, and any ""updates"" to them are really constructing new structures.  There are rare exceptions to this like DiffArray, which does a bunch of sneaky mutation behind the scenes (using unsafePerformIO) when you update, and stores a list of changes that get used on accessing the old versions of the array. The implementation is pretty subtle in the face of concurrency, and had some pretty serious concurrency-related bugs in the past, if I recall correctly (but those hopefully did get ironed out somewhere along the way, given the present implementation is using MVars in careful-looking ways). However, I can't think of anything too popular of that sort. DiffArray never really took off, because the cases where it out-performed other less-evil structures were pretty rare.  While there's no simple description of how to design immutable data structures such that various operations perform well, the key is typically to try to ensure that as much as possible of the ""old"" structure is kept when forming the ""new"" structure, which generally happens when you bind part of the old structure to a variable (through pattern matching) that then gets used as an argument to a constructor of the new structure. This just amounts to copying a pointer.  It's very common when manipulating tree structures that an insertion into the tree will only involve rebuilding a path between the newly inserted element and the root (and perhaps a constant-width swath around that to maintain balance) such that only O(log n) new constructors get built."
haskell,3cwa09,cgibbard,3,Sat Jul 11 09:11:08 2015 UTC,"OP didn't state, but I imagine s/he perhaps wanted practice designing such a structure thenselves (even if it is redundant in Haskell proper)"
haskell,3cwa09,ABC_AlwaysBeCoding,3,Sat Jul 11 13:24:09 2015 UTC,With GHC's profiler you can monitor allocations precisely. Avoid unpacking in the spine (this is the default anyway).
haskell,3cvypq,begriffs,2,Sat Jul 11 05:58:01 2015 UTC,How this compares to reflex and elm ?
haskell,3cvypq,akegalj,6,Sat Jul 11 10:14:07 2015 UTC,"The difference between Elm and Halogen is used as the motivation for moving from signals to signal functions in the video. I haven't used Reflex, but it claims to be an FRP implementation. I wouldn't say Halogen is an FRP implementation, in either the ""continuous, denotative"" sense, or in the looser sense. It's more about composing state machines. You could replace the words ""signal function"" with {Mealy, Moore} machine and the rest of the content would be the same."
haskell,3cvypq,paf31,6,Sat Jul 11 15:35:10 2015 UTC,"I guess people are less curious about reflex and more so about reflex-dom.    When I looked into Halogen, for example, I compared the code to what's found in the try-reflex tutorial.  From a quick glance,Halogen would seem  to have more in common with haste-perch, in particular in the way event handlers are set up."
haskell,3cvypq,emarshall85,2,Sat Jul 11 16:16:14 2015 UTC,...and to using a React binding?
haskell,3cvypq,cies010,5,Sat Jul 11 10:53:31 2015 UTC,"purescript-thermite is probably the closest thing to Halogen for React in PureScript-land. Halogen uses virtual-dom, but supports different backends in theory, so a React backend should be possible.   The separation of state updates from the component itself is a little more marked in Halogen, though: it uses a purely functional model, with components emitting new states, whereas React supports a direct setState operation on the component context."
haskell,3cvypq,paf31,-1,Sat Jul 11 15:38:30 2015 UTC,How does it not at all compare to this?   https://github.com/paylogic/halogen http://halogen.readthedocs.org/en/latest/
haskell,3cvbyr,rampion,5,Sat Jul 11 02:04:47 2015 UTC,"That sounds pretty weird. I tried it on a Linux VM with GHC 7.10.1.20150710 (7.10.2 RC, basically) and it didn't succeed, but it also didn't cause any problems with instance:  % mkfifo output-fifo % cat output-fifo > a.out & ghc -x hs =(echo 'main = print 1') -o output-fifo [1] 23414 [1 of 1] Compiling Main             ( /tmp/zsh6aJm6m, /tmp/zsh6aJm6m.o ) Linking output-fifo ... [1]  + 23414 done       cat output-fifo > a.out /usr/bin/ld: final link failed: Illegal seek collect2: error: ld returned 1 exit status %   If I had to take a wild guess, I'd say it's something to do with the linker on OS X rather than a GHC thing. One thing you could try is setting GHC to only produce the object file without linking and see if the problem still happens."
haskell,3cvbyr,Vulpyne,2,Sat Jul 11 03:22:23 2015 UTC,"GHC tends to store derived files (foo.hs --> (foo.o, foo.hi)) so it is unlikely that - is accepted."
haskell,3cvbyr,heisenbug,3,Sat Jul 11 10:29:25 2015 UTC,mkfifo / named pipe sounds overkill. Try specifying /dev/stdin as the input file. Maybe ghc also allows the usuall '-' as shorthand for this (Not at computer to try this)
haskell,3cvbyr,Tim_M,3,Sat Jul 11 08:37:22 2015 UTC,melpomene's answer  demonstrates that neither of these work.
haskell,3cvbyr,Vulpyne,5,Sat Jul 11 10:50:54 2015 UTC,"Actually...  % echo 'main = print 1' | runhaskell 1   Could that be what you want? It's running Haskell in the interpreter, so it's not going to perform as well as compiling but I'd guess that's less important for snippets you'd want to pipe in anyway."
haskell,3cvbyr,sambocyn,1 point,Sat Jul 11 14:01:32 2015 UTC,hawk can interpret haskell in a terminal.  (might help with your original problem)
haskell,3cx02o,Vetii,9,Sat Jul 11 14:50:57 2015 UTC,"The Enum instance for Double works a bit different: it can produce values higher than the max bound. The Haskell report says   the list terminates when the elements become greater than e3 + i/2 for positive increment i, or when they become less than e3 + i/2 for negative i.   Source: https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1310006.3.4"
haskell,3cx02o,quchen,10,Sat Jul 11 16:35:40 2015 UTC,"If you look at the specification, it says   The sequence enumFromThenTo e1 e2 e3 is the list [e1,e1+i,e1+2i,...e3], where the increment, i, is e2-e1. If the increment is positive or zero, the list terminates when the next element would be greater than e3; the list is empty if e1 > e3. If the increment is negative, the list terminates when the next element would be less than e3; the list is empty if e1 < e3.  For Float and Double, the semantics of the enumFrom family is given by the rules for Int above, except that the list terminates when the elements become greater than e3+i/2 for positive increment i, or when they become less than e3+i/2 for negative i.   Whether that's a ""wat"" or not, I leave up to you to decide."
haskell,3cx02o,rpglover64,8,Sat Jul 11 16:43:38 2015 UTC,1.2 ≤ 1.0 + 0.6/2
haskell,3cx02o,tailbalance,2,Sat Jul 11 15:13:36 2015 UTC,Why 0.6/2 ?
haskell,3cx02o,vitalijzad,4,Sat Jul 11 15:50:35 2015 UTC,This I guess: https://www.reddit.com/r/haskell/comments/3cx02o/duh/cszstha
haskell,3cx02o,tomejaguar,2,Sat Jul 11 19:01:24 2015 UTC,"In the notation [a, b .. c] you're meant to put the last value you want in the list as c. Your example goes wrong partly because you're not using it as intended.   You're supposed to say [0, 0.6 .. 1.2]  or [0, 0.6 .. 1.8] etc, depending on which list you want.   It's just rounding to the nearest multiple of the increment. This is to deal with the inherent inaccuracy of floating point arithmetic, which could have bitten you whilst using it as intended but with very large final values, if it didn't round to the nearest half increment."
haskell,3cx02o,_AndrewC_,1 point,Sat Jul 11 22:38:05 2015 UTC,"[0,x .. 1.0] is simply syntactic sugar for enumFromThenTo 0 x 1.0. This function is defined over all types in the Enum typeclass. Its default definition (that is, if one isn't provided when a type is instantiated) relies on the type in question's definitions of fromEnum and toEnum.  λ> fromEnum 1.2 1 λ> fromEnum 1.0 1   As far as the Enum typeclass is concerned, 1.2 is 1.0."
haskell,3cx02o,Ashandalar,1 point,Sat Jul 11 16:51:19 2015 UTC,"It kind of is, but the explanation is wrong."
haskell,3cx02o,tailbalance,5,Sat Jul 11 18:22:45 2015 UTC,"Yes.  It's a bug in the spec, imo."
haskell,3cx02o,augustss,-1,Sat Jul 11 23:59:57 2015 UTC,Translated into imperative:  set current value to be 0  if current value is less than 1  add 0.6 to the current value  put current value inside the list  return the list
haskell,3cx02o,vitalijzad,3,Sat Jul 11 15:01:50 2015 UTC,"But... Is it what the programmer meant?   Wouldn't something similar to takeWhile (<=1) [0, x .. ] be better?"
haskell,3cx02o,cullina,5,Sat Jul 11 15:12:13 2015 UTC,"To understand the motivation for the current design, try  takeWhile (<= 0.3) [0.0,0.1 ..]    and   [0.0,0.1 .. 0.3]"
haskell,3cx02o,mcapodici,2,Sat Jul 11 22:50:40 2015 UTC,Or   0.3/0.1==3
haskell,3cw7oo,togrof,3,Sat Jul 11 08:03:14 2015 UTC,"Personally I'd leave it be at first, then if profiling would show that this boundingBox is taking a lot of time of the program,  move to a smart constructor and make it a field accessor. But that stable-memo library does look interesting, it might indeed be the answer here."
haskell,3cw7oo,mjmrotek,4,Sat Jul 11 08:22:11 2015 UTC,"I'd do what /u/mjmrotek suggested and pass the 'boundingBox' value along with the 'Polygon'. One nifty thing about Haskell is that due to laziness, the 'boundingBox' value won't be calculated until it's needed, so you'll be able to achieve the effect you're looking for without any explicit memoization logic.  Example code:  module MyModule   ( Point (..)   , BoundingBox (..)   , Polygon   -- Constructors NOT exported, meaning you can't create a   , mkPolygon -- 'Polygon' unless constructed with 'mkPolygon'   , points   , boundingBox   ) where  import           Data.Vector      (Vector) import qualified Data.Vector      as V import           System.IO.Unsafe  data Point = Point { x :: Int                    , y :: Int                    } deriving (Show)  data BoundingBox = BoundingBox { topLeft :: Point                                , bottomRight :: Point                                } deriving (Show)  data Polygon = Polygon { points :: Vector Point                        , boundingBox :: BoundingBox                        } deriving (Show)  -- This prints ""EVALUATED!"" each time 'boundingBox' is evaluated. {-# NOINLINE calculateBoundingBox #-} calculateBoundingBox :: Vector Point -> BoundingBox calculateBoundingBox vec = unsafePerformIO $ do   putStrLn ""EVALUATED!""   return $ actualCalculateBoundingBox vec  -- This is just a proof of concept and can be further optimized to collect -- all the necessary values in just one pass over 'vec'. actualCalculateBoundingBox :: Vector Point -> BoundingBox actualCalculateBoundingBox vec =   BoundingBox { topLeft = Point { x = V.minimum $ V.map x vec                                 , y = V.maximum $ V.map y vec                                 }               , bottomRight = Point { x = V.maximum $ V.map x vec                                     , y = V.minimum $ V.map y vec                                     }               }  mkPolygon :: Vector Point -> Polygon mkPolygon vec = Polygon { points = vec                         , boundingBox = calculateBoundingBox vec                         }  -- main :: IO () -- main = do --   let p = mkPolygon $ V.fromList [Point 0 0, Point 0 1, Point 1 0] --   print $ points p --   putStrLn ""Bounding box has not been evaluated"" --   print $ boundingBox p --   putStrLn ""Now it has"" --   print $ boundingBox p --   putStrLn ""It is not evaluated again"" -- -- => fromList [Point {x = 0, y = 0},Point {x = 0, y = 1},Point {x = 1, y = 0}] -- => Bounding box has not been evaluated -- => EVALUATED! -- => BoundingBox {topLeft = Point {x = 0, y = 1}, bottomRight = Point {x = 1, y = 0}} -- => Now it has -- => BoundingBox {topLeft = Point {x = 0, y = 1}, bottomRight = Point {x = 1, y = 0}} -- => It is not evaluated again"
haskell,3cw7oo,TumbleSteed,3,Sat Jul 11 09:38:38 2015 UTC,"Yes, lazyness is why it putting fields to be memoized in the data type will work. Unfortunatly there are drawbacks. In your example you use deriving to get a Show instance and that will include boundingBox in the result of show. Then boundingBox will be forced as soon as the polygon is shown. Not a big deal maybe in this case, but if we were to add more properties as fields to the record to output of show may be too big (and expensive).  And there is ofcourse the problem with lack of clarity as to the relation between boundingBox and points. It is unfortunate to loose that."
haskell,3cw7oo,TumbleSteed,4,Sat Jul 11 10:00:04 2015 UTC,"I think you're selling this solution a little short.  I used deriving (Show) because it was the quickest way to demonstrate how things get evaluated, not because I expect you use it in production code. If you wanted to use Show in production, you'd want to write a custom Read and Show instance that hid the boundingBox construction/value so that you couldn't use read to create an invalid instance, and it wouldn't evaluate calculateBoundingBox when shown.  As for the relationship between boundingBox and points, that's encapsulated entirely within the Polygon data type. As long as you don't export the constructors for Polygon, there's no way for the caller to know its internal representation, so they wouldn't be able to tell whether the BoundingBox returned from boundingBox myPolygon is stored as a part of the Polygon or calculated each time."
haskell,3cw7oo,TumbleSteed,5,Sat Jul 11 10:18:02 2015 UTC,"As for the relationship between boundingBox and points, that's encapsulated entirely within the Polygon data type.    The data type only states that there is a vector of points and some bounding box. To see their relation one also needs to look at mkPolygon.  It may be that I am selling the solution a little short, but it has some disadvantages that may seem minor, but that I think could be more problematic than one might think at first.   If you wanted to use Show in production, you'd want to write a custom Read and Show instance [...]   And that is exactly the problem, that one cannot/should not longer use derived instance but has to write custom ones. The problem is not  that we have to write more code, but that one has to read more code afterwards. Maybe Show is not significant, but what if we want to translate the Polygon to Json or xml or serialize to binary? Libraries for doing such things may provide generic functions (or template) to automatically derive functions for the translation, but if we include things in the data type that we don't want to appear in the translation we have to do all the work ourselves. And that leads to more code to maintain and reason about.  So, adding properties as fields to the data type works, but it feels like the language does not really want this. We have to write our way out of adding those fields many times later by adding more and more code to ignore what is not the real data."
haskell,3cw7oo,twistier,1 point,Sat Jul 11 11:48:46 2015 UTC,"I see. That makes sense.  If you're okay with holding results in a datatype but don't like the coupling, you could make a wrapper type that operates similar to how the previous composite Polygon type worked:  data PolygonW = PolygonW { base :: Polygon                          , boundingBox :: BoundingBox                          }  mkPolygonW :: Polygon -> PolygonW mkPolygonW p = PolygonW p (calculateBoundingBox p)   Or perhaps pass around a PolygonResults object by hand or using something like the Reader monad.  data PolygonResults = PolygonResults { boundingBox :: BoundingBox }  mkPolygonResults :: Polygon -> PolygonResults mkPolygonResults p = PolygonResults (calculateBoundingBox p)   Also, while I can't personally vouch for it, that stable-memo library you mentioned should let you be able to avoid having to create these cache datatypes if you don't mind incurring the overhead of a hash table lookup keyed on Haskell's rough equivalent of a pointer."
haskell,3cw7oo,mjmrotek,2,Sat Jul 11 12:54:53 2015 UTC,"Also, while I can't personally vouch for it, that stable-memo library you mentioned should let you be able to avoid having to create these cache datatypes if you don't mind incurring the overhead of a hash table lookup keyed on Haskell's rough equivalent of a pointer.   There is a bit more overhead than that, unfortunately. There's also overhead to create/lookup the stable name, and there is overhead due to the finalizer, and there is overhead on the GC due to the use of weak references."
haskell,3cw7oo,twistier,1 point,Sat Jul 11 22:04:46 2015 UTC,"Ok, so there is a performance price to pay. Still could be a nice thing to try as a first step to improve performance by memoization, given a data type and a function."
haskell,3cw7oo,twistier,1 point,Sun Jul 12 07:53:18 2015 UTC,"And there is ofcourse the problem with lack of clarity as to the relation between boundingBox and points. It is unfortunate to loose that.   Well you can always make a ""smart lens"" if you want to make it look like Polygon is still a Vector Points and an unrelated function:  import  Control.Lens  data Polygon = Polygon {_points :: Vector Point, boundingBox :: BoundingBox}  points :: Iso' Polygon (Vector Point) points = iso _points $ \p -> Polygon p (calculateBoundingBox p)  ( ... )  p = from points $ someVector p & points %~ Vector.map someTransformation   Now whether you like stacking abstractions like this or not is another matter."
haskell,3cu5nu,ezyang,7,Fri Jul 10 20:17:34 2015 UTC,I'm still concerned that Backpack is not embedded within the Haskell language.  I thought the point of modules was that they were first class values within the language that you could manipulate using ordinary functional programming idioms.  The fact that this requires special integration with Cabal is a huge warning sign to me that this will end up requiring reinventing functional programming at the Cabal level.
haskell,3cu5nu,Tekmo,8,Fri Jul 10 22:13:24 2015 UTC,"Actually, within the last few months we've gone a lot back further having Backpack be embedded in the Haskell language. For example, in my HiW talk I described a Cabal-esque format for defining Backpack packages: we've gone back to a proper language like in the Backpack paper which GHC will parse and compiler. However, I've needed to circle back to Cabal, because I need to answer the question, ""So you've written a Backpack file which uses the new module system features: how do you distribute it with Cabal?"" And the biggest barrier is dealing with Cabal's assumption that when it calls GHC, it is going to get a blob of code that can be registered as a single entry in the installed package database. But this is simply not true when you're compiling Backpack files."
haskell,3cu5nu,gridaphobe,8,Fri Jul 10 22:36:14 2015 UTC,"What's the motivation for this feature? The GH issue describes how this might work, but not why we would want/need this support."
haskell,3cu5nu,tomejaguar,7,Fri Jul 10 20:55:52 2015 UTC,"Copied from updated ticket:   For Backpack, we absolutely need the ability for a single Cabal file to result in the installation of multiple ""packages"" in the installed package database, because these packages are how you do modular development in Backpack. I took a detour to implement this feature, because it will serve as a good blueprint for how to make it easier for Cabal to support this use-case. There are many packages which have been split it a wide constellation of packages in order to make it easier for users to install useful subsets of functionality without pulling in the rest of the dependencies they don't want. However, maintaining N different Cabal files can be a bit of a pain for tightly coupled packages. With scoped packages, all of these packages could be placed in one Cabal file. (We have to make sure components get depsolved separately, but @edsko has put us most of the way there.) This change presents a really good opportunity to substantially simplify Cabal's handling of components. Currently, benchmarks, testsuites, executables and libraries are all separately special cased in Cabal, and anything that, e.g. mucks about the BuildInfos has to be implemented FOUR times for each of these cases. Here's a simpler model: every Cabal package has some number of components, which may be one of a few types."
haskell,3cu5nu,snoyberg,8,Fri Jul 10 21:16:11 2015 UTC,"we absolutely need the ability for a single Cabal file to result in the installation of multiple ""packages"" in the installed package database, because these packages are how you do modular development in Backpack   This needs to be elucidated."
haskell,3cu5nu,snoyberg,11,Fri Jul 10 21:54:17 2015 UTC,"OK, this is a kind of long story, but here goes.  The point about modularity is that you can take a module and switch it out for something else, without needing any source level changes.  So if in Haskell today you write:  module RNG where     data RNGState = ... module Crypto where     import RNG     data SessionState = ... RNGState ...   The goal of a project like Backpack is to make it possible to compile Crypto with different versions of RNG in a relatively user-friendly way, and furthermore, perhaps use the resulting Crypto modules in the same program.  Now, the fact that RNG can define types, and Crypto can define types based on those types results in an interesting problem: if I have RNG.HmacDrbg and RNG.CtrDrbg, their RNGStates are probably different; and furthermore, the SessionState I get from Crypto should have a different type-identity depending on which RNG I picked.  OK, so now for a tangent: how does GHC decide if two types are equal or not?  You might naively think that it's something like doing equality over the module it's defined in plus the name of the type. But in GHC today I am allowed to write two packages with a module having the same name, and if they define the same types these SHOULD NOT be the same.  So, GHC defines the ""Name"" of a type to be the module name, the type's name, AND some sort of ""package key"" (more on this shortly as well).  In pre-GHC 7.10, this package key was usually just a string like ""transformers-1.0"", which solved your problem if the conflicting name was in ""mtl-1.0"".  Now, there is one more piece of the puzzle I have to describe to you, which is how GHC does separate compilation.  When you build and install a library, GHC bundles up all the types and unfoldings into interface files, so that when you type-check some code that depends on one of those types, GHC can slurp in the interface file and find out what the actual darn type of the thing is.  Now, there are a lot of interface files, and GHC tries its hardest not to load them all in because that would make GHC very slow.  Instead, GHC uses the package key (which we just talked about) to figure out what ""installed package"" contains the interface file for any type in question.  It does this by consulting what is called the ""installed package database"", which is essentially a big mapping from package keys to directories holding interface files among other things.)  To summarize: the identity of a type is a package key (""foo-0.1""), a module name (""Data.Foo"") and an occurrence name (""FooTy"").  When GHC comes across one of these references, it looks up the package key in the installed package database to find the interface describing what the type actually is.  Following along?  So let's go back to the original Crypto example. We want our Crypto.SessionState to be different based on which RNG we filled in with.  The identity of this type is the package key (unspecified), the module name Crypto (not changeable) and the occurrence name SessionState (not changeable).  So the ONLY place we can stuff in the information we need is in the package key.  The implication of this is that each instance of Crypto (compiled against RNG) needs to be installed separately in the installed package database, because we still need to be able to lookup these interfaces.  (BTW, you could try just adding a new field to our concept of a 'Name'.  We decided not to do this because, (1) it would slow down GHC, and (2) SPJ was quite insistent, early on, that type identity be computed by looking at the dependencies of a package as a whole, rather than just a module: it makes some problems like how to link your programs and UX easier.  This, by the way, was NOT how the Backpack paper used to work.)  So, where are we at?  If you want to write a module and instantiate it multiple times, you need to give it different package keys, which means it needs multiple entries in the installed package database.  On the other hand, when you distribute this package to users, you are only going to have one Cabal file and one source distribution. Thus, you have a one to many relationship between Cabal packages, and Backpack units of modularity.  BTW, I am not that invested in the scoping bits; we could live with an implementation of Backpack where there was only one package you could access externally. But regardless of whether or not cabal-install/stack know about the internal private packages, they DO have to be installed. And it seems the best way to do this is to have Cabal treat each instance of a package which it is going to install as another library."
haskell,3cu5nu,radix,4,Fri Jul 10 22:23:18 2015 UTC,"This explanation helped me understand things a bit more, thank you. I've used that and other comments made here to try and advance the discussion on the issue itself on Github."
haskell,3cu5nu,tomberek,11,Sat Jul 11 01:08:19 2015 UTC,"Please, please don't do this. Our tooling is barely holding together as is. Throwing yet another curve ball is yet another failure case we all get to worry about and experience."
haskell,3cu5nu,snoyberg,2,Fri Jul 10 20:48:36 2015 UTC,"I guess the thing that's missing here is a ""use cases"" section in the ticket that describes why this is desired"
haskell,3cu5nu,phadej,4,Fri Jul 10 20:54:57 2015 UTC,"Apart from the case for or against this due to the current state of tooling, what is the theoretical argument for or against?"
haskell,3cu5nu,snoyberg,4,Fri Jul 10 21:33:50 2015 UTC,"There a reason one library was chosen in the first place: it comes with a very logical ""this package provides a library of the same name."" It's breaking that abstraction. Should we have initially adopted a totally different mindset about how library packaging happens to allow for this 1-to-many relationship instead of 1-to-(0/1) relationship? Perhaps, but I'm not convinced it would have been worth it even then. Trying to hoist it in now is a totally different ballgame."
haskell,3cu5nu,snoyberg,5,Fri Jul 10 21:49:15 2015 UTC,"I mentioned this in the uses cases, but I think this change will allow us to greatly simplify Cabal's internal code, by having us treat components more uniformly. So I think this will make the tooling situation better."
haskell,3cu5nu,snoyberg,9,Fri Jul 10 21:18:22 2015 UTC,"We can simplify Cabal's internal code to treat components uniformly, but keep cabal file parser so it accepts at most one library. Even internal structure supports some feature, it doesn't need to be publicly exposed.  Cabal-the-library GenericPackageDescription could then have multiple library components. But you could construct such entities only programmatically, or using different parser (for Backpack need?)."
haskell,3cu5nu,snoyberg,4,Fri Jul 10 22:08:04 2015 UTC,+1 Exactly.
haskell,3cu5nu,_AndrewC_,5,Fri Jul 10 22:31:37 2015 UTC,"By all means, clean up the internals of Cabal. But claiming that this will make the tooling situation better is ignoring the enormity of the situation. What you're proposing will be breaking changes for:   GHC Cabal (the library) cabal-install stack Stackage Editor integration IDEs   And who knows what else. Lobbing about these kinds of changes because they make a library a bit easier to clean up, while forcing breakage across a widely distributed system of components, is not a good trade-off."
haskell,3cu5nu,cies010,3,Fri Jul 10 21:29:16 2015 UTC,"This proposal is fully backwards compatible with GHC (since each sub-library gets its own package in the installed package database, so it just looks like you installed multiple packages), and only requires minor API updates for cabal-install/stack if you decide to simply ignore packages with multiple libraries. Honestly, that's what I expect to happen for a few years. But if you want to a feature to eventually enter into circulation, you have to put it into Cabal some time.  (Edit: BTW, you should see the original proposal SPJ pushed me towards https://ghc.haskell.org/trac/ghc/ticket/10622 , which was even more breaking! I spent a day cracking my head against it and decided to ignore it. This is the more tame version. )"
haskell,3cu5nu,snoyberg,3,Fri Jul 10 21:37:18 2015 UTC,"You're contradicting what you've already said in the Github issue. GHC won't accept the separator without tweaking it, for instance. How is Hackage going to display these? How is permissions management for uploading going to work there? This will entail massive changes to the cabal-install dependency solver. Anything anywhere that parses a package name or package identifier will need to be modified.  There are dozens of papercuts that will result from this change, and this all comes from something with highly dubious value."
haskell,3cu5nu,edwardkmett,4,Fri Jul 10 21:46:51 2015 UTC,"I hadn't worked out this part of the issue, so thanks for forcing it. You are right: ghc-pkg will not accept a slash/period separator in package names. Thus, we'll have to go for hyphens. So any sub-library name is also a valid package name; the hyphenation scheme is a ""convention"" that cabal-install can use to find a Cabal package which exists and defines the file.  So, no papercuts! A Cabal file with multiple libraries is now is /exactly/ equivalent to multiple Cabal files.  (I've updated the proposal)"
haskell,3cu5nu,snoyberg,6,Fri Jul 10 21:53:58 2015 UTC,"No, that doesn't make the problem better, that just makes the problem different. It's not some ""convention,"" we've now completely broken invariants. Where is snap-server, or yesod-core, or pipes-bytestring, going to be located? Probably a dozen tools have hard-coded into them that they'll be located in snap-server.cabal, yesod-core.cabal, etc, located in the 00-index.tar file at a specific location. That invariant's gone.  And this is the crux of the matter: every tool out there has been going on the fact that library X is in package X. You're removing that rule. Whether you're removing it by saying ""libraries can now be X.Y,"" or ""library X-Y can exist in either package X or package X-Y,"" or any one of the untold variations we could come up with, all of those tools will need to be changed. (And this doesn't even get to the level of documentation, and teaching all Haskellers and all new people ""ignore what we've said until now, we have a brand new rule in place."")  On top of all of that, there is a very mysterious argument from authority going on here: Backpack requires it. I think Tom's comment needs to be addressed: where does this requirement come from? Is there no other way of achieving this? Is the benefit we get from this implementation worth the cost we're all going to have to pay to get it?"
haskell,3cu5nu,snoyberg,3,Fri Jul 10 22:03:38 2015 UTC,"OK, I am willing to give up on the ability of a Cabal package to EXPORT multiple libraries to the outer world. However, I do still need the ability to DEFINE multiple PRIVATE libraries, which still get installed to the package database. I've split up the proposal into the two parts here."
haskell,3cu5nu,cartazio,5,Fri Jul 10 22:31:13 2015 UTC,"That sounds a lot more palatable, so my concern can go from ""terror"" to ""worried."" I still don't understand the ramifications that's going to have on everything else, and I'm not sure if the Github description is supposed to reflect the new, refined proposal."
haskell,3cu5nu,Crandom,2,Fri Jul 10 22:46:37 2015 UTC,"I've rewritten the Github description; the first part should reflect the new refined proposal, and the second part should be the ""expanded"" proposal (which we are not going to do.)"
haskell,3cscuj,_skp,7,Fri Jul 10 11:24:30 2015 UTC,Have you seen mvc ?
haskell,3cscuj,AlpMestan,9,Fri Jul 10 12:13:17 2015 UTC,"The really nice thing about mvc is that it isn't bidirectional.  The computations flow strictly one way:  controller -> model -> view  So you dont have to handle communication between each of the three parts - just events rocking in (from the controllers), and events rolling out (to the views).  This is very different to the sort of javascript MVC out there, where controllers can produce effects and views can talk back to the model.  The other nice design feature is that the model part is pure.  You work out what's your state, how that state can change due to inputs, and can refactor aggressively at any time without having  to think about IO effects.  Asynchronous bidirectional comms quickly overwhelms my ability to work out what's going on.  You should take a closer look at mvc's one-way flow with the pure computation in the middle - I get the sense that it's what you might be working towards."
haskell,3cscuj,tonyday567,3,Fri Jul 10 13:58:43 2015 UTC,"Yes. I told Gabriel about that, and he advised me not to use it and write my own. However, I had a closer look. Seems like he manages the synchronization issue with Managed and managed. I have mixed feelings, but it sounds great."
haskell,3cscuj,twistier,1 point,Fri Jul 10 12:50:49 2015 UTC,"I’d like to hear from you guys, as I’m looking for ideas and opinions here. :)"
haskell,3cscuj,Tekmo,2,Fri Jul 10 11:24:57 2015 UTC,You will be pleased to learn that pipes natively supports bidirectional communication. Just look in Pipes.Core (I think) for the gory details.
haskell,3crcq7,theonlycosmonaut,12,Fri Jul 10 03:52:00 2015 UTC,"Coincidentally, there's a recent branch of stack which automates creating a docker image with your project's executables.  This makes creating a docker image as easy as running ""stack image container"".  As discussed in this post, it can base this image off a different one than your development image."
haskell,3crcq7,mgsloan,1 point,Fri Jul 10 06:17:13 2015 UTC,"That's really cool! I've only used stack briefly but it's very slick, and this would be a great addition."
haskell,3crcq7,haskman,1 point,Fri Jul 10 07:06:31 2015 UTC,That is really great. I love how fast the development has been moving.
haskell,3crcq7,arianvp,11,Fri Jul 10 12:43:25 2015 UTC,Seriously. You don't need docker in production.  Haskell produces static binaries. The only thing you need to pay attention to is the libc and libgmp version. As those are dynamically linked. The rest of your executable is fully self contained. I just rsync a binary for deployment. Its fast and does the job just fine.  Docker is great for sharing a development environment. Not a deployment environment when working with non-dynamic languages. So I firmly agree with the author here
haskell,3crcq7,nkvdoo,3,Fri Jul 10 13:46:32 2015 UTC,"I would have to disagree, docker is not just for development, though it may seem that way in for a simple application. Containers provide isolation, resource sharing policies, simple automated scaling, defining interrelations and dependencies in system with several parts, etc. For example, I use docker and docker-compose to easily deploy and manage multiple instances of my application alongside other applications such as nginx, redis, etc. You can do this without docker but docker makes it much more convenient and simple as well as being able to deploy and test the entire system on other machines easily. There are other tools for doing similar things such as google's kubernetes (http://kubernetes.io/), but I mostly use docker-compose and docker - maybe someone who has experience can way in with a comparison."
haskell,3crcq7,leperLlama,1 point,Sat Jul 11 00:49:20 2015 UTC,"I guess there are advantages in process isolation, or if you ever need to distribute static files alongside your binary (web assets?). But yeah, a container with a binary might as well just be a binary."
haskell,3crcq7,vagif,12,Sat Jul 11 00:25:43 2015 UTC,"I've always been irritated by the docker insistence that development and production share the same container. A consequence of this was the restriction of only one Dockerfile per folder which has been annoying to deal with. What if I have two projects in two subfolders, which share some configuration in the parent directory? As great as docker is for providing a package format for an application I can't wait to see competition like rocket try their solutions to the same problem."
haskell,3crcq7,leperLlama,3,Fri Jul 10 04:59:07 2015 UTC,"You can tell it to use specific dockerfile via commandline argument. In fact do not name docker file by its default name, so it would not build if no docker file is provided."
haskell,3crcq7,vagif,2,Fri Jul 10 05:34:54 2015 UTC,"That's true. However it complicates things a little bit:   Note: If you build by passing a Dockerfile through STDIN (docker build - < somefile), there is no build context, so the Dockerfile can only contain a URL based ADD instruction. You can also pass a compressed archive through STDIN: (docker build - < archive.tar.gz), the Dockerfile at the root of the archive and the rest of the archive will get used at the context of the build.   You were always able to have several dockerfiles and rename them to 'Dockerfile' when you intended to use them, so it's not like functionality was lost. They were only friction to developers experimenting with docker, not those already committed to using it. It was just frustrating, particularly if you read the issue pages on github and the discussion happening between users and developers on how people ought to be using this tool that no one had used for longer than 6 months versus how people were using this tool.  Note that the intensity of my complaint is not high. If I had to say I was happy or unhappy with docker I'd say happy. I will just be happier when the competitors are out providing alternative user interfaces."
haskell,3crcq7,leperLlama,7,Fri Jul 10 05:46:58 2015 UTC,Actually there's a command line argument -f filename. No need to pipe anything. And it works fine with context.
haskell,3crcq7,leperLlama,3,Fri Jul 10 05:56:04 2015 UTC,"Thanks, that's news to me. Last time I checked they didn't seem too interested in adding that flag:  https://github.com/docker/docker/issues/2112"
haskell,3crcq7,insitu,3,Fri Jul 10 06:00:52 2015 UTC,Whenever I'm not talking about Docker specifically (as in this post) I prefer to talk about containers and containerisation specifically to be inclusive of other alternatives we see emerging. I like the CoreOS team and can't wait to see how rocket shapes up.
haskell,3crcq7,MaxDaten,3,Fri Jul 10 05:51:10 2015 UTC,I'm also interested in daemonless competitors like vagga. On the whole it's an exciting area which is being held back by the (necessary) pace of development and ecosystem growth.
haskell,3crcq7,snoyberg,7,Fri Jul 10 05:55:58 2015 UTC,"I had problems using Haskell-scratch for my application, which uses some http client : the /etc/hosts file ends up empty which prevents addressing e.g. Linked containers by name.  I resorted to use FROM busybox as a base, adding needed libraries as is done in scratch. As mentioned, this strategy reduced the size of deployed containers by 90%."
haskell,3crcq7,insitu,2,Fri Jul 10 05:06:07 2015 UTC,"yes, I bumped against it too. If you need some important system infrastructure (eg. dns lookups in a k8s cluster), the bare minimum is too small. Just something to keep in mind."
haskell,3crcq7,snoyberg,2,Fri Jul 10 05:46:56 2015 UTC,Good point. I've made a note of this in the post.
haskell,3crcq7,kyllo,2,Fri Jul 10 05:57:30 2015 UTC,"In general: you probably are safer with busybox. However, the specific issue of http-client was resolved by this pull request."
haskell,3crcq7,benclifford,2,Fri Jul 10 15:26:07 2015 UTC,"I may be a bit presumptuous but I think I am the author of this PR :-) see this SO question, I might post an issue to docker : http://stackoverflow.com/questions/30874184/why-is-etc-hosts-file-empty-in-my-docker-container"
haskell,3crcq7,miguelnegrao,1 point,Fri Jul 10 16:05:21 2015 UTC,"Hah, there you go. It's very difficult to align names across sites. (I still get emails sent to ""Mr. Snoyberg"" because of that...)"
haskell,3crcq7,stepcut251,5,Fri Jul 10 16:26:59 2015 UTC,"Can someone please help me understand the use case for Docker in the deployment process for a statically compiled language? I can understand developing on a Docker image, but I just don't get why you'd want to use Docker to deploy binaries."
haskell,3crcq7,agrafix,5,Fri Jul 10 15:53:21 2015 UTC,"If you're shipping open source software, Docker Hub seems more convenient than system package repos. Also you get the benefits of containers (process isolation), and you can package static files (like web assets) in with your binary."
haskell,3cqlua,Peaker,34,Fri Jul 10 00:01:10 2015 UTC,"I'm actually against deprecating them.  There are several use cases where you don't need the extra guarantees that streaming libraries provide, and in those cases the simple lazy versions greatly simplify your program."
haskell,3cqlua,Tekmo,10,Fri Jul 10 00:45:24 2015 UTC,But is that extra functionality worth the pitfalls of when they are used wrong or the confusing error messages they cause?
haskell,3cqlua,joehillen,2,Fri Jul 10 01:16:45 2015 UTC,"Yes, a thousand times !"
haskell,3cqlua,bartavelle,1 point,Fri Jul 10 06:22:37 2015 UTC,"It is true that things are simpler if you do not have to import and deal with an all-purpose streaming library that globally meets all of the desiderata propounded by Oleg and whatever else occurred to people in that discussion . ... But e.g. pipes-bytestring has basically nothing to do with such a 'streaming library'. It uses two types ByteString m r and List (ByteString m) m r (or if you like ByteStrings m r), to use the obvious synonyms. The operations like map that are implemented as pipes, can as well take the naive forms - in the case of map,  (Word8 -> Word8) -> ByteString m r -> ByteString m r"
haskell,3cqlua,michaelt_,54,Fri Jul 10 18:57:12 2015 UTC,eats popcorn
haskell,3cqlua,bos,10,Fri Jul 10 05:17:54 2015 UTC,Lazy popcorn or Strict popcorn?
haskell,3cqlua,dagit,18,Fri Jul 10 17:01:15 2015 UTC,"Pops in your mouth, not in your hand..."
haskell,3cqlua,sclv,11,Fri Jul 10 17:23:07 2015 UTC,A lazy Bag of strict Kernels
haskell,3cqlua,snoyberg,12,Fri Jul 10 17:19:54 2015 UTC,"IMO, Text and ByteString should just be strict ropes of chunks. This covers most of the use cases of both strict and lazy variants - often people use the lazy versions just to avoid copying things when slicing, dicing, and building them up. For the remaining stuff, people can just use [Text] explicitly."
haskell,3cqlua,pchiusano,11,Fri Jul 10 00:56:31 2015 UTC,"What benefit does the strictness bring? It is ""morally"" out of keeping with how we do data structures otherwise...  Note this is distinct from a discussion over lazyIO."
haskell,3cqlua,sclv,6,Fri Jul 10 02:14:03 2015 UTC,"Wow, I mentally rearranged the suggestion above to ""ropes of strict chunks"" until I read your comment (a few times). Thank you for pointing that out to me.  And I'm not firing on all cylinders, I should stop commenting in this thread :)"
haskell,3cqlua,snoyberg,1 point,Fri Jul 10 02:16:26 2015 UTC,"If you have any cylinders you're not currently using, please send them over. I'd love to have some of your cylinders, even on loan."
haskell,3cqlua,yitz,2,Sun Jul 12 10:10:03 2015 UTC,"You know, I haven't thought much about whether the rope should be strict or lazy and don't have strong opinions on that. What I do think is overkill is having separate types for 'a single strict chunk' and 'a sequence of chunks'. If you use a good sequence type there is no need to distinguish these at the type level and we can have less plumbing code. Note: I am not saying one can never conjure up a use case where you want to distinguish these concepts at the type level. But those cases are a minority."
haskell,3cqlua,pchiusano,2,Fri Jul 10 12:14:11 2015 UTC,"But the problem is the APIs are totally different -- the append operation on ""chunk"" makes a new chunk, the append operation on a sequence is like list append, etc. With bytestring, but not text, there is also the important difference that the strict variant works directly with the FFI, which is not unimportant :-)"
haskell,3cqlua,sclv,2,Fri Jul 10 14:45:12 2015 UTC,"What benefit does the strictness bring? It is ""morally"" out of keeping with how we do data structures otherwise...   The impression I have of my own code (at home and at work) is that in practice we rarely use lazy data structures, as is echoed in this comment by Johan. These days I start with: what benefit does the laziness bring?"
haskell,3cqlua,chrisdoner,6,Fri Jul 10 10:16:41 2015 UTC,"rarely use lazy data structures   Indeed, we use things like lazy lists for control structures not data structures. One obvious case is serialising structures, like json/binary serialisation. Yes one can also do that with continuations or pipes, but lazy sequences work perfectly well there with none of the issues of lazy I/O for input, and many would argue with lower cognitive overhead than continuations or pipes."
haskell,3cqlua,dcoutts,3,Fri Jul 10 14:47:42 2015 UTC,"There are some issues, such as when exceptions get kept inside the renderer, instead at the point of construction, so you only get an exception half way through writing to a Handle. Laziness is leaky. Sure, that's just the typical laziness problem (I think I have a banana, but really there's a gorilla holding onto the banana waiting to hit me on the head), but it's the most problematic when combined with I/O."
haskell,3cqlua,chrisdoner,3,Fri Jul 10 16:17:57 2015 UTC,"But that's not a problem with lazyness, you have the exact same problem with a continuation/pipe style: you can get an exception thrown at any stage when you ask for the next chunk of output. This is fundamental to an incremental approach, and I don't think you're advocating abandoning incremental approaches."
haskell,3cqlua,dcoutts,2,Fri Jul 10 18:40:09 2015 UTC,"Right, an incremental writer must fundamentally run arbitrary code on request. I agree they are the same."
haskell,3cqlua,chrisdoner,3,Fri Jul 10 19:08:27 2015 UTC,"Every time we use lists, we use lazy data structures. :-)  Maybe you don't use lists. I happen to like them."
haskell,3cqlua,sclv,3,Fri Jul 10 14:30:01 2015 UTC,"That was mentioned in the link I linked. Lists are the exception to the rule (hence ""rarely"", not ""never ever pinky swear"")."
haskell,3cqlua,chrisdoner,3,Fri Jul 10 16:12:22 2015 UTC,But a strict bytestring is morally just a list of bytestrings. So it fits neatly in the exception :-P
haskell,3cqlua,sclv,1 point,Fri Jul 10 16:27:50 2015 UTC,"(/me hands /u/bos another cup of popcorn)  I completely disagree. For me, laziness (well, non-strictness actually) is probably Haskell's most important feature. That's what makes Haskell expressions pure and enables referential transparency, since an enforced evaluation order can be viewed as a kind of side-effect.  Lately I have been programming almost exclusively in a web app environment, where at the top level everything is in a strict monad. Yet even there, most of the non-trivial logic is in pure expressions, and that relieves my brain of a significant number of required think-cycles every day. Because the basic underlying meaning of the code I write is higher-level: it tells what I want the result of a calculation to be in terms of the inputs, not how or when to calculate it.  Admittedly, it took time to get used to thinking that way. As an experienced programmer in imperative languages, it took a while to unload all that imperative-think baggage, which found many ways to creep in to my thinking. But now that I am past that, I wouldn't give up non-strictness for anything."
haskell,3cqlua,yitz,1 point,Sun Jul 12 10:37:52 2015 UTC,Note this is distinct from a discussion over lazyIO.   It is and it isn't. Check out the ambition of the module as stated on the hackage page:   Lazy ByteStrings use a lazy list of strict chunks which makes it suitable for I/O streaming tasks.     The remark was added for bytestring-0.10.
haskell,3cqlua,michaelt_,7,Sat Jul 11 02:28:01 2015 UTC,what's a strict rope or of chunks?
haskell,3cqlua,sambocyn,3,Fri Jul 10 04:16:16 2015 UTC,"A strict list of what we call strict bytestring or strict text chunks would give the effect he means. Like a strict bytestring/text, it would all exist if any of it exists, and would contain no undeveloped thunks; but like lazy and strict text as we have them, many manipulations would not involve massive re-allocation and copying of chunks but would just re-arrange references to chunks. He is thinking of a re-implementation of the strict text and bytestring types in terms of the existing strict types, taking those as close-to-the-machine features of the implementation."
haskell,3cqlua,michaelt_,24,Fri Jul 10 18:01:16 2015 UTC,"Oh hell no! as /u/tekmo says, they are straightforward and useful constructions. I use them and similar things all the time.  If we ignore lazyIO, these are still deeply useful structures, because their asymptotics, even on pure computations, are quite different.  For example, if I am generating a chunk of text out of a bunch of smaller fragments, and do not wish to go all the way through a Builder, then using lazy is much nicer than using strict, because it gives me a ""cheap rope"".  Perhaps ""lazy"" is a misleading misnomer -- the key aspect, to me, is that they are chunked structures that are ""piecewise strict, but spinewise lazy.""  If I just want to glue together chunks and manipulate things chunkwise, then this should not require any fancy structure like a Builder or pipes or conduits that introduces extra notions.  It is just a pure structure with a certain convenient qualities."
haskell,3cqlua,sclv,8,Fri Jul 10 00:56:47 2015 UTC,"If I just want to glue together chunks and manipulate things chunkwise, then this should not require any fancy structure like a Builder   Not exactly disagreeing, but... Why not?  In both Java and Python, concatenating strings in a loop is quadratic; in the former you use a StringBuilder to avoid this, and in the latter you build up a list (or any iterable, really) and then ''.join(it). Even in Haskell, you don't want to be building lists by appending.  Why is concat not enough?"
haskell,3cqlua,rpglover64,6,Fri Jul 10 01:13:45 2015 UTC,"Because it has completely different asymptotics, thats why. Strict Text is an array without sharing. You'll get memory bloat and burning CPU cycles by using the strong structure.  Builders don't do the same thing as Lazy Text even, you simply can't write the same programs with them.  Keeping Lazy Text is pretty much an algorithmic requirement. You could advance it to be a rope or something, but you need a chunked version."
haskell,3cqlua,davean,8,Fri Jul 10 01:52:01 2015 UTC,Apparently I don't know the first thing about strict vs. lazy text. Do you have any reading material about their implementation?
haskell,3cqlua,rpglover64,2,Fri Jul 10 02:29:53 2015 UTC,Text.Lazy = [Text.Strict]
haskell,3cqlua,twistier,1 point,Fri Jul 10 12:27:28 2015 UTC,That would seem to suggest that concat is enough.
haskell,3cqlua,rpglover64,1 point,Fri Jul 10 12:51:37 2015 UTC,"In both Java and Python, concatenating strings in a loop is quadratic   In some implementations of Python, it is not.  Current versions of CPython can concatenate a string in-place if the reference count is 1.  Not sure about Java, both javac and Hotspot optimize string concatenation in very different ways."
haskell,3cqlua,f2u,4,Fri Jul 10 18:42:27 2015 UTC,"this should not require any fancy structure like a Builder   And even if you do use a Builder, what does it produce as output? A lazy ByteString! (and similarly for Text) And that's because it's simple and composable and has the operational behaviour that we often want."
haskell,3cqlua,dcoutts,2,Fri Jul 10 14:50:54 2015 UTC,"The cases for Data.Text.Lazy and Data.ByteString.Lazy are quite different, and much stronger for text.   The special optimization scheme that Text uses is 'pure', but it is indifferent between lazy and strict text. There is a pair of stream and unstream functions for each case, and in the (absurdly idealized) case where all the text functions fuse, no text is created or destroyed; everything happens at the level of the stream. It would not make any difference whether your module said import Data.Text or import Data.Text.Lazy.  Since the stream operations in https://github.com/bos/text/blob/master/Data/Text/Internal/Fusion/Common.hs do admit application to a sort of 'lazy text' or 'pure text producer,' it would be too bad if they weren't used for it.   In the case of lazy bytestring, I cannot really see that anything but confusion is served. It is [ByteString] pure and simple, and this disfigures everything including the builder machinery. The correct concept is that of a bytestring producer, something equivalent to   data B r = B {-#UNPACK#-} !ByteString r  type ByteString m r = FreeT B m r -- or one of a zillion variants  splitAt :: Monad m => ByteString m r -> ByteString m (ByteString m r)  fromHandle :: Handle -> ByteString IO ()  lines :: ByteString m r -> FreeT (ByteString m) m r   and so on. The types could be specialized to the case at hand - just as Data.ByteString.Lazy doesn't use [ByteString], but its own specialized list concept. The 'prelude' for such a 'ByteString' idea would perfectly pure, in the sense of monad-indifferent.    As soon as one sees that lazy ByteString is ByteString Identity () one sees that what we have in Data.ByteString.Lazy are things like    fromHandle :: Handle -> IO (ByteString Identity ())   which is an out-and-out conceptual monster.   The trouble is that as things stand the only way to get an equivalent of ByteString m () is to use one of the fancy streaming IO frameworks. which do indeed ""bring in extra notions."""
haskell,3cqlua,michaelt_,3,Fri Jul 10 03:08:02 2015 UTC,"You're describing stream fusion.  There are plenty of ops that conceptually don't fuse, but where the additional asymptotics help you. Being [ByteString] pure and simple is a nice property! The disadvantage to using that is you need a different API than normal ByteString. The lazy interface is what gives you that very nice API."
haskell,3cqlua,sclv,2,Fri Jul 10 03:31:14 2015 UTC,"No, the 'interface' for monadic 'bytestrings' like the ones I explained is almost indistinguishable from the one you see in Data.ByteString.Lazy. See for example Pipes.ByteString - here it is covered up by the fancy lenses and, of course, the fact that everything is sunk in the swiss-army-knife Proxy type. The difference is that Data.ByteString.Lazy is basically unusable. Nothing in heaven or earth can stop lazy bytestring from being equivalent to ByteString Identity () explained along the above lines. But if we specialize on that we gain basically nothing, and lose genuine applicability. The user is forever extracting a ByteString Identity () from stdin, rather than dealing directly with stdin :: ByteString IO ()"
haskell,3cqlua,michaelt_,3,Fri Jul 10 03:35:11 2015 UTC,"Your entire approach seems based around the idea that a core use of lazy bytestrings is lazyIO. My entire argument is based around the idea that lazy bytestrings are a very nice datastructure entirely independently of any sort of effectful context, and that it is nice to have a them precisely as such.  It also seems entirely clear to me that the asymptotics on the type you've given are not the same as those of a lazy bytestring, even though interfacewise they may appear equal in power."
haskell,3cqlua,sclv,3,Fri Jul 10 04:22:04 2015 UTC,"I'm not sure what you are putting under the heading of 'asymptotics'.  If you mean for example, that we can cut and paste and crop without copying and making giant new actual arrays, then there is absolutely no difference between lazy bytestring and e.g. the pipes-bytestring Producer ByteString m r or some perhaps much more specialized equivalent. There couldn't be, since lazy bytestring is Producer ByteString Identity (); there's just no way around it. If there are special optimizations available for operations only in the Identity monad, we can use them in module Data.ByteString.Producer.Identity. In fact though, there aren't any.  I was amazed too, but it goes on and on like this."
haskell,3cqlua,michaelt_,2,Fri Jul 10 04:39:53 2015 UTC,"Ah I see the argument. But you're missing a beat.  Assume we use FreeT -- that's:  data FreeT f m r = FreeT { runFreeT :: m (FreeF f r (FreeT f m r)) }   Where FreeF is our skeleton of a free monad.  So even if Identity is a newtype, FreeT and FreeF are not -- so we have more constructors than we otherwise would for the same thing.  You're right that in this construction the asymptotics match up, because we ""morally"" just have a list. But it is a heavier-weight way to encode it, because it is a list with interleaved potential effects, even if we now specialize those effects to identity.  And furthermore, as I've been arguing, lazy bytestrings have a very rich API, which is a different sort of rich API than you get from the construction you give.  Just because a simpler thing is a special case of a complicated thing doesn't mean there's any reason to then get rid of the simpler thing in favor of the more complicated one.  Your same argument would extend to never using lists at all, but instead always using interleaved lists with effects. I hope you'll agree that's... odd at the very least."
haskell,3cqlua,sclv,3,Fri Jul 10 06:29:50 2015 UTC,Why would you not make FreeT a newtype?  The one in Control.Monad.Free is a newtype.  Then all you're left with is FreeF which just corresponds to the distinction between [] and :.  I can't see how you've lost anything in this translation.
haskell,3cqlua,tomejaguar,2,Fri Jul 10 10:05:52 2015 UTC,You still have FreeF and the base bytestring functor.  And I don' t know why FreeT isn't a newtype there -- i just pulled the direction straight from the pipes library.  Perhaps it was an old version?
haskell,3cqlua,sclv,2,Fri Jul 10 14:29:30 2015 UTC,"Certainly that should be newtype. However there are a thousand alternatives before us even for the general case. In the present discussion we considering the possibilities where the so-called base functor is specialized as    data T r = T {-#UNPACK#-} !Text r  data B r = B {-#UNPACK#-} !ByteString r   whatever you want to call them.   The real trouble with the newtype formulation is that the compiler has nothing to specialize. Constructor counting by itself does not have the significance it might usually be thought to have, at least as far as I have been able to tell, because we are not envisaging the whole structure ever present in memory.  That's because we are only considering sequences of things, not e.g. branching trees, implementations of maps to which refer again and again, and so on. Also, we are attempting to optimize Stream Word8 and Stream Char and have already made a spectacular win by packing the individual units of interest in chunks of genuine ByteString and Text chunks."
haskell,3cqlua,michaelt_,1 point,Fri Jul 10 16:48:29 2015 UTC,"The way of formulating a general FreeT type that corresponds to what Pipes does is    data List f m r = Return r | List (f (List f m r) | Wrap (m (List f m r)   For its complicated Proxy type, pipes just specializes this to the 'base functor' Sum (Compose ((,)a) ((->) a')) ((Compose ((,)b) ((->) b'))). All this needs to be handled with some care, since the type one intends is a sort of quotient of this. The scheme works well, but there are a million others. The implementation that would be strictly parallel to this, in the present case would be   data ByteString m r =     Empty r     | Chunk {-#UNPACK#-} !S.ByteString (ByteString m r)    | Wrap (m (ByteString m r))   this gives the compiler plenty of things to specialize before it gets to the unspecific 'm' in the Wrap constructor. This is the existing implementation, except that Empty can carry a return value and a possibility of 'monadic' sequencing is given.  The return value is need to expressing pairing:   splitAt :: Monad m => Int -> ByteString m r -> ByteString m (ByteString m r)   in place of the non-streaming    splitAt :: ByteString Identity () -> (ByteString Identity (), ByteString Identity ())   And, you still need something like the more general List or FreeT type to express things like   lines :: ByteString -> [ByteString]   as    lines :: Monad m => ByteString m r -> List (ByteString m) m r   The only other deep differences between the associated prelude of functions are that splittings are expressed like so  and that folds are monadic   length :: Monad m => ByteString m r -> m Int   Thus procedures for composing various folds are desirable, since of course we can't get the past back to do a second run; for that you need to stop streaming and accumulate into another type."
haskell,3cqlua,michaelt_,2,Fri Jul 10 22:16:14 2015 UTC,"In the discussion of text, I was of course presupposing that the reader was familiar with stream fusion."
haskell,3cqlua,michaelt_,2,Fri Jul 10 03:52:29 2015 UTC,My point there was that the optimization framework is indifferent between realizing the streams as strict or lazy text. This is a genuine 'asymptotic' advantage that has no equivalent in Data.ByteString.Lazy.
haskell,3cqlua,michaelt_,17,Fri Jul 10 05:23:48 2015 UTC,"I'm +0 on deprecating them, but +1 on the discussion thereof."
haskell,3cqlua,snoyberg,11,Fri Jul 10 00:27:37 2015 UTC,"Lazy.ByteString is used in various places in warp, correct?  Was there a design choice for this? Some impact on low-level / socket stuff? (asking mostly out of curiosity)."
haskell,3cqlua,aaronlevin,16,Fri Jul 10 00:43:49 2015 UTC,"Wait, really? goes to check  Not for anything useful. There was an unused import/identifier, and in one place it used responseLBS when responseBuilder was more appropriate anyway. I'd completely forgotten about that code, thanks for reminding me!"
haskell,3cqlua,snoyberg,3,Fri Jul 10 01:37:52 2015 UTC,What is the motivation for using lazy bytestrings in http-conduit? It claims that it doesn't do lazy IO so the whole string lives in memory anyway.
haskell,3cqlua,cocreature,3,Fri Jul 10 05:39:09 2015 UTC,"It avoids having to allocate a single large chunk of memory and copy all of the bytes in there. I've never once tested what the performance hit of doing that would be. Arguably, a single strict chunk is a better default in that case since you should never be using httpLbs for a large response body."
haskell,3cqlua,snoyberg,1 point,Fri Jul 10 10:26:45 2015 UTC,Thanks for the answer.
haskell,3cqlua,cocreature,7,Fri Jul 10 13:07:11 2015 UTC,"I think a very important thing missing from this discussion is: what do we mean by ""deprecate""?  I think that term can be finessed in a variety of ways.  One that I think sees some support from the discussion here is this:   As /u/sclv mentions, it's important to distinguish between the lazy types and the lazy IO actions.  The case for deprecation may be reasonably narrowed to the latter. /u/Tekmo mentions the case where you don't need streaming libraries, and can make do with (what I read as) lazy IO.  But perhaps a finesse on that is this: use lazy IO only in contexts where you are the one who will have to live with any negative consequences thereof.  So for example, if you're writing a library that you would like third parties to use, avoid lazy IO.  If you're writing a throwaway standalone program for your own use, feel free."
haskell,3cqlua,sacundim,16,Fri Jul 10 06:18:57 2015 UTC,"I'd prefer it. I never import lazy ByteString or lazy Text unless a library I'm using forces me to do so, and often it'll be just to convert it to something strict. The only reason String appears in my programs is because a library I'm using is old fashioned, and then it gets packed into Text anyway.  I agree re streaming libraries; my experience with conduit is that it's nicer to have a general API for ""stream of something"" than libraries implementing their own lazy stream types. It's explicit in that it's dealing with a stream of chunks, and the boundaries are clearer.  Also, a stream is often overkill when simply loading the whole thing into memory or writing to the Handle's buffer directly a strict string is sufficient. For newbies or quick programs, strictly reading in the whole thing is just more predictable. I remember being a newbie and the choice to pick between lazy and strict IO was mystical.  Relatedly, an initiative to move many of the System.IO functions to System.IO.Lazy and removing them from Prelude would be good, but that'll probably never get past the old guard who think lazy IO with [Char] is Just Fine and that the Prelude cannot shrink under any circumstances."
haskell,3cqlua,chrisdoner,13,Fri Jul 10 00:32:01 2015 UTC,"Your latter proposal (at least the part regarding moving the lazy functions to their own module) I'm more on board with. I find lazy IO useful, but with sharp edges. Forcing and import to indicate you ""really mean it"" sounds quite reasonable to me."
haskell,3cqlua,sclv,3,Fri Jul 10 00:59:20 2015 UTC,"I wouldn't complain either. Incidentally, the I/O actions in Data.ByteString ought to move to their own module, like they're split out for Data.Text."
haskell,3cqlua,dcoutts,3,Fri Jul 10 15:45:18 2015 UTC,"Incidentally, the I/O actions in Data.ByteString ought to move to their own module, like they're split out for Data.Text.   I'm interested in the reasoning behind that. I always found it a bit of a buggerance to have to import Data.Text.IO to do a T.putStrLn. Although I'd be totally onboard with it if there's a compelling reason for it."
haskell,3cqlua,chrisdoner,2,Fri Jul 10 16:27:49 2015 UTC,"Indeed, one ought at least to avoid the tendency to quadratic expansion in the number of imports."
haskell,3cqlua,michaelt_,2,Fri Jul 10 17:50:14 2015 UTC,"I'm not really sure if deprecating lazy variants is a good idea, but one thing that confuses me very often is the proliferation of string types. For instance, when using the aeson package, I often find myself importing lazy ByteString, some Builder and lazy Text, just for the purpose of converting between these types.   So, I'm in favor of consolidating the string types in a single import, but I have not yet formed an opinion on which it should be."
haskell,3cqlua,apfelmus,4,Fri Jul 10 10:00:53 2015 UTC,"I'm also pained by the number of string types, but I don't think you really can get away with just one of strict and lazy bytestring/text. Usually in each case only one of them makes sense (usually for performance reasons), and so I usually think trying to parametrise over them all is a mistake."
haskell,3cqlua,dcoutts,5,Fri Jul 10 14:55:52 2015 UTC,"To elaborate a little with that aeson and builder example: it uses a builder because that's the efficient thing to do. A builder uses multiple buffer chunks because it doesn't know up front how big the output is going to be, and each time a buffer is produced that's an opportunity for the consumer to write the buffer chunk somewhere. Obviously this corresponds naturally with a lazy bytestring, and so that's why that's used there.  In that example, one does not want to use the wrong type (ie strict rather than lazy) and the choice should not be hidden by parametrising. If you're going to convert the result of serialising a structure to json from lazy bytestring to strict then that ought to be explicit in your code, because it relies on your assumption that the size of the result is small (for some definition of small)."
haskell,3cqlua,dcoutts,7,Fri Jul 10 15:50:33 2015 UTC,"I totally understand. The thing is just that most of the time, I really do not care about performance at all, which is also why I frequently use String. Chances are that I will rewrite the code long before the nuances between lazy strings, strict strings or builder become relevant. It's not that the distinction is unimportant — the trouble is more that I have to convert between different data structures when I do not yet care about which one it is. This makes it harder to compose different library functions.  What I would like to see is a canonical way to convert between different representations, i.e. some very leightweight glue code that comes from a single module and which I can use without thinking a lot. The OverloadedStrings language extension intends to do something like that, but it never quite worked for me. Often, I end up using T2.pack . T1.unpack just because conversion via String is the easiest combination I can think of."
haskell,3cqlua,apfelmus,3,Fri Jul 10 17:33:23 2015 UTC,"I sympathise. These days we do at least provide semi-convenient conversion functions. The concern with making them too invisible though is what I said above, about hidden performance bugs. But it's worth looking at whether we can make the other common conversions clearer / more regular to help with the ""but I don't even care yet"" case.  Suggestions welcome. But I should say pre-emptively that I don't like a general convert :: Convertable a b => a -> b approach because again I think it hides those expensive operations too much (toLazy is O(1) time and space but toStrict is O(n) time and space)."
haskell,3cqlua,dcoutts,1 point,Fri Jul 10 18:48:38 2015 UTC,"I think it's best for a library to always return the monomorphic variant, i.e. the data structure that the library deems appropriate.  I don't mind if we have different names like convertToLazyText :: Convertable a => a -> Lazy.Text etc -- usually, you end up specifying the name in a type signature anyway due to ambiguities, so you can as well write it down from the beginning. The short the names, the better, though.  In any case, I think the important thing is to have these conversion functions available from a single module. Often, I import, say, both Data.ByteString.Lazy and Data.Text.Lazy just to be able to convert one type to the other because I want to glue two third-party libraries together. Only having to import a single module, say Data.String.Convert, and being able to find all the conversion functions in the documentation of this module would be a huge improvement, in my opinion."
haskell,3cqlua,apfelmus,1 point,Sun Jul 12 08:11:25 2015 UTC,Lazy IO with [Char] is Just Fine - in some circumstances. But I doubt anyone would disagree with moving the lazy IO functions out of the Prelude.
haskell,3cqlua,yitz,1 point,Sun Jul 12 10:43:59 2015 UTC,"I don't think it's just fine... I believe it to be super error prone, violate the nice properties we have via purity, leaky, and all around terrible..."
haskell,3cqlua,yitz,1 point,Fri Jul 17 20:02:53 2015 UTC,"It is well defined and principled, and thus by definition doesn't violate anything or leak anything as long as you observe the caveats implied by its definition. Pure functions whose input is read via lazy IO, or whose output is written using lazy IO, are still completely pure in a very well-defined sense. In situations that are a good fit for its computation model, it is still the simplest and most straightforward way to do IO.  From what I understand, most of the stuff you do happens not to be a good fit for lazy IO. So it's understandable that you won't use it. Some of the stuff I've done is a good fit and some is not. When it was good - it was great, and I wouldn't want to have to use anything else. When it was bad - it was very bad, but that was quite clear from the outset, and I used something else."
haskell,3cqlua,literon,1 point,Mon Jul 20 10:36:18 2015 UTC,"It is well defined and principled,   How so? It interacts with IO.  result <- withFile ... $ \h -> doPureStuff h   Becomes valid or not (IO-wise), depending on the evaluation order of the pure doPureStuff.  If you have a reference to the ByteString you read via lazy I/O (that you forced a prefix of, and will never force the suffix), you leak the file handle.  The IO effects and the IO exceptions are translated to pure exceptions that pop up in random unrelated places to the IO action that supposedly did the IO.  It has such weird rules and interactions with other stuff that I would call it anything but simple.  A more appropriate word could be insidious. It is seemingly simple but incredibly complicated."
haskell,3cqlua,dcoutts,3,Mon Jul 20 16:54:44 2015 UTC,"My gut feeling was (when writing an api for consumption by unknown parties) to take lazy as input, and return either strict (when I condense the input) or explicitly streaming (with pipes etc, if my operation was monadic).  Taking lazy gives the largest freedom for any caller, while leaving room for fused operation operating chunk wise behind the scenes."
haskell,3cqlua,literon,2,Fri Jul 10 12:56:52 2015 UTC,"Yes I think that's sensible advice. If your code can accept incremental input then that's more general. On output yes it depends on what your code does. If it necessarily produces a single chunk then you preserve that information by returning a strict string. On the other if you can get some performance advantage by producing output incrementally (or you don't know how big the output will be) then lazy output strings are good.  On the other hand if you're just storing strings in memory for long periods, especially short ones, then there are space advantages to using a single chunk. (Indeed the bytestring lib now has ShortByteString for such special cases.) Or if you're going to be traversing a string kept in memory many times, especially using C code then a single chunk (or at least fewer) can be faster."
haskell,3cqlua,drb226,1 point,Fri Jul 10 15:56:41 2015 UTC,If your code can take incremental input you may as well support a stream producer and not just a pure stream of chunks?
haskell,3cqlua,pchiusano,1 point,Fri Jul 10 18:51:22 2015 UTC,My point with taking lazy input was that anything can be converted to that - either strict or produced.  I would expect that having a function from lazy text to lazy text can be trivially lifted to a pipe-like thing consuming/producing strict chunks by the user if needed. Can it not?
haskell,3cqlua,tomejaguar,3,Fri Jul 10 19:55:06 2015 UTC,"My point with taking lazy input was that anything can be converted to that - either strict or produced.   Effectful streams generally cannot be converted to ""lazy input"" without performing the entire effect. For example, reading from a file.  On the other hand, lazy input can easily be turned into an effectful stream. So I think that it is more accurate to say that ""anything can be converted to effectful streams"", and that should be the preferred universal input type."
haskell,3cqlua,pchiusano,2,Fri Jul 10 20:21:11 2015 UTC,"You can't really convert an IO stream of bytestrings/text into a lazy bytestring/text. You'd have to read it all or use lazy I/O, both of which are bad options.  I don't think you can lift an incremental processor like: [a] -> [a] to a Pipe m a a that incrementally consumes (without lazy I/O). Pure consumption of the next list element should trigger the next m action to generate the next chunk, but that may require lazy I/O."
haskell,3cqlua,dcoutts,2,Fri Jul 10 20:09:22 2015 UTC,"This discussion has gotten completely derailed. It's somehow become about whether [Text.Strict] and [ByteString.Strict] are useful concepts or not. Of course they are. That doesn't mean the status quo (which is a usability catastrophe and results in plumbing code which is annoying for experts and confusing for newbies) should continue!  What is wrong with the following definitions:  import Data.Sequence  data Text' = Text' (Sequence Text.Strict) data ByteString' = ByteString' (Sequence ByteString.Strict)   We then get rid of separate Text and Text.Lazy, likewise for ByteString. That is, Text' is the only public type, and the strict chunk type inside is an implementation detail. A Sequence of chunks covers 99% of the use cases, is just as efficient or more efficient (asymptotically anyway, and I'm sure constant factors could be optimized). And if you really want to work with [Text'] where the segments happen to be single-chunk sequences, go right ahead. We don't need to create a separate type for that though (but if you really want to, well go ahead and make a separate library)."
haskell,3cqlua,pchiusano,2,Fri Jul 10 13:53:21 2015 UTC,"That is, Text' is the only public type, and the strict chunk type inside is an implementation detail   Do you mean that strict Text would be just a Sequence of length 1?"
haskell,3cqlua,dcoutts,1 point,Fri Jul 10 14:01:52 2015 UTC,Yes.
haskell,3cqlua,sclv,3,Fri Jul 10 14:05:05 2015 UTC,"This is tricky for performance reasons. Operations on chunked strings tend to create more chunks, and more chunks tends to slow things down. With lazy semantics (ie a lazy list not a tree) it's also pretty hard to automatically rechunk. There are quite a few cases where it's useful to know for sure that the thing is just a single buffer, and not a whole bunch of them.  It's not totally implausible. One could do it with a tree of chunks for the strict case. But a tree doesn't work for the lazy use case, and in the lazy use case that's where you cannot easily opportunistically rechunk because operations are not allowed to ""look ahead"" because that breaks the strictness properties of the functions. So it doesn't easily let you unify the strict and lazy string types."
haskell,3cqlua,pchiusano,2,Fri Jul 10 15:39:20 2015 UTC,"By 'performance reasons', you are talking about constant factors. With an efficient sequence type, you get the same or better asymptotics as the strict 1-chunk Text we have now. And the type becomes usable for many more cases. Seems like a clear win to me.  I also believe that the constant factors can be made very small with good engineering. But in any case, why would we settle for a worse API just to improve constant factors? This is Haskell, not C.  Again, this isn't a discussion about whether my proposal satisfies every use case, I'm sure there are cases where working with a lazy list of chunks is exactly what you want. Fine, someone can create a separate library for that (or just use [Text] explicitly). It's a question of what the default type should be that everyone uses 95% of the time. The situation right now is pretty bad IMO."
haskell,3cqlua,sclv,4,Fri Jul 10 15:54:52 2015 UTC,"I would really welcome someone writing a tree-style multi-chunk strict bytestring/text and demonstrating what the constant factors are. When Don and I were writing the new bytestring we did think a bit about a rope/sequence of chunks style. As I said above, it's not the same use case as a lazy list because a balanced tree can't represent a lazily produced sequence. But as you're suggesting it could in principle replace the strict bytestring as the default (leaving the ""guaranteed to be one chunk"" for the special case of FFI). The problem is it's a lot of hard work to do really well, and our intuition was that you have to do really well to stay close to the constant factors of the single chunk (or even lazy multi-chunk) representations.  If you or anyone else wants to have a go, here's where I'd start (I've got an old tech report on bytestring and its variants somewhre if you're interested): keep the first chunk always easily available to minimise indirections to the head, something like:  data ByteString = BS {-# UNPACK #-} !SingleChunkByteString                                     !(FingerTree SingleChunkByteString)   With the invariant that the first chunk is never empty except when the entire tree is empty. You also need to pick your heuristics for when to merge chunks carefully and tune and benchmark them.  Good luck!"
haskell,3cqlua,pchiusano,3,Fri Jul 10 19:03:38 2015 UTC,"With an efficient sequence type   With an efficient sequence type you can win best paper at ICFP :-P   someone can create a separate library for that   But we have a library for that already!  I think the only complaint is that, as this thread indicates, people don't know when to use what, or they find the naming convention slightly confusing.  Once we agree these are all valid cases that need their own types, that's the end of the story, modulo renaming."
haskell,3cqlua,pchiusano,2,Fri Jul 10 16:32:47 2015 UTC,"With an efficient sequence type you can win best paper at ICFP :-P   I have no idea what you are talking about. There are great purely functional sequence types, most of them discovered over 15 years ago.   I think the only complaint is that, as this thread indicates, people don't know when to use what, or they find the naming convention slightly confusing.   This is why Haskell's libraries have such catastrophically bad usability. No one has applied taste and good judgement to come up with reasonable defaults, and libraries (which everyone is told to use) often make it easier to make the wrong choice. The result is an ecosystem with totally inconsistent usage of each of the different types, often with little rhyme or reason (""eh, I guess I'll take a strict ByteString here""; ""Okay, I'll allow lazy Text here"") which forces plumbing code on everyone else and is confusing for newcomers (which was part of the OP's question...).  I think part of the problem is that people will not even acknowledge it is a problem that there is no reasonable default provided by the ecosystem, only 4 very different types (String, Text, Text.Lazy, and Builder) each with completely different behavior, requiring expertise to decide between. (And none of these types cover cases where you are alternating between building and observing your string, for which you need ropes of some sort anyway...)  I'm also rather dubious there are even many uses of Text.Lazy that can't just use [Text] and Text.concat explicitly. I would like to see a non-contrived example of this in the wild that isn't lazy I/O.  An efficient sequence of chunks is a great compromise. I still haven't heard a compelling argument as to why that's a bad default."
haskell,3cqlua,dcoutts,1 point,Fri Jul 10 18:58:11 2015 UTC,"I have no idea what you are talking about. There are great purely functional sequence types, most of them discovered over 15 years ago.   And their constant factors are all insufficient for what we want.  What precise ""efficient sequence"" do you keep proposing here?  (On another note, we do have a default type, which is String. Once you move past that, you only have two types, strict and lazy text. ByteString is not for text. It is for streams or chunks of bytes.)"
haskell,3cqlua,drb226,1 point,Fri Jul 10 19:11:46 2015 UTC,"Constant factors are often more important than asymptotics.  We care about performance, and asymptotics are only half of the problem, and I disagree they're necessarily the more important half."
haskell,3cqlua,sclv,1 point,Fri Jul 10 18:54:34 2015 UTC,"I get what you are saying. But why can't we have both in this case? Good asymptotics, and good engineering to get the constant factors close enough. Look at like array-indexed trie based sequences. Great asymptotics AND great constant factors. It can be done."
haskell,3cqlua,tomejaguar,1 point,Fri Jul 10 20:20:17 2015 UTC,"Wrapping all the strict bs/text with sequence of 1 will add a bunch of expensive indirections and possibly have more side effects. It'll necessarily harm the constant factors, probably significantly."
haskell,3cqlua,sclv,0,Fri Jul 10 23:01:15 2015 UTC,You should write all your code in C then if you are seriously worried about the cost of an extra pointer indirection. Then you'd really have all the control you needed. :)
haskell,3cqlua,pchiusano,5,Fri Jul 10 23:38:38 2015 UTC,"the cost of an extra pointer indirection   This is exactly the sort of thing that the bytestring and text library authors worry about so that you don't have to. It's partly why Haskell went from being considered slow to being considered fast. We got these libraries and a bunch of others that take performance seriously with minimal compromises on ""Haskelly niceness"" (e.g. pure, lazy, high level)."
haskell,3cqlua,sclv,2,Sat Jul 11 01:48:09 2015 UTC,I write a lot of my code in c indeed. Don't force me to write even more of my Haskell code in c :)
haskell,3cqlua,pchiusano,1 point,Fri Jul 10 23:41:57 2015 UTC,"There are quite a few cases where it's useful to know for sure that the thing is just a single buffer, and not a whole bunch of them.   Okay then, how about  data Text' = TextSingle !Text | TextMultiple !(Sequence Text)   Then you can case split whenever you have a Text' and know for sure if it makes it into the TextSingle branch that you have a single buffer."
haskell,3cqlua,michaelt_,2,Fri Jul 10 20:26:03 2015 UTC,"Hah! I could almost get on board with this for text. But I suspect there would be a riot :-P. (Also we'd need to use lists and not sequences, because the asymptotics are not what you would hope).  For bytestring, as I discuss elsewhere, this wouldn't make sense, because one purpose it serves is as something that works well with the FFI, as a wrapper for ""foreign array of bytes,"" and that only works properly with the strict variant."
haskell,3cqlua,pchiusano,3,Fri Jul 10 14:50:57 2015 UTC,"Also we'd need to use lists and not sequences, because the asymptotics are not what you would hope   What do you mean?"
haskell,3cqlua,michaelt_,2,Fri Jul 10 15:30:09 2015 UTC,"erm, not asymptotics, but rather constant factors I meant. i mentioned this elsewhere -- the constant factors in sequences are bad enough that lists can beat them in certain very common cases."
haskell,3cqlua,drb226,2,Fri Jul 10 16:30:26 2015 UTC,"For bytestring, as I discuss elsewhere, this wouldn't make sense, because one purpose it serves is as something that works well with the FFI, as a wrapper for ""foreign array of bytes,"" and that only works properly with the strict variant.   I am totally unconvinced by this argument. If anything, the FFI should just be smarter and allow one to define nontrivial marshalling functions for types (maybe it already supports this, actually, I don't know the FFI at all). And besides, usages of ByteString for pure Haskell code are still the vast majority and we should have the best API for pure Haskell code. If there's a bit more plumbing when going to FFI, that's the right place to force more plumbing code!"
haskell,3cqlua,agocorona,2,Fri Jul 10 16:00:08 2015 UTC,"But the marshalling needs to go via some type. That type is, most naturally, ByteString.  You may say ""that is a niche case"" and yes it is. So that tells me that strict bytestring is useful mainly for this niche case :-)"
haskell,3cqlua,singpolyma,2,Fri Jul 10 16:29:12 2015 UTC,"Agreed. But that is not a point in favor of making the strict ByteString a type everyone uses throughout public APIs, which is the current situation.   I would move the strict, 1-chunk version to a separate package that pretty much no one depends on directly, unless they are doing FFI stuff and need it."
haskell,3cqlua,codygman,2,Fri Jul 10 16:36:00 2015 UTC,"Yes, you are considering assemblages of Word8 and Char that are a) successive and yet b) always completely constructed in memory. This is not 99% of the use cases."
haskell,3cqlua,singpolyma,2,Fri Jul 10 17:09:50 2015 UTC,When they aren't the use case you usually need effects in some monad and a lazy text/bs isn't enough anyway.
haskell,3cs143,rorriMnmaD,25,Fri Jul 10 08:37:59 2015 UTC,"You may have been confused by the overlapped uses of Person. There are two different Persons in the code above: one as a type, the other as a constructor. If we rename the latter to MkPerson, we get the following:  data Person = MkPerson String Int Thing   deriving Show  brent :: Person brent = MkPerson ""Brent"" 31 SealingWax  stan :: Person stan  = MkPerson ""Stan"" 94 Cabbage  getAge :: Person -> Int getAge (MkPerson _ a _) = a   Then let's think about the caller's side. You may use getAge like this:  main = print (getAge person)   where person = MkPerson ""Akemi Homura"" 14 thing   Now you can see MkPerson _ a _ will be matched against MkPerson ""Akemi Homura"" 14 thing. So, in this case, a will be assigned to 14."
haskell,3cs143,barosl,2,Fri Jul 10 08:51:22 2015 UTC,Great answer. If only this was posted on StackExchange :)
haskell,3cs143,cies010,1 point,Fri Jul 10 08:53:47 2015 UTC,+1 for the madoka reference
haskell,3cs143,gilmi,2,Fri Jul 10 10:10:51 2015 UTC,Homura did nothing wrong.
haskell,3cs143,MonkeeSage,3,Fri Jul 10 12:54:37 2015 UTC,"I'm a complete noob, but the way I'm looking at it is:  You have a Person, and a Person has a String, and Int, and a Thing. In getAge, you say that it takes in a Person, and produces an Int. In the pattern match it's saying, ""When we're working with a Person, I don't care what that person's String is, or what its Thing is, I only care what its Int is,"" and then it returns the Int.  I'm really new to Haskell, but can someone tell me if I'm on the right track?"
haskell,3cs143,banebot,2,Fri Jul 10 14:28:35 2015 UTC,"Sure, you can view it like that. You're basically reaching into the structure and pulling out what you actually want to use."
haskell,3cs143,IceDane,3,Fri Jul 10 15:35:35 2015 UTC,"Perhaps lining things up visually will help illustrate what's going on?  getAge (Person  _        a    _        ) = a ---------------------------------------------- getAge (Person  ""Stan""   94  Cabbage   ) = 94 getAge (Person  ""Brent""  31  SealingWax) = 31   The underscores indicate that the data at that position is ignored. The a indicates that whatever data is at that position will be referred to as ""a"" on the right-hand-side of the equation."
haskell,3co9qm,tailbalance,10,Thu Jul 9 13:24:34 2015 UTC,Did something neat or unexpected come out from writing these proofs?
haskell,3co9qm,smog_alado,5,Thu Jul 9 18:40:10 2015 UTC,A few interesting things are mentioned in the history section of the read me.
haskell,3co9qm,dagit,2,Fri Jul 10 07:10:11 2015 UTC,"The use of Coyoneda to work around Coq's strict positivity requirement for transcoding the Proxy type was the most useful result.  I've written a separate Functional Pearl on this, which has been submitted to the Journal of Functional Programming.  Another positive outcome is the ability to play with experimental transformations of the core Proxy type (for example, using a Church encoding to avoid poor asymptotics of the recursive nature of the Proxy_bind function), and prove that such transformations are correct with respect to the Pipes laws."
haskell,3co9qm,jwiegley,6,Mon Jul 13 20:29:54 2015 UTC,"How do you deal with the mismatch between Haskell and Coq types? Are all functions assumed total, are all Haskell data declarations interpreted as codata?"
haskell,3co9qm,gallais,6,Thu Jul 9 15:35:32 2015 UTC,https://github.com/jwiegley/coq-pipes#the-compromise
haskell,3co9qm,Mob_Of_One,7,Thu Jul 9 16:34:35 2015 UTC,"(for example, runEffect must be a fixpoint)   Can someone elaborate?  I'm unconvinced that this ""compromise"" doesn't in fact imply absurdity. I don't know much about Coq inductive data types, but couldn't you show that the base case both is and is not reachable?"
haskell,3co9qm,PM_ME_UR_OBSIDIAN,3,Thu Jul 9 16:38:44 2015 UTC,"but couldn't you show that the base case both is and is not reachable?   I don't understand the question. Do you mean with no further axioms this can be proven, or do you mean this situation could arise in the proof of something?"
haskell,3co9qm,drb226,4,Fri Jul 10 20:37:11 2015 UTC,My question is more general though (e.g. total programs of type [a] correspond to ones of type CoList a).
haskell,3co9qm,gallais,2,Thu Jul 9 16:37:46 2015 UTC,It's up to the individual Coq programmer but I think many will assume total/inductive unless being coinductive is proof-relevant.
haskell,3co9qm,Mob_Of_One,5,Thu Jul 9 18:35:28 2015 UTC,I think this deserve a repost in Coq subreddit.
haskell,3cndn7,mn-haskell-guy,24,Thu Jul 9 06:36:17 2015 UTC,"Little offtopic:  Is there a single one blog post explaining GADT without class Expr as an example?  I’m not complaining in any way, it’s just for some statistics :)"
haskell,3cndn7,tailbalance,25,Thu Jul 9 13:03:12 2015 UTC,I guess GADT tutorials have an expression problem.
haskell,3cndn7,NihilistDandy,7,Thu Jul 9 15:40:02 2015 UTC,(•_•) ( •_•)>⌐■-■ (⌐■_■)
haskell,3cndn7,sclv,10,Fri Jul 10 15:03:37 2015 UTC,"It's like dependent typing tutorials, which seem to mostly end up statically typing the length of a statically allocated linked list."
haskell,3cndn7,tibbe,8,Thu Jul 9 20:53:04 2015 UTC,They don't have to be statically allocated.
haskell,3cndn7,augustss,1 point,Thu Jul 9 22:53:15 2015 UTC,"How is it possible to use vectors with sizes known at compile time without hardcoding these sizes at least somewhere, perhaps near the IO?  The only thing that comes to my mind, that when one would like to convert a regular list / vector to a sized one, perhaps something like this would work:  class GetSize v n where     type Sized v :: Nat -> *     getSize :: (n <= m) => v -> sing n -> Sized m  instance GetSize Vector (n+1) => GetSize Vector n where    type Sized Vector = ...    getSize v n = if length v == natVal n then ... else getSize v (undefined :: sing (n+1))   With an exponential instead of a linear search it could be feasible, I guess, but I have no idea how to write this code so that it actually has some base case (other than artificially constraining it to some hardcoded number)."
haskell,3cndn7,mjmrotek,3,Sat Jul 11 07:38:46 2015 UTC,Who said the sizes have to be know at compile time?  You can prove things about numbers without having the concrete numbers.  The power of algebra over arithmetic. :)
haskell,3cndn7,augustss,1 point,Sat Jul 11 09:49:50 2015 UTC,"Okay, forgive my bluntness, but what if I don't really want to prove theorems about natural numbers, but do some actual programming instead?  Let's say I have functions like  add :: Vector n a -> Vector n a -> Vector n a  append :: Vector n a -> Vector m a -> Vector (m+n) a   That's all nice of course, but then I want to read a vector from a file, without any idea what its length could be:  read :: Handle -> IO (Vector' a)   So how to connect (Vector n) functions to Vector' ones? I guess something like this would be useful:  withSize :: Vector' a -> (forall (n :: Nat) . Vector n a -> b) -> b   but I have no idea how to implement it..."
haskell,3cndn7,mjmrotek,2,Sat Jul 11 10:08:40 2015 UTC,"If you want to use the power of dependent types there will be proofs (just as there are proof with statically typed languages, but with dependent types the propositions you prove are more interesting).  Hopefully these proofs will mostly be done by the computer. You are totally on the right track; if the size is not statically known you need some kind of existential.  The problem occurs already when converting a list to a vector.  But that's what existential are for; you know the length exists, you just don't what it is."
haskell,3cndn7,augustss,1 point,Sat Jul 11 10:19:34 2015 UTC,"If you want to use the power of dependent types there will be proofs (just as there are proof with statically typed languages, but with dependent types the propositions you prove are more interesting). Hopefully these proofs will mostly be done by the computer.   I was hoping that the SMT plugin for solving natural numbers constraints could handle this; I remember proving the associativity of addition in Agda, and I don't think that would add to the experience of using any length-indexed vector library ;)   You are totally on the right track; if the size is not statically known you need some kind of existential. The problem occurs already when converting a list to a vector. But that's what existential are for; you know the length exists, you just don't what it is.   Well yes, but converting a list to a vector (or a vector as in vectors package, to a newtype adding a type-level number) seems to require a function from values to types, and given that Haskell isn't a truly dependently-typed language even with all the fancy extensions, I'm not sure if anything like this is legal:  fromList : ∀ {a} {A : Set a} → (xs : List A) → Vec A (List.length xs)   EDIT: ... unless reifyNat from reflection is exactly what I'm looking for. Whether or not this package can be called ""legal Haskell"" ;)"
haskell,3cndn7,mjmrotek,2,Sat Jul 11 10:50:31 2015 UTC,"The reflection package uses some tricks for efficiency, but reifyNat can be written without such tricks."
haskell,3cndn7,augustss,2,Sat Jul 11 13:14:42 2015 UTC,"Hey, there is one about Pokemon. Granted, it's much more pointless than dependently typed lists, and it kind of starts with rather awkwardly defined types just to show that they're awkward, but still."
haskell,3cndn7,mjmrotek,11,Sat Jul 11 00:08:24 2015 UTC,"In some cases, OverlappingInstances can be considered harmful."
haskell,3cndn7,emarshall85,2,Thu Jul 9 12:26:12 2015 UTC,It would appear that they are actually Considered Deprecated by GHC 7.10
haskell,3cndn7,mjmrotek,3,Fri Jul 10 16:07:56 2015 UTC,Here is the actual deprecation message for OverlappingInstances from ghc:   -XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS   Here is some background.
haskell,3cndn7,m0rphism,-8,Sat Jul 11 08:39:40 2015 UTC,"The phrase ""considered harmful"" is considered harmful."
haskell,3cndn7,TheFryeGuy,2,Thu Jul 9 13:59:35 2015 UTC,It's true; someone on the internet says so: “Considered Harmful” Essays Considered Harmful.
haskell,3cndn7,rpglover64,10,Fri Jul 10 02:27:46 2015 UTC,"An alternate way around the above issue is to enforce that a has to be Char via some constraint, for example:   class CharType a instance CharType Char  instance CharType a => Truthy [a] where     truthy s = length s /= 0   Can be written as  instance a ~ Char => Truthy [a] where     truthy s = {- could use fact a is a Char! -} s == ""true""   EDIT: reference https://www.reddit.com/r/haskell/comments/3afi3t/the_constraint_trick_for_instances/"
haskell,3cndn7,phadej,2,Thu Jul 9 14:51:42 2015 UTC,"I was coming to the comments section to say exactly this, but you beat me :)"
haskell,3cndn7,radix,14,Thu Jul 9 15:45:14 2015 UTC,"Also, you may be interested in Oliver Charles' co-authored 24 Days of GHC Extensions.  Not to devalue your work, but perhaps you'd enjoy comparing notes or discovering more extensions.  edit: here is the full calendar."
haskell,3cndn7,emarshall85,1 point,Thu Jul 9 13:45:11 2015 UTC,"I have stumbled across this before and it's a great resource! My main motivation for writing my own post was phrasing things in a way that helped me get to grips with them, and putting it all in one place so that I could use it to remind myself later! I'll make a note to add a link to this from my post."
haskell,3cndn7,lytnus,7,Fri Jul 10 23:55:31 2015 UTC,This is great. I never even dared googling these language extensions since I've been spending so much energy grappling with the core language. But this is well presented and has made the language even more intriguing. Will share at work. Good write up.
haskell,3cndn7,nbkthrowaway2015,4,Thu Jul 9 11:49:35 2015 UTC,"+1, the format and content make this really helpful. Thank you! I hope you'll add more, keep them on one page, and make each extension linkable."
haskell,3cndn7,simonmic,1 point,Thu Jul 9 14:22:03 2015 UTC,"Thanks a lot, I didn't notice my post made it onto reddit :) I mean to make each extension linkable (current semi-limitation of system I'm using) and have a bunch more to add, so I'll update it gradually as I find time/learn more!  Edit Linkability added!"
haskell,3cndn7,lytnus,2,Fri Jul 10 23:41:40 2015 UTC,"I can't read this on firefox mobile (android) in landscape, the width of the text is wider than my 1080 pixels wide screen and it just won't let me zoom out!"
haskell,3cndn7,Ancipital,2,Thu Jul 9 20:26:15 2015 UTC,"Thanks for letting me know, I'll have a look at this on firefox mobile when I have time. It should have shrunk to fit, doh!  Edit I believe I've fixed this (and generally shrunk font sizes down a bit)."
haskell,3cndn7,lytnus,1 point,Fri Jul 10 23:43:10 2015 UTC,You have. Much thanks!
haskell,3cndn7,Ancipital,2,Sat Jul 11 18:22:26 2015 UTC,Some really clear explanations in here! Thanks very much.
haskell,3co5od,TheManaKnight,9,Thu Jul 9 12:44:43 2015 UTC,"It's great that something like this appeared, directly serializing thunks, without the strong limitations of Cloud Haskell (limited to what you can make a ""closure"" from) or a bit less restricting ones of HdpH (allowing additionally the composition of closures).  Some people like me have been looking for such a solution for communicating partially evaluated states to/from a computational agent (RESTfully, i.e., the agent is statelessly doing steps of pure computations; and the agent might be restarted).  Here is a shorter summary:   ...this serialisation is orthogonal to evaluation: the argument is serialised in its current state of evaluation, it might be entirely unevaluated (a thunk) or only partially evaluated (containing thunks).  ...The library enables sending and receiving data between different nodes of a distributed Haskell system. This is where the code originated: the Eden runtime system.  ...Apart from this obvious application, the functionality can be used to optimise programs by memoisation (across different program runs), and to checkpoint program execution in selected places. Both uses are exemplified in the slide set linked above.  ...Another limitation is that serialised data can only be used by the very same binary. This is however common for many approaches to distributed programming using functional languages.  ..."
haskell,3co5od,imz,4,Fri Jul 10 11:28:00 2015 UTC,This is great!
haskell,3co5od,augustss,3,Sat Jul 11 13:15:42 2015 UTC,"Does this work with GHC or requires a patched GHC (as in the Eden fork)?  Some time ago Rob Stewart wrote concerning the best available such serilization solutions:   The closest anyone has come to a design and implementation is Jost Berthold, who has implemented function serialisation in Eden. See his IFL 2010 paper ""Orthogonal Serialisation for Haskell"". The serialisation support is baked in to the Eden runtime system. Something similar would be needed for GHC. This is the serialisation support Eden, in the version forked from GHC 7.4"
haskell,3co5od,imz,5,Fri Jul 10 11:39:38 2015 UTC,This appears to work directly with GHC. So very neat!
haskell,3co5od,sclv,2,Fri Jul 10 15:06:01 2015 UTC,"This looks really cool. Is it possible to use ghci with this as a dependency, btw? Because I tried with a trivial package and trying to run cabal repl gives this:  <command line>: can't load .so/.DLL for: /home/ari/foo/.cabal-sandbox/lib/x86_64-linux-ghc-7.10.1.20150630/packm_IO3HxUTLbRYFQ7GGVeJZ2W/libHSpackman-0.2-JOjXGEW5z3VHMDLmBKwwpf-ghc7.10.1.20150630.so (/home/ari/foo/.cabal-sandbox/lib/x86_64-linux-ghc-7.10.1.20150630/packm_IO3HxUTLbRYFQ7GGVeJZ2W/libHSpackman-0.2-JOjXGEW5z3VHMDLmBKwwpf-ghc7.10.1.20150630.so: undefined symbol: ZCMain_main_info)   The important part seems to be ""undefined symbol: ZCMain_main_info"". I see that's referred to in Pack.c, but I don't know enough about how linking Haskell programs works to figure out whether it's possible to do this.  e: Actually based on looking at its limitations, actually trying to use this to serialize or deserialize anything while running from ghci is probably meaningless. But it'd still be cool to have a way of running cabal repl on a package with this in the dependency list.  e2: I suppose you could probably do a setup where you put most of your code in a library a la here and pass the packman functions down from main..."
haskell,3cmc6l,TheCriticalSkeptic,14,Thu Jul 9 00:52:37 2015 UTC,"in addition to security and graceful crashing, consider how different it would be to refactor, maintain, or improve your code after six months :p"
haskell,3cmc6l,mstksg,8,Thu Jul 9 01:39:13 2015 UTC,"Having already massively re-factored twice I can definitely see the benefits in that. Though with less pure code the refactoring wasn't as smooth as I've found on less IO heavy code.  There are downsides too. Trying to reason about why my WriterT was dropping logs during an exception was frustrating. But when I refactored the logs into the StateT it involved a handful of trivial changes.  In that sense you win some, lose some and some are rained out."
haskell,3cmc6l,sambocyn,3,Thu Jul 9 08:12:13 2015 UTC,"I've heard /u/Tekmo say that the WriterT in base is incorrect, and one should use StateT instead. possibly related."
haskell,3cmc6l,Tekmo,5,Thu Jul 9 19:05:30 2015 UTC,"Actually, the appropriate solution is to use a Producer to log values as I describe here."
haskell,3cmc6l,sambocyn,2,Thu Jul 9 19:13:10 2015 UTC,pipes for all!
haskell,3cmc6l,sacundim,9,Thu Jul 9 20:10:21 2015 UTC,"Well, one thing I notice when I write Java nowadays is that every time I write something like this:   private void whatever(Blah blah) {      // ...  }   I find myself thinking: ""How the heck can the caller know if whatever does the right thing if it returns no value as evidence that it even did anything?""  One example of this is that nowadays when I write a Visitor interface, instead of doing the texbook thing:  interface Foo {     void accept(FooVisitor visitor); }  class Bar extends Foo {     void accept(FooVisitor visitor) {         visitor.visitBar(this);     } }  // ...  interface FooVisitor {     void visitBar(Bar bar);     void visitBaz(Baz baz);     // ... }   I write this instead:  interface Foo {     <R> R accept(FooVisitor<R> visitor); }  class Bar extends Foo {     <R> R accept(FooVisitor<R> visitor) {         return visitor.visitBar(this.getThing1(), this.getThing2());     } }  // ...  interface FooVisitor<R> {     R visitBar(Thing1 thing1, Thing2 thing2);     R visitBaz(Thing3 thing3);     // ... }   ...with the logic that the second version provides greater compile-time assurances that the code is handling all the cases it ought to, because the code won't compile unless I go to the trouble of actually returning something of type R (ok, or throwing an exception).  Also, the Thing1/Thing2 thing: instead of making the visitor's methods take the exact subclasses of Foo, write them so that they're called with some sort of observation of the subcases of Foo.  More sum type-ish."
haskell,3cmc6l,theonlycosmonaut,3,Thu Jul 9 22:00:55 2015 UTC,"I work in a large C++ codebase that has void returns everywhere. It's a nightmare. Even if the method logically doesn't return something, it'd be nice to be able to chain setters so I don't have to repeat the object name on every line!"
haskell,3cmc6l,sambocyn,1 point,Fri Jul 10 02:43:09 2015 UTC,I like this. does this pattern have a name I can Google?
haskell,3cmc6l,sacundim,5,Thu Jul 9 23:36:45 2015 UTC,"I don't know.  It's just the Visitor pattern, except that I modified it so that visitors return values.  I'm certainly not the first person to think of it—the ANTLR4 parser generator generates visitor classes with a similar pattern."
haskell,3cmc6l,razvanpanda,2,Fri Jul 10 06:22:39 2015 UTC,"I think it is called method-chaining or fluent interface, see: https://en.wikipedia.org/wiki/Fluent_interface"
haskell,3cmc6l,acow,16,Sun Jul 12 00:06:38 2015 UTC,"I vote to make this the intro text on haskell.org :)  It's really wonderful to hear from someone improving their programming skills, as opposed to their Haskell skills. It's this kind of thinking that I appreciate Haskell for encouraging."
haskell,3cmc6l,kqr,20,Thu Jul 9 03:35:49 2015 UTC,"I vote to make this the intro text on haskell.org :)   To someone who hasn't used Haskell it is just a bunch of weird terminology with some evangelism. Monad transformers, pure functions, imperative, EitherT e (StateT s (ReaderT h IO)) a, IterT, mplus, forever, strictness, transformer stack and so on.  I'm not saying the experience is bad or useless, I'm saying it only means something to the ones who have had it themselves."
haskell,3cmc6l,acow,5,Thu Jul 9 07:08:04 2015 UTC,"Yes, I was being facetious as it is too much text, if nothing else. I just find it funny how we agonize over the few sentences there and end up pleasing nobody, and then have an unprompted testament like this that is so much more powerful."
haskell,3cmc6l,mjmrotek,9,Thu Jul 9 18:51:59 2015 UTC,"I appreciate the thought - some of this enthusiasm is definitely missing on haskell.org. Consider this intro on the Rust website:   Rust is a systems programming language that runs blazingly fast, prevents nearly all segfaults, and guarantees thread safety.   vs   An advanced purely-functional programming language   There's no enthusiasm or evangelism in that. And further down we get to the features section - and it is really just that: features. We could sell some of these features as the advantages they bring:   Helps you catch more errors at compile time and write more bug-free code It's a high-performance high-level language Type safety that let's you reason about your code like never before Easy to refactor pure functional code Write code that's trivially parallel Thread safe, exception safe, type safe - code more, worry less"
haskell,3cmc6l,augustss,3,Thu Jul 9 08:04:42 2015 UTC,"Write code that's trivially parallel   I'm not sure what do you mean by that, but I think that automatic parallelization is impossible in Haskell because of the lazy evaluation. Though lazy evaluation allows one to choose how to evaluate some particular piece of data, as in Control.Parallel.Strategies"
haskell,3cmc6l,mjmrotek,10,Thu Jul 9 10:39:25 2015 UTC,"Haskell does not have lazy evaluation, Haskell has non-strict evaluation.  The distinction is there exactly to allow you to evaluate as many things in parallel as you like.  For instance, in the application f x lazy evaluation would require you to evaluate f first and x when it is needed.  But with non-strict evaluation an allowed evaluation order is to evaluate f and x in parallel.  Of course, you have to ensure that any bottoms encountered in x does not wreak havoc.   Non-lazy evaluation strategies have been explored somewhat, e.g., in pH.  Here are some references https://wiki.haskell.org/Research_papers/Runtime_systems#Optimistic_Evaluation"
haskell,3cmc6l,augustss,3,Thu Jul 9 11:07:50 2015 UTC,"I stand corrected, but is it actually done by GHC? It would be still misleading to boast about trivial parallelism when it really isn't so trivial."
haskell,3cmc6l,mjmrotek,10,Thu Jul 9 11:16:47 2015 UTC,"No, it's not done by ghc.  Robert Ennals' branch of ghc was never merged, because it had rather extensive changes with not much gain.  A problem with this level of parallelism is that you get too much of it.  No matter how cheap thread creation is, it's still going to cost something, and this cost can dominate if the actual work is very small.  Finding the right granularity of parallel tasks seems difficult to do automatically, so in that respect i agree that it's not trivial."
haskell,3cmc6l,theonlycosmonaut,1 point,Thu Jul 9 14:38:41 2015 UTC,"Well, yeah, it's obviously better that the difficulty of writing parallel programs in Haskell lies in selecting the right Strategy, or perhaps trying something like lvish, instead of dabbling in threads and mutexes."
haskell,3cmc6l,hiptobecubic,6,Fri Jul 10 10:22:04 2015 UTC,Even the manual tools we have like Strategies can be pretty trivial - I managed to change one of my maps into a parallel map in about ten minutes of reading and one line of code.
haskell,3cmc6l,theonlycosmonaut,2,Thu Jul 9 12:50:41 2015 UTC,"To be fair, parallelizing a map operation is one thing the imperative languages can also do easily."
haskell,3cmc6l,kqr,1 point,Thu Jul 9 21:32:12 2015 UTC,"That's true, but they've got to make sure manually that the mapping function is pure/threadsafe."
haskell,3cmc6l,mjmrotek,5,Fri Jul 10 02:38:59 2015 UTC,"Some of the hardest things about parallellism – low level primitives, mutable state/reference semantics, uncontrolled side effects – are a nonproblem in Haskell. That trivialises parallell programming."
haskell,3cmc6l,5outh,2,Thu Jul 9 13:48:45 2015 UTC,"Okay, okay, I guess we are now arguing the definition of ""trivial""."
haskell,3cmc6l,Barrucadu,2,Thu Jul 9 13:57:16 2015 UTC,Everything is trivial once you understand it!
haskell,3cmc6l,mjmrotek,3,Thu Jul 9 17:09:08 2015 UTC,"With strictness analysis, you can infer which arguments to a function are needed (and even how much of them is needed!) and so safely automatically parallelise things that way."
haskell,3cmc6l,nolrai,7,Thu Jul 9 10:56:28 2015 UTC,"Good for you, I guess. It seems to me that, as far as imperative languages go, the only thing I've gained by learning Haskell is gag reflex whenever I see code like  import matplotlib.pyplot as plt %matplotlib inline  plt.rcParams['figure.figsize'] = (10, 10) plt.rcParams['image.interpolation'] = 'nearest' plt.rcParams['image.cmap'] = 'gray'   EDIT:  Okay, as for the downvotes, allow me to elaborate. I have to use Python and Matlab from time to time, as they're the languages of choice among the scientific community which I aspire to join. I'm not sure if programming in Haskell has made me any better in these languages, but it surely has made me painfully aware how limited they are. Dynamic typing is sometimes presented as freeing from the tyranny of the compiler, but in reality it robs me of not only all the toys that make Haskell worthwhile (First and foremost type classes. Not to even mention fancier type system extensions, that for example made the Units of Measure plugin, for which I want to sincerely thank Adam Gundry, because not only it's very useful to me, but it also makes peddling Haskell a lot easier) but also a lot of the documentation. In Haskell, I can often just look at the type of a library function to learn a lot about how it works. Not so much in imperative languages, where for the ""freedom"" of being able to overwrite variables comes with a can of worms containing global variables (It's just painful to see them used where a reader monad would suffice) and thread safety (when in Haskell I only really need to worry about bindings to thread-unsafe C libraries).  Obviously, with some effort it is possible to write in a functional style in these languages, especially because they do support high-order functions, just like it's possible for a Haskell function to launch the proverbial missiles off unsafePerformIO, or a Template Haskell macro to thrash my hard drive and sign me up for ISIS. But the language support and community practices matter. I have to constantly think about things that these languages hide, while Haskell makes them explicit (like the issue of concurrent states /u/TheCriticalSkeptic mentioned). Every now and then I'd run into a library with an outright unfunctional interface. It's an uphill battle."
haskell,3cmc6l,tomejaguar,8,Thu Jul 9 01:53:45 2015 UTC,But that code would look almost the same in Haskell wouldn't it?
haskell,3cmc6l,mjmrotek,8,Thu Jul 9 02:18:21 2015 UTC,"What it looks like is not really the issue.  The problem, as far as I can tell, is that it is modifying some global state."
haskell,3cmc6l,tomejaguar,7,Thu Jul 9 07:23:17 2015 UTC,"Well yes, I thought that is obvious. Also the use of strings to select the fields, and name the color and the interpolation method."
haskell,3cmc6l,mjmrotek,3,Thu Jul 9 08:30:07 2015 UTC,"I thought that is obvious.   It seems it wasn't obvious to /u/nolrai.   Also the use of strings to select the fields, and name the color and the interpolation method.   Quite right.  Perhaps I'm so caught up in a strongly-typed mindset I didn't even notice it!"
haskell,3cmc6l,Hakawatha,6,Thu Jul 9 09:14:21 2015 UTC,"I think there's a significant difference between the code above, and for example using the Chart library:  renderableToFile (def & fo_size .~ (10,10) & fo_format .~ PNG)   $ def & layout_plots .~ [ toPlot $ def & plot_points_style .~ (def & point_color .~ gray) & plot_points_values .~ vals]   Haskell version has thread safety (because threads are there to use them, not to constantly worry about whether the libraries you use are thread-safe), detection of errors at compile-time instead of using strings to select parameters, things like that.  EDIT:  info = def       & fo_size .~ (10,10)       & fo_format .~ PNG  plot vals = def            & plot_points_style .~ (def & point_color .~ opaque gray)            & plot_points_values .~ vals  renderableToFile info $ def & layout_plots .~ [ toPlot $ plot vals ]   There, is that better?"
haskell,3cmc6l,mjmrotek,22,Thu Jul 9 02:33:20 2015 UTC,"In all fairness to the imperative people, though, this is substantially uglier and much less readable."
haskell,3cmc6l,edwardkmett,8,Thu Jul 9 04:41:38 2015 UTC,"It looks better when properly indented rather than written as an one-liner, but I admit you do have a point. However, I'd still take a nice and safe language with syntax that can make Perl shy, over one that can make my program crash long after it started, and has some important data in memory just because I mistyped a string somewhere, or didn't figure out that plotting is somehow not a pure action and two threads will happily mangle each other's settings, thank you very much.  EDIT:  Also, this is legal Haskell too, and no different in the end result than the above method:  build l = execState l def  layout vals = build $ layout_plots .= [toPlot plot]  where    plot = build $ do      plot_points_style  .= gr      plot_points_values .= vals    gr = build $ point_color .= opaque gray   main = do       ( ... )       renderableToFile info $ layout vals   where info = build $ do                   fo_size .= (10,10)                   fo_format .= PNG   ;)"
haskell,3cmc6l,mjmrotek,6,Thu Jul 9 05:08:53 2015 UTC,You can replace build with def &~ if you want something in the middle.  plot = def &~ do   plot_points_style .= gr   plot_points_values .= vals   and  plot = def     & plot_points_style .~ gr    & plot_points_values .~ vals   are interchangeable (for non-type-changing lenses)
haskell,3cmc6l,edwardkmett,3,Thu Jul 9 07:51:06 2015 UTC,"Thanks, I didn't know about (&~).  But I posted that as a curiosity really, I think the style with &'s at the left is clear enough."
haskell,3cmc6l,Peaker,3,Thu Jul 9 07:58:50 2015 UTC,"(&~) started as a thought experiment. We at first thought we might be able to replace the need for separate .~ and .= operators and the like by using it to open a do block, but once we got more than an hour or two into the enterprise we realized that of course the lack of type-changing-assignment killed this goal."
haskell,3cmc6l,edwardkmett,1 point,Thu Jul 9 08:40:16 2015 UTC,Indexed monads and indexed state by default could have been nice.
haskell,3cmc6l,physicologist,1 point,Thu Jul 9 20:56:47 2015 UTC,"The main problem is the 2-parameter version of indexed state is what you want here, but it is the less expandable version than the 1-parameter version, so alas, it isn't a clear cut win."
haskell,3cmc6l,tomejaguar,6,Fri Jul 10 00:22:21 2015 UTC,"In a bit of fairness to matplotlib, the code above is rather unidiomatic usage.  While not quite as rude as sprinkling unsafePerformIO throughout your code, it reads to a regular matplotlib user as comfortably as a Haskell user seeing  foo :: IO [IO (IO Int)]   Now, I'm not saying that mjmrotek hasn't seen code like this.  I'm in the scientific community as well and have seen some horrors (e.g. a professor who still uses his first edition copy of K&R to point out ""mistakes"" in code that follows the ANSI standard).  I just have a fondness for the matplotlib library which doesn't have to be that ugly."
haskell,3cmc6l,physicologist,7,Thu Jul 9 14:32:43 2015 UTC,Please let us know what your idiomatic alternative is!  It's hard to benefit from your comment without it.
haskell,3cmc6l,mjmrotek,4,Fri Jul 10 09:03:52 2015 UTC,"Very good point.  The more idiomatic approach I've seen would be long the lines of  import matplotlib.pyplot as plt from scipy.misc import imread  #Load an image to give context to method calls image = imread(""foo.png"",flatten=True) plt.figure(figsize=(10,10)) plt.imshow(image,interpolation='nearest',cmap='gray')   For those not familiar with matplotlib, the original code was setting a global variable that would change the colour map and pixel interpolation for every plot in the rest of the program.  That's the biggest reason why it burned to read that code.  The above version only changes the figure being drawn and does not touch the colour of any future plots.  We've also moved to having proper function arguments, instead of dictionary keys, so python will throw an error if you type fgisize instead of figsize.  Now, the fact that we're using a string to declare out interpolation method is a travesty and I'm not going to pretend otherwise.  The colour map is a bit more complicated.  I've worked on a program that required that the user could define and name new colour maps at runtime, so it's not as simply as being able to enumerate via a data type.  I'm not saying that strings are the right choice here, but the solution isn't as trivial as it might first appear."
haskell,3cmc6l,physicologist,3,Fri Jul 10 20:58:15 2015 UTC,"I don't want to sound as if I were speaking from some high horse, as I know this was designed to make interactive plotting easier, which is admittedly much more awkward in GHCi (though this discussion prompted me to work on a more plot-friendly interactive shell, wish me luck), but mixing plotting and IO like that is just plain wrong. In Haskell, you first assemble the plot and it's parameters, then put in on a layout, render it, and only the last step (writing it to a file, outputting to screen) requires IO. And that's the only way this could be written, because any haskeller would call bullshit on a function of the form  data -> IO plot   when it's clear that absolutely no IO is to be done at this point. It may seem convenient just to have the figure passed around implicitly, but have fun debugging this if you ever decide that you need more threads* in your program. Find every single use of matplotlib in your code, make sure that figures are passed explicitly, and pray to Guido van Rossum that these functions won't fight for some other implicit state? (which they apparently still are going to do, at least I don't know if there's a way to supress using the global current figure). Same thing goes for Matlab (except that in that case no one's going to have problems with concurrency, as to my knowledge it isn't even possible).   The colour map is a bit more complicated. I've worked on a program that required that the user could define and name new colour maps at runtime, so it's not as simply as being able to enumerate via a data type. I'm not saying that strings are the right choice here, but the solution isn't as trivial as it might first appear.   Why not just use a dedicated type for colours, like Data.Colour does?   (*) It's not some edge case that I've pulled just to have a go at Python (or Matlab). I'm currently writing a program that spawns new threads to read and/or process data from GUI callbacks, so that they don't interfere with either themselves or the GUI. After a thread is done processing, it draws a chart and puts it in a TVar for the GUI to read in its own time. Of course I could set up sort of a queue for plots to be drawn in a single thread, and send the IO actions there a'la postGUIAsync from the Gtk binding, but why on Earth would I have to do that?"
haskell,3cmc6l,mjmrotek,3,Fri Jul 10 22:10:03 2015 UTC,"Oh, I know your pain.  Back during my thesis, I wrote a concurrent program with Matplotlib and handling the threads took quite a bit of discipline and care that Haskell would have handled for me.  As for just using a dedicate type for colours, there's two bits to it.  First, on the pedantic side, the parameter doesn't take a colour, but a colour map.  The reason that I bring this up is the second part, that even in Haskell, you wouldn't want this to just be a data type.  Rather, you'd want something like  (Num a) => a -> Colour   And then have Data.Cmap.grey just be a function.  That would be the proper way to handle it in either language.  It'd still kill some neat tricks I pulled in the past (e.g. using python reflection to make a labelled list of all defined colour maps), but I think it's better than just a data type or a stupid string.  Finally, best of luck with your GUI library. Honestly, even with its problems, matplotlib is the biggest reason I keep coming back to Haskell.  It's amazing how many plotting utilities don't have something as fundamental as imshow.  Actually, given my explorations into other plotting packages, it's disturbing how many utilities can't even handle errorbars or a log axes."
haskell,3cmc6l,physicologist,3,Fri Jul 10 22:51:45 2015 UTC,"Finally, best of luck with your GUI library. Honestly, even with its problems, matplotlib is the biggest reason I keep coming back to Haskell. It's amazing how many plotting utilities don't have something as fundamental as imshow. Actually, given my explorations into other plotting packages, it's disturbing how many utilities can't even handle errorbars or a log axes.   Thanks. You mean to Python? Yeah, in Haskell one would probably have to hack something up with Diagrams.TwoD.Image and then, if needed for any reason, glue it together with a Chart by using the Chart-diagrams backend. Though Chart at least does support errorbars and log axes ;)"
haskell,3cmc6l,tomejaguar,2,Fri Jul 10 23:50:16 2015 UTC,"I need to go to bed.  Yeah, I meant coming back to Python.  Thanks for the link to the TwoD.Image library.  Somehow I missed that the last time I played with Diagrams.  I'll really need to give that a look."
haskell,3cmc6l,physicologist,1 point,Sat Jul 11 00:16:05 2015 UTC,When you do plt.figure what does that apply to?
haskell,3cmc6l,mjmrotek,2,Fri Jul 10 21:46:23 2015 UTC,"plt.figure applies to the current figure, which is an ugly little bit of state hidden inside the plt module.  You can create explicit figure objects, but that doesn't seem to be the standard approach in most code I've encountered.  To try and give a bit of translation, if this had been a haskell API, it would have looked something like this:  main = do   image <- imread ""foo.png""   plt $ do     figure defaultFigure{figsize=(10,10)}     imshow defaultImage{interpolation=Nearest,cmap=Gray} image     show"
haskell,3cmc6l,physicologist,2,Fri Jul 10 22:02:10 2015 UTC,"For the record: I've been playing around with Google's Deepdream recently and with Caffe in general, the code in my post is copied verbatim from the Caffe tutorials.  I understand that in this particular case it's just a quick-and-dirty demonstration code, but the thing is, Haskell actively discourages writing like this even in throwaway programs. If you want mutable state you have to use a monad, if you select something from a (hash)map you get a Maybe result by default, etc. And because quick-and-dirty programs can often evolve into larger ones, or at the very least influence the style of both the writers and readers, it think Haskell's right.  EDIT:  Your IO [IO (IO Int)] type kind of reminds me of a talk by Gabriel Gonzalez, about 36 minutes in. It's not necessarily that hairy! ;)"
haskell,3cmc6l,cie7kei,1 point,Fri Jul 10 10:16:04 2015 UTC,"That's... I have no comeback to that.  That is some ugly, ugly code write there in a high profile tutorial.  There are no excuses here."
haskell,3cmc6l,ocramz,1 point,Fri Jul 10 21:07:13 2015 UTC,"I wonder if your code is open source, sounds like a beginner could learn a lot from it. I still struggle a bit at fitting parts together in Haskell."
haskell,3cosdl,evohunz,11,Thu Jul 9 15:52:06 2015 UTC,"Most people find Applicative easier to learn and use than Arrow, and Applicative + Category is essentially equivalent to Arrow + Category. Why do you want to use Arrow instead?"
haskell,3cosdl,yitz,3,Thu Jul 9 16:11:34 2015 UTC,"How much ""essentially equivalent""?  Also, any Applicative+Category alternative to WAI, then?"
haskell,3cosdl,martingalemeasure,5,Thu Jul 9 17:48:59 2015 UTC,I think they are actually equivalent.
haskell,3cosdl,Crandom,4,Thu Jul 9 20:32:15 2015 UTC,They are exactly equivalent. Generally Applicative + Category interfaces are nicer to use than Arrow-based ones so it's best to go the A+C nowadays.
haskell,3cosdl,SrPeixinho,1 point,Fri Jul 10 17:06:07 2015 UTC,But   Coming next: what about getting Arrow from Applicative?  Are the Applicative axioms powerful enough?  (Hint: no)
haskell,3cosdl,yitz,1 point,Sat Jul 11 18:01:58 2015 UTC,"They are exactly equivalent   No, not exactly. Applicative is a bit more general than Arrow. In part IIa of the post you linked, /u/cdsmith postulated some additional laws for Applicative which he conjectures would allow you to derive the Arrow laws. In that post he derives all except one. Ross Paterson earlier proposed a similar but different set of laws for the same purpose. I don't know if anyone has actually completed this kind of construction, but it seems that it should be possible.  It appears that the required  extra Applicative laws will be reasonable and intuitive, and satisfied by any garden-variety Applicative that you encounter in practice.  Anyway, I have not yet seen any Arrow-based library that could not have been implemented easily, and more simply in my opinion, with an Applicative interface instead."
haskell,3cosdl,yitz,1 point,Sun Jul 12 11:18:11 2015 UTC,"any Applicative+Category alternative to WAI, then?   Stating the obvious, every monad is an applicative. So you can write whatever you want applicatively and just thread through the additional Monad constraint in the types.  More to the point: what do you think you could gain by relaxing the Monad constraint in WAI? Isn't the whole point of an HTTP request-to-response calculation ultimately to send the response out over the wire in IO?"
haskell,3cosdl,singpolyma,1 point,Sun Jul 12 11:29:53 2015 UTC,"Yes and no.  An HTTP request-to-response calculation is to send the response over the wire. But this does not mean that the entire calculation should be an IO action.  All code should do something in the real world, does this means that all code should be an IO value? No.  Arrows (or applicatives, in this case) can yield richer static information about the calculation as they constraint the dynamic nature a bit (no >>= or join equivalent available)."
haskell,3cosdl,singpolyma,6,Mon Jul 13 15:25:46 2015 UTC,Can't you just wrap the monad in MonadArrow and go from there?
haskell,3cosdl,kamatsu,2,Thu Jul 9 17:44:37 2015 UTC,You mean ArrowMonad?
haskell,3cosdl,eegreg,1 point,Thu Jul 9 20:57:43 2015 UTC,"Yeah, whatever the wrapper is called :)"
haskell,3cosdl,tomberek,1 point,Thu Jul 9 22:15:31 2015 UTC,I think singpolyma means Kleisli.
haskell,3cosdl,abaquis,4,Sat Jul 11 01:19:17 2015 UTC,"You shouldn't need an alternative to WAI, but instead build the interface you want on top of it. Arrow-based interfaces have been created, but I think they are focused on continuations rather than REST. Here is a throwback: http://haskell.on-a-horse.org/"
haskell,3cni39,DarkSkyKnight,16,Thu Jul 9 07:33:09 2015 UTC,"I write Haskell all day every day and I use Atom to do it. See an old blog post of mine for some pointers, although I have to say that in Haskell ""automatic indentation"" is something I hate with a passion -- I want to decide my own layout :) Some support with layout is useful of course, as I point out in the blog post. Also, the ide-haskell plugin for Atom is currently under very active development, and works rather well with ghc-mod. I'm currently working with the developer to integrate my own package for cabal support with ide-haskell as well. As a bonus, you can write plugins in Haskell! :)"
haskell,3cni39,edsko,4,Thu Jul 9 10:13:41 2015 UTC,"I wanted to try it out today, but I switched to Stack earlier this week. And Stack support in ide-haskell is still an open issue: https://github.com/atom-haskell/ide-haskell/issues/82  Actually it Stack support first needs to land in ghc-mod (more info in the above link)."
haskell,3cni39,cies010,2,Thu Jul 9 12:37:50 2015 UTC,In the meantime you can use the two hdevtools plugins which work with stack.
haskell,3cni39,ranjitjhala,1 point,Thu Jul 9 16:46:36 2015 UTC,Thanks for the heads-up. I'll check 'm out. :)
haskell,3cni39,cies010,3,Thu Jul 9 17:14:20 2015 UTC,Big +1.  I completely switched to Atom from Sublime now. I'm not looking back.
haskell,3cni39,mallai,2,Thu Jul 9 13:18:17 2015 UTC,"After reading your comment, I tried atom out -- I love it, it's possible that I'll switch from emacs. As I found it easily customisable, I tried out writing a package I missed: https://github.com/kaeluka/atom-haskell-hoogle  It was very easy, documentation was mostly excellent and so is atom's support for writing packages. Due to that, it took me only a few hours from start to publish -- and I've neither written javascript nor coffeescript before. I'm impressed!"
haskell,3cni39,everybodyhatesclowns,1 point,Sun Jul 12 19:40:48 2015 UTC,"I love atom as well. The ease of package installation and update, and ability to write plugins are two reasons why. Since haskell modules are typically small, the fact the Atom doesn't handle very large files seldom bothers me."
haskell,3cni39,martingalemeasure,1 point,Thu Jul 9 13:24:43 2015 UTC,I am using Atom on Windows and it works. Unfortunately I cannot make it work on Ubuntu GNU/Linux.
haskell,3cni39,vitalijzad,14,Thu Jul 9 14:11:39 2015 UTC,I use vim but training is required.
haskell,3cni39,j0sejuan,2,Thu Jul 9 07:45:38 2015 UTC,"It sure does, but I found https://github.com/begriffs/haskell-vim-now to be an excellent default setup. The tool setup pretty much everything by itself.  Of course my typical Haskell workflow is type in one terminal with ghci opened in another so I'm not the most demanding user but it's worth checking out for newbies."
haskell,3cni39,pyskell,1 point,Thu Jul 9 22:14:15 2015 UTC,Same here.
haskell,3cni39,andrewthad,9,Thu Jul 9 13:08:20 2015 UTC,Emacs of course :)
haskell,3cni39,jsantos17,15,Thu Jul 9 16:48:48 2015 UTC,"https://github.com/syl20bnr/spacemacs  Minimum hassle, little to no configuration required, even better than Sublime. Get the best of both worlds (emacs for best Haskell support, vim for a usable editor)."
haskell,3cni39,mochamocha,5,Thu Jul 9 07:47:24 2015 UTC,"I think Haskell support is rather minimal. Enough for an editor (which is the question of the OP), but not very IDE'ish.  I'd like to try out stack-ide's stack-mode, as I have move to Stack. But stack-ide depends on GHC 7.10 which was never used for LTS releases and I wonder how much trouble I get myself into upgrading my projects to 7.10 (and stackage nightly) just to try out stack-ide.  I'm really interested though the have my editor's Haskell mode understand my projects because they build on top of the same tool: Stack."
haskell,3cni39,cies010,5,Thu Jul 9 12:43:35 2015 UTC,"I use Sublime myself, and never have indentation issues...   Are you using SublimeHaskell? Do you have it set to convert tabs to spaces? GHC has... not the greatest tab handling, it's best to have no tabs in your source files."
haskell,3cni39,tejon,3,Thu Jul 9 08:58:54 2015 UTC,Could you elaborate on GHC's poor tab handling? I use tabs for indenting without much trouble...
haskell,3cni39,absence3,2,Thu Jul 9 09:03:13 2015 UTC,"ghc hard wires a tab stop at 8, so if your editor says different, you see the file differently to ghc.   There are plenty of stack overflow questions which are resolved by using tabs instead of spaces.   If you set your editor to indent by inserting the appropriate number of spaces, you can't have a misunderstanding between it and ghc."
haskell,3cni39,_AndrewC_,1 point,Thu Jul 9 16:26:49 2015 UTC,"The space character is usually quite thin in the fonts I use, so I prefer wider indents than most people. When indenting with spaces you can't easily adjust indentation width."
haskell,3cni39,absence3,2,Fri Jul 10 00:40:33 2015 UTC,"I'd always recommend fixed width fonts for programming, but if you're using variable width fonts then I'd switch my advice for you to use tabs exclusively for indentation!"
haskell,3cni39,_AndrewC_,2,Fri Jul 10 05:32:14 2015 UTC,"The problem is that GHC assumes 8-character tab stops. If your editor sets them to anything else, and for whatever reason you wind up mixing tabs and spaces, it's very easy to wind up with indentations that look right on your screen but break when passed through GHC. The official position on tabs now is, ""don't."" There's even a compiler warning when a file contains them."
haskell,3cni39,tejon,1 point,Thu Jul 9 16:32:24 2015 UTC,Perhaps GHC should warn about mixing tabs and spaces instead then? All my cabal files have to disable that warning now :|
haskell,3cni39,absence3,3,Fri Jul 10 00:42:07 2015 UTC,"Ah, I didn't use the plugin. I thought Sublime fully supports Haskell out of the box. Thanks!"
haskell,3cni39,hvr_,2,Thu Jul 9 09:22:45 2015 UTC,"GHC has... not the greatest tab handling   That's not a fault of GHC, but rather a result from following the Haskell 2010 specification!  Quoting HR2010 / 10.3 Layout:    Tab stops are 8 characters apart. A tab character causes the insertion of enough spaces to align the current position with the next tab stop.    If you can't configure your editor to follow that for .hs files, I'd rather argue your editor doesn't have ""the greatest tab handling"" ;-)"
haskell,3cni39,tejon,1 point,Fri Jul 10 06:46:05 2015 UTC,"""Can't"" is not the issue. ""8 character tabs are an abomination I refuse to endure"" is more the crux of the matter. :) You're right that GHC shouldn't be blamed for an upstream spec, though on the other hand a tab size override option seems trivial to provide.  However, I'm of the opinion that ""don't use tabs"" is actually the better answer considering both the semantic rules and stylistic tendencies of indentation in Haskell."
haskell,3cni39,Syzygies,1 point,Sat Jul 11 01:04:34 2015 UTC,"I too use Sublime for everything. (I tried to instead master Vim. I never got over the feeling that I was working through a periscope.)  One needs to master enough Python 3 to customize Sublime for whatever one does frequently. There's  a huge advantage to the same editor for everything; a custom Haskell environment only makes sense to me if ""everything"" is 95% Haskell, which is not the case for me."
haskell,3cni39,ttt72,5,Sat Jul 11 15:08:03 2015 UTC,"Although I prefer vim for common programming, I still suggest you use emacs rather than other editors. There's several Haskell-like and ML-like languages, such as Idris, Agda, Coq, ATS, properly supports only emacs."
haskell,3cni39,davidchristiansen,3,Thu Jul 9 14:34:49 2015 UTC,idris has a great vim mode
haskell,3cni39,gracjan,1 point,Thu Jul 9 15:04:28 2015 UTC,"The Atom mode for Idris is also quite good. Emacs is still the best, but Atom is catching up quickly."
haskell,3cni39,YoureTheVest,4,Fri Jul 10 11:34:07 2015 UTC,https://github.com/haskell/haskell-mode
haskell,3cni39,RnMss,3,Thu Jul 9 16:48:08 2015 UTC,Is Yi still a thing?
haskell,3cni39,chrisdoner,1 point,Fri Jul 10 01:19:23 2015 UTC,"I'm using OS X, and after tons of trying, I still can't get Yi built. (T_T)"
haskell,3cni39,Peaker,6,Sat Jul 18 09:39:55 2015 UTC,"If you use hindent then you can just write   x=do{let{x=1;y=2};return(case x of {1->();_->3})}   and hit M-q (e.g. in Emacs) and get  x =   do let x = 1          y = 2      return (case x of                1 -> ()                _ -> 3)   I've been pondering recently that I might write a much simpler structured-haskell-mode which pre-supposes hindent (as it was originally written a year or so before hindent) and lets you write and edit in the former fully explicit style when you put your cursor there; it'd have some key to convert to ""explicit style"", because fully explicit delimiters are much much easier to manipulate/edit unambiguously (see Lisp and paredit, unfortunately that Haskell community settled on the prettiest style which is hardest to work with programmatically), and then hit a key to pretty print it in the significant whitespace way as above. Never use the tab key / tab cycle or worry about alignment again.  The downside is that it means to use this method on a declaration you have to ultimately reformat it, which isn't good for contributing to other people's projects that don't use automatic formatting."
haskell,3cni39,chrisdoner,2,Thu Jul 9 10:22:51 2015 UTC,"Is there any built-in style that does not indent based on arbitrary name lengths? e.g: All indents are always multiples of 4?  I tried writing an hindent style once, and was discouraged by what seemed like a lot of work, but if it doesn't exist maybe I should give it another go..."
haskell,3cni39,Peaker,2,Thu Jul 9 12:49:07 2015 UTC,"Sure, the johan-tibell style:  hello = do     let x = 1         y = 2     return         (case x of              1 -> ()              _ -> 3)   Not all lines are indented based on a multiple of 4, like in the let bindings."
haskell,3cni39,conklech,1 point,Thu Jul 9 13:18:34 2015 UTC,"length ""let "" = 4 so it sounds like that invariant should not be broken :)  Perhaps where does break it though?  I do use let without a newline and where with a newline for this reason. Being able to cut and paste stuff without reindent or with simple +4/-4 on the indent is nice."
haskell,3cni39,chrisdoner,2,Thu Jul 9 20:21:34 2015 UTC,"unfortunately that Haskell community settled on the prettiest style which is hardest to work with programmatically   ""Pretty"" is kind of derogatory, don't you think? It's not exclusively an aesthetic concern; the idea at least is that it's easier to read. (Who knows whether that's true.) Programmatic support is of course great for editing, but your eyes don't have programmatic support.  It's a question of perspective. I probably read ten or twenty times as much Haskell code as I write; generally not in a programmatic environment. My interests are probably a bit skewed as a result."
haskell,3cni39,lukexi,5,Thu Jul 9 18:31:13 2015 UTC,"Whitespace significance coupled with Haskell's wealth of syntactic sugar and freedom of layout (or lack of ability to be automatically indented) is aesthetically pleasing but superficially beneficial. I read Lisp code in the wild far better than Haskell code in the wild. “Pretty” is entirely intentional.  Reading a Lisp codebase or Python codebase is like reading a newspaper. Reading a Haskell codebase is like reading the scrawled handwriting of a diary.  I often call Lisp a selfish language for selfish programmers, but one thing it gets right is its syntax (along with Python, sorta). Haskell's syntax is made for selfish programmers."
haskell,3cm68a,enricoschiattarella,4,Thu Jul 9 00:04:42 2015 UTC,"Watching first video. Its very nice that he stops and asks questions through the lecture, very good pedagogical style. Love it"
haskell,3cm68a,mishach,2,Thu Jul 9 05:36:03 2015 UTC,What's the scope of the class?
haskell,3cm68a,jgcoded,4,Thu Jul 9 05:20:42 2015 UTC,"Well, it seems to keep expanding.   Avant, in Chicago, is interested in Haskellizing some of its technology. It's mostly Ruby and R (with some Clojure) and will stay that way for some time; 10-20% market share in a year would be a pretty good showing. We do know that some of our services are going to need to be rewritten in a high-performance language in order to scale, and while Clojure is very elegant (and has a fantastic community) it tends to force a tradeoff between elegance/beauty and performance. You can get one or the other, but it's rare that you get both, just because the underlying platform (JVM) is so janktastic.   Also, I think that Haskell's a much better long-term bet than Java (even with Scala in the mix) for high-performance programming's future, but that's another debate.   Hiring existing Haskell talent can be really tough, so the goal is to train it from within.   Honestly, the course started as an intern course that would be 5 or 6 sessions, just as a way of starting the conversation. Then it grew beyond the intern program because so many engineers wanted to take it. So it became the summer Haskell class. Then we started having outside people in Chicago hear about it and want to sit in. So, at some point, I just decided to put it on Youtube. The video editing is pretty poor (it was done by me, not a professional) but I hope that the information is useful.   It's been a lot of work to build this class (I'm about 1/3 done) but it's been fun as hell.   The ""first half"" is 4 weeks (1 lab, 7 lectures) and will cover enough to get a person to read and write code at a beginning professional level. Not a Haskell expert, but enough exposure to take the language on. The ""second half"" (which begins when I come back from vacation) will be 5-6 weeks, more lab-focused, and cover some of the libraries (e.g. lens, aeson, bench, scotty or snap). I'm still deciding how I want to broach Haskell and the Web: I'll probably use Scotty just because I don't think that I'll be able to learn Yesod or Snap (given all the other things I have going on) well enough to teach them."
haskell,3cm68a,michaelochurch,1 point,Fri Jul 10 00:02:49 2015 UTC,This response should be on the github page readme. I'd put this right under the Lecture videos heading.
haskell,3cm68a,jgcoded,3,Fri Jul 10 04:51:53 2015 UTC,"Specifically, I'd be interested in seeing a syllabus."
haskell,3cm68a,emarshall85,6,Thu Jul 9 12:20:22 2015 UTC,"From the slide deck for lesson #1:  ""Lecture #1 (6/29): Why Haskell, functional programming, ghci. ● Lecture #2 (7/1): User-defined and algebraic data types. ● Lab #1 (7/6): We’ll dissect a whole working program (Dodgy Dice). ● Lecture #3 (7/8): Anon. functions, types in detail. Laziness. ● Lecture #4 (7/13): The Prelude and list functions. ● Lecture #5 (7/15): Type classes I. ● Lab #2 (7/20): File I/O, parsing, creating own type classes. ● Lecture #6 (7/22): Functor, Applicative and Monad.""  For lectures #7 and after, author says:  ""Once we’ve tackled Monad, the language opens up to us. Possibilities include: ● Haskell in the large (cabal, modules). ● Haskell and the Web. ● The lens library. ● Concurrency, parallelism, and distributed computation. ● Generative testing (QuickCheck). Your computer is better at coming up with unit tests/counterexamples than you are. ● High-performance computing in Haskell (vectors, unboxed types, GPU acceleration).""  I have watched lesson #1 yesterday, seems to be very clear and well paced."
haskell,3cm68a,emarshall85,1 point,Thu Jul 9 16:00:35 2015 UTC,Thank you!
haskell,3cmfp8,ForTheFunctionGod,7,Thu Jul 9 01:21:05 2015 UTC,"I haven't used SMT solvers, but otherwise I have thought about this a bit. I think products can be done with extensions already. Something like  {-# LANGUAGE TypeFamilies, DataKinds, KindSignatures #-}  data Product :: [*] -> * where     Unit :: Product '[]     Cons :: x -> Product xs -> Product (x ': xs)  (++) :: Product a -> Product b -> Product (Append a b) (Cons a as) ++ bs = Cons a (as ++ bs) Unit ++ bs = bs  type family Append (xs :: [*]) (ys :: [*]) :: [*] where     Append (x ': xs) ys = x ': Append xs ys     Append '[] ys = ys   Associativity will hold for this type, but commutativity is still only true up to isomorphism. Of course this is still just a linked list memory-wise.  I think for sums you need dependent types. Something like:  data Sums :: [*] -> * where     MkSum :: (n :: Nat) -> (ts !! n) -> Sums ts   Edit: I think sums might also work now, thought I haven't compiled any of this:  {-# LANGUAGE KindSignatures, GADTs, DataKinds, TypeFamilies #-} data Nat = S Nat | Z data Natty :: Nat -> * where     Zy :: Natty Z     Sy :: Natty a -> Natty (S a)  data Sums :: [*] -> * where     MkSum :: Natty n -> Lookup ts n -> Sums ts  type family Lookup (ts :: [*]) (n :: Nat) :: * where     Lookup (x ': xs) Z = x     Lookup (x ': xs) (S a) = Lookup xs a"
haskell,3cmfp8,htebalaka,2,Thu Jul 9 02:07:07 2015 UTC,You could use the singletons library for sums.
haskell,3cmfp8,Crandom,2,Thu Jul 9 11:24:42 2015 UTC,"You could also use Dynamic under the hood of sums. I have some half-baked code for that here: http://hub.darcs.net/mjm/polymorph/browse/src/Data/Polymorph.hs together with partial and total case statements, but the types sometimes get quite hairy and could really use a solver."
haskell,3cmfp8,mjmrotek,5,Thu Jul 9 13:10:22 2015 UTC,"Idris has Control.Isomorphism to define isomorphisms between types of the same size (e.g. between Either 1 1 and Fin 2), but I haven't seen much use of it, though I imagine, with dependent types, it could be used to generalize over these structures."
haskell,3cmfp8,DavidJRHarrison,3,Thu Jul 9 02:14:31 2015 UTC,"That's an interesting idea. Unfortunately one can't make the equalities on (,) or Either hold directly, because they would be inconsistent (since datatype constructors are injective).  One could imagine defining a commutative monoid as a new kind, then making the monoid laws hold via a type-checker plugin (much as the type-nats plugins do, or my uom-plugin does for an abelian group). Then it would be possible to index a datatype by the commutative monoid, but whether that is useful for defining open sums/products is another question... it may be easier to index by a list (i.e. a free (non-commutative) monoid), as /u/htebalaka observes."
haskell,3cmfp8,adamgundry,2,Thu Jul 9 12:26:06 2015 UTC,"You're probably right about scrapping commutativity. Unlike associativity, it would require serious computation and it would be semantically problematic, since one generally wants unambiguous access to the elements of a product."
haskell,3cjo0p,edsko,27,Wed Jul 8 12:57:28 2015 UTC,"One of the things I really love of our community is the immense sense of respect we have for each other as developers and human beings. I'm pretty sure that in any other community this release, which is happening weeks after the initial stack announcement, might have been the perfect ""excuse"" to make it cabal-install-centric, (en)forcing a fracture between people wanting to try out or switch to stack & normal user of cabal install. Even so, WT could have written this post in a cold-war fashion, without even mentioning stack.   I want to seize the chance to thank WT - I interact with some of their devs on a everyday basis and I'm constantly amazed by their professionalism & competence. A big thank you also to all the people hacking daily to make the Haskell ecosystem a better place."
haskell,3cjo0p,CharlesStain,10,Wed Jul 8 16:46:08 2015 UTC,Nice! It's great to see this done thoughtfully and carefully and not as some post disaster emergency bolt-on fix.
haskell,3ck7gv,quchen,4,Wed Jul 8 15:37:01 2015 UTC,"The version I posted earlier (thread) had the slides out of sync with the video, which should now be fixed."
haskell,3ck7gv,eacameron,2,Wed Jul 8 15:38:10 2015 UTC,Absolutely brilliant. I hope to see this as a language extension sooner rather than later.
haskell,3ck7gv,htebalaka,2,Thu Jul 9 21:49:14 2015 UTC,"Nice to see this back. One question I wanted to ask in the previous thread was if using anonymous records with sum types would incur a small performance cost. The slides seemed to state there wouldn't be, but it only compared using a newtyped anonymous record to a regular record. It seems like sum types would complicate things."
haskell,3ck7gv,mallai,4,Wed Jul 8 20:09:56 2015 UTC,"Yes, esp. that this new version removed some previous quirks (e.g., quasi quoters). Apparently, there were some talks about making this into a proper GHC extension."
haskell,3ck7gv,joehillen,3,Thu Jul 9 01:25:33 2015 UTC,"Apparently, there were some talks about making this into a proper GHC extension.   I haven't seen anything on the mailing lists about this. Do you have any links?"
haskell,3ck7gv,mallai,3,Thu Jul 9 05:50:21 2015 UTC,"No, that's just what Nikita mentioned during the Q&A part of the talk."
haskell,3ck7gv,maninalift,5,Thu Jul 9 10:39:02 2015 UTC,"I think it was just a reference to a comment by /u/tekmo in the previous thread. Sorry no link, on my phone  Link: https://www.reddit.com/r/haskell/comments/2svayz/i_think_ive_nailed_it_ive_solved_the_records/cntc09h"
haskell,3ck7gv,Categoria,2,Thu Jul 9 17:47:06 2015 UTC,How is this solution related to Adam Gundry's work that was moth balled (used to be slated for 7.10)? Are they compatible? conflicting?
haskell,3cj4sf,branneman,19,Wed Jul 8 08:58:17 2015 UTC,"The === ligature is the worst thing I've seen in a font. Three-bar equality has a meaning, separate from two-bar. === is just ""sort of more equal, or something... we've gotta ship tomorrow"""
haskell,3cj4sf,Dickferret,16,Wed Jul 8 15:13:26 2015 UTC,"I am very surprised at how rude the comments are in here. Yes, maybe ligatures aren't the solution we're looking for, but with Haskell becoming more alegebraic and more symbolic, it's naive to think we can just keep smashing the same 7 or 8 symbols together in various ways and still consider Haskell readable. I'm not exactly sure how many of you can argue that >=, <>, >>=, /=, etc. are very nice to look at. Currently, there isn't an entirely satisfying solution. Haskell doesn't support unary operators. λ is classified as a alphabetic character. Unicode only allows fullwidth characters, when we are using double width or triple width symbols. I'm not sure exactly how to solve this problem, but I think this is something we should look into."
haskell,3cj4sf,R0sborn,4,Wed Jul 8 17:47:56 2015 UTC,"Haskell doesn't support unary operators.   Any problem with (⊗ x) or (x ⊗)?   λ is classified as a alphabetic character   Oh, I know why :)  Anyway, what that all has to do with ugly ligatures?"
haskell,3cj4sf,tailbalance,3,Thu Jul 9 12:30:36 2015 UTC,I've been using prettify-symbols-mode in emacs to do something similar and I've found it quite helpful after a long day of staring at code.
haskell,3cj4sf,physicologist,2,Wed Jul 8 21:49:12 2015 UTC,"Honestly I prefer the look of ASCII characters over the mess of Unicode turds people always drag out in these discussions. And frankly, I don't want the number of operators to keep increasing and I sure as hell don't want to have to remember Unicode code points or use a special typing system just to do my work."
haskell,3cj4sf,hiptobecubic,1 point,Thu Jul 9 04:34:44 2015 UTC,"I'm not sure it's a problem with many programmers. As programmers like to code and play with abstractions and implementations. It's a very different focus and hence, possibly, the ""rude"" comments. But if you find it problematic, it'll be interesting to see what you come up with."
haskell,3cj4sf,abaquis,1 point,Wed Jul 8 20:50:28 2015 UTC,"λ is classified as a alphabetic character   Why would lambda be more suitable for defining anonymous functions than a slash? It's just a letter that was arbitrarily selected for naming the calculus. I'd rather use it as a variable name like any other letter (as is was equally arbitrarily selected to mean, for example, wavelength in physics).   Unicode only allows fullwidth characters   Well, yeah, I wouldn't mind using ← , → , or ↣ (for Pipes) if they were bigger. Even ↠ for >>= could have its use if it wasn't so unreadable (but its still looks"
haskell,3cj4sf,mjmrotek,8,Sat Jul 11 01:21:14 2015 UTC,"Nice, indeed.  This issue will make me stay with Hasklig though."
haskell,3cj4sf,mosha48,1 point,Wed Jul 8 09:21:52 2015 UTC,"Wasn't this issue closed some time ago? Hasklig is also nice, thanks."
haskell,3cj4sf,Kaligule,1 point,Tue Jul 14 09:31:11 2015 UTC,"Closed but not solved ( for /=) : The font is language agnostic, and /= means something entirely different in Haskell and other languages like C"
haskell,3cj4sf,mosha48,9,Tue Jul 14 12:05:11 2015 UTC,"Instead of ligatures, what are some monospace fonts where the horizontal midline of symbols align? That is, :=, ->, -+, {|, etc should line up."
haskell,3cj4sf,clumsyfeet,29,Wed Jul 8 22:35:05 2015 UTC,Some people just shouldn't touch typography
haskell,3cj4sf,tailbalance,7,Wed Jul 8 11:18:07 2015 UTC,that's mean
haskell,3cj4sf,sambocyn,8,Thu Jul 9 00:45:06 2015 UTC,There is also PragmataPro with examples with Haskell and Agda.
haskell,3cj4sf,noteed,1 point,Wed Jul 8 12:17:39 2015 UTC,the exaggerated differences between lower and upper case make camelCasedIdentifiers much easier to read
haskell,3cj4sf,sambocyn,4,Thu Jul 9 00:43:29 2015 UTC,"I definitely prefer ""Fira Mono (without ligatures):"", at least I know what's going on. Ligatures just make me think harder because I cannot recognize the shapes immediately. I wonder how much time is required to get used to them."
haskell,3cj4sf,mallai,17,Wed Jul 8 13:42:39 2015 UTC,"I'll level with you, man: I hate ligatures. I hate them very, very much.  There's some difference between a ligature and a non-ASCII symbol. → is a symbol that source code emulates with cheapo ASCII art like ->. Ligatures, on the other hand, come out of the pits of Hell itself. They are multiple, independent symbols, smashed together: ﬁ, ﬄ, or æ (try selecting them).  Ligatures were employed by printers out of a misguided sense of aesthetics - or æsthetics, since we're at it. These people, too clever for their own good, either wanted to recreate common-place bunglings in handwriting (& for ""et""), or they had a bizarre wish to conserve ink by, say, reusing the little blot on top of an f as the dot of an i. I fear that people are nowadays trying to revive these awful, dead practices with computers.  Look at this picture. It contains the most egregious examples. There's a ligature for </, for God's sake. One for #[. What's the point of smashing these into one symbol? They're no quicker to recognize and look like display errors. ∈ and ≠, and maybe ≫= for monads (since > and = are not independent symbols in that context) are understandable, but there's ever a great peril in getting carried away and turning the creation of extra symbols into a masturbatory exercise."
haskell,3cj4sf,ForTheFunctionGod,25,Wed Jul 8 10:03:34 2015 UTC,"Why is it misguided? Also, it has nothing to do with conserving ink. It is because it looks prettier   They are multiple, independent symbols, smashed together: ﬁ, ﬄ, or æ (try selecting them).   Yes, there are unicode code points for some ligatures for some reason*, but the way they should be handled is that you editor should automatically render for example and 'i' after an 'f' in a special way, but still keep them as to separate symbols. I am quite sure this is also the way it is handled here, and the reason it is unsupported in so many editors.   I fear that people are nowadays trying to revive these awful, dead practices with computers.   They are not dead practices. Good typesetting has used ligatures since the printing press, and has not stopped. LaTeX has used ligatures since forever.  Out of interest, what is your stance in things like negative kerning between letters like A and V in for example ""AV""? That could be considered a ligature as well. On a printing press you would certainly need a special type to accomplish it. And if removing some whitespace is okay in some contexts, why isn't slightly adjusting the the shape of a symbol in some contexts?  * Sometimes ligatures evolve into actual symbols or letters, like & has become an ""and"" symbol and Æ/æ is a separate letter in the Danish alphabet. In that case it makes sense. I guess it also makes sense if you want to have ligatures in an editor which does not support them, but then I agree with you that it becomes a bit horrible."
haskell,3cj4sf,ismtrn,10,Wed Jul 8 10:51:47 2015 UTC,there are unicode code points for some ligatures for some reason   Their addition was an error. They all are deprecated now.
haskell,3cj4sf,tailbalance,2,Wed Jul 8 11:29:48 2015 UTC,"As I understand it, their addition was not an error.  Quote:   The existing ligatures exist basically for compatibility and round-tripping with non-Unicode character sets. Their use is discouraged. No more will be encoded in any circumstances.   Unicode wouldn't have gained as much traction if it didn't support round-tripping with legacy encodings."
haskell,3cj4sf,sacundim,3,Wed Jul 8 21:00:38 2015 UTC,"Sometimes ligatures evolve into actual symbols or letters, like & has become an ""and"" symbol   This is interesting. I didn't know of ampersand's history. I always thought of it as a symbol.  Thanks for pointing it out."
haskell,3cj4sf,AsymptoteToHappiness,1 point,Wed Jul 8 11:02:52 2015 UTC,"They are not dead practices. Good typesetting has used ligatures since the printing press, and has not stopped.   I don't think they're good typesetting. When printing began, printers wanted to ape handwriting. Therein, ligatures evolved because they were easier and quicker to write, not because they looked good. & is one of the most egregious instances of people not wanting to write ""et"" a thousand times; instead, they just smeared something quick there. Similar things were done with ""db"", where people just made one vertical stroke, or ""tz"", which got welded into a weird-looking glyph because writers were too lazy pick up the pen between letters. All of these practices are understandable, but I reckon that they were transported into the world of typesetting because of traditionalism, not because they aided reading or looked good.   LaTeX has used ligatures since forever.   Latex purposely imitated antiquated printing practices.   Out of interest, what is your stance in things like negative kerning between letters like A and V in for example ""AV""?   I strongly dislike ligatures, but I'm not dogmatic. For me, negative kerning is at the bounds of what's acceptable because it improves readability... but that's just my opinion. Others might have different tastes. At any rate, kerning is different from merging symbols together. Look, again, at the ampersand. It's so jumbled that nobody would ever guess that it's supposed to be an e and a t. ﬁ is similarly wont to confuse people (not in this font; you'd probably need a serif that actually deletes the i's dot)."
haskell,3cj4sf,ForTheFunctionGod,4,Wed Jul 8 12:22:02 2015 UTC,"I think you can have different opinions about different ligatures. Some are good some might be bad. Some, like & are a product of imitating handwriting. I am quite sure fi, fl and ff are sometimes ligatures because otherwise they would look awkward in a serif font, not because of handwriting conventions. I am not sure if ""ﬁ is similarly wont to confuse people""  means that you think the fi ligature is or isn't confusing. I don't think it is. In fact, you have to point it out to people who doesn't know about it before they see that it is there most of the time.  I think it is reasonable that you don't think typesetting should try to ape handwriting (although I don't see a problem in typesetting taking some inspiration from handwriting. Handwriting can look really nice). But there is no way you can argue that the ligatures in question here are based on handwriting. It is quite clear to me that they are made because the author thinks they make programming text look better. So ""typesetting shouldn't ape handwriting"" is not a good argument against them or against ligatures in general I think.   I reckon that they were transported into the world of typesetting because of traditionalism, not because they aided reading or looked good.   I think traditionalism plays a large role in what looks good."
haskell,3cj4sf,ismtrn,2,Wed Jul 8 16:35:25 2015 UTC,"I am quite sure fi, fl and ff are sometimes ligatures because otherwise they would look awkward in a serif font, not because of handwriting conventions.   Serifs were invented to have clean ends on lines chiseled into stone. Using them in print is yet another imitation of prior conventions, which has poor implications for any argument in this thread which depends on them. ;)  But while I personally find them as loathsome as ligatures, I'll make no attempt to assert an objective basis for my aesthetic preferences. The idea that one thing can look good to everyone is just wishful thinking IMO, especially considering how strongly aesthetics can be influenced by culture. Consider the undying popularity of Comic Sans among non-typographers."
haskell,3cj4sf,tejon,2,Thu Jul 9 01:45:29 2015 UTC,Consider the undying popularity of Comic Sans among non-typographers.   And famous Haskellers!
haskell,3cj4sf,htebalaka,3,Thu Jul 9 03:16:14 2015 UTC,"I always disliked ligatures too and never could understand how on earth they are supposed to make anything look better (in logotypes, okay, but never in ordinary typesetting – apart from the issue with serif fonts discussed below).  However, I have to admit that I can't say ligatures are inherently bad – or at least they definitely aren't bad enough to deserve the amount of irrational hatred I feel towards them. I guess I'm just very annoyed with all those people who think they are inherently good and mentally give bonus points to whatever site/book that happens to use them (I think Apple used them in the past, for instance, and maybe even now). I'd also be quite glad if everyone just forgot about ligatures and stopped spending any effort whatsoever on supporting them in various fonts, because once it happens, I'm sure nobody would feel any need to revive them."
haskell,3cj4sf,peargreen,2,Wed Jul 8 21:50:06 2015 UTC,"Similar things were done with ""db"", where people just made one vertical stroke, or ""tz"", which got welded into a weird-looking glyph because writers were too lazy pick up the pen between letters. All of these practices are understandable, but I reckon that they were transported into the world of typesetting because of traditionalism, not because they aided reading or looked good.   Really, we should be drawing a little ox head instead of writing the letter A. And don't get me started on this lower case nonsense."
haskell,3cj4sf,eruonna,0,Wed Jul 8 20:24:06 2015 UTC,"And don't get me started on this lower case nonsense.   Funny that you should mention that! I  am against letter case as it happens! In fact, I regard capitalization as pointless tedium whose minuscule benefits are only appreciated by the sort of neurotic ass-kissers who think that its omission ""disrespects"" the object of a proper noun. A teacher of mine in elementary school was one such... she always beat me when I ""disrespected"" a classmate by not capitalizing his name. Come to think of it... That, coupled with my inability to read those god-damned Fraktur and Sütterlin scripts, probably explains a great deal of my present loathing for typographical trickery."
haskell,3cj4sf,ForTheFunctionGod,2,Wed Jul 8 20:49:18 2015 UTC,minuscule benefits   I see what you did there.
haskell,3cj4sf,eruonna,1 point,Wed Jul 8 21:11:25 2015 UTC,𝕴 𝖈𝖆𝖓'𝖙 𝖎𝖒𝖆𝖌𝖎𝖓𝖊 𝖜𝖍𝖆𝖙 𝖞𝖔𝖚'𝖗𝖊 𝖙𝖆𝖑𝖐𝖎𝖓𝖌 𝖆𝖇𝖔𝖚𝖙. 𝕻𝖑𝖊𝖆𝖘𝖊 𝖊𝖝𝖕𝖑𝖆𝖎𝖓.
haskell,3cj4sf,NihilistDandy,1 point,Thu Jul 9 18:19:15 2015 UTC,TRIGGERED
haskell,3cj4sf,ForTheFunctionGod,8,Thu Jul 9 19:10:18 2015 UTC,"Ligatures can make text more readable, but they are glyphs, not symbols.  Æ and æ are symbols. In many languages they are characters of their own, the same way ß, originally a ligature of ſ and ʒ, is a character. ﬁ and ﬄ are not symbols, and their use in Unicode is discouraged; their codepoints exist for compatibility with obsolete character sets only.  Rendering -> as → may be more readable, but it is also misleading, because those are different symbols. It might cause syntax errors that are impossible to see. It would be better to define (→) = (->), and use input methods for APL symbols instead of emulating them with ligatures.  Ligatures for </ and /> do not have this problem. If you hate ligatures so much, you must think this worse than Hell."
haskell,3cj4sf,Stino_Dau,5,Wed Jul 8 11:34:19 2015 UTC,"I have a low opinion of ß too - and don't even get me started on the long s. It was already discouraged in the beginning of the 19th century, but people still wore fandals and focks to reftaurants in the 1940s.   If you hate ligatures so much, you must think this worse than Hell.   Well... let's not go overboard. If don't hate them that much - if I did, you'd see my 20-page manifesto entitled ""The inky foe of civilisation""."
haskell,3cj4sf,ForTheFunctionGod,2,Wed Jul 8 12:32:10 2015 UTC,"see my 20-page manifesto entitled ""The inky foe of civilisation"".   I would read it."
haskell,3cj4sf,Stino_Dau,2,Wed Jul 8 14:23:50 2015 UTC,"""I have a low opinion of ß too ""  Don't learn German, I guess, since it's a totally standard orthographical symbol there.  Bad news about umlauts, too: they were originally just ""e""s that migrated to the tops of preceding letters."
haskell,3cj4sf,gclichtenberg,1 point,Wed Jul 8 16:50:52 2015 UTC,"Are we referring to the sharp S (eszet), or the small beta character here? If the latter I think we're using the wrong character, lower case beta should not have an even bottom."
haskell,3cj4sf,saudade,1 point,Wed Jul 8 17:40:55 2015 UTC,Sharp S.
haskell,3cj4sf,gclichtenberg,4,Wed Jul 8 20:33:06 2015 UTC,Ligatures are completely fine when they are used properly. They help.  But I agree than 90% ones in this one font under discussion are idiocy.
haskell,3cj4sf,tailbalance,5,Wed Jul 8 11:28:23 2015 UTC,"Well just to add my two cents, I would like programming in Agda more if symbols like ⇒ or ℕ weren't squeezed so much that you either have to squint your eyes to get every last bit of depth of field, or come to terms with having every single other character oversized. And I in general like the idea of using fancy symbols instead of combinations of ASCII characters."
haskell,3cj4sf,mjmrotek,1 point,Wed Jul 8 16:02:36 2015 UTC,I think those symbols come out looking fine in normal sized-fonts as long as you have the DPI to support it. Emacs with agda-mode on my macbook is a lot prettier than emacs with agda-mode on my buddies HP. I think progress can be made in the font department as well as the commodity display hardware department on this front.
haskell,3cj4sf,robrene,1 point,Mon Jul 13 13:32:02 2015 UTC,"I'll level with you, man: I hate ligatures. I hate them very, very much.   Down with W!"
haskell,3cj4sf,alexeyr,2,Fri Jul 10 15:06:28 2015 UTC,"Looks pretty, but It also looks like a good way to make it harder for learners to join the elite club of haskell."
haskell,3cj4sf,stephen789,9,Wed Jul 8 12:13:51 2015 UTC,"Because it's a font, I could presumably install it in my editor and it wouldn't affect anyone else. The same cannot be said for using Haskell's unicode extensions."
haskell,3cj4sf,multivector,5,Wed Jul 8 13:46:57 2015 UTC,"Why? It's just a font, people who don't use it just see the regular ascii code."
haskell,3cj4sf,sjoerd_visscher,5,Wed Jul 8 13:17:27 2015 UTC,"Just don't write a blog and paste the ligatures into the blogposts. It's horrible :(  Same applies to academic papers. Don't do it! Now I have no idea what I'm reading. Ligatures are fine in private, just not out in public."
haskell,3cj4sf,Crandom,6,Wed Jul 8 13:39:20 2015 UTC,"Just don't write a blog and paste the ligatures into the blogposts.   This is not even possible unless your blog uses the ligature-supporting font. The text is not changing when you use this font, just the way the text is rendered. Any other application looking at your text will see e.g. - followed by >—two separate characters."
haskell,3cj4sf,MileyCylon,1 point,Wed Jul 8 13:49:47 2015 UTC,Screenshots. Case in point: this page
haskell,3cj4sf,ExceedinglyEdible,1 point,Wed Jul 8 14:00:30 2015 UTC,I don’t understand your comment…
haskell,3cj4sf,MileyCylon,3,Wed Jul 8 14:43:35 2015 UTC,"They mean that if you screenshot a page of code (who are these monsters, by the way?) it will be illegible to someone not already familiar with these ligatures."
haskell,3cj4sf,NihilistDandy,1 point,Wed Jul 8 20:32:21 2015 UTC,Love the font. Ligatures are interesting. I'm not sure how I feel about them yet. But the font by itself is attractive.
haskell,3cj4sf,eacameron,1 point,Thu Jul 9 17:07:51 2015 UTC,Code example: https://raw.githubusercontent.com/tonsky/FiraCode/master/showcases/haskell.png
haskell,3cj4sf,davidrusu,2,Wed Jul 8 08:58:52 2015 UTC,Is that haskell? that doesn't look like haskell
haskell,3cj4sf,tailbalance,4,Wed Jul 8 11:07:44 2015 UTC,It is not.
haskell,3cj4sf,fruitbooploops,4,Wed Jul 8 11:18:39 2015 UTC,Yea... Since when is => valid in pipes?
haskell,3cj4sf,kuznero,1 point,Wed Jul 8 11:14:40 2015 UTC,Nice effort! Thanks!
haskell,3cjqtr,_skp,7,Wed Jul 8 13:23:27 2015 UTC,I would look at the section on Haskell's async library in Simon Marlow's Parallel and Concurrent Programming in Haskell. I'd then have a read through the rest of the Concurrent section of the book as it's really well written and can be read for free.  http://chimera.labs.oreilly.com/books/1230000000929/ch08.html
haskell,3cjqtr,multivector,1 point,Wed Jul 8 13:51:19 2015 UTC,Thanks for the link. :)
haskell,3cjqtr,Tekmo,9,Wed Jul 8 13:58:49 2015 UTC,You should probably read this post which explains how your Future type can implement Monad.
haskell,3cjqtr,Tekmo,3,Wed Jul 8 14:35:32 2015 UTC,"Thanks! I’ll have a look. I’m also thinking of using pipes, which could be a great use for streaming values to views once bound to my Futures.  EDIT: that is a very good link! I devored all the content! Thanks again!"
haskell,3cjqtr,Denommus,1 point,Wed Jul 8 16:59:39 2015 UTC,You're welcome! :)
haskell,3cjqtr,cies010,13,Thu Jul 9 01:47:29 2015 UTC,FRP is reaching a great maturity point. There are plenty of projects using reflex in production. Rx is based on a less restrictive idea of FRP and is being used by Netflix. Why avoiding it?
haskell,3cjqtr,Denommus,5,Wed Jul 8 15:39:33 2015 UTC,I wonder as well: why you do not want to use the FRP libs out there?
haskell,3cjqtr,hamishmack,1 point,Wed Jul 8 15:48:49 2015 UTC,"Because they’re pretty experimental, basically. And because the documentation are also not that great. :("
haskell,3cjqtr,Denommus,6,Wed Jul 8 16:58:38 2015 UTC,"I find the documentation for reflex quite good, and in case you have any doubt you can ask directly from the developers in the channel #reflex-frp on Freenode."
haskell,3cjqtr,tomejaguar,1 point,Wed Jul 8 17:20:34 2015 UTC,There is a Early Access Program for a FRP book that might be of interest to you.
haskell,3cjqtr,martingalemeasure,2,Thu Jul 9 00:48:09 2015 UTC,"Yeah, I’ve been told about reflex. May you elaborate on your answer? Which subpart of FRP does it use?"
haskell,3cjqtr,agocorona,4,Wed Jul 8 16:59:02 2015 UTC,"It's a classic FRP system that supports both continuous-time and discrete-time semantics.  If you target the browser, for instance, you can use reflex-dom, and your whole DOM will be treated as a reactive Behavior (actually, a Dynamic, a concept that reflex introduces that is a Behavior with an associated Event that is emited every time it changes).  Since your DOM is a Behavior, you can create your front-end composing different Behaviors and Events, instead of dealing with callbacks."
haskell,3cjepy,eckyputr,8,Wed Jul 8 11:16:18 2015 UTC,You should minimally add a README.md explaining what your project does.  Otherwise it's difficult for reviewers to know where to begin
haskell,3cjepy,Tekmo,1 point,Wed Jul 8 15:26:47 2015 UTC,"Hi, I've updated the high level overview of the project here.  I've also added a test to cover ""user's journey"" in here. It's not yet implemented, but I hope it gets the idea about how the application works."
haskell,3cjepy,sclv,5,Thu Jul 9 02:36:53 2015 UTC,"What does your code do? What is the architecture? You'll get better feedback if you point to specific areas and give some structure and context.  Otherwise, people will have to read through the whole repo to understand what's going on at all!"
haskell,3cjepy,L8D,2,Wed Jul 8 15:26:23 2015 UTC,"Hi, I've updated the high level overview of the project here.  I've also added a test to cover ""user's journey"" in here. It's not yet implemented, but I hope it gets the idea about how the application works.  It's a RESTful API created with Scotty. The implementation of this API lies in src folder. The application entrypoint is Lib.hs.  Actually, one feedback that I'd like to get is about whether I architect this application correctly."
haskell,3cjepy,rodrigosetti,3,Thu Jul 9 03:04:48 2015 UTC,"Some things that come to mind when looking around:   You should try to name your modules under some shared namespace. Perhaps Livelog.Lib, Livelog.Types and so on. I recommend separating your import into an ""external"" and a ""local"" block, where the first block contains imports of external/3rd party modules, and the second contains imports for all of the livelog modules. Perhaps even create a third block at the top to contain all of the qualified imports. It might be temporary, but I'd advise against looping and restarting the server on an error. It's best to let your host server/load distributor catch those and restart externally. Try to move each individual route declaration outside of the where block in your controllers. They can be defined at the top level. Instead of this requireUser function, I'd recommend instead creating an additional monadic context which is a reader over the user id. This allows you to express the dependency on the user being logged in more elegantly, but also will clean up some of your handlers."
haskell,3cjepy,NihilistDandy,3,Wed Jul 8 21:32:05 2015 UTC,"Thanks for the feedback.   Instead of this requireUser function, I'd recommend instead creating an additional monadic context which is a reader over the user id. This allows you to express the dependency on the user being logged in more elegantly, but also will clean up some of your handlers.   Can you give a pseudo-code example for this? I don't understand how this is done."
haskell,3cfax3,clrnd,30,Tue Jul 7 13:44:20 2015 UTC,"Not at all a new Haskeller, but I'll ask a question about something that I'm new to: I'm trying to get into reading FP research papers, and they've got this weird notation for proving things that I don't even know what it's called. Is there a good intro to 'how to read this stuff' somewhere? Also, I don't really remember what most of the greek letters are called, and I don't know what they conventionally refer to in these papers, so it makes reading these papers that much more painful."
haskell,3cfax3,semigroup,31,Tue Jul 7 16:24:20 2015 UTC,"The style of these things is ""natural deduction"" (https://en.wikipedia.org/wiki/Natural_deduction) and the rules that are written are typically called ""typing judgments"" or ""inference rules"".  You typically read them ""top down"" as in ""if I know the things above the line, I can conclude the thing below the line.""  In some cases (with type inference) you can try to read ""bottom up"" as in ""if I know the thing below the line, it may well be because the things above the line are the case"".  Types and Programming Languages has a nice introduction to this style.  A few other notes -- there is often a ""turnstile"" (|-). To the left of a turnstile is a context, often called ""gamma"". Think of it as ""a list of terms and their types"". So now we write ""Gamma |- A"" as ""in environment Gamma I know A."" And, ""Gamma, x : A |- B"" as ""in environment Gamma, extended with a variable named x of type A, I know B"".  On greek letters, I sympathize. It is worth it to find and print out a small cheat sheet to the greek alphabet at least at first. The main conventions are that Gamma, and sometimes Delta refer to environments, capital letters to types and lowercase letters to terms. Outside of that, typically a paper will introduce its own notation.  It is also worth knowing the notation for substitution. x[s/n] is ""the term referred to by x, with all occurrences of n substituted for by s"". (with the usual ""capture-free"" conditions)."
haskell,3cfax3,sclv,14,Tue Jul 7 17:32:48 2015 UTC,"As an example of both turnstile and natural deduction style, here's a typing judgement for lambda abstraction      x : A |- E : B ---------------------  |- \x -> E : A -> B   In other words, if we can show that the expression E has type B in an environment where we know x has type A, then the (larger) expression \x -> E must have type A -> B in an environment where that x is no-longer bound."
haskell,3cfax3,tel,4,Tue Jul 7 19:34:20 2015 UTC,"Piggy-backing on /u/sclv's response, this tutorial (by /u/ezyang, IIRC) does a good job of introducing sequent calculus."
haskell,3cfax3,rpglover64,6,Tue Jul 7 18:30:22 2015 UTC,"And if you like that, there's a language where types are specified directly in sequent calculus notation: http://www.shenlanguage.org/learn-shen/types/types_sequent_calculus.html"
haskell,3cfax3,deech,7,Tue Jul 7 20:00:50 2015 UTC,Does this help?  StackOverflow: “What part of Milner-Hindley do you not understand?”
haskell,3cfax3,drb226,4,Tue Jul 7 20:02:43 2015 UTC,"Perhaps Jeremy Siek's blog post, Crash Course on Notation in Programming Language Theory, will help?"
haskell,3cfax3,nonzen,26,Wed Jul 8 02:21:10 2015 UTC,"What is the preferred, canonical, idiomatic way to write a unix command line style utility in haskell? i.e. one which would be used like this:  foo> process-data --flag inputFilePath outputFilePath   There seem to be a lot of different ways to parse the arguments that an executable is given, and several different ways to open a file and read each line of it and then close it (and s/read/write on that).  Edit: answers   parsing command lines: optparse-applicative  dealing with the lines of a text file (which mine will be):  data.Text.IO"
haskell,3cfax3,keithb,27,Tue Jul 7 15:06:32 2015 UTC,"optparse-applicative is probably the accepted best way to parse arguments. It's very nice.  There are several ways to process a file because requirements for that vary. You won't go far wrong using text or somehing based on it (unless the file is binary, in which case you'll want to use bytestring instead)."
haskell,3cfax3,joeyh,3,Tue Jul 7 15:53:35 2015 UTC,What makes it the best way compared to other options?
haskell,3cfax3,fruitbooploops,7,Tue Jul 7 21:10:28 2015 UTC,"It does a lot of the grunt work for you, such as creating help and converting argument types (e.g. converting a particular argument to an Int.)  It's also well documented and easy to get started with.  The standard library includes GetOpt but it does not do nearly as much grunt work.  It works just fine but you will have to do a lot more boring stuff to get it usable."
haskell,3cfax3,massysett,3,Tue Jul 7 23:06:52 2015 UTC,"I think the Hackage description is enough of a proof:  data Sample = Sample   { hello :: String   , quiet :: Bool }  sample :: Parser Sample sample = Sample   <$> strOption       ( long ""hello""      <> metavar ""TARGET""      <> help ""Target for the greeting"" )   <*> switch       ( long ""quiet""      <> help ""Whether to be quiet"" )  greet :: Sample -> IO () greet (Sample h False) = putStrLn $ ""Hello, "" ++ h greet _ = return ()  main :: IO () main = execParser opts >>= greet   where     opts = info (helper <*> sample)       ( fullDesc      <> progDesc ""Print a greeting for TARGET""      <> header ""hello - a test for optparse-applicative"" )   This is one of the moments when i catch myself thinking, ""how can people even do their daily programming without applicative functors?"""
haskell,3cfax3,mjmrotek,11,Wed Jul 8 15:40:54 2015 UTC,"optparse-applicative is what I've used in the past, would recommend."
haskell,3cfax3,PM_ME_UR_OBSIDIAN,10,Tue Jul 7 15:55:18 2015 UTC,I hear Turtle is great:  http://hackage.haskell.org/package/turtle-1.2.0
haskell,3cfax3,keithb,9,Tue Jul 7 15:22:13 2015 UTC,"It might be. But:   turtle is a reimplementation of the Unix command line environment in Haskell so that you can use Haskell as both a shell and a scripting language.   which is almost exactly the complete opposite of what I want to do. I want to write command line utilities in haskell that I can run from a regular shell—and I want to know the preferred, canonical, idiomatic way to do that."
haskell,3cfax3,keithb,6,Tue Jul 7 15:26:58 2015 UTC,"Oh, yeah ok, let me try:  Well for options I'd use optparse-applicative  For IO with text files, text  For IO with non text files, bytestring"
haskell,3cfax3,merijnv,2,Tue Jul 7 15:55:50 2015 UTC,Do you mean data.Text.IO?
haskell,3cfax3,Tekmo,2,Tue Jul 7 16:21:00 2015 UTC,"Once you want to go fancier, conduit and pipes are two great libraries for doing streaming IO and stream processing."
haskell,3cfax3,keithb,3,Tue Jul 7 21:09:33 2015 UTC,"are you asking how to write command-line option parsing code? if so i would reccomend docopt or optparse-applicative. the former uses some metaprogramming magic, which comes with it's own paines in the haskell world but works out quite well here i think. the latter is more haskelly in it's style in that it uses combinators to build up a tiny dsl for describing your command line arguments"
haskell,3cfax3,Tekmo,11,Tue Jul 7 16:00:18 2015 UTC,"You can do this with turtle's newly added command line options parsing, which is a beginner-friendly wrapper around the optparse-applicative library.  For the example you gave, you would write:  {-# LANGUAGE OverloadedStrings #-}  import Turtle import Prelude hiding (FilePath)  parser :: Parser (Bool, FilePath, FilePath) parser = (,,) <$> switch ""flag"" 'f' ""Some flag""               <*> argPath ""inputFilePath"" ""The input file path""               <*> argPath ""outputFilePath"" ""The output file path""  main = do     (bool, path1, path2) <- options parser ""A simple program""     ... -- and off you go!   To learn more, you can read the turtle tutorial and specifically the section on options parsing.  For even more details you can read the API in the Turtle.Options module."
haskell,3cfax3,kqr,6,Tue Jul 7 17:03:16 2015 UTC,"So, to be clear, you are suggesting that in order to write a unix command line utility I should pull in a library which implements a whole shell environment? Does that seem right to you?"
haskell,3cfax3,zcleghern,9,Tue Jul 7 18:56:29 2015 UTC,"I think you misconstrue what turtle does.  Turtle does not implement a new shell environment.  turtle just provides Haskell analogs of Unix commands.  For example, there is mv, which is just:  mv :: FilePath -> FilePath -> IO ()   ... and that's it.  There is no magic super-environment that these commands have to be run in."
haskell,3cfax3,satsujinka,3,Tue Jul 7 19:33:19 2015 UTC,Why not? I rarely use 100% of the libraries I include. Sometimes I only use 2% and that's kinda okay.
haskell,3cfax3,zcleghern,23,Tue Jul 7 19:00:51 2015 UTC,What is the practical way to debug running programs? I am writing a game-playing AI and cannot get the alpha-beta pruning algorithm to work. Aside from trace (which was somewhat helpful) what ways do you find useful for debugging?
haskell,3cfax3,pycube,23,Tue Jul 7 16:03:09 2015 UTC,"Have you pulled the alpha-beta pruning algorithm out of the AI?  At least when I was doing an AI (a much simpler one then you are) I built up the AI in GHCI, testing each algorithm and addition separately and then combining. And conversely, if I had an issue I broke down the problem function until I reached the smallest fragment that gave me an unexpected answer."
haskell,3cfax3,massysett,15,Tue Jul 7 17:05:58 2015 UTC,I think this is the advice I need. I've sort of been debugging it from the top down. Duh! I'm using Haskell! No need to do that. Thanks.
haskell,3cfax3,MegaManki,11,Tue Jul 7 17:19:07 2015 UTC,"For an alpha-beta pruning algorithm, you might consider writing QuickCheck tests which compare alpha-beta with plain minimax for small trees. QuickCheck can be used to ""shrink"" test cases until they no longer fail the test, which can be used to produce small examples  which should be easier to debug."
haskell,3cfax3,lambdafool,4,Tue Jul 7 17:27:12 2015 UTC,Don't.  Write pure code and then use equational reasoning or property testing.  I wrote about this here.
haskell,3cfax3,WarDaft,22,Tue Jul 7 23:09:00 2015 UTC,"I learned the concepts of functional programming using the book ""Functional Programming in Scala"". But now that I've become more and more aware of the limitations of Scala as a functional language, I want to dive into Haskell.   As I already know most of the concepts of FP, I just need to know how to translate the syntax from Scala into Haskell. Is there some kind of quick-start guide for intermediate functional programmers I can use?"
haskell,3cfax3,MeanLittleBunny,37,Tue Jul 7 14:27:40 2015 UTC,Stephen Diehl's What I Wish I Knew When I was Learning Haskell is an excellent discussion of Haskell language features for people who already know the basics of Haskell.
haskell,3cfax3,dagit,13,Tue Jul 7 15:22:01 2015 UTC,"https://wiki.haskell.org/A_brief_introduction_to_Haskell  If your experience is anything like mine, once you start digging into Haskell, you'll find you didn't know nearly as much about types and abstraction as you thought you did."
haskell,3cfax3,Quick_A_Distraction,4,Tue Jul 7 15:17:09 2015 UTC,"Scalaz is basically most of Haskell's features ported to Scala. This includes type classes, monads, arrows, lenses and more, you should check it out if you don't want to dive into something so radically different"
haskell,3cfax3,charlieb,3,Tue Jul 7 16:51:32 2015 UTC,"This is now quite dated as it focuses on Haskell 98, but it was good for me coming from a Common Lisp background: https://www.haskell.org/tutorial/  Another great exercise for someone already familiar with FP, but new to Haskell, is to read the Prelude and then, in a different sitting, reimplement the common types and functions (you can ignore the typeclasses to keep it tractable).  The cool thing about the Prelude exercise is that you become more familiar with the stuff that is already in scope, and it makes a nice baseline. By the time you have a decent familiarity with the Prelude, I think you're ready to write some real, but simple, programs.  Finally, the type system in Haskell is hard for beginners, so I recommend reading/implementing typing Haskell in Haskell: http://web.cecs.pdx.edu/~mpj/thih/"
haskell,3cfax3,tibbe,5,Tue Jul 7 15:37:32 2015 UTC,"It's going to baby-step you through concepts you probably already know but if you just look through the index, learn you a haskell is a great lookup for simple syntax/concepts."
haskell,3cfax3,kqr,22,Tue Jul 7 14:52:44 2015 UTC,I'm wondering how I can control laziness better.  When I was even newer to haskell than I am now I wrote a simple physical simulation that would output the positions of each mass for each iteration.  It was running slowly (as I expected) so I profiled it and the memory profile was a giant triangle. I assume this is because it was accumulating all the partial results (the upslope of the triangle) and then evaluating them all at once just before the file write (the downslope).  I looked into how to force the evaluation every iteration but I never managed to get/understand a satisfactory answer. Assume that I only want one file write :)  Conversely: How can I make sure the code I'm writing will be lazy? Is there a test I should use or maybe some static code check?
haskell,3cfax3,edwardkmett,14,Tue Jul 7 15:52:43 2015 UTC,"The best advice I can give (which is not quite sufficient) is to make all your data types strict (i.e. using a ! and also an UNPACK pragma if the field is a small scalar, such as Int) if there's no good reason to do otherwise."
haskell,3cfax3,rpglover64,8,Tue Jul 7 18:47:41 2015 UTC,I've heard this recommendation before. Make your data strict and let your functions be lazy. Are there any arguments behind that?
haskell,3cfax3,chreekat,21,Tue Jul 7 19:04:17 2015 UTC,"Consider a data type like  data Tree k v = Nil | Bin Int (Tree k v) k v (Tree k v)   where the Int is carrying around a size of the tree below you.  As you insert you might bump the counter by one, but you aren't actually changing a machine int by one, you're putting in place a thunk that says 'hey go read the old value add 1 and then replace me with that answer'. As your program runs you'll keep building up more and more of these thunks until someone finally needs to look at the size, e.g. for balancing or because someone asks for the size of the structure.  Those thunks have been sitting there wasting space this entire time, and you now have to go and compute their answer, which takes as long as it takes.  On the other hand, if we switch to  data Tree k v = Nil | Bin !Int !(Tree k v) k v !(Tree k v)   relying on the -funbox-small-strict-fields extension that is on as part of modern GHC versions to fully inline the Int directly into the parent constructor, we're actually getting a machine int, and bumping that counter as part of inserting is now writing to a machine int inside of the Bin constructor. This takes less memory, since we're not randomly leaking thunks in the vain hope of avoiding a simple (+1) at each step.  My recommendation is nowhere near as strong as tibbe's. I tend to recommend unboxing any value of concrete type that you know will otherwise accumulate a bunch of thunks like this.  Next, you'll notice that I also put (!)'s in the sub-trees. Why? Now we can know that the trees below us are already evaluated. This can rather drastically improve the cost of computations that are doing things like searching the tree, because they can know that they'll never have to enter a thunk, do some unbounded amount of computation and come back. They get evaluated when the structure is constructed. This means the initial construction becomes, potentially, more expensive, but the lookup parts of your code later become faster, at the expense of losing the possibility of storing infinite trees. (On the other hand, memoizing size in the node, already cost us infinite trees!)  Finally, I recommend that you sit down and analyze how many thunks will build up in your structure as it changes over time, and if you can't bound it, ask yourself a.) why not, and b.) how you can change it so you know.  The best book for learning how to do this is Okasaki's ""Purely Functional Data Structures"". It is incredibly dense, but it is a treasure trove of ""Hey, I never knew that was possible!"" results that I still mine today. (If you aren't willing to throw money at Amazon for a copy of the book, his thesis is almost as readable, but lacks the Haskell appendix and some later examples."
haskell,3cfax3,conklech,8,Tue Jul 7 22:23:36 2015 UTC,"I looked into how to force the evaluation every iteration   I ran into this problem once (on an assignment for an AI class to implement a time-bounded iterative deepening search; it was not pleasant to debug). The simplest approach (i.e. the biggest hammer) is deepseq. There may be an underlying symptom that this hides, though (e.g. using foldl instead of foldl')."
haskell,3cfax3,bigelow13,12,Tue Jul 7 18:24:11 2015 UTC,"An answer to this question that may be unhelpful yet informative is that you can control laziness better by learning how to write more idiomatic code. :)  In your case, it sounds like you may want to use a strict streaming library like pipes or conduit. Search this very thread for more discussion on the two."
haskell,3cfax3,dukerutledge,5,Tue Jul 7 18:04:13 2015 UTC,"How can I make sure the code I'm writing will be lazy?   In ghci, you can use undefined and seq. f is lazy only if f undefined `seq` ()  produces () rather than an exception. Similarly, try putting undefined into structures like lists. See what happens when you feed these lists to head and tail: [1, undefined]; [undefined, undefined]; (1 : undefined).  (Note that just putting the expression into ghci is different than using the seq test. If you put, say, tail [1, undefined] into the ghci prompt, it'll try to show the resulting list ([undefined]), which fails; but the expression itself doesn't force the result and therefore doesn't throw an exception."
haskell,3cfax3,tejon,64,Tue Jul 7 17:59:47 2015 UTC,"This should be called ""hask anything"""
haskell,3cfax3,cies010,11,Tue Jul 7 16:25:26 2015 UTC,Revenge of the naming convention part heux.
haskell,3cfax3,cies010,10,Tue Jul 7 17:37:31 2015 UTC,Bottoms. Bottoms everywhere.
haskell,3cfax3,MoralHazardFunction,5,Tue Jul 7 20:59:23 2015 UTC,And repeated every 2 weeks :)
haskell,3cfax3,sclv,8,Tue Jul 7 17:40:59 2015 UTC,Some of these QA pairs would also fit really well on StackExchange.
haskell,3cfax3,acow,18,Tue Jul 7 17:41:31 2015 UTC,Why wasn't the functionality provided by the ScopedTypeVariables extension present in the language from the beginning (preferably without the extra foralls)? It seems way more useful than what you get with Haskell98.
haskell,3cfax3,yitz,14,Tue Jul 7 14:50:42 2015 UTC,"Good question! In H98, there is no function that you can write where the type cannot be fully inferred. As such, ScopedTypeVariables is never necessary. The trick back in the days before it was to use asTypeOf to fix types that might need to be pinned down.  With the addition of more extensions, RankNTypes in particular, ScopedTypeVariables became increasingly useful/important."
haskell,3cfax3,cameleon,12,Tue Jul 7 16:17:24 2015 UTC,"And is widely considered a ""safe"" extension, so don't worry about using it."
haskell,3cfax3,drb226,7,Tue Jul 7 17:06:32 2015 UTC,"Requiring explicit quantification makes type signatures noisier and harder to read. The need for ScopedTypeVariables is very rare in practice; my experience has been that almost always, if I feel the need to reach for ScopedTypeVariables, it means that I did something wrong. In those very rare cases where it really is needed, it's not such a big deal to invoke the pragma."
haskell,3cfax3,conklech,13,Tue Jul 7 15:11:30 2015 UTC,"ScopedTypeVariables doesn't require explicit quantification, it just allows it. I'm not sure why it wasn't included initially, but it's pretty conservative: I doubt there are many modules that would break if it was turned on everywhere.  One common use I've found is to have the type variables from a class instance declaration in scope in the functions inside it:  instance C a where   f x = ...     where       t :: [a]       t = ..."
haskell,3cfax3,drb226,3,Tue Jul 7 15:29:16 2015 UTC,You may also be interested in InstanceSigs if you need to get a hold of a universally quantified type variable on an instance method.
haskell,3cfax3,PM_ME_UR_OBSIDIAN,10,Tue Jul 7 20:12:17 2015 UTC,"The need for ScopedTypeVariables is very rare in practice   My experience has been that it's generally not necessary once you're finished writing something, but it's very useful for beginner/intermediate programmers and for when you're just sketching things out and want to be able to pin down intermediate terms using  where clauses or what have you. When you're finished, all the types can be inferred."
haskell,3cfax3,acow,3,Tue Jul 7 17:49:09 2015 UTC,"Ditto. When developing a tricky function, I like to sprinkle type annotations all over the place as sanity checks. Once the function is written, it is usually just fine to remove the type annotations."
haskell,3cfax3,rdfox,15,Tue Jul 7 20:15:28 2015 UTC,"Conduit, pipes. Which one should I learn? Where's the best material to learn it? (I particularly like learning by short examples.)"
haskell,3cfax3,drb226,10,Tue Jul 7 15:52:33 2015 UTC,"I think pipes really benefits from having been refined in parallel with its strong tutorial. Its underpinnings make a ton of sense, and the in-package tutorial walks you through usage. That said, you should also be prepared to deal with conduits because it has a very valuable ecosystem around it."
haskell,3cfax3,OmnipotentEntity,8,Tue Jul 7 17:12:36 2015 UTC,Learn Pipes!  (Unless you're here for Yesod. In which case Learn Conduit!)
haskell,3cfax3,rpglover64,3,Tue Jul 7 17:13:07 2015 UTC,"The two libraries have very similar underpinnings.  It's out of date, but you might be interested in checking out my old series of blog posts: Pipes to Conduits."
haskell,3cfax3,kqr,13,Tue Jul 7 20:18:01 2015 UTC,"I consider myself more or less beyond the absolute beginner stages of Haskell.  I get Monads and Applicatives, I've read and understood Lenses more or less, I've written small scripts, and so on.  But from here, there's a lot of things in Haskell that are still a mystery to me and it's hard to move on from where I'm at.  It's been mentioned elsewhere that Haskell doesn't have very good intermediate level tutorials, and I'm really feeling this.  (Template Haskell?, Various Shakespearian Libraries (and others)?, How do I manage data in a state monad (how do I know if I'm screwing up best practices)?, FFI?, How do I even begin to design a non-trivial program in Haskell (the approach is different from the data oriented approach of OO/procedural world?))  How did you get over this hump?"
haskell,3cfax3,rpglover64,12,Tue Jul 7 17:24:37 2015 UTC,"What I Wish I Knew When Learning Haskell (as /u/lambdafool mentioned elsewhere in the thread) is shaping up to be a great intermediate level... not quite tutorial, but jumping-off point.  Regarding your particular questions (beware, opinions):   Template Haskell Don't worry about it. When you need meta-programming, then come to it, but not before. One useful thing to remember when you do is that you can run Q-monadic expressions at the ghci top-loop with runQ. Shakespearian Libraries Again, don't worry about it (IIUC, you're talking about the Yesod stuff like Hamlet and Cassius). It's documented for when you need it, but unless you're doing web dev, it's not important. If you are doing web dev, there was a good post here a bit ago. Manage data in State I can't really help there (I don't know what you mean), but one thing that helped me was trying to write the same code without State: each function takes an extra parameter (for the ""state"" before it ran) and returns an extra parameter (for the ""state"" after) and you need to ensure that you correctly pass the state along. Once you've done that a couple of times, realize that the State monad just abstracts away that annoying and error prone pattern. How to design programs You still want to be data-oriented. Half the difficulty is picking the right datatypes. You're going to want to design the interface early; that is, the data types and the functions using them. Stub out the functions with holes. Take a look at ""denotational design"" (the best link I found quickly was this, a reddit discussion of a blog post critical of the concept; you can get to the original concept by a short link walk). /u/Tekmo has a lot of good general advice on his blog   You get over the hump by keeping at it."
haskell,3cfax3,kqr,2,Tue Jul 7 18:49:43 2015 UTC,One useful thing to remember when you do is that you can run Q-monadic expressions at the ghci top-loop with runQ.   Ohhh why didn't I know this already? Silly me.
haskell,3cfax3,vitalijzad,2,Tue Jul 7 19:12:46 2015 UTC,"Even better, IO has a Quasi instance, so you don't even need runQ in many cases."
haskell,3cfax3,Crandom,4,Tue Jul 7 20:46:01 2015 UTC,"I'm still slowly getting over that hump, like I expect most Haskell users are. You never really stop marvelling at the fantastic libraries some users are able to create.  But here's how I'm navigating the hump: I write code, as much of it as I can. Whenever I start a new pet project, I think, ""Hey, among all these technologies I've never used... can I incorporate one of them in this?"" and usually the answer is yes. So I do. I hit my head against the wall a hundred times, but I learn out of necessity.  I try to only do one new technology per project too, so I don't get overwhelmed. The latest thing I'm exploring is tables, right after vector. Before that, gloss, and before that wreq and taggy-lens (rare case of doing two new technologies at once, but they fit so well together!). Before those, lenses, and going back even further, blaze, attoparsec and aeson in that order.  There's lots to learn! On my list for the future is, among other things, finding a use for vinyl."
haskell,3cfax3,Total_1mmersion,3,Tue Jul 7 19:14:33 2015 UTC,"I programmed a dson parser and a lot of things clicked during that, and have been clicking since.  Just try to program something ""real-like"", not just a couple of files for a project euler problem, but an actual project, with dependencies and versions and structure and stuff."
haskell,3cfax3,int_index,25,Tue Jul 7 18:17:52 2015 UTC,What IDE should a beginner use? Is there an Haskell-ready Emacs bundle?  Is there a project to localize and translate to other languages Haskell tutorials?
haskell,3cfax3,keithb,9,Tue Jul 7 14:23:36 2015 UTC,Any old text editor and ghcid works pretty well.
haskell,3cfax3,MegaManki,8,Tue Jul 7 16:27:04 2015 UTC,Atom with the ide-haskell package is wonderful and easy to set up. I scrapped my Vim setup in favor of Atom and haven't looked back.
haskell,3cfax3,drb226,11,Wed Jul 8 02:25:14 2015 UTC,Haskell does not have a beginner-friendly IDE (yet). Use your favorite text editor.
haskell,3cfax3,MeanLittleBunny,6,Tue Jul 7 16:16:55 2015 UTC,"Is there a project to localize and translate to other languages Haskell tutorials?   For examples, rather than tutorials, try Rosetta Code"
haskell,3cfax3,ephrion,10,Tue Jul 7 15:10:47 2015 UTC,I hear spacemacs is great.  I use plain Vim though.
haskell,3cfax3,cies010,13,Tue Jul 7 15:18:32 2015 UTC,"You can use FP Haskell Center by FPComplete It's an IDE ""in the cloud"" so you need constant internet access and its free version is a bit limited, but it is the easiest to use Haskell IDE out there. It also supports Vim and Emacs key bindings"
haskell,3cfax3,mallai,10,Tue Jul 7 16:23:50 2015 UTC,And it's a great way to start learning Haskell because you don't have to install anything.
haskell,3cfax3,drb226,7,Tue Jul 7 19:56:18 2015 UTC,"I personally use Emacs with Haskell Mode + Company Mode + FlyCheck + HLint as my main Haskell IDE, it works fairly well if you're willing to tinker with it"
haskell,3cfax3,rdfox,4,Tue Jul 7 16:49:53 2015 UTC,"There's haskell-vim-now which transforms vim into a Haskell IDE. It seems really neat, but if you already use vim for other things, it may not be appropriate."
haskell,3cfax3,edwardkmett,3,Tue Jul 7 19:05:56 2015 UTC,"Good question. Others have recommended FPCompletes online IDE named Haskell Center (as good as no setup time), and Emacs (has quite a learning curve of it's own).  While I have not (yet) tried it myself, I expect there to be an option in between: Atom with ide-haskell. Not as easy as Haskell center, but a lot more beginner friendly than Emacs."
haskell,3cfax3,dagit,3,Tue Jul 7 17:38:17 2015 UTC,Atom is quickly becoming a beginner friendly alternative. I've been using it now for quite some time and I prefer it over Sublime. There are updates almost every day and the quality is rapidly improving.
haskell,3cfax3,edwardkmett,4,Wed Jul 8 03:04:01 2015 UTC,I find Sublime Text to be sufficient. For documentation I'd teach beginners to look stuff up on Hackage & how to use the online interface for Hoogle. I often use http://stackage.org for my hoogling needs.
haskell,3cfax3,ttt72,2,Tue Jul 7 19:58:00 2015 UTC,Until that happens I find that haddocset with Dash or Zeal solves the problem of quickly searching vast oceans of documentation.
haskell,3cfax3,zxamt,25,Tue Jul 7 17:26:32 2015 UTC,"What is the point of having an explicit newbie-friendly thread and then downvoting questions or requests for clarification by new users? (I've seen this happen several times in this post so far.)  Please be considerate and if you see an honest question being downvoted, grip it tight and raise it from perdition."
haskell,3cfax3,yitz,4,Wed Jul 8 09:21:58 2015 UTC,"In threads like these, I find it helpful to load all the comments and sort by new. Otherwise, things slip through the cracks."
haskell,3cfax3,joeyh,5,Wed Jul 8 15:01:56 2015 UTC,The one nice thing about reddit gold is that you get to see things highlighted in blue that are new since the last time you visited the current post.
haskell,3cfax3,Crandom,25,Wed Jul 8 15:38:40 2015 UTC,"Why is target by ghc so big? My code is just:  putStr ""hello\n""   and ghc produces a 1.1M file. I compiles it by ""ghc -O3 main.hs -o main1"". Did I miss something?  Similiar codes in c and ocaml, their targets are just 4K and 16K."
haskell,3cfax3,eaturbrainz,15,Tue Jul 7 14:50:53 2015 UTC,take a look at this stackoverflow answer. It covers a lot about why GHC binaries are big and what you can do to make them smaller.
haskell,3cfax3,rpglover64,22,Tue Jul 7 16:27:41 2015 UTC,"GHC always links in the entire runtime. There is a lot of magic there that you'll almost always want for real programs. I suppose there could be a special HelloWorld mode, but no one has found it valuable enough to implement."
haskell,3cfax3,rdfox,17,Tue Jul 7 15:15:51 2015 UTC,"I don't think the runtime alone is the whole story. I have a program that uses yesod, but doesn't use yesod-auth. But many yesod-auth strings still appear in the binary.  Seems that ghc doesn't eliminate unused symbols when linking in libraries. Wouldn't be surprised if there are unused bits of Prelude or GHC.* in the hello binary, although in the hello case, the runtime (some 770kb of it) does dominate.  Size matters. Large binaries push haskell developers toward making more monolithic utilities, and make haskell less useful for making small unix-style tools. Dynamic linking to haskell libraries might be the final solution though, rather than trying to optimize static library linking."
haskell,3cfax3,martingalemeasure,10,Tue Jul 7 15:46:50 2015 UTC,"Haskell does cross package optimisation, iirc. So some constants and expressions from other packages may get inlined into the compiled form of some packages."
haskell,3cfax3,peargreen,5,Tue Jul 7 16:29:04 2015 UTC,"I suppose there could be a special HelloWorld mode, but no one has found it valuable enough to implement.   Smart-linking is a fairly standard feature in many other languages: only link the functions that actually get called.  Now, I'm guessing that if I talk to the right people, I could volunteer to implement it, but I'm rather much of a Haskell noob myself, even though I'm good with compilers and have some decent FP experience from other languages (Coq and Scala)."
haskell,3cfax3,samwise99,11,Tue Jul 7 19:29:20 2015 UTC,"Haskell noob   Dude, you introduced me to Haskell like, 10 years ago."
haskell,3cfax3,edwardkmett,11,Tue Jul 7 20:52:27 2015 UTC,ghc --make -dynamic Hello.hs   13364 bytes.  strip Hello   12900 bytes.
haskell,3cfax3,dagit,9,Tue Jul 7 17:04:24 2015 UTC,btw. --make is the default now so: ghc --make === ghc
haskell,3cfax3,dmwit,5,Tue Jul 7 19:15:59 2015 UTC,"Additionally, you can use strip (I think cabal does it automatically, by the way) to reduce size to 750 kB.  (And then get it down to 220 kB with upx, but that's cheating a bit.)"
haskell,3cfax3,quiteamess,21,Tue Jul 7 15:55:40 2015 UTC,Is laziness really a good idea?
haskell,3cfax3,FedericoAureliano,34,Tue Jul 7 15:23:12 2015 UTC,"Yes.  Lazy algorithms compose, and may wind up with better asymptotics than the parts from which they are made.  When strict algorithms compose you always pay full price. This is fundamentally antimodular.   I want to design the best possible building blocks once: algorithms that I can pour every trick I know into how to optimize them, algorithms that I'm just barely smart enough to fit all the details in my head. I want to test them, prove them correct and move on to new problems.  Consider a simple example:  take :: Int -> [a] -> [a] take _ [] = [] take 0 _ = [] take n (x:xs) = x: take (n - 1) xs   and  sort :: Ord a => [a] -> [a] sort [] = [] sort (x:xs) = sort ys ++ [x] ++ sort zs where   (ys, zs) = partition (<x) xs   In a strict language if I were to compose  take 10 . sort  I'd pay full price to fully sort the list, when I only care about the relative ordering of the top 10 elements.  In a lazy language the computation of the relative ordering after the top 10 elements is never computed at all. The result has the same asymptotics as a variant of 'quickselect' tuned for this particular problem. Moreover, as the number of elements I take grows to equal or exceed the length of the list I'm sorting my asymptotics smoothly vary between the two extremes.  I was able to put together two algorithms written without knowledge of each other, and get a better algorithm from the result.  In a strict setting, what would you do? Once you realized it was inefficient, instead of using the algorithms you'd already written, you'd go and fuse them together by hand. This requires you to hold in your head all the invariants of both algorithms at the same time, prove that they all hold, and laboriously rebuild everything. You can then ship a fused-together program which has been less well tested, but which doesn't pay this higher cost. You only managed to do so by giving up on code-reuse.  On the other hand we have things like ""tying the knot"" for building up circular structures. In a strict language to make a circular linked list or the like you start off by initializing something with a null pointer and then overwrite it after the fact. This requires this null sentinel value to be an observable thing, and it requires a form of mutation. When we go to define things like letrec in a language like scheme it means that occasionally you'll see these initialization values when there are cycles #fs will just start popping up in your code. In a lazy setting we have a benign form of mutation available to us, thunk evaluation, which is capable of overwriting these things without requiring us to either a.) introduce mutation everywhere in the system and deal with spurious nulls when we're building up cycles or b.) pay a logarithmic factor slowdown to emulate references to avoid mutation.  I know the tradeoffs on the strict side of the equation. They bore me.  Laziness is interesting to me precisely because the bulk of the programmers in the world aren't looking at it. There is still low hanging fruit to be had over here. There are still interesting algorithms to discover. It permits incredibly nice algorithms and data structures that interact nicely with non-determinism while still paying less asymptotically than any pure strict language can.  If what I want is purity, correctness, and reusable code with good asymptotics then laziness follows."
haskell,3cfax3,WarDaft,20,Tue Jul 7 22:42:51 2015 UTC,"Short answer: it forced us to keep the language pure (no side effects) and that has lead to many great things.  Long answer: laziness increases composability of functions. For example, you can write a function that generates an infinite stream and consumers can take just the amount they need, even when that amount isn't known at the start. In other languages you need some new explicit language construct to do this, such as generators in Python.  Laziness also allows data structures to serve as control flow structures. This is especially nice compared to lisp, where you do a similar thing with macros except, there you have to add quote to delay evaluation and it can be hard to get right.  Laziness led us to monads for controlling effects, because in a lazy language to have effectful operations that make sense, you need a way to control evaluation order.  For more about the history of Haskell and the decisions behind it, I encourage you to read this: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/  Edit: Fixed some typos."
haskell,3cfax3,sclv,13,Tue Jul 7 15:50:23 2015 UTC,"For examples of why laziness is good for composability, see the answers to Non-Trivial Lazy Evaluation on StackOverflow."
haskell,3cfax3,lambdafool,6,Tue Jul 7 16:16:15 2015 UTC,There has been a vivid discussion on this topic. Link.
haskell,3cfax3,lleksah15,9,Tue Jul 7 15:49:18 2015 UTC,"Total Haskell noob here. I realise I could have googled most of these and gotten good answers but I think some of the easier questions will help give context to my problem. Thanks for any help!!  1) can I have an n by m mixed type data structure?  2) can I call a function on each row of this data structure and end up with a new data structure made up of the output of each function call (the new rows). As in, give each row as the input to a function and then output a new row  3) can these function calls be performed concurrently or in parallel?  4) can I zip two of these mixed type data structures together?  5) can I unzip two of these mixed type data structures?  6) does Haskell have any libraries for sampling from probability density functions?"
haskell,3cfax3,hdgarrood,7,Tue Jul 7 14:24:17 2015 UTC,"1) Yes. You could have a list of tuples, or other more esoteric options. You generally don't actually want to do this, there are often more clever solutions.  2) Yes. This is trivial for the tuple formulation, just write a function that takes and returns tuples.  3) Both, and they are not the same thing. Concurrently means asynchronously in a non-deterministic model, parallel means using more hardware to split up work and compute a deterministic (IE identical with each run) result faster.  4,5) Yes, but this is better handled by those more esoteric versions.  6) Something like this?"
haskell,3cfax3,conklech,3,Tue Jul 7 15:10:26 2015 UTC,hmatrix provides a mode with statically typed dimensions: http://hackage.haskell.org/package/hmatrix-0.16.1.5/docs/Numeric-LinearAlgebra-Static.html  and repa provides strongly typed matrices as well: http://hackage.haskell.org/package/repa
haskell,3cfax3,sumgy,2,Tue Jul 7 16:15:47 2015 UTC,for #6 have a look at the random-fu package.
haskell,3cfax3,el-seed,10,Tue Jul 7 16:20:26 2015 UTC,"(two questions probably related due to my poor understanding of Monads and Transformers)   I have always found it hard to work with Monads of third party libraries. When I ask questions, the developers may ask 'are you sure this can be run inside this Monad?' and I don't know what to say.  Let's say I am inside Persistent's Monad and I want to invoke another library (maybe calls an external api over the network), what I do need to make sure the other library can be used inside the Persistent Monad?  I recently started using MaybeT for chaining computations that should all succeed together or fail if one of them fails. But it does not give me any error reporting. What  should I be using instead? Is it ErrorT. Also, how can I make sure it can be used with say runDb of Persistent?"
haskell,3cfax3,DoctorProfessorson,8,Tue Jul 7 16:30:03 2015 UTC,"I'll have a go at answering 2). Sorry, this got quite long.  I generally prefer ExceptT to ErrorT, since the latter encourages using String as the type of your errors. I think ErrorT is deprecated in favour of ExceptT for this reason. If you don't need any other monad transformer effects, I would recommend using Either instead, whose Monad instance usually has the behaviour you want.  Regarding running inside other monads, there's a tradeoff to be made. One solution to use Either; that is, a monad which has the ability to throw and catch errors but nothing else. This means it can run pretty much anywhere; you can compose them with functions like (>=>) as much as you want and get an Either error result out at the end. However, you may find you want other features in your monad as well, such as those provided by ReaderT or WriterT or IO. The more of these features you add, the fewer things it will be able to run inside.  I suppose there are two types of effects that monad transformers can provide: those which can't be replicated in pure code, ie IO, and those which can, ie ReaderT, StateT. If you want to ensure that computations in a monad A can be run inside another monad B, it is sufficient to go through each effect and see whether B supports it. For example, IO is easy; if A can do IO, then B will also need to be able to do IO. For the other kind (ReaderT etc), you can look at the function that unwraps that particular layer. Often it will require a value to be passed in; ReaderT requires an environment to be passed in to runReaderT, and StateT requires an initial state to runStateT. In this case, the test is ""can I obtain that value inside B"". So for example, if B has a MonadReader r instance, and A needs access to an environment s, and you can write a function r -> s, then you're good.  Take STM, for example. (I don't know Persistent, sorry). Since STM will often retry transactions, it forbids any IO from happening inside an STM computation. One way around this is to do any IO beforehand, obtain the result, and then pass that into the STM computation."
haskell,3cfax3,kqr,6,Tue Jul 7 17:01:29 2015 UTC,"Answering 1 is difficult. As you may know, Monad isn't really a ""thing"" or even ""type of thing""; its' a class of relationships among things of a given type. Monad allows you to return and bind (>>=). If M is a Monad, and command :: M a you can use do notation to bind a variable, x <- command, so that x :: a within that do block. (Which is ""really"" just a use of >>=.) For beginning purposes, that's all Monad means. It's a mechanism for building values, not running them.  Individual types, such as Reader and State, provide functions to ""run"" values of those types. ""Run"" in this context generally means unwrapping the layer; turning a State String Int into a String and an Int. But that's basically unrelated to their Monad-ness. Other monads, notably IO, can't be ""run""; once you have a value of type IO a, you can never ever turn it into a plain old a.  Mixing expressions of two different monadic types requires different tricks. Perhaps the most common, and one that I think persistent uses, is MonadIO. If you have a value of type IO a, such as callExternalAPI apiParameters :: IO Result, you can use liftIO to turn it into   liftIO (callExternalAPI apiParameters) :: MonadIO m => m Result   So if you're ""in"" a given monad M (e.g. writing a do block of type M a), check whether M is an instance of MonadIO. If it is, you can use liftIO to embed arbitrary IO within it."
haskell,3cfax3,rpglover64,10,Tue Jul 7 18:18:29 2015 UTC,"What are some good options for deployment? I've been trying to set up CI, but I'm using stack and most [all?] options seem to use cabal-install. Maybe more broadly, what does your test, develop, deploy workflow look like and what tools do you rely on?"
haskell,3cfax3,kqr,3,Tue Jul 7 18:19:30 2015 UTC,"It switches all the time, but I use stack ghci to develop locally. I still have a cabal sandbox installed in my app folder so I can get hdevtools to work. I have my app integrated with Circle CI. I originally had it deploying with docker, but deploys took too long so for now I rsync the files and compile on the server. Maybe it's worth trying docker again now that stack is out.   The app is open source so you can check out everything I'm using here. Look at circle.yml, the cabal and stack file, and everything in the bin folder. The Vagrantfile and Dockerfile are probably out of date."
haskell,3cfax3,edwardkmett,9,Wed Jul 8 00:24:03 2015 UTC,"What is the difference between Functor's fmap and Traversables traverse? I for the love of god cannot find this out. The example Tree traverse in the docs just makes use of fmap using its infix <$> operator. Thus, the traverse functions looks like just a complex way of calling fmap to me. I don't see how they are not identical."
haskell,3cfax3,chrisdoner,10,Tue Jul 7 21:27:50 2015 UTC,"Imagine you had this list:  λ> xs = [1, 2, 3] :: [Int]   now imagine you did fmap print over it:  λ> :type fmap print xs fmap print xs :: [IO ()] λ> fmap print xs -- ERROR, but we can imagine the result -- as [print 1, print 2, print 3]   This doesn't actually perform the IO action, it just kinda... sits there as a list of IO actions to eventually be fired. Now imagine you did traverse print instead:  λ> :type traverse print xs traverse print xs :: IO [()] λ> traverse print xs 1 2 3   So in a very hand-wavey way, you can view fmap as ""installing"" the action, but not executing it. traverse will both install it and execute it."
haskell,3cfax3,asthasr,5,Tue Jul 7 21:55:54 2015 UTC,The first thing I noticed from your example was that it illustrates the identity traverse f = sequence . fmap f. Cool.
haskell,3cfax3,ephrion,6,Tue Jul 7 23:05:02 2015 UTC,"Yup, and that's exactly what traverse does in Haskell terms! It first ""installs"" the action everywhere with fmap, and the executes all of them in order with sequenceA!"
haskell,3cfax3,pyow_pyow,12,Wed Jul 8 00:15:44 2015 UTC,"fmap can let you take any function from (a -> b) and apply it to an entire container full of as and give you a container full of bs.  ""Container"" here is potentially misleading as you might have a data type that has a function in it!  data Foo a = Foo { runFoo :: Int -> a }   and yet we can still fmap over it  instance Functor Foo where   fmap f (Foo g) = Foo (f . g)   In fact functions themselves form a Functor  instance Functor ((->) x) where   fmap = (.)   which lets you map over the output of the function.  We can also build more interesting Functors where the 'a's occur in weird positions.  A fun exercise is figuring out how to write the Functor instance for  newtype Cont r a = Cont { runCont :: (a -> r) -> r }   We could change out all of the potentially uncountably infinite results of our function (in the Foo case) with fmap.  On the other hand traverse gives you a bit more power, in exchange for allowing slightly fewer instances it says you can run any action you want, which may have Applicative 'side effects'.  traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)   Since all we know about f is that it is Applicative, we're stuck using a very limited palette of operations to pull this off:  pure   :: Applicative f => a -> f a (<*>) :: Applicative f => f (a -> b) -> f a -> f b (<$>) :: Functor f => (a -> b) -> f a -> f b   This set of operations combined with the laws of Traversable requires you not only 'apply a function to each element a in your container, but to be able to ""line them up"" in an order. If you view the combinators we just gave you (<*>) is the only one that lets you do anything with two fs. and when you apply your action to two different a's in your structure you'll get two f bs you need to deal with. Sticking them together with (<*>) this forms a tree-like structure out of the combinators you are using.  The laws prevent you from using the function on the same element multiple times or from skipping some of the as in your structure, so this enforces that you have to be able to put all the elements in your container into some order and enumerate them.  This is a stronger claim. We didn't know anything about the argument to the function in the Functor ((->) x) instance, but here we'd have to be able to enumerate all the xs in some canonical order, and then build a new function that held onto all the answers in order to even attempt a Traversable ((->) x) instance. At least there it is still potentially tractable, but if you start with the Functor (Cont r) example above, it is a lost cause to derive a Traversable (Cont r) instance.  On the other hand, most of the time we're really dealing with something that is more ""like a container"" and the extra power of Traversable is easy to harness."
haskell,3cfax3,ephrion,4,Tue Jul 7 21:47:32 2015 UTC,"Actually I think of traverse as being fmap but where the mapping function can do something extra. Like map vs mapM, but over applicative instead of monad, and over any traversable instead of just lists."
haskell,3cfax3,int_index,8,Wed Jul 8 09:43:57 2015 UTC,How are databases and external data integrations (i.e. JSON unpacking) generally dealt with in real code?
haskell,3cfax3,p01ym47h,8,Tue Jul 7 15:24:43 2015 UTC,"Libraries!  Haskell has some of the finest and more modular/composable libraries out there.  Data.Aeson is fast as hell, and can generate most boilerplate automatically for you with Template Haskell (if you want to).  And I've used postgresql-simple and loved it.  Then it's just a matter of making toMyData functions and fromMyData functions, which advanced programmers may even automate with some type black magic :D"
haskell,3cfax3,eaturbrainz,4,Tue Jul 7 16:00:07 2015 UTC,deriving Generic and aeson make JSON as simple as:  data MyData = MyData { ... } deriving Generic instance ToJSON MyData instance FromJSON MyData
haskell,3cfax3,Stratege1,6,Tue Jul 7 16:40:43 2015 UTC,"You can trim that down a tiny bit further:  {-# LANGUAGE DeriveAnyClass  #-} data MyData = MyData { ... } deriving (Generic, toJSON, fromJSON)   :)"
haskell,3cfax3,Dickferret,5,Tue Jul 7 21:49:37 2015 UTC,Jesus. That's offensively nice.
haskell,3cfax3,ahoover8,3,Wed Jul 8 01:29:23 2015 UTC,"aeson for JSON. To work with a DB use a client library (such as postgresql-simple for PostgreSQL) or similar.  If you're using a web framework, stick to its preferred way of dealing with DBs."
haskell,3cfax3,chreekat,2,Tue Jul 7 16:11:48 2015 UTC,I like how we gave very similar responses :D
haskell,3cfax3,kqr,7,Tue Jul 7 16:35:13 2015 UTC,"Why aren't there more/any machine learning libraries? Is this a result of implementation being difficult in a purely functional language, or because the crossover between the stats/machine-learning/numerical-optimization and haskell communities just isn't very large? I know about HLearn, but it doesn't seem to be nearly as complete as R and Python machine learning libraries. Also, I don't believe I've seen a single neural networks library, though I am not searching rigorously.  To expound on implementation being difficult: is it simply difficult to be flexible to feature data types given the category theory restrictions? Is it just hard to implement the trickery necessary to do matrix multiplication optimization? Is calling out the BLAS and other optimized linear algebra fortran libraries difficult? I'm definitely stepping into territory I'm not familiar with - how category theory and linear algebra + stats + multivariable differentiation relate - so please forgive my ignorance.  edit: added link to hlearn and last paragraph"
haskell,3cfax3,Ink-Jet,9,Tue Jul 7 17:50:24 2015 UTC,"As far as I know, it's not that Haskell is bad for numerical methods (quite the opposite), but just because the Ancient and Most Respected Custom of the statistics community is to use R and that of the machine-learning community is to use Matlab and Python.  (In a minor example, I needed to calculate a certain correlation coefficient for my MSc thesis, at my advisor's bidding.  After it turned out that no implementation existed for that statistic in anything other than R, my advisor hacked out an implementation in Java one night.  I still have to translate it into idiomatic Java or Scala Real Soon Now and follow up on my promise to open-source the damn thing.)  The Haskell community is disproportionately filled with programming-languages theory geeks, which means it's very probably disproportionately lacking statistics and ML geeks who would volunteer to reimplement major libraries in Haskell."
haskell,3cfax3,sccrstud92,7,Tue Jul 7 21:53:57 2015 UTC,"not so much a library, and certainly not worried about getting perfect performance, but I've recently implemented a Neural Network as a class project. See: https://github.com/Stratege/Coevolutionary-Neural-Network in particular this file implements a multilayer perceptron (for which, in the other files, there is a rather adhoc coevolutionary genetic algorithm defined to train them to play simple games, like TicTacToe or Global Thermonuclear War (I just couldn't resist naming it that, given the topic))  edit: note the lack of category theory being used. It really isn't necessary to get work done, although I suppose it helps at times."
haskell,3cfax3,kqr,4,Tue Jul 7 19:16:26 2015 UTC,"I don't think there are any matrix libraries that implement optimal ordering, but it should be possible to hack in. It'll never be as fast as hand-tuned fortran written by buddhist monks on the moon, but it should help."
haskell,3cfax3,chreekat,7,Tue Jul 7 18:28:20 2015 UTC,I just started reading about Haskell recently. What are some good recently sized projects or problems to work on that will get me familiar with the language?
haskell,3cfax3,sclv,11,Tue Jul 7 16:26:38 2015 UTC,"We at Snowdrift.coop welcome new Haskellers. If you are interested in funding freely-licensed works, then yay! That's what we're trying to do. Our system uses the Yesod Web Framework.  Some links:   Our how-to-help wiki page. Our README."
haskell,3cfax3,el-seed,2,Tue Jul 7 18:11:05 2015 UTC,"Have you worked with other programming languages? Do the same things with Haskell you would do in those!  If Haskell is your first language, here are some ideas: make simple text-based games, create computer-generated animations, convert files of different formats, create some blog software... you're free to do whatever you want! Pick something that sounds fun, and make sure it's something small enough you'll be able to complete it in a few weeks."
haskell,3cfax3,Tekmo,6,Tue Jul 7 21:12:34 2015 UTC,"I'm trying to get into using Haskell for real world applications, but struggling to find information for the more practical side, particularly cabal. Any pointers?"
haskell,3cfax3,kqr,9,Tue Jul 7 18:01:00 2015 UTC,"stack has recently been released as a way to quickly start haskell projects, and was created to get around some of the pain points that cabal-install has. It might be worth checking out."
haskell,3cfax3,AlpMestan,3,Tue Jul 7 18:41:09 2015 UTC,"Though there is certainly much less written documentation about stack, which makes it harder to get started with.  Well, either that, or the name just sucks because I don't find anything on Google."
haskell,3cfax3,conklech,4,Tue Jul 7 19:25:16 2015 UTC,"You probably know this, but for posterity there is a bunch of reading material on the stack wiki."
haskell,3cfax3,klaxion,5,Tue Jul 7 21:32:55 2015 UTC,"If you look in the ""Package and Dependency Management"" section of the documentation page in the new haskell homepage (https://www.haskell.org/documentation) there should be a wealth of pointers."
haskell,3cfax3,evincarofautumn,6,Tue Jul 7 21:06:04 2015 UTC,"How can I get beyond a beginner / early intermediate stage? How can I find a mentor or work with more experienced Haskell developers?  I've been messing around with Haskell off and on since 2011. Only this year have I finally felt moderately productive on my latest project, but I still get thrown completely off balance when I do something outside my comfort zone. For example today I was trying to get ReaderT to work with servant. People totally helped me, but I didn't understand their answers, and had to apply their advice blindly.   As a beginner I read LYAH, followed bitemyapp's guide, and did problems on https://www.hackerrank.com/. What should I do now that I'm an ""early intermediate"" haskeller besides hacking on projects?   I feel like I learn very slowly, and if I were working with a more experienced haskell dev I would learn much faster. Given that haskell teams are rare (where one normally gets this sort of mentoring), is anyone interested in some kind of mentoring relationship? I'm more than willing to pay it forward."
haskell,3cfax3,Bubbasauru,8,Wed Jul 8 00:12:54 2015 UTC,"Build something useful, no matter how ugly it is.  That's the only way to break out of the beginner phase."
haskell,3cfax3,peargreen,7,Wed Jul 8 00:40:51 2015 UTC,"I didn't understand their answers, and had to apply their advice blindly.    Haha. I have done this a lot as I've been learning. When I've used things blindly enough times, when I've parroted enough existing code, I start seeing a pattern and I then understand how it works.  The way I learned to work with lenses was through just rolling a dice on which combinator to use in each situation, and then after a while the dice were right more and more times."
haskell,3cfax3,mishach,6,Wed Jul 8 07:40:47 2015 UTC,"Please, please feel free to use the servant IRC channel or the mailing list and ask questions there! I'll gladly answer them until you understand what's going on and maybe adapt the tutorial accordingly (if you couldn't get it to work initially, that might mean the relevant section of the tutorial could be made more helpful)."
haskell,3cfax3,kqr,6,Wed Jul 8 08:50:50 2015 UTC,"People totally helped me, but I didn't understand their answers, and had to apply their advice blindly.   I'll echo /u/kqr: don't feel too bad about that! The first step to understanding X is knowing that X exists and that you don't understand it.  Knowing that X addresses your problem is a good starting place; now you can look at X more closely, try to figure out why it solves or doesn't solve your problem, what it's called, what other problems it solves, etc.  And anyway, life is full of things we use but don't fully understand. This particular community is pretty idealistic about fully understanding everything, but that's an ideal; you don't have to get there right away, and you don't have to fully understand the same set of things as anyone else."
haskell,3cfax3,Nebu,5,Wed Jul 8 17:04:58 2015 UTC,What's the best way to do FFI with C++? I've heard it's a pain but how much of a pain?
haskell,3cfax3,edwardkmett,6,Wed Jul 8 02:15:34 2015 UTC,"C++ mangles its symbols in order to support overloading, templates, and namespaces. So whereas a C function like int foo(const char*) would be compiled as simply foo, in C++ the symbol name includes type information, e.g., in the IA-64 mangling convention, it would be _Z3fooPKc. You can get the mangled symbol from your compiler and do an ordinary foreign import declaration:  foreign import ccall ""_Z3fooPKc""   foo :: CString -> IO CInt   When I was working at Facebook and we had to interoperate with C++ a lot, I wrote a plugin for hsc2hs that would let you write this:  foreign import ccall #{ mangled int foo(const char*) }   foo :: CString -> IO CInt   They haven’t open-sourced it, though. I could bug them about it or rewrite it—it only worked for IA-64, because we were only using GCC on Linux, but in principle it could be extended to support other mangling conventions.  Interoperating with any of the nontrivial parts of C++ will typically require making some compiler/platform-specific assumptions, too, but generally your interop layer shouldn’t be fancy."
haskell,3cfax3,peterlew,5,Wed Jul 8 02:40:21 2015 UTC,Where can I find the Happstack Book? Every mention I find of it 404's.
haskell,3cfax3,sccrstud92,4,Tue Jul 7 18:03:58 2015 UTC,http://web.archive.org/web/20150329145816/http://happstack.com/docs/crashcourse/index.html
haskell,3cfax3,kqr,4,Wed Jul 8 00:17:07 2015 UTC,What is the best way to learn how to write idiomatic lazy code?
haskell,3cfax3,chrisdoner,4,Tue Jul 7 19:22:49 2015 UTC,Review code by people skilled in it. Studying the masters is a good idea when it comes to anything!
haskell,3cfax3,hnerixh,4,Wed Jul 8 07:24:20 2015 UTC,"There exists a type that has zero values. This wikipedia article offers various names for this type, including ""Bottom"", ""Empty"", ""Zero"". Haskeller sometimes refer to this type as ""Void"". That's fine, I'm not overly concerned with what name we wish to use to refer to that type. Let's just go with ""Void"" for the sake of this particular discussion.  Haskellers often then say that this type has a special value which they call ""bottom"". For example:   http://dev.stephendiehl.com/hask/#bottoms ""The bottom is a singular value that inhabits every type"". https://wiki.haskell.org/Bottom ""Bottom is a member of any type"" https://en.wikibooks.org/wiki/Haskell/Denotational_semantics ""we introduce a special value ⊥, named bottom"" http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/ ""These diagrams are quite good for forcing yourself to explicitly see the bottoms lurking in every type.""   Why is this mental model of how bottom types work so popular? Instead of postulating the existence of some special value, it seems a much cleaner mental model is to say all values are normal, that the Void type truly has zero values, and that undefined is a function whose return type is Void (or Bottom or whatever you want to call it), not because it can magically return a value from a type that is explicitly defined to have no values, but because it does not return: it either raises an exception (as seen in here, where they offer the implementation undefined =  error ""Prelude.undefined"") or it enters into an infinite loop (as proposed here, where they offer the implementation undefined = undefined).  Why isn't this latter mental model more popular in Haskell? Is there some scenario that the latter model fails to explain, but the former model succeeds?"
haskell,3cfax3,fmapthrowaway,10,Wed Jul 8 06:28:00 2015 UTC,"You can work your way through all of the statements folks make in a CPO about _|_ in the vocabulary you are using here. It gets pretty tedious as the problems grow more complicated, however.  The benefit of the _|_ vocabulary is we can simply say that all functions are monotone. That is to say, for something like Bool, we have {_|_, False, True } as inhabitants with _|_ < False, _|_ < True and every function from Bool to Bool is monotone with respect to this ordering. So e.g. if you take _|_ -> _|_ you can do whatever you like for False or True, but if you take _|_ -> True, then you must also take False -> True and True -> True.  Simply stating that all functions are monotone, or more properly talking about functions being ""Scott continuous"" carries with it a lot of meaning about how _|_'s must be treated in your language! You could of course build up all that machinery using a different vocabulary, but you'd lose all the existing terminology and tools of CPOs and the like.  These tools are already well studied in other areas, and let us borrow results from areas like lattice theory, rather than force us to make up terminology and tooling as we go, and it makes it easy to formally talk about things like one function is more defined than another just in terms of reasoning about partial orders.  As a friend of mine likes to say, ""continuity means nothing weird happens at infinity"". A large part of the genius of Dana Scott's original work on dcpos and denotational semantics is that the notion of continuity that he built up is good enough to make a ton of non-trivial problems just vanish. The mappings between any two dcpos themselves form a dcpo, giving us a nice cartesian closed category, so ""it looks like turtles all the way down""  Could you build all of this up explicitly? Probably, but it'd get to be a pain in the ass to actually work with once you started dealing with recursion.   Moreover, you'd have to make up your own vocabulary for everything, and then pretty much anything you published in the field of denotational semantics, nobody would be able to read."
haskell,3cfax3,aflott,4,Wed Jul 8 07:06:25 2015 UTC,What's the deal with Arrays? Why are they faster sometimes and when should I use them?
haskell,3cfax3,radix,6,Tue Jul 7 17:41:33 2015 UTC,"Both Arrays and Vectors provide constant time access to data. They are sometimes faster than lists because to access the 100th element of a list, you have step past the first 99 elements. For Vectors and Arrays, the elements are stored in contiguous memory, and thus can be accessed by computing an offset and jumping right to the 100th element."
haskell,3cfax3,sclv,3,Tue Jul 7 18:38:27 2015 UTC,"And if you're using unboxed or primitive vectors, you don't even have to deal with following pointers to access objects (which can be slow) – the objects are stored directly in the array!"
haskell,3cfax3,kqr,3,Tue Jul 7 19:24:24 2015 UTC,"I made a very modest start on trying to document this. I have to flesh out the other data structures and then was hoping to implement a number of benchmarks in that repo that anyone can clone and run, comparing them all for science and justice. I'd appreciate any contributions to that repo. Only so much time in the day."
haskell,3cfax3,dmalikov,2,Wed Jul 8 09:52:09 2015 UTC,"I assume you mean ""faster than lists"".  This is more of a computer science kind of question, so check out Chapter one in OpenDSA. (The text is somewhat boring, but the demos are nice.)"
haskell,3cfax3,edwardkmett,4,Tue Jul 7 19:28:37 2015 UTC,"Does anyone have an example .emacs file available, with comments/documentation maybe, for setting up both haskell-mode and ghc-mod (or some other type-inspection tool, like hdevtools or ghci-ng) with stack yet? All of these tools move fast, and I don't know of a central place to look for IDE ""news"" besides following the individual projects on github (the serras tutorial at one point seemed comprehensive, but it was written before stack).  I'm new to using emacs, haskell, ghc-mod, and the cabal/stack ecosystem; so far, of the threads I've seen (for instance this) where people discuss their attempts & successes at IDE and haskell tooling, they're all speaking from significant experience with those tools, and seem a bit intimidating to a newbie like me."
haskell,3cfax3,tomejaguar,3,Tue Jul 7 19:36:45 2015 UTC,"Maybe overkill, but with spacemacs my ~/.spacemacs file looks like (snipped for brevity)  (defun dotspacemacs/layers ()    ...    dotspacemacs-configuration-layers    '(      (haskell :variables               haskell-enable-ghci-ng-support t               haskell-enable-hindent-style ""gibiansky""               haskell-enable-company-mode t)      ...     )     ..."
haskell,3cfax3,transitlog,3,Tue Jul 7 21:53:22 2015 UTC,"Just an idle curiosity for me: What is the runtime representation of a value of type IO T? My mental model is basically a struct like {action :: *function, args :: [args], continuation :: *function} where action is a pointer to a low-level side-effecting procedure (e.g. read_line or something), args are the arguments to be passed to that procedure, and continuation is the haskell function + environment that has been bound with >>=.  Is this even close to the truth? Or do laziness and/or compiler optimizations allow the runtime representation to be completely different or non-existent?"
haskell,3cfax3,Tekmo,8,Tue Jul 7 19:45:02 2015 UTC,"The runtime representation of pure and effectful things are precisely the same -- ""thunk"" nodes in the ""g-machine"" (http://stackoverflow.com/questions/11921683/understanding-stg).  Under the hood, an IO a value is represented as a ""state-like"" function #RealWorld -> (#RealWorld, a) where #RealWorld is a  magic zero-width token just meant for book-keeping purposes.  Not sure if that helps or if you're interested at a different level (i.e., the FFI)."
haskell,3cfax3,baconated,2,Tue Jul 7 21:05:09 2015 UTC,"From what I understand, an IO t value is represented as any other thunk, except it does I/O when evaluated. If that is true, your guess is not bad."
haskell,3cfax3,conklech,3,Tue Jul 7 21:30:11 2015 UTC,Is there a connection between void and Void?
haskell,3cfax3,mckennar,11,Tue Jul 7 20:00:39 2015 UTC,"Nope. I had Void in a library, then they decided they wanted to name the combinator in base void by loose analogy to having a function with a void return type in C/C++. This caused a name collision with the combinator I had in the void package, so I ultimately renamed the combinator to absurd.  Ironically, because folks made void only have a Functor constraint rather than a Monad constraint it was more or less useless for its stated purpose for years until the AMP went through."
haskell,3cfax3,ignorantone,3,Tue Jul 7 21:50:12 2015 UTC,Not as far as I am aware.
haskell,3cfax3,ABC_AlwaysBeCoding,5,Tue Jul 7 20:12:50 2015 UTC,"I'm pretty new to Haskell and finding it really hard to do anything really productive in it. I come from an imperative programming background.  I would like to know how long it took you to become proficient in Haskell (if you came from an imperative programming background like me). By proficient, I mean being able to read and understand most Haskell programs, and pretty quickly build yourself a web application using a particular framework like Snap, Yesod or whatever."
haskell,3cfax3,eaturbrainz,3,Tue Jul 7 23:53:43 2015 UTC,"It took me about a couple of months of full-time programming to get to the point where I considered myself proficient.  I came from a C background, which is about as imperative as it gets."
haskell,3cfax3,sclv,2,Wed Jul 8 00:39:56 2015 UTC,"Why can't multiple records have a field with the same name?  To me this feels like if two Java classes couldn't have the same private instance variable name. Or if two hashes/maps couldn't use the same string as a key.  I'm probably thinking about records wrong, but this just doesn't make any sort of sense."
haskell,3cfax3,radix,4,Wed Jul 8 15:43:06 2015 UTC,"There's not a deep reason; it'd just make a name collision. A datatype data A = A { a :: Int } also creates a function a :: A -> Int. Making a second record, data A' = A' { a :: Int} leads to two different functions named a, which isn't permitted.  There's been work on ""fixing"" that problem in one way or another for years; it might happen soon, but it'll involve a little bit of added complexity. My usual approach is to use either lens-style HasA typeclasses or vinyl extensible records."
haskell,3cfax3,_skp,4,Wed Jul 8 16:20:07 2015 UTC,"I think this thread was a great idea; hopefully I'm not too late to the party.    I think the deriving keyword is pretty awesome, and I saw here (https://en.wikibooks.org/wiki/Haskell/Classes_and_types) that you can derive Eq,Ord,Enum,Bounded,Show, and Read.  (1) How is that implemented?  But there are other typeclasses that (can) have trivial implementations, for example NFData and Arbitrary.  (2) Why isn't the same deriving functionality provided for those?  I've seen Foldable, Traversable and (I think) Monoid being derived in some cases - (3) what makes these possible?"
haskell,3cfax3,tactics,3,Thu Jul 9 15:31:58 2015 UTC,"As far as question #1 goes, if you sit and think about it for a while, you can probably figure out some of it yourself.  I would say that Eq, Ord, Enum, Bounded, Show do the 'obvious' thing once you state the rules for the type class, e.g. for Ord, constructors declared to the left are < those to the right.  Eq makes sure that the constructors match, and if that constructor takes any arguments, all arguments must be equal. For example,  data Maybe a = Just a | Nothing   is implemented (assuming that both types being compared are Maybe a):  (Just x) == (Just y) = x == y Nothing == Nothing = True _ == _ = False   Ord uses the order of the constructors you declared:  data Color = Red | Green | Blue   implies Red < Green < Blue  Enum is similar to Ord, using the order of constructor declaration to implement succ. For more detail read the documentation.  From the documentation of Bounded: ""The Bounded class may be derived for any enumeration type; minBound is the first constructor listed in the data declaration and maxBound is the last""  For Show and Read, I suggest you read the documentation first and then ask more specific questions :)  Have a look at https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/deriving.html"
haskell,3cfax3,tel,5,Fri Jul 10 01:07:13 2015 UTC,"What abstract algebra or geometry or math books/papers must I read to be able to best grok the esoteric stuff around monads and monoids?  Edit: I was recommended this book, but I haven't started it yet. Is that all I might need?  Edit 2: Here is a link to a free copy of Aluffi's ""Algebra, Chapter Zero"" (PDF) mentioned below."
haskell,3cfax3,crb002,4,Tue Jul 7 16:00:02 2015 UTC,"Mostly category theory, actually.  Other than that, algebraic topology.  Slight problem is, algebraic topology, category theory, and functional programming are all turning out to be part-and-parcel with each-other, but nobody has completely documented the shared concepts in one book yet."
haskell,3cfax3,kqr,2,Tue Jul 7 19:50:08 2015 UTC,"You do not need algebraic topology. It is great fun, and you can learn neat things, but I promise that at least for the next few years it you will be able to get by absolutely fine without it."
haskell,3cfax3,sccrstud92,6,Tue Jul 7 20:07:48 2015 UTC,"I recommend just reading through the typeclassopedia. You don't need esoteric stuff; Monoids and Monads don't have a lot of dependent concepts. If you understand the general idea of higher-order functions and really basic types, they're very simple. https://wiki.haskell.org/Typeclassopedia You don't have to read the whole thing, just the parts up to Monoid and Monad (or whatever else you want to understand)."
haskell,3cfax3,kqr,4,Tue Jul 7 19:51:27 2015 UTC,t algebra or geometry or math books/papers must I read to be able to best grok the esoteric stuff around monads and monoids   I’d say none. Monads are simple. Monoids are even simpler. :)
haskell,3cfax3,musicmatze,3,Tue Jul 7 18:51:17 2015 UTC,"Pinter's book is very excellent. However, it sticks to the classical topics in abstract algebra: groups, rings, and fields. You won't see anything on monoids. Monads and category theory won't be mentioned even once.  If you are interested in algebra for mathematics' sake, it's a great book. If you want to ""do IO in Haskell"", you can skip it."
haskell,3cfax3,Stratege1,2,Tue Jul 7 17:10:26 2015 UTC,"Aluffi's ""Algebra: Chapter 0"" is available for free online and quite nice.  But it's really worth emphasizing that for about 80% of what it might mean to grok monads/monoids you don't need a formal mathematical take at all."
haskell,3cfax3,4X3L_,3,Tue Jul 7 19:41:00 2015 UTC,Is there a cleaner example of how to make a mutable hash table than what is featured in Hackage?  import qualified Data.HashTable.IO as H  type HashTable k v = H.BasicHashTable k v  foo :: IO (HashTable Int Int)  foo = do      ht <- H.new      H.insert ht 1 1      return ht
haskell,3cfax3,hans2504,5,Tue Jul 7 16:56:56 2015 UTC,What do you mean by cleaner?
haskell,3cfax3,4X3L_,3,Tue Jul 7 19:22:18 2015 UTC,Maybe look at HashMap/HashSet from unordered-containers?
haskell,3cfax3,Stratege1,4,Tue Jul 7 18:35:56 2015 UTC,Those are not mutable.
haskell,3cfax3,chreekat,3,Tue Jul 7 19:22:29 2015 UTC,"I started with LYAH, continued with a bunch of other papers, and I guess I understand the theory pretty good. My idea to get started was a simple web app with groundhog and snap. I failed hard (also because the documentation for these two are ... a bit sparse). What things (size, complexity) should I try to write first? I guess some commandline applications would be nice, but I don't know where to start..."
haskell,3cfax3,sour_doaf_low,3,Tue Jul 7 19:10:53 2015 UTC,"as per usual, for a beginner, I'd recommend reimplementing parts of the prelude or base and then check your implementation against the source code of the things you reimplemented. Afterwards - just grab some project that interests you and doesn't depend on too many libraries (in my opinion: preferably none but the basic ones like Control.Monad) - if at some point you feel like it'd be too much work or annoying to implement a part of it yourself you can still reach for the library, but don't -have- to / are bound to it from the start. Perhaps if you like web applications you might want to try to implement your own (very simple) web server? That way you explore a similiar space those libraries/frameworks did which in turn might help with understanding how and why they did things, which then helps with evaluating which one is best and how to use them."
haskell,3cfax3,AdituV,3,Tue Jul 7 19:23:10 2015 UTC,"Let's say I have some type constructor who's type signiture looks like ""String -> String -> String -> String -> Foo"" I would like to prompt the user for input one at a time until I just have ""IO Foo"" but how do I prompt the user with ""putStrLn"" without the function overwriting ""IO String -> .... -> Foo"" with ""IO ()""? Would this be something I would use the state monad? Can I use two monads in conjunction?"
haskell,3cfax3,orlock,4,Tue Jul 7 20:49:32 2015 UTC,"You can use two monads with a monad transformer, but the state monad probably isn't necessary in this case.  The type signature you specified doesn't include the IO type anywhere so you couldn't really prompt from within that function. Instead, you'll need a separate function that prompts for the values which can then be passed to the function you specified:  f :: String -> String -> String -> Foo   fPrompt :: IO Foo fPrompt = do   s1 <- prompt ""Question 1""   s2 <- prompt ""Question 2""   s3 <- prompt ""Question 3""   s4 <- prompt ""Question 4""   return $ f s1 s2 s3 s4   prompt :: String -> IO String prompt p = putStr p >> getLine   There are many more elegant ways to do this, but this seems the clearest to me."
haskell,3cfax3,dagit,4,Tue Jul 7 21:12:53 2015 UTC,"Damn, once I see the solution it makes so much sense. Thanks!"
haskell,3cfax3,jgcoded,5,Tue Jul 7 21:15:57 2015 UTC,"an alternative (and shorter) way of doing it involves Control.Applicative    say you have the functions:    f :: String -> String -> String -> String -> Foo f = undefined -- replace with proper implementation of f  prompt :: String -> IO String prompt p = putStrLn p >> getLine   then you can just tie that all together into a function with the type IO Foo via:    g :: IO Foo g = f <$> prompt ""Q 1"" <*> prompt ""Q 2"" <*> prompt ""Q 3"" <*> prompt ""Q 4"""
haskell,3cfax3,dagit,5,Tue Jul 7 21:24:06 2015 UTC,"I was going to say this is well. It may look like crazy-space-language to a newcomer, but (<$>) and (<*>) are used often and I actually find this definition easy to read.  Well, slightly easier for me would be:  g = f <$> prompt ""Q 1""       <*> prompt ""Q 2""       <*> prompt ""Q 3""       <*> prompt ""Q 4"""
haskell,3cfax3,Faucelme,3,Tue Jul 7 21:36:19 2015 UTC,"My question deals with hw04 form CIS194.  P a represents a type class of polynomials, where a is the list of a polynomials's coefficients from degree 0 to n.  The last problem of the homework is to write a function for the derivative of a polynomial, and my solution was:  instance (Num a, Enum a) => Differentiable (Poly a) where     deriv (P a) = P (zipWith (*) [1..] (tail a))   Initially I didn't have Enum as a constraint, and my code wouldn't compile.  Why does a have to be an instance of Enum?  Is it simply because the list is being mapped to the integers, or am I missing something?"
haskell,3cfax3,bokabo,5,Wed Jul 8 00:40:36 2015 UTC,"[1..] gets a list of 1, and all values that follow it in a sequence.  Not all numeric types have a clear successor function (try complex numbers, for example), so you require an Enum constraint as well to say that your type a has that successor function defined.  More technically, [1..] is a pretty way of calling the function enumFrom 1, which gives you a list of all values that succeed its parameter.  As a bonus, it means you can easily construct lists like this from any enumerable type, including Bool, Char, and anything else you can think of."
haskell,3cfax3,radix,3,Wed Jul 8 02:14:21 2015 UTC,"Another question. What's the best way of handling dynamic metaprogramming, annotation and reflection in haskell? Writing things like aeson mappings seems to involve a lot of writhing about in low-level code and I'd be interested in whether someone has developed a more declarative approach."
haskell,3cfax3,dagit,5,Wed Jul 8 01:21:47 2015 UTC,"I can't give you much first hand experience, so instead I'll point you towards some introductory material and some more in depth material:   First go read Chris Done's intro to Typeable. This will work well for certain classes of problems. There is also the reflection package. You can also do generic programming in Haskell with lots of libraries. The only one I've used in GHC Generics. It was hard to grok at first, but it works remarkably well. Finally, Template Haskell can do just about anything because it allows you to run Haskell code at compile time. That gives you chance to do code generation, for instance. It's also the most unwieldy of the bunch. Which makes sense considering it's very general and very powerful.   I hope that helps."
haskell,3cfax3,conklech,3,Wed Jul 8 04:09:35 2015 UTC,"What is your real-life intuition of a monad? For example, my intuition for the stacks data structure is a stack of plates."
haskell,3cfax3,log_2,3,Wed Jul 8 16:33:31 2015 UTC,"I don't know that I have one anymore. For a while I thought of them as containers over structured computation. Later I learned that intuition matches the fact that monads are built from two natural transformations. The deeper my category theory knowledge becomes the less I like the intuitions I used to have about it. This article may also be worth a read: https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/  Moreover, I would say that intuitions are good, but many things in mathematics (and especially category theory) are design to be so abstract that they apply in many different contexts. Meaning, that your intuition can actually limit your understand of them or, worse, give you false impressions.  If you'd like to develop more familiarity (but not necessarily intuition) for categorical concepts, then I would recommend you find a copy of this book: http://www.amazon.com/Mathematics-Form-Function-Saunders-MacLane/dp/0387962174  It's bit pricey on amazon, so look around."
haskell,3cfax3,htebalaka,3,Wed Jul 8 17:22:34 2015 UTC,"Mi main intuition for both Monad and Applicative is in terms of trains:   In an Applicative, effects build the railroad upon which the locomotive of function application will travel. All the effects take place while building the railroad, not when the locomotive moves. The locomotive cannot change its course in any way.  A Monad is like having a locomotive in a railroad which is still under construction. Passengers can actually yell to the construction crew a few meters ahead to tell them things like ""I like the scenery on this side, please lay the tracks a bit more towards the right"" or ""you can stop laying tracks, I get out right here"". Of course, for this strange railway, the company can't provide a timetable or a fixed list of stops that can be checked before embarking on the train.   For more train analogies, see these slides on railway-oriented programming: http://fsharpforfunandprofit.com/rop/"
haskell,3cfax3,radix,3,Wed Jul 8 23:03:02 2015 UTC,Largely self taught developer here.Looking to better understand the mathematical basis for a lot of the stuff in Haskell. And what it's good for. What are some good places to start? Discrete mathematics textbooks? Proofs? The math part of all this seems incredibly interesting but I'm a little overwhelmed as to where to start.
haskell,3cfax3,evincarofautumn,5,Sat Jul 11 00:35:12 2015 UTC,"Another one (sorry if I'm using up my karma points by asking more than one question ;-): I'm aware of the equivalence of typeclasses with records of functions, but are these dictionaries really always reified at runtime, or are they often optimized away to static lookups by specializing code? Do all of the calls to == in my program have the overhead of dynamic dispatch, or are the majority of them static?"
haskell,3cfax3,kuribas,8,Wed Jul 8 02:55:44 2015 UTC,"If the compiler can prove statically that only one instance is to be used in a spot, then it can specialize that use and remove the dictionary lookup.  Often times, specializing code is a good way to optimize Haskell code. GHC even has a SPECIALIZE pragma that helps in certain circumstances.   Do all of the calls to == in my program have the overhead of dynamic dispatch, or are the majority of them static?   It's hard to say without seeing the code :) It is a common optimization that the compiler does and people try to take advantage of."
haskell,3cfax3,nolrai,4,Wed Jul 8 03:51:15 2015 UTC,"To expand on /u/dagit's answer: Judicious use of inlining and specialization (which may require pragmas to expose cross-module optimization) will often eliminate the runtime dispatch. To conclusively determine whether GHC has succeeded in eliminating the dictionary lookup, examine the generated Core output with -ddump-simpl."
haskell,3cfax3,rpglover64,4,Wed Jul 8 16:31:05 2015 UTC,"Why do we need output monads at all? All computations perform side effects such as heating your cpu, why is heating some pixels any different? Why aren't there functions like  print :: String -> String   with impl.  print s = s   that appear to do nothing from the program's perspective, but actually print those characters to the screen?"
haskell,3cfax3,RedLambda,8,Wed Jul 8 00:14:32 2015 UTC,"Aside from issues due to laziness which /u/evincarofautumn explained, allowing hidden side-effects also means you lose referential transparency. One thing I like a lot about Haskell is that assignment is dead simple to understand: if a = b then I know I can replace any occurrence of a with b without changing the result of an expression. Allowing side-effects would disallow this, and make a number of things more difficult (inlining for example).  There's also the reason that the types are simply useful. If I have a type for IO then I know a function of type String -> Stringhas ruled out certain behaviours (including buggy behaviours). And even if pure functions do have some side-effects (memory usage, the passage of time), a pure function cannot change its behaviour* based on that information, so the distinction is still useful even in the presence of those side-effects.  Lastly, sometimes the indirection is useful. When you do concurrency in certain languages you need to package up a function separately from its arguments to avoid evaluating it in the same thread. This can make concurrency somewhat awkward in those languages. This indirection already exists in Haskell, since a value of type IO b doesn't perform the IO unless you bind its result. Comparing with Python, these are somewhat equivalent:  Haskell: x = putStrLn ""Hello world"" Python: x = lambda y: print(""Hello world"")  Haskell: a = getLine Python: a = lambda y: input()   I believe when Haskell gets compiled to STG values of type IO a are indeed represented as functions with dummy arguments like this. Combinators like forever :: IO a -> IO a, or async :: IO a -> IO (Async a) are a lot more awkward in other languages unless you manually add the indirection with lambdas, and often require special language support otherwise.  Once you've gotten over the initial hurdle the IO monad seems very nice, even in a non-lazy setting. The lack of an IO monad in other languages is one of the first things I miss when not using Haskell.   I'm not sure if pure functions can throw exceptions due to lack of memory, but you need to be in IO to catch the exception either way, so at least they can't change their well-defined behaviour.   EDIT: I may be wrong about STG, I think I was remembering how it handles thunks, but I'm not sure if IO is handled the same way."
haskell,3chl27,heisenbug,3,Tue Jul 7 23:36:51 2015 UTC,"As someone that is just finally wrapping up getting ghc ported to a new Linux, the shake build system bit somewhat worries me.  As long as I can easily port things via cross compilers I'm ok with it. I have to do an arm port yet so don't change anything for a while. >.<"
haskell,3chl27,saudade,3,Wed Jul 8 02:31:36 2015 UTC,why do you think that Shake would make cross-compiling more difficult?
haskell,3chl27,hvr_,2,Wed Jul 8 14:15:13 2015 UTC,"Just not tried it is all, not really anything but a gut reaction. I've no facts to back up my own pathos. :)"
haskell,3chl27,saudade,4,Wed Jul 8 15:08:12 2015 UTC,"It will be easier, or your money back :)"
haskell,3chl27,ndmitchell,2,Wed Jul 8 19:49:15 2015 UTC,"I am fully mollified now!  Am I to buy this in 3 easy installments of $29.99? :)  Also this is as good a time as any, so in my porting efforts I've become a bit inspired/interested in helping out with ghc itself. While I doubt I can fix ghc emitting pie assembly today, or in a year or more really, I am fairly good at dealing with autoconf (years of c/kernel stuff will... warp your brain to tolerate it, like spice) so maybe I can help with the porting and whatnot."
haskell,3chl27,saudade,1 point,Thu Jul 9 16:28:24 2015 UTC,"/u/ndmitchell gave a talk about how some bank ported their 10kloc Makefile to Shake. not as proven as make, but that's some proof right there."
haskell,3chl27,sambocyn,2,Thu Jul 9 01:01:48 2015 UTC,"Yep no worries on that, I'm only thinking of having to deal with the fallout of converting to other build tools, cough cmake, which makes cross compilation not as tolerable. Or did at the time, I've since shied away from it in the past."
haskell,3chl27,saudade,2,Thu Jul 9 16:29:50 2015 UTC,"http://shakebuild.com/ is the Shake website and Standard Chartered was the bank. There are some details at http://shakebuild.com/#who-uses-shake. Hopefully cross compilation will be a lot easier with Shake, since we no longer have to worry about 100 different versions of grep all of which take subtly different flags, or take identical flags but with subtly different meanings!"
haskell,3chl27,ndmitchell,2,Thu Jul 9 18:21:18 2015 UTC,"So the meson link on shakebuild.com is giving a 404. But http://hackage.haskell.org/package/shake-language-c looks interesting. I need to test that out and shake itself and if it makes building my c stuff easier for cross compiling, I'm going to ditch autotools like the bad habit they are."
haskell,3chl27,saudade,2,Thu Jul 9 22:46:27 2015 UTC,"Thanks, I've fixed the link in the Markdown, and will regenerate the website tonight. I find that as long as you support Linux+Windows, you don't get much benefit from autotools anyway."
haskell,3chl27,ndmitchell,1 point,Fri Jul 10 07:20:53 2015 UTC,"so Shake provides a pure-Haskell  grep-like function? does it provide other utilities? are they ""streaming"" like pipes/conduit?"
haskell,3chl27,sambocyn,1 point,Thu Jul 9 22:26:00 2015 UTC,"What makes you think Shake provides a pure-Haskell grep-like function? It has a few utilities for command line stuff, but little else outside the build system world."
haskell,3chl27,ndmitchell,1 point,Fri Jul 10 07:17:33 2015 UTC,"then how does it make cross compilation easier? oh, I guess I misread that as ""compiling on (not for) different systems""."
haskell,3chl27,sambocyn,2,Fri Jul 10 20:10:36 2015 UTC,"Oh, now I understand your remark. The idea is to avoid tools like grep, using simple readFile/writeFile instead, rather than make grep better."
haskell,3chl27,ndmitchell,1 point,Fri Jul 10 21:40:28 2015 UTC,Got it. does it try to provide as much UNIX functionality in Haskell as possible? or do you just try to avoid the most on portable UNIX commands?
haskell,3cfhdc,mallai,13,Tue Jul 7 14:38:16 2015 UTC,"I don't think either is ""more basic"". But I agree with you that in most code, using =<< makes mores sense than the opposite, for exactly the reason you describe. It keeps function application in the same order.  In fact, I can't remember the last time I used >>= in my code :-)"
haskell,3cfhdc,sclv,11,Tue Jul 7 14:41:17 2015 UTC,"From a category theory perspective I think (=<<) is more basic, since it's usually generalized to:  (=<<) :: (Monad m, Category c) => c a (m b) -> c (m a) (m b)  return :: (Monad m, Category c) => c a (m a)   ... with these functor laws:  (=<<) return = id  (=<<) (f <=< g) = (=<<) f . (=<<) g"
haskell,3cfhdc,Tekmo,6,Tue Jul 7 16:23:44 2015 UTC,"Since >>= and =<< are the same function, just flipped, neither can be more basic.  Even category-theoretically there are people that write function composition in both orders."
haskell,3cfhdc,sclv,9,Tue Jul 7 17:25:00 2015 UTC,flip only works for the special case where c = (->).  You can't flip the arguments of (=<<) for arbitrary categories.
haskell,3cfhdc,Tekmo,10,Tue Jul 7 17:48:32 2015 UTC,"Ah, I see, your argument is that =<< looks more like a Kleisli lift of a -> m b to m a -> m b. I sort of buy that.  But by pre and post-composition you can still recover one from the other, so this nonetheless feels slightly ""syntactic"" :-)"
haskell,3cfhdc,sclv,5,Tue Jul 7 18:14:17 2015 UTC,"From a category theory perspective I think the most basic is join :: m (m a) -> m a, but then I agree if you decide to use Kleisli-style presentations (=<<) is clearer. The reason people use (>>=) is the analogy with ""effectful let"" when the function argument is a lambda -- less useful in presence of a do notation or let! syntax."
haskell,3cfhdc,gasche,3,Wed Jul 8 04:18:41 2015 UTC,"Since discovering that &, >>= and <&> all have the same infixl precedence, I've switched to mostly using just these operators (instead of $, =<< and <$> which I used before). Chaining them line by line without worrying about parenthesis is so liberating!"
haskell,3cfhdc,Peaker,1 point,Wed Jul 8 11:33:21 2015 UTC,"Where do & and <&> come from? I've never seen them before, and they don't show up in a hoogle search."
haskell,3cfhdc,Hamilcar98,1 point,Wed Jul 8 17:06:09 2015 UTC,"Control.Lens, but perhaps less controversial places too."
haskell,3cfhdc,Peaker,1 point,Wed Jul 8 20:22:50 2015 UTC,Thanks. I should have thought to check there.
haskell,3cfhdc,Hamilcar98,12,Wed Jul 8 23:16:00 2015 UTC,"Don't you answer your own question in the first paragraph? :P  Do you need any more reasons?  I'm going to reply on the assumption that this post wasn't a question about emphasis of >>= over =<< and more about arguing for the usefulness of =<<.  For the record, I did write a blog post that approached monads from the perspective of =<< -- http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad  There are a couple situations where I think >>= truly shines:  (1) With lambda notation, >>= gives much better visualization of data flow.  Consider  \y -> z =<< x   as opposed to  x >>= \y -> z   The data ""flows"" the same way.  x flows into y which flows into z.  In the first example, x to y to z is a weird zig zaggy thing.  Also the shapes of the >>= and \ and -> all align, so it looks rather nice visually too.  =<< does shine with do notation, however:  z <- y =<< x   as opposed to  z <- x >>= y   The ""data"" flows from x to y to y, and the =<< version shows this better, instead of jumping back and forth like for the >>= example.  (2) It helps you reason better with ordering of effects.  With haskell, using (.) instead f (>>>) (flip (.)) is a lot better because it helps you reason with the ordering of evaluation.  Evaluation is driven/starts with the first thing, then goes to the second thing, etc.  However, with monads, a lot of times what we care about is the ordering of effects, and not the ordering of evaluation.  If we sequence two IO effects, it's often much more important to make clear the ordering of effects.  For exmaple:  getLine >>= putStrLn   vs.  putStrLn =<< getLine   In the first one, the ordering of effects is the dominant feature.  getLine happens first, and then putStrLn.  The second way sort of implies the ordering by using data demand arguments, and if you remember =<<, then you can easily see the ordering...but the first one undeniably makes the ordering take front-stage.  If you want to emphasize ordering of effects in your code, >>= is the better choice.  Many people use monads to deal with/handle effects and ordering of effects, so this situation comes up very often  Also let me suggest some ways to rewrite what you wrote that i feel looks a little nicer.  instead of  incByOne <$> incByOne <$> Just 1    -- which is also badly parenthesized, i think   why not  incByOne . incByOne <$> Just 1   instead of   incByOneM =<< incByOne <$> Just 1   why not  incByOneM . incByOne =<< Just 1   And maybe   incByOne <$> (incByOneM =<< Just 1)   might be nicer as  fmap incByOne . incByOneM =<< Just 1   to save the parentheses."
haskell,3cfhdc,mstksg,1 point,Tue Jul 7 17:44:11 2015 UTC,"I'm sorry but I don't quite like your suggestions for rewriting the expressions. Firstly, I try to avoid point-free style as much as possible - it leads to unreadable code in my opinion. Also mixing infix operators with fmap in the last example feels convoluted. I tried to keep the ""data flow"" visible in the examples, whether right to left or left to right. Throwing in function composition using . breaks that flow. But these are just my personal preferences.  But, I buy the argument for using (>>=) with lambda expressions, looks indeed nice."
haskell,3cfhdc,mstksg,5,Tue Jul 7 21:24:58 2015 UTC,"Hm.  I don't think point-free code is inherently readable or unreadable.  that's like saying you avoid using the letter 'e' in variable names...the point is to be readable, and if that happens to be point-free, then so be it.  it might be a little indiscriminate to just say ""all point free code is unreadable => never use point free.""  point-free for the sake of point free is bad of course, but using e's in your variable names just because you want to use e's is also equally weird.  There is readable code that happens to be point-free, and unreadable code that happens to be point-free...the point-freeness is an arbitrary side-thing, i think.  For example, I don't know anyone who would write  mapM_ (\x -> print x) xs   instead of  mapM_ print xs   by looking at the second one, seeing that it's point-free, and disregarding it as a hard and fast rule.  readability should be the main concern, i think...point-freeness or non-pointfreeness might be a red herring if used as ""the reason"" for not picking something, and trying avoiding all point-free solutions as a policy might be a self-defeating strategy :)  Also, i think if data flow is what you care about, then isn't (.) the quintessential data flow operator?  f . g is ""it goes through g then f"".  (.) exists basically literally for data flow, right?  f . g $ x   it flows from x, to g, to f  f . g <$> x   it flows from x, to go, to f  f . g =<< x   it flows from x, to g, to f.  I think the point of using . is to emphasize data flow, over function application.  . is sort of the go-to thing for visualizing and representing data-flow in haskell, so the reason for using . in general is to demonstrate data-flow, I think...is there a particular reason why . is anti-data-flow to you?"
haskell,3cfhdc,duplode,1 point,Wed Jul 8 05:23:50 2015 UTC,"Point taken. I have just seen too many pieces of unreadable point-free code which uses flip etc. just to make it point-free just for the sake of it... I fully agree that one should use whatever formulation that's best for the given case instead of sticking to some dogmas.   I don't think, however, that your example mapM_ print xs qualifies as point-free - it's just a higher order function taking another function. But, yes, that's natural and desirable, of course."
haskell,3cfhdc,yitz,6,Wed Jul 8 13:16:17 2015 UTC,"Any existing resources using this style of explanation?   The Haskell Wikibook acknowledges that point of view in a post scriptum section in which Functor, Applicative and Monad are compared. Personally, ever since I got the hang of the involved abstractions I have felt (=<<) to be the most natural operator as well. The issue, I guess, is that learning resources understandably tend to introduce monads from the ""how to sequence effects""/""understanding do-notation"" point of view, rather than the ""how to map different kinds of arrows"" one. But the latter approach could be interesting to try as well."
haskell,3cfhdc,yitz,5,Tue Jul 7 15:17:52 2015 UTC,I don't think it makes enough of a difference to care very much one way or the other.
haskell,3cfhdc,drb226,1 point,Tue Jul 7 15:21:55 2015 UTC,please see the final conclusion of this thread (EDIT5) :-) It does make a difference and we need both.
haskell,3cfhdc,sgraf812,1 point,Thu Jul 9 13:28:24 2015 UTC,"I stand by my statement. That difference is one tiny detail. I, and most experienced Haskellers I know, use mostly or exclusively >>=. I find that code absolutely readable, clear, and logical, and I see know reason to change. People who use =<<, well, it feels weird to me, but it's still readable and logical, so that's fine too. There are many much more important matters to worry about."
haskell,3cfhdc,nifr,5,Thu Jul 9 16:08:17 2015 UTC,It's just a matter of style and legacy. (>>=) is in the class definition.  One way that I like to use >>= is in combination with LambdaCase:  mExpr >>= \case   Foo a -> ...   Bar b -> ...
haskell,3cfhdc,imz,8,Tue Jul 7 19:20:27 2015 UTC,I'd argue that function application is traditionally written the wrong way if you focus on data flow.
haskell,3cfhdc,imz,4,Tue Jul 7 19:22:06 2015 UTC,"I wholeheartedly agree that =<< is under used, especially within pedagogy. The fact that it is, like fmap and <*>, similar in shape to function application is very powerful notion."
haskell,3cfhdc,massysett,3,Tue Jul 7 19:03:15 2015 UTC,"Your example needs a correction (if it is a intended to be a good learning material):  incByOne <$> (incByOne <$> Just 1)     :: Maybe Int   because <$> is surprizingly left-associative like most normal operators, and unlike $ (which is disliked by some); =<< is more like $ though:  Prelude Main> :m + Control.Applicative Prelude Control.Applicative Main> :i (<$>) (<$>) :: Functor f => (a -> b) -> f a -> f b     -- Defined in `Data.Functor' infixl 4 <$> Prelude Control.Applicative Main> :i (=<<) (=<<) :: Monad m => (a -> m b) -> m a -> m b     -- Defined in `Control.Monad' infixr 1 =<< Prelude Control.Applicative Main>"
haskell,3cfhdc,mightybyte,1 point,Tue Jul 7 16:31:06 2015 UTC,"Hmmm, I tested all expressions in GHCi before posting and they worked. I'll check again."
haskell,3cfhdc,tomejaguar,2,Tue Jul 7 17:32:10 2015 UTC,"They do type-check, and are even equivalent to what you wanted, but for different reasons (explained under the ""surprizingly"" link) ;)"
haskell,3cfhdc,Peaker,1 point,Tue Jul 7 17:49:12 2015 UTC,"Thanks for pointing that out! I edited the question.   I was actually not aware of this. It breaks the analogy to ($), which is often used to avoid the parentheses, which are required with (<$>). :-("
haskell,3cfhdc,tomejaguar,3,Tue Jul 7 21:17:02 2015 UTC,My first impulse was  incByOneM <=< incByOneM $ 1
haskell,3cfhdc,ninereeds314,3,Tue Jul 7 19:54:48 2015 UTC,I've been introducing Monads to people this way using the (=<<) operator for awhile now for exactly this reason.  I think ($) is fairly easy to understand and it's a logical jump from that to (=<<) in the monadic context.
haskell,3cfhdc,sclv,2,Wed Jul 8 05:11:42 2015 UTC,"Yes, more =<< please.  Mixing =<< in with <$> and . is particularly heinous."
haskell,3cfhdc,ninereeds314,2,Tue Jul 7 20:03:17 2015 UTC,"Which is the set of operators >>=, <&> and & are so much nicer."
haskell,3cfhdc,sclv,1 point,Wed Jul 8 11:34:31 2015 UTC,"I'll use them just as soon as function application happens on the left too.  Arguably it should, since it seems to match the function type constructor -> direction better."
haskell,3cfhdc,ninereeds314,2,Wed Jul 8 18:24:33 2015 UTC,"Like many people, I find that the . function composition operator seems backwards. For normal function application - well, with two functions, you already probably need parentheses. OK, yes I know about $, but that's still kind-of the point - you need an extra operator that isn't from mathematics to clean up the mess and help keep things readable.  I also remember that a commonly claimed advantage of Forth is that, although losing prefix and infix notations for arithmetic is jarring at first, in the long run the advantage is that all operations are written in the order they are performed.  Where there are effects, I think writing operations in the order they are done is particularly important. Writing the last effect first is rarely intuitive.  When's the last time you gave instructions to someone separating all the steps with ""after you"" rather than ""then""? Despite the function composition rule, my experience is that even mathematics lectures describe the first step first then the later steps. And of course ""then"" is the common name for the >> operator."
haskell,3cfhdc,sclv,3,Tue Jul 7 22:06:55 2015 UTC,"Instead of ""after you"" or ""then"" read ""of"".  So f . g . h $ x is ""f of g of h of x"""
haskell,3cfhdc,WarDaft,1 point,Wed Jul 8 01:33:20 2015 UTC,"Sure, there's a word you can use that makes function composition ""read right"", but when's the last time you gave someone IRL instructions as a sequence of steps combined using function composition? Would you try to find a wording for ""the second right . the first left"", or would you just say ""the first left then the second right""?  In any case, >>= isn't . - there are (potentially) ""real"" effects to account for. Effects have a natural ordering, which is a significant part of what monads are for in Haskell, even when the effects are an abstraction created by the monad with a pure underling implementation. IOW for >>= there's at least two conflicting lines of reasoning for where to draw your ordering intuition from.  If the argument ordering for simple function composition were universally considered intuitive, it still wouldn't be a conclusive argument, because effect ordering has just as strong a claim and conflicts. The fact that function composition isn't universally considered intuitive only adds to that - unless you know a significant group who find sequencing effects first-to-last unintuitive.  Note - OP doesn't count because OP wasn't thinking in terms of effects."
haskell,3cfhdc,ninereeds314,3,Wed Jul 8 02:32:20 2015 UTC,"If I think of it as a declarative description rather than an imperative sequence of actions, then the ""of"" reading is the one that feels most natural to me.  Since I'm thinking declaratively and functionally rather than imperatively, then the sequencing makes sense to me.  Additionally, f (g x) --> f . g $ x reads very naturally as a rewrite."
haskell,3cfhdc,WarDaft,1 point,Wed Jul 8 03:16:15 2015 UTC,"My claim is that there exist people who find the argument order for . unintuitive. Counter-examples are not disproofs. I never claimed that view is universal.   If I think of it as a declarative description rather than an imperative sequence of actions   Declarative doesn't imply any particular ordering. You can declare a route in any order - whatever is convenient for the context. There is no one ordering that's convenient for all contexts, so IMO ""being declarative"" is irrelevant here.  Going back to the traffic directions example, a route isn't imperative - it's declarative. The imperative actions only happen when someone follows that route. The reason to identify a route is presumably so that it can be followed, but that's just why the ""imperative"" ordering is usually natural in that context.  In some cases, the same applies to the steps needed to compose a sequence of functions. That's one of the reason pure computations are occasionally expressed in do notation when even the abstraction (as far as one exists) has no effects.  The argument ordering for . isn't a result of declarative thinking, it's an accident of the fact that functions are written in a prefix notation. If functions happened to be written postfix, no doubt your simple rewrite would have been (x g) f --> x $ g . f. It's just as declarative - only notational conventions have changed. That was part of my point when I mentioned Forth earlier, though I was putting all the stress on effects so that wasn't very clear.  There's a tendency to view math-based abstractions as ""high level"" and imperative abstractions as ""low level"". IMO the point of a high level abstraction is to be close to the actual problem you're trying to solve, not merely as far as possible away from the abstractions provided by machine code. Depending on the problem, function application can be as far from your problem as goto. The historic accident of function application being written prefix, therefore, is not a good reason to write problem-oriented code any particular way.  TBH the objection I originally expected was about non-strict evaluation order - after referring to the correlation between strict-evaluation ordering and notational ordering in Forth, I wasn't very clear when I said ""writing operations in the order they are done"" that that doesn't mean the literal evaluation order.  That's kind of relevant here. First-thing-first can absolutely be a high-level aspect of an abstraction, irrespective of low-level implementation details."
haskell,3cfhdc,ForTheFunctionGod,2,Wed Jul 8 04:13:11 2015 UTC,My claim is that there exist people who find the argument order for . unintuitive.   Of course there are. I know this because I'm talking to one right now :-P
haskell,3cfhdc,ForTheFunctionGod,2,Wed Jul 8 05:43:59 2015 UTC,"{-# LANGUAGE     RebindableSyntax     #-}  chain = (flip (.), (\x y z -> y (x z) (x z))) multi = (flip (.), flip (.))  someFunc = do     (+1)     (*2)     show     where ((>>),(>>=)) = chain   someFunc == show . (*2) . (+1)  evenBetterFunc = do     (+1)     n <- (*2)     show     (++ replicate n '!')     where ((>>),(>>=)) = chain   evenBetterFunc == (\n -> show n ++ replicate n '!') . (*2) . (+1)  evenEvenBettererFunc = do     (+1)     n <- (*2)     l <- filter (/= 'e')     map (*n)     show     (l++)     where ((>>),(>>=)) = multi   evenEvenBettererFunc == \n l r -> filter (/= 'e) l ++ show (map (((n+1)* 2) *) r)  So, in someFunc, we're just using do notation to compose functions in the ""do this then do that"" manner.   In evenBetterFunc, we're doing that, and also changing monadic bind so it lets us name the processed input so far, and use the current value for further processing.  In evenEvenBettererFunc, we're creating a 3 argument function, where as soon as we bind a value to a name, we are saying we're done processing that argument and now the functions are applying to the next argument.  These overloadings, alas, cannot be nested."
haskell,3cfhdc,ForTheFunctionGod,1 point,Wed Jul 8 21:29:07 2015 UTC,"Interesting, though I had in mind things like the Maybe monad, using names for all the intermediate results.  The weakness in my argument there is that doing that purely for the do-this-then-that could be done by abusing Maybe, but is more clearly expressed by Identity. Which is still overkill because you can write the same thing as a let expression, which doesn't require any particular order. Plenty of people prefer a do-that-after-this order. In fact for where expressions the ""final"" (outermost) step must be written first.  It reminds me, many years ago, of all that fuss about top-down vs. bottom-up design in college lectures. I've never known anyone work entirely one way that I remember - having names makes sense, but arguing which is better always seemed a bit stupid.  Anyway, using do to make the ""main sequence"" of intermediate results anonymous - interesting idea.  BTW - there's a missing close parenthesis on your definition of multi."
haskell,3cfhdc,maxiepoo_,1 point,Thu Jul 9 01:51:52 2015 UTC,"Good catch, thanks.  I think it's overkill to name results you aren't interested in. I can't take credit for the idea of using it to chain composition, but I haven't seen using binds for naming intermediate values anywhere else yet."
haskell,3cfhdc,imz,2,Thu Jul 9 02:41:43 2015 UTC,"This is purely an issue of psychology and sociology. In cultures with left-to-right writing schemes, (.) is the odd artifact, wheras (>>=) manifests the right way™.  Due to Western acculturation, we are used to two directions in which information flow (text) can go: right and down. (>>=), in conjuction with the do-notation, goes in these 2 directions:  f = do x <- m1          y <- m2          return $ g x y  f = m1 >>= (\x -> m2 >>= (\y -> return $ g x y))   On the other hand (.) has the signature (b -> c) -> (a -> b) -> (a -> c) for compatibility with Euler's idiosyncratically chosen prefix function application:  f (g (h x)) = (f . g . h) x   While I think people would have an easier time with an (~>) :: (a -> b) -> (b -> c) -> (a -> c), prefix function application, baked into Haskell's grammar, sabotages the effort. Sending one x through a series of functions is easy enough (x & f ~> g ~> h), but it'd be murder to convert an expression like f (g (h x) y) (z x x) into postfix form."
haskell,3cfhdc,maxigit,1 point,Tue Jul 7 23:03:27 2015 UTC,"Interesting, I haven't thought about it this way!   So, having & and >>= supports left to right. What about something at the functor level analogous to <$>?"
haskell,3cfhdc,chrisdoner,2,Wed Jul 8 00:22:00 2015 UTC,What about something at the functor level analogous to <$>?   I actually made a package for that - precisely because of how annoying mixing monadic and pure functions was.
haskell,3cfhdc,Peaker,1 point,Wed Jul 8 01:56:45 2015 UTC,":-) Just for consistency reasons, since we have $ and <$>, then I would prefer to have & and <&>. But it would be good to add an operator like that to base."
haskell,3cftha,joehillen,13,Tue Jul 7 16:07:24 2015 UTC,Skete is a very interesting point in the cabal/stack/whatever design space. Having the ability to download all of hackage in exchange for about a gig of storage and being able to update all the changes to every package in the repo faster than cabal can let you update the index is kind of hilarious.  I'm really happy to see the video from this talk finally making its way online.
haskell,3cftha,edwardkmett,5,Tue Jul 7 16:36:35 2015 UTC,The link to the repository from the end of the talk is here:  http://code.xkrd.net/groups/skete
haskell,3cftha,edwardkmett,3,Tue Jul 7 16:55:10 2015 UTC,Is there a README of any sort anywhere?
haskell,3cftha,acow,6,Tue Jul 7 19:30:11 2015 UTC,ekmett's link is to the group. It has individual repos under it  http://code.xkrd.net/skete/skete/tree/master has a README
haskell,3cftha,Pikachut,2,Wed Jul 8 03:41:09 2015 UTC,For that I'd have to defer to davean and alec.
haskell,3cftha,edwardkmett,1 point,Tue Jul 7 20:09:21 2015 UTC,Is there an article/text version? I'm unable to listen to the talk.
haskell,3cftha,alantrying,2,Wed Jul 8 11:43:22 2015 UTC,"We haven't written one yet.  Shae cleaned up our README quite a bit, which you can find at http://code.xkrd.net/skete/skete#tab-readme.  Here's a link to the presentation: https://docs.google.com/presentation/d/1J2xDeXZLajJOhPlJxlAiv4Pv-OL7r7gGw4BwuZ87LNU/edit?usp=sharing.  I'll follow up here in a bit with a gloss of the the slides."
haskell,3cftha,deviant-logic,7,Wed Jul 8 16:22:46 2015 UTC,"So we're familiar with software repositories like Hackage, PyPI, CPAN, RubyGems, Debian, etc.  By and large, they work by providing some form of package index (00-index.tar.gz with Hackage, for instance) to clients. Clients then use the index to find package artifacts and install them. Different systems do, of course, provide different features.  One of the more relevant features for skete is a notion of ""package sets"" (like Debian's stable/testing/unstable).  People (ourselves included) have a few nits to pick with Hackage.  We frame these largely as being due to its being excessively centralized: Hackage only works when it's up, when you can reach it, when the packages you want to install are published to the world, and so on.  So we started with the idea: ""wouldn't it be cool if we could have a git repository of all of Hackage?"".  After a bit of abstraction creep, we ended up making a framework for building and using software repositories.  Skete itself provides a reasonably minimal interface against which one can implement a package-management front-end (methods with default implementations elided):  class Monad m => SketeStorage d m r | m -> r, m -> d where   storage :: MonadIO mp => d -> m a -> mp a   add :: ToJSON a => PackageVersion -> a -> DirTree FileData -> m r   lookup :: PackageVersion -> m (Maybe r)   packageData :: FromJSON a => r -> m (Maybe a)   packageFiles :: r -> m (DirTree FileData)   labels :: m [PackageSet]   label :: r -> MetaMap -> PackageSet -> m ()   labelData :: PackageSet -> PackageVersion -> m (Maybe MetaMap)   list :: PackageSet -> m [PackageVersion]   Primarily, this amounts to being to add a package to the repo, put it in a package set (we call it a ""label""), find a package by its version, retrieve the files in a package, and obtain the list of package sets.  We have implemented a git-based backend (in fact, we've implemented at least three git-based backends, but one has won out).  So there are about 54K package-versions on Hackage.  They amount to 19GB of tarballs (4.7GB when compressed, 975MB when compressed all together with xz). Our embedding of Hackage into git occupies a bit over 1GB of space, which is a pretty reasonable amount of space in exchange for all of hackage.  Our current git backend for skete embeds packages into git thusly: package sets are represented as branches (including a distinguished all branch that includes all packages in the repo).  When a new package-version is added, we make a commit of its contents, with its parent being the previous commit of that package version (i.e., each package gets its own history).  When that package is labelled, we make a commit that's a merge of the previous label commit, and the commit of the new package.  (These commits hang on to some metadata in the commit messages as well).  What does this allow?  Well, now we can overlay private package sets on top of Hackage.  If your company doesn't open source every line of code it writes, you can still create a package repository with Hackage upstream that includes your own unshared code.  We also get incremental pulls off Hackage of a few kiB instead of redownloading the whole package index, or redundant code in new packages.  Additionally, you get a Hackage you can use offline."
haskell,3chq5v,fuzzyslippers42,5,Wed Jul 8 00:18:27 2015 UTC,"I think what's happening is that Data.ByteString.Lazy.hGet doesn't complete until either it has read 1024 bytes or the client closes the connection, and the client isn't writing that many bytes.  Use Data.ByteString.hGetSome instead? (N.b. not lazy.)  For streaming data frameworks, look at the pipes (or conduit) library."
haskell,3chq5v,dave4420,4,Wed Jul 8 02:31:26 2015 UTC,"Yep, I was directed on the irc to conduit, and I'm going to give that a shot, thanks."
haskell,3chq5v,hagda,3,Wed Jul 8 02:37:40 2015 UTC,you may want to try out io-streams which is a thin abstraction layer over handles and sockets and yet handles this exact issue youre experiencing
haskell,3chq5v,hagda,3,Wed Jul 8 12:52:49 2015 UTC,How does that compare to conduits?
haskell,3chq5v,Tekmo,3,Wed Jul 8 14:01:35 2015 UTC,"For one, the types and the abstraction is much simpler (and thus easier to understand, less cognitive overhead etc). Take a look at the io-streams tutorial to get an idea how easy everything becomes in the familiar IO monad.  Then there's pipes in case io-stream doesn't fit the bill and something more generic is needed, as you can implement io-streams on top of pipes."
haskell,3cf5yd,ephrion,5,Tue Jul 7 12:58:14 2015 UTC,"That is just ""what the doctor ordered"" :-D Thanks!"
haskell,3cf5yd,mallai,4,Tue Jul 7 13:05:10 2015 UTC,"In the meantime, here's a quick script that can be used to configure Cabal to use stack's package databases and GHC. This fixes tools which rely on Cabal's stored information, such as ghc-mod. There are probably a lot of corner cases that the script doesn't handle, but it has been working for my projects.  #!/bin/bash  ghc_version=""7.10.1""  [ -z ""$1"" ] || ghc_version=""$1""; shift  cabal configure --package-db=clear \                 --package-db=global \                 --package-db=""$(stack --no-system-ghc path --snapshot-pkg-db)"" \                 --package-db=""$(stack --no-system-ghc path --local-pkg-db)"" \                 --with-compiler=""$(stack --no-system-ghc path --ghc-paths | head)/ghc-${ghc_version}/bin/ghc"" \                 $@   Note that the GHC version has to be specified manually. As far as I'm aware, stack currently has no interface for determining the GHC it's going to use.  The script is based on an idea by Github user DanielG."
haskell,3cf5yd,jlimperg,2,Tue Jul 7 14:07:43 2015 UTC,"I typically use stack exec which ghc for that, which should even work on Windows since we include msys in the PATH. But theoretically we could just add this to stack path as well, I don't see a problem with doing so.  I wonder if the --with-compiler and --no-system-ghc stuff is what's necessary to solve this undiagnosed issue."
haskell,3cf5yd,snoyberg,1 point,Tue Jul 7 14:53:10 2015 UTC,"stack exec which ghc does indeed work on Windows. It'll return a POSIX style path (/c/Users/...), which may or may not be what's required. To get a Windows-style path, replace which with its Windows equivalent, where: stack exec where ghc."
haskell,3cf5yd,conklech,1 point,Tue Jul 7 15:12:07 2015 UTC,"That makes a lot of sense and is quite obvious in hindsight, thank you.  The undiagnosed issue doesn't look like a typical bad interaction with the global package DB to me, but I have no clue what it might be caused by either."
haskell,3cf5yd,jlimperg,1 point,Tue Jul 7 16:14:32 2015 UTC,"Same here:  $ ghc-mod check src/Main.hs  [1 of 3] Compiling CabalHelper.Types ( CabalHelper/Types.hs, /home/joe/.ghc-mod/cabal-helper/CabalHelper/Types.o ) [2 of 3] Compiling CabalHelper.Common ( CabalHelper/Common.hs, /home/joe/.ghc-mod/cabal-helper/CabalHelper/Common.o ) [3 of 3] Compiling Main             ( CabalHelper/Main.hs, /home/joe/.ghc-mod/cabal-helper/Main.o ) Linking /home/joe/.ghc-mod/cabal-helper/cabal-helper-0.3.5.0-Cabal-1.22.2.0 ... ghc-mod: <command line>: cannot satisfy -package-id lens-4.11-0041a0fd8f4b1ccd73802b553a590b55     (use -v for more information)"
haskell,3cf5yd,joehillen,1 point,Tue Jul 7 14:22:42 2015 UTC,That usually means that your project isn't built yet. Can you try running stack build again to make sure it completes successfully?
haskell,3cf5yd,haskman,1 point,Tue Jul 7 16:17:22 2015 UTC,"Nope, it builds just fine."
haskell,3cf5yd,joehillen,0,Tue Jul 7 18:19:06 2015 UTC,"There is also different fork of ghc-mod with some hacky stack support. It is based on release 5.2.1.2, which I find more stable than master. https://github.com/esmolanka/ghc-mod  At first, you stack build your project and then just use ghc-mod.  Update: yes, it might not work with GHC 7.10, but works fine with GHC 7.8"
haskell,3cenfi,Florian939,11,Tue Jul 7 09:06:00 2015 UTC,to quine a phrase
haskell,3cenfi,yitz,8,Tue Jul 7 09:11:53 2015 UTC,"I am well-typed but I won't tell you what my type is  let a x = (x,x); b = a.a; c = b.b; d = c.c; e = d.d; f = e.e; g = f.f in g ()"
haskell,3cenfi,quchen,6,Tue Jul 7 15:56:54 2015 UTC,Another fun one: http://stackoverflow.com/questions/23746852/why-does-haskells-do-nothing-function-id-consume-tons-of-memory
haskell,3cenfi,RyanGlScott,3,Tue Jul 7 16:46:39 2015 UTC,"b is a2, so c is a4, d is a8... and g is a64.  At first, our argument () has a string representation of length 2.  If (length . show) x == n, then:     (length . show) (a x) == length (show (x, x)) == length (""("" ++ show x ++ "", "" ++ show x ++ "")"") == length ""("" + length (show x) + length "", "" + length (show x) + length "")"" == 1 + n + 2 + n + 1 == 2*n + 4   So the length of representation of the final result is:  iterate (\n -> 2*n + 4) 2 !! 64 == 110680464442257309692"
haskell,3cenfi,13467,1 point,Tue Jul 7 17:57:19 2015 UTC,Am I missing a joke or something because b isn't well typed.
haskell,3cenfi,darkroom--,3,Tue Jul 7 16:41:07 2015 UTC,"b is well-typed because a is polymorphic. Each use creates a different set of unification variables. It's the same reason id id () is well-typed.  The second id has type () -> (), and so the first has type (() -> ()) -> () -> ().  This also explains the performance problem, because you can see the type grows exponentially..."
haskell,3cenfi,c_wraith,2,Tue Jul 7 19:13:12 2015 UTC,the type grows exponentially   Ackermanniany in my case! :-)
haskell,3cenfi,quchen,1 point,Tue Jul 7 21:06:15 2015 UTC,Why not?
haskell,3cenfi,PM_ME_UR_OBSIDIAN,3,Tue Jul 7 16:45:11 2015 UTC,I stand corrected thought through the types
haskell,3cenfi,darkroom--,5,Tue Jul 7 17:37:54 2015 UTC,"main = (putStrLn . ((++) <*> show)) ""main = (putStrLn . ((++) <*> show)) ""   is rather nice, too."
haskell,3cenfi,NihilistDandy,1 point,Tue Jul 7 14:13:42 2015 UTC,"Golf it like OP's and it actually clocks in a character shorter, because there's no backslash that needs escaping!"
haskell,3cenfi,tejon,2,Wed Jul 8 08:36:03 2015 UTC,Even shorter if ap were in the Prelude.
haskell,3cec0n,bos,11,Tue Jul 7 06:29:08 2015 UTC,"I believe the video for this talk will be available reasonably soon, along with the videos for all the other ZuriHac talks."
haskell,3cec0n,dcoutts,5,Tue Jul 7 09:13:13 2015 UTC,We're working on it.
haskell,3cec0n,tibbe,2,Tue Jul 7 13:05:58 2015 UTC,https://youtu.be/60gUaOuZZsE  This will appear alongside all the other ZuriHac videos shortly on the Google Open Source blog.
haskell,3cec0n,dcoutts,8,Wed Jul 8 10:39:09 2015 UTC,"Is there any ETA for this new *better, faster binary serialization"" library? Can't wait to use it..."
haskell,3cec0n,RedLambda,7,Tue Jul 7 06:58:36 2015 UTC,"https://github.com/well-typed/binary-serialise-cbor  We're currently trying it out in a customer's application. This should give us some real-world feedback. If you want to try it and give me feedback that'd also be most welcome. Note that there are some known TODOs (including a couple numeric type range issues).  As I say in the talk, the longer term goal is to put it into the binary package as the new serialisation layer. But in the meantime it'll be available as a separate library."
haskell,3cec0n,dcoutts,3,Tue Jul 7 09:08:49 2015 UTC,What does “not great core” mean (slide 18)? Does it refer to the GHC intermediate representation?
haskell,3cec0n,f2u,3,Tue Jul 7 10:43:47 2015 UTC,"Yep. Sorry, this is all a bit clearer with the video. Look out for when those are available. Should be soonish, the ZuriHack organisers had to get everything past the google video copyright release form bureaucracy."
haskell,3cek9a,erikd,4,Tue Jul 7 08:19:00 2015 UTC,The https code probably shouldn't be relying on /dev/random which can block.  If you trust the kernel CSPRNG enough to be using /dev/random then just use urandom for TLS.  Not that havaged isn't a good idea on VMs.
haskell,3cek9a,jpnp,2,Tue Jul 7 11:56:08 2015 UTC,I haven't actually got around to finguring out where in the Yesod stack this is happening. I suspect its actually in the tls libraries. /u/vincenthz ?
haskell,3cek9a,vincenthz,2,Tue Jul 7 21:54:17 2015 UTC,"While you're right on linux, all unixes are not made equal regarding their handling of random/urandom; it's the reason that random is probbed first.  The bug (that was fixed a week ago) happened to be, that hGetSome is not returning if there no data, as initially assumed. It's now the proper call that return without blocking."
haskell,3ce3v6,jystic,8,Tue Jul 7 05:00:23 2015 UTC,"This is not quite finished yet as runEffect isn't implemented, but I'm sure Patryk will upload that by the end of the week.  The interesting thing about this if you compare it to pipes is that it has two continuations, so it is able to observe end of stream in a type safe way (as opposed to conduit which does it by convention), while (I think?) retaining all of the nice categorical properties of pipes.  Quiver:  type Producer b' b f r = forall a' a . P a' a b' b f r  type Consumer a' a f r = forall b' b . P a' a b' b f r  data P a' a b' b f r     = Consume a' (a  -> P a' a b' b f r ) (Producer b' b f r)     | Produce b  (b' -> P a' a b' b f r ) (Consumer a' a f r)     | Enclose    (f    (P a' a b' b f r))     | Deliver r   Pipes:  data Proxy a' a b' b m r     = Request a' (a  -> Proxy a' a b' b m r )     | Respond b  (b' -> Proxy a' a b' b m r )     | M          (m    (Proxy a' a b' b m r))     | Pure    r   I'm super interested to hear what Gabriel and Michael think about this approach and how it compares to their libraries."
haskell,3ce3v6,snoyberg,11,Tue Jul 7 10:46:44 2015 UTC,"Referring to features of the core datatype in the respective libraries, here are the differences:  pipes: has bidirectionality conduit: has termination detection, finalizers, and leftovers  Based on what I'm reading here, this would be:  quiver: has bidirectionality, termination detection  If this abstraction also obeys all of the Category laws (like pipes does), it seems like a very nice extension of pipes. From the conduit perspective, leftovers are still vital to how we do things (though finalizers less so). If you could figure out a way to add in leftovers, it seems like you'd have the holy grail of streaming abstractions! :)  Note: I'm fairly certain it's impossible to have leftovers with a properly behaving Category, since composing two components together will necessarily discard leftovers from the downstream one. In other words: if you find a solution to this, awesome! But don't spend the next 20 years staring at a chalkboard hoping it'll happen."
haskell,3ce3v6,tomejaguar,3,Tue Jul 7 13:12:51 2015 UTC,"I must admit I am very puzzled.  Could you and Tekmo please explain the problem with leftovers?  Why can't it lead to a category?  In particular, why does giving unused input back to the person who gave it to you not work?"
haskell,3ce3v6,Tekmo,6,Tue Jul 7 20:02:17 2015 UTC,My post on pipes-parse explains the problem and how pipes-parse solves this without dropping leftovers.  I can summarize the solution by saying that pipes does not use pipe composition for parsing purposes but instead uses lenses/getters between Producers.
haskell,3ce3v6,snoyberg,3,Wed Jul 8 00:05:55 2015 UTC,"Consider the following:  mapM_ yield [1,2,3] $$ CL.map show =$ CL.peek   The CL.peek will call leftover ""1"". How do you re-leftover that up from CL.map? And this is just a trivial case; imagine things like receiving a ByteString, converting to `Text, consuming the first 20 characters, and calling leftover on the rest.  You may be able to see it better if you look at functions for conduit composition with leftovers."
haskell,3ce3v6,tomejaguar,5,Tue Jul 7 20:15:12 2015 UTC,"What does ""re-leftover that up"" mean?"
haskell,3ce3v6,snoyberg,3,Tue Jul 7 20:45:55 2015 UTC,"It means that the next thing monadically composed upstream would have access to those leftovers. Consider this:  mapM_ yield [1,2,3] $$ ((CL.map show =$ CL.peek) >> CL.mapM_ print)   What would you expect the output to be?"
haskell,3ce3v6,tomejaguar,3,Tue Jul 7 20:48:14 2015 UTC,"Oh I see, the leftover in this case is 2?  And it needs to be saved so that print can have it?  Actually I guess the output should be~~  1 1 2 3  Is that right?  No, I'm just confused.  What's the answer? :S"
haskell,3ce3v6,snoyberg,3,Tue Jul 7 20:55:24 2015 UTC,"Maybe this example is confusing the situation, since it's not actually demonstrating directly the category violation, but rather why the violation exists. Here's the violation:  idC :: Monad m => Conduit a m a idC = awaitForever yield -- same as CL.map id  idC =$= CL.peek /= CL.peek   However:  fuseLeftovers id idC CL.peek == CL.peek"
haskell,3ce3v6,tomejaguar,2,Tue Jul 7 21:02:27 2015 UTC,"By ""why the violation exists"" do you mean ""the reason why the violation should exist""?"
haskell,3ce3v6,snoyberg,2,Tue Jul 7 21:05:34 2015 UTC,Yes
haskell,3ce3v6,zadarnowski,3,Tue Jul 7 21:06:28 2015 UTC,"That analysis is almost correct, except that Quiver also has [a generalized form of] finalizers - you actually get a separate one for the cases of downstream and upstream termination, which is neat for my application of Quiver processors under Snap. Also, leftovers can be done pretty naturally in Quiver as part of its Deliver constructor, using a concoction such as P a' a b b' f (r, [a'], [b])  As I'm working through the various combinators, it also seems that I get to retain all if the pipe category laws, although with dubious utility, since the Monad instance for P is far less useful than in pipes or conduit (it's a binary structure after all, and monads don't do binary very well.)  What I'm finding more fascinating is that, despite my best intentions, Quiver seems insistent on doing leftovers, and doing them pretty well too, although at the expense of loosing the Monad instance altogether. A few years back I've been working with a similar streaming structure (in the context of compiler verification) in which I tried to incorporate leftovers resulting in a mess of truly magnificent proportions (and largely causing me to drop the project altogether until now.) So with Quiver I've intentionally avoided leftovers like a plague. But the more I try to work with the structure, the more it seems to push me in the direction of incorporating leftovers into the Deliver constructor, leveraging on the bidirectionally of communication for typing. I could still be wrong, but I'm pretty sure it won't take 20 years to find out :) Either way, expect significant changes in the next few releases!"
haskell,3ce3v6,NihilistDandy,2,Wed Jul 8 05:56:07 2015 UTC,"P a' a b b' f (r, [a'], [b])   That looks so scary."
haskell,3ce3v6,Tekmo,4,Wed Jul 8 20:11:11 2015 UTC,"This looks interesting.  There is one thing missing compared to pipes which is other composition operators like (>~>) and (>+>).  However, there may be generalized versions of these operators that works for the P type such that the consume and produce functions are the identities of those generalized operators."
haskell,3ce3v6,michaelt_,2,Tue Jul 7 13:46:13 2015 UTC,"I'm wondering how 'runEffect' would be implemented. One keeps coming on constructors (Produce and Consume) containing two quivers, each returning whatever the other returns. Do you throw one out?  Maybe the answer will be obvious if I can figure out the idea behind the additional Quiver in each case."
haskell,3ce3v6,michaelt_,2,Tue Jul 7 19:51:43 2015 UTC,runEffect is now up on Hackage if you want to look.  I think your concern is probably answered looking at the types for >>-> and >->>. They tuple up the two results.
haskell,3cg236,mu_livecodingtv,3,Tue Jul 7 17:07:41 2015 UTC,https://www.fpcomplete.com/school/starting-with-haskell
haskell,3cg236,FPguy,3,Tue Jul 7 22:45:02 2015 UTC,http://learnyouahaskell.com/  http://book.realworldhaskell.org/read/
haskell,3cg236,hans2504,3,Tue Jul 7 22:51:51 2015 UTC,My two all-time favorite resources are:  How to Learn Haskell  What I Wish I Knew When Learning Haskell
haskell,3cg236,nootloop,0,Tue Jul 7 23:19:54 2015 UTC,You gaze at the compiler until code manifests itself. *joking*
haskell,3cg236,Vektorweg,3,Wed Jul 8 02:07:50 2015 UTC,"Dunno man, this hits close to home."
haskell,3cc4wv,andrewthad,9,Mon Jul 6 19:33:20 2015 UTC,One observation: this looks like it has a natural instance for Divisible that contramaps each table based on the given function and then mappends them (since they're now the same type).  That would be nice for building up more complex tables from smaller ones.
haskell,3cc4wv,SirPsychoS,5,Tue Jul 7 02:05:02 2015 UTC,"I've written the following instance and it typechecks. I've never used Divisible before, so my intuition for it is not good, and I mostly used the types to guide me. Can you tell me if this is correct:  instance Divisible (Table site) where   conquer = mempty   divide f (Table aCols) (Table bCols) = Table $     (fmap (contramap (fst . f)) aCols) <>     (fmap (contramap (snd . f)) bCols)"
haskell,3cc4wv,SirPsychoS,2,Tue Jul 7 13:09:44 2015 UTC,"Yeah, that's the one I was envisioning."
haskell,3cc4wv,Taladar,2,Wed Jul 8 02:03:53 2015 UTC,"Sweet. I've merged it into the master branch, and this will go out in the next release."
haskell,3cc4wv,_AndrewC_,3,Thu Jul 9 10:40:50 2015 UTC,Thanks for pointing that out. I was not aware that that even existed. I'll will be an instance for Divisible (once I really get my head around what it means).
haskell,3cc4wv,_AndrewC_,9,Tue Jul 7 11:07:42 2015 UTC,"Also, if any novices enjoyed Gabriel's talk and were wondering about a good example of where monoids show up in ""the real world"", this may be enlightening."
haskell,3cc4wv,Vektorweg,6,Mon Jul 6 21:31:27 2015 UTC,"Looks good though I think tables have a few more commonly used pieces of code, particularly when you take server-side pagination into account.  I suppose to fully implement that general case in Yesod we would need something like a subsite that can be parametrized by data and row count fetching functions though and then we would get into the whole problem of identifying the first element of the nth page (ideally not just via limit and offset in case someone added rows while we were browsing pages).  So in summary i guess that would be a much larger scope than yesod-table currently has."
haskell,3cc4wv,MaxGabriel,10,Mon Jul 6 22:24:23 2015 UTC,"Yeah. On one project I worked on, I built a different pagination solution as a part of a web app (one that just patches persistent and esqueleto queries with limit+offset information and does a count query to calculate the total number of pages). It's from when I was newer to haskell, so it's got some real ugliness to it, but its still chugging away on a live application to this day.  When I finally factored all the table stuff into a library, I decided to avoid any including pagination features. Three reasons:   I couldn't think of anything elegant or anything that others could really reuse. Pagination can still be built on top of yesod-table by another library if someone has a solution they like. Most importantly, I stopped liking pagination. I realized that rather than having 50 results split over 5 pages, most clients just want to see all 50 of them at once. Clearly, once it gets something like 1000, that's no good anymore, but neither is seeing 100 pages of paginated results. At that point, you just want a search feature. So these days, I tend to just show everything or require searching.   This being said, I am not opposed to pagination on principle. I just don't use it in my own projects. But if anyone ever comes up with a particularly compelling solution, I'd happily welcome a PR."
haskell,3ccglr,duplode,9,Mon Jul 6 20:52:52 2015 UTC,"The short tale of how I got over a pet peeve - that Applicative laws did not seem to have a presentation as neat as that of the Monad ones using (<=<). I'm quite certain the resulting presentation of Applicative in terms of static arrows is already well-established (even if there is no popular literature about it) though not terribly useful (which explains why there is no popular literature about it). In any case, it is a fun thing to know about.  (Link fixed, thanks /u/dougmcclean .)"
haskell,3ccglr,imz,5,Mon Jul 6 20:54:44 2015 UTC,"Very interesting.  I wonder whether that's really true:   I do not think there will be many opportunities to use the Starry methods in practice. We are comfortable enough with applicative style   I've recently have been adding an Applicative (like a Reader) to my pure code, wanting to restructure it as little as possible (and write everything in at most applicative style, without do and monads -- simply because coming up with a Monad instance for my Reader-like wrapper around the computations was not obvious). And have been struggling a lot with the pieces of code where a function a -> b should become MyReader (a -> b) (with injecting calls to the ""language"" of MyReader inside the code) or even MyReader (a -> MyReader b).  You see, I can't name the argument of the function because it's inside the MyReader. So I have to write in point-free style (which is complicated by that the function is not linear, i.e., uses its argument more than once in the code). And in order to mix pure function composition and what would be <*> and <$> in ""point-full"" style, I had to rely on a Compose MyReader (a ->) instance. (This also gave the convenience that I could easily shuffle the order of layers, if I found out that the injected calls to MyReader should really depend on the function argument.) But it seemed too difficult to understand the code at the end (partly because of switching the semantics of the applicative operators between the MyReader applicative and the Compose ... applicative when going from one piece of code to another.)  Perhaps, the Starry style would help me in this situation... I have yet to think about it. (O I'm mistaken.)  Perhaps, I could also make the code more clear by using a Category instance and <<</>>>... (And also explore what http://hackage.haskell.org/package/transformers-compose-0.1/docs/Control-Monad-Compose-Class.html and monadLib-compose give.)"
haskell,3ccglr,mjmrotek,5,Tue Jul 7 08:15:49 2015 UTC,"though not terribly useful    Well, there is also the formulation in terms of a lax monoidal functor, as described in the Typeclassopedia. It also seems to generalize better, for example to (shameless self insert) mutable references.   But your version is interesting too, actually, I think you can easily get an Arrow (as in a type class instance, not the category theory concept) from functions of type (Applicative f => f a -> f b), though I'm not sure if you can get back to Applicative then."
haskell,3ccglr,imz,3,Tue Jul 7 09:46:32 2015 UTC,"It'd be interesting to see what doesn't work out for mutable reference when we try to define an Applicative instance.  In order to understand better where and why in general a ""lax monoidal functor"" formulation fits more naturally, than Applicative.  I've also had an experience where I had to overcome the feeling that defining the Applicative <*> (as opposed to pairing) was very unnatural for my functor. It had to do with that it was like a functor which added annotations to computations (perhaps, can be thought as an additional Const layer if I'm not mistaken about Const; perhaps, Writer-like, or Reader/RWST-like if extended a bit).  Const itself feels very unnatural in the form of Applicative..."
haskell,3ccglr,mjmrotek,3,Tue Jul 7 11:30:14 2015 UTC,"It'd be interesting to see what doesn't work out for mutable reference when we try to define an Applicative instance.   Well first of all, mutable references can't even have a Functor instance in Haskell, because it's not enough  to have a single function to map between references. There must be some way to update the old value with the new one, and that's precisely a lens. Though the mapping  zoom :: Lens' a b -> TVar a -> TVar b   might be a functor, as lenses also form a category. When I was writing my package I haven't thought about the applicative-like mapping  app :: TVar (Lens' a b) -> TVar a -> TVar b   and I'm not sure how does it relate to  pair :: TVar a -> TVar b -> TVar (a,b)   and the ""zoom"" above, but  zoom' :: Lens' (ALens' a b, a) b zoom' k (l,a) = f <$> k (a^#l)     where f b = (l, a & l #~ b)   seems to be okay, though I'm not sure how to go the other way around. Perhaps my version doesn't really generalize better, and it was just my oversight."
haskell,3ccglr,twanvl,7,Tue Jul 7 14:32:20 2015 UTC,"Another alternative formulation of Applicative is in terms of a zip like operation:  class Functor f => Zippy f where   unit :: f ()   zip :: f a -> f b -> f (a,b)   with the laws  zip x unit = fmap (,()) x zip unit y = fmap ((),) y zip (zip x y) z = fmap assoc (zip x (zip y z))   If I understand category theory well enough, this is saying that f is a lax monoidal functor. See also this stack overflow question"
haskell,3ccglr,willIEverGraduate,5,Tue Jul 7 09:44:23 2015 UTC,"What if we had Contravariant functors as the superclass?  I'm thinking of something like:  import Data.Functor.Contravariant  class Contravariant f => Zippy f where     unit :: f ()     zip :: f a -> f b -> f (a, b)  newtype Effect a = Effect (a -> IO ())  instance Contravariant Effect where     contramap f (Effect io) = Effect (io . f)  instance Zippy Effect where     unit = Effect $ const $ return ()     zip (Effect io1) (Effect io2) = Effect $ \ (a, b) -> io1 a >> io2 b   with analogous laws:  zip x unit = contramap fst x zip unit x = contramap snd x zip (zip x y) z = contramap assoc' (zip x (zip y z))   This ""Zippy"" definition seems to extend to contravariant functors, while the standard Applicative definition with pure and <*> is impossible.  I'm not an expert on these things by any means, so... does the above make any sense at all? Does it have a name? Could it be useful?"
haskell,3ccglr,sacundim,6,Wed Jul 8 02:42:58 2015 UTC,"IMHO the friendliest presentation of Applicative and its laws is E.Z. Yang's Monoidal class, which this post links as well and remarks (footnote 1):   While the laws in this formulation are much easier to grasp, Monoidal feels a little alien from the perspective of a Haskeller, as it shifts the focus from function shuffling to tuple shuffling.   I wouldn't call it ""alien,"" though.  The key concept that ties Applicative and Monoidal is currying, which you do need to grasp a little bit to master Haskell.   But my main point here is this: after studying free applicative functors, I did manage to develop an intuition for the canonical presentation of the Applicative laws.  The key idea here is that any value in an applicative functor can be written in the form:  f <$> a1 <*> ... <*> an   ...where a1 ... an are actions drawn from some set of minimal ""atomic"" actions appropriate for the given functor, and f is some function that takes their results.  This corresponds to one of the popular intuitive explanations of the difference between Applicative and Monad:    Monadic computations have the power to inspect the results of actions and use information from them to choose the next action; With Applicative computations on the other hand, the actions are statically predetermined, and all that Applicative can do is combine their results with statically predetermined functions.   So seen from this lens, the canonical Applicative laws are the rewrite rules that you need to rewrite any free-form applicative computation term into the f <$> a1 <*> ... <*> an form: a list of actions (heterogeneous on the result type) and a function to combine their results."
haskell,3ccglr,tomejaguar,3,Tue Jul 7 20:02:12 2015 UTC,"I wouldn't call it ""alien,"" though. The key concept that ties Applicative and Monoidal is currying, which you do need to grasp a little bit to master Haskell.    Sure. The ""a little alien"" comment was from a more operational/immediate convenience perspective, in the spirit of this quote from the Monoidal post:   It seems that there is a general pattern where the API which has nice formulations of laws is not convenient to program with, and the formulation which is nice to program with does not have nice laws.   Your rewrite rules intuition, on the other hand, is one that is pretty clear from an operational perspective."
haskell,3ccglr,tomejaguar,4,Tue Jul 7 21:32:45 2015 UTC,"I tried to prove this once but I didn't manage it.  Congrats for working it out!  Has anyone written down the proof before, or are you the first?"
haskell,3ccglr,tomejaguar,1 point,Mon Jul 6 22:10:52 2015 UTC,"Thank you. I would be very surprised if this had never been put down on paper before, even though I wasn't able to unearth it."
haskell,3ccglr,gergoerdi,3,Mon Jul 6 22:32:12 2015 UTC,So it seems that in the Stack Overflow answer that /u/gergoerdi linked I stated that Wadler et al. proved that an Applicative is equivalent to an Arrow arr with isomorphism arr a b ~ arr () (a -> b).  You seem to have claimed something stronger: all you need is a Category.
haskell,3cb7ed,edsko,2,Mon Jul 6 15:30:48 2015 UTC,"This seems great!  One question though, somewhat unrelated to this post, but mentioned in it. Historically, why has base shifted versions? What caused base-3.x to be changed to base-4.x? What might cause us to want to switch to base-5.x?"
haskell,3cb7ed,NiftyIon,5,Mon Jul 6 16:19:23 2015 UTC,"Significantly incompatible changes, as in the majority of packages no longer built. One was splitting syb out of base. Another major change I remember was the switch to new style exceptions. I'm sure there were other changes too."
haskell,3cb7ed,dcoutts,2,Mon Jul 6 16:28:49 2015 UTC,How painful was it? Would something like that be much worse to pull off now? (I am thinking of the discussion about filepaths and how someone mentioned that there wasn't a consensus on whether many small changes or fewer larger changes were preferable.)
haskell,3cb7ed,NiftyIon,4,Mon Jul 6 18:45:03 2015 UTC,"The 3.x -> 4.x change was much less painful than the 2.x -> 3.x change. The 2.x -> 3.x change was done as a bang and everyone complained. The 3.x -> 4.x change was pretty good. Everything still worked and then people could change from 3 to 4 at their own pace, and critically there was no need for all packages to change at once. So yeah, it worked rather well."
haskell,3cb7ed,dcoutts,1 point,Mon Jul 6 21:08:51 2015 UTC,Would something like the base3/4 scheme have worked for the superclass-changing AMP?
haskell,3cb7ed,hagda,3,Tue Jul 7 12:27:45 2015 UTC,"I don't think it would. The crucial thing with two base versions is that the types are the same, so base3:Int is the same type as base4:Int, which means that you can depend on one package that uses base 3 and another package that uses base 4.   With AMP, if base 5 had had the new Monad class, then what would base 4 provide? It can't re-export the base 5 Monad class, and it cannot really define a new one that lacks the superclass (because then you couldn't mix packages using base 4 with those using base 5). So no, you'd need some additional trick to make that work (like superclass defaults)."
haskell,3cat88,rorriMnmaD,15,Mon Jul 6 13:31:14 2015 UTC,"There are great libraries for doing most of those. There's a lot less boiler plate with Haskell frameworks but they are much more difficult to learn to use. If you're just getting started, scotty or spock are good minimal frameworks that are not ""too magical"", like Yesod or servant might be."
haskell,3cat88,ephrion,6,Mon Jul 6 14:17:40 2015 UTC,"If you're just getting started, scotty or spock are good minimal frameworks that are not ""too magical"", like Yesod or servant might be.    To explain this a little more, Yesod uses Haskell's macro system (called 'Template Haskell') to autogenerate a lot of the routing code, as well as to provided templating of html, css, etc.  This makes the haddocks (the Haskell version of JavaDocs or RubyDocs) much less useful, since you're mostly not programming in Haskell but in the language defined by the macro.  I'm not sure if there's a good documentation source for heavily macro-based libraries like Yesod other than e.g. the Yesod book - if there is, I haven't found it yet."
haskell,3cat88,pipocaQuemada,1 point,Mon Jul 6 15:35:47 2015 UTC,"This makes the haddocks (the Haskell version of JavaDocs or RubyDocs) much less useful, since you're mostly not programming in Haskell but in the language defined by the macro   This made me pause and think for a while, and then I did some analysis.  b@fuzzbomb (~/src/Haskell/snowdrift) (master) $ wc templates/* config/models config/routes | tail -n 1   3807  10233 112870 total b@fuzzbomb (~/src/Haskell/snowdrift) (master) $ git ls-files '*.hs' | xargs wc |tail -n 1  20340  82071 789126 total   20,000 lines of Haskell versus 3800 lines of not-Haskell. Of the not-Haskell, fully 2900 are templated versions of html and css, and I'm on the fence about the fairness of adding them to this comparison.  In summary, even a Yesod-based project is mostly (84%-96%) just Haskell.  Having said that, I think there is a strong need for better tools regarding the templating in Yesod. I want to generate a tags file that knows that 'getRouteR' is ""defined"" on a particular line in config/routes!"
haskell,3cat88,chreekat,11,Wed Jul 8 18:36:10 2015 UTC,"Take this with a grain of salt as I am still a Haskell newb myself.  If you are familiar with ActiveRecord, persistent is a similar idea. It can take care of the CRUD operations for you.  There is also esqueleto which I believe is meant to be similar.  As for web frameworks, you have yesod which I hear most people referring to as the most rails-like framework in Haskell. There is also snap, which people relate to sinatra. happstack is unlike the other frameworks, I believe it is also the oldest. There is also scotty which to me seems the most Sinatra like. And finally there is spock which appears to be another Sinatra-esque framework.  If you are just building an API to produce JSON or something, servant looks really interesting. However, I have also heard that it is a fairly high entry barrier.  Keep in mind there are probably a fair few more web frameworks worth looking at in Haskell. These are just the ones that I have had referred to me in the past.  Note: I've not done anything serious in any of these packages. I've really only followed along with the tutorials."
haskell,3cat88,Ankhers,8,Mon Jul 6 13:52:36 2015 UTC,"Regarding servant: I needed a very simple API for an android app and the tutorials are pretty comprehensive. I put what I wrote on github.  Take a look at the src/Main.hs file for the whole API ( ~90 LOC) , I only needed 3 routes but it's worked out great so far."
haskell,3cat88,Untrothy2,3,Mon Jul 6 14:36:39 2015 UTC,You are creating a new database connection on every request! That can't be a good example template. Did you find it difficult to keep state across requests?
haskell,3cat88,glutamate,1 point,Mon Jul 6 21:41:00 2015 UTC,I'm pretty much a novice at haskell. I didn't even think of trying to keep state across requests.   I just linked to the github repo to show that writing a simple (but not very efficient apparently) API with servant isn't very complicated.  I'll see if I have some time to try and make it faster.
haskell,3cat88,Untrothy2,1 point,Tue Jul 7 06:49:09 2015 UTC,Checkout https://github.com/codygman/servant-persistent-benchmarks/blob/master/src/Main.hs
haskell,3cat88,codygman,1 point,Tue Jul 7 18:47:59 2015 UTC,You are creating a new database connection on every request! That can't be a good example template. Did you find it difficult to keep state across requests?    Here's an example of using a database pool with Servant and Persistent:  https://github.com/codygman/servant-persistent-benchmarks/blob/master/src/Main.hs
haskell,3cat88,codygman,1 point,Tue Jul 7 18:47:23 2015 UTC,Here's another example of using servant with persistent.
haskell,3cat88,theonlycosmonaut,2,Tue Jul 7 23:30:17 2015 UTC,"There is also esqueleto which I believe is meant to be similar.   Esqueleto works with persistent, but provides a more detailed set of primitives for querying SQL databases. Persistent can use redis, mongodb etc. as backends, but as a consequence, doesn't have an API for joins. Esqueleto limits itself to SQL backends, but lets you express more query types."
haskell,3cat88,theonlycosmonaut,10,Tue Jul 7 23:28:45 2015 UTC,"From what I've seen from beginners, learning Haskell through a project like this is a very frustrating experience. I would suggest at the very least following one of the courses aimed at teaching you Haskell before trying out one of the web frameworks.  Other than that, Haskell is very very well suited for the task."
haskell,3cat88,srhb,7,Mon Jul 6 15:12:02 2015 UTC,"I am Haskell beginner myself and I have some experience playing with Yesod. I started using servant recently and very much like it. If you are new to the Haskell world and want to use servant, I would highly recommend /u/ephrion's post about using Persistent and Servant. Just clone the GitHub repo and start writing your own handlers. Once you get the hang of it, customize Matt's code.   If you are building a full blown site, I would recommend Yesod as it comes with bells and whistles but for REST Api, I like servant's simplicity.   Persistent is nice but it is fairly limited to single table access. You will have to use esqueleto for joins and other db specific functionalities. That said, when I had almost no knowledge of Haskell, trying to use esqueleto was not fun -- the type errors was just impossible to decipher and figuring out type annotations took me really long time.    Anything simple (not pulling is 100s or records), these days I just use Persistent and then do manual joins -- most of the times, it is fine and when I start to write 10+ lines of code which will be a simple join, i resort to esqueleto. This Yesod Book article will be useful."
haskell,3cat88,lleksah15,5,Mon Jul 6 15:00:00 2015 UTC,"What am I getting myself into trying to write a REST API with a haskell framework? (I don't know haskell, but am very interested)   A fun learning experience. Surly what you want to do is possible with Haskell, and not even that hard. But as you have probably already noticed there is a learning curve to Haskell that is steeper than, lets say, learning Ruby when you already know Java.   Like I said, I don't mind if it costs me extra time since I'm learning, but what are we talking here?   I'd advise you to learn Haskell basic by first making a non-networked app. I think Chris-bitemyapp-Allen's advice on how to start is great. Basically, don't use Haskell Platform, and start with the cis194 course.  Once that course is done you will be --in my opinion-- good to go with making a basic API server. Search this subreddit for discussions on the best REST API libraries, as there are a few. Maybe you want to try out more then one before deciding the on the lib to use for your work projects."
haskell,3cat88,cies010,6,Mon Jul 6 14:46:28 2015 UTC,"Is this going into production? If so, and your time-table isn't above 6 months, don't do it. Seriously - Don't. I might say otherwise for someone coming from FP, but that's about how long it takes before you can produce anything of remote quality - and that's if you're good. 1 month basics of type system, 2 months in monads + typeclassopedia applicaton, 2+ more months in editor tooling and full acquisition of the paradigm. Perhaps another month on top of that if you want to write monads as well. The Haskell community is filled with savants that will tell you otherwise, but this is quite realistic for a non-FP'er that is just starting."
haskell,3cat88,slowkill82,3,Mon Jul 6 22:42:40 2015 UTC,"In my experience, it is possible to get a person with some CS background in some FP language like Scheme, and get them productive in Haskell in a month. However; that is only possible with very close mentoring, pair programming, meetings every other day to get them unstuck, etc.   What I'm trying to say is that learning on your own without having somebody to talk to (or at least some meetup to attend) will take you much longer and the timetable proposed by /u/slowkill82 is optimistic to get something production-ready."
haskell,3cat88,mallai,2,Tue Jul 7 13:16:34 2015 UTC,"Well, it's not what I wanted to hear, but I appreciate this sub giving straight answers"
haskell,3cat88,meem1029,1 point,Tue Jul 7 15:33:30 2015 UTC,"I appreciate the straight advice.  What is FP/FPer?  Doing my own research, combined with your comment I've decided to learn haskell on a hobby-project, and develop my more important stuff with node/rails because they are so simple"
haskell,3cat88,htoov,4,Tue Jul 7 03:04:38 2015 UTC,"I think that's a good plan.   You can likely do something equally good or better in Haskell than ruby, but not if it's your learning project."
haskell,3cat88,theonlycosmonaut,2,Tue Jul 7 09:46:17 2015 UTC,Functional Programming
haskell,3cat88,pyr,1 point,Tue Jul 7 03:19:21 2015 UTC,/Functional Programmer
haskell,3cb79z,Darwin226,7,Mon Jul 6 15:29:49 2015 UTC,"I suspect most of the performance improvements you're seeing are due to using intermediate arrays, and not from any secret sauce radix sort magic.  See http://lpaste.net/136015 for an example of another sort that beats the default sort by a large margin, just by copying everything into an array and sorting it there.  sort :: Ord a => [a] -> [a] sort xs = Vec.toList $ runST $ do     let l = length xs     arr <- MVec.new l     _ <- drain l xs arr     I.sort arr     Vec.unsafeFreeze arr   My results:  -7212132088802539410 ""local"" -7212132088802539410 CPU time:   0.64s ""Standard"" -7212132088802539410 CPU time:   4.27s"
haskell,3cb79z,frud,2,Mon Jul 6 18:18:06 2015 UTC,"Indeed, I've later written an inplace quicksort and it performs really well. I would like to see if I can further optimize the radix sort to beat it but the asymptotics were only the reason I started looking into it. It wasn't really my goal to show that it's faster than some other implementation."
haskell,3cb79z,frud,6,Mon Jul 6 18:31:38 2015 UTC,"The asymptotics are fishy anyway.  People get all hot and bothered about radix sort on fixed size ints being O(n), but that's just wrong.  Radix sort on fixed size ints is O(nw) where w is the size of the int type, and w >> log(n) in every practical example."
haskell,3cb79z,sclv,7,Mon Jul 6 18:36:37 2015 UTC,w is a constant.  log(n) is not.  how the heck is that fishy.
haskell,3cb79z,winterkoninkje,6,Mon Jul 6 19:59:19 2015 UTC,"Well, it's fishy in the sense that w is only ""constant"" if we always use exactly one int type. Which means, that as soon as we switch to dynamically picking different int types, w is no longer ""constant"". This is the thing most folks forget about asymptotic analysis: ""constants"" aren't.  For example, HMM tagging is often quoted as being /O(n)/ where /n/ is the length of the sequence to be tagged. But once you step into the real world (e.g., natural language processing which uses HMMs) you quickly realize that calling it /O(n)/ is, at best, an unhelpful white lie. The actual complexity of first-order HMM tagging is /O(T2*n)/ where /T/ is the size of the tagset. While the tagset can be assumed constant for a particular fixed dataset, it is not at all constant when working with multiple datasets or multiple annotation schemes for the same dataset. In practice, the /T2/ component almost invariably dominates the /n/ component; thus, calling it /O(t2)/ has far more predictive value."
haskell,3cb79z,julesjacobs,2,Mon Jul 6 22:31:10 2015 UTC,"Good point in general, but note that in this case the log factor is still there even if w is not constant. Radix sort is O(wn) and comparison sort is O(wn log n)."
haskell,3cb79z,rpglover64,1 point,Tue Jul 7 12:31:11 2015 UTC,"/O(T2*n)/   That should be read as /O(T2*n)/, right? Apparently wrapping the thing being super-scripted in parentheses fixes the annoying superscripting everything that follows:     /O(T^(2)*n)/"
haskell,3cb79z,winterkoninkje,1 point,Tue Jul 7 13:24:15 2015 UTC,"Oof, yes! Thank ye kindly"
haskell,3cb79z,frud,2,Wed Jul 8 23:24:26 2015 UTC,"w is a parameter, not a constant."
haskell,3cb79z,sclv,5,Mon Jul 6 21:03:03 2015 UTC,"but you said ""fixed size ints"" and ""w is the size of the int type."" so w is fixed. to be the size of the int type. which is fixed."
haskell,3cb79z,frud,5,Mon Jul 6 21:21:28 2015 UTC,"On any particular machine, w is fixed.  When talking about radix sort in general, w is a parameter.  Also, I'd like to defer to wikipedia"
haskell,3cb79z,dalaing,3,Mon Jul 6 21:33:15 2015 UTC,"When comparing two radix sorts with different values for w on the same machine, w is relevant.   When w is fixed for a given machine, and you're using the asymptotics to compare radix sort to other sorts in a machine independent manner, then the w is a constant that goes away. Otherwise you'd have constants fit for clock speed in there as well.   Context matters :)   Edit: Gah, that's more or less what you said.  I thought I was responding to ""w is a parameter, not a constant"" - that's what I get for typing a comment on my phone while on the train :)"
haskell,3cb79z,edwardkmett,6,Mon Jul 6 22:37:19 2015 UTC,"and w >> log(n) in every practical example.   This doesn't fit with my experience.  It comes down to the fundamental question of why we are sorting?  Are we sorting because we know absolutely nothing about the order of the data we're given? Or are we sorting because it isn't quite in the right order?  In the former case stability buys us nothing, so we heavily encumber our sort with having to distinguish every single bit of information in the source some how in the interest of determinism. There? Sure, your assumption of w >> log n is likely true. Every sort must pay at least the sum of the lengths of the longest common prefixes between adjacent keys in the result worth of work, which is potentially a bit smaller.  But the very reason I like to use stable sorts is because almost every data source I have will spit out my data in some order, it just may not be exactly the one I want.   I may want to regather it stably by employee, or trades by whether they are long/short, etc. This is typically far fewer bits of stable re-sorting than there are records in the data I'm re-organizing!  Given how much of my day to day existence is consumed by problems precisely of this sort, we seem to have fundamentally different experiences on this front.  I use stable radix-like sorts, hash-joins, etc. when appropriate because they let me exploit that reduction in problem size whenever log n does happen to be σ or whenever it might. Any sort will pay a cost that is at least the permutation entropy between the two orders. Then we just need to analyze the cost of keeping the data indexed in the right order against the cost of paying the appropriate permutation cost when asked based on whatever our problem is.  Using a radix sort is just one tool in the toolbox for getting closer to that optimal permutation entropy bound.  Your argument is grounded in the fact that there are cases where the radix sort must devolve to the same bound as a symbol-wise comparison sort, (random strings, etc.). Mine is grounded in the fact that there are cases where a stable radix sort wins over any stable-or-unstable symbol-wise comparison sort.  These two claims are not mutually contradictory."
haskell,3cb79z,frud,2,Mon Jul 6 23:38:20 2015 UTC,"My main beef with the rah-rah over radix sorts is that they don't do much for you when you're sorting fixed size ints, but people use the fixed size of int to then claim radix sort over them is O(n).  Radix sort is great when dealing with larger lexicographic types, because the cost of comparison can become so much larger."
haskell,3cb79z,edwardkmett,2,Tue Jul 7 01:01:07 2015 UTC,"The detailed claim I make about a radix sort is that irrespective of word size w = σ^k, for any set of strings S, using σ buckets at a time, an MSD radix sort is O(ΣLCP(S) + n log σ) while the bound on symbolwise comparison-based sorting is Θ(ΣLCP(S) + n log n), where ΣLCP(S) is the length of the longest common prefixes of neighbors in the final sorted result.  What is increasing when you raise the word-size is w (and k), not σ.  Depending on ΣLCP(S) this may be a win, only caring about the distribution of strings in S, not the original order, while every comparison sort (even symbolwise) must always pay full price.  So to turn your phraseology back on you, my main beef with folks who dismiss radix sorts is that they say ""well it doesn't win in every case so hrmmph."" =)"
haskell,3cb79z,edwardkmett,3,Tue Jul 7 01:26:14 2015 UTC,I'm really not trying to extend the argument but I would appreciate some clarification. You seem to agree that the complexity depends on the number of buckets you choose. Wikipedia seems to have the number of buckets fixed to 2 and even uses that to claim that even in the best case w > n log n. What am I missing?
haskell,3cb79z,frud,2,Tue Jul 7 07:34:54 2015 UTC,"The wikipedia complexity article is making a very large assumption. It is assuming you'll never actually use stability to exploit your existing order, and that you'd never try to partition your data on less than something capable of distinguishing all of it.  The very point of having a stable sort is that these properties are available for your use.  When you don't need stability you can get better constant factors. e.g. American Flag sort is an unstable radix sort variant that is typically 2x faster."
haskell,3cb79z,edwardkmett,2,Tue Jul 7 15:47:28 2015 UTC,"I'm not sure, but I think we're violently agreeing with each other."
haskell,3cb79z,frud,2,Tue Jul 7 01:36:08 2015 UTC,I violently agree.
haskell,3cb79z,frud,3,Tue Jul 7 01:40:12 2015 UTC,"I never actually understood that. w is only the size of the int type (if by size you mean the number of bits) if you use two buckets, but why would you use two buckets? I chose 256 of them so as far as I understand my algorithm (and profiling also shows that) iterates through each element 8 times. That's less than log n for n > 256."
haskell,3cb79z,autowikibot,2,Mon Jul 6 20:59:36 2015 UTC,"big-O is defined within a constant of proportionality.  A 256-bucket radix sort chomps 8 bits at a time, and a 2-bucket radix sort chomps 1 bit at a time, so that's just a difference of a constant factor of 8 in the end.  So 2 buckets vs. 256 buckets is the same thing in this context.   That's less than log n for n > 256.   Sort a list of two 128-bit integers.  A straightforward comparison sort requires only one operation and one swap.  An 8-bit radix sort would require as many as 16 128-bit swaps, plus whatever overhead is required to manage the 254 idle buckets on each of the 16 iterations."
haskell,3cb79z,edwardkmett,2,Mon Jul 6 21:12:35 2015 UTC,"Exactly, that why n has to be more than 256. Let's say n = 216 and we're sorting 64bit integers. nlogn sort will do 16 * 216 comparisons/swaps, while radix sort will only do 8 * 216 + 8 * 256.  You could make the argument that you radix loses out when we increase the number of bits in the integer but I'm pretty sure comparing two 128bit numbers will be twice as slow as comparing two 64bit ones.  256 buckets and 2 buckets is not the same thing in this context since the w parameter describes exactly that number."
haskell,3cb79z,frud,3,Mon Jul 6 21:29:29 2015 UTC,"I think we're getting our terminology, contexts, and basic computer science principles confused.  I'm just going to punt here and defer to wikipedia"
haskell,3cb79z,edwardkmett,2,Mon Jul 6 21:42:33 2015 UTC,"Section 1. Efficiency of article  Radix sort:       The topic of the efficiency of radix sort compared to other sorting algorithms is somewhat tricky and subject to quite a lot of misunderstandings. Whether radix sort is equally efficient, less efficient or more efficient than the best comparison-based algorithms depends on the details of the assumptions made. Radix sort complexity is O(wn) for n keys which are integers of word size w. Sometimes w is presented as a constant, which would make radix sort better (for sufficiently large n) than the best comparison-based sorting algorithms, which all perform O(n log n) comparisons to sort n keys. However, in general w cannot be considered a constant: if all n keys are distinct, then w has to be at least log n for a random-access machine to be able to store them in memory, which gives at best a time complexity O(n log n).  That would seem to make radix sort at most equally efficient as the best comparison-based sorts (and worse if keys are much longer than log n).     Relevant: American flag sort | Counting sort | Sorting algorithm | Bucket sort   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3cb79z,julesjacobs,2,Mon Jul 6 21:45:21 2015 UTC,"""If all n keys are distinct"" is the key claim (no pun intended) in that article."
haskell,3cb79z,mbruder,2,Mon Jul 6 23:48:13 2015 UTC,"That implies w > log(n).  So wn > n log(n).  Which implies radix sort is not faster than a good comparison sort (within a constant factor, also with comparison cost being O(1))"
haskell,3cb79z,mbruder,3,Tue Jul 7 01:05:50 2015 UTC,"My point above is that in many of the applications I have for a radix sort, I'm not using the radix sort to sort a whole key, but rather to sort stably by part of it, so the w > log n assumption is a big assumption."
haskell,3cant7,Ramin_HAL9001,26,Mon Jul 6 12:35:07 2015 UTC,"I teach Haskell courses and one of the issues that repeats every year is difficulties with deeply nested expressions. For a beginner   sbf = concat . sortBy (comparing length) . group . sort   Is pretty much indistinguishable from  sbf = concat . sortBy . comparing length . group . sort   Or any such variation, whereas the more ugly  sbf xs  = let              runs = group (sort xs)             orderedRuns = sortBy compareByLength runs             result = concat orderedRuns              compareByLength a b = compare (length a) (length b)           in result    is often understood more easily. (Also, you can add types to the latter if necessary)  Also, in my experience, where beginners fall, experts may stumble."
haskell,3cant7,aleator,8,Mon Jul 6 12:55:08 2015 UTC,"Yep this is something I struggle with. The only way I can decipher those concatenated expressions is by constantly checking the type of the expression I've written so far using :t in GHCi. Even then, when it all fits together, it still seems like voodoo to me."
haskell,3cant7,jgcoded,10,Mon Jul 6 14:12:01 2015 UTC,"Why do you find it harder when written separated by (.) than when separated by newlines? What is added by meaningless or redundant variable names, like ""x"" or ""y"", or like some variation on the name of the function itself?  When it's not clear what one or more of the steps is doing, I can understand splitting it up and binding intermediate results to a variable whose name adds information. That is a good kind of documentation, and I do that. But otherwise? Why not write it in the simpler and clearer style?  This is just a matter of getting used to the notation - which isn't hard and doesn't take long. It's just much different than what programmers from traditional imperative languages are used to.  I definitely do not write inferior less clean code just to appease a beginner who hasn't yet spent the five minutes to learn about function composition. And I do not appreciate having to read code written by people who do that."
haskell,3cant7,yitz,3,Mon Jul 6 17:46:34 2015 UTC,"and for newlines, you can always:  sbf  = concat  . sortBy (comparing length)  . group  . sort"
haskell,3cant7,sambocyn,3,Mon Jul 6 19:49:37 2015 UTC,"Put four spaces in front of your code to prevent the markdown parser from prettifying it for you.  Alternately, put two spaces at the end of a line to prevent the markdown parser from joining two lines together."
haskell,3cant7,dmwit,1 point,Tue Jul 7 03:21:09 2015 UTC,"Here's an example: how I implemented a combinations generator. As you can see, I have very strong roots with imperative languages. After making that, I wondered how others did it. This was one of those one liners that are super elegant. I was blown away when I saw that because it was so simple. It's coming up with those simple concatenated one-liners that I find difficult to do."
haskell,3cant7,jgcoded,2,Mon Jul 6 22:54:48 2015 UTC,"I think this function is the same as the powerset function, so I have to share this with you:  filterM (const [False ..])"
haskell,3cant7,twistier,7,Tue Jul 7 03:17:55 2015 UTC,"Okay, that's pretty awesome, but...   [False ..]   ...I think this qualifies as ""too clever."" [False,True] is only two more characters and considerably clearer."
haskell,3cant7,tejon,1 point,Tue Jul 7 04:53:06 2015 UTC,"I don't think it's so unclear. It's documented and, I thought, well known. I would avoid using it when teaching a beginner, of course, but I'm guessing you are not talking (only) about that."
haskell,3cant7,twistier,1 point,Tue Jul 7 12:46:46 2015 UTC,"TBH I think most beginners could figure out what it means. That's not my issue. The extra thought, ""...oh, right, Bool has an Enum instance,"" is an extra thought. It takes longer than simply recognizing a symbol. Every moment like that makes reading code a little slower. If we were talking about an enumeration with more than two or three members, the savings from making the code shorter and easier to scan would likely be worth it; ..] is perfectly useful notation in general. But in this (very specific!) case, it really isn't.  Edit: In fact, this is literally a matter of evaluating a thunk vs. normal form. When you know for a fact that you've only got one operation and you're going to require it, laziness probably isn't the best choice. :)"
haskell,3cant7,tejon,1 point,Tue Jul 7 19:43:28 2015 UTC,Wow that is cool! How did you come up with that?
haskell,3cant7,jgcoded,3,Tue Jul 7 03:28:43 2015 UTC,"I can't take credit for it. It happens to be known around some parts of the community.  Anyway, it can be read in English as ""for each element in the list, generate results both excluding and including it."""
haskell,3cant7,twistier,10,Tue Jul 7 03:50:23 2015 UTC,"As I have matured in my Haskell writing, I have actually started writing what I perceive to be more ""beginner friendly"" code for the reason you mention. If I have to choose between  zip [1..] (lines log)   and  zip [1..] $ lines log   I will pretty much always choose the former. I rarely, if ever, use dollar signs for ""parentheses avoidance"" these days except for when I'm using functions that look like control structures. It is for example not odd for me to do  parseLog log =     fromList $ do         (i, line) <- zip [1..] (lines log)         rights [fmap (reqIdL .~ i) (parseOnly parseLine line)]   (As can be seen in that example, I also have started preferring fmap over <$> unless the latter really does make the code nice.)  I'm also writing a lot more of  gravity entity =     if entity ^. entityFalling then         entity & entityYSpeed +~ 1     else         entity   over  gravity entity =     entity & if entity ^. entityFalling then entityYSpeed +~ 1 else id   or even worse  gravity =     bool (entityYSpeed +~ 1) id =<< view entityFalling   or whatever weird incantation it could be defined as."
haskell,3cant7,kqr,7,Mon Jul 6 16:06:50 2015 UTC,Why not guards?  gravity entity   | entity ^. entityFalling = entity & entityYSpeed +~ 1   | otherwise = entity
haskell,3cant7,Peaker,3,Mon Jul 6 21:59:26 2015 UTC,That would actually look better in this case. Not sure why I didn't think of that. Thanks!
haskell,3cant7,kqr,2,Mon Jul 6 22:17:17 2015 UTC,"Personally I've always preferred the style of  gravity entity =     if entity ^. entityFalling         then entity & entityYSpeed +~ 1         else entity   since my if-then-elses in Haskell often have 1 line, but if they do have more than one line:  fastGravity entity =     if entity ^. entityFalling         then do             entity & entityYSpeed += 1             entity & entityYSpeed += 1         else             entity   would be better IMO.  I don't do this in any other language, strangely, if I'm using a C-like language I put the open brace on the same line as the if.  I'd say the reason why I prefer it this way in Haskell is because the then and else are logically contained in the if, and therefore should be more indented, but just indenting else looks ugly."
haskell,3cant7,bheklilr,2,Mon Jul 6 19:11:29 2015 UTC,"That's generally how I do it too, though particularly short things I'll sometimes squeeze into one line. I haven't yet decided whether I prefer indenting then and else, though; if doesn't actually require it and, being the same length, they still create a nice flow even if you keep them all at the same level:  gravity entity =   if entity ^. entityFalling   then entity & entityYSpeed +~ 1   else entity   Edit: This is probably related to my preference for two-space indentation, now that I think about it; then and else are both two characters longer than if so it just looks right to me as-is."
haskell,3cant7,tejon,1 point,Tue Jul 7 05:00:14 2015 UTC,That's mostly a matter of indentation and line breaks though. It's exactly the same code otherwise. :)
haskell,3cant7,kqr,1 point,Mon Jul 6 19:33:52 2015 UTC,"Of course, this is a discussion thread about style, though.  I'm just sharing my slight permutation on valid haskell syntax ;)"
haskell,3cant7,bheklilr,2,Mon Jul 6 19:39:01 2015 UTC,Fair enough. I was focusing on differences that would still be visible after lexing. Hence my confusion!
haskell,3cant7,kqr,4,Mon Jul 6 19:52:24 2015 UTC,"Perhaps ""at all costs"" is too strong an expression."
haskell,3cant7,josuf107,12,Mon Jul 6 13:13:47 2015 UTC,"Maybe weaken to ""avoid (naming at all costs)"""
haskell,3cant7,mjmrotek,3,Mon Jul 6 16:07:13 2015 UTC,sbf = concat . sortBy (comparing length) . group . sort   Is pretty much indistinguishable from  sbf = concat . sortBy . comparing length . group . sort    But the second one won't typecheck. What is the problem?
haskell,3cant7,ocharles,11,Mon Jul 6 14:03:50 2015 UTC,"Understanding why it doesn't type check is presumably the problem. A big pain point of learning anything (in terms of programming) is when your expectations don't match up with the compiler's interpretation. To the beginner, they may read the two as equivalent, but in reality they are very different. Understanding that can be hard work."
haskell,3cant7,htebalaka,4,Mon Jul 6 14:26:40 2015 UTC,"Rather than naming the intermediate variables in the pipeline I prefer  sbf = concat . sortByLength . group . sort     where         sortByLength :: [[a]] -> [[a]]         sortByLength = sortBy (comparing length)   IOW, giving names (and types) to intermediate functions rather than intermediate variables. Intermediate functions can be independently tested, and the types are useful documentation to the user and the compiler. Anything worth giving a name is worth knowing the type.  Though I've been a little curious if giving polymorphic types might impact performance in general due to reduced sharing."
haskell,3cant7,sambocyn,1 point,Mon Jul 6 20:15:16 2015 UTC,they can be tested only if hoisted out to the toplevel.
haskell,3cant7,mjmrotek,2,Mon Jul 6 22:51:51 2015 UTC,or copied to GHCi ;)
haskell,3cant7,meem1029,1 point,Tue Jul 7 09:29:37 2015 UTC,Does it count as a test if it has to be manually run after each change?
haskell,3cant7,mjmrotek,1 point,Tue Jul 7 09:53:34 2015 UTC,"I thought we are still on the topic of newbie friendliness, and by ""test"" /u/htebalaka meant ""see if it compiles and how it works""."
haskell,3cant7,jystic,2,Tue Jul 7 09:56:20 2015 UTC,"I tend to wrap long point free chains which makes things more obvious:  sbf = concat     . sortBy (comparing length)     . group     . sort   vs  sbf = concat     . sortBy     . comparing length     . group     . sort   edit: Just saw the F#/Elm post about the |> operator, I guess this is the same idea. Personally, I find it awkward that the |> inverts function application, so that sometimes I have to read right-to-left and sometimes left-to-right. I much prefer standard function composition using ."
haskell,3cant7,sgraf812,3,Mon Jul 6 23:14:06 2015 UTC,"I really like using F#'s/Elm's forward application operator |> (I think Haskell got &). OOP programmers feel immediately at home, plus you don't have to read from right to left:  sbf items =    items     |> sort     |> group     |> sortBy (comparing length)     |> concat   Splitting comparing length into its own line would be awkward. The whole syntax is also reminiscent of bash's | operator.  I get the part about the naming though. items is not descriptive at all, but I'd imagine this syntax is much easier to follow.  I know the drawbacks wrt. splitting such an expression up, but that's something one discovers later on."
haskell,3cant7,Iceland_jack,5,Mon Jul 6 22:43:40 2015 UTC,The latest base includes sortOn f = sortBy . comparing f:  sortOn        :: Ord b => (a -> b) -> [a] -> [b] sortOn length :: Foldable t => [t a] -> [t a]
haskell,3cant7,kqr,3,Tue Jul 7 05:28:30 2015 UTC,"The trouble with $ (and &) is that it makes it ever so slightly harder to symbolically manipulate your code. The following two lines are equivalent  sort . group . sort . concat sort . gs . concat    where gs = group . sort   You see how we just pulled a subsection out into a variable and that's all we had to do. The following two are not equivalent  items & sort & group & sort & concat items & sort & gs & concat    where gs = group & sort   In other words, when you are applying with &, the surrounding context matters a lot for the correct interpretation of your expression. When you are composing with ., you don't have to care (as much) about the surrounding context because . binds pretty tightly."
haskell,3cant7,drb226,2,Tue Jul 7 08:31:23 2015 UTC,"This. This is what can be so annoying about using certain Haskell operators. Another example is (<*>).  f <$> mx <*> my <*> mz   /= f <$> mx <*> myz  where myz = my <*> mz   Non-associative operators are annoying, especially when they appear in a repeated chain that makes them look associative."
haskell,3cant7,sgraf812,1 point,Tue Jul 7 19:53:09 2015 UTC,"Yeah, but the gain in readability for newcomers is worth it, IMO. At least for getting things going, that is."
haskell,3cant7,mightybyte,15,Tue Jul 7 09:30:45 2015 UTC,"I agree with the spirit of the post, but I think it goes too far.  In my early Haskell days, I noticed a very clear trend that when I tried to string things together too much it took me much longer to get it working than if I broke things down and assigned a name to each step.  This was especially true with monadic code.  Part of the problem was that I was still learning monads, but I've noticed that the trend persists in my programming (although much reduced) even today.  So I think a balance must be struck.  You don't want to name everything because finding the right names is hard.  But you don't want to name too few things because then the code becomes hard to understand and modify.  This is the crux of why building good software is hard.  There are rarely absolutes--almost everything is a tradeoff.  I also think this is why Haskellers use one letter names so much.  Haskell allows us to break things down a lot more than most other languages, so in many places we don't need descriptive names.  When you have ""n = length xs"" in some where clause, you don't need a more descriptive name because you can look at the definition and immediately know.  This, of course, is not the case everywhere.  In many places you really do need good names.  At the end of the day, the right approach is to not go around mindlessly applying rules."
haskell,3cant7,safiire,11,Mon Jul 6 14:52:15 2015 UTC,"This falls under the assumption that it's actually true that naming things is hard.  I honestly don't really find that to be true, but I am one of those programmers who don't mind longer_identifiers, instead of naming everything shitty 1-3 letter names, which drives me crazy and reminds me of the bad old days.  The only time I use 1 letter variable names is usually if something has a well known mathematical single letter name, and I don't mind Haskell's list variables x and xs, or other idioms that everyone is expected to know."
haskell,3cant7,josuf107,5,Mon Jul 6 14:04:51 2015 UTC,"I think at least one difficult aspect of naming is evaluating success. Often the writer of the code chooses a name that seems perfect and natural, but the onus of understanding it is on the reader of the code, and often these are not the same people (or the same person at very different points in time). Long names don't always help either, as they incur a greater burden of understanding on the reader, who needs to understand both the english (named) and code (expressed) meanings of the program. There's a large spectrum of naming and organization choices along multiple axes, and finding the right vector for optimal speed and thoroughness of expression is, well, hard. It's even harder to know whether you've succeeded, unless you review old code with your team with some regularity."
haskell,3cant7,yitz,3,Mon Jul 6 16:15:35 2015 UTC,"Agreed. In some cases, long_identifier_names are the right thing, and in other cases they are very wrong. You have to do your best to make your code as clear and maintainable as possible for the intended audience.  EDIT: ""in other cases they are very wrong"", not ""long"". :/"
haskell,3cant7,Doji,6,Mon Jul 6 17:49:15 2015 UTC,"Naming things is hard, but that is not a justification for avoiding it. Good names add value and meaning to code. This is like saying writing good comments is hard, so don't write comments. Names and comments are just two different forms of documentation."
haskell,3cant7,everybodyhatesclowns,2,Tue Jul 7 04:13:53 2015 UTC,"I think the point is that because naming things is hard, you should only do it when it is actually adding value and meaning to code. If you are adding too many names, or spending too much time thinking of good names, you may need to stop and think about a different way to code it."
haskell,3catfb,haskman,14,Mon Jul 6 13:33:06 2015 UTC,"Both cabal-install and stack are involved with package management whether they like it or not because they install packages.  With stack, upgrading or un-installing a package is a project-local concern by default, so you don't have to worry about globally mutating your package database. So upgrading a package is simply using a newer version. But stack still doesn't help you with un-installing packages or build tools.  I think you should be able to fix versioning/dependency issues by vendoring the packages in question."
haskell,3catfb,eegreg,12,Mon Jul 6 17:00:46 2015 UTC,"IMO that ""cabal is not a package manager"" stuff has always been an annoying cop-out.  Build tools have a responsibility to not suck."
haskell,3catfb,Bzzt,7,Tue Jul 7 00:04:31 2015 UTC,ghc-pkg is a package manager. it does not build however.
haskell,3catfb,sclv,5,Mon Jul 6 18:05:22 2015 UTC,"In the olden days, it was par for the course to answer queries about haskell package management with ""cabal is not a package manager"".  This is a true statement, but it omits the fact that ghc-pkg is the package manager for GHC Haskell. Stack is an alternative build tool to cabal-install, but it still installs your packages using ghc-pkg (via the cabal library)."
haskell,3catfb,kyllo,7,Mon Jul 6 18:12:22 2015 UTC,"You can see the ongoing discussion on uninstall. For upgrading packages: in general with stack, you'd just modify the resolver value in your stack.yaml to point to a newer snapshot, and stack will handle all necessary upgrading.  We definitely aim to make dependency issues less of a problem, mostly through usage of curation and making reproducible builds first-class. But ""versioning / dependency issues"" is a broad enough category that I'm certain there are lots of things that we're not solving."
haskell,3catfb,snoyberg,5,Mon Jul 6 15:13:07 2015 UTC,I summarised the steps to get ghc-mod working with stack here - https://www.reddit.com/r/haskell/comments/3bw95a/using_cabal_and_stack_together/csqdbe2
haskell,3catfb,snoyberg,2,Mon Jul 6 16:11:22 2015 UTC,"There's already a stack-ide project for ide-backend support which is pretty far along. I don't know about ghc-mod, but some people have discussed it in the past."
haskell,3catfb,snoyberg,2,Mon Jul 6 20:15:04 2015 UTC,Stack ide seems pretty cool. Does it integrate with any IDEs apart from FPComplete's own?
haskell,3catfb,LadenSwallow,3,Mon Jul 6 16:46:09 2015 UTC,"Its primary target right now is Emacs, though we hope to support all commonly used editors. It's not actually designed for the web based IDE at all."
haskell,3catfb,snoyberg,1 point,Mon Jul 6 20:17:32 2015 UTC,That is awesome!  Is there any documentation on how to set it up with emacs? I found the video demonstrating 'ide-backend-mode' on FPComplete blog but https://github.com/chrisdone/ide-backend-mode/ seems to have disappeared. Is it still under development?
haskell,3catfb,ephrion,2,Tue Jul 7 01:52:38 2015 UTC,I think this is where it lives: https://github.com/commercialhaskell/stack-ide/tree/master/stack-mode  No documentation though
haskell,3catfb,ephrion,1 point,Tue Jul 7 05:33:33 2015 UTC,"Everything is in a rough state right now, so it may not be the best time to jump in. You can see status on the Github issue: https://github.com/commercialhaskell/stack/issues/232"
haskell,3catfb,ephrion,1 point,Tue Jul 7 06:46:10 2015 UTC,Ghc mod works with stack with some modifications. There's a pull request to add stack support.   Hackage Hdevtools works with stack now.
haskell,3catfb,snoyberg,1 point,Tue Jul 7 12:58:43 2015 UTC,Can you please link to the pull request? I searched but couldn't find it.
haskell,3catfb,kqr,1 point,Tue Jul 7 02:02:54 2015 UTC,Did you try these steps - https://www.reddit.com/r/haskell/comments/3bw95a/using_cabal_and_stack_together/csqdbe2
haskell,3catfb,emarshall85,1 point,Tue Jul 7 05:25:56 2015 UTC,ajnsit's repository has the majority of the work. I made some changes so it would work on my laptop with GHC 7.10.  I just did the following to get it working on my desktop PC:   git clone https://www.github.com/parsonsmatt/ghc-mod cd ghc-mod && git checkout stack-support stack install   And then it works in my stack projects. Give that a shot and post any issues on github?
haskell,3catfb,theonlycosmonaut,1 point,Tue Jul 7 06:08:36 2015 UTC,"Ah, I see the pull request you are talking about now! :)"
haskell,3catfb,technicolorNoise,1 point,Tue Jul 7 09:53:45 2015 UTC,"Oh, hey! :D Thanks for getting it working!"
haskell,3catfb,kyllo,2,Tue Jul 7 12:52:03 2015 UTC,"I don't have any new ideas on how to solve dependency issues in Haskell, and curation through Stackage and LTS Haskell works pretty well for me at the moment. I was mostly interested in knowing if adding such features would go against stack's philosophy."
haskell,3catfb,abaquis,2,Tue Jul 7 14:35:18 2015 UTC,"Since we're talking at such an abstract level: no, features that solve problems people are facing do not go against stack's philosophy. Though I don't think that statement is either surprising of illuminating ☺"
haskell,3catfb,kqr,1 point,Tue Jul 7 14:48:47 2015 UTC,"No. Stack, like Cabal, is a build tool, not a package manager. Nix is a package manager."
haskell,3catfb,cynede,12,Mon Jul 6 20:20:45 2015 UTC,"Nix is not a Haskell tool.   My point being that Pythonistas have pip to manage packages (install/update/unisntall), Javascripters have npm. Haskellers surely shouldn't be expected to use cabal/stack + Nix for package management, especially if you consider the overhead in getting started. For comparison, To use pip, one need only understand how to write a Setup.py. For what you seem to be suggesting, I need to not only have a stack.yml file, but a nix expression as well.   I hope that something comes of the discussion /u/snoyberg linked to (especially if you consider the last comment as I write this."
haskell,3catfb,drb226,2,Tue Jul 7 01:51:04 2015 UTC,"Also, I think it's pretty important to be able to keep your project directory free of cruft.  Perhaps a ""stack cleanup"" command should be added which would remove all locally installed packages which are not currently being referred to by stack,yaml."
haskell,3caza0,Agent_HK-47,20,Mon Jul 6 14:26:14 2015 UTC,"Haskell is used in the spam fighting system at Facebook, which receives over a million requests per second. They developed the Haxl package to provide a nice interface for efficient, concurrent data accesses."
haskell,3caza0,Roboguy2,21,Mon Jul 6 18:10:02 2015 UTC,"http://snapframework.com/media/img/pong-bench-20101117.png (Happstack and Snap are Haskell frameworks, Node.js isn't even a framework so no wonder it's able to be fast!)  http://www.yesodweb.com/assets/new-warp/result.png (Mighty/Mighttpd is an HTTP server written in Haskell)  http://www.aosabook.org/en/posa/warp-images/benchmark.png ( - || - )  Haskell is much web scale."
haskell,3caza0,kqr,9,Mon Jul 6 14:43:19 2015 UTC,"Yes, these are quite nice but quite old as well. See also this reddit thread about WAI being #3 in some benchmarks."
haskell,3caza0,mallai,4,Mon Jul 6 15:15:32 2015 UTC,"Just for the precision, in the first graph Snap and Happstack are two web frameworks made in Haskell."
haskell,3caza0,kaukau,3,Mon Jul 6 14:59:43 2015 UTC,Is it possible to have high reqs per second but not be able to handle lots of concurrent connections?  Does that actually answer the question?
haskell,3caza0,get-your-shinebox,1 point,Mon Jul 6 23:05:24 2015 UTC,I didn't realize rails was that bad. Jesus.
haskell,3caza0,hiptobecubic,-1,Sat Jul 11 05:32:22 2015 UTC,"Node.js isn't even a framework so no wonder it's able to be fast!)   And that benchmark compares apples to oranges, err... snap to Ruby on Rails. Good job."
haskell,3caza0,rstd,14,Mon Jul 6 16:51:01 2015 UTC,100%
haskell,3caza0,jberryman,8,Mon Jul 6 19:14:43 2015 UTC,web scale
haskell,3caza0,andrewthad,12,Tue Jul 7 13:23:07 2015 UTC,http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
haskell,3caza0,joehillen,1 point,Mon Jul 6 14:39:48 2015 UTC,"I appreciate the link, but would it be possible to present it in a format more digestable than a 12 page technical paper?"
haskell,3caza0,kqr,28,Mon Jul 6 14:43:06 2015 UTC,"We also show that with Mio, McNettle (an SDN controller written in Haskell) can scale effectively to 40+ cores, reach a throughput of over 20 million new requests per second on a single machine, and hence become the fastest of all existing SDN controllers.  […]  For comparison, we also measure the performance of nginx, arguably the world’s fastest web server, written in C specifically for high performance. […] the graph also demonstrates that a realistic web server in Haskell, mighty, performs within a factor of 2.5x of nginx for every number of cores and performs within 2x of nginx for 8 cores and higher.  […]  As a result, the performance of network servers in Haskell rivals that of servers written in C.   Tip for the future: if you're not interested in the problem or how it was solved, only the actual solution, look at the ""abstract"", ""result"" (in this case called ""evaluation"") and ""conclusion"" parts of a paper. And skim based on headlines and diagram captions."
haskell,3caza0,agocorona,2,Mon Jul 6 14:53:52 2015 UTC,Great job!  I suppose that the amazing improvement in speed is because the current GHC IO manager block all threads when it is doing an OS call.  Can I assume that  Mio will be the IO manager of GHC in the next release?
haskell,3caza0,tibbe,3,Tue Jul 7 06:27:27 2015 UTC,"MIO was released in 7.8.  I'm not sure what you mean by   the current GHC IO manager block all threads when it is doing an OS call.   Do you mean when the I/O manager thread itself does a call to epoll_select? It doesn't block all threads even then, as GHC has a pool of OS thread per core that it uses to run Haskell threads."
haskell,3caza0,kyllo,10,Tue Jul 7 08:59:35 2015 UTC,"Yes, it is as fast and scalable as anything. This post will tell you everything you want to know about Warp, the flagship Haskell web server. In a nutshell, it's as fast as nginx:  http://www.yesodweb.com/blog/2012/11/warp-posa"
haskell,3caza0,Taladar,7,Mon Jul 6 18:07:00 2015 UTC,Node can't even scale past a single CPU core last time I checked. I would say those claims were more hype caused by synthetic benchmarks than anything else.  Haskell on the other hand has a rather sophisticated runtime system which allows you to program in the more readable way that looks like blocking I/O (unlike callback hell in event based languages and framework that expose that fact which becomes unreadable very fast) while in reality using a combination of OS and green threads to keep other Haskell threads on the same OS thread running even if one of them calls a blocking FFI function.
haskell,3caza0,Quabouter,3,Mon Jul 6 22:31:45 2015 UTC,"Node can't even scale past a single CPU core last time I checked.   You probably haven't read past the ""NodeJS is single-threaded"" titles. Properly designed NodeJS applications are (virtually) stateless (sounds familiar?), which makes it trivial to scale them among as many cores as you like. The NodeJS runtime even can automatically route requests among different worker threads, it's explicitly designed to easily scale well. For properly written NodeJS applications the only thing you need to do to run it on multiple cores is to run it with a process manager like pm2 (e.g. pm2 start -i <numberOfProcesses> myApp). There aren't many platforms out there that make it easier to write multi-process web applications than NodeJS.  As for the callback hell: there are tons of articles already written about it. Any half-decent (Javascript) dev knows how to prevent this. Perhaps the most well-known strategy is to use the promise monad, but there are dozens of other techniques out there. The upcoming versions of Javascript also have a large focus on improving asynchronous programming, so it will even get better.  I have written web servers in several languages (Among things, Java, Python, NodeJS, C# and even C++. Unfortunately not yet in Haskell), but in 9/10 real world use cases NodeJS is a lot faster than the others (it actually doesn't perform that well in synthetic benchmarks usually). NodeJS isn't really good at CPU intensive tasks, but it extremely good in handling I/O (mostly because it forces you to do it non blocking). So if most of your application consists of responding to web requests and doing stuff like DB lookups then NodeJS will likely outperform most other choices.   I can't make a personal judgement on Haskell vs NodeJS for web since I haven't yet written a lot of code in Haskell. Haskell will definitely outperform NodeJS on synthetic benchmarks, if it also outperforms NodeJS in real world application depends most on the frameworks available. I'm not familiar enough with those though to say anything about that."
haskell,3caza0,Taladar,1 point,Wed Jul 8 22:51:21 2015 UTC,"Any system can ""scale"" if it is completely stateless. You can just run many copies of the same software.  I don't know about your real world use cases but most I have seen include a fair amount of CPU work, not just database queries. Of course i suppose if the only thing you do are REST APIs that mirror database queries 1:! you would see something like that."
haskell,3caza0,Quabouter,5,Thu Jul 9 11:54:25 2015 UTC,"Any system can ""scale"" if it is completely stateless. You can just run many copies of the same software.   Exactly! Therefore a platform that forces you to do so will in practice result in better scalable systems. That's why in the real world NodeJS applications often outperform applications written in other languages, even though many other languages are orders of magnitude faster than NodeJS.   I don't know about your real world use cases but most I have seen include a fair amount of CPU work, not just database queries.   Well, small to medium scale websites usually have next to no CPU work that needs to be done, especially compared to the time it spend doing IO. For larger website you don't want a monolithic application that does all the work anyway since that's an absolute nightmare to maintain. In those situations you're better of lifting the heavy CPU work to separate stand-alone services, for which you definitely should not use NodeJS. NodeJS is still a very viable candidate though for creating the service that's facing the web."
haskell,3caza0,Taladar,2,Thu Jul 9 15:19:38 2015 UTC,"To me, especially compared to the Haskell RTS, NodeJS seems very much like implementers being lazy at the cost of language users. It feels like it would be very much a maintenance and debugging nightmare with all the callback hell and no static typing or even simple checks for valid variables at compile time."
haskell,3caza0,semigroup,7,Thu Jul 9 17:07:16 2015 UTC,"Scalability as a phrase is overrated for a lot of scenarios. Plenty of companies are built on Ruby on Rails, which is like building skyscrapers out of sand, and they still survive.  Additional food for thought: http://erlangcentral.org/scalable-is-awesome-literally-garrett-smith-erlang-user-conference-2015/#.VZsGSxNVhBc"
haskell,3caza0,gaze,4,Mon Jul 6 22:52:35 2015 UTC,"What do you mean? I realize everyone asks about scalability, but really every language is scalable. Precisely what do you want to know? What characteristics does a scalable language have to you?"
haskell,3caza0,TheBikingDev,4,Mon Jul 6 22:39:59 2015 UTC,"Not an answer to your question but I see scalability as 4 variables, picture it as a radar/spider chart and draw the dots for your platform of choice.  1) Raw horsepower, how fast does it take to serve a request 2) Concurrent horsepower, how many requests can you process 3) Single developer productivity 4) Multiple developer productivity  Nodes great, it's fast you can do lots with it just look at the number of repos on Github so I won't discredit it. It ticks boxes 1-3. It is easy to block the event loop though in which case being single threaded it's not so great. Also being dynamically typed the more developers and the larger the project the more likely you are to see issues arising from code changes, it's not compiled so you only find them at runtime. A lot of new languages are coming out treating JS as a bytecode to get around some of the language weaknesses while getting benefit of the Node environment.  Statically typed languages do better at 4, you get help from the compiler making changes. Then with things like FP and immutability you also get rid of things like mutating state bugs. There's a certainly more upfront investment in learning compared to JS, infact if you've done lots of OO for a long time it can be a huge upfront investment due to a complete mind shift, eventually it starts to click and make sense although it can be a slow journey.  I'm only learning Haskell myself playing with Spock/Scotty so can't give any better answers. I've worked hell of a lot with PHP / JS / Groovy before which are all dynamic and the past 3 years Scala professionally. All my pain points with PHP / JS / Groovy have turned out to be dynamic runtime issues, Scala automatically looses a large proportion of the bugs I had if you make the type system work for you, hence I'm now at Haskell."
haskell,3caza0,tboettch,1 point,Tue Jul 7 12:24:44 2015 UTC,A really good answer. Thank you!
haskell,3cclva,benekastah,3,Mon Jul 6 21:31:21 2015 UTC,"getProperty :: Show t => Test -> t means, that you can get getProperty to return any t which has an instance for Show, but this choice has to take place statically. For example you could specialize getProperty by replacing the type variable t with Int, String, and Bool respectively, e.g.  getPropertyInt :: Test -> Int getPropertyInt = getProperty  getPropertyString :: Test -> String getPropertyString = getProperty  getPropertyBool :: Test -> Bool getPropertyBool = getProperty   For your function these wouldn't make sense, as depending on what Test value you pass into one of those functions, they may in all three cases still return either a String or an Int.  One way to fix this is to use a sum type instead, e.g.  data Either a b = Left a  -- This is also defined in the Prelude                 | Right b                 deriving (Show)  getProperty :: Test -> Either String Int getProperty test =     case mode test of         A -> Left $ a test         B -> Right $ b test  main = do     let t = Test { a = ""yes!"", b = 5, mode = A }     print $ getProperty t   Here the compiler does not complain that getProperty may return either a String or an Int, because for both cases - A and B - it returns an Either String Int ;)  Another way to fix this would be to use a ghc extension for existentially quantified types. In your original type signature you universally quantify over t: the signature getProperty :: Show t => Test -> t can be read as forall types t which have a Show instance, take a Test and return a t. Using existential types, you could construct a type signature, which reads as take a Test and return something for which exists some type which has a Show instance.  Without knowing more about your usecase, I'd guess the first solution is probably what you are looking for.  edit: I think in this particular case, the approach suggested in this comment is the way to go."
haskell,3cclva,m0rphism,2,Mon Jul 6 22:10:45 2015 UTC,"I think I'll end up using the Either approach. I would have used existentially quantified types, but I still would have needed to do something like case getProperty t of Showable s -> print s in order to call a function on it, at least as far as I could tell. That's not the worst, but it's not quite as terse as I was hoping for. Ultimately, I think doing this with Either will be pretty easy to read, even if it isn't as terse as I was hoping for."
haskell,3cclva,Peaker,2,Mon Jul 6 22:54:27 2015 UTC,Note that a Showable existential is almost the same as a simple String (modulo precedence and ShowS features).  The Either approach preserves more information and that may be useful.
haskell,3cclva,tailcalled,2,Mon Jul 6 23:53:37 2015 UTC,"Note that [Bool] has a show instance. What should the result of or $ getProperty $ Test { a = ""yes!"", b = 5, mode = A} be?  The problem here is that getProperty :: Show t => Test -> t means that for any t that has a Show instance, you have getProperty :: Test -> t. It does not mean that given some x :: Test, getProperty x will return something whose type has a Show instance.  Now, it turns out that it is possible to write an API that looks like this:  type Showable instance Show Showable toShowable :: (Show t) => t -> Showable   Using such an API, you can simply write your getProperty as  getProperty test =     case mode test of         A -> toShowable $ a test         B -> toShowable $ b test   The way to write the Showable API is simple:  newtype Showable = MkShowable String instance Show Showable where   show (MkShowable s) = s toShowable = MkShowable . show   However, all of this smells like an XY-problem."
haskell,3cclva,tailcalled,1 point,Mon Jul 6 22:24:20 2015 UTC,"Yeah, I think this is a bit of an XY-problem. For the curious, I'm using vty-ui to make a terminal ui. The have a lot of functions that operate on some Widget a. As far as I can tell, they don't belong to any typeclass (though I'm not sure that would really change my present situation). I was implementing a Widget that wraps Widget Edit and Widget FormattedText, only one of which is displayed at a time. I wanted a function with a type kind of like getDisplayedWidget :: Widget MyWidget -> Widget a so that I could do render $ getDisplayedWidget w or growHorizontal $ getDisplayedWidget w. I ended up getting things to compile by having a function like getDisplayedWidget :: Widget MyWidget -> Either (Widget Edit) (Widget FormattedText). It's not quite as terse as I would have liked, but the file is still small enough that I don't think it will end up being that much of an issue."
haskell,3cclva,Tekmo,1 point,Mon Jul 6 23:21:17 2015 UTC,That actually sounds like one of the rare appropriate spots for an existentially qualified data type:  data GenericWidget where   Forget :: Widget a -> GenericWidget
haskell,3cclva,tailcalled,1 point,Tue Jul 7 00:13:51 2015 UTC,"Hm, I messed with existentially qualified types a bit. I'll try this again."
haskell,3cclva,Peaker,1 point,Tue Jul 7 03:00:44 2015 UTC,You can simplify that even further:  getProperty :: Test -> String getProperty test = case mode test of     A -> show (a test)     B -> show (b test)
haskell,3cclva,tdammers,1 point,Mon Jul 6 23:56:38 2015 UTC,I mostly did it the bulky way to split up the different ideas; showing the structure first and then how to implement said structure.
haskell,3cclva,kqr,2,Tue Jul 7 00:08:31 2015 UTC,"Some GADTs fun:  data Test a where   TestA :: String -> Int -> Test String   TestB :: String -> Int -> Test Int   Then you can have:  getProperty :: Test a -> a   If replicating the Test constructor many times is a problem, you can do something like:  data TestMode a where     A :: TestMode String     B :: TestMode Int data Test a = Test { a :: String, b :: Int, mode :: TestMode a }   If you don't want to hard-codes all tests to use the same types for the modes, you can use a type family for each test. Or:  data TestMode l r a where     A :: TestMode l r l     B :: TestMode l r r data Test a = Test { a :: String, b :: Int, mode :: TestMode String Int a }   All this is far more complicated than the other suggested solutions, so use them instead :) I only mention it for pedagogical purposes!"
haskell,3cclva,tdammers,1 point,Mon Jul 6 23:59:28 2015 UTC,"Error from the first bit of code:  test.hs:9:14:     Could not deduce (t ~ String)     from the context (Show t)       bound by the type signature for getProperty :: Show t => Test -> t       at test.hs:6:16-34       ‘t’ is a rigid type variable bound by           the type signature for getProperty :: Show t => Test -> t           at test.hs:6:16     Relevant bindings include       getProperty :: Test -> t (bound at test.hs:7:1)     In the expression: a test     In a case alternative: A -> a test  test.hs:14:5:     No instance for (Show s0) arising from a use of ‘print’     The type variable ‘s0’ is ambiguous     Note: there are several potential instances:       instance Show Double -- Defined in ‘GHC.Float’       instance Show Float -- Defined in ‘GHC.Float’       instance (Integral a, Show a) => Show (GHC.Real.Ratio a)         -- Defined in ‘GHC.Real’       ...plus 24 others     In the expression: print     In a stmt of a 'do' block: print $ getProperty t     In the expression:       do { let t = ...;            print $ getProperty t }"
haskell,3cclva,sccrstud92,1 point,Mon Jul 6 21:31:49 2015 UTC,"Maybe a data type like this one is closer to what you want:  data Tests = TestA String | TestB Int   ...and then:  main = do     let t = TestA ""yes!""     case t of         TestA x -> print x         TestB x - >print x"
haskell,3c8rp2,akurilin,2,Sun Jul 5 23:31:52 2015 UTC,I got the update from a normal apt upgrade in Ubuntu. Is that not enough or not the recommended way to update Stack?
haskell,3c8rp2,wolftune,6,Mon Jul 6 02:51:27 2015 UTC,"If you're using your OS's package repository, that's a great way to upgrade."
haskell,3c8rp2,borsboom,2,Mon Jul 6 04:16:36 2015 UTC,"I got the following error on OS X with an existing stack 0.1.1.:  ~$ stack upgrade --git && stack upgrade Cloning stack Cloning into 'stack'... Warning: Permanently added the RSA host key for IP address '192.30.252.128' to the list of known hosts. Permission denied (publickey). fatal: Could not read from remote repository.  Please make sure you have the correct access rights and the repository exists. Exit code ExitFailure 128 while running [""git"",""clone"",""git@github.com:commercialhaskell/stack"",""stack"",""--depth"",""1""] in /var/folders/q7/syq5t6r56snds9cmly6k07mw0000gn/T/stack-upgrade785/"
haskell,3c8rp2,tkx68,2,Mon Jul 6 06:16:48 2015 UTC,We had a similar problem recently with GitHub. This problem is invisible to GitHub users because cloning public repos via SSH works for them but users without an SSH key known to GitHub can not. The solution is to use the https URL instead.
haskell,3c8rp2,Taladar,5,Mon Jul 6 07:29:37 2015 UTC,"That was a silly mistake on my part. I'll update the codebase to use the https URL. Thanks for the report /u/tkx68.  EDIT In order to get the newest version in this case, either download the binaries from the download page or manually clone the repo."
haskell,3c735q,quchen,17,Sun Jul 5 14:08:34 2015 UTC,"Short summary:   build from small, provably correct pieces (functions like length, mapM,...), leverage type classes & their laws (Monoid, Applicative, etc.), use equational reasoning, (implicitly) make use of lazy evaluation and use custom control structures instead of writing the control flow by hand.   All good advice, but the title might be misleading. The talk is about building provably correct software, not about proving existing software correct. It's one thing to maintain strict discipline when writing and designing a system, but if you have some slapdash legacy application, none of this is going to help you anymore. A C model checker, on the other hand, might be useful even then."
haskell,3c735q,ForTheFunctionGod,9,Sun Jul 5 16:51:58 2015 UTC,"That's correct.  I should have clarified that this cannot be easily applied to an existing codebase without heavy refactoring, although I have done this as an exercise on a few occasions and it is possible."
haskell,3c735q,Tekmo,0,Sun Jul 5 17:49:57 2015 UTC,"How does the proof work for IO, knowing that this wrapper is prone to side effects?"
haskell,3c735q,BanX,1 point,Tue Jul 7 01:09:50 2015 UTC,"The following Monoid instance is always guaranteed to satisfy the Monoid laws:  instance (Applicative f, Monoid a) => Monoid (f a) where     mempty = pure mempty     mappend = liftA2 mappend   So if you specialize f to IO (which implements Applicative) you get:  instance Monoid a => Monoid (IO a) where     mempty = pure mempty     mappend = liftA2 mappend   So the correctness of the proof depends entirely on whether IO obeys the Applicative laws.  We also know that if IO implements Monad correctly then IO also implements Applicative correctly.  However, we have to take on faith that IO obeys the Monad laws."
haskell,3c735q,Tekmo,2,Tue Jul 7 04:03:41 2015 UTC,"As a side note, and regarding the lack of such an instance in Haskell, I sort of wonder if it would be feasible to make a law that for any Alternative  empty == pure mempty   I remember there was some discussion whether Vinyl should use an Applicative constant on the type constructor and Monoid constraint on  all fields, or just an Alternative constraint on the type constructor, and apparently it settled on  (Monoid (f r), Monoid (Rec f rs)) => Monoid (Rec f (r:rs))   which seems fair enough. But the whole thing still leaves the feeling that programmers shouldn't have to put up with such language implementation details that prevent the generic  (Monoid a, Applicative f) => Monoid (f r)   and   Alternative f => Monoid f r    instances to coexist."
haskell,3c735q,mjmrotek,0,Wed Jul 8 19:08:50 2015 UTC,So it's a responsibility of the programmers to implement IO actions satisfying the Monad laws? The programming language can offer no guarantees when using impure functions?
haskell,3c735q,BanX,3,Tue Jul 7 09:37:10 2015 UTC,No.  It's the result of the programming language implementers to provide an IO type that satisfies the Monad laws (which it does as far as I can tell).  Programmers don't need to make any special effort.
haskell,3c735q,Tekmo,7,Tue Jul 7 13:43:32 2015 UTC,This is the first time I've seen the type IO (IO (IO (IO ( IO ())))) -> IO ().
haskell,3c735q,lambdafool,14,Sun Jul 5 17:36:20 2015 UTC,"Ha, funny! In mathematics we define a monad precisely as things m such that you can collapse sequences `m (m (… (m x))) to m x with join, and it doesn't matter which order you use. Also, you need a compatible function return. Bind is only secondary.   The Haskell definition and the mathematics definition are equivalent though."
haskell,3c735q,bgeron,7,Sun Jul 5 17:42:37 2015 UTC,"In mathematics we define a monad precisely as [mu and eta obeying laws]   Can't you also define the Kleisli structure for an endofunctor, and then define a monad to be the additional structure needed for that endofunctor to make Kleisli a category? Kleisli composition is pretty close to Haskell's bind operation, I don't think one (bind or join) is more primitive than the other."
haskell,3c735q,ABC_AlwaysBeCoding,6,Sun Jul 5 20:39:34 2015 UTC,It is this sort of comment that makes me wonder if I should have taken more math theory before blundering into programming
haskell,3c735q,pythonista_barista,9,Sun Jul 5 23:28:56 2015 UTC,"You wouldn't have learned category theory, so I wouldn't sweat it personally. There's a good number of working mathematicians who have never heard of it."
haskell,3c735q,drwebb,6,Mon Jul 6 00:26:55 2015 UTC,"Even if I didn't take Category Theory, good ole third year Abstract Algebra helped me immensely in touching on some of the topics."
haskell,3c735q,pythonista_barista,1 point,Mon Jul 6 02:49:04 2015 UTC,That's certainly true.
haskell,3c735q,pythonista_barista,1 point,Fri Jul 10 16:11:27 2015 UTC,What I said was completely orthogonal to using Haskell as your everyday language (and then some). Don't assume it's even remotely necessary just because a handful of people like to talk about things like these.
haskell,3c735q,pythonista_barista,1 point,Mon Jul 6 16:56:23 2015 UTC,"I didn't, and I think my comment says that? Sorry if I wasn't clear."
haskell,3c735q,Archaeanimus,1 point,Fri Jul 10 16:10:39 2015 UTC,I just wanted to make it absolutely clear for everyone who reads it. :-)
haskell,3c735q,Umbrall,1 point,Sat Jul 11 12:05:53 2015 UTC,👍
haskell,3c735q,Umbrall,4,Sun Jul 12 17:48:18 2015 UTC,"I don't think one (bind or join) is more primitive than the other   Depending on what you mean by ""primitive,"" I think it depends on the monad in question. Personally, I feel like join is the more ""primitive"" operation in things like List and Maybe, while bind seems at least as ""primitive"" in things like IO.  One could argue, though, that because bind uses exactly the structure of map and join:  bind = join ∘ map   while defining join in terms of bind sort of discards some of the semantics of map by using id:  join = bind id   join is the more ""primitive"" operation."
haskell,3c735q,Tekmo,1 point,Mon Jul 6 05:26:52 2015 UTC,"Yeah, a monad is just a monoid over the category of endofunctors.  It has a transformation m (m a) -> m a (as in mappend) and from a -> m a (mempty). Bind is just a given from join . fmap"
haskell,3c735q,Umbrall,3,Sun Jul 5 18:08:06 2015 UTC,At that point I feel like I'd use the free monad over the IO Functor.
haskell,3c735q,Tekmo,3,Sun Jul 5 18:06:18 2015 UTC,There were two reasons for using that type in the talk's example:   The example required a fixed number of IO layers That type gives the desired Monoid instance
haskell,3c735q,Umbrall,3,Sun Jul 5 19:00:33 2015 UTC,"I wouldn't expect anything more complicated in the talk than just the layers.  After some work I've managed to get the monoid instance for Free that works appropriately in cases like this. It might be able to be simplified a bit but this appears to work:  instance (Functor f, Monad f, Monoid a) => Monoid (Free f a) where     mempty = return mempty     mappend (Pure a) mb = fmap (a <>) mb     mappend ma (Pure b) = fmap (<> b) ma     mappend (Free ma) (Free mb) = Free $ do         a <- ma         b <- mb         return (a <> b)   EDIT: Simplified it from the original"
haskell,3c735q,absence3,5,Sun Jul 5 22:07:04 2015 UTC,"Yeah, to make an analogy:  Monoid : Monad :: mempty : return  Monoid : Monad :: mappend : join  Monoid : Monad :: mconcat : Control.Monad.Free.retract  Monoid : Monad :: [a] : Free f  Monoid : Monad :: (a, a, a, a, a) : f (f (f (f (f r))))   So to make an analogy to simpler types, your solution is one that works on ""lists"" of functors of arbitrary size, and my solution works on ""tuples"" of functors of fixed size."
haskell,3c735q,Umbrall,2,Mon Jul 6 00:36:12 2015 UTC,"Unfortunately though mine's actually a solution for lists of monads, not functors. That said yours is too (?). There is a generalization you can make for functors, but you lose the ability to control the ordering. As I typed this I realized/remembered you only need applicatives for either."
haskell,3c735q,absence3,2,Mon Jul 6 00:56:37 2015 UTC,"Does this have any negative gotchas?  instance (Functor f, Monoid a) => Monoid (Free f a) where     mempty = pure mempty     mappend = liftA2 mappend  job' :: Int -> Free IO () job' n = do     liftF . putStrLn $ ""Generating job "" ++ show n     liftF . putStrLn $ ""Packaging job "" ++ show n  main = retract $ job' 3 <> job' 5"
haskell,3c735q,Umbrall,2,Mon Jul 6 15:53:41 2015 UTC,"That prints them out in sequence for me, which isn't the desired behaviour. The correct output of that is supposed to be:  Generating job 3  Generating job 5  Packaging job 3  Packaging job 5  But yours has jobs 3 and 5's generating and packaging squished together."
haskell,3c735q,absence3,1 point,Mon Jul 6 16:10:03 2015 UTC,"You're right! I could have sworn I got the correct output when I tried it, but I must have mixed up the functions or forgotten to reload or something. Thanks for pointing it out."
haskell,3c735q,Umbrall,1 point,Mon Jul 6 16:16:12 2015 UTC,I thought literally the same thing. It took me several times to notice that the output was wrong and actually verify it.
haskell,3c735q,alt_account10,2,Mon Jul 6 16:28:11 2015 UTC,"I had to poke around a bit more to gain a better understanding, and ended up with this instance:  instance (Applicative f, Monoid a) => Monoid (Free f a) where     mempty = pure mempty     mappend (Free ma) (Free mb) = Free $ liftA2 mappend ma mb     mappend fa fb = liftA2 mappend fa fb   It's now clear to me that the case with two Frees has to be handled separately to allow interleaving, as the Applicative instance otherwise recurses through the entire Free tree."
haskell,3c735q,mightybyte,1 point,Tue Jul 7 16:35:18 2015 UTC,"Yeah, that's why I had the cases I did. With the general case it did appropriately apply all of the parts, but it recursed infinitely."
haskell,3c735q,3453280,5,Tue Jul 7 16:49:22 2015 UTC,"Am I the only one that spells mempty, mappend as m empty and m append?"
haskell,3c735q,mightybyte,3,Sun Jul 5 20:04:09 2015 UTC,"I'm half and half.  I pronounce them ""em empty"" and ""mappend""."
haskell,3c735q,FeatureRush,1 point,Sun Jul 5 20:11:26 2015 UTC,"Where do you stress ""mappend""?"
haskell,3c735q,kamatsu,2,Mon Jul 6 03:51:07 2015 UTC,"On the second syllable, just like the word ""append""."
haskell,3c735q,FeatureRush,4,Mon Jul 6 04:26:50 2015 UTC,"I imagine that when growing from small to medium sized codebase proof assistant would have to be introduced? How would it look like today? Would it be Haskabelle or some other solution? Are there any repositories with non-trivial examples?   Say I'm working on simple multiplayer RTS game (currently learning about FRP), how complicated (harder than just doing ""normal"" game engine) would it be to prove high level properties of game engine, like:   world simulation gives exactly the same results on all clients,  game doesn't leak info about unseen units to other players to make memory hacking useless, impossible moves (like teleportation or wall clipping) are impossible even when client sends modified packets, all possible combinations of item and commands properly handled without game crash, etc...   Is this something doable with tools available today? How would one integrate all the networking, compression etc libraries on hackage without proofs? How to add robustness to the picture - you need to handle all the impossible game states resulting from network lag?"
haskell,3c735q,mjmrotek,4,Sun Jul 5 21:49:53 2015 UTC,"Haskabelle is nigh-on unusable, to be honest. I don't know why the Isabelle maintainers keep it in their tree."
haskell,3c735q,kamatsu,1 point,Mon Jul 6 02:29:13 2015 UTC,"I was kind of expecting it to be like that, will try anyway. Are there other similar tools or currently most of proving is done by hand?"
haskell,3c735q,Tekmo,4,Mon Jul 6 07:38:45 2015 UTC,"Not sure if this is what you're looking for, but you can try LiquidHaskell, that adds refinement types to Haskell."
haskell,3c735q,kwef,3,Mon Jul 6 08:26:28 2015 UTC,"HERMIT can be used for this, although the reasoning is very fast and loose."
haskell,3c735q,PokerPirate,5,Mon Jul 6 13:38:37 2015 UTC,"Most of those are solved by unrelated techniques and don't require any equational reasoning:   world simulation gives exactly the same results on all clients   Encode your world simulation as a Fold from my foldl library so that you have a pure update function and it's automatically pure and reproducible on all clients   game doesn't leak info ...   This is impossible to prove in Haskell as far as I can tell.  I have no clue how you would do this.   impossible moves .... are impossible ...   This is the job of the type system.  Make impossible states unrepresentable   all possible combinations of item and commands properly handled without game crash   This is also the job of the type system: ""A well typed program does not go wrong"" which in this context means that it will never crash.  This is even truer in ""total"" programming languages, which statically guarantee that all expressions terminate without any errors"
haskell,3c735q,kwef,7,Mon Jul 6 00:40:52 2015 UTC,"game doesn't leak info ...   This could potentially be encoded in an information flow control (IFC) system. One example of this in Haskell is the LIO framework—it is dynamically enforced, but there are also static versions of IFC which put secrecy/integrity in the type system rather than a special runtime layer. They tend to be much trickier to work with, though. My suspicion is that static IFC would require a lot of dependent types to make it practically useable, and as far as I'm aware, there's still a lot of work to be done in that area."
haskell,3c735q,FeatureRush,2,Mon Jul 6 00:51:06 2015 UTC,Does LIO (or anything similar) handle the case of leaking information through timing attacks?
haskell,3c735q,Tekmo,1 point,Mon Jul 6 18:23:34 2015 UTC,"As far as I'm aware, LIO has nothing to prevent leakage through side-channels like timing attacks. I don't know of any language-level (i.e. type-driven) way of preventing side-channel attacks, but I would be fascinated if anybody here has heard of something like this."
haskell,3c735q,FeatureRush,2,Tue Jul 7 01:33:33 2015 UTC,"Well, maybe I'm mistaken about what proving software correct actually means - I was under the impression that it can be used in place of QuickCheck, just instead of testing small, random subset of inputs it would use equational reasoning? And that there are some tools (proof assistants?) that could be integrated into build process? If not, could you please give couple examples of what kinds of proofs would be written for game software?  The example game engine features I listed prove to be very, very hard to achieve even in commercial engines, so please understand my skepticism that the solution can't simply be just using better type system? I mean wouldn't you need to somehow prove that the program is ""well"" typed?  As for not leaking info to the players -  it's about players not having information about other not seen players physically in their RAM, I already plan for having central trusted server, so that actually make it possible without homomorphic encryption:)"
haskell,3c735q,Tekmo,3,Mon Jul 6 07:29:12 2015 UTC,"Let's use a simplified example to drive this discussion forward otherwise we'll keep speaking in terms of generalities instead of specifies.  Let's say that you are programming a game of Tic-Tac-Toe.  You can use dependent types to enforce that invalid states are impossible at compile time.  You can enforce things like:   A player can only select a space that has not yet been selected Players cannot keep playing once a winning move or draw has been played   You can actually even do this in a system without dependent types, but it's just much more verbose (and does not scale well to larger game mechanics).  These types will then enforce that you can't program your game correctly.  Any time you add game logic that violates those invariants you will get a type error that prevents your program from compiling.  It's like adding a unit test at the type level."
haskell,3c735q,mightybyte,1 point,Mon Jul 6 15:16:31 2015 UTC,"It's not that tic-tac-toe example is not clear to me, rather (you probably hear this one often) it's the bigger programs that would be a problem. I fear that in more complex program some possible unhandled game state may slip through, either as a result of game behavior depending on data files or from some non trivial interaction between components that I've missed.  After rethinking all the specific bugs I had in mind most really don't require more than good use of types. I'm not sure about some, but it's hard for me to formulate question right now, I will be sure to ask on r/haskell or #haskell when I code up to that place.  Also one of the comments mentioned ""C model checkers"", I looked it up and must say BLAST etc are close to my initial expectations of how proving software correct would look like."
haskell,3c735q,Tekmo,2,Tue Jul 7 01:38:11 2015 UTC,"One of the key tricks that makes this all work is that any interaction with external components can be ""purified"".  The way you do this is that you mock the interaction by building a syntax tree representing external interactions and then a thin interpreter that translates the syntax tree to side effects.  I wrote a post on purifying IO that explains this in much more detail.  Once you have that syntax tree, you can project that syntax tree into the types in a language with dependent types and encode tests over that syntax tree's behavior that get evaluated at compile time.  Note that this will not work in Haskell because Haskell does not have dependent types, but it would work in Idris.  There is one vulnerable part of the program, which is the interpreter that translates the syntax tree to side effects.  The correctness of that can only be established by end-to-end tests or human inspection, so that's why you want to keep it as thin as possible."
haskell,3c735q,mightybyte,2,Tue Jul 7 04:07:30 2015 UTC,Is that Monoid Applicative instance defined anywhere in the standard libraries?
haskell,3c735q,Tekmo,1 point,Mon Jul 6 22:56:04 2015 UTC,Not that I know of
haskell,3c7nn0,rampion,9,Sun Jul 5 17:38:27 2015 UTC,"This trick seems related to the unambiguous choice operations provided by the unamb package. I used to know a nice article introducing the reader to an unambiguous zip operation closely related to your assertSpine, but I can't find it anymore. If anyone has a hunch what I'm talking about, please do post the link! For now, I can only remember one article by Conal Elliott, which is about the library in general only though."
haskell,3c7nn0,quchen,8,Sun Jul 5 21:03:46 2015 UTC,"Hasn't unamb been pretty much obsoleted by Lindsey Kuper's work on LVars, and the lvish library?  Unamb sometimes works and sometimes doesn't. The way I understand it, Kuper's work provides a theoretical underpinning for when it works and when not, and provides an alternative whose types ensure that you use it only in the cases that are guaranteed to work."
haskell,3c7nn0,yitz,4,Sun Jul 5 22:15:01 2015 UTC,"This is a connection I really wanted to explore, but unfortunately never got round to. I'd also love to hear if this is a real connection or not."
haskell,3c7nn0,ocharles,4,Mon Jul 6 07:45:11 2015 UTC,"did you mean ""Lazier function definitions by merging partial values"" by Conal Elliot?"
haskell,3c7nn0,DanielWaterworth,8,Sun Jul 5 21:37:43 2015 UTC,"maybe you've never needed to check whether the reversal of an infinite list was empty,   It's not a question with a well defined answer."
haskell,3c7nn0,Taladar,5,Sun Jul 5 17:46:52 2015 UTC,"Why not? Shouldn't the concept of 'is the same length as' still have meaning even in infinity, even if it is hard to actualy calculate the length?"
haskell,3c7nn0,tel,7,Sun Jul 5 18:59:18 2015 UTC,"It's not clear that an infinite stream has a reversal. If it did, we might have such properties... but when does it?"
haskell,3c7nn0,Taladar,5,Sun Jul 5 19:07:29 2015 UTC,"I would say it has one, it is just impossible to calculate the first element of the reversal in finite time since we do know that reversal is a shape-preserving operation we should be able to say a lot about the spine but very little about the elements."
haskell,3c7nn0,Archaeanimus,4,Sun Jul 5 20:22:31 2015 UTC,"it is just impossible to calculate the first element of the reversal in finite time   Which is to say, reversal is not well-defined over infinite lists. If you want to reason about the behaviour of reversal on infinite lists, you must first expand the definition of reversal to be well-defined over infinite lists.  Actually, what this means is that the ""last element"" function is not well-defined over infinite lists. It is not simply the case that it takes infinitely long to compute the last element of an infinite list; the ""last element"" does not exist, any more than the ""last element"" of an empty list exists.   we do know that reversal is a shape-preserving operation   We know that reversal is a shape-preserving operation on finite lists. That does not imply that a suitably extended concept of reversal would have the same property over infinite lists."
haskell,3c7nn0,tel,3,Mon Jul 6 09:16:10 2015 UTC,"Well, it depends on a lot of things. If we take streams to be things where we compute the first element and then the rest. If we take our reversal of one to be computing its first element as ""find the end of the input stream and then return it"" then we can be quite confident that this is not an effective procedure for getting even the first element of the stream. Subsequently, we can receive none of the others.  So I'd say that either (a) you have more information about the streams you are working with than I just laid out, (b) reversals of streams does not make any sense, or (c) your domain includes bottom and reverse = const bottom."
haskell,3c7nn0,kcuf,3,Mon Jul 6 01:51:24 2015 UTC,"It doesn't. A list is an enumeration (a mapping from N to your set). The reversal is not an enumeration as don't have a way to define it: no matter what value 1 maps to, it will be incorrect."
haskell,3c7nn0,evincarofautumn,3,Mon Jul 6 17:43:59 2015 UTC,"Hm, that’s curious. Are all infinite (“does not end”) streams S expressible using iterate f for some f? If so, the infinite (“does not begin”) reverse of S ends at a fixed point of the inverse of f. Call that inverse g. The reason you can’t find the first element is that there are infinitely many possible inputs tog, and you haven’t chosen one by making the stream finite."
haskell,3c7nn0,Archaeanimus,7,Sun Jul 5 22:58:09 2015 UTC,"Are all infinite (“does not end”) streams S expressible using iterate f for some f?   Nope! There are uncountably infinitely many infinite streams (with an element type with two or more inhabitants; see Cantor's diagonalization argument) and countably infinitely many expressible computable functions (read: Turing machines). For every infinite stream to be representable by iterate f for some f would require, essentially, a bijection between the set of infinite streams (uncountable) and some subset of the set of functions (countable), which is impossible.  This is essentially the same reason that there are uncountably many real numbers which cannot be described or represented in any form (and in fact only countably many can).  Edit: In fact, this argument answers in the negative to the more general question: are all infinite streams expressible at all?"
haskell,3c7nn0,tomejaguar,5,Mon Jul 6 08:58:53 2015 UTC,"There are uncountably infinitely many infinite streams   Ah, but the uncomputable ones won't be inhabitants of S!"
haskell,3c7nn0,evincarofautumn,2,Mon Jul 6 18:15:29 2015 UTC,"Huh. So with probability 1, a randomly chosen instance of any infinite data structure is uncomputable."
haskell,3c7nn0,tel,3,Mon Jul 6 22:37:11 2015 UTC,"Nope! For example,  fibs = 1 : 1 : zipWith (+) fibs (tail fibs)   would require  f(1) = 1 f(1) = 2   Which contradicts the definition of f as a pure function (as required by the type of iterate)."
haskell,3c7nn0,tomejaguar,1 point,Mon Jul 6 10:29:07 2015 UTC,"I'm not really sure I understand what you mean. S = iterate (const 0) is one such f, non-invertible obviously. On the other hand, if any stream has a reverse then S does: it most certainly is repeat 0.  But I'm not computing that reverse as a reverse of a stream. I use far more information such as exact knowledge that it's generated as a function f applied to iterate where f happens to be const k for some k. I can't rightfully claim I reversed the stream.  Honestly the most I could claim is that you cannot find evidence to distinguish reverse S and repeat 0, but that claim also holds for any answer since we will clearly never observe anything of reverse S."
haskell,3c7nn0,htebalaka,1 point,Mon Jul 6 02:27:52 2015 UTC,s is streamMap head (streamIterate streamTail s) if that helps.
haskell,3c7nn0,htebalaka,3,Mon Jul 6 18:33:14 2015 UTC,"How does sort compare on last. I remember a while back someone posted a version of quicksort that I think used the same trick, which let them access the i-th greatest element for any i in O(n). Cool to see more examples of this."
haskell,3c84qr,RnMss,30,Sun Jul 5 20:10:26 2015 UTC,"Just dive in and build something, even if it's not the best approach.  Haskell's very, very, very refactor-friendly because of the awesome type system, so you don't need to architect your application correctly the first time."
haskell,3c84qr,Tekmo,12,Sun Jul 5 21:13:58 2015 UTC,"Emphatically agree. Even if you're not working in Haskell, if you feel overloaded with decisions you don't know how to make, the best way to progress from there that is to dive in and gather data, so that you will be able to make these decisions in the future. Don't be afraid to make a total pile of crap, it's the best way to learn."
haskell,3c84qr,hdgarrood,3,Sun Jul 5 22:20:53 2015 UTC,"It's like learning a foreign language. The person is old, but the vocabulary is like children's.  I started learning programming when I was very young. And then when I started learned C++ I thought it was like any other (imperative) languages.  Now I have been using C++ for about 7 years, and Haskell only 2 years. When I had been using C++ for 2 years, I didn't know my code could be beautiful and readable. All that makes me happy is that my code works and runs fast.  But now that I know, there is always someone inside my mind saying ""your code is ugly"". Hard to get rid of it. I must be having OCPD.  -_-||"
haskell,3c84qr,Guvante,2,Mon Jul 6 04:50:52 2015 UTC,"Working >>> pretty. Hard thing to follow but the truth.  Also keep in mind that lots of OOP still works in Haskell, encapsulation is obviously still beneficial, you just have objects that return modified versions instead of internally managed state."
haskell,3c84qr,Guvante,2,Mon Jul 6 12:37:43 2015 UTC,encapsulation is obviously still beneficial   What do you think stands beside encapsulation?
haskell,3c84qr,tejon,1 point,Mon Jul 6 15:48:05 2015 UTC,Structure mainly. You still have members and functions that operate on those members even if you don't have this.
haskell,3c84qr,yitz,6,Mon Jul 6 17:20:27 2015 UTC,"Haskell's very, very, very refactor-friendly    As a relative noob, I'd like to voice my agreement here. In my only serious project so far, near the end I realized that I'd made a bad decision in module that half the code relied on. I needed to change it and everything that used it. Fixing that was one of the easiest tasks in the entire project! I don't think it took more than 15 minutes.  It's very true that as a newbie, figuring out how to structure things in Haskell can be a huge and frightening task. But the thing that's not intuitive when you're used to imperative languages is that once you've got a structure in mind, you've basically written the code in your head because Haskell is a language for describing structures. All that's left is to type it out. And with the flexibility of higher-order types and functions, you can do this one small piece at a time."
haskell,3c84qr,david72486,2,Sun Jul 5 22:12:39 2015 UTC,"For me, it is more like that refactoring by replacing something stateful with something stateless is easy, but not vice versa."
haskell,3c84qr,Taladar,1 point,Mon Jul 6 15:49:33 2015 UTC,"In practice it's not too hard the other way either. Typically, you'll need to change the types of only a few functions. In any given expression, there will be at most one or two touch points that need to become stateful, so you split the expression at those points.  If there is much more than that to do, then you are changing the entire point of the program in a deep way, and you probably would have needed a total re-write in any language.  In this direction as well as the other, the compiler uses the type system to guide you through what ever changes are needed. It shows you what needs to be changed and makes sure you get it right."
haskell,3c84qr,Taladar,4,Tue Jul 7 15:33:06 2015 UTC,"There's a lot of stuff that is still ongoing in development, people aren't always going to have answers to your questions, and they very may well never have answers that make sense to you. You can look at that as an opportunity to shape your own programming philosophy more, that's basically what I did when I got stuck - try to find opportunity in what is actually quite challenging.   That said, I don't program a ton in Haskell, so take my advice with a handful of salt. Some things just take a really long time to learn, and so much of what you learn along the way is going to be stuff you have to theoretically come to grips with yourself. If you've got hard questions without answers, the best person to try to answer those questions correctly is yourself.   A friend of mine says that ""perfect is the enemy of good"". Just start somewhere, a little bit, instead of not starting. I get the phobia of starting, of making decisions, when you are working with something that seems like it was built from perfect decisions. But even the tiniest of steps might help you see that you are actually making gigantic strides in progress, it's just hard to evaluate when it's all crammed up in your head, and not a lot of people care about the topic to pay enough attention to listen to you, and those that do are either too shy or too sure of themselves to help provide a clue."
haskell,3c84qr,Taladar,1 point,Sun Jul 5 20:36:35 2015 UTC,"Why is this ""[deleted]""? Maybe I could have prevent that, it's just that I was thinking what to reply."
haskell,3c84qr,agocorona,3,Wed Jul 8 15:41:12 2015 UTC,"I would say just have a project you want to complete, and make it work any way you know how. If you're using a pattern that you are pretty sure isn't ideal, but don't know a better way, just press forward.  A lot of things become more clear once you've gone farther down the path, and as Tekmo mentioned, you can usually refactor later.  Don't try to write perfect code from the beginning, because you'll never make any progress (and likely give up).  Remember this program isn't the last one you'll ever write - and look forward to the day when you can look back on it and be embarrassed (because that's a sign you've learned a lot!)"
haskell,3c84qr,mbrodersen,3,Sun Jul 5 21:49:17 2015 UTC,"What do you gain by encapsulating your state? It is still just as many bits of state, just as many potentially different behaviours, even if you hide which types of state there are."
haskell,3c9x9h,jmite,7,Mon Jul 6 06:26:36 2015 UTC,"Wait no no no no, GHC doesn't fill fields with undefined  try yourself in GHCi:  Prelude> data A = A { a :: Int } deriving Show Prelude> A {} A {a = *** Exception: <interactive>:11:1-4: Missing field in record construction a   It's possible that one of the libraries is using undefined and causing the problem"
haskell,3c9x9h,dramforever,5,Mon Jul 6 10:00:04 2015 UTC,"1st step to ""undebuggable"" bugs: misunderstand bugs."
haskell,3c9x9h,dramforever,1 point,Mon Jul 6 10:00:54 2015 UTC,Ahh... this is very informative. I have probably been following a completely wrong route. Thanks so much.
haskell,3c9x9h,dramforever,1 point,Mon Jul 6 19:00:32 2015 UTC,You're welcome :)
haskell,3c9x9h,singpolyma,5,Tue Jul 7 06:45:34 2015 UTC,"That message only comes from direct invocation of undefined, any other thing (such as partial record construction) has its own special error message (usually with line numbers). So, try grepping for undefined -- someone is calling it on purpose."
haskell,3c9x9h,cameleon,1 point,Mon Jul 6 12:29:11 2015 UTC,"This is good to know, I didn't realize this. I wasn't explicitly calling it, but I'll use grep to find out where it is. Thanks."
haskell,3c9x9h,cameleon,4,Mon Jul 6 19:03:19 2015 UTC,"Note that you can load both the library and the executable in GHCi: just pass -i options to include both source directories, then load the executable.  Additionally, try compiling with profiling and passing +RTS -xc to get a stack trace. That might help you find the location."
haskell,3c9x9h,maxigit,2,Mon Jul 6 09:12:12 2015 UTC,"Very handy to know about GHCi, thanks!  For -xc, will --enable-executable-profiling --enable-library-profiling in Cabal be enough, or do I need -prof?"
haskell,3c9x9h,alan_zimm,2,Mon Jul 6 19:01:31 2015 UTC,"I think the cabal flags are enough and shouldn't be combined with -prof. However, you will probably need to pass --auto-all to GHC."
haskell,3c9x9h,alan_zimm,2,Mon Jul 6 20:06:00 2015 UTC,Have you tried to feel for 'undefined' (in all packages). If they are too many replace them by an error with a message indicating the location.
haskell,3c9x9h,cocreature,7,Mon Jul 6 10:03:17 2015 UTC,A useful replacement error value is assert False undefined which then gives the precise error location when it gets executed
haskell,3c9x9h,sccrstud92,2,Mon Jul 6 12:23:58 2015 UTC,"This is an incredibly handy trick, thanks so much! I'm not calling undefined to my knowledge, so I'll have to search through the libraries and see where it's being called."
haskell,3c9x9h,cocreature,3,Mon Jul 6 19:02:41 2015 UTC,Credit for the trick goes here  http://dev.stephendiehl.com/hask/#bottoms
haskell,3c9x9h,creichert,5,Mon Jul 6 19:29:02 2015 UTC,Partially initializing a record doesn't really make sense in haskell. After all it is immutable so you can't initialize those fields later. There are basically two ways around the problem of not being able to initalize everything at once. Often you can use Applicative style to initialize your datastructure. If that's not possible I recommend either using a different structure if the intermediate state is actually used and not just an intermediate state or just sticking with tuples until you can fill your complete structure.  So to summarize: If there is an undefined in your code it is very likely to be a bug and you should search for the place where it is in your code and fix that part.
haskell,3c9x9h,alt_account10,7,Mon Jul 6 06:35:35 2015 UTC,"His question is pretty much ""how do I find the location of this bug?"" so your advice to ""find the bug and fix it"" is probably not helpful."
haskell,3c7h5j,maxigit,8,Sun Jul 5 16:36:48 2015 UTC,"I am not sure about your assertion that it is a Monoid.  For one thing there are the elements of an SQL query which can only be used once like limit and offset and in particular aggregate functions.  Speaking of the latter, did you consider the difference between WHERE and HAVING conditions (before and after aggregates). This came up in a related, smaller scale, one off, internal project one of my co-workers wrote recently.  I assume you plan to add other backends? How about making at least one more (e.g. postgresql-simple based) to make sure your backend API is at the proper abstraction level."
haskell,3c7h5j,Taladar,3,Sun Jul 5 19:08:48 2015 UTC,I think limit can be treated as a monoid if the library recognizes there can be only one and if you ask for it twice just let's the smaller one win. e.g:  limit 5 <> limit 6 = limit 5 limit 6 <> limit 5 = limit 5   It's probably fine to let the rightmost one win also.
haskell,3c7h5j,rdfox,1 point,Sun Jul 5 20:30:47 2015 UTC,Another alternative would be to have an error value for these cases in the type i suppose.
haskell,3c7h5j,Taladar,4,Sun Jul 5 20:44:26 2015 UTC,Then you have something more than a monoid though.
haskell,3c7h5j,kcuf,2,Mon Jul 6 04:54:16 2015 UTC,"Well, 'SQLFragment []   []' is an instance of Monoid. However limits, offset (as well the type of query : SELECT, INSERT, etc are not part of it and are specified when executing the query).  Yea, having and where are treated diff entry.  About backend, fragments are just converted to query so they could be used with every backends. What is specific is when using type safe query to get a result of the correct type. Writing the PostgreSQL-simple backend should just be matters of swapping MySQL with PostgreSQL."
haskell,3c7h5j,ricky_clarkson,2,Sun Jul 5 20:55:29 2015 UTC,"""joins can be deduced automatically from an join graph.""  Any ideas on generating the join graph? Particularly for DBs that don't have the constraints built in."
haskell,3c8a3k,mightybyte,3,Sun Jul 5 20:56:10 2015 UTC,First part here: https://www.reddit.com/r/haskell/comments/3c1fzy/set_theory_and_haskell_part_1/
haskell,3c88x0,nabokovian,3,Sun Jul 5 20:45:31 2015 UTC,"I am not an expert on pseudorandom numbers, but this is a strange approach because each time you run the program you are seeding the random number generator with a new seed. If you replace the last line with  mapM_ print (take 9399 (randoms g :: [Victim]))   and just run the program once you'll generate all your random names from the same seeded generator.   Regardless, I'm not sure your data is unexpected. I get a similar spread when I do it this way, but Henry is not always at the top.  $ cat log | sort | uniq -c 1919 Bob 1883 Carlo 1869 Deepak 1851 Henry 1877 Joe"
haskell,3c88x0,sasquatch007,2,Sun Jul 5 21:04:50 2015 UTC,"On the face of it, as long as it's not consistent, an error by roughly 1% from the expected frequency doesn't seem a big deal.  However, assuming a flat distribution, the probability of getting more than 2000 Henrys from that run is about 0.001, and to get more than 2015 had exceeded the accuracy of the online binomial calculator I just used (it said 0.000).   In any case, the chance of you both getting over 2000 for the same item is less than one in a million, but given that it was a different favourite, that's 1 in 250 000. I think it's fair to conclude that the distribution is unlikely to be completely flat."
haskell,3c88x0,_AndrewC_,2,Mon Jul 6 12:15:46 2015 UTC,"Is Henry being on top repeatable? The values of Henry and Bob differ by only ~1%. Without doing a test for uniform distribution, this seems random enough to me.  BTW, here's a much faster implementation that doesn't use runhaskell (I quickly typed it up in the console; excuse the formatting):  {-# LANGUAGE ScopedTypeVariables #-}  import qualified Data.Map as M import Data.Ord (comparing) import Data.List (sortBy) import Control.Monad (join) import System.Random (randomRIO)  data Sum1 = Bob | Joe | Henry | Deepak | Carlo deriving (Show, Enum, Bounded, Eq, Ord)  sums :: [Sum1] sums = [minBound..maxBound]  maxInd :: Int maxInd = length sums - 1  rchoose :: IO Sum1 rchoose = let{ss :: [Sum1]; } in do{i <- randomRIO (0,maxInd); return (sums !! i)}  buckets :: Sum1 -> M.Map Sum1 Int -> M.Map Sum1 Int buckets s m = M.adjust (+1) s m  printM :: M.Map Sum1 Int -> IO () printM = mapM_ (\(k,v) -> putStrLn $ show k ++ "": "" ++ show v) . sortBy (comparing snd) . M.toList  trials :: Int -> IO () trials n = join $ fmap (printM . foldr buckets initB) (sequence $ replicate n rchoose)"
haskell,3c88x0,ForTheFunctionGod,2,Sun Jul 5 21:22:45 2015 UTC,Have you tried using uniform from Control.Monad.Random?  I think something like this might work:   main = evalRandIO $ uniform [(minBound :: Victim) .. (maxBound :: Victim)]
haskell,3c88x0,TheCriticalSkeptic,1 point,Mon Jul 6 02:48:15 2015 UTC,"You're basically seeing a real life version of the law of large numbers from mathematics, here.  If you sample enough times, there is obviously going to be something that is chosen more than the other --- the probability that they are all the same as extremely small.  If henry accrues a large lead near the beginning by coincidence, and you assume that the other 9000 totals are perfectly uniformly distributed, then henry's ""large"" lead at 400 items in becomes a ""pretty negligible"" lead at 9400 items in...which is what we'd expect.  The law of large numbers says that even if things are weirdly chosen in the beginning --- or if there are weird streaks in the middle --- as you go on, the ""percent difference"" caused by these streaks and weird values has to go to 0.  What we're seeing here is a % difference that is like 1%, so it looks like we're seeing something decently random here.  But the point is that we can expect something to be at the top.  And we can expect what's at the top to be a fairly large ""absolute"" number (50), bounded by a small ""percent"" difference.  But I'd check with other seeds, and also rearrange the constructors to see what happens."
haskell,3c5383,cies010,4,Sat Jul 4 21:36:24 2015 UTC,"It seems that Emacs and Vim are the main editors. I expect that Atom will quickly become another main editor given how quickly it gained popularity (combined with that it is open source and uses JS for plugins).  There is very little mention of hdevtools (2) and ide-backend (0). On the other hand I was surprised to see so many using hlint. Finally this survey pointed me to the existence of ghcid, somehow I never heard of it before.  In the comments of this survey we also found many pointers that it is hard to install sophisticated Haskell tooling. For that reason many used more conservative tooling then what is currently available.  Much of these installation problems could probably be solved by Stack. Then I found out about stack-ide, which is an Stack aware kind of ide-backend that has my hopes for bringing easily installable advanced Haskell tooling to the masses."
haskell,3c5383,SkoomaMudcrab,3,Sun Jul 5 10:32:55 2015 UTC,Main editor frequencies...   vim: 14 emacs: 13 Atom: 4 SublimeText: 4 vi: 2
haskell,3c5383,hiptobecubic,3,Sat Jul 4 21:37:11 2015 UTC,"Hooray for Vim, the best text editor that is not an attempt at a Lisp OS disguised as a text editor, that humanity has invented."
haskell,3c5383,jeremyjh,5,Sat Jul 4 21:49:35 2015 UTC,I find more and more people use Vim in Emacs with Evil :)  Personally I think that is probably the way to go as Vim is not very capable in attaching background processes.
haskell,3c5383,hiptobecubic,3,Sat Jul 4 21:53:51 2015 UTC,"My experience has been that only people who can tolerate this are people who would have been fine using vi instead of vim anyway. Evil mode is by far the best emulation, but lacks support for all of the plugins that I use and behaves slightly differently even for some stock text objects.  Arguments about embedding other processes never really won me over. There's no reason to emulate a window manager in Emacs. Just use a window manager. Even just tmux is fine and supports sending keys if that's your thing.  Ive tried it four times now and have only lasted about six days total before going back :("
haskell,3c5383,kqr,1 point,Sun Jul 5 14:04:38 2015 UTC,Have you looked at spacemacs? The plugin integration in haskell mode is very well done.
haskell,3c5383,vagif,1 point,Sun Jul 5 21:15:43 2015 UTC,"The problem isn't the Haskell r, it's the text support. Vim is anrr excellent text editor and I find myself typically pretty frustrated when I have to edit text in other contexts because there are just too many things I want that are missing, including things written in plugins."
haskell,3c5383,erewok,-1,Wed Jul 8 05:22:59 2015 UTC,that is probably the way to go as Vim is not very capable in attaching background processes.   FTFY. ;)
haskell,3c5383,codygman,6,Sun Jul 5 07:29:06 2015 UTC,Not so fast. I did not take part in the survey and i'm using emacs.
haskell,3c5383,rdfox,3,Sun Jul 5 03:28:42 2015 UTC,"Me too, but I'm a Haskell amateur, so I'm not sure if I count."
haskell,3c5383,codygman,3,Sun Jul 5 06:20:20 2015 UTC,https://github.com/syl20bnr/spacemacs ;)
haskell,3c5383,mreeman,2,Sat Jul 4 23:14:33 2015 UTC,"I like spacemacs but I find that every hour that I don't restart it, it consumes another gigabyte of memory."
haskell,3c5383,rdfox,3,Sun Jul 5 01:03:59 2015 UTC,Really? I've had it open for about a month and don't see any issues. What OS are you on and what version of spacemacs?
haskell,3c5383,anders_,9,Sun Jul 5 08:26:00 2015 UTC,What OS are you on   He already said he was on emacs :P
haskell,3c5383,ranjitjhala,1 point,Sun Jul 5 12:07:23 2015 UTC,I drive a mac. Spacemacs is at version 0.102.2. There's reason to believe it's my configuration which I've copy-pasted from somewhere ...  dotspacemacs-configuration-layers '(     ;; --------------------------------------------------------     ;; Example of useful layers you may want to use right away     ;; Uncomment a layer name and press C-c C-c to install it     ;; --------------------------------------------------------     auto-completion     better-defaults     (haskell :variables             haskell-enable-haskell-process-log t             haskell-enable-ghci-ng-support t             haskell-enable-shm-support t             )     (colors :variables (display-graphic-p))     (git :variables         git-gutter-use-fringe t)     markdown     org     syntax-checking     xkcd     gtags     shell     emacs-lisp     dash     )
haskell,3c5383,tomejaguar,3,Sun Jul 5 12:07:05 2015 UTC,"PSA for anyone who used to use ghc-mod but doesn't because of 7.10 wonkiness:  The version from git seems to work just fine. It also has an extra helper program meaning it no longer dies if it's compiled against a different version of Cabal than GHC is.  (Also if you have any niggling issues that you haven't reported yet, do so, because it's going to be getting a lot of attention this summer.)    edit: ghcmod-vim gives an error on first use with the git version of ghc-mod, due to it expecting there to always be exactly three components in the version number. You can either ignore it or change the version in the cabal file to something greater than or equal to 5.3.0 before installing. Presumably the latter."
haskell,3c36gd,agrafix,15,Sat Jul 4 08:59:49 2015 UTC,"Pretty nice, quite advanced too.  I'm working in a presentation like this but for beginners, with Scotty and plain json responses, so I'm gonna steal some of your ideas :P (like the colour associations in descriptions, pretty clever)"
haskell,3c36gd,clrnd,5,Sat Jul 4 13:33:40 2015 UTC,Let us know when your presentation for beginners is ready!
haskell,3c36gd,enz_,10,Sat Jul 4 20:17:59 2015 UTC,Author here: people might be interested to know that there is a set of exercises that come along with the slides.
haskell,3c36gd,serras,1 point,Sun Jul 5 07:37:24 2015 UTC,"Thanks for writing the book, got it as soon as it came out. Lots of great code snippets. I always keep referencing the chart of string-like type transformations."
haskell,3c36gd,akurilin,4,Sun Jul 5 09:42:22 2015 UTC,Woohoo the author is sometimes an Idris user too! ;-)
haskell,3c36gd,jfdm,2,Sat Jul 4 16:21:01 2015 UTC,I saw this presentation at LambdaConf - it was great then and great now. It got me started with my first Haskell web app.
haskell,3c36gd,TdotGdot,5,Sun Jul 5 00:13:03 2015 UTC,"I've had the opposite experience. As someone who has written his own framework for a real product, and switched away from it years later, I wouldn't do it again.  There's simply too much pre-existing functionality that should not be re-invented, functionality that you will almost always need to add to your own applications: a framework saves you all of that development time. Booting, reloading, logging, security (e.g. CSRF protection), templating, routing, cache busting for assets, asset pipeline, form helpers and validators, redirection through sessions, test helpers etc. These aren't problems you should be solving as an application developer.  I'm not a huge fan of being forced into a framework's way of doing things, but Yesod is fairly unopinionated. You can mix and match a bunch of utilities that all interact pretty well together, and you can add your own. The beauty of Haskell is that as long as the pieces fit together, you can plug in whatever library you want to solve that problem. It gets a bit trickier when the functionality is baked into some core framework monad you're using, but I haven't run into that issue too often."
haskell,3c36gd,akurilin,2,Sat Jul 4 22:21:14 2015 UTC,"Same experience here. After the brutal learning curve was over, yesod has been the most pleasant for me. I feel the yesod has the right amount of constrictiveness: enough to give you all the normal things people need for a website but not too much to stop me from layering on my own abstractions like yesod-table."
haskell,3c36gd,andrewthad,1 point,Sun Jul 5 09:00:08 2015 UTC,What does it enforce that is incorrect?
haskell,3c36gd,ephrion,1 point,Sun Jul 5 10:53:50 2015 UTC,"Doesn't persistent 2.x address most of this? If you can let us know what the specific issue is and how it's preventing your use cases, we can always look into it, see what can be done."
haskell,3c36gd,akurilin,1 point,Sun Jul 5 18:57:21 2015 UTC,"http://www.yesodweb.com/blog/2014/08/announcing-persistent-2  The idea is that you no longer need a surrogate serial primary key for persistent to work, which was somewhat annoying, as you pointed out. You can now pick an arbitrary key (not sure if you can avoid a PK altogether, maybe?) that's more natural. Can be composite as well if you want."
haskell,3c36gd,akurilin,1 point,Sun Jul 5 19:17:53 2015 UTC,"Do you find that in any language, or just Haskell? I think I feel the same way,but haven't been able to articulate it."
haskell,3c36gd,zcleghern,3,Sun Jul 5 19:24:18 2015 UTC,"I've found it in other languages too. I feel all of these ""rail-like"" (including rails) frameworks are most useful for small projects and prototypes.   As the project becomes big you end up using just a subset of it (which means they end up getting in the way).   I haven't used yesod or snap on large projects but I have done Play (Scala) and Rails (for a short while) and felt the same way."
haskell,3c36gd,Die-Nacht,2,Sun Jul 5 19:28:55 2015 UTC,"I have used yesod and rails (and CakePHP and a little bit of Play, all on medium-large projects), and I can assure you that yesod is a completely different animal. Rails optimizes its object models for use in forms. It's clear that the whole thing was built with crud applications in mind. As things get bigger, several features (like before_save callbacks in models or before_filter in controllers,  etc.) do not seem to be appropriate for real projects. Yesod's ORM (persistent) is much less invasive, and the core of yesod focuses on routing and handling requests. Actually understanding things takes a while, but I would contend that it is the best general-purpose web framework I have found. Don't be mislead into thinking that yesod is the same thing as the others because it really is different."
haskell,3c3pta,wolftune,1 point,Sat Jul 4 13:52:24 2015 UTC,Nice write up!
haskell,3c3pta,cies010,1 point,Sun Jul 5 10:34:09 2015 UTC,Thanks :)
haskell,3c3pta,chreekat,1 point,Wed Jul 8 18:42:58 2015 UTC,Thanks :)
haskell,3c0baw,rostayob,14,Fri Jul 3 16:38:41 2015 UTC,We really need to ship GHC with the DWARF symbols included (in a separate -dbg package on platforms where that makes sense).
haskell,3c0baw,tibbe,7,Fri Jul 3 19:54:50 2015 UTC,"Agreed.  Opened a ticket https://ghc.haskell.org/trac/ghc/ticket/10601 .  We also need support on cabal for building with DWARF, like we do for profiling libraries.  Edit: opened a ticked for cabal too: https://github.com/haskell/cabal/issues/2702"
haskell,3c0baw,cartazio,5,Sat Jul 4 08:37:35 2015 UTC,I will totally make sure my personal Mac build has them :) Your directions on the wiki good!?
haskell,3c0baw,simonmar,12,Fri Jul 3 22:08:35 2015 UTC,"perf often attributes cost to the instruction after the expensive one (out-of-order scheduling in the CPU? or something).  So it's not the register-to-register move or the xor, it's the memory read instruction before it that is taking the time."
haskell,3c0baw,tibbe,3,Sat Jul 4 20:09:02 2015 UTC,"I did not know that, thanks."
haskell,3c0baw,edsko,3,Sun Jul 5 18:45:10 2015 UTC,"I asked about this on the perf users list once. This is the response I got:   ""It looks like you're noticing ""skid"" which means the PC returned by the profiling is a little beyond the problem instruction because it is hard for the CPU to stop in exactly the right place.  Typically the problem instruction will be a few before, not after."""
haskell,3c0baw,lykahb,7,Mon Jul 6 09:34:35 2015 UTC,Very nice!
haskell,3c0baw,scpmw,4,Fri Jul 3 18:43:33 2015 UTC,A small typo:  sudo apt get install zlib1g-dgb should be  sudo apt-get install zlib1g-dbg
haskell,3c0baw,CharlesStain,1 point,Fri Jul 3 20:43:31 2015 UTC,Thanks!
haskell,3c1fzy,mightybyte,7,Fri Jul 3 21:53:11 2015 UTC,"FWIW (perhaps to help you decide if it's worth your time watching this talk), here's the presenter's own words about what his talk is about:   What is Set Theory:   ZFC set theory is an axiomatic theory of sets. The reason for such a theory is that one wants a ""definition"" of what a set is. The reason that sets are important to mathematics is that they provide an encoding of most of mathematics (there are a couple of reasons why one cannot encode all of math).  Why Learn about Set Theory:  Axiomatic set theories provide the theoretical underpinnings of various subjects of interest to programmers and computer scientists. For instance relational database theory, and Lisp/scheme are both based upon set theory. ZFC set theory in particular acts as an assembly language for most of mathematics. It is also interesting to note the quite a few of the axioms of ZFC come naturally out of common functional constructs such as Append, Filter, and Map.   What I will be Discussing:  In this talk, I will discuss the theory of ZFC set theory, its raison d'etre (to be pretentious), as well as some applications (time permitting). Some Haskell code will also be shown that illustrates the axioms of ZFC."
haskell,3c1fzy,Nebu,-1,Sat Jul 4 04:04:14 2015 UTC,"For instance relational database theory, and Lisp/scheme are both based upon set theory   Well no. Lisp is based on the lambda calculus (as I assume most people on /r/haskell will know) which Church attempted to use as an alternative foundation of mathematics. So it's actually one of the few things explicitly not based on set theory. (Later on it was found that lambda calculus is inconsistent which led to simply-typed lambda calculus and all sorts of other interesting things.)"
haskell,3c1fzy,ganderso,18,Sat Jul 4 04:43:09 2015 UTC,"Oh for crying out loud. Lisp was traditionally given set theoretic semantics. The speaker actually gave a variant of this talk at lispnyc and it was quite well received. Nor was the lambda calculus found ""inconsistent"" because it wasn't used as a logic initially but just to give a formal system for expressing computability. The typed lambda calculus was introduced to capture termination, not ""consistency"" (because the latter doesn't make sense relative to a 'theory of computation').  In fact, when Lisp was initially developed, it was not in any sense at all based on the lambda calculus, which led to the famous funargs problem. Only with the development of scheme did people adopt proper lexical scoping.  You may find it interesting to review the paper in which Howard developed what we call the ""Curry-Howard correspondence"" -- in it, his method of interpretation of types and formulae is done entirely in set-theoretic terms.  I'm glad you have an interest in history. But please try to get it right, or at least not to sound off about it when you are not confident that you are not wrong."
haskell,3c1fzy,sclv,6,Sat Jul 4 05:19:45 2015 UTC,"Nor was the lambda calculus found ""inconsistent"" because it wasn't used as a logic initially but just to give a formal system for expressing computability. The typed lambda calculus was introduced to capture termination, not ""consistency"" (because the latter doesn't make sense relative to a 'theory of computation').   Lambda calculus was intended as a logic, initially. Dana Scott mentions it at 14:45 in this talk: https://www.youtube.com/watch?v=7cPtCpyBPNI&t=886"
haskell,3c1fzy,Faucelme,2,Sat Jul 4 07:39:01 2015 UTC,"Thanks for the nice link to a video. You'll find it agrees with what I said, though expands in more detail. Scott explains that the lambda calculus was developed as an effort towards a logical system, but what was published as the lc itself had that stuff stripped away beforehand, as it was inconsistent. So indeed the lambda calculus as published was not a logic, but simply a formal system of computation."
haskell,3c1fzy,sclv,1 point,Sat Jul 4 14:20:07 2015 UTC,"the latter doesn't make sense relative to a 'theory of computation'   It may not have been a motivating factor for the typed lambda calculus, but as I understand things, there's at least one straightforward interpretation of ""consistency"" w.r.t. a type-based theory of computation: that it is impossible to produce a term of type ⊥."
haskell,3c1fzy,Archaeanimus,2,Mon Jul 6 09:43:32 2015 UTC,"Well, yes, via Curry-Howard, once we have types, we can talk about the logic they correspond to and the consistency of that logic. But this discussion has been about the untyped lambda calculus."
haskell,3c1fzy,sclv,1 point,Mon Jul 6 13:58:12 2015 UTC,"In fact, when Lisp was initially developed, it was not in any sense at all based on the lambda calculus   The original paper (see here) mentions explicitly "" Because we shall later compute with expressions for functions, we need a distinction between functions and forms and a notation for expressing this distinction. This distinction and a notation for describing it, from which we deviate trivially, is given by Church [3]."" where [3] refers to ""3. A. CHURCH, The Calculi of Lambda-Conversion (Princeton University Press, Princeton, N. J., 1941)."" so I wouldn't say it's not at all based on lambda calculus.  I am, however, unfamiliar with the cited book, as well as the funargs problem that you mentioned and I'd be happy to stand correct if I missunderstood anything in what I quoted :)"
haskell,3c1fzy,Stratege1,2,Fri Jul 10 11:11:52 2015 UTC,"section 1.1 of this paper gives  a brief recap of the issue involved: http://www.p-cos.net/documents/dynfun.pdf  Up until the introduction of scheme, lisp traditionally had dynamic rather than lexical scoping.  This is to say that its scoping rules did not match the lambda calculus.  So while the name may have been ""lambda"", it wasn't like the lambda we know and love."
haskell,3c1fzy,sclv,1 point,Fri Jul 10 14:36:50 2015 UTC,"the paper helped a lot, thank you very much."
haskell,3c1fzy,Stratege1,0,Fri Jul 10 22:24:30 2015 UTC,So I scrubbed through this casually and it seems like a very nonrigorous introduction to set theory. Was there any connection to Haskell or was this just bad mathematics for trivia
haskell,3c1fzy,wherethebuffaloroam,13,Fri Jul 3 23:14:55 2015 UTC,"Part two has some code. Also don't confuse informal math with 'bad math'. The discussion of quotients for example went a little deeper than you might think, etc. Sure, if you know ZFC cold this is an intro talk and not for you. But as a popularization it can serve a valuable purpose."
haskell,3c1fzy,sclv,0,Sat Jul 4 01:33:53 2015 UTC,Fair enough. The intro and first bits just seemed to stumble a bit and say stuff a bunch
haskell,3byvg6,LadenSwallow,11,Fri Jul 3 07:25:28 2015 UTC,Is there a changelog somewhere? I don't see it mentioned in the email
haskell,3byvg6,alt_account10,5,Fri Jul 3 12:47:42 2015 UTC,https://ghc.haskell.org/trac/ghc/query?status=closed&resolution=fixed&milestone=7.10.2
haskell,3byvg6,thomie,2,Fri Jul 3 15:57:39 2015 UTC,What about a human readable changelog?
haskell,3byvg6,rstd,6,Sun Jul 5 16:40:45 2015 UTC,"Quoted:   We are pleased to announce the first release candidate for GHC 7.10.2:  https://downloads.haskell.org/~ghc/7.10.2-rc2 https://downloads.haskell.org/~ghc/7.10.2-rc2/docs/html/   This includes the source tarball and bindists for Windows, and Debian Linux. FreeBSD, OS X and Solaris binaries will follow soon. These binaries and tarballs have an accompanying SHA256SUMS file signed by my GPG key id (0x3B58D86F).  We plan to make the 7.10.2 final release in a week or two - so please test as much as possible; bugs are much cheaper if we find them before the release!    Regards,  Austin Seipp, Haskell Consultant Well-Typed LLP, http://www.well-typed.com/"
haskell,3byvg6,sopvop,4,Fri Jul 3 07:26:02 2015 UTC,"I hope #10527 gets fixed in release. There are workarounds, like strategically removing INLINE pragmas, but still it may bite vinyl users."
haskell,3byvg6,acow,8,Fri Jul 3 09:24:42 2015 UTC,"Ben's sleuthing on that bug is incredible! Thanks so much for filing it, it would be somewhat disastrous for me if it made it to release."
haskell,3byvg6,sopvop,5,Fri Jul 3 16:43:35 2015 UTC,"I'm so glad that we have such wonderful people working on GHC, many (most?) of them doing it in their free time."
haskell,3byvg6,acow,8,Fri Jul 3 18:31:22 2015 UTC,"Agreed! It's a mixture of students, faculty, professionals who rely on GHC, and Well Typed who do a lot of the work to keep things running as well as deep dives like this one."
haskell,3byvg6,mallai,4,Fri Jul 3 18:44:10 2015 UTC,Deja vu :-)
haskell,3byvg6,Peaker,3,Fri Jul 3 12:17:39 2015 UTC,I've encountered some issues with hvr's ppa snapshot build of ghc 7.10.2 of a few days ago.  It seems to fail to infer at least a couple of fundeps that 7.8.3 inferred successfully.  Does anyone know if anything changed w.r.t fundeps with 7.10?
haskell,3byvg6,adamgundry,3,Fri Jul 3 22:50:07 2015 UTC,"There certainly are some changes in the constraint solver that mean 7.10 fails to solve some constraints that were handled by 7.8. See #10009 for example, though that is primarily about type families rather than functional dependencies."
haskell,3byvg6,etrepum,4,Sat Jul 4 16:14:53 2015 UTC,"Yes, when the release is made I'll update the binaries."
haskell,3byvg6,technicolorNoise,2,Fri Jul 3 09:56:41 2015 UTC,They'll presumably be updated once the actual release is made. This is only a release candidate.
haskell,3byvg6,jocomoco,1 point,Fri Jul 3 17:30:33 2015 UTC,What is the easiest way to build this version ? I would like to use it to build ghcjs improved base.
haskell,3byf25,ephrion,6,Fri Jul 3 04:35:23 2015 UTC,Thanks to /u/ranjitjhala for this!
haskell,3byf25,spindakin,3,Fri Jul 3 06:38:35 2015 UTC,"Great to see process being made here! Compiling and installing the fork worked, but it doesn't seem to pick up the right package-db in my stack-enabled projects.  If I manually try to run configure like this, I get these errors:  $ cabal configure --package-db=clear --package-db=global --package-db=$(stack path --snapshot-pkg-db) --package-db=$(stack path --local-pkg-db) Resolving dependencies... Configuring project-x.y.z... cabal: At least the following dependencies are missing: basic-prelude -any, filemanip -any, optparse-applicative -any, stringable -any, terminal-size -any   Any pointers?"
haskell,3byf25,ch0wn,2,Fri Jul 3 10:39:38 2015 UTC,Silly question but does which hdevtools point to the right one? This tripped me up when I was working on it :o You may want to kill the hdevtools server process. That's helped me resolve similar issues
haskell,3byf25,snoyberg,1 point,Fri Jul 3 15:48:03 2015 UTC,Just to confirm: does stack build install any of those packages?
haskell,3byf25,ch0wn,1 point,Fri Jul 3 11:14:34 2015 UTC,"Yes, stack build and stack install work just fine."
haskell,3byf25,snoyberg,1 point,Fri Jul 3 11:20:01 2015 UTC,Do you have the same version of GHC on the PATH and being used by stack? You can test this with:  stack exec -- ghc --version ghc --version
haskell,3byf25,ch0wn,1 point,Fri Jul 3 12:16:14 2015 UTC,"I'm using the GHC version I installed through stack, so yes. Thanks for helping, by the way. :)  $ stack exec -- ghc --version ghc --versionThe Glorious Glasgow Haskell Compilation System, version 7.10.1 $ ghc --version The Glorious Glasgow Haskell Compilation System, version 7.10.1 $ which ghc /Users/phartig/.stack/programs/x86_64-osx/ghc-7.10.1/bin//ghc"
haskell,3byf25,snoyberg,3,Fri Jul 3 13:24:31 2015 UTC,"Oh, I think I know what the problem is: you probably aren't using stack from HEAD, which changed the stack path output a bit to make this all work. What does stack path --snapshot-pkg-db look like?  You can try running stack upgrade --git and see if that fixes things."
haskell,3byf25,ch0wn,1 point,Fri Jul 3 13:41:43 2015 UTC,"You're right, I'm not. Sorry, didn't know that was required. And thanks for pointing me to the upgrade command; didn't know about that."
haskell,3byf25,snoyberg,2,Fri Jul 3 13:45:38 2015 UTC,"That's what you get for building off of HEAD: things aren't properly documented and break easily ;)  We're planning another stack release for this Sunday, so this should be a temporary problem anyway."
haskell,3byf25,ch0wn,1 point,Fri Jul 3 13:47:32 2015 UTC,"Okay, upgraded but still the same issue. Do I need to invalidate/rerun something?  $ stack path --snapshot-pkg-db /Users/phartig/.stack/snapshots/x86_64-osx/nightly-2015-06-17/7.10.1/pkgdb/  $ stack path --local-pkg-db /Users/phartig/Projects/haskell/android-lint-summary/.stack-work/install/x86_64-osx/nightly-2015-06-17/7.10.1/pkgdb/"
haskell,3byf25,snoyberg,1 point,Fri Jul 3 13:53:56 2015 UTC,"I'm not sure what's happening. We had a weird OS X issue previously where trailing slashes caused a problem for some reason, maybe try manually running the cabal configure command without the trailing slashes and see if that fixes it?"
haskell,3byf25,ch0wn,2,Fri Jul 3 16:00:37 2015 UTC,"I manually wiped .stack-work, dist/ and now after a new stack build, hdevtools works just fine. Sorry for taking so much of your time, but I'm glad that it's working now. :)"
haskell,3byf25,drb226,1 point,Fri Jul 3 17:35:37 2015 UTC,Is there an issue for this? Can't we just use stripTrailingPathSeparator or something like that?
haskell,3byf25,lleksah15,1 point,Fri Jul 3 16:24:58 2015 UTC,"I installed hdevtools from the linked stack branch and I copied the newly created binary to my path. I also tried launching it manually and it seems to launch the server / shutdown fine.  which hdevtools points to the right binary. The path has be set in linter-hdevtools and hover-tooltips-hdevtools Settings.   Now when I open my Stack project (opened it using the File -> Add Project Folder) in Atom, I don't see any errors being report when I deliberately break things -- it just says No Issues. How do I use hdevtools with an existing stack project? Do I need to specify anything in the settings?   I have only used plain vanilla Vim before so this is all new to me. Thanks!"
haskell,3byf25,ranjitjhala,2,Fri Jul 3 22:29:16 2015 UTC,"I have no idea how Atom works, sorry! You should be able to do hdevtools check $(path to your source file). That will perform the check if there's anything wrong. The file also has to be written to disk in order for it to check, so it can't do checking ""live"""
haskell,3byf25,lleksah15,2,Fri Jul 3 22:34:20 2015 UTC,"Can you first just try with a standalone .hs file (i.e. in a non-stack project) to see if the  atom plugins are working? Did you build the project with stack already? Once you've done that, then open it in Atom and edit source..."
haskell,3byf25,ranjitjhala,1 point,Fri Jul 3 22:40:23 2015 UTC,"/u/ranjitjhala, a stand alone file works well. It gives me inline error messages.  I built my project using stack build and then opened the individual .hs files in Atom but it does not do any error checking.   I noticed  my standalone file has a blue x icon in Atom while my stack projects have a regular black one.   I have never used hdevtools so not sure if I am missing a step. I just opened my project after building it using stack build. Do I need to setup any specific settings in stack to make this work with hdevtools?   When I did check like /u/ephrion suggested I get this    hdevtools check rest-api/src/Main.hs   hdevtools: <socket: 4>: hGetLine: end of file"
haskell,3byf25,ranjitjhala,1 point,Fri Jul 3 23:12:14 2015 UTC,"hmm... can you try killing all the hdevtools processes and restarting? so:  $ killall hdevtools   (To be sure, I always do it a bunch of times) and then try again:  $  hdevtools check rest-api/src/Main.hs   ?"
haskell,3byf25,lleksah15,2,Sat Jul 4 00:08:56 2015 UTC,also: can you double check with a which hdevtools that the right one is being run? You shouldn't need to do anything other than have a stack.yaml file on the path from the target (rest-api/src/Main.hs) to the root /...
haskell,3byf25,ranjitjhala,1 point,Sat Jul 4 00:18:10 2015 UTC,"Yup, the right hdevtools is being picked up. I don't follow your last comment though. My directory structure looks like this:    - rest-api       - stack.yaml      - src           - Main.hs           - more modules   Should stack.yaml be inside the src directory?"
haskell,3byf25,lleksah15,1 point,Sat Jul 4 00:43:08 2015 UTC,That looks fine...
haskell,3byf25,ranjitjhala,1 point,Sat Jul 4 00:46:29 2015 UTC,"Thanks /u/ranjitjhala. I did this:     killall hdevtools   ps -u dev | grep [h]devtools   zsh: no matches found: [h]devtools   hdevtools check src/Main.hs   hdevtools: <socket: 4>: hGetLine: end of file   Now when I do hdevtools check on the standalone file, it just returns without any message.   I tried it on another stack project and same issue."
haskell,3byf25,lleksah15,2,Sat Jul 4 00:25:21 2015 UTC,"puzzling! I'm assuming things work fine for non-stack projects  (e.g. plain cabal or cabal-sandbox projects?) In that case, I  suspect the problem is in the code that runs process to  extract the stack paths.  Can you do this:  Go to the place where you've have the hdevtools code, and do:   $ cd hdevtools/src/ $ ghci  ghci> :l Stack.hs ghci> getStackConfig' ""/path/to/rest-api/src/Main.hs""   and let me know what happens?"
haskell,3byf25,ranjitjhala,1 point,Sat Jul 4 00:45:32 2015 UTC,"Thanks again for helping me troubleshoot this.  I think the issue seems to be the stack command. Since it is aliased it is not being exported to another shell. Let me try creating a symlink.  $ which stack stack: aliased to /Users/dev/stack/stack-0.0.3-x86_64-osx $ ghci GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help Prelude> :l Stack.hs [1 of 2] Compiling Types            ( Types.hs, interpreted ) [2 of 2] Compiling Stack            ( Stack.hs, interpreted ) Ok, modules loaded: Stack, Types. *Stack> getStackConfig' ""/Users/dev/rest-api/src/Main.hs"" /bin/sh: stack: command not found  *Stack> import System.Directory *Stack System.Directory> doesFileExist ""/Users/dev/rest-api/src/Main.hs"" True"
haskell,3byf25,lleksah15,1 point,Sat Jul 4 00:54:56 2015 UTC,"Btw, I suddenly remembered -- can you see this:  https://github.com/bitc/hdevtools/issues/40  There is a known issue with older versions of ghc/cabal -- I had a similar problem myself, and was solved by moving to GHC 7.10 and cabal 1.22."
haskell,3byf25,ranjitjhala,1 point,Sat Jul 4 00:51:42 2015 UTC,"Update: installing the latest version of stack seems to be working ok in GHCi but not inside Atom.   Update2:  Thank you /u/ranjitjhala. It seems to be working inside Atom now. I did hdevtools check on Main.hs and re-opened Atom and that seems to have helped. It sometimes does not show an error but that could also be due to long compile times for my project that has Persistent's Template Haskell.    I recompiled the project with the newer version of stack. I have not changed anything else -- not sure if I need to update my old stack.yaml file or anything.   *Stack> getStackConfig' ""/Users/dev/rest-api/src/Main.hs"" Just (StackConfig {stackDist = ""Caching build plan\nPopulating index cache ...\nPopulated index cache.\n.stack-work/dist/x86_64-osx/Cabal-1.22.2.0/"",   stackDbs = [""/Users/dev/rest-api/.stack-work/install/x86_64-osx/nightly-2015-06-17/7.10.1/pkgdb"",""/Users/dev/.stack/snapshots/x86_64-osx/nightly-2015-06-17/7.10.1/pkgdb"",  ""/Users/dev/.stack/programs/x86_64-osx/ghc-7.10.1/lib/ghc-7.10.1/package.conf.d""]})   For completeness:  I am on hdevtools: version 0.1.0.8 (ghc-7.10.1-x86_64-darwin, cabal-1.22.4.0)  I am on GHC 7.10.1 and I don't think I even bothered to install cabal. Here is an updated error message after fixing the stack command not found issue.  Stack> getStackConfig' ""/Users/dev/rest-api/src/Main.hs"" Invalid option `--dist-dir'  Usage: stack path [--help] COMMAND Print path information for certain things *** Exception: readCreateProcess: stack path --dist-dir (exit 1): failed  Is this because of the version of stack I am using?"
haskell,3byf25,lleksah15,2,Sat Jul 4 01:02:49 2015 UTC,"So all good now, right?"
haskell,3byf25,ranjitjhala,1 point,Sat Jul 4 03:19:41 2015 UTC,"/u/ranjitjhala, it works but it is a bit flaky.  It works for certain modules in the project but not all -- it did work for the other ones for a bit and then stopped working.  I am not sure why that's the case -- cannot really tell any clear pattern. I initially thought the modules that import things that were based on Template Haskell were the culprit but that theory did not hold water for long. Will let you know if I notice any clear pattern as to when it fails."
haskell,3byf25,pimiddy,2,Sat Jul 4 04:07:31 2015 UTC,"ok, please do! (Ideally file an issue etc.) Thanks!"
haskell,3byf25,ranjitjhala,1 point,Sat Jul 4 04:13:47 2015 UTC,"Slightly off-topic, but: Is there emacs integration for hdevtools? There's flymake-hdevtools, but the github page says it's unmaintained."
haskell,3byf25,kfound,1 point,Sat Jul 4 16:56:03 2015 UTC,"As I recall, hdevtools was designed to be pretty similar to ghc-mod, so it shouldn't be too hard to get it to work.  I'd investigate the ide-backend client emacs tool that /u/chrisdoner has worked on."
haskell,3byf25,ranjitjhala,1 point,Sat Jul 4 17:17:50 2015 UTC,This works pretty well (despite the dire warning in the README.)
haskell,3bz9iw,imz,4,Fri Jul 3 10:27:47 2015 UTC,"data-or package also has it. My implementation focused a lot on deforestation of the intermediate data types wherever possible, because that performance was critical for where I was using it. That's all data-or does; I haven't needed to build up the whole ecosystem that these has. So, y'know, whichever floats your boat"
haskell,3bz9iw,winterkoninkje,1 point,Fri Jul 3 20:47:42 2015 UTC,"Thanks for your reply! That's the one I wanted to recall.  I've been using bytestring-trie (thanks for it! BTW, I had to take out some code out of its internals and modify some functions for the construction of a trie because the provided ones didn't perform well in my case; I'm going to show my modifications after a while if I find them sensible on a second look) and had a look through other packages by you. That's when I noticed it and thought why not possibly unify it with these if there are no substantial differences..."
haskell,3bz9iw,winterkoninkje,2,Tue Jul 7 11:03:53 2015 UTC,"Performance-wise, about a year ago I started a major rewrite of bytestring-trie to switch over to using array-mapped-tries in lieu of the big-endian Patricia trees. Then life happened, as it does. I'm no longer using bytestring-trie in the project that originated it, so I just haven't had a chance to get back to the rewrite. But yeah, if you have performance complaints, do let me know and I'll work them in! It's a fun project and I miss working on it"
haskell,3bz9iw,winterkoninkje,1 point,Wed Jul 8 23:50:37 2015 UTC,"...continuing my comments regarding additions to bytestring-trie interface:  I see now that I didn't find something like an issue tracker to publish my additions to, that's why I didn't post them immediately."
haskell,3bz9iw,maxigit,2,Tue Jul 7 11:16:46 2015 UTC,"Yeah, I'm in the process of switching all my darcs repos over to github for the sake of adding a ticket tracker (and CI, etc). Also, bytestring-trie is in the midsts of a major rewrite. But you should be able to post things to the newly created https://github.com/wrengr/bytestring-trie"
haskell,3bz9iw,gallais,1 point,Wed Jul 8 23:42:12 2015 UTC,"Thanks for giving the link to the new place!  Theoretically, I like the possibilitites of darcs more, but practically I have had to use git most of the time. I'm always a bit sorry when darcs is not used..."
haskell,3bz9iw,maxigit,3,Thu Jul 9 04:52:47 2015 UTC,"(Disclaimer : I'm a big fan of the these package which I think is underrated. I use it all the time).  The problem with the zipping continuing after the shortest is you need to find a value for the missing ones. You have two options :   using Nothing so your function is `[a] -> [b] -> [(Maybe a, Maybe b)] or using These instead of Maybe  and get [a] -> [b] -> [These a b] which is much cleaner and easier to use  than (Maybe a, Maybe b). You probably don't need another version that the one provide in the these library."
haskell,3bz9iw,etrepum,3,Fri Jul 3 17:20:08 2015 UTC,I use [the these package] all the time   Do you have blog posts / source files describing interesting use cases for These?
haskell,3bz9iw,maxigit,2,Fri Jul 3 19:25:30 2015 UTC,"Sorry, but I don't have any blog or posts. My main use case is to join (as in SQL) data from csv or different sources.  The align function also works on Map and join on the key. For   fromList [(""a"", 1), (""b"", 2)] `align` fromList [(""c"", 3.0), (""b"", 4.5)] >> fromList [(""a"",This 1),(""b"",These 2 4.5),(""c"",That 3.0)]"
haskell,3bz9iw,pycube,1 point,Fri Jul 3 21:13:27 2015 UTC,"Neat, hadn't seen the these package before."
haskell,3bz9iw,maxigit,1 point,Fri Jul 3 17:32:32 2015 UTC,"Do you understand perhaps Control.Monad.Chronicle? ;)  Me don't (yet), though I'd like to learn."
haskell,3bz9iw,tel,1 point,Fri Jul 3 22:00:11 2015 UTC,Absolutely not. I'm not even sure why it is in this package.
haskell,3bz9iw,maxigit,3,Fri Jul 3 22:13:50 2015 UTC,"Just as you can think of These as a mix of (,) and Either [you can have 2 results (like (,)) or either one (like Either)], the Chronicle monad is a mix of a Writer monad and the Either monad (also know as Except monad). The Chronicle monad has a notion of success (which corresponds to the That constructor for These), failure (which corresponds to the This constructor for These) and success with an attached, accumulated value (like Writer, corresponds to the These constructor). In the docs, this attached value is called the record. The type of the attached value and the failure value must be the same."
haskell,3byqmm,jocomoco,9,Fri Jul 3 06:30:34 2015 UTC,Your link points to a 5 gb zip file. A little heads up would be nice.
haskell,3byqmm,vagif,8,Fri Jul 3 14:07:57 2015 UTC,"aye, and a bit more of a writeup as to how to get it running / what the desired use case is!"
haskell,3byqmm,fredugolon,2,Fri Jul 3 15:55:06 2015 UTC,Here is the screen cast https://youtu.be/UwDpskjf7BA
haskell,3byqmm,sambocyn,1 point,Sat Jul 4 08:24:56 2015 UTC,Basically a VBox 5 RC 1 is what I am running it on.
haskell,3byqmm,codygman,2,Sat Jul 4 10:40:50 2015 UTC,how hard is it to torrent?
haskell,3bx93a,gtab62,10,Thu Jul 2 22:20:48 2015 UTC,https://wiki.haskell.org/GHC/Memory_Management
haskell,3bx93a,ItsNotMineISwear,8,Thu Jul 2 23:00:23 2015 UTC,"The reason GC is easier without mutation is because old objects can't point to new objects. That means you don't need a write barrier for generational GC. It makes concurrent collection easier. That doesn't apply to Haskell because there is mutation in the IO and ST monads and for lazy values. Lazy values work by allocating a location in memory where the value will eventually be stored, and in there you store a pointer to the code that can create that value. When somebody needs the value you run the code behind the pointer and store the value in the location. This mutates the location. It will only be mutated once*, but that doesn't help much with GC. Therefore on a high level the Haskell GC is the same as a Java GC.  * unless you have multiple threads"
haskell,3bx93a,julesjacobs,11,Fri Jul 3 11:11:16 2015 UTC,"It will only be mutated once, but that doesn't help much with GC   It does:  https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/EagerPromotion"
haskell,3bx93a,dtellerulam,2,Fri Jul 3 13:21:26 2015 UTC,"TIL, very interesting."
haskell,3bx93a,julesjacobs,7,Fri Jul 3 14:56:51 2015 UTC,"There's actually a ton of mutation under the hood, due to laziness."
haskell,3bx93a,twistier,5,Fri Jul 3 00:16:03 2015 UTC,http://ezyang.com/jfp-ghc-rts-draft.pdf 2.3.1
haskell,3bx93a,dtellerulam,2,Fri Jul 3 08:44:03 2015 UTC,The immutability may help with concurrent GC. There is talk in the paper about using immutability to reduce per object synchronisation. The idea is that if an object is immutable its not the end of the world if it's copied twice especially as contention is rare anyway.   I don't know if this is implemented in GHC though.
haskell,3bwn4z,dogweather,27,Thu Jul 2 19:30:53 2015 UTC,"The purported problem (probably true) was that the data wasn't capable of ""protecting itself"" from incorrect use. Additionally, lots of bad uncompartmentalized design resulted. E.g., no encapsulation.    To an OO programmer, this yells lack of encapsulation, but to a Haskell programmer, it yells complete lack of types and structure. If your data is an array of strings or integers, you can do almost anything with it that's unrelated to its purpose. If it's a TestResultSet then you can only use functions that work on that type - and of course the module author is in full control of the export list.  So, to address your 5 points:   1  keep all the data related to an entity,   Custom data types   2  restrict access to their data,   Module export list   3  know how to validate their own state,   Validation as part of smart constructors, explicit fail states eg using Maybe or Either data types which cannot fail to be handled, instead of exception-propagating Nulls.  The gold standard, however, is carefully designing your data types so that invalid data is unrepresentable. This can be as simple as using data VisionCorrection = Glasses | ContactLenses | Monacle | Unspectacled instead of an integer, but goes more importantly to things like datatypes where it's impossible to construct a request that's invalid, so that validity is enforced by the compiler on all users of your library.   4  are the locus of business logic for that entity,    The module for that data type.   5  and manage their persistence.   Probably using a good, high-level, type-safe, backend-agnostic solution like Persistent.  The foundations for these features are    pure functions and immutability to isolate different code from interacting with each other unless it's explicit and pipelined, and  a very advanced type system indeed making things explicit and compiler-enforced (and incidentally replacing whole classes of human-generated unit tests with compiler checks)."
haskell,3bwn4z,_AndrewC_,3,Thu Jul 2 23:15:35 2015 UTC,"Great response. I would just add that in addition to using specificity in types to ensure correctness, one can also use generality. Parametric polymorphism is a very powerful tool for ensuring program correctness."
haskell,3bwn4z,ReinH,4,Sat Jul 4 23:19:35 2015 UTC,"To an OO programmer, this yells lack of encapsulation, but to a Haskell programmer, it yells complete lack of types and structure. If your data is an array of strings or integers, you can do almost anything with it that's unrelated to its purpose. If it's a TestResultSet then you can only use functions that work on that type - and of course the module author is in full control of the export list.   Ok, very cool. This might be heresy — but this sounds a little like Java. (?)  I.e., I guess I could approximate some of Haskell's behavior if I used only static (class) methods and defined other classes which are essentially named collections of simpler data types. And, I suppose, only used set-once constant attributes."
haskell,3bwn4z,mightybyte,14,Thu Jul 2 23:36:37 2015 UTC,"I guess I could approximate some of Haskell's behavior if I used only static (class) methods and defined other classes which are essentially named collections of simpler data types. And, I suppose, only used set-once constant attributes.   This will only get you so far.  At the end of the day it is simply impossible to get the same compile-time guarantees in Java that you can get in Haskell because Java is not a pure language.  I gave an example of this in this talk that was directly inspired by my experience with Java.  This was a significant part of my original motivation to start looking at Haskell."
haskell,3bwn4z,cies010,8,Thu Jul 2 23:50:42 2015 UTC,"Also the typesystem of Haskell is way more advanced (called Hindly-Milner), and stays away from the billion dollar 'null' mistake."
haskell,3bwn4z,rpglover64,8,Fri Jul 3 03:43:52 2015 UTC,"Hindley-Milner   Also, Haskell's type system is not really an H-M system, because of type classes."
haskell,3bwn4z,cies010,2,Fri Jul 3 14:00:23 2015 UTC,"Oops, sorry Hindley :)  So is there a better classification for Haskell's type system?"
haskell,3bwn4z,rpglover64,2,Fri Jul 3 15:08:56 2015 UTC,"Not really, as far as I know."
haskell,3bwn4z,theonlycosmonaut,4,Fri Jul 3 16:58:08 2015 UTC,Isn't Hindley-Milner the inference algorithm?
haskell,3bwn4z,rpglover64,4,Fri Jul 3 13:04:01 2015 UTC,Algorithm W is the standard inference algorithm for HM systems; OutsideIn is the algorithm Haskell uses.
haskell,3bwn4z,bartavelle,16,Fri Jul 3 14:02:34 2015 UTC,"There are separate concerns.  The ""capable of protecting itself"" part can be solved in several ways :   immutability let you ignore all the ""defensive copy"" practices that are common in OO languages your invariants can often be expressed thanks to the richer type system, so you don't need to hide anything you can still keep your type invariants by hiding the constructors (see the common Text and ByteString types !)   You can ""keep all the data related to an entity"" with a simple record. As for the persistence story, there are many of them. I am familiar with ... persistent, which works sort of like in other languages, where you define your models and it generates all the boilerplate. Then instead of writing :  x = foo.new(a=3, b=4) x.save()   You write something like :  let x = Foo 3 4 insert x"
haskell,3bwn4z,tactics,12,Thu Jul 2 20:02:02 2015 UTC,"your invariants can often be expressed thanks to the richer type system, so you don't need to hide anything   This feels like it should be sloganed to parody the cliche attack against privacy: ""If you can prove what you've constructed is legal, you have nothing to hide.""  But for sure. Most classes you work in practice are really just mungled up records. If all you have is data to pass around, what would you even want to hide?  Highly stateful components are often closely tied to some IO. If I have a database connection or a network manager or a thread pool, all the state is going to live at the IO layer."
haskell,3bwn4z,ephrion,15,Fri Jul 3 04:31:38 2015 UTC,"Ruby:  class Restaurant   def initialize(opts = {})     @inspections = opts[:inspections]   end    def latest_inspection     @inspections.last   end  end   Haskell:  data Restaurant = Restaurant      { inspections :: [Inspection]     }  data Inspection = Inspection     { date :: Date     , score :: Int     }  lastInspection :: Restaurant -> Maybe Inspection lastInspection restaurant =      let inspects = inspections restaurant      in  if null inspects then Nothing                          else Just (last inspects)"
haskell,3bwn4z,int_index,13,Thu Jul 2 21:03:08 2015 UTC,lastInspection :: Restaurant -> Maybe Inspection lastInspection = listToMaybe . reverse . inspections
haskell,3bwn4z,sacundim,8,Thu Jul 2 21:26:34 2015 UTC,"Actually, the bigger issue here is the implicit and unenforced assumption that the list of inspections is ordered by the Dates.  If the code that constructs and maintains these lists breaks that assumption, both of these lastInspection functions will return incorrect results.  Assuming a restaurant is inspected at most once on each Date, and that Date has an Ord instance, this strikes me as a better solution:  import Data.Maybe import Data.Map (Map) import qualified Data.Map as Map import Whatever.Date  newtype Restaurant = Restaurant { inspections :: Map Date Inspection }  newtype Inspection = Inspection { score :: Int }  lastInspection :: Restaurant -> Maybe Inspection lastInspection = listToMaybe . map fst . Map.toDescList . inspections   Note that the key idea here is that Data.Map is an ordered search tree, so it takes care of keeping entries ordered by their key.  So Map.toDescList gives us constant-time access to the last entry in the map.  Note that this is an excellent example of two techniques that others have mentioned in the threads:   Make illegal states unrepresentable.  In this case, by representing the collection of inspections as a Map keyed by Date, it's impossible to have them out of order. The Data.Map module itself relies on encapsulation to enforce that invariant.  It doesn't export the constructors for the Map type, because that would allow clients to construct invalid maps."
haskell,3bwn4z,rpglover64,3,Fri Jul 3 06:23:48 2015 UTC,"If you're going to go through Data.Map, why not use maxView?  lastInspection = fmap fst . Map.maxView . inspections"
haskell,3bwn4z,sacundim,2,Fri Jul 3 14:06:14 2015 UTC,"Because it appears later in the page than toDescList, of course!  More seriously, I suspect it doesn't make a significant difference."
haskell,3bwn4z,rpglover64,1 point,Fri Jul 3 17:55:44 2015 UTC,"Performance-wise, I expect they're near-identical."
haskell,3bwn4z,dramforever,6,Fri Jul 3 18:48:23 2015 UTC,Just a hint: you can store the inspections in reverse order
haskell,3bwn4z,dsfox,1 point,Fri Jul 3 01:52:47 2015 UTC,Or a set.
haskell,3bwn4z,ForTheFunctionGod,5,Fri Jul 3 06:30:35 2015 UTC,I'm not very familiar with Haskell syntax yet. Could you explain what's going on here?
haskell,3bwn4z,spaceloop,9,Thu Jul 2 22:22:46 2015 UTC,"Restaurant and Inspection are regular data types. The curly braces are shorthand for this sort of stuff:  data Restaurant = Restaurant [Inspection] inspections :: Restaurant -> [Inspection] -- boilerplate getter function inspections (Restaurant ins) = ins   Maybe is a pre-defined data type, defined as  data Maybe a = Nothing | Just a   and corresponds to something like nullable/optional. If you have a type Maybe a, you'll either get a Nothing or a Just a.  lastInspections takes a Restaurant and checks whether the list of its inspections is empty (null inspects). If it is, you get Nothing. If it isn't, it gives you Just <the last element of the inspection-list>. null and last are just regular functions. The let-clause defines inspects to be a shorthand for inspections restaurant.  I hope this helps.  EDIT: /u/int_index expressed the same functionality in a shorter way. You chain 3 functions together (from right to left): first, you get the Restaurant's list of inspections (inspections), then you reverse it so that the last inspection comes first, and then you call listToMaybe on that reversed list. listToMaybe is defined in Data.Maybe as  listToMaybe :: [a] -> Maybe a listToMaybe [] = Nothing listToMaybe (firstElem:rest) = Just firstElem"
haskell,3bwn4z,ForTheFunctionGod,5,Thu Jul 2 23:22:07 2015 UTC,Thanks for writing that all out. That's going to be very helpful for me.
haskell,3bwn4z,kyllo,4,Thu Jul 2 23:35:01 2015 UTC,data Maybe = Nothing | Just a    should be  data Maybe a = Nothing | Just a
haskell,3bwn4z,agocorona,1 point,Fri Jul 3 12:04:26 2015 UTC,Right you are. I fixed it.
haskell,3bwn4z,singpolyma,1 point,Fri Jul 3 13:44:07 2015 UTC,"And you'd probably also have a function that takes a Restaurant and returns a new Restaurant with an additional Inspection appended to the end of its [Inspection].  Mutability just becomes functions returning new/updated ""copies"" of the same object instead of updating them in place."
haskell,3bwn4z,mightybyte,6,Fri Jul 3 04:02:45 2015 UTC,"I have a very particular view of the problem. IMHO the goal in a language like Haskell is to express the problem in a way that the top level entities of the problem are elements of an algebra, or talking in more practical terms, to construct an EDSL (Embedded Domain-Specific Language) in which the entities of the problem are first class. That means that they may be combined to solve the particular problem and all the problems in which these elements may be involved.   Since the top level elements of the problem are the elements of the EDSL, that also means that - ideally - they must appear to the EDSL as if they would have no internal structure. That means that they have no setters/getters, no methods, no state. They are elements.  By combining different EDSLs for different problems: persistence, caching, web page composition, form combinators, page navigation etc the problem can be solved. This is - in my humble opinion - the Haskell way.  What this means in your particular problem? Restaurant and Inspection are two elements. but they have no  properties except that a Restaurant contains inspections and that both are serializable. Since they have no properties, they can not be combined, so they are raw data, and a EDSL can do little more than an OOP language with it. So all the suggestions in the comments for handling the data here are Ok for me. Maybe I would use an EDSL that may ideally automatically cache, transact, query, save and retrieve the data to/from whatever permanent storage when it is needed, using STM.  The TCache package does that.  But your problem has many other elements that have properties and can be combined: pages, HTML elements, form elements, web navigations. These are inherently made to be combined: two form elements makes a form. a page can contain many forms or links. they trigger an invocation to the server. A combination of pages makes a route or a navigation. Navigations or routes can be combined to create an application.  There are many implementations of the formlet concept in haskell to combine form elements and produce  statically typed form results. All major Haskell web frameworks have it. But none treat the rest of the elements of a web application the same way  There is a package ""MFlow"" that treat forms, links, pages and navigations/routes as elements in a monadic EDSL.  For people coming from other languages it is weird since they think in terms of HTML and request-response handlers, not in terms of combinations of elements of the domain problem.  Who thinks in that way? paradoxically two kinds of people: the category theorists on one side and the client, the people who write the specification in the other side. They naturally talk about elements that may involve an entire navigation, like payment. or a set of routes, like  ""visit the catalog"". If the framework  manage the same terms and combine them in the way the client need then the code may follow the specification more closely , would need munch less documentation and can be maintained with much less problems.  It is not weird functional academicism. the goal is to get closer and closer to the specification level. That is why functional programming could be higher level and could allow faster and more flexible, more intuitive and error free programming if the programmer uses his full potentiality and does not limit himself to clone OOP solutions."
haskell,3bwn4z,chrisdoner,4,Fri Jul 3 08:54:55 2015 UTC,"For OO with ""classes"" an object instance is just a closure with some features missing. So a closure in IO with some way to pass in messages (either arguments to the closure you repeatedly call or a thread with Chan/TChan) is the same thing. Though definitely not idiomatic"
haskell,3bwn4z,simonmic,6,Thu Jul 2 21:49:44 2015 UTC,"I was going to write a point-by-point response to your 5 uses of RoR models, but this comment by /u/_AndrewC_ says almost exactly what I was going to say.  For persistence, there are several options.  I use groundhog, but there is also opaleye, and the older haskelldb.  These solutions are pretty good, but I personally think there is still room for improvement in this space--it's a complex problem.  I also gave a presentation on some of these ideas awhile back.  Unfortunately we didn't get video of the presentation, but you can look at the slides here."
haskell,3bwn4z,uncannyworks,2,Thu Jul 2 23:31:14 2015 UTC,"Great, thanks.   Rails programming has gotten a little more Haskell-like: all database queries are now lazy. A Relation is produced and the database is only accessed when the app layer tries to use some of the data. This has some great benefits for View template fragment caching; when the view is cached, the db query is never executed although it ""looks"" like it is."
haskell,3bwn4z,dagit,7,Thu Jul 2 23:48:34 2015 UTC,A module with a bunch of data types and a bunch of functions that work on that data type.
haskell,3bwn4z,ForTheFunctionGod,1 point,Thu Jul 2 23:52:08 2015 UTC,That's pretty cool. Sounds very easy to keep everything together.
haskell,3bwn4z,sambocyn,2,Thu Jul 2 23:54:32 2015 UTC,"It's a great plan, but often needs a slight modification: since circular imports are a hassle with GHC, you'll tend to move the actual type definitions into one module imported by everything else."
haskell,3bwn4z,ForTheFunctionGod,1 point,Fri Jul 3 16:02:49 2015 UTC,"I'm a Haskell noob, ended up doing exactly that the other day."
haskell,3bwn4z,jocomoco,3,Mon Jul 6 08:01:14 2015 UTC,"You might find this interesting: http://arxiv.org/abs/cs/0509027  I wouldn't recommend you use many of the techniques described in that article, but it does cover the ground pretty well.  You might also look at the ""expression problem"" and the proposed solutions. I don't have a particular link to hand you on that.  Typically, when I want something like an object, I create a record and some of the fields are functions and other can be data. I can then populate these fields as needed. I did that for a raytracer when the different object primitives (triangles, planes, spheres, etc) all needed a ""hit"" function.  You can see the idea in play here: https://github.com/dagit/haray/blob/master/src/Graphics/Rendering/Haray/Shape.hsc#L37"
haskell,3bwn4z,rdfox,3,Thu Jul 2 21:27:36 2015 UTC,"The simplest way of doing it - and modules like Data.Map and System.IO, do this - is to write your data type as a record/ADT, but not export its constructors. Instead, you just export ""legitimate"" functions from your module. These functions, in turn, can do whatever validation you want.  Now, if you want persistence and message-sending, it's probably best to use a framework, although that's a lot more complicated a subject."
haskell,3bwn4z,drb226,2,Thu Jul 2 23:10:19 2015 UTC,"Thanks. Is there a module or namespace naming convention in the Haskell world? E.g., Java devs use a (very verbose, of course) domain name in reverse order: com.mycompany.myapp.MyClass. In Ruby, devs pick one name which isn't use on rubygems.org and go with that. E.g. ActiveRecord::Base."
haskell,3bwn4z,Enamex,3,Thu Jul 2 23:45:30 2015 UTC,the idiomatic boilerplate is inserting your module into some hierarchy:   module Data.Tree   or   module Control.Monad   rather than Tree or Monad. but some packages will just write:  module Stuff
haskell,3bwn4z,sambocyn,2,Fri Jul 3 00:25:28 2015 UTC,"Well, there's a very loose, informal hierarchy for libraries. Most people tend to insert their packages on the 2nd level, beneath something like Data, Control, Text, or Numeric if they're writing something ""canonical"" like Data.Tree or Text.Parsec. Less obvious things, or extensions to other modules, generally land on the 3rd level, e.g. Data.List.Safe or Control.Monad.Error.  The system's a bit shit, honestly, but nobody has come up with anything better. The commonly used namespaces are filling up more and more, but thanks to Hackage as a central repo, we've at least managed to avoid Java-style ""solutions"" à la import uk.co.dragonparadise.shadowDrake666.myLittlePackage."
haskell,3bwn4z,Harkins,3,Fri Jul 3 10:31:48 2015 UTC,"Here is a high level understanding of mine (coming from OO):  There are 2 kinds of problems :  1) transformational (e.g. compiler) 2) interactive (GUI, CRUD, video game, etc).  In transformational problems, OO class=  Data Types (class)+Immutable Data Structures (collections) + Lenses (properties) + Pure Functions that transform data (methods)  In interactive problems, OO class =  Data Types wrapped into a Behaviour in an FRP System (class)+ Immutable Data Structures (Collections) + Lenses (properties) + Functions that describe the time evolution of the Behaviour (methods)"
haskell,3bwn4z,mjmrotek,2,Fri Jul 3 08:16:01 2015 UTC,"Maybe this sort of thing will appeal to you. Here's a taste:  rectangle x y width height self = do     super     <- shape x y self     widthRef  <- newIORef width     heightRef <- newIORef height     return $             getWidth  .=. readIORef  widthRef         .*. getHeight .=. readIORef  heightRef         .*. setWidth  .=. writeIORef widthRef         .*. setHeight .=. writeIORef heightRef         .*. draw      .=. printLn (""Drawing a Rectangle at:(""                             << self # getX << "","" << self # getY                             << ""), width "" << self # getWidth                             << "", height "" << self # getHeight)         .*. super"
haskell,3bwn4z,Enamex,2,Fri Jul 3 13:25:44 2015 UTC,"Let's talk algebraic data types for a minute.  In OO languages, an object usually has multiple fields. For example, the Point class defines two fields, x: double and y: double. In algebraic words, this is called a product type, and the ""equation"" is Point = double * double.  In OO languages, you might have an abstract class that describes an interface for more than one class. For example, Shape, with subclasses Square and Circle, and abstract method, area, producing a double, which the Square and Circle classes must implement. In algebraic words, we could call this a sum type, and the equation is Shape = Square + Circle.  In Haskell:  data Point = Point { x :: Double, y :: Double } data Square = Square { side :: Double } data Circle = Circle { radius :: Double } data Shape = SquareShape Square | CircleShape Circle  area :: Shape -> Double area (SquareShape square) = let s = side square in s * s area (CircleShape circle) = let r = radius circle in pi * r * r   Haskell allows you to ""pattern match"" on sum types, which decouples the implementation of new functions from the subtypes, but closes off extension of the Shape type unless you have access to that piece of the source code."
haskell,3bwn4z,mjmrotek,2,Fri Jul 3 16:52:35 2015 UTC,"Not a complete equivalent, however, given that [edit]sum types consistently occupy as much space as their hungriest variant needs."
haskell,3bwn4z,Enamex,1 point,Sat Jul 4 13:38:00 2015 UTC,"unless you're unpacking fields, you're only storing pointers (one word?), and since a constructor won't often have more than a few fields, it's not a big deal right?"
haskell,3bwn4z,anarcap,2,Sat Jul 4 20:41:31 2015 UTC,"You mention some of the benefits of ActiveRecord models, but neglect to mention the drawbacks: they have unpredictable performance, quickly become interdependent, are often unreliable, have large amounts of private functionality, allow domain concepts to be smeared across several models, spend time in invalid partially-usable states, and are difficult to test. These things are hard to recognize, they feel like the normal hassles of development, but they don't need to exist.  To me, as a developer moving from Ruby to Haskell, the ""Haskell equivalent"" is a better-decomposed system that works very differently. I do not want any equivalent to AR models in my code - even in my Ruby code!  I [gave a talk](https://push.cx/2015/railsconf] at RailsConf this year on using FP concepts to improve OO code, with lots of examples from ActiveRecord models."
haskell,3bwn4z,theonlycosmonaut,2,Sat Jul 4 04:26:23 2015 UTC,"Well, it depends, if you want encapsulation, then as mentioned by others, abstract data types with operations that preserve their invariants are the way to go (though there seems to be an unspoken rule, of which I very approve, that one should export all innards of a package anyway, under an ""Internal"" subtree. It can save the users a lot of trouble in some edge cases).  If you want state, there are a couple of possibilities:   State - it's a wrapper over (s -> (a, s)) functions that lets you treat those as if it was just an ""a"" value with some added context. Can be a bit awkward to use as of itself, but really shines when combined with lenses. ST - for operations that are pure in the end, but use mutable state internally. STM - Software Transactional Memory, for concurrently accessed variables without the fear of deadlocks. IORefs - to be honest I haven't ever used them in any bigger code; if I need mutability I probably also need concurrency, and then I feel safer using TVars, even if I'm not sure if I'd ever try to access the same variable from multiple threads.   This being said, avoiding mutable state in IO/STM whenever possible makes the code safer and way easier to test (especially that Haskell's modularity is rather underwhelming, and you can't just replace IO with some mockup monad for the purpose of testing). I know /u/tekmo is/was working on some tools to combine concurrency (sort of) with purity, like MVC, or apparently abandoned arrowized pipes. Though for me it all breaks when I need to make some Haskell computation concurrent to some external code (for example I don't want the GUI to freeze while the program is doing some number crunching). Oh well.  EDIT: There's also one ""design pattern"" i found emerging in my code for communicating with HsQML. To be able to fire signals into QML I need ObjRefs, and to keep track of main program state (where I store various things displayed by the GUI) I need TVars, so I have a toplevel record from which the context object will be created:  data Toplevel = Toplevel    { foo'tv :: TVar Foo    , bar'obj :: ObjRef Bar    ...    }   I need an ObjRef to the context object (or any of helper sub-objects) at hand at all times, so I use a reader monad:  type ObjT a = ReaderT (ObjRef a)   To make things easier I define some helper functions, like:  member :: Monad m => (a -> b) -> ObjT a m b member f = asks $ f . fromObjRef   readVar :: (a -> TVar b) -> ObjT a STM a readVar = lift . readTVar <=< member  subobj :: Monad m => (a -> ObjRef b) -> ObjT b m c -> ObjT a m c subobj f = withReaderT $ f . fromObjRef    (I wish I could wrap also fireSignal, defMethod, and the like from HsQML, but I can't get through the type black magic)  Voilà! Now I have something almost, but not entirely unlike, object oriented programming ;)"
haskell,3bvpm1,andrewthad,9,Thu Jul 2 15:17:48 2015 UTC,"I am the author of the job listing, so feel free to ask any questions here or send me an email at amartin@layer3com.com"
haskell,3bvpm1,haskman,12,Thu Jul 2 15:27:21 2015 UTC,I guess I'll ask the question that always comes up when a Haskell job is posted - Is remote work a possibility?
haskell,3bvpm1,jonsterling,7,Thu Jul 2 17:57:41 2015 UTC,"Unfortunately, it is not. But thank you for asking about it."
haskell,3bvpm1,mcapodici,2,Thu Jul 2 18:07:30 2015 UTC,Alas! Hit me up if that changes.
haskell,3bvpm1,gmfawcett,17,Thu Jul 2 21:47:54 2015 UTC,"Haskellers must be nomads.  But nomads are really hard to get your head around, at first."
haskell,3bvpm1,ephrion,12,Thu Jul 2 22:28:12 2015 UTC,"Whenever I get my head around nomads, someone invariably brings up conomads, and I feel ignorant all over again."
haskell,3bvpm1,tailbalance,8,Thu Jul 2 23:23:46 2015 UTC,Yoneda comonad tutorial?  i'll see myself out
haskell,3bv3k5,_ion,69,Thu Jul 2 11:54:33 2015 UTC,Wow. I .. just wow.  I'll just say that for some of these logos it is clear that they were designed by computer scientists.
haskell,3bv3k5,IceDane,12,Thu Jul 2 12:40:13 2015 UTC,Looking at all these designs makes me realize just how good the current logo is.  Anyone know the story behind it?
haskell,3bv3k5,PokerPirate,8,Thu Jul 2 20:25:32 2015 UTC,https://wiki.haskell.org/Haskell_logos#Current_Haskell_logo
haskell,3bv3k5,gfixler,16,Thu Jul 2 22:07:05 2015 UTC,hell ask
haskell,3bv3k5,SrPeixinho,65,Thu Jul 2 17:45:03 2015 UTC,On a related note: Most Haskell programmers should not think about going into the graphic design industry.
haskell,3bv3k5,Xophmeister,38,Thu Jul 2 13:01:09 2015 UTC,Who can forget this one ?
haskell,3bv3k5,edwardkmett,17,Thu Jul 2 13:14:13 2015 UTC,The Haskell logo contest was my first exposure to the language and I voted on that logo (back then I was one of the people who treated the whole thing as a joke).  If I remember correctly it almost came in first place
haskell,3bv3k5,Tekmo,2,Thu Jul 2 16:31:02 2015 UTC,Mr. Haskelly Pants.
haskell,3bv3k5,gfixler,10,Thu Jul 2 22:09:15 2015 UTC,In that picture: How not to be taken seriously by the industry as an up and coming programming language.
haskell,3bv3k5,IceDane,17,Thu Jul 2 16:53:45 2015 UTC,Avoid success at all costs.
haskell,3bv3k5,silvestre,3,Thu Jul 2 19:07:18 2015 UTC,That made my day.
haskell,3bv3k5,andrewthad,2,Thu Jul 2 13:55:49 2015 UTC,I need to make a sticker from this.
haskell,3bv3k5,semanticistZombie,1 point,Thu Jul 2 18:38:18 2015 UTC,That was also my favorite.
haskell,3bv3k5,erewok,1 point,Thu Jul 2 17:54:34 2015 UTC,that narwall is doing the dean scream @ time 0:36 for those who happened to miss this cultural oddity of US politics in 2004
haskell,3bv3k5,herbadah,21,Sun Jul 5 04:23:47 2015 UTC,And do not forget the haskell mascot.
haskell,3bv3k5,sopvop,9,Thu Jul 2 13:17:21 2015 UTC,oh my god.
haskell,3bv3k5,gilmi,2,Thu Jul 2 13:19:59 2015 UTC,deepdream
haskell,3bv3k5,hexasquid,21,Fri Jul 3 16:33:14 2015 UTC,I didn't know the logo for NixOS was originally designed for Haskell: https://wiki.haskell.org/File:Sgf-logo-blue.png
haskell,3bv3k5,Hypercactus_,20,Thu Jul 2 12:33:05 2015 UTC,"Yes, I suggested it for NixOS after the contest, because ""nix"" is Latin for ""snow"", and the logo resembles a snowflake. And obviously, Nix is also a functional language, so the lambdas fit. IIRC, we then asked the author whether we could use the logo for NixOS and got a positive response, so we did."
haskell,3bv3k5,kosmikus,3,Thu Jul 2 20:24:53 2015 UTC,"Whoa, I didn't know about snow in Latin. The story is pretty cool :)"
haskell,3bv3k5,Hypercactus_,5,Thu Jul 2 20:52:13 2015 UTC,Only now I realized the NixOS logo is made of lambdas.
haskell,3bv3k5,SrPeixinho,19,Thu Jul 2 17:46:55 2015 UTC,"I'm glad this one won (I initially thought the competition was to replace it, and they didn't pick one because the ideas were awful..)."
haskell,3bv3k5,protestor,17,Thu Jul 2 13:51:41 2015 UTC,"I hope they don't replace it. It's very simple, clean, and focuses on form rather than trying to be flashy--yet prominently show a lambda and the bind operator which are core to the language. The neutral colors also allow it to be easily colorized to fit different situations. It's probably my favorite language logo for these reasons."
haskell,3bv3k5,NoGodTryScience,11,Thu Jul 2 14:47:46 2015 UTC,"Agree whole-heartedly. It also why I have it as a sticker on my laptop.   The single ugliest logo I know is the emacs logo, though Haskell would have been at the top of that list if almost any logo from that link would have won."
haskell,3bv3k5,IceDane,10,Thu Jul 2 16:56:43 2015 UTC,"Naturally as a vim user I have to make this into a pissing contest and point out that the Vim logo ain't that great, either."
haskell,3bv3k5,mipadi,7,Thu Jul 2 20:44:59 2015 UTC,"I'd rather have the vim logo personally. I also have it on my laptop, which is incidentally the reason I looked up the emacs logo and found that it was hideous. I wanted to see if I could replace the vim sticker, since I switched to emacs.  If you ever have the time(and the urge), I highly recommend you try emacs out with evil-mode + evil-leader. It is like vim but better."
haskell,3bv3k5,IceDane,1 point,Thu Jul 2 21:07:38 2015 UTC,Or Spacemacs. Loving it so far.
haskell,3bv3k5,bb010g,0,Fri Jul 3 07:48:17 2015 UTC,"Maybe the logo should be a graphic version of :v/i/m. (which is a valid Vim command that doesn't do anything). Or maybe something leaning the V the other way, with angles like this: \|||\/\"
haskell,3bv3k5,gfixler,3,Thu Jul 2 22:23:06 2015 UTC,looks pretty nice on a cm storm :)  Img
haskell,3bv3k5,D_duck,1 point,Fri Jul 3 02:05:05 2015 UTC,"Wow, that's classy, where did you..?"
haskell,3bv3k5,Ancipital,1 point,Sat Jul 4 09:16:12 2015 UTC,https://www.reddit.com/r/haskell/comments/31xpea/haskell_logo_keycaps_finally_up_for_groupbuy/
haskell,3bv3k5,D_duck,2,Sat Jul 4 10:11:49 2015 UTC,"The Emacs logo is terrible indeed. I think the icon, on the other hand, is okay."
haskell,3bv3k5,TarMil,7,Fri Jul 3 09:17:13 2015 UTC,"yes, simple, elegant, idiomatic Haskell.  I hate 3D logos, they're garish."
haskell,3bv3k5,sambocyn,5,Fri Jul 3 00:17:23 2015 UTC,Fwd: Racket & Nim
haskell,3bv3k5,NoGodTryScience,2,Fri Jul 3 03:29:00 2015 UTC,RUBY
haskell,3bv3k5,sambocyn,9,Fri Jul 3 03:34:23 2015 UTC,"I never liked the greyness of it, so I'm glad I got to use in the flamboyant/regal purple that was used in the old logo on the new haskell.org."
haskell,3bv3k5,chrisdoner,17,Thu Jul 2 19:28:02 2015 UTC,"The ""freedom from State"" one is genius. Not as an official logo, more like a T-shirt…"
haskell,3bv3k5,adimit,7,Thu Jul 2 18:05:09 2015 UTC,dismantle all unsafelyCoercive institutions!  purity of action!  state is not self-legitimizing!
haskell,3bv3k5,sambocyn,5,Fri Jul 3 00:13:43 2015 UTC,My favourite. Just needs to be a bit graphic-designered and it'd be amazing.
haskell,3bv3k5,theonlycosmonaut,1 point,Thu Jul 2 23:12:45 2015 UTC,I'd buy that shirt.
haskell,3bv3k5,rdfox,16,Fri Jul 3 13:18:20 2015 UTC,You can learn many things from category theory - turns out graphic design isn't one of them.
haskell,3bv3k5,synackle,8,Thu Jul 2 19:53:33 2015 UTC,"Oh, God. I remember voting on these years ago. After looking at the options, I felt for sure that Haskell was doomed."
haskell,3bv3k5,mipadi,9,Thu Jul 2 20:43:44 2015 UTC,Well we know what our April fools day logo is going to look like for the next few years.
haskell,3bv3k5,Octopuscabbage,8,Thu Jul 2 13:35:32 2015 UTC,"The blocks one reminds me of the Isabelle logo.   I much prefer the current logo to most of these, but this one looks better, IMHO"
haskell,3bv3k5,kamatsu,16,Thu Jul 2 12:41:35 2015 UTC,"I think this particular picture looks like a book cover from the late 90s on how to write Haskell. I don't know why, it's probably the font. It's a nice font though."
haskell,3bv3k5,tsahyt,7,Thu Jul 2 13:28:47 2015 UTC,"This was my exact thought. Maybe it’s just because the colors remind me of Netscape Navigator, though."
haskell,3bv3k5,eigengrau82,6,Thu Jul 2 17:44:00 2015 UTC,https://wiki.haskell.org/wikiupload/5/5d/Sgf-logo-blue.png  Hey this is the NixOS logo nowadays right?
haskell,3bv3k5,arianvp,9,Thu Jul 2 18:03:46 2015 UTC,I liked this one enough that I made it into a painting:  http://i.imgur.com/UHfa6ja.png
haskell,3bv3k5,stepcut251,4,Thu Jul 2 15:55:16 2015 UTC,"What's the bat from the ""boobs, robot monkeys, and bats"" one?  <^(:)^>   FP Hoogle didn't find those operators (<),(>)."
haskell,3bv3k5,Dickferret,1 point,Thu Jul 2 16:00:31 2015 UTC,I'm pretty sure ( and ) are not valid characters to have in identifiers in Haskell anyway.
haskell,3bv3k5,kqr,1 point,Fri Jul 3 10:05:14 2015 UTC,"Yeah, it's doing something with the cons function."
haskell,3bv3k5,Dickferret,4,Fri Jul 3 14:15:26 2015 UTC,Wonder why this one didn't win. :D
haskell,3bv3k5,anders_,2,Thu Jul 2 21:34:49 2015 UTC,Time to make some shirts.
haskell,3bv3k5,gilmi,2,Thu Jul 2 13:22:28 2015 UTC,Might be interesting to turn this white and incorporate it into the current logo on haskell.org:  https://wiki.haskell.org/wikiupload/2/21/Haskell-apankrat.png
haskell,3bv3k5,codygman,2,Thu Jul 2 23:51:42 2015 UTC,Hlskell
haskell,3bv3k5,hdgarrood,3,Fri Jul 3 06:45:09 2015 UTC,H  reddit_comment:1:1:       No instance for (Show (a0 -> a0))         arising from a use of ‘show’
haskell,3bv3k5,kqr,2,Fri Jul 3 10:08:05 2015 UTC,"I really do like this logo, wouldn't have complained if that was the official one."
haskell,3bv3k5,alt_account10,2,Thu Jul 2 13:15:58 2015 UTC,Glad we didn't go with the ones bearing resemblance to a swatika O_O
haskell,3bv3k5,caninestrychnine,1 point,Thu Jul 2 19:17:43 2015 UTC,"Hi guys, can somebody create a Haskell ITA logo for the Italian Haskell community? Maybe just applying Italian flag colours to some of those logos."
haskell,3bv3k5,vitalijzad,8,Thu Jul 2 13:42:39 2015 UTC,Let me know if this helps: http://imgur.com/l6hkqYr
haskell,3bv3k5,jberryman,1 point,Fri Jul 3 02:26:21 2015 UTC,"It's perfect! :-D  However, I think I will use this one:  https://pbs.twimg.com/profile_images/616706223027589120/HmT-yq3x.png"
haskell,3bv3k5,vitalijzad,6,Fri Jul 3 05:41:12 2015 UTC,"There's a good LaTeX style file for the current one. You can extend it this way:  % % The Italian version as per /u/vitalijzad's request % \definecolor{hasklogo@italiangreen}{HTML}{009246} \definecolor{hasklogo@italianred}{HTML}{ce2b37} \pgfkeys{/hasklogo/italian/.style={         lambdabehind,         logo          color=hasklogo@italianred,         first  rangle color=hasklogo@italiangreen,         second rangle color=hasklogo@italiangreen }}   to get this colourization"
haskell,3bv3k5,gallais,1 point,Thu Jul 2 18:34:52 2015 UTC,Thank you so much!
haskell,3bv3k5,vitalijzad,1 point,Thu Jul 2 18:40:08 2015 UTC,"I voted for the logo that eventually won as my first choice, the snowflake of lambdas logo as my second choice , and the ""freedom from state"" one as my third choice."
haskell,3bv3k5,Ramin_HAL9001,1 point,Fri Jul 3 03:35:32 2015 UTC,I like the skull one and a few others are metal.
haskell,3bv3k5,rdfox,1 point,Fri Jul 3 13:12:23 2015 UTC,I quite like the Warm Fuzzy Thing mascot: https://wiki.haskell.org/wikiupload/1/1d/Monica_monad_falconnl.png
haskell,3bv3k5,get-your-shinebox,1 point,Sat Jul 4 00:18:51 2015 UTC,"Ouch. bitemyapp and I came up with the ""owl with a jetpack"" idea a few weeks ago (you know, the whole ""move fast and don't break things"" idea), we just need to drop a couple of bucks on fiverr for someone to sketch it out for us :P"
haskell,3bv3k5,akurilin,-5,Sun Jul 5 09:44:59 2015 UTC,tl;dr - autism
haskell,3bw95a,haskman,14,Thu Jul 2 17:47:44 2015 UTC,"Michael Snoyman mentioned this on the mailing list (https://groups.google.com/forum/#!topic/haskell-stack/8HJ6DHAinU0), it did the trick for me :   cabal configure --package-db=clear --package-db=global --package-db=$(stack path --snapshot-pkg-db) --package-db=$(stack path --local-pkg-db)"
haskell,3bw95a,madjar,3,Thu Jul 2 17:57:59 2015 UTC,Thanks! That got me past cabal configure and cabal build.  However cabal install still tried to download and install all packages. And I was still not able to run ghc-mod as it still cannot find any dependencies.
haskell,3bw95a,adamse,2,Thu Jul 2 18:16:19 2015 UTC,"cabal install is essentially installation of deps, configure, build, ..., bundled together in one command. I.e. reconfigures and you would need to pass the package dbs to it as well.  You might be able to put package db paths in a cabal.sandbox.config or cabal.config file."
haskell,3bw95a,esmolanka,3,Fri Jul 3 00:10:27 2015 UTC,Yeah putting 3 package-db: <stack db paths> statements in cabal.config did the trick as well!
haskell,3bw95a,codygman,4,Fri Jul 3 05:07:27 2015 UTC,"Yes, vanilla ghc-mod does not work properly with stack. So I hacked it a bit and now it works for my purposes. However still investigating if it's worth to adapt ghc-mod further.  https://github.com/esmolanka/ghc-mod"
haskell,3bw95a,ephrion,3,Thu Jul 2 19:55:11 2015 UTC,Thanks! I had been meddling with the ghc-mod sources trying to figure this out. I took the minimum changes needed from your code to get this working - https://github.com/ajnsit/ghc-mod/commit/60f19a8ac414c404097b4aa57328e07fdfb05210  It would be nice if you contributed these changes into the next release of ghc-mod.
haskell,3bw0wc,Croaky,3,Thu Jul 2 16:44:42 2015 UTC,"I'm supposed to run some image with no source code or build instructions. Thanks, but no thanks."
haskell,3bw0wc,oheoh,1 point,Fri Jul 3 05:59:12 2015 UTC,Didn't work for me.  I got this very early on:  $ docker run --rm --interactive --tty thoughtbot/ghc 2015/07/03 00:55:23 Error response from daemon: Cannot start container eba6f055a380ceeed16ad82ead305339ba5c035a55b028397b766c311a3b82ca: /var/lib/docker/aufs/mnt/eba6f055a380ceeed16ad82ead305339ba5c035a55b028397b766c311a3b82ca is not within /var/lib/docker/aufs/mnt/eba6f055a380ceeed16ad82ead305339ba5c035a55b028397b766c311a3b82ca
haskell,3bwc61,0v3rk1ll,28,Thu Jul 2 18:10:08 2015 UTC,"You can also do:  test ? t = if test then const t else \f -> f  Prelude> (1 > 3) ? ""true"" $ ""false"" ""false"" Prelude> (1 < 3) ? ""true"" $ ""false"" ""true"""
haskell,3bwc61,gclichtenberg,9,Thu Jul 2 18:47:31 2015 UTC,"Implementation of the same idea using either.  infixl 2 ? (?) ::  Bool -> a -> (b -> Either b a) True  ? a  = \_ -> Right a False ? _  = \b -> Left b  *Ternary> 1 > 2 ? ""Nope"" $ 0 Left 0  *Ternary> 1 < 2 ? ""Duh"" $ 0 Right ""Duh""   It's not quite as practical because the result is wrapped in Eitherbut it means that the if end else part don't have to have the same type."
haskell,3bwc61,dohaqatar7,8,Thu Jul 2 19:35:49 2015 UTC,You can use id instead of \f -> f
haskell,3bwc61,Denommus,5,Fri Jul 3 06:06:51 2015 UTC,"Note that there is an if' already, but it doesn't to quite what you propose:  if' :: Bool -> a -> a if' True x _ = x if' False _ x = x   ...which ""fixes"" the semi-common complaints about if being special syntax construct for no good reason."
haskell,3bwc61,tdammers,7,Thu Jul 2 18:52:54 2015 UTC,"There is Data.Bool.bool, it's:   bool :: Bool -> a -> a -> a  bool False x _ = x  bool True  _ x = x"
haskell,3bwc61,utdemir,2,Thu Jul 2 20:57:57 2015 UTC,I get a different type for bool:  Prelude> import Data.Bool Prelude Data.Bool> :i bool bool :: a -> a -> Bool -> a     -- Defined in ‘Data.Bool’   That type makes bool the catamorphism for Bool.
haskell,3bwc61,yitz,2,Sat Jul 4 23:08:48 2015 UTC,"Yeah, I know about that version, but something like this might be more useful/readable in some cases.  One of the arguments for the if_then_else_  special syntax was the readability due to having that 'else' as part of the syntax."
haskell,3bwc61,tdammers,10,Thu Jul 2 18:57:46 2015 UTC,"And I'll counter the ""readability"" argument by saying that the only readability advantage of something if condition else some_other_thing lies in the fact that, in trivial cases, it yields almost literally English grammar: ""speak up if you have any complaints, else remain silent"" -> speak_up() if you.have_any_complaints() else remain_silent(). And the problem with that, like many other Python constructs, is that the similarity with English grammar isn't half as helpful as it seems, because it ends sooner rather than later, and the isomorphism doesn't hold up enough to be useful, simply because programming languages and natural languages are not the same thing. Eventually, you will have to think in terms of syntax trees or similar programming language structures (an observation that lends support to the Lisp idea), and once you do that, the most readable syntax is one that minimizes the mental leap from written syntax to syntax trees.  This is what the syntax tree for if looks like:  if  +-- condition  +-- then-branch  +-- else-branch   The traditional syntax (e.g. C) matches our ""good"" parse tree (except for the additional else token):  if (condition)     then-branch else     else-branch   Haskell matches it even more nicely:  if condition     then then-branch     else else-branch   The classic if' in Haskell, just like typical if implementations in some Lisp flavor, also match:  if (condition)     (then-branch)     (else-branch)  (if condition     then-branch     else-branch)   But here comes Python with its ""readable"" syntax:  then-branch if condition else else-branch   ...which, to the naive eye, suggests a tree that looks something like:  then-branch  +-- if       +-- condition       +-- else-branch   ...or maybe:  then-branch  +-- condition  +-- else-branch"
haskell,3bwc61,sambocyn,3,Thu Jul 2 19:15:06 2015 UTC,"I once wrote  if string is """":   in Python because I was thinking in English ""if the string is empty..."". CPython might intern the empty string for all I know, but you want structural (not pointer) equality, to be safe."
haskell,3bwc61,rdfox,3,Thu Jul 2 21:01:09 2015 UTC,"You were right to do that. You only need to be careful of Python's different string types:  >>> ""foo"" is ""foo"" True >>> ""foo"" is u""foo"" False >>> ""foo"" == u""foo"" True"
haskell,3bwc61,sambocyn,2,Fri Jul 3 13:44:43 2015 UTC,"good to know.  and now that I've been trying to ""observe sharing"" (see the data-reify package) with IORefs and StableNames (""eqStableName"" in Haskell is like ""is"" in Python), I feel like I'm writing Python again :)"
haskell,3bwc61,tdammers,2,Fri Jul 3 20:19:19 2015 UTC,"In this case that problem can be easily solved by flipping if'. I just can't think of what to call it. The ""only two hard things in computer science..."" problem strikes again :)"
haskell,3bwc61,gavintlgold,5,Thu Jul 2 19:36:09 2015 UTC,"'fi, obviously."
haskell,3bwc61,rdfox,2,Thu Jul 2 19:47:04 2015 UTC,You can always do  if' condition a `else'` b   But mixing fixities and the unsymmetry makes me nervous
haskell,3bwc61,Peaker,1 point,Thu Jul 2 19:57:20 2015 UTC,flif :P
haskell,3bwc61,_deepfire,1 point,Fri Jul 3 03:56:47 2015 UTC,I like the ? idea:  https://www.reddit.com/r/haskell/comments/3bwc61/python_style_ternary_if_in_haskell/csq5b5t
haskell,3bwc61,hagda,1 point,Fri Jul 3 13:47:55 2015 UTC,"I disagree. The main benefit is that of named arguments.  Positional arguments, especially ones of the same type are terrible and error prone. The if syntax labels the branches to make argument meanings clearer and an error less likely.  I also disagree strongly with your claim about syntax trees. Most of us agree that infix is extremely useful notation, and your argument is that ""we think in syntax trees"" so infix should be harder, but it's just not true. Infix is easier for most people.    Python places the condition in the middle such that if you nest conditions the visual shape of the expression more closely resembles the shape of the condition tree (the branches in each tree node are the true/false decisions, which you'd draw on the left and right)."
haskell,3bwc61,Kaligule,3,Sun Jul 5 07:45:31 2015 UTC,And here I was thinking it is one of  the ugly quirks of Python..  The classic if-then-else structure follows the order of evaluation.. which is a good thing that Py lays to W.
haskell,3bwc61,Fkald,3,Thu Jul 2 22:04:18 2015 UTC,...also C's ternary operator (i.e. □ ? □ : □) is more readable than Python's....
haskell,3bwc61,yitz,2,Fri Jul 3 16:15:06 2015 UTC,I like the idea that if could be a useful function on its own.
haskell,3brqsf,PokerPirate,10,Wed Jul 1 16:49:45 2015 UTC,SubHask still has a number of bugs that need to be fixed.  This release should be seen as just a technology preview.
haskell,3brqsf,Tekmo,9,Wed Jul 1 16:50:22 2015 UTC,"Minor terminology note: a ""category transformer"" is a functor"
haskell,3brqsf,Tekmo,8,Wed Jul 1 18:28:28 2015 UTC,"At some point, everything is a functor.  But more seriously, it's a functor from a category to a subcategory, and I don't know a special name for that."
haskell,3brqsf,redxaxder,11,Wed Jul 1 18:53:05 2015 UTC,"I only point this out because then you can immediately infer the relevant functor laws.  Using your MonT functor as an example:  MonT id = id  MonT (f . g) = MonT f . MonT g   ... which is in fact how the Category instance is defined for MonT.  Calling it a ""functor"" is a convenient way to summarize that."
haskell,3brqsf,solinent,6,Wed Jul 1 18:58:47 2015 UTC,"That is a good perspective that I should probably flesh out.  I've asked on math overflow if there's a standard name for these sorts of functors, but there's not much response yet."
haskell,3brqsf,echatav,3,Wed Jul 1 23:07:14 2015 UTC,Perhaps you want it to be a retraction in Cat.
haskell,3brqsf,edwardkmett,3,Wed Jul 1 22:02:42 2015 UTC,"I can sort of see how this is related, but it seems like a very specific instance of a much more general concept.  In particular, not all retractions would be what I've dubbed category transformers."
haskell,3brqsf,sambocyn,3,Wed Jul 1 23:10:22 2015 UTC,"Would it not be a full functor? If it's ismorphic it'd be a fully faithful functor, and a faithful functor if it was injective. I'm not sure if a full functor can be fully faithful, but it probably can. I don't think there's anything more specific than that.  https://en.wikipedia.org/wiki/Full_and_faithful_functors"
haskell,3brqsf,cartazio,2,Thu Jul 2 02:30:59 2015 UTC,"Yes, I think this is correct.  I'll have to think about how to incorporate this without just making everything more confusing though."
haskell,3brqsf,BlackBrane,3,Thu Jul 2 19:57:49 2015 UTC,"It looks to me like a ""full subcategory"", but given the name of your library, I think you know that.  MonT :: (* -> * -> *) -> * -> * -> * MonT :: (ValidMon a, ValidMon b) => cat a b -> MonT cat a b   So the type MonT catis the full subcategory of cat whose objects have a ValidMon constraint."
haskell,3brqsf,_AndrewC_,10,Thu Jul 2 01:45:42 2015 UTC,"If you're going through all the trouble to make somewhat more ""real"" functors, why limit them to endofunctors?"
haskell,3brqsf,rampion,6,Thu Jul 2 17:35:24 2015 UTC,"Because I've found other parts of the library more fun and rewarding to work on so far.  In particular, I'm focusing on things with numeric applications, and I don't see an obvious numeric application them.  The Functor hierarchy is something I basically haven't touched at all yet.  I'm pretty sure I'd want the better type system features I mention before seriosly tackling it too.  I'd guess I've currently implemented less than 10% of the ideas I've had floating around in my head."
haskell,3brqsf,rampion,4,Thu Jul 2 19:51:41 2015 UTC,<10%   woah
haskell,3brqsf,cscherrer,3,Thu Jul 2 21:06:02 2015 UTC,I don't claim they're all good ideas :)
haskell,3brqsf,tel,7,Thu Jul 2 22:43:20 2015 UTC,"thanks for mentioning hblas in the readme! i'm hoping to announce a new release pretty soon, that incorporates a whole bunch of great work from a gsoc student this summer."
haskell,3brqsf,fridofrido,4,Thu Jul 2 03:11:59 2015 UTC,This sounds like a fantastic project. Count me as excited to see how it progresses.  On my initial look at your source I also appreciate the healthy amount of documentation and links to nlab/wikipedia.
haskell,3brqsf,rampion,5,Thu Jul 2 08:08:18 2015 UTC,Reading this was like opening the door on a sunny day and stepping outside.   I'm not sure I've ever had an emotional reaction to a library before! Wow.
haskell,3brce1,clrnd,97,Wed Jul 1 15:04:22 2015 UTC,"Discrimination effectively uses a ""most significant digit"" variant of radix sort which has been modified to work over algebraic data types.  The Omega(n log n) bound that you're used to thinking about comes from limiting yourself to pairwise comparisons, and gaining no extra information beyond that. Such an approach is terribly inefficient for keys like strings, where a ""structure-conscious"" approach can avoid rewalking the start of the key over and over.  Here the idea is that you can sort integers stably in O(n) time by radix sort, and it is possible to nest two most-significant digit radix sorts to handle products without changing asymptotics, and you can view the sum of two radix sorts as a 1 digit sort followed by a dependent sort. Each of these steps doesn't change the overall asymptotics from linear.  A stable ordered discriminator:  newtype Sort a = Sort { runSort :: [(a,b)] -> [[b]] }   is responsible for taking n (a,b) pairs and giving back each of the sorted equivalence classes by whatever property of a you want to discriminate on. This is a ""set at a time"" operation, not pairwise.  One key insight though is that (n) here isn't the number of elements, it is the 'amount of the structure we have to inspect', the sum of the longest prefixes we need to disambiguate, but for things like sorting integers that is a constant, and for things like strings it is usually considerably cheaper than the sum of the string lengths, as being most-significant-digit-based (rather than least-significant-digit-based like most radix sorts) it can stop recursing when it gets down to a bucket of size 1.  I put together the package precisely because of the counter-intuitive asymptotics involved."
haskell,3brce1,edwardkmett,15,Wed Jul 1 15:23:44 2015 UTC,"Wow, this is probably the best short explanation of this work I've seen/heard you give!"
haskell,3brce1,acow,14,Wed Jul 1 16:00:54 2015 UTC,I'm slowly figuring out how to convey how it works. =)  The new promises stuff adds a pretty complicated wrinkle to the grouping side.
haskell,3brce1,edwardkmett,6,Wed Jul 1 16:02:59 2015 UTC,"I bet! I'm not clear on how chunky the production of results is, but it's a super useful addition so I'm sure you'll get practice explaining it."
haskell,3brce1,acow,10,Wed Jul 1 16:05:18 2015 UTC,"I still have a bunch of work to do in this space:  sorting is offline, since you can always get something earlier than one of your equivalence classes. I'm currently working on incorporating techniques from burstsort to improve the cache locality of sorting.  grouping is now based on an online technique which effectively forces me to build a trie in memory by mutation as it runs and then use promises to drive the computation on a demand driven basis. I'll also likely change the way the internals of grouping works for integers to use array-mapped trie techniques rather than the big mutable tree I do now, this would let me win a great deal (3-4x) on constant factors.  I may wind up having to add back another form of offline grouping to get better constant factors. The memory footprint for online grouping is way higher than the old offline footprint, but productivity means you can drop it in as a replacement for nub for all usecases and just go linear."
haskell,3brce1,edwardkmett,19,Wed Jul 1 16:15:18 2015 UTC,"""What are you so excited about?""  ""We're getting linear nub!"""
haskell,3brce1,acow,1 point,Wed Jul 1 16:19:44 2015 UTC,HEAD now has the performance improvements for grouping done.
haskell,3brce1,edwardkmett,3,Tue Jul 7 05:22:32 2015 UTC,"I like pretty diagrams! And imperative pseudo code is good for newbies like me. I think the talk you gave in Brisbane was hard because it also covered the Category theory behind this. However as a simple algorithm it is relatively easy to understand, and a nice surprising result to have an O(N) sort."
haskell,3brce1,mcapodici,3,Thu Jul 2 06:43:20 2015 UTC,"One key insight though is that (n) here isn't the number of elements, it is the 'amount of the structure we have to inspect'   I always thought the O(n) asymptotics on radix sort was a teensy bit disingenuous because it's only linear in the number of elements if you have a fixed number of keys.   I've always preferred to think of it as O(m*n),  where m is the size of your keys,  and in most use cases m ≈ log(n)."
haskell,3brce1,lpsmith,4,Fri Jul 3 11:05:32 2015 UTC,"You can factor the size of the keys and word size of your machine in, but they don't conspire quite so badly against you as your analysis here would indicate. For top down radix sort or comparison sort we deal with comparison costs based on the ""longest prefixes needed to discriminate between your keys"" which is often considerably less than the entire key.  So, let me give the full description of the asymptotics involved without simplifying terms:  An LSD radix sort (the one you learn in school) has a more accurate complexity bound of O(|R| + mσ), where σ is the size of the alphabet or # of buckets we are using to classify at a time (this is not the word size!), m is the length of the longest key in terms of σ, and |R| is sum of the lengths of all the inputs. This is the complexity bound that corresponds to the one you gave. I'd like to point out carefully that varying your word size w affects |R| and m, but not σ.  If each key has a fixed size of the form w = σ^m, then |R| = m * n and you get O(mn + mσ). Your bound comes from lumping these two summands together.  On the other hand, MSD radix sort works its way top down and has a complexity of O(ΣLCP(R) + n log σ) where n is the number of keys, ΣLCP(R) is the sum of the lengths of the prefixes needed to disambiguate the keys. ΣLCP(R) <= |R|, and it is often much much less. This is a much tighter bound when working with string comparisons.  This discrepancy is why LSD radix sort is really only useful for things like fixed sized integers, for anything else the MSD radix sort techniques dominate it in both constant factors and asymptotics. MSD radix sorting took it from an old, crusty, theoretical curiosity to winning on a wall clock for real. (Alas, the American Flag sort they built there, while fast, is unstable.)  Now, for comparison, with just symbol-wise comparison there is a hard Ω(ΣLCP(R) + n log n) bound on all string sorts. This bound holds on algorithms such as multikey quicksort, string mergesorts or string heapsort, which get to exploit some of the structure of their keys to beat the naive pairwise comparison bound on strings. (comparing two strings isn't O(1), so if you plugged in a classic sort on strings it'd do quite poorly!) This is analogous to the naive pairwise comparison bound you get on algebraic data types limited to pairwise comparisons, but now we're allowing some insight into the structure of the keys, letting us do string comparisons faster.  So this does point to an asymptotic complexity improvement on the radix side of things! When we tease it apart to see that σ is not the word size, σ is a constant, and the number of buckets you use in classifying a ""layer"" of the structure does not change with n. It isn't tied to the size of your word w or the number of keys n you are sorting in any way.  We can see more clearly the connection between radix sorting and string sorting when we include the ΣLCP(R) term in our complexity bounds, because otherwise people confuse σ for the word size!  Getting sloppy again, when we fix a word size w = σk and assume we're working with integer keys then w and σ both vanish as constants, ΣLCP(R) becomes n and you get the O(n) vs O(n log n) distinction folks commonly cite.  But even without fixing these things there is a win in the second summand given above replacing a hard Ω(ΣLCP(R) + n log n) bound with O(ΣLCP(R) + n log σ)."
haskell,3brce1,edwardkmett,1 point,Fri Jul 3 16:00:23 2015 UTC,"You're really struggling to say this is O(n) while being ambiguous enough to not actually say it. This just seems like you are complicating the matter in order to be misleading on purpose.  Answer the following questions with a 'yes' or 'no':  A) Given an list of random stings, will this algorithm sort them with an average time complexity of O(n)?  B) Given an list of random stings, will this algorithm sort them with an average time complexity asymptotically less than O(n log n)?   On standard hardware. Where comparison of two fixed-size portions of strings (say 64 bits) counts as one operation."
haskell,3brce1,wubleduble,7,Fri Jul 3 17:56:38 2015 UTC,"This just seems like you are complicating the matter in order to be misleading on purpose.   No. I'm endeavoring to explain why my bounds and the ones that lpsmith offered disagree and to distinguish between the word size w and the alphabet size σ that arise in a radix sort, because if you don't take the more complicated analysis above, then they are easily conflated.  Given a list of strings R every algorithm that is capable of sorting it must pay at least Ω(ΣLCP(R)). Where ΣLCP(R) is the amount of the strings you must inspect to disambiguate them.  Period. Game over. I can't escape that bound. Nobody can.   So I can't sort strings in O(n) time, unless ΣLCP(R) = O(n). One situation that happens in is when we're sorting fixed sized integers with a fixed number of radix passes.  On the other hand, when the strings are random, like you've requested, the expected value of the longest common prefix involved becomes:  E(ΣLCP(R)) = O(n log n)   So the bounds I gave become a randomized upper bound:   O(n log n + n log σ) = O(n log n)   and we're bounded below with a randomized bound of:   Ω(ΣLCP(R)) = Ω(n log n)   So:  A.) No.  B.) No.  No paradox is introduced and the universe doesn't collapse.  On the other hand, what I am saying is that the complexity involved here is less than that of a symbol-comparison sort under other input distributions. Then the complexity here  O(ΣLCP(R) + n log σ)   can dominate the achievable complexity of any pairwise symbol based string sort:  Ω(ΣLCP(R) + n log n)   I'd like to point out that the questions you asked are merely about random strings, however, where the ΣLCP(R) term dominates, while the bounds I gave above hold in all situations.  If we take N = ΣLCP(R), then the O(ΣLCP(R) + n log σ) complexity bound on MSD radix sorting is linear in N as we can absorb the n log σ bound into the coefficient for N, as log σ is a constant, and n <= ΣLCP(R).   We get no such collapse for the lower bound on symbolwise comparison. We only have n <= ΣLCP(R), so I can only get a sloppier bound n log n <= N log N, so in those terms if we collapse the terms together to get a single variable  Ω(ΣLCP(R) + n log n) = O(N + N log N) = O(N log N)   and then we're talking O(N) for radix techniques vs O(N log N) for comparison based techniques. Our equation now only involve one variable.  But notice that N = n log n under your assumptions of randomness. The latter bound was made sloppy by merging the two terms, Ω devolved to an O, making it useless.  In the case you are interested in, when our strings are random we can see the tighter ""one variable"" bound:  Θ(ΣLCP(R) + n log n) = Θ(n log n + n log n) = Θ(n log n)   for symbolwise comparisons agrees with that for radix-style comparison.  In my original description the n was N = ΣLCP(R), not the number of strings.  I included the more detailed breakdown above not to ""throw up dust"" but to explain why we're starting with the same facts and yielding different conclusions."
haskell,3brce1,edwardkmett,1 point,Fri Jul 3 18:21:49 2015 UTC,My point is the sort isn't actually O(n) in general so the package description and documentation is misleading without further clarification.
haskell,3brce1,wubleduble,3,Sat Jul 4 01:48:51 2015 UTC,I'll include greater clarification along the lines of the above.
haskell,3brce1,edwardkmett,3,Sat Jul 4 01:55:40 2015 UTC,Thanks bro. :)
haskell,3brce1,wubleduble,5,Sat Jul 4 01:59:41 2015 UTC,based edward
haskell,3brce1,PM_ME_UR_OBSIDIAN,1 point,Wed Jul 1 15:27:59 2015 UTC,"absolutely fantastic, thanks!"
haskell,3brce1,wubleduble,1 point,Wed Jul 1 15:57:04 2015 UTC,tl;dr - its not actually O(n)
haskell,3brce1,phadej,11,Fri Jul 3 13:45:41 2015 UTC,Shortly: https://en.wikipedia.org/wiki/Radix_sort
haskell,3brce1,fmapthrowaway,3,Wed Jul 1 15:16:53 2015 UTC,A nice lecture on linear-time sorting (from MIT OCW): https://www.youtube.com/watch?v=Nz1KZXbghj8
haskell,3bsa0f,gracjan,6,Wed Jul 1 19:06:57 2015 UTC,"...all of this in a async way that will not hang Emacs   This sounds wonderful.  Does anything similar exist for Vim?  There's a bunch of Vim stuff on HaskellWiki, but it seems to be rather stale."
haskell,3bsa0f,earldouglas,5,Thu Jul 2 01:05:44 2015 UTC,Emacs has evil mode with vi bindings if there are no other alternatives yet.
haskell,3bsa0f,MCHerb,3,Thu Jul 2 13:31:30 2015 UTC,This is what I did: kept vim but moved to emacs. The evil package is very complete.
haskell,3bsa0f,cies010,2,Thu Jul 2 21:41:50 2015 UTC,"Btw, semi-static completion-sets like pragmas and ghc options are easy to get async-completed. You basically just need to fetch the information once per GHC binary (either lazy on-demand or at eagerly at startup). haskell-mode was able to do this for ages (I don't remember though if it was part of the upstream distribution, or just my local configuration where it worked). So that's something that should be easily doable for Vim in a non-blocking way as well.  The more interesting part is where you need to query the running GHCi process for completions (in-scope symbols, type-information, visible module names, module prefixes and so on)."
haskell,3bsa0f,hvr_,2,Thu Jul 2 07:40:43 2015 UTC,We are talking about async interface for ':complete' command in GHCi.
haskell,3bsa0f,massysett,2,Thu Jul 2 12:31:47 2015 UTC,"Vim's architecture simply does not allow this, which is one of the reasons Neovim was started."
haskell,3bsa0f,sambocyn,1 point,Thu Jul 2 17:30:22 2015 UTC,could you explain? thanks
haskell,3bsa0f,massysett,3,Thu Jul 2 21:07:04 2015 UTC,This writer explains (with some commentary) the Vim code base
haskell,3bsa0f,pycube,2,Thu Jul 2 23:44:30 2015 UTC,"Can anybody explain how to enable the async completion with company mode? It is not clear to me, even after reading the relevant issues / PRs. Or does haskell-mode now provide async completions by default?"
haskell,3bsa0f,rdfox,2,Thu Jul 2 14:39:04 2015 UTC,It just works. You can notice it is async because it does not hang Emacs.
haskell,3bqy5h,jocomoco,19,Wed Jul 1 12:59:07 2015 UTC,"Emacs (with haskell-mode) ghc-mod company-ghc hlint (this is a quick toggle with ghc-mod that I occasionally flip on for cleanup)   They are very useful! In-editor warning and error highlighting is great for efficiency. More recently, typed hole support is another really nice feature as I can always replace a problematic term with a hole and iteratively refine it until I get it right.  company-ghc is a nice addition, too. It auto completes things like LANGUAGE pragmas, and lets you explore a qualified import by just hitting the dot. At that point, you get suggestions based on what you type along with type signatures of those suggestions. I often find that a helpful way of reminding myself of what's in Data.Text, for example."
haskell,3bqy5h,acow,6,Wed Jul 1 14:10:55 2015 UTC,"Unfortunately the official ghc-mod release doesn't support 7.10 yet,and it seems that it will take some time until we get a 7.10 compatible release.  TBH, I don't understand the release policy, as the 7.10 bugs are long fixed in git: https://github.com/kazu-yamamoto/ghc-mod/issues/437"
haskell,3bqy5h,mnik,5,Thu Jul 2 01:57:45 2015 UTC,I've been using it on 7.10 for quite a while now. There are some bugs which I guess are keeping the maintainers wary. I'll see if I can help move it forward tomorrow.
haskell,3bqy5h,acow,2,Thu Jul 2 02:21:17 2015 UTC,"Yes, I just installed it from source as well to use with 7.10. Works ok for me."
haskell,3bqy5h,mallai,7,Thu Jul 2 17:24:41 2015 UTC,These are the blocking issues:  https://github.com/kazu-yamamoto/ghc-mod/issues?q=is%3Aopen+is%3Aissue+milestone%3A%22Next+release%22
haskell,3bqy5h,codygman,1 point,Thu Jul 2 04:45:40 2015 UTC,Half of those are about the version that is not displayed correctly because people have been compiling from the repo manually because there is no release.
haskell,3bqy5h,Taladar,3,Fri Jul 3 13:24:57 2015 UTC,"I've been switching from vim to emacs for Haskell recently, and one thing I really miss from my vim setup is having both ghc-mod and hlint run on every save.  One day I'll get that back.  It'll be a good day."
haskell,3bqy5h,dalaing,4,Wed Jul 1 22:24:33 2015 UTC,In emacs you don't even have to wait until you save. It's live in buffer.  I recommend checking out spacemacs if you're coming from vim.
haskell,3bqy5h,joehillen,2,Thu Jul 2 07:22:56 2015 UTC,"Can confirm, Spacemacs is amazing."
haskell,3bqy5h,bb010g,2,Sat Jul 4 03:15:11 2015 UTC,"That should be easy to configure in emacs, though, I would imagine?"
haskell,3bqy5h,erewok,2,Wed Jul 1 23:31:52 2015 UTC,"I use flycheck.  I have bound it to <f5>, so when I want to typecheck the code, I press <f5> and it automatically highlights all errors and warnings."
haskell,3bqy5h,kuribas,5,Thu Jul 2 10:17:52 2015 UTC,"Ah, perhaps you could help me. I understand it is possible to toggle ghc compile and hlint warnings with ghc-mod. I try C-c C-c twice  but I don't get the hlint warnings, just the ghc compile output. Is that the correct toggle?  Edit:  I see that on line 46 of haskell.el in haskell mode:  (define-key map (kbd ""C-c C-c"") 'haskell-process-cabal-build)   Whereas on line 67 of ghc.el in ghc-mod:  (defvar ghc-toggle-key      ""\C-c\C-c"")   In my emacs setup, C-h k then C-c C-c shows that this is bound to haskell-process-cabal-build, because my haskell-mode setup in init.el comes after the ghc-mod setup. My workaround is to just run ghc-toggle-check-command in my Haskell file buffer to switch between hlint and GHC syntax checking."
haskell,3bqy5h,robstewartUK,1 point,Thu Jul 2 07:17:59 2015 UTC,How about adding a define-key to your haskell-mode hook to set C-c C-c back to the ghc-mod toggle?
haskell,3bqy5h,acow,1 point,Thu Jul 2 15:37:22 2015 UTC,"That'd do it, thanks. I don't know why I can't find other people on the web having this problem, given that the list of haskell interactive model key bindings in https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#list-of-key-bindings assumes the ghc-mod binding to ghc-toggle-check-command, but if the ""interactive commands"" section earlier in the tutorial is followed https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#interactive-commands , then C-c C-c binds to haskell-process-cabal-build ."
haskell,3bqy5h,robstewartUK,1 point,Thu Jul 2 15:48:00 2015 UTC,"I don't have these lines in my configuration:  (autoload 'ghc-init ""ghc"" nil t) (autoload 'ghc-debug ""ghc"" nil t)   Maybe they're causing ghc-mod to load too early for you."
haskell,3bqy5h,acow,13,Thu Jul 2 15:56:32 2015 UTC,Just plain emacs with haskell-mode.
haskell,3bqy5h,zorasterisk,10,Wed Jul 1 14:19:12 2015 UTC,"I use   stack haskell-mode structured-haskell-mode   stack mostly because I don't want to rebuild things constantly just because I have a new sandbox. haskell-mode for basic stuff like syntax highlighting and a repl in emacs and structured-haskell-mode for treating my code more as an ast than plaintext.  I used to use ghc-mod but I got annoyed when it broke  with 7.10 and don't feel like spending the time to fix it. I am kinda hoping, that stack-ide will implement part of what ghc-mod does and being integrated into stack and being backed by a company hopefully ensures that it doesn't break so easily."
haskell,3bqy5h,cocreature,5,Wed Jul 1 14:02:11 2015 UTC,The github version of ghc-mod works out of the box with 7.10.
haskell,3bqy5h,0v3rk1ll,2,Wed Jul 1 16:13:21 2015 UTC,I should probably try it again. Last time I tried the github version worked but the emacs integration was broken which basically made it useless for me.
haskell,3bqy5h,cocreature,3,Wed Jul 1 16:40:19 2015 UTC,Does haskell-mode work with stack?
haskell,3bqy5h,vagif,8,Wed Jul 1 14:32:09 2015 UTC,"Yes, quite well. See the .dir-locals.el in the stack repository https://github.com/commercialhaskell/stack. Also I've stolen some code from Chris Done's setup for running stack commands in my haskell-mode setup https://github.com/chrisdone/chrisdone-emacs/commit/d1f77fcccc744d5abec81879e9b6b85beaada74e"
haskell,3bqy5h,drwebb,2,Wed Jul 1 15:57:24 2015 UTC,"Ooh, I should start using the stack commands setup."
haskell,3bqy5h,codygman,1 point,Thu Jul 2 01:31:00 2015 UTC,I just use this .dir-locals.el and it works flawlessly.
haskell,3bqy5h,codygman,5,Wed Jul 1 19:02:52 2015 UTC,"I would absolutely love to use it, but I'm an ex-Vimmer, so I rely on Evil mode for everything in Emacs, and structured-haskell-mode doesn't seem to have any plans of playing nice with Evil mode in the future :("
haskell,3bqy5h,evanrelf,1 point,Wed Jul 1 23:58:10 2015 UTC,There is an Emacs state in evil right? Couldn't that be used to integrate the two?
haskell,3bqy5h,cies010,1 point,Thu Jul 2 05:11:44 2015 UTC,I think that might be possible. I just hope that some day there is a way to use it with Vim/Evil keys
haskell,3bqy5h,evanrelf,10,Thu Jul 2 19:39:28 2015 UTC,"I use vim with ghc-mod, syntastic, hlint, and a few other indentation/highlighting plugins. I also sometimes have ghcid running in a tmux pane to the side, but not sure if I prefer ghcid or syntastic for error checking.  They are crucial, for me. Being able to inspect types under cursor, use typed holes and see members in scope, and get good feedback on syntax/type errors is really important for my development.  I like the speed of hdevtools but I do not like that type inspection doesn't work on source files with errors. That makes it difficult to use holes productively.  I am really excited for ide-backend. It seems like a much more powerful and sophisticated version of hdevtools and ghc-mod. I intend on studying the current emacs integration with it and trying to write a vim plugin for it.  I have not tried an IDE like EclipseFP, Leksah, etc. I like vim and it works very well for the other development I do, and I don't have time to learn a new editor. I've tried to get into spacemacs, as it seems like a really cool tool, but haven't had time to learn it sufficiently well."
haskell,3bqy5h,ephrion,1 point,Thu Jul 2 20:08:08 2015 UTC,Is syntastic a vim plugin?
haskell,3bqy5h,0Il0I0l0,1 point,Wed Jul 1 16:27:53 2015 UTC,yup
haskell,3bqy5h,zcleghern,17,Wed Jul 1 18:03:10 2015 UTC,-haskell platform  -eclipseFP   Send help
haskell,3bqy5h,ben7005,8,Wed Jul 1 19:45:29 2015 UTC,I'm sorry :(
haskell,3bqy5h,ranjitjhala,6,Wed Jul 1 14:54:38 2015 UTC,"I've started using atom, for various reasons.   This is a super set of resources for atom:   http://edsko.net/2015/03/07/vim-to-atom/   The haskell-ide is amazing but relies on ghc-mod which is not quite there with ghc710, so I've written a couple of plugins:   https://atom.io/packages/linter-hdevtools https://atom.io/packages/hover-tooltips-hdevtools"
haskell,3bqy5h,ranjitjhala,3,Wed Jul 1 16:47:37 2015 UTC,"can you get ""go to definition"" with atom ?"
haskell,3bqy5h,mallai,4,Wed Jul 1 19:03:40 2015 UTC,"Yes (thankfully! this is a biggie for me...) as Edsko writes: ""atom supports CTAGS out of the box ... just call hasktags -x -c . in your project directory, and then you can jump to any tag using ⌘-Shift-R"""
haskell,3bqy5h,bheklilr,1 point,Thu Jul 2 09:42:34 2015 UTC,"just checked: it is next on the todo list , so not yet"
haskell,3bqy5h,biglambda,1 point,Thu Jul 2 18:53:22 2015 UTC,it works together with hasktags or codex
haskell,3bqy5h,pycube,5,Thu Jul 2 09:44:19 2015 UTC,"I use   ghc-mod hoogle Sublime Text 3 + SublimeHaskell stylish-haskell hlint misc others   These tools are pretty good, but I'd say that SublimeHaskell is a bit sub-par.  I'm running primarily on Windows, so I can't comment on the state of affairs on Linux, but I've always had to jump through hoops (including editing the source of plugin) to get it to work properly, and even then it can have difficulty with one feature or another.  In the end I just write my code with AllAutocomplete and syntax highlighting, then build with cabal (and lately stack) at the command line.  Then again, I do much of the same with Python, my editor is for editing code, my command line is for issuing commands to orchestrate my code."
haskell,3bqy5h,pycube,1 point,Thu Jul 2 16:51:21 2015 UTC,I very much wish that SublimeHaskell were better as well :(
haskell,3bqy5h,evanrelf,5,Wed Jul 1 13:10:36 2015 UTC,"I use emacs with haskell-mode, but with a few additional packages:   https://github.com/chrisdone/haskell-flycheck This provides a syntax checker for flycheck that uses the current GHCi process spawned by haskell-mode for syntax checking Plain company mode, with no extra haskell plugins. By setting 'completion-at-point-functions to '(haskell-process-completions-at-point), the completion will uses GHCi to complete imports, language pragmas and names.    By relying only on the GHCi for all haskell functionality, I only need to configure ghci to be able to find the packages. So it works easily for cabal (just use cabal repl for the process) or nix (i  use a wrapper script to launch ghci inside a nix shell)"
haskell,3bqy5h,pycube,3,Sat Jul 4 04:17:45 2015 UTC,Based on what information will company mode autocomplete ?
haskell,3bqy5h,ekilek22,3,Wed Jul 1 14:52:59 2015 UTC,"I think it uses GHCi's :complete command, which completes based on available identifiers (imported functions), module names, language pragmas"
haskell,3bqy5h,_skp,1 point,Thu Jul 2 15:43:46 2015 UTC,The link to flycheck-haskell is broken.
haskell,3bqy5h,_skp,1 point,Thu Jul 2 18:01:13 2015 UTC,"Oh, will correct it, thanks"
haskell,3bqy5h,fractalsea,5,Thu Jul 2 05:43:40 2015 UTC,"Apart from what other people have said, ghcid is simple and godsend. edit: arion too (auto test runner)."
haskell,3bqy5h,kuribas,4,Thu Jul 2 06:50:57 2015 UTC,"ghc-mod is a must have.  hasktags is really good.  hoogle I use it sometimes, but not that much.  The atom plugins are great even, especially the linter. I don’t use haskell-ide though.  ghci, of course."
haskell,3bqy5h,fractalsea,1 point,Wed Jul 1 15:09:47 2015 UTC,"How do you use hasktags? Integrated with some editor, if yes, which editor?"
haskell,3bqy5h,fractalsea,2,Wed Jul 1 15:39:22 2015 UTC,"Depends. On vim I used to bind a macro like @t. q t :vnew :!hasktags -c src.  For other editors, like atom, I use a script, but there might be some kind of plugins to handle that. No idea."
haskell,3bqy5h,razvanpanda,5,Wed Jul 1 16:56:14 2015 UTC,"IntelliJ + Haskforce (which uses HLint and ghc-mod).  I like the idea of moving to emacs at some point, but the intuitive out-of-the-box functionality I get with an IDE has been too much of an attraction so far.  The functionality I require for any serious development is:   Jump to definition Show usages Good searching + find and replace Show type Autocomplete On-the-fly syntax and type error highlighting I also like having the list of project files and also list of symbols in the current file   IntelliJ + Haskforce provides these (except show usages and list of symbols), although some can be flakey. Having said that I have not managed to get emacs into as reliable a state after many hours of configuration.  Haskforce is under active development, and I always eagerly anticipate new releases."
haskell,3bqy5h,fractalsea,4,Wed Jul 1 17:41:45 2015 UTC,"You can do most of these things with emacs:   Jump to definition: you can do that with tags Show usages: do you mean call graph?  I don't think emacs does that, but there are extern tools for that (sourceGraph) Good searching + find and replace: c-s, m-x query-replace, m-x replace-string, etc...  Show type: c-c c-t, or c-u c-c c-t to insert the type Autocomplete: m-/ On-the-fly syntax and type error highlighting: flycheck-mode project files etc: I am using ecb with good succes.  You need to edit ecb-source-path to add project directories.  I have set ecb-layout-name to left-15, which shows the project list and functions to the left."
haskell,3bqy5h,implicit_cast,1 point,Wed Jul 1 15:28:17 2015 UTC,"Hey, thanks for the suggestions. Some day I still plan on getting emacs set up correctly. So far my experience has been hours of frustration for something that is not as good as my IntelliJ setup. When I have more free time I will bite the bullet with emacs!"
haskell,3bqy5h,hiptobecubic,3,Thu Jul 2 10:32:35 2015 UTC,I wonder which tools supports show usages? Beyond the simple syntactic search aka grep.
haskell,3bqy5h,mallai,2,Tue Jul 7 08:49:25 2015 UTC,i think ghci-ng supports usages : https://github.com/chrisdone/ghci-ng/blob/master/README.md
haskell,3bqy5h,ndmitchell,1 point,Wed Jul 1 17:31:13 2015 UTC,"Thanks. I wasn't sure this existed for Haskell.  grep does work nicely in practice, but I find it lacks the convenience of ""find usages"" you would find in a Java IDE for example."
haskell,3bqy5h,mallai,2,Fri Jul 3 10:45:11 2015 UTC,"https://github.com/Atsky/haskell-idea-plugin has improved quite a lot lately, you might want to give it a/nother try."
haskell,3bqy5h,ndmitchell,1 point,Tue Jul 7 08:47:54 2015 UTC,I've just tried it out. It does look very good. The one feature I'm missing is hlint integration...
haskell,3bqy5h,mallai,6,Thu Jul 2 23:30:16 2015 UTC,I'm very happy with Atom and ide-haskell right now.
haskell,3bqy5h,ndmitchell,1 point,Tue Jul 7 09:06:36 2015 UTC,This looks great
haskell,3bqy5h,mallai,1 point,Wed Jul 1 15:57:39 2015 UTC,"Yes, ""happy"" is the right word. It works like a charm!"
haskell,3bqy5h,ndmitchell,6,Thu Jul 2 06:00:00 2015 UTC,"The whole ethos of ghcid is a bit of an IDE for those who couldn't get over the barrier to entry. If it isn't working in 5 minutes, that's a bug."
haskell,3bqy5h,mallai,3,Thu Jul 2 17:41:35 2015 UTC,"I tried ghcid a few times and it seemed to hang. Finally, today, I tried again but with built in windows cmd.exe and it works! The problem was that previously I tried with MSYS and MinGw-w64 shell! Perhaps, a note about which shells it was tested with on the README would help.  Otherwise, it's a nice tool!"
haskell,3bqy5h,ndmitchell,2,Wed Jul 1 20:45:02 2015 UTC,"Does it still hang on a Cygwin shell? I've done a lot of work in the last release making it more verbose and predictable during start up, so it doesn't appear to hang."
haskell,3bqy5h,alt_account10,1 point,Thu Jul 2 10:04:23 2015 UTC,"Unfortunately, I don't have Cygwin installed. However, I tried ghcid-0.5 and it hangs on all MSYS2 shells: MSYS, MinGW-w64 Win64, and MinGW-w64 Win32 Shell.  I'm ran a command ghcid ""--command=cabal repl"" in a project. This works in the cmd.exe."
haskell,3bqy5h,alt_account10,1 point,Thu Jul 2 17:37:10 2015 UTC,"I just tried an MSYS2 shell and it worked just fine. It didn't detect the console height (defaults to 8 lines I think), but otherwise worked just as well as my cmd."
haskell,3bqy5h,gfixler,1 point,Thu Jul 2 18:24:00 2015 UTC,"I tried again in a few different ways (with/without --topmost, --height, with ghci or cabal repl) but it still hangs. I have Windows 8, MinGHC 7.10.1, cabal-install version 1.22.6.0. I noticed it does start a new bash.exe process in task manager but it seems to be headless.   However, when running with cmd.exe, I get this output:  Loading cabal repl... Preprocessing library clafer-0.3.11... GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help Ok, modules loaded: <long list of modules> _exception :: e = _ Unable to list source for <exception thrown> Try rerunning with :trace, :back then :list   So maybe that's a problem with my project?  EDIT. I created a fresh dummy project and indeed it works in MSYS shells. So, it must be related to my project."
haskell,3bqy5h,lally,1 point,Thu Jul 2 19:22:10 2015 UTC,"That does look like the problem - it seems to get wedged. Do you have a .ghci file? If you run cabal repl does it get wedged too? My guess is in the MSYS shell it gets equally wedged, but the buffer doesn't flush so you don't find out and it appears like it hangs."
haskell,3bqy5h,Peaker,1 point,Thu Jul 2 19:31:07 2015 UTC,"It might be an interaction due to having .ghci present in the project but using cabal repl. Normal cabal repl works fine and, after removing .ghci, executing ghcid ""--command=cabal repl"" --topmost --height=8 produces:  Loading cabal repl... Preprocessing library clafer-0.3.11... GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help Ok, modules loaded: <...>  All good (36 modules)   my .ghci was  :set -fbreak-on-exception :set -fbreak-on-error :set prompt ""\\>"" :set stop :list :def seq (\arg -> return (""seq ("" ++ arg ++ "") ()"")) :set -fprint-evld-with-show   Which explains everything. It was breaking on exception and MSYS didn't flush. The only strange thing is where does the exception come from? Just doing cabal repl does not result in any exceptions."
haskell,3bqy5h,Peaker,2,Fri Jul 3 01:02:09 2015 UTC,"Ah, I know, you have break-on-exception set! In ghcid, the way I determine that the stdout and stderr are both flushed is to signal an error and wait for it to appear on stdout. However, you want to break into the debugger at that point, and it goes horribly wrong. I guess I should pass -fno-break-on-exception to turn it off for ghcid.  Tracking here: https://github.com/ndmitchell/ghcid/issues/43"
haskell,3bqy5h,Peaker,3,Fri Jul 3 11:04:30 2015 UTC,"vim  hasktags  For my source code, BUT I also unpack all the dependencies I use and ""index"" all those in my tags file. Not as important to jump to the sourcecode of a function, like in an OO language (functions are less opaque than object methods). But when I need it, it's there. Especially useful if I clone/unpack a project that doesn't do qualified imports. I tried once to setup ghc-mod, didn't work for some reason, and it's easier to jump to a function definition than muck around with a big expression until I can pin down the type, which I can search afterwards. I'm constantly postponing a script that does this automatically for me, since at this point I always inspect the cabal sandbox for versions I must unpack manually :)  ghcid  Always compiles my code in a terminal split, no write/reload ghci cycles spent.  hoogle + hoogle-index  hoogle-index requires hoogle, and it works with sandboxes. I can search inside my sandbox from the shell without having to navigate to the hosted hoogle and mix/match versions with what I have installed in my sandbox. Unfortunately it still blows up trying to index some projects c'est la vie (reminder, I need to submit some bug reports). Also I know there's interest to have hoogle-index merged into hoogle, so the combination won't be necessary at some point in the future.  hlint  If I'm really bored and I want to refactor my code, I will run hlint and apply the suggestions. Unfortunately the suggestions are pretty shallow. I understand that it is a hard problem to suggest smarter refactoring, but there are also suggestions like ""redundant brackets"" which I won't apply most of the time, since they help with readability (not everybody has the memory to remember all the infix values for the operators used :) )  Tabular  A vim plugin I use to vertically align all those =, ->, etc. But I try to avoid a lot of let's, where's and cases, and simplify my functions."
haskell,3bqy5h,cretan_bull,2,Fri Jul 3 12:43:15 2015 UTC,What do you use hoogle for ? Can you use it to search for usages (of a given identifier) ?
haskell,3bqy5h,ndmitchell,3,Fri Jul 3 12:58:24 2015 UTC,"No. It's used for searching functions based on types, or name.  For example, dealing with the Pandoc package, say I want to know which functions return the Pandoc type, I query a -> Pandoc, and then I want to know which functions take a Pandoc type, I do another query Pandoc -> a  The search using the online tool uses some version of the pandoc package (idk which one) (I've also specified that I want to restrict the search to the pandoc package via +pandoc), but locally I might have a different version and that's why I use hoogle-index, to search inside the package versions I use.  edit:  It also depends how familiar you are with a packages types. Because it's one thing to know what to search for, and another to be started with a package from scratch."
haskell,3bqy5h,cies010,2,Wed Jul 1 16:04:17 2015 UTC,"$ sudo apt-get install hoogle $ hoogle ""a -> a -> a"" | head   I also have this in my ~/.ghci, which lets me :hoogle a -> a (no quotes needed) right in GHCi:  :def hoogle \s -> return $ "":! hoogle --count=15 \"""" ++ s ++ ""\"""""
haskell,3bqy5h,Vektorweg,3,Wed Jul 1 17:34:34 2015 UTC,"Emacs with a :hoogle command in ghci.  Cabal sandbox and cabal repl.  Haskell-mode with some add-on that shows -> as a real arrow, \ as a lambda, etc.  I tried FPComplete, but I've got a lot of customizations and integration in emacs that I want to keep.  Keybindings, orgstruct-minor-mode, and magit.  I've tried some of the smarter stuff in the past with emacs (that does autocomplete, etc), but my work-related source bases are usually quite huge, so they just fall over and die.  I've stopped trying to get anything more than M-x compile and next-error working."
haskell,3bqy5h,gallais,3,Wed Jul 1 19:21:21 2015 UTC,"ghci-ng and haskell-mode with proper goto-definition, get any subexpr type, quick type-checking and jump to error, and more are a life-safer for me."
haskell,3bqy5h,ndmitchell,1 point,Wed Jul 1 21:37:55 2015 UTC,How do you get go to definition? Which part of your setup gives you this feature? haskell-mode alone can do that ?
haskell,3bqy5h,gallais,2,Wed Jul 1 20:12:47 2015 UTC,It queries the ghci-ng.
haskell,3bqy5h,mallai,1 point,Wed Jul 1 21:09:47 2015 UTC,"ok, just checked , haskell-mode can do that either via ghci or hasktags"
haskell,3bqy5h,mallai,1 point,Thu Jul 2 06:56:14 2015 UTC,does ghci-ng work with ghc 7.10 ?
haskell,3bqy5h,andrewthad,2,Thu Jul 2 13:07:42 2015 UTC,"Yeah, at least the latest git version does."
haskell,3bqy5h,el-seed,3,Thu Jul 2 11:04:13 2015 UTC,"I use emacs with ghc-mod, haskell-mode, haskell-indentation-mode and company-mode. Also magit and haskell-cabal-mode. ido-mode helps with navigating large projects.  ghc-mod is vital, working without it feels like having a hand tied behind my back. Seeing type errors without the need to compile and being able to inspect types under the cursor is vastly more efficient.  I tried several haskell indentation packages for emacs, haskell-indentation-mode is the only one which hasn't broken on my yet. Others were quite brittle, notably failing when I used ghc syntactical extensions.  I'm still experimenting with company-mode. It feels like black magic.  Generally I have a browser window open to the haddock documentation in my local sandbox. This is still somewhat awkward due Cabal issues #1465 and #462. It would be very nice if I could run a local webserver serving the documentation from all my sandboxes with actual working hyperlinks."
haskell,3bqy5h,wolftune,3,Thu Jul 2 11:46:15 2015 UTC,"I think if you build hoogle docs with --local, and then run a server with --local, it will serve the docs and rewrite the links to make them all work in a web server. I don't remember exactly how to do that, but I have done it in the past."
haskell,3bqy5h,Categoria,2,Thu Jul 2 13:07:21 2015 UTC,It would be very nice if I could run a local webserver serving the documentation from all my sandboxes with actual working hyperlinks.   Maybe a nice feature for stack?
haskell,3bqy5h,andrewthad,3,Wed Jul 1 21:42:11 2015 UTC,The Geany IDE. No magic interactive help and it works fine for me.
haskell,3bqy5h,drwebb,3,Thu Jul 2 20:32:15 2015 UTC,"Same here. And (for small projects which typecheck almost immediately), I tend to have a terminal on the side with watch -d -n 1 ""ghc -fno-code MyModule.hs"" to get feedback on potential type errors as soon as I save the file. It's a bit of a broken workflow but as I4dcQsEpLzTHvD1qhlDE said the barrier to entry is just too high for me to consider other tools."
haskell,3bqy5h,codygman,4,Thu Jul 2 21:33:14 2015 UTC,"Have you thought about ghcid, which basically is your watch workflow refined and packaged?"
haskell,3bqy5h,mnik,1 point,Wed Jul 1 23:32:23 2015 UTC,I finally had the opportunity to try it out today and it is indeed a great tool. Thanks for mentioning it and thanks for developing it!
haskell,3bqy5h,evanrelf,3,Thu Jul 2 01:11:45 2015 UTC,"Windows MinGhc - absolutely great on Win! cabal SublimeHaskell (gbrsales branch which works with GHC 7.10.1) ghc-mod (using the unreleased version built from source for 7.10.1) hasktags hoogle (over web) reverse dependency lookup (packdeps.haskellers.com/reverse/)    Recently I've been using Atom with plugins: haskell-ghc-mod, autocomplete-haskell, ide-haskell, language-haskell. It works really great! For example, you hover a mouse over an identifier and its type pops up! You save a file and errors and warnings are marked on the source. You hover a mouse and you can see them. Go to definition works with hasktags.  Given all the problems with SublimeHaskell, I am using Atom more and more now with good results.  I also tried stack and it works nicely. I will likely adopt it in the future.   Things I tried and would love to continue using but...   ghc-vis (https://github.com/def-/ghc-vis/), if it were easier to get up and running. EDIT: Tried again and failed. I managed to get it working once a few months ago. threadscope, if it were easier to get up and running. EDIT: actually, this time I managed to install it without any problems! haskell platform, if it were more up to date. I stopped using it in favor of MinGHC"
haskell,3bqy5h,drwebb,1 point,Thu Jul 2 20:31:18 2015 UTC,How do you use go to def in Atom ? ide-haskell does not support it afaik.
haskell,3bqy5h,WarDaft,2,Mon Jul 6 17:04:03 2015 UTC,I run hasktags like this hasktags --ctags --extendedctag . and then when you click on Go to declaration it pops up a dialog with two choices pointing to the same location. Just hit Enter.
haskell,3bqy5h,WarDaft,2,Thu Jul 2 16:53:46 2015 UTC,"vim, tmux, stack. I've always wanted to get ghcmod running and integrated with vim, but there always seems to be some problem where ghcmod doesn't work. I perceive it to be very useful, and when I move to GHC 7.10 I will being giving in another go.  Also, the vim syntax plugin for shakespeare is very useful for me."
haskell,3bqy5h,WarDaft,1 point,Thu Jul 2 19:18:07 2015 UTC,What is stack ? Can I get a link for it ?
haskell,3bqy5h,tejon,6,Thu Jul 2 19:26:54 2015 UTC,https://github.com/commercialhaskell/stack - it's rad. It's an alternative to cabal-install that reads cabal files and works much more predictably. Only downside is it doesn't integrate with ghc-mod and hdevtools.
haskell,3bqy5h,mallai,1 point,Wed Jul 1 13:39:59 2015 UTC,"thanks, is there some introductory video explaining how to use it? i cannot find any on youtube"
haskell,3bqy5h,tejon,6,Wed Jul 1 14:56:36 2015 UTC,Very new (and superb): https://github.com/commercialhaskell/stack/
haskell,3bqy5h,Mob_Of_One,1 point,Wed Jul 1 15:13:12 2015 UTC,"For starters, ghcmod still doesn't work with 7.10"
haskell,3bqy5h,maxigit,1 point,Sat Jul 4 17:38:55 2015 UTC,Nothing wrong with ghcmod-vim. It was ghcmod that didn't work correctly because I had GHC 7.8.4 and a version of cabal-install that was too new (if I remember correctly).
haskell,3bqy5h,shishkabeb,2,Wed Jul 1 15:19:28 2015 UTC,I use.   stack tmux (I run emacs in a terminal window) emacs haskell-mode structured-haskell-mode https://github.com/chrisdone/haskell-flycheck for flychecking hindent haskell-dash hlint dipping my toes in the water with stack-ide   With stack my tool chain has become a lot less brittle.  edit: fix haskell-flycheck link
haskell,3bqy5h,edwardkmett,2,Wed Jul 1 17:08:19 2015 UTC,"What exactly is stack-ide and how do you use it? I checked out the project page and I'm still not sure how to use it.  Ah I see, I didn't notice the ""stack-mode"" directory and *.el files last time."
haskell,3bqy5h,edwardkmett,1 point,Wed Jul 1 17:50:55 2015 UTC,Is stack-mode basically the stack variant of  ide-backend-mode?
haskell,3bqy5h,stepcut251,1 point,Wed Jul 1 18:13:56 2015 UTC,The link to flycheck-haskell is broken.
haskell,3bqy5h,tikhonjelvis,1 point,Wed Jul 1 16:05:16 2015 UTC,fixed ty
haskell,3bqy5h,bb6xt,2,Thu Jul 2 01:28:59 2015 UTC,"Not much, I just use:   Notepad++ ghcid   The only thing that feels missing is a type correct auto-complete, that works on library functions as well."
haskell,3bqy5h,hvr_,2,Thu Jul 2 02:05:11 2015 UTC,type correct autocomplete? in what situation would you use that? can you give a simple example?
haskell,3bqy5h,ndmitchell,10,Thu Jul 2 05:47:11 2015 UTC,"Basically every situation.  Suppose I'm typing map f (i. If f :: String -> Int, then obviously isJust :: Maybe a -> Bool is not a valid auto-complete suggestion at this point. On the other hand, id would be. intList :: [Int] would not, inventory :: [String] would, init :: [a] -> [a] would, instance would most definitely not.  Notepadd++ would suggest all of these tokens and more, however."
haskell,3bqy5h,_deepfire,1 point,Thu Jul 2 15:19:26 2015 UTC,This is indeed very interesting. Is there any tool in existence that can do that ? I wonder.
haskell,3bqy5h,kfound,2,Wed Jul 1 17:42:58 2015 UTC,I'm fairly sure it's a standard feature for IDEs on OO languages where the types are much simpler and the choices easier to filter out.
haskell,3bqy5h,cgibbard,2,Wed Jul 1 17:46:48 2015 UTC,"On Windows:   Sublime Text 3 SublimeHaskell hsdev branch SublimeRepl hsdev, hlint, stylish-haskell"
haskell,3bqy5h,cgibbard,1 point,Wed Jul 1 18:47:02 2015 UTC,"Interesting! I tried hsdev branch of Sublime Haskell but it was ""hanging"" Sublime badly all the time (program is not responding). Are these issues fixed now?"
haskell,3bqy5h,theonlycosmonaut,1 point,Wed Jul 1 18:55:54 2015 UTC,"Well, I'm a sample size of one and don't have any particularly large projects, but I haven't personally run into any hangs for whatever that's worth!"
haskell,3bqy5h,cgibbard,2,Wed Jul 1 21:41:50 2015 UTC,"Emacs with haskell-mode ghci GHC for Mac OS X / hvr's GHC PPA Stackage (Stack soon probably, which obviates the former list item and Stackage)"
haskell,3bqy5h,theonlycosmonaut,2,Wed Jul 1 19:45:29 2015 UTC,"vim : I probably tried all the plugins available but don't really use any. (I disabled ghc-mod and syntastic the other day, never managed to make them inside a sandbox). I don't use syntax highlight but instead a tweak configuration of vim-rainbow which colorize the full block instead of just the parentheses. tmux ghcid I discovered it recently and I love it (it's blazing fast) (when I don't forget to use it) cabal sandbox google to browse package on hackage. I wish I could browse the doc  (in textmode) straight from vim. I think that's what codex but I haven't had time to try it.   What I'm missing : having vim configured properly to jump/show to type/function definitions ]i. It's probably just a problem of setting path correctly. Be able to have the type of an expression under the cursor when the file doesn't compile."
haskell,3bqy5h,vitalijzad,2,Thu Jul 2 12:20:53 2015 UTC,emacs ghc-mod with hlint standard autocomplete   I need to look up the things people have written here...
haskell,3bqy5h,ch0wn,2,Thu Jul 2 21:56:07 2015 UTC,"I use vanilla vim, badly. Every once in a while I call out to grep or find.   hlint keeps sneaking into my projects by accident, but I can't point to anything tool wise that I use that isn't available on a fresh box."
haskell,3bqy5h,dan00,1 point,Wed Jul 1 19:47:30 2015 UTC,fresh box ? what do you mean ?
haskell,3bqy5h,afmrak,1 point,Wed Jul 1 20:21:32 2015 UTC,"Meaning if I grab a new Mac and install Haskell and pull things from github, I'm usually up and operational in an hour."
haskell,3bqy5h,codygman,2,Wed Jul 1 20:39:10 2015 UTC,Coffee. Lots of coffee.
haskell,3bqy5h,sandwichsaregood,2,Wed Jul 1 21:05:53 2015 UTC,"I use Emacs with haskell-mode. It's enough for me, so I haven't spent too much time looking at things like ghc-mod.   Honestly, ghci integration is pretty much all I need: as long as it's easy for me to load my current module into a ghci buffer and jump back and forth, I can be very productive. For me, ghci commands like :browse are good enough that I don't care much about intelligent auto-complete.  haskell-mode gets me that out of the box, as well as great syntax highlighting and indentation.  I have some hacky custom code for things like cabal sandboxes, but I think they're supported out of the box now."
haskell,3bqy5h,clrnd,2,Thu Jul 2 19:14:33 2015 UTC,Emacs with Prelude (https://github.com/bbatsov/prelude) ghc-mod
haskell,3bqy5h,Crandom,2,Thu Jul 2 21:38:44 2015 UTC,"Emacs (w/ haskell-mode, org-mode, Gnus, and other extensions)  To me personally, Emacs represents a (local) optimum in terms of usefulness. I haven't found any better (local) optimum yet I could switch to without incurring regressions.  The great thing for me is I don't need to learn a new IDE for each new language I come across, and I don't have to fight with my muscle-memory. If I need something changed, I can just load up the Elisp code, and modify/tweak it in-place inside my (long-running) running Emacs session.  Of course, nothing's perfect, so Emacs & Elisp have several warts too, due to design decisions made decades ago which are only being slowly addressed. Nevertheless, the benefits in productivity (except for the occasional procrastination when I start tweaking Emacs rather than working on the task at hand) clearly outweigh the downsides for me.  I'd love to have something like Emacs powered by Haskell instead of Elisp, but I think some of the dynamic properties of Elisp which Haskell can't easily emulate are what make Emacs so succesful. At the very least, one needs the ability to modify/tweak code in place, and have instant feedback. Even with code hot-swapping (which Haskell supports), I don't know how to handle modifying data-type definitions in a live program."
haskell,3bqy5h,semanticistZombie,2,Wed Jul 1 21:34:13 2015 UTC,"My main environment is Sublime Text plus ghcid.  I also use Google and Hoogle and GitHub extensively, although through Chrome."
haskell,3bqy5h,gelisam,2,Wed Jul 1 22:11:52 2015 UTC,"Emacs, haskell-mode, ghc-mod, nix-shell, halive -- which I'm surprised noone mentioned yet, it's great!  Considering a switch to ghci-ng.  Want to get company-mode completion working."
haskell,3bqy5h,bryangarza,1 point,Thu Jul 2 00:41:49 2015 UTC,Not heard of halive - will definitely try this. Thanks!
haskell,3bqy5h,athanclark,2,Thu Jul 2 07:21:44 2015 UTC,"I use vim with nothing special installed (configured to expand tabs to spaces, to maintain the indentation of the previous line, and to do some syntax highlighting and that's about it), and I typically just keep ghci running in a separate window alongside it, and a browser open to relevant haddock documentation.  Really just about any text editor will do, so long as it can be configured to do the tabs to spaces thing, I don't even mind using gedit or gobby (though gobby's lack of undo is unfortunate, the multiplayer ability makes up for it, I suppose). I have used emacs a bit in the past, but I mostly found haskell-mode to be disruptive (especially its weird indenting shenanigans which got in the way more often than helping). The only reason I use vim over gedit is that I'm somewhat used to its keys for search/replace and go-to-line, and perhaps the fact that it runs in the terminal window I opened it from is sometimes a bonus. I use the arrow keys, and some vim users would hate the amount of time I spend in insert mode.  The only thing I can imagine being useful as far as editor features go, but which to the best of my knowledge, no editor actually does correctly, is that any edit which directly or indirectly causes the position of the first non-whitespace character following a layout keyword (i.e. ""let"", ""do"", ""of"", ""where"", ""mdo"") to change, should cause the entire following block to move accordingly. That would save a small bit of time spent reformatting things occasionally.  Everything else I've found pretty underwhelming and/or seemingly unnecessary. I guess jump to definition might be nice in some cases? I dunno, it's not something I've ever really worried about. If it's a library definition and I want to see the implementation, usually I'll just click the source link from its haddock. If for some reason there's no haddock, I'll either load the file it's in and use search to get there, or if I'm really that unfamiliar, I suppose I'll grep for it at the commandline.  Sure, having a feature which does that for you is nice if you do it a lot, but I dunno, it somehow just doesn't bother me at all. Most of the cases where jump-to-definition will actually work seem like cases where you're likely to have a haddock generated for browsing documentation anyway.  Being able to see the types of terms in the editor is another nice feature idea, but how useful is it really when you have ghci open right there, and can ask it yourself? It would be really handy in a handful of cases where you're working on local definitions with complicated types to be able to see the types that actually got inferred by the typechecker. The typechecker in my head usually suffices somehow though, especially given that ghci is going to check my work and will tell me what types things had when I go wrong.  So I dunno, every time I installed things like ghc-mod, it ended up being like ""well, that's pretty neat"" while I played around with my editor for about 10 minutes, and then I proceeded to somehow avoid any circumstance where the features would be useful and justify the time spent setting them up."
haskell,3bqy5h,athanclark,1 point,Thu Jul 2 09:26:55 2015 UTC,"The only thing I can imagine being useful as far as editor features go, but which to the best of my knowledge, no editor actually does correctly, is that any edit which directly or indirectly causes the position of the first non-whitespace character following a layout keyword (i.e. ""let"", ""do"", ""of"", ""where"", ""mdo"") to change, should cause the entire following block to move accordingly. That would save a small bit of time spent reformatting things occasionally.   Isn't structured-haskell-mode doing something like that ?"
haskell,3bqy5h,rpglover64,2,Sun Jul 5 10:02:23 2015 UTC,"Only insofar as you let it take total control of handling layout and structure of the document, and only use its commands, rather than editing things on a textual level at all."
haskell,3bqy5h,get-your-shinebox,1 point,Mon Jul 6 19:54:39 2015 UTC,"should cause the entire following block to move accordingly   This is one of the reasons I prefer swung style, where all those keywords end a line, and the following block is simply indented some standard amount.  It doesn't always work AFAIR, thanks to Haskell being persnickety about indentation sometimes, but I find it much nicer overall."
haskell,3bqy5h,markandrus,1 point,Thu Jul 2 00:30:42 2015 UTC,"Yeah, that style often works better in terms of how much editing you need to do, but I don't like how it looks to read quite as much as the hanging style."
haskell,3bqy5h,AndrasKovacs,1 point,Thu Jul 2 16:27:03 2015 UTC,"I far prefer it aesthetically, and didn't even consider the burden of editing when I started to use it instinctively. I just didn't want to bring aesthetics into the discussion ;P. I prefer code to be close to the left of the page, not the right."
haskell,3bqy5h,fridofrido,1 point,Thu Jul 2 16:58:35 2015 UTC,"I am an Haskell newbie. I have tried to download Emacs Haskell plugins being behind a proxy and didn't succeed.  I have tried to install Atom plugins via atm behind a proxy but failed. At the end I just downloaded plugins and copied them into the right folder. Now I work with Atom, which is nice!  Maybe we should have a clear guideline and say: ""ignore eclipse and IntelliJ plugins, they don't work."""
haskell,3bqy5h,kfound,1 point,Fri Jul 3 04:55:59 2015 UTC,"I use hlint and used to use ghc-mod and hsimport inside vim, but they aren't compatible with stack (yet), I'm left with only the first one for the time being."
haskell,3br7b2,kqr,4,Wed Jul 1 14:23:55 2015 UTC,You can simplify things even further:  forM_ numbers $ \i -> do     response <- get (problem i)     putStrLn (response ^. responseBody . to decodeUtf8 . title)     threadDelay 2000000   Edit: s/title . traverse/title/
haskell,3br7b2,Tekmo,5,Wed Jul 1 15:09:58 2015 UTC,"I don't even need traverse here? Since title is already a traversal and will get smashed together with the Text monoid, if I understand /u/edwardkmett correctly."
haskell,3br7b2,Tekmo,3,Wed Jul 1 15:43:30 2015 UTC,"Yeah, that's right.  I think the traverse is not supposed to be there.  I'll fix my parent coomment."
haskell,3br7b2,edwardkmett,2,Wed Jul 1 18:29:47 2015 UTC,"Does traverse in this case work as a concat, merging all available h2 tags to a single string?"
haskell,3br7b2,edwardkmett,3,Wed Jul 1 15:12:29 2015 UTC,"kqr: (^.) will use a Monoid on the result type to smash together the 0 or more answers you can get if you are using it with a Traversal, but won't demand a Monoid from you if you have a Lens or Getter."
haskell,3br7b2,tel,2,Wed Jul 1 15:27:30 2015 UTC,"I'm not sure what this means, sorry. Bear in mind my understanding of lens(es) is mainly operational."
haskell,3br7b2,pimiddy,11,Wed Jul 1 15:30:28 2015 UTC,"Normally you use (^..) or (^?) to access the result of a traversal, the former gives you back a list of all results, the latter gives you back the first match in a Maybe:  > (""hello"",""world"")^..both [""hello"",""world""]   You can use (^.) to read from a Lens:  > (""hello"",5)^._2 5   but when you feed it a Traversal  > (""hello"",""world"")^.both ""helloworld""   it asks you for a Monoid to glue the answers together, here String = [Char] has a Monoid which appends the results."
haskell,3br7b2,Intolerable,3,Wed Jul 1 15:35:03 2015 UTC,"Ohh, that's neat and makes a lot of sense. I did not know that!"
haskell,3br7b2,TheJonManley,7,Wed Jul 1 15:37:21 2015 UTC,"It's a really cool trick, too. It relies on the fact that Const e is a Functor no matter what e is but only an Applicative exactly when e is a Monoid. So (^.) uses Const and if you pass it a Lens (which uses Functor only on the inside) it'll not add any additional demands on e, but if you pass it a Prism or a Traversal (which use Applicative internally) then it'll automatically upgrade its ask to include Monoid."
haskell,3br7b2,taylorfausak,3,Thu Jul 2 03:33:56 2015 UTC,Thank you for this short and informative post! I didn't know about taggy-lens or wreq.
haskell,3br7b2,AlpMestan,3,Thu Jul 2 08:45:16 2015 UTC,"mildly off-topic – is there a better way of feeding durations to threadDelay? usually i just do threadDelay $ 5 * 1000 * 1000, you've just got threadDelay 5000000 but there must be a less error-prone way of saying ""wait 5 seconds"""
haskell,3brzvz,NiftyIon,2,Wed Jul 1 17:55:34 2015 UTC,"data Person = Adult {         age :: Age,         weight :: Weight,         address :: Address     } | Child {         age :: Age,         weight :: Weight,         parent :: Person      }   Might be worth pointing out that address and parent can fail at runtime, as you do with head and tail later. That's assuming you intend to keep peddling this partial smut to impressionable new Haskellers, you filthy degenerate. ;)   This cartoon is of course not exactly what happens when Haskell code is run   ...what cartoon? I wanna see the cartoon!  Edit: Finished the first one. That replaceWithMin example at the end is really cool!"
haskell,3brzvz,tejon,2,Thu Jul 2 02:07:35 2015 UTC,"EDIT: Changing the location signature to location :: Person -> Address seems to  fix it  I knew 0 Haskel as of this morning. This example is where I got stuck:  module PeopleRecord (main) where  newtype Age     = Age Float     deriving Show newtype Weight  = Weight Float     deriving Show newtype Address = Address String     deriving Show  data Person = Adult {     age :: Age,     weight :: Weight,     address :: Address } | Child {     age :: Age,     weight :: Weight,     parent :: Person }  charlie, victoria, john :: Person charlie  = Adult (Age 50) (Weight 150) (Address ""Happy St."") victoria = Adult (Age 52) (Weight 150) (Address ""Happy St."") john     = Child (Age 10) (Weight 90) charlie  location :: Person -> String location Adult{address = addr} = addr location Child{parent = adult}  = location adult   main = print(location charlie, location john, location victoria)   produces this error:  PeopleRecord.hs:26:34:      Couldn't match type ‘Address’ with ‘[Char]’     Expected type: String       Actual type: Address     In the expression: addr     In an equation for ‘location’:         location (Adult {address = addr}) = addr   Any pointers on how to fix it?"
haskell,3brzvz,ThuperThecret,3,Sat Jul 4 20:07:08 2015 UTC,"(For a short answer, jump to the dividing line.)  For starters, if you don't know, this:  PeopleRecord.hs:24:34:   ...means the error was detected on line 24 of your source, starting at character 34 of that line. The root cause might be elsewhere, but this is always a good place to start. Your line 24 is:  location Adult{address = addr} = addr   The rest of the error is telling you that this is returning an Address when the compiler expects it to return a String (a.k.a. [Char], they're synonymous -- that inconsistent representation is admittedly a blemish in the GHC error output). So there are four questions here: why does it expect a String, why is it returning an Address, which of those behaviors do you actually want, and what change needs to be made? It's best to investigate them in that order, because the earlier ones can give hints about the later ones.  The reason it expects a String is right on the previous line: you told it so!  location :: Person -> String   While it's possible you were mistaken about what you actually want to return from this function, it's unlikely, so this also answers question three as well; you really do want a String. So then, where does the Address come from? Well, there's pretty much only one place it could -- your function is only one line long, and has only one way of getting data: Adult{address}. And indeed...  data Person = Adult {     ...     address :: Address }   So what, exactly, is an Address? It's defined just above:  newtype Address = Address String   And this gives us two possible solutions, which I'll take a moment to explain in detail because I spent a while confused about type and newtypetoo. :)  A type is just a synonym. All it does is take an existing type and give it a different name, at which point the two names are completely interchangeable. As illustrated in that slightly inconsistent error message, String is a type for [Char]. Your location function is written as if Address were a type for String.  But it's not -- it's a newtype, which is more like a wrapper around another type, not just an alias. The compiler still knows it's the same type underneath, so newtype costs nothing at runtime just like type, but in the source you're required to pretend they're two completely different types with nothing in common. Basically, you need to treat it as if it were a data type.  So newtype is less convenient to use, but when you think about it, it's often the more useful of the two. In your code here, you have an absolute guarantee that arbitrary strings cannot be placed in the address field: they have to be wrapped into Address first. On its own, this prevents a lot of accidents; and if you want an even stronger guarantee, you can put this in a module and not export the Address constructor, instead exposing only functions to wrap (and maybe unwrap) an Address -- allowing you full control over what strings can legally become Addresses. (newtypes also allow new typeclass instances, which is a more advanced topic but also extremely useful.)  That's not to say there are no good uses for type. Types can get complex, and it's handy to be able to abbreviate them. For instance, when writing a reddit bot, I declared this:  type BotM a = RedditT (StateT CommentID (ReaderT BotInfo IO)) a   ...because that's a hell of a thing to put in every type signature! Essentially, type is great when you want a shortcut for a more specific version (or combination) of existing types. (Or, in the case of String, just a friendlier name.)    So let's finally solve your error. :) As I said, there are two options. Either change your Address definition:  type Address = String   Or, explicitly unwrap the newtype in your location pattern-match:  location Adult{address = (Address addr)} = addr   I recommend the latter, because you really don't gain anything from the former. (In fact, the type solution is exactly equivalent to changing your Person to use address :: String. So I guess that's technically a third option.)"
haskell,3brzvz,tejon,1 point,Sat Jul 4 21:09:22 2015 UTC,Sorry about that. That's just a mistake in my code; I'll fix that. Take a look at /u/tejon's response for a good explanation of how to fix and diagnose errors like this.
haskell,3brzvz,wolftune,2,Sat Jul 4 23:27:32 2015 UTC,"Looks good at first glance. Would you please add an explicit CC BY-SA license or other free/open license to your blog to make it easiest for others to adapt, improve, use, combine with other resources?"
haskell,3brzvz,wolftune,1 point,Thu Jul 2 19:59:49 2015 UTC,"I haven't thought about licensing in this context. What sort of things might one want to do that require such a license? (I'm open to the idea, though.)"
haskell,3brzvz,gilmi,3,Thu Jul 2 20:31:25 2015 UTC,"All the freedoms that relate to software relate entirely to other works just as well. See http://freedomdefined.org/Definition  To be specific to your case, one might do any of these sorts of things:   print out sections of your blog to hand out to students in a class (yes, that is arguably copyright infringement, despite happening all the time) make a version that has more thorough exercises / added content translate this to another language make a video version edit the text to add more humor or to make wordings yet more concise or who knows what other creative things make a derivative work that mixes bits of your explanations (which are excellent btw! Now that I've started really reading this, THANKS!) with other resources, such as the freely-licensed https://wiki.haskell.org content or the generally excellent Haskell Wikibook use some of the nice illustrations in a totally different writing about lists or whatever   and so on and so on…  Now, regarding licensing, just as the Free Software and Open Source definitions reject weird clauses about non-commercial use or no-distributing changes, such clauses are equally problematic here. Thus, please don't use NC or ND clauses that Creative Commons licenses offer as options. Effectively those are the anti-Wikipedia clauses and such, as they just divide the commons and make things awkward. The two other clauses that CC licenses offer are BY (require people to give you credit) and SA (share-alike, i.e. copyleft, like the GPL for software). The Creative Commons license chooser is pretty good (although it leads too many people to choose the NC license without realizing its problems, but at least they mark that as non-free).  Like with software, the SA (copyleft) clause keeps things in the commons and discourages unfair exploitation (e.g. someone using your work in their proprietary textbook) but can cause unwanted license incompatibilities. So, you should use CC0 to waive all rights (effectively a public domain grant), CC-BY to license in a way that is like the MIT license for software, or CC-BY-SA to license more like GPL.  Thanks for your consideration of these things, and thanks for your contribution to the community! I'm happy to answer other questions or provide other links about the issues if you want."
haskell,3brzvz,emarshall85,1 point,Thu Jul 2 21:10:28 2015 UTC,"I've only skimmed it, but it looks like really good stuff.  If there was one thing that I could add it would be some emphasis on composition early on the intro."
haskell,3brzvz,wolftune,1 point,Wed Jul 1 19:42:21 2015 UTC,Interesting. I'll go through this the next few days to see how much I've forgotten about Haskell :-p. Will keep notes as I go through it of errors.
haskell,3bqlis,want_to_want,22,Wed Jul 1 10:23:46 2015 UTC,"Using accum and replicate from Data.Vector:  histogram n ns = accum (+) (replicate n 0) (fmap (\x -> (x, 1)) ns)   According to the documentation of Data.Vector this should be O(n + length ns).  Not sure, wether this fits your criteria, but it is probably as close as it gets, since the only spirit-violating stuff would be happening under the hood in the Vector library."
haskell,3bqlis,Pseudoradius,3,Wed Jul 1 14:25:09 2015 UTC,I really need to learn Data.Vector at some point...
haskell,3bqlis,kqr,1 point,Thu Jul 2 06:56:21 2015 UTC,"That's not quite within the spirit of the question, but thanks for the pointer anyway!"
haskell,3bqlis,focuskids,13,Wed Jul 1 14:32:27 2015 UTC,"Vector is pure. All functional languages compile down to some program that actually mutates memory. The difference is, they have been carefully written so that the interface is pure."
haskell,3bqlis,danbst,7,Wed Jul 1 17:13:07 2015 UTC,"My question wasn't dictated by a practical need. I'm trying to figure out some stuff in theory, under the artificial constraint that you can't use any ""under the hood"" mutability except the limited mutability provided by laziness and thunks."
haskell,3bqlis,kqr,2,Wed Jul 1 17:31:34 2015 UTC,"f xs :: Unique [Int] -> () =   let xs' = map (+1) (uniq xs)   in xs' `seq` ()   assuming that Haskell could get uniq keyword, that forbids using the value thereafter, it is possible for compiler to do under-the-hood mutable algorithm for map and allocate no additional thunks (assuming that foldr/build optimisations do not trigger). Is this kind of mutation forbidden in your specification of a problem?"
haskell,3bqlis,merijnv,3,Thu Jul 2 09:30:26 2015 UTC,"Yeah. There's a bit of rivalry between laziness and uniqueness types, because both are disciplined forms of mutation. Since I already know that uniqueness types allow translating any imperative program into a functional program with the same asymptotic complexity (learned that from /u/Felicia_Svilling a while ago), in the current post I focus on laziness only."
haskell,3bqlis,chrisdoner,23,Thu Jul 2 10:40:44 2015 UTC,"I probably don't have the answer you're looking for, but I just want to dispel a myth: you can (and frequently do!) have mutation in pure languages. If the same input array always gives the same output histogram, then the histogram function is pure. It doesn't matter whether or not it's implemented with mutations. (You sort of hint at knowing this already, I just want to make it abundantly clear.)  A couple of other observations:   Logarithmic update time might not be as bad as it seems. As the saying goes, ""O(log n) is O(1) for any realistic n"". I've found that immutability throughout generally has worse performance than mutability, as you observe. But this is not surprising nor a bad thing, given that our von Neumann machines are kinda stateful in their core. If we were using languages with a focus on immutability all along, we would probably view mutability as a performance optimisation akin to unrolling loops or inlining functions.  So in a way, your question reads like, ""In a language with no loops, this code is really fast because there are no conditional jumps. How would you do that in a language where a loop is more idiomatic, while retaining the performance of an unrolled loop?"" (Barring any cache issues, branch prediction and the like which might make the loop actually faster.)  The answer is a pretty boring, ""By unrolling the loop and writing unidiomatic code, if performance is critical."" Similarly, I suspect the boring (but correct) answer to your question might be, ""By using isolated mutation in the histogram function, if performance is critical."""
haskell,3bqlis,edwardkmett,7,Wed Jul 1 10:36:11 2015 UTC,"Yeah, these points are not new to me. I'm mostly interested the purely theoretical question."
haskell,3bqlis,maxigit,6,Wed Jul 1 11:36:36 2015 UTC,"If you are interested in the purely theoretical question, pick up Chris Okasaki's ""Purely Functional Data Structures"", this book is based on his thesis with the same title and is concerned with two topics: 1) Efficient, purely functional data structures/algorithms, like purely functional queues, etc. and 2) the proof that for any given imperative algorithm there is a purely functional algorithm that is, at worst, O(log n) slower. So it's possible there are equally fast/faster functional algorithms, but the best purely functional one will never be more than log n slower than the imperative."
haskell,3bqlis,TJSomething,6,Thu Jul 2 08:37:58 2015 UTC,I've read Okasaki and it's one of my favorite books. The question is whether we can avoid the logarithmic slowdown in this specific problem.
haskell,3bqlis,gelisam,2,Thu Jul 2 08:59:45 2015 UTC,"you can (and frequently do!) have mutation in pure languages   If it's not observable or expressible it's not really ""in"" the language."
haskell,3bqlis,guibou,9,Thu Jul 2 13:43:40 2015 UTC,">>> Data.Foldable.toList $ accumArray (+) 0 (0,49) $ (,1) <$> [1,3,1,1,1,1,2,2,3,2] [0,5,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]   uses the ability to construct an array in linear time in the number of elements and updates using accumArray.  Does this use mutation behind the scenes? Yes.  Can you observe that fact? No.  Alternately you can embrace an MSD or LSD radix sort using discrimination, etc. n is included in your problem size. You have to build an array of that size anyways, so a counting sort or radix sort doesn't change the asymptotics."
haskell,3bqlis,ReinH,1 point,Wed Jul 1 16:09:19 2015 UTC,Replied over there.
haskell,3bqlis,TJSomething,1 point,Wed Jul 1 16:38:50 2015 UTC,Can you observe that fact? No I think the OP question is on a theoretical point of view. Using a mutating array under the hood is answering the question.
haskell,3bqlis,twistier,6,Wed Jul 1 19:16:31 2015 UTC,"I actually implemented that algorithm in C and it appears to be logarithmic with respect to the number of bins. I used a length of 1,000,000. Also, Data.IntMap uses big-endian patricia trees, which have an update complexity of O(min(bins, word size)), which seems close to what you want.  #include <stdlib.h> #include <stdio.h> #include <time.h>  int main(int argc, char **argv) {   srand(time(0));   if (argc == 3) {     int max = atoi(argv[1]);     int length = atoi(argv[2]);     int *arr = malloc(max*sizeof(int));     for (int i = 0; i < length; i++) {       arr[rand() % max]++;     }     // Print the result to keep it from being optimized away     printf(""%d\n"", arr[0]);   } else {     printf(""%s <max> <length>\n"", argv[0]);   } }     ints        time 1           0.02 2           0.018 4           0.014 8           0.013 16          0.012 32          0.02 64          0.013 128         0.012 256         0.013 512         0.013 1024        0.01 2048        0.01 4096        0.01 8192        0.01 16384       0.014 32768       0.02 65536       0.021 131072      0.016 262144      0.015 524288      0.014 1048576     0.021 2097152     0.039 4194304     0.048 8388608     0.062 16777216    0.061 33554432    0.083 67108864    0.176 100663296   0.243 134217728   0.22 201326592   0.392 268435456   0.407 402653184   0.627 536870912   0.673 805306368   0.906 1073741824  0.955"
haskell,3bqlis,TJSomething,5,Wed Jul 1 18:30:55 2015 UTC,"For the lazy, here's a plot of the points: http://fooplot.com/plot/mhxo5mw2bw"
haskell,3bqlis,twistier,3,Wed Jul 1 19:26:21 2015 UTC,"Do you have an idea of the reasons of this log behavior ?  This algo is so simple that the instruction cost must be negligible, so I ""guess"" roughly all the time is spent in memory read and write.  When you increase the bin count, you just increase the probability of cache miss. For example, my i7 have respectively 64 KB and 6 MB in its L2 and L3 caches. So above 16000 int, I'll start missing L2 cache and above 1.5 millions int, I'll start missing L3 cache. So I'm predicting a non linear behavior with some increase at 16000 and 1.5 millions int, which is not what you observe, so I'm wrong, but why ? ;)  (edit: I'm observing exactly the same thing)"
haskell,3bqlis,TJSomething,2,Thu Jul 2 08:46:21 2015 UTC,"I'm not seeing any log or log-linear behavior here, though. I'm seeing linear behavior as expected. Perhaps if you have more data to support the conclusion you could offer it, because 30 data points isn't really enough."
haskell,3bqlis,chreekat,2,Thu Jul 2 17:01:49 2015 UTC,"It appears to show roughly logarithmic behavior until about 2 billion ints. I believe that might be because it hits the capacity of my RAM, since free tells me I have 9.5 GB of free RAM. Past that it stays constant. Here's a plot of 935 data points"
haskell,3bqlis,_AndrewC_,1 point,Thu Jul 2 23:51:22 2015 UTC,"Probably the big flat part of the plot is when nearly every memory access is a cache miss. If you were to continue growing until you run out of RAM and have to swap, you would see it start to slowly grow again as more memory accesses have to go to the hard drive, and then it would flatten out again until you run out of swap space, and then you have to find some other way to store your data, at which point it will begin slowing again.  How far can this go? At the theoretical limits of the real world, accessing any sort of memory is probably O(∛n); if you imagine you are in the center of a perfect sphere of data and you want to access some point within that sphere, this is how long it would take the light to travel."
haskell,3bqlis,gelisam,1 point,Fri Jul 3 16:02:29 2015 UTC,"Actually, due to the fact that the Bekenstein-Hawking entropy of a black hole is proportional to its area, not its volume, the entropy of a given sphere is actually limited to its surface area, which would make accesses O(√n). More exactly, you can fit n bits into a sphere of radius 7.592×10-36×√n meters or P*sqrt(ln(2)*n/(π bits)), where P is the Planck length."
haskell,3bqlis,gelisam,1 point,Fri Jul 3 17:23:19 2015 UTC,"I hadn't read about Bekenstein-Hawking entropy before now, and I definitely am out of my ballpark here, but doesn't the relevance of this to the point depend on how the black hole information paradox is resolved? Or does this property of black holes imply something in other contexts, not involving black holes?"
haskell,3bqlis,_AndrewC_,1 point,Fri Jul 3 18:26:06 2015 UTC,"If we're pessimistic and say that we can't build computers out of black holes, since we're talking about asymptotic behavior, we have to consider the case of a solid ball of memory with a mass on the order of a star. At about that size, there will come a point where, if we keep adding memory, the memory ball will collapse into a black hole. In order to prevent this from happening, larger memory balls need to be lower in density in order to prevent them from collapsing into black holes. This limits the amount of memory in the memory ball to the area of the ball, as the amount of memory approaches infinity.  Practically, at that scale, the only design for memory that we know works is storing the memory in a Dyson sphere, which is inherently limited by the area of the sphere."
haskell,3bqlis,_AndrewC_,4,Fri Jul 3 19:16:59 2015 UTC,"Code with effects is not impure code. That's what monads are for!  I don't think it's fair to disallow ST as ""not spiritually pure"". It's totally pure. Sure, under the level of abstraction there is real electricity flowing through wires, but isn't that true of the entire runtime? Would it be fair to say, ""well, under the surface it's just C, so Haskell isn't really pure""?  The point of a real-word language like Haskell is to create a pure abstraction that programmers can use. Even IO is pure! It's just ugly, because it captures so many different types of effects, with no laws, that it is impossible to reason about. (Hopefully we continue to find effects with laws that we can split out of IO.)  To summarize, the only thing the imperative histogram implementation has that a functional implementation would not is implicit state. It's true that a programmer's first inclination might be to use an O(N log N) solution, but if it became necessary to optimize one could do so without breaking purity."
haskell,3bqlis,Tekmo,2,Wed Jul 1 14:47:48 2015 UTC,"Yes, I'm aware of many possible solutions in Haskell. I want specifically a solution under certain constraints. Partly it's a reaction to claims that laziness is a particularly disciplined form of mutation and can be used to replace less disciplined forms."
haskell,3bqlis,Tekmo,5,Wed Jul 1 15:10:56 2015 UTC,"But then it seems irrational to rule out ""mutation under the hood"" solutions like accumArray, because they provide a simple pure interface to memory, efficiently. The hard truth is that haskell uses mutation under the hood all the time, on the heap and the stack.   I worry that you crave to conclude that haskell is slow because it's pure and doesn't mutate, but you've ended up tying yourself in knots about just what counts as haskell so you can discount a pure immutable data structure that's implemented using random access.   Essentially you want to criticise haskell for not having unprincipled random mutation, but to make this stick you're ruling out principled implementation using random access mutation.   The clue is that every time someone comes up with an asymptotically fast solution you say it missed the spirit of the question or call it borderline.   Don't be surprised if you conclude that haskell is deficient if you rule out its features."
haskell,3bqlis,Tekmo,3,Thu Jul 2 00:00:18 2015 UTC,"Too many people interpreted my post as ""Haskell sux"", when the intended interpretation was ""here's a nice math problem"".  Arguing against the assumptions of a given math problem is usually unproductive. For example, ""you can't square a circle using only a compass and ruler"" is a deep mathematical fact that opens up a whole new area, while saying ""it's unfair to restrict yourself to compass and ruler, you're biased against geometry"" is an argument that leads nowhere.  The right attitude for a researcher is to sometimes adopt unreasonable assumptions and run with them, just to learn exactly where they will take you. The impossibility of squaring a circle doesn't mean that ""geometry sux"", Arrow's theorem doesn't mean that ""democracy sux"", and the CAP theorem doesn't mean that ""databases sux"". These are interesting facts that expand our knowledge of the world, but you'll never discover them if you get stuck on arguing which assumptions are ""fair""."
haskell,3bqlis,tavianator,4,Thu Jul 2 07:00:16 2015 UTC,"Too many people interpreted my post as ""Haskell sux""   I do admit that contributing to this thread makes me emotionally charged. However that is not because I want to defend Haskell (the fact that you're excluding ST etc. already indicates that you're talking about a more restricted language), but rather, because of the way in which you dismissed many great answers by seemingly changing the goal posts. This is frustrating because I and others spend a lot of time looking for good answers and finding the right words to explain them, so when I saw your comments dismissing those answers without even bothering to explain in which way the answer did not fit the ever-so-vague ""spirit"" of your question, it made me upset. I decided to call you out on this behaviour; my first comment started as a rant, and then I rewrote and rewrote it to make it as polite and constructive as I could. Which is also what I mean by ""spending a lot of time finding the right words"".  I have since realized that you were not actually changing the goal posts, you were merely guilty of assuming that everybody would intuitively understand what you meant by ""pure in spirit"".   when the intended interpretation was ""here's a nice math problem"".   Then the semi-heated discussions are unfortunate, because I would have enjoyed a nice math problem. May I advise working on the way in which you formulate such problems? It wasn't obvious to me at all that this was a math problem. For one thing, math problems are usually extremely precise in their assumptions."
haskell,3bqlis,Tekmo,3,Thu Jul 2 13:04:41 2015 UTC,"Well, I didn't know the precise formulation of the problem when I posted it, and I'm still figuring it out now. The keywords ""lazy lambda calculus"" and ""transdichotomous model"" seem relevant, while things like accumArray seem less relevant, but it's hard to say much more than that. Mostly I was hoping that people would pick up on my sense of ""hmm there's something interesting here"" and help me flesh it out. That did happen to some extent.  Maybe my idea of ""interesting"" doesn't agree with most people's? What do you feel is the most interesting direction this discussion could take?"
haskell,3bqlis,WarDaft,3,Thu Jul 2 13:30:45 2015 UTC,"I think ""interesting"" is even more ill-defined than ""pure-in-spirit"" :)"
haskell,3bqlis,maxigit,2,Thu Jul 2 14:38:41 2015 UTC,"Too many people interpreted my post as ""Haskell sux"", when the intended interpretation was ""here's a nice math problem"".   Maybe I can help you understand how this happened with an analogy. If you're used to being teased for being geeky and nerdy whilst at school and told you'd never get a girlfriend, and then years later someone asks on www.weareallsogeeky.com/forum/ ""is it technically possible for a nerd to have a proper relationship?"" then I'm likely to pipe in with the fact that I'm married to someone much more attractive than me and have two children. If you then discount this example because I have too many social skills to be a genuine nerd, and you discount Bill Gates because he's rich and so on, you're likely to get called out for essentially redefining the question until you get the answer you wanted, making your conclusion vacuous.  Now it may be that you intended to have a discussion about how we define the word nerd, and wondered innocently whether we should exclude people with enough social skills to have a long-term relationship, but if so, you've framed it too combatively with people who've been rejected previously for nerdiness.  Coming back to Haskell, I've had so many conversations over the decades where people who don't do pure FP assert that it's an academic toy that's inherently and inevitably drastically slower than imperative code, that it's hard to hear someone ask ""can this possibly be as fast as imperative code?"" without feeling attacked yet again.   <paraphrased from first version> You don't know what I crave and shouldn't make assumptions </paraphrased>   I wasn't so much making assumptions as reading the mood music:   Partly it's a reaction to claims that laziness is a particularly disciplined form of mutation and can be used to replace less disciplined forms.   I hope you can see how it appears that you were looking for a counterargument to the benefits of pure FP. I'm afraid I'm still struggling to see this as a purely neutral theoretical thought experiment coming from a completely open mind. For instance it struck me quite firmly that you didn't explicitly assert that you aren't developing ammunition for such an such an argument and instead told me I didn't know what you were trying to achieve.    Radix sort complexity depends on integer width, which is O(log n) in my problem.   ...whilst array lookup is O(1) because integer width is ... oh... wait.. hang on... er?  This is the sort of thing that feels like goalpost-shifting. If integer length is really O(log n) then perhaps you should upgrade your server from 32 to 64 bit before sorting your 4 billion customer records."
haskell,3bqlis,maxigit,1 point,Fri Jul 3 02:09:42 2015 UTC,"Radix sort complexity depends on integer width, which is O(log n) in my problem.   ...whilst array lookup is O(1) because integer width is ... oh... wait.. hang on... er?   If we count individual bit operations, I think a purely functional radix sort still has higher asymptotic complexity than doing n imperative array lookups, by a factor of log(n) or similar. For a radix sort with log(n) passes, you need to copy the whole data log(n) times. For a radix sort with one pass, you need a large data structure for the buckets, with log(n) update time (similar to the counting sort in my post)."
haskell,3bqlis,Tekmo,1 point,Fri Jul 3 09:12:24 2015 UTC,"The factor you're referring to is (word size), not log (n) unless you are making the patently absurd assumption that you're always sorting enough data to bring you to the maximum possible addressable space, in which case from a practical point of view you'll have to take into account all the thrashing to disk (unless of course you're flying on bare metal without an operating system! ).   If you're going down to bits you have to do so for both, and your comparisons for nearby data (which you inevitably do a fair bit of in a comparison based sort) all take (word size) time to do as well, so you can't assert nlogn any more there.   Again, you can't split hairs on one side and gloss over them on the other without falling prey to yet more accusations of in-match goalpost-shifting.   You again don't deny that this is just part of an anti pure fp argument/viewpoint/bias, I notice."
haskell,3bqlis,SrPeixinho,2,Sat Jul 4 13:38:19 2015 UTC,"This conversation isn't useful to me, sorry. Let's take a break."
haskell,3bqlis,zhensydow,4,Sat Jul 4 13:49:42 2015 UTC,"Imperative reads and writes are technically not O(1) both in theory and practice.  If you want to supply an index into an array of N values the index itself is O(log N) bits.  In practice this time complexity of indexing manifests as slower reads and writes as your data grows and requires larger and slower data stores (i.e. registers -> L1 cache -> L2 cache -> ""RAM"" -> disk -> distributed data store).  The only difference between imperative and purely functional mutation is constant factors, not time complexity."
haskell,3bqlis,augustss,2,Wed Jul 1 15:22:23 2015 UTC,"Are you saying that mutating a piece of memory has the same bit complexity as making a new version of a functional array implemented over that same memory? I'm not sure. If the former is O(log N), it seems like the latter should be O(log2 N) or something like that."
haskell,3bqlis,tsahyt,3,Wed Jul 1 15:25:14 2015 UTC,"The equivalent functional data structure is a binary tree.  In Haskell, both reading and updating a value in a binary tree is O(log N) thanks to sharing."
haskell,3bqlis,augustss,3,Wed Jul 1 17:16:07 2015 UTC,"Am I missing something, or are you comparing the complexity of array indexing in bit operations to the complexity of tree update in integer operations?"
haskell,3bqlis,augustss,4,Wed Jul 1 17:29:06 2015 UTC,"So the O(log N) factor bites you at several levels (physical layout, memory hierarchy, and just plain indexing).  However, let's focus on just indexing since that is the easiest one to explain even though it has the smallest constant factors.  In order to index into an array that has N elements you must provide an index that is O(log N) bits.  That means that in order to actually look up the element you must minimally scan O(log N) bits of the address the user provides.  The only reason you don't notice this time complexity is that on a single machine log N never exceeds 64 bits, but asymptotic time complexity has to consider numbers larger than what fits on a machine.  These O(log N) bits are analogous to the O(log N) binary decisions that you have to make when descending into a binary tree."
haskell,3bqlis,augustss,3,Wed Jul 1 17:59:28 2015 UTC,"But the point is, in a binary tree the pointers are log N bits wide too, so if you have to follow log N pointers you take log2 N time.  Whereas the array indexing is still just log N."
haskell,3bqlis,augustss,3,Thu Jul 2 03:55:26 2015 UTC,A binary tree doesn't have to be encoded using pointers.  There are more efficient representations that /u/edwardkmett describes in this talk
haskell,3bqlis,twistier,2,Thu Jul 2 05:06:18 2015 UTC,"Such techniques are not tailored to my problem, they can apply to all uses of imperative arrays. That means if you can overcome the logarithmic slowdown using such techniques, you'll prove that every imperative program can be converted to a functional program with the same asymptotic complexity in bit operations. But actually that's provably false in the strict setting, and an open problem in the lazy setting. So maybe worth double-checking your reasoning here, because you might have a big new result on your hands :-)"
haskell,3bqlis,augustss,6,Thu Jul 2 07:26:41 2015 UTC,"From a strictly CS perspective, they do in fact have the same time complexity. To see this, reduce to the absurd: Suppose you want to change just one of a long vigintillion items all contained in an array. You need a big-int for this index, which is slower than an int64. And an int64 on 64 bit architecture is slower than an int32 on 32 bit architecture of the same scale, the int64 requires more gates to do every option, meaning a bigger chip, meaning larger travel times, even if the gates are just as small.  We treat them as constant, but that's only because we've applied a ceiling function to all int64s and made the smallest run every bit as slow as the biggest.  So in the theory sense, the difference between an array lookup and bitwise binary tree really is a constant factor, just a big one."
haskell,3bqlis,maxigit,1 point,Wed Jul 1 21:57:09 2015 UTC,"Read and writes are still always faster than the worth case scenario (register -> L1 cache ...), therefore it's still O(1) (just a bigger O ;-))"
haskell,3bqlis,AndrasKovacs,1 point,Wed Jul 1 19:10:29 2015 UTC,"The only difference between imperative and purely functional mutation is constant factors, not time complexity.   Not being able to modify a ""slot"" (O(1)) but have to use binary tree (O(log n)) is a change in complexity. Of course we are discarding the use of array which are under the hood mutable."
haskell,3bqlis,frud,3,Wed Jul 1 19:14:05 2015 UTC,My point was that you can't modify a slot in O(1).  It's actually O(log N) to modify a slot with an extremely small scaling factor
haskell,3bqlis,sambocyn,1 point,Wed Jul 1 19:45:26 2015 UTC,It is more like O(N1/3) no? We don't have infinite spatial dimensions to do the search...
haskell,3bqlis,frud,1 point,Thu Jul 2 08:14:03 2015 UTC,"Maybe even O(N1/2), because the max information stored within a volume of space is proportional to its surface area (Bekenstein bound)."
haskell,3bqlis,maxigit,11,Thu Jul 2 20:38:39 2015 UTC,"In Haskell:  import  Data.List import Control.Arrow  histogram = fmap (head &&& length) . group . sort   I try to explain. To obtain an histogram you should count the number of times a different element appears on the data.   If you have [1,2,1,3,1,2,1,2,1,2,1,2,1], the (group . sort) part groups your elements in three lists with homogeneous values -> [[1,1,1,1,1,1,1],[2,2,2,2,2],[3]]  Then if you apply head to this list you obtain the histogram index -> [1,2,3]. If you apply length to this list, you obtain the count of each element [7,5,1].   With (head &&& length) you apply both transformations at the same time, you obtain an histogram [(1,7),(2,5),(3,1)]  From there you can convert the histogram as [(index,count)] to the representation you need.  Do you think it is pure enough ;) ;) ?"
haskell,3bqlis,alien_at_work,6,Wed Jul 1 11:22:04 2015 UTC,"Sorting is O(n log n), where n is the length of the input list. The imperative solution is O(n)."
haskell,3bqlis,zhensydow,8,Wed Jul 1 11:23:39 2015 UTC,Sorting fixed width integers (like your example has) is O(n).
haskell,3bqlis,tsahyt,9,Wed Jul 1 11:26:49 2015 UTC,Does Data.List.sort do that?
haskell,3bqlis,AndrasKovacs,7,Wed Jul 1 11:28:16 2015 UTC,No.
haskell,3bqlis,lodi_a,4,Wed Jul 1 11:36:57 2015 UTC,"Yes, with a counting sort, which uses a histogram, which is what I'm asking about. Or do you mean something else?"
haskell,3bqlis,gelisam,11,Wed Jul 1 11:37:46 2015 UTC,"For instance, radix sort.  See http://hackage.haskell.org/package/discrimination"
haskell,3bqlis,gelisam,3,Wed Jul 1 11:41:02 2015 UTC,"Radix sort complexity depends on integer width, which is O(log n) in my problem."
haskell,3bqlis,maxigit,13,Wed Jul 1 11:44:12 2015 UTC,"I assumed that the n is limited to the array size you can have in a computer, so either 32 or 64 bits.  If you're going use use arbitrary sized integers in your input then your array indexing in histogram is unlikely to be constant time."
haskell,3bqlis,gelisam,5,Wed Jul 1 11:46:58 2015 UTC,"By the same token, would you say that functional arrays have O(1) update because address space is finite? That feels a bit borderline, not 100% within the spirit of the question."
haskell,3bqlis,maxigit,9,Wed Jul 1 11:57:29 2015 UTC,"And to answer the array update question.  If you assume a maximum size of all arrays then ""updating"" by copying is formally O(1).  This is of little use in a practical case, of course.  Asymptotic complexity can be quite useless. :)  On the other hand, if you assume that arrays can have unbounded size, then copying is O(n) (or O(log n) using a tree).  But assuming you can have unbounded size arrays with a O(1) access time is also an unreasonable machine model."
haskell,3bqlis,gelisam,4,Wed Jul 1 12:19:47 2015 UTC,I find it a bit unusual that you would consider what is effectively a comparison O(log n) but using the same data as an index for an array lookup O(1).
haskell,3bqlis,gelisam,3,Wed Jul 1 12:24:08 2015 UTC,"The complexity of radix sort is not due to individual comparisons being O(log n), it's due to multiple passes through the data."
haskell,3bqlis,julesjacobs,2,Wed Jul 1 13:36:53 2015 UTC,"Well, I'm not sure what the spirit of the question is.  Questions of complexity are hard unless you nail down exactly what you're asking, and what kind of primitives you assume.  From a practical perspective there's no doubt the imperative version you gave is faster than any ""pure"" version.  But if you're talking asymptotic complexity things are different.  Also, (I've not tested this, so take it with a grain of salt) if you use the package I linked to and make a histogram of a [Int] you will get a straight line when plotting time as a function of input length.  Is that in the spirit of the question?"
haskell,3bqlis,gelisam,3,Wed Jul 1 12:05:17 2015 UTC,"For what it's worth, my intended machine model is something along these lines. Operations on ""machine words"" (integers of a certain fixed size) take constant time, including array indexing, but the ""word size"" isn't known to you in advance, so you can't claim that its logarithm is a constant factor."
haskell,3bqlis,julesjacobs,1 point,Wed Jul 1 12:49:30 2015 UTC,Your problem is O(m) (lenght of the list)
haskell,3bqlis,julesjacobs,3,Wed Jul 1 19:08:30 2015 UTC,"I second this, radix sort seems easily doable in O(n) in immutable settings too."
haskell,3bqlis,tsahyt,0,Wed Jul 1 11:54:27 2015 UTC,Any sort of any size in any existing computer is O(1).
haskell,3bqlis,utdemir,1 point,Wed Jul 1 22:33:19 2015 UTC,?
haskell,3bqlis,utdemir,2,Fri Jul 3 03:19:06 2015 UTC,"Find the largest size of the memory of any existing computer.  Find the slowest processor in any existing computer.  Calculate the longest time a sort would take on a computer with this memory size and processor speed.  This is a constant.  All sorts on existing computers will take less than this constant.  Therefore all sorts on existing computers are O(1).  The point I'm trying to make is that if you artificially restrict an aspect of the quantity you are measuring with a big-O expression, the big-O expression becomes meaningless."
haskell,3bqlis,tailbalance,3,Fri Jul 3 05:05:41 2015 UTC,"Just to clarify when you say O(n), do you mean n as "", you're given an integer n and an array (or list) of integers less than n"" or the length of the array (list) (which we should call m) ?"
haskell,3bqlis,julesjacobs,2,Wed Jul 1 13:54:25 2015 UTC,"Yeah, sorry, O(m)."
haskell,3bqlis,julesjacobs,2,Wed Jul 1 13:59:24 2015 UTC,"I don't have time to look at it, but you should be able to use this approach to do everything in one pass, sans the sort."
haskell,3bqlis,WarDaft,1 point,Wed Jul 1 13:04:02 2015 UTC,"I didn't read the blog, I only ask your question, and you didn't put a O(n) restriction, did you?"
haskell,3bqlis,maxigit,2,Wed Jul 1 11:31:44 2015 UTC,"But it would be interesting to have a solution that matched the imperative version in complexity while being pure ""in spirit"", not just ""in letter"". Does such a solution exist?"
haskell,3bqlis,WarDaft,1 point,Wed Jul 1 11:32:50 2015 UTC,OP asked whether an O(n) solution is possible. This doesn't seem relevant to that.
haskell,3bqlis,maxigit,1 point,Wed Jul 1 11:24:57 2015 UTC,"In my opinion this is the best solution in this thread.  I'm okay with trading O(n) for O(n * log(n)) for anything I'd write in Haskell, and this is by far the most declarative solution in the thread.  Almost perfectly captures what a histogram is, as opposed to what procedure to use to calculate it."
haskell,3bqlis,WarDaft,11,Thu Jul 2 17:14:38 2015 UTC,"Does such a solution exist?   Unfortunately, no, there is no solution which will satisfy you. But be warned: you're not going to like my explanation of why that is the case.  There are pure implementations which match the complexity of the imperative implementation. But there are no solutions which satisfy those criteria and which in addition will satisfy you. Proof: we already gave you great answers which received many upvotes, but you claimed they were not ""in the spirit"" of your question. I can only conclude that the question you are asking is not the same as the one we are answering, that there are some extra requirements hidden in the phrase ""pure in spirit, not just in letter"" which do not match the interpretation of ""pure in spirit"" which everybody else  here (the commenters and the upvoters) have.  In particular, you say that the simplest implementation would probably use ""a functional array with logarithmic update time"". What kind of functional array are you thinking about? Some funky ""fibonacci tree"" or similar structure offering logarithmic insertions and updates? I wouldn't call that a functional array, but a functional sequence. Data.Sequence.index and Data.Sequence.update are both logarithmic time.  A functional array, in my opinion, would be an immutable data structure offering O(1) insertions but O(n) updates, due to the fact that the entire array has to be copied. Data.Vector.(!) is O(1) and Data.Vector.(//) is O(n). I believe that also applies to Data.Array, the de facto definition of ""functional array"", even though the documentation doesn't specify any complexity bounds.  Note how the second argument of (//) is a list of (index, value) pairs, not a single pair. That's because updating the elements of an array one at a time, at a cost of O(n) each time, would be hopelessly inefficient, which is why the API is encouraging batched updates. This way performing n updates in one batch is a single O(n) operation, the same cost as n consecutive O(1) updates in an imperative language.  At this point, I'm sure you're preparing to say: ""aha! This batched update is implemented imperatively, and hence this answer does not satisfy the spirit of the question"". I disagree: mutable arrays are imperative, and immutable arrays are pure, whether they implement batched updates and accumArray-style updates or not. Proof: many imperative languages offer immutable strings, but how many offer immutable arrays?  All this to say, if you want to disallow functional arrays, you should ask something more specific than ""pure in spirit"". Here's a question which I think you might be trying to ask: is it possible to implement an efficient version of histogram in a language in which every structure allocated has a fixed size determined at compile time? For example, a cons has size 2, a data structure with k fields has size k, and so does a function which has access to k variables, but you can't allocate or access a structure of size n for a n which is obtained at runtime. I think the answer to that question is no, but finding an impossibility proof will require a bit of work."
haskell,3bqlis,fridofrido,5,Wed Jul 1 19:16:57 2015 UTC,"""Pure in spirit"" = uses no mutation anywhere, except the limited mutation provided by laziness and thunks.  It looks like the problem is indeed open."
haskell,3bqlis,j0sejuan,3,Wed Jul 1 19:20:56 2015 UTC,"So the following implementation of a different problem would have satisfied your criterion even though it batch-updates the elements of an array?  import Data.Array  -- | O(length xs). -- Returns the elements of xs in sorted order, discarding duplicates. -- The elements must be in the range [1..length xs]. --  -- >>> sortUniq (listArray (1, 4) [3,1,4,1]) -- [1,3,4] sortUniq :: Array Int Int -> [Int] sortUniq xs = [i | i <- range (bounds xs)                  , bitfield ! i                  ]   where     -- True if the key is present in xs.     bitfield :: Array Int Bool     bitfield = listArray (bounds xs) (repeat False)             // [(i, True) | i <- elems xs]"
haskell,3brio7,evohunz,6,Wed Jul 1 15:51:37 2015 UTC,"I symphatize with this, because for some some expressions like  sorted list   it happens that English and Haskell are indistinguishable.  You are also right about the nature of function names, this is why the often cited essay ""Execution in the Kingdom of Nouns"" is mistaken when it  describes Haskell as a land of verbs. No! (pure) Haskell expressions do nothing, they just describe what is!  (Now this reminds me on that old joke: The lesser known programming languages - SARTRE. SARTRE programs do nothing they just are. ....)"
haskell,3brio7,voxfrege,4,Wed Jul 1 17:43:27 2015 UTC,"Haskell expressions do nothing, they just describe what is!   One day, a Zen master met two men arguing over a computer program. One said ""the nouns do!"" The other replied: ""the verbs do!"" The Zen master shook his head and said: ""the mind does""."
haskell,3brio7,ForTheFunctionGod,1 point,Thu Jul 2 17:58:27 2015 UTC,God created the typing judgment. Evaluation is the work of man.
haskell,3brio7,tactics,6,Fri Jul 3 04:34:02 2015 UTC,"That's a good point, however you can think of ""call-by-need"" an implementation details. When you write on a paper (whilst doing math homework) f(x) = x+1, do you care about strict/lazzy etc ?  I think that verb/adjective is just a question of point of view, and both are fine :  people just usually use the shortest one.  Some mutable language (e.g python) make a distinction between sort and sorted, one sorting in place and the other returning a sorted version. In haskell we don't have this problem so we can use whatever we want."
haskell,3brio7,maxigit,3,Wed Jul 1 16:58:35 2015 UTC,"I get your point, but math usually limits itself in ""naming"" functions. For example, how do you read f(x) = x+1? I read it like ""F of X is equal to X plus 1"", so: map f xs = ... translates to ""MAP of F and XS is equal to ..."" while xs 'mappedBy' f translates to ""XS MAPPED BY F is equal to ..."". It just seems more natural to spell it.  Call-by-need is an implementation detail, but you code thinking about it, the definition of map in Haskell depends on call-by-need. Otherwise we would (probably) write map in a different way."
haskell,3brio7,epicepee,2,Wed Jul 1 18:10:12 2015 UTC,"Good point. I think the idea is that you take something and you transform it using functions.  The functions are named after what they do, not what comes out."
haskell,3brio7,cies010,2,Wed Jul 1 16:08:50 2015 UTC,"Some functions are named after what they do (e.g. map) and others after what comes out (e.g. length). There is no naming standard in the ""standard"" Haskell libraries."
haskell,3br87g,socratesthefoolish,2,Wed Jul 1 14:31:02 2015 UTC,"I found Chris Doner  has 2 interesting repos on this topic. His own dotemacs (which uses ide-backed), and a more generic dotemacs (which last time I checked does not use ide-backen).  I also like Spacemacs as an alternative to EmacsPrelude."
haskell,3br87g,cies010,1 point,Thu Jul 2 19:15:19 2015 UTC,Sorry for no links. On the phone.
haskell,3br87g,cies010,1 point,Thu Jul 2 19:15:52 2015 UTC,"Check out Emacs Prelude (https://github.com/bbatsov/prelude). The defaults for haskell seem fair to me. Plus, it is easier to setup from scratch than the link you mentioned. You can also take a look at Bodil's emac.d (https://github.com/bodil/emacs.d)."
haskell,3br87g,bb6xt,1 point,Thu Jul 2 00:31:38 2015 UTC,Thanks for the bug report. I've put it in github issues list on your behalf:  https://github.com/haskell/haskell-mode/issues/745  You may follow the progress on fixing this issue using the link above.
haskell,3br18r,lleksah15,5,Wed Jul 1 13:28:58 2015 UTC,"There's an issue (solved in HEAD) with the priority of failure statuses in servant, which has been discussed in [1] (the discussion might be helpful more generally too). In particular, you can get a 401/403 when you'd expect a 405 or 404, which is why we ourselves don't yet have authorization and authentication combinators in the released version. This is avoidable through a disciplined organization of the routes in the types, but of course that's not an ideal experience for library users.  That aside (i.e., if you're willing to stick to the route-ordering discipline, or don't care about the errors, or are willing to wait a bit for the next release), it's not too complicated. In essence, just declare a new datatype data MyData, and a HasServer instance for it like so:  instance (FromText b, HasServer a) => HasServer (MyData b :> a) where     route _ action request respond = case processedPathInfo request of       (first : rest) -> case fromText first of         Nothing -> respond $ failWith NotFound         Just v  -> do            allowed <- isAllowed v request           case allowed of             (Failed, _) -> respond $ succeedWith err401             (_, Failed) -> respond $ suceedWith myErr             _ -> route (Proxy :: Proxy a) (subserver v) request{                      pathInfo = rest                    } respond       _ -> respond $ failWith NotFound   Where isAllowed can look at the request header, and the deserialized capture, and decide what to do.  It's worth looking at the implementation of HasServer for Capture and Header, as well as the link below.   [1] https://github.com/haskell-servant/servant/issues/70   EDIT: I haven't actually tried compiling or testing any of this - it's just a sketch of how one might do things."
haskell,3br18r,jkarni,4,Wed Jul 1 15:27:57 2015 UTC,"Thank you, /u/jkarni.   I am new to Haskell, not even a professional developer and thanks to servant, I have been able to build core aspects of the API quickly. Thank you to the servant team.   The BasicAuth feature discussed in that issue will be very helpful and I can wait for the next release. It will be super, super helpful, if you could add some documentation a la the ones you guys have now, that shows a very simple Authentication / Authorization use case so I can learn from your example and adapt.   In the meantime, I will review the HasServer, etc."
haskell,3br18r,ephrion,3,Wed Jul 1 19:40:50 2015 UTC,"There's a Ruby library for authorization that I really like called pundit. I've been thinking about how to port it over, and I think type classes might be able to cover it, though I haven't played with the ideas as much as I want to."
haskell,3br18r,AlpMestan,7,Wed Jul 1 16:13:43 2015 UTC,"We're currently trying to design a generic interface for auth, in order to provide it out of the box in the next release of servant. If you feel like describing what you like about pundit here along maybe with your ideas for implementing that, that would be very appreciated!"
haskell,3br18r,ephrion,2,Wed Jul 1 16:17:20 2015 UTC,Sure thing! I'll try to get a basic implementation together and write up my thoughts.
haskell,3bpvcw,cdep_illabout,4,Wed Jul 1 04:47:05 2015 UTC,Can you make sure that the framework cabal generates is not restricted with respect to copyright? I feel uncomfortable potentially creating a derivative work of your copyrighted code when running cabal init.
haskell,3bpvcw,FUZxxl,3,Wed Jul 1 10:00:02 2015 UTC,"The only thing that has changed is the creation of the Main.hs file:  module Main where  main :: IO () main = putStrLn ""Hello, Haskell!""   Are you saying that you're worried that the above code would be considered my copyrighted code?"
haskell,3bpvcw,FUZxxl,7,Wed Jul 1 10:20:23 2015 UTC,"Yes. This may seem overly pedantic, but we are talking about potential legal issues here."
haskell,3bpvcw,hagda,4,Wed Jul 1 10:23:05 2015 UTC,"afaik, there's a threshold of originality for a work to be copyrightable in the first place..."
haskell,3bpvcw,FUZxxl,2,Wed Jul 1 21:40:34 2015 UTC,"I definitely understand your concern.  It makes sense to be pedantic about legal issues.  I always assumed that the copyright would be handled the same way that, for instance, the copyright over Setup.hs (which also gets created by cabal) is handled.  Is there some reason why you would be concerned about the Main.hs file but not the Setup.hs file?  How do you think I should go about handling this?"
haskell,3bnpa7,MaxGabriel,16,Tue Jun 30 18:05:14 2015 UTC,"This is a really nice effort! The first part -- showing where the error occurred -- is addressed quite nicely with editor-integrated tooling, but I'd love to see some effort at error-directed hints in GHC. They can serve as a TL;DR + most likely fix that one could quickly glance at before perusing the gory details of just how wrong your code is. The vast majority of my debugging is guided entirely by red squiggly lines, but sometimes I do need to read an error message. In those cases, I often read the first two lines and then the last line of GHC's type error messages, for example, and it feels a bit unfriendly."
haskell,3bnpa7,acow,18,Tue Jun 30 20:32:08 2015 UTC,"Yeah, squiggly lines and colours and showing the code you wrote is all redundant when your editor just shows you the code in question.   Having the compiler actually output semantic structured error types in JSON or whatever is ideal. There is an unfortunate architectural state of affairs in GHC that messages are not all in a sum type and instead every error is a nonce error constructed stringly in place (and apparently SPJ does not want to fix this), making any kind of meaningful interpretation of the messages be reduced to fickle regex matching in IDE/teaching systems."
haskell,3bnpa7,chrisdoner,30,Tue Jun 30 21:21:20 2015 UTC,"SPJ here.  Yes, I would love to improve GHC's error messages. There is no single aspect of GHC that consumes more of my time, and the result is still not great.  (Although it's a complicated problem.)   It's wide open for people to help.  The ""not want to fix"" though probably emerges from this thought.  Building error messages from strings (or in GHC's case SDocs) is pretty lame because you can write them but not analyse them.  The ""obvious"" alternative is to use a huge algebraic data type with one constructor for each error message that GHC can produce. Then you generate the constructor in one place, and render it into a string somewhere else, perhaps in more than one way.  I am not optimistic about this, because it puts a big central road-block in the way of generating error messages, and splits the work into two different places (the renderer and the generator). That's an advantage in some ways, but there are so darn MANY different error messages that it feels far too centralised and brittle to me.  Idris does something in the middle.  As I understand David Cristiansen, they have an abstract type a bit like SDoc, but it is much richer than GHC's SDoc. They can certainly do colour (and SDocs should too).  And you can attach auxilary info to the SDoc so that when rendered in a web browser you get popup hints.   This would all be very feasible in GHC, if someone did the work.  Another big issue is having enough information to hand when you are generating the message in the first place.  Attaching provenance information to type constraints is a huge help (as the Elm article suggests) which GHC does, but not well enough.  For example Lennart Augustsson gave a talk at the Haskell Implementors workshop last year with some simple suggestions that work really well in his Mu compiler.   Jurriaan Hage and his colleages at Utrecht have a lot of experience of this kind of thing with Helium.  GHC is better placed to do this now than it has ever been before, because the type inference engine is increasingly based on solving constraints.  Almost all type errors are generated in a single module, TcErrors, if you are interested to look there.  I'm keen to make sure that running GHC in batch mode sending output to a text file or dumb terminal gives something useful.  I don't want to require a snazzy IDE or emacs mode. But I'd love to be able to exploit one if it was available.  So it's all wide open.  Do join in.  Start a wiki page on GHC's Trac and debate designs.  There is plenty of room for improvement.  You could do anything from improving SDoc, to better provenance info on constraints, to delivering on ""I’d wager small improvements to the user output strings would increase readability by a great margin"".  Thanks!"
haskell,3bnpa7,simonpj0,7,Wed Jul 1 11:35:22 2015 UTC,"For what it's worth, I was thinking about this earlier today and together with @edsko came up with what seems like a reasonably painless way of incorporating Idris-style metadata into the SDoc we have today. There is a mini-proposal on #8809. It's a small first step, but it at least sounds like the impact wouldn't be too terrible."
haskell,3bnpa7,bgamari,2,Wed Jul 1 17:02:22 2015 UTC,"Interesting solution!  I tried to add annotations last year, after ICFP, but unfortunately got mired in the pretty printing code..  I was attempting to wrap subtrees of SDoc in annotations, which is what David's solution for Idris does.  Your approach adds annotations at points, avoiding overhauling the impenetrable pretty printer code.  To regain interval annotation, I suppose it ought to be easy to have something like   data IntervalAnn a   = BeginIntervalAnn Int a   | EndIntervalAnn Int   Then, we'd need a supply of unique integers, and now we can annotate intervals within the doc.  Personally, I'd prefer if the annotation constructor annotated a subtree, as it seems strange to assign semantic meaning to a point within the doc.  But I have been down that implementation path, and it's surprisingly difficult.  So, if this is the approach that lets us easily get annotations in GHC, I'm all for it!"
haskell,3bnpa7,mgsloan,3,Thu Jul 2 04:45:45 2015 UTC,"If you have any thoughts from your own experiences playing around with pretty-printer annotations I think it would be quite useful if we could collect them on the ticket.  Indeed I have also found that wiring the annotations through the pretty-printer is a bit tricky. I have written a bit about the problem on the ticket. Perhaps you have some insight.  About the points versus intervals issue: I'm actually not sure whether annotations on intervals are necessary. My thought was that instead of the annotations describing elements of the document, the annotations are the document: A semantically meaningful atom should be encoded as a proper value, not a pretty-printer document. So long as we provide an easy way to flatten down the annotated Doc into ""normal"" Doc I don't think this will be any less convenient to use than what we have now. In fact, in my experience most of the work is just finding references to ppr and replacing them with a function lifting the value being printing into the Doc's annotation."
haskell,3bnpa7,bgamari,3,Fri Jul 3 10:04:44 2015 UTC,"In Idris, annotating regions has been quite useful. This is because we want to present the same semantic value in different ways, depending on the context. For example, we have pretty-printer options that describe whether to show the hidden arguments in terms, or whether names should be displayed fully-qualified. It's the same name either way, or the same term, so it gets the same annotation. It also lets us use annotations for things like text formatting when displaying docstrings, and it lets us nest the annotations.  Really, though, this is a question of where the rendering work for semantic objects should be done: at the site where the rest of the document is rendered, or by the client part of GHC who wishes to display it. Presumably, once it gets out of GHC, you still want to send annotated sub-regions of text to clients outside the compiler, such as semantic colors on the terminal, popups with documentation highlights in Emacs, etc, without the Emacs mode implementer needing to re-implement the rendering code for terms and source positions.  I'm happy to see these things happening in GHC! It's been a really pleasant thing to have in Idris, in any case."
haskell,3bnpa7,davidchristiansen,1 point,Fri Jul 3 19:07:59 2015 UTC,"I see that annotating intervals carries some value, but I wonder whether you can recover much of this value with annotating on points. For instance, in my mini-proposal a Doc annotated with Types would look something like,  ty1, ty2 :: Type  msg :: Doc Type msg = text ""Failed to unify""<+>pure ty1<+>""with""<+>pure ty2   This is, of course, a simplified example; in the compiler you'd want to embed more than just Types. You'd likely want to lift Type into an ADT which can encode the various atoms that you might want in an error message; in the type checker these might include types, expression, instance lookup results, names, etc. Alongside these values this type also include hints to the client describing how to best format the value (e.g. whether to fully qualify a name for clarity).   Once you have constructed such an annotated Doc, you may want to flatten out annotations into something printable. Given prettyType :: Doc Type -> Doc VoidI envision this looking something like msg >>= prettyType where Doc's bind has subtree replacement semantics (e.g. take a pure node, feed the value through the function to yield a new Doc which will replace the old node).  Alternatively, GHC API users might decide to simply work with the annotated Doc, rendering the text elements with inline rich elements in place of the effect nodes. Ideally the GHC API would expose just enough of its internal formatting functionality to allow clients to do this without reimplementing most of the logic for rendering Doc. I'm not sure I see how annotating regions of a Doc would improve code-reuse over annotating points."
haskell,3bnpa7,bgamari,1 point,Sat Jul 4 07:26:18 2015 UTC,"Sorry if I wasn't clear enough - I suspect that point annotations and region annotations can express the same things, as it's a matter of moving the rendering work from one part of the code to another. The specifics of which to pick probably depend on the overall architecture of the system more than any inherent superiority.  The code re-use that I was referring to occurs in clients of the document, rather than in the compiler. For example, idris-mode for Emacs has code that determines how to highlight a region of the output that is marked as a function name (make it green, give it a tooltip with a docstring, make the right-click menu include commands like documentation lookup, etc). When I implemented highlighting of source code in addition to compiler output, I was able to re-use the annotation logic in idris-mode's elisp.  In any case, having semantics attached to pretty printer ocuments has proven to be highly useful in Idris, and making the annotations available out of band to editor clients has let us get a nice rich experience with very little work."
haskell,3bnpa7,davidchristiansen,3,Sun Jul 5 20:13:56 2015 UTC,"Did you see that Trevor Elliott implemented annotated regions for the pretty library? I heard talk that it could make its way into GHC to replace the built-in pretty-printer, as they have quite similar APIs. So it could be that the work has been done."
haskell,3bnpa7,davidchristiansen,1 point,Fri Jul 3 19:09:17 2015 UTC,"I hadn't seen that, that's pretty awesome!  I think a route like this is ideal, because GHC's pretty printing code is fairly old."
haskell,3bnpa7,mgsloan,2,Tue Jul 7 21:27:25 2015 UTC,"I looked at TcErrorsearlier. What kind of info is present in the Ct data type? The only information I could find said that it was purely information about type classes, not inference errors or the like."
haskell,3bnpa7,beerdude26,9,Wed Jul 1 14:49:43 2015 UTC,Why does SPJ not want to fix it?
haskell,3bnpa7,Tekmo,13,Tue Jun 30 21:37:25 2015 UTC,"I think he means SPJ does not personally want to do all that work himself.   The impression I get from SPJ on the mailing lists is that he would also love to see better error messages from GHC, but someone needs to take on that monumental task."
haskell,3bnpa7,joehillen,11,Tue Jun 30 21:47:53 2015 UTC,Is there a ticket associated with this so that interested people can share notes on what changes would need to be made?
haskell,3bnpa7,Tekmo,10,Tue Jun 30 22:28:40 2015 UTC,I have seen these:    https://ghc.haskell.org/trac/ghc/ticket/8809 (I'm really annoyed by goldfire's push back) https://ghc.haskell.org/trac/ghc/ticket/9173   But some interested party should bring this blog post up on the GHC mailing list. I want to see what the core devs have to say.
haskell,3bnpa7,joehillen,12,Tue Jun 30 22:45:44 2015 UTC,"This is goldfire (a.k.a. Richard Eisenberg) reporting in. I'm very sorry my comment on #8809 has offended. As some people have commented here, my intent was to break down an enormous, ill-specified problem (""GHC's error messages are worse than clang's"") into small(er), well-specified chunks.  At the same time, I wanted to inject some gray into what could easily be a black-and-white conversation. That is, it's easy to jump onto a train toward an imaginary place called ""better"" without really considering what you're leaving behind. My bullet points toward the bottom of that post are some reflections on what we might be leaving behind if we went ahead with the OP's general idea. They are not intended to be an argument against travel!  If anything, my intent was to understand the OP's ideas better, and I remember being disappointed that my comment didn't get a follow-up. Another goal of my post was to make the problems smaller, thus making them amenable to volunteer work. The post should have included more wording encouraging those volunteers, and I do see how the whole thing can be viewed as negative.  Once again, I'm very sorry if I've been discouraging -- it was certainly not my intent."
haskell,3bnpa7,goldfirere,4,Wed Jul 1 15:28:30 2015 UTC,"Thank you for chiming in, and I'm sorry I was so hard on your response here. You're a central figure in GHC development, so a thumbs down from you is a big deal, while a pat on the back is a powerful bit of encouragement for anyone who wants to contribute. While I appreciate your desire to inject some gray, I submit that setting things out as check boxes, say, rather than ""reasons against"" would be a much less discouraging way to indicate that there are issues to work through.   Vibrant open source projects are in large part vibrant because the core team is committed to metaphorically high-fiving every passer by so that everyone feels valued. That kind of thing isn't a big part of the GHC culture, but inadvertently pushing people away doesn't help with the lack of manpower problem."
haskell,3bnpa7,acow,3,Wed Jul 1 20:18:00 2015 UTC,"And also this one: https://ghc.haskell.org/trac/ghc/ticket/7870  Which points IMHO to the central problem. Not a problem of mere prettiness, but a problem of concept. I´m very happy knowing now that SPJ is working to solve the problem with the Helium team"
haskell,3bnpa7,agocorona,5,Wed Jul 1 14:09:10 2015 UTC,"The problem is that the concerns are so vague that they can not be won over by argumentation. Might there be a terminal output problem? Possibly, but the thing to do is to say, ""This is great, but we should beware of potential problems with terminal output as we go forward."" Instead, it's written here as an argument for not doing the work.  Clang is widely credited with bringing on improved error reporting around the compiler world (eg in gcc), but the top two objections are based on terminal output and emacs integration. Both issues that clang has had to overcome.   If you genuinely don't find the GHC error messages worse, that is of course a totally valid opinion. But if it turns out that most people find GHC's error messages to be lacking, then we should encourage folks to have a go at improving them without having to worry that their work will be rejected on principle rather than evidence or democracy.  Finally, goldfire was able to infer four distinct areas of improvement from the example, so I do not think the objection was entirely a lack of specifics. If so, a more constructive response would be to encourage that specificity rather than end the discussion with so many words spent on how things might not work out."
haskell,3bnpa7,acow,3,Wed Jul 1 02:05:00 2015 UTC,"At worst, the comments are a slightly pessimistic and asking that the problem be clarified and iterated on incrementally, which never happened. I actually don't think the comment is unreasonable. The real issue looks like a lack of volunteers to do the work on the problem."
haskell,3bnpa7,creichert,4,Wed Jul 1 04:58:34 2015 UTC,"It's far from terrible, but how can you read the first and last sentences without coming away with a negative feeling on this effort moving forward? I had never encountered anyone who didn't immediately appreciate clang's error messages until seeing this ticket tonight, so I can sympathize with why the proposer was put off.  As I already harped on, so much is said about what are irrelevancies at this point in the discussion. When all is said and done, most of the words on the entire ticket are now spent making weak arguments for not making these changes. It's like burying a lawyer with paper work to win a court case.  Perhaps it wasn't an unreasonable comment, but if I'm cruising around looking to work on GHC, I'm probably not going to dive into something so weighed down by negativity. And if that negativity is focused on things like editor support, I'd figure this really isn't going to move at all. You can't tell potential volunteers who were put off by a comment that the real problem was a lack of volunteers."
haskell,3bnpa7,acow,3,Wed Jul 1 05:50:53 2015 UTC,"Well, first, it's good to have charitable voices like yours. I think the cynicism that's rubbing you the wrong way is due to a lot of smaller things that amount to people feeling boxed out. A list of slights would be long and rambling, but it amounts to a perception that changes aren't welcomed by some kind of inner circle (to give one egregious example, a pull request for markdown readme support on hackage languished for many months with no feedback). Given that this perception exists, if you believe it to be the result of misunderstanding, then being more encouraging of contributions is really important.  How is a fear of emacs tooling not yet being ready useful input to a proposed compiler change? It's a minor thing in isolation, but it's how the perception forms that change is not welcome."
haskell,3bnpa7,acow,-6,Wed Jul 1 06:17:46 2015 UTC,I was waiting for this response.  Comments like his are how things never get fixed.
haskell,3bnpa7,joehillen,9,Wed Jul 1 05:06:19 2015 UTC,I don't understand how this comment is preventing any code from being written. It looks like there is just a lack of volunteers to work on the proposal.
haskell,3bnpa7,creichert,1 point,Wed Jul 1 05:15:46 2015 UTC,"I, for one, don't want to volunteer when a proposal for an improvement immediately gets derailed by negative, irrelevant, and minor issues like in goldfire's comment.   He might have thought it was helpful, but I read it as defeatist.   The core team should point to solutions and not just point out problems."
haskell,3bnpa7,joehillen,-6,Wed Jul 1 02:35:51 2015 UTC,Calm down.
haskell,3bnpa7,joehillen,2,Wed Jul 1 05:26:02 2015 UTC,"That is a shame. If you (or anyone else) are feeling extremely generous, you could look into just making some of these changes without waiting for approval. You will get pushback on a lack of pre-existing editor support from various people; I do not know why this is a thing in the community, but it is (from goldfire here, and I've seen it from hvr, too).  The downside is that the patch might not be accepted. I don't know how this process can be unclogged, but I would love to see some actual efforts -- even experiments that could prove to be unsuccessful -- at improving this rather than hand wringing about whether emacs tooling can be adapted."
haskell,3bnpa7,acow,8,Wed Jul 1 20:23:20 2015 UTC,"I'm honestly seeing far more negativity from you right now than goldfire on that thread, and anyone reading your account of things would be more discouraged than someone just reading GHC tickets for themselves."
haskell,3bnpa7,sclv,5,Wed Jul 1 02:45:11 2015 UTC,"Fair enough. I didn't like the way the original poster gave up on their original point when pressed. When someone says, ""Comments like this are how things never get fixed"" before I said a word, I think you're giving my influence too much credit."
haskell,3bnpa7,acow,5,Wed Jul 1 02:46:24 2015 UTC,"I'm glad you were here to clarify. You covered my thoughts exactly. I didn't expect this thread to blow up, and I didn't feel like having a pointless Internet argument with someone with a name like ""I4dcQsEpLzTHvD1qhlDE"""
haskell,3bnpa7,joehillen,5,Wed Jul 1 04:39:04 2015 UTC,"anyone reading your account of things would be more discouraged than someone just reading GHC tickets for themselves   I don't see how you can extrapolate that. I was discouraged by goldfire's comment when I first read it several months ago, and I've been discouraged by the apparent attitude that nothing can ever be improved because something somewhere might break.  The recent import syntax proposal, Native -XCPP proposal, and the records library threads are good examples of this.  I get the impression that too many people are eager to point out problems in order to make themselves feel like they're contributing (too many cooks, so to speak) rather than offer solutions to work towards a common goal."
haskell,3bnpa7,joehillen,3,Wed Jul 1 06:50:06 2015 UTC,"From my discussions with /u/mgsloan, who was working on improving the situation a while ago, due to the maintenance burden of always having to go back to your data type and add a constructor and a printer every time you want to write a message to the user. A price to pay for good engineering IMO."
haskell,3bnpa7,chrisdoner,1 point,Wed Jul 1 06:52:07 2015 UTC,Well that stinks.
haskell,3bnpa7,acow,1 point,Wed Jul 1 20:11:12 2015 UTC,"What's a ""nonce error""? Or is it just an error ""constructed stringly in place""."
haskell,3bnpa7,sambocyn,10,Wed Jul 1 20:32:55 2015 UTC,"""Nonce"" is a relatively uncommon English word meaning ""(of a word or expression) coined for or used on one occasion."" Vaguely synonymous with ""one-off"" or ""ad hoc."""
haskell,3bnpa7,conklech,1 point,Wed Jul 1 08:37:56 2015 UTC,And also colloquially means pedophile
haskell,3bnpa7,NicolasGuacamole,5,Tue Jun 30 21:38:05 2015 UTC,"I've just gone spelunking in GHC to look for its error reporting functionality. It's indeed pretty bad, but definitely nothing that wouldn't be able to be mitigated. (Github Gist file with my findings)"
haskell,3bnpa7,beerdude26,3,Tue Jun 30 21:52:42 2015 UTC,"That is a tremendously valuable contribution to the conversation. I hope you can find a ticket to add that information to, as it is a really useful map. I might be tempted to lump the JSON into MsgDoc, so it'd be MsgDoc = (SDoc, JSON). This might also be an opportunity to start making amends for arguable design by not producing JSON straight away, but having a go at something with a bit more Haskell-visible structure. I think it's interesting how TcLclEnv superficially looks already overburdened, but everything there actually makes good sense. A function that takes that augmented with slightly more structured error messages, would seem to be a really good project.  In any case, thank you for sharing this!"
haskell,3bnpa7,acow,3,Tue Jun 30 22:16:34 2015 UTC,Do you have a good candidate ticket?
haskell,3bnpa7,beerdude26,5,Wed Jul 1 08:36:42 2015 UTC,Probably one of the ones from the thread where I was being pouty. You could try adding the link as a comment to https://ghc.haskell.org/trac/ghc/ticket/8809
haskell,3bnpa7,acow,10,Wed Jul 1 09:43:29 2015 UTC,ghc --report=json    yes please  and it would be nice to export a (Parser JSON) consistent with how the JSON is pretty printed (or whatever format).
haskell,3bnpa7,sambocyn,3,Wed Jul 1 13:46:44 2015 UTC,Oh god yes.   Especially as someone who oncetwice tried to write an ide plugin.
haskell,3bnpa7,Crandom,10,Wed Jul 1 14:50:49 2015 UTC,Really interesting. I agree that GHC error message are sometimes hard to read (and understand).
haskell,3bnpa7,maxigit,8,Wed Jul 1 14:55:13 2015 UTC,"I like this a lot, but I have some gripes.   Generally, I don't want my compiler error messages to be novel-length. Stuff like ""As I infer the types flowing through your program"" is just fluff. I'm never going to read that. Tell me the details or go away. Type mismatch could be greatly improved by tagging which type came from the function's type and which type came from the argument you provided. GHC does this, but it doesn't look like Elm does. I know that all elements of a list should have the same type. I don't need you to justify your type system in the error messages: ""so that we can iterate..."". It's not a blog post or compiler documentation. I just want to know what's wrong with my code. You should probably also print the code syntax highlighted. I find this to be a big improvement also."
haskell,3bnpa7,kamatsu,2,Tue Jun 30 20:39:05 2015 UTC,"Generally, I don't want my compiler error messages to be novel-length. Stuff like ""As I infer the types flowing through your program"" is just fluff. I'm never going to read that. Tell me the details or go away.   This kind of fluff is tremendously helpful for beginners. And the specific structure here makes it easy to gloss over and ignore for a more experienced user.  Now, a huge goal of Elm is to be easy for beginners to use and learn, and this has apparently driven a number of design decisions. Haskell is pretty beginner unfriendly at the moment, and I think that it would be beneficial for language adoption if more effort were made to be beginner-friendly."
haskell,3bnpa7,ephrion,3,Wed Jul 1 21:23:11 2015 UTC,"Where is the evidence that that fluff is helpful for beginners? It's fundamentally useless, information-free verbiage. Even beginners know that a compiler does type checking. ""Type error"" is established terminology. I don't need the life story."
haskell,3bnpa7,kamatsu,5,Tue Jun 30 18:51:07 2015 UTC,"I have to agree; even Jef Raskin states in “The Humane Interface“ something along the lines of “There should be no distinction made between beginner and expert mode.”  Even worse is an “always beginner mode” in my opinion. Minimize noise, maximize signal to noise. And then have a good tutorial explaining it in a beginner-friendly way."
haskell,3bnpa7,Profpatsch_,2,Wed Jul 1 15:41:22 2015 UTC,"I disagree. We should distinguish beginners from early programmers. The first do know about type checking, the others don't.   When I started learning Haskell it took me ages to decipher the error messages. They just didn't tell you what the problem was, just stuff about things not matching where I never told them to match. Additionally ghc constantly told me to add instances to basic data types, as if this was my job.  Messages like ""all things in a list must have the same type"" would have been great at this time.  I agree that the amount of text would be overwhelming in most situations, though. So maybe this is a problem where a compiler flag could help out?"
haskell,3bnpa7,Kaligule,1 point,Wed Jul 1 21:11:55 2015 UTC,"their target is dynamically typed web developers. when learning Haskell, a ""all items in list must share the same to iterate and stuff"" would have been nice. it tutorializes compilation. which helps when you goal is ""get this to build so I can learn how to code"". I mean, if you asked a human ""why"", it's probably what they'd say verbatim.   however, once you get the point, there should be a ""--concise"" flag, because it gets obnoxious."
haskell,3bnpa7,sambocyn,8,Thu Jul 2 02:03:11 2015 UTC,Very interesting. I'd love to see some of this improvements in GHC.  Wonder how it works when RankNTypes and the like come into picture. I've had nightmares with those .... shivers
haskell,3bnpa7,clrnd,3,Thu Jul 2 14:43:25 2015 UTC,This probably is material for a whole dissertation of a real smart person.
haskell,3bnpa7,Profpatsch_,6,Fri Jul 3 05:35:46 2015 UTC,Have you thought about implementing an ide-protocol like Idris does? http://idris.readthedocs.org/en/latest/reference/ide-protocol.html That way all IDEs just have to implement speaking that protocol and we have a central place to improve. I think https://github.com/commercialhaskell/stack-ide is such a thing for Haskell but that doesn't ship with the compiler. I would like such things be shipped out of the box to be easy accessible.
haskell,3bnpa7,alexbiehl,1 point,Fri Jul 3 20:33:06 2015 UTC,This would be awesome
haskell,3bnpa7,Crandom,3,Tue Jun 30 20:05:37 2015 UTC,I really like the example where it gives the error about one element of a list being of the wrong type. I feel like that's a very good example of a place where something like this helps a good deal.
haskell,3bnpa7,andrewthad,7,Wed Jul 1 09:51:41 2015 UTC,"Is it, though?  t.hs:3:20:     Couldn't match expected type ‘[Char]’ with actual type ‘Bool’     In the expression: True     In the expression: [""one"", ""two"", True, ""four""]   is already pretty clear to me – in fact it's more succinct than some of the Elm errors, which is a good thing when I'm trying to get a sense of roughly which things have gone wrong. Even in a tricky situation when we involve type classes:  t.hs:3:20:     No instance for (Num [Char]) arising from the literal ‘3’     In the expression: 3     In the expression: [""one"", ""two"", 3, ""four""]     In an equation for ‘a’: a = [""one"", ""two"", 3, ....]   it reads fairly clearly to me.  Granted, I know that I'm somewhat of an experienced users and these might mean nothing to a beginner, but I think it is worth acknowledging ust that. Sacrificing usability for experienced users to enable beginners to more quickly grok something carries a cost."
haskell,3bnpa7,kqr,2,Wed Jul 1 08:43:33 2015 UTC,"In the first example it tells you kind of what the problem is, but not why this is a problem. Many programming languages would be fine with lists of multiple types. This would be a very helpful information for beginners.  In the second example it gets even worse:   it reads fairly clearly to me.   Yes, If only there wasn't this halfhearted attempt to help the user by stating:   Possible fix: add an instance declaration for (Num [Char])   This is an attempt to provide similar help like discussed in the Blog post. I just points in the wrong direction 95% of the time this error occurs.  Maybe we should think about providing error messages of different detail levels."
haskell,3bnpa7,Kaligule,5,Wed Jul 1 21:34:05 2015 UTC,"We can do a lot on the terminal, but features like “jump to definition” and red squiggles in your actual code are a whole ’nother level of ease of use. Elm 0.15.1 makes some progress on that too!   I don't know whether it's a common knowledge, but I was pleasantly surprised when I found that vim can jump to the line where the error occurred when opened from ghci.  :set editor vim :l file.hs <error message> :e file.hs <jumps to the error line>"
haskell,3bnpa7,Evil_is_live,2,Tue Jun 30 19:05:17 2015 UTC,"I’d wager small improvements to the user output strings would increase readability by a great margin (although GHC does really well compared to e.g. Clojure), albeit probably destroying most of the tooling out there.  A general solution for abstract type-y things though …"
haskell,3bnpa7,Profpatsch_,2,Wed Jul 1 07:45:23 2015 UTC,"What happens when we accept that there is a problem here and try to do better?   While this is very off-topic to Elm, I should note that there was a very exciting recent paper ""Counter-Factual Typing for Debugging Type Errors"" describing machine-learning-based technique that would improve GHC for a better way to identify ""real error locations"", e.g. when you have a type-mismatch, make a better guess of an actual location where bug happened, not where compiler ended up when checking type-matches. Very interesting read!"
haskell,3bnz7a,emarshall85,27,Tue Jun 30 19:13:28 2015 UTC,What happened was that the previous haskell-prime committee effectively quietly shut down a couple of years ago.  We're now in the process of trying to get it restarted -- most likely with Herbert Valerio Riedel at its head.
haskell,3bnz7a,edwardkmett,8,Tue Jun 30 19:42:27 2015 UTC,"Who is the ""we"" there?"
haskell,3bnz7a,acow,22,Tue Jun 30 19:58:44 2015 UTC,"""We"" here is really Simon Peyton Jones. He reached out to the folks from the haskell-prime committee. In the process they reached out to the core libraries committee to see if we'd be willing to help out on the library side of things to help sync things up there, so I'm somewhat in the loop but not driving the process."
haskell,3bnz7a,edwardkmett,7,Tue Jun 30 20:03:45 2015 UTC,"Gotcha. I hope there's some transparency to this process. The intermittent announcements of decisions being made by an undefined group of insiders end up leading to much gnashing of teeth in private, and community fracturing in public. I think it also led to the quiet fizzle of the last committee.  As for how it goes this time, I think most folks agree that SPJ is a great central figure, and I trust you, but this already sounds like it's perpetuating the group of insiders with most of the same faces. From recent evidence, I do not trust this group to act in good faith, or be responsive to the larger community. I understand this is the way things are, but it's disappointing."
haskell,3bnz7a,acow,13,Tue Jun 30 20:21:41 2015 UTC,"""act in good faith"" is probably stronger language than you meant. From a whole host of evidence I don't trust that the prime process will be kickstarted again, given that a few past reboots have failed, due to inertia more than any particular cast of characters.  It's the usual thing with projects based on who is willing to step up to the plate -- plenty of people would like for some modern features to be added to the standard. But standardizing things is a pain, and even proposing extensions that may not be standardized can be a handful as you've seen.  That said, if anyone is going to get things in gear, I think hvr well may, since he seems to have a knack for actually following through on all the troublesome details :-)"
haskell,3bnz7a,sclv,11,Tue Jun 30 22:30:13 2015 UTC,"You're right, it was stronger language than needed, but I don't think the problem is a willingness to step up to the plate. I won't retread all the BBP stuff, but it applies here. You alluded to my recent attempt to improve syntax, during which Herbert introduced to the discussion a statement about how it would break things due to not being compatible with how cabal has always worked, then opened an issue on cabal to make it work that way. Even assuming he meant it with the best of intentions because of his many valuable contributions, it's the kind of debate tactic that utterly breaks the debate. It clears the plate.  You see arguments that adding syntax that accomplishes something we can already do is not worth it put forth by people who immediately turn around and argue for syntax that accomplishes something we can already do. You see people say things like, ""-1000 if the shed is blue, but +1 if it's red."" You see people hypothesize about the impact of a change on newcomers, rather than hear out those who actually work with newcomers, or just acknowledge that we're trading anecdata and nobody's entirely right or wrong.  I know this is just the way people act on the Internet, but these kinds of responses are not just glib, they stifle the possibility of progress by pushing would-be batters off the plate. So I'd really like to see a committee that represents the larger community, and can actually make changes by simply letting folks have their say, and decisively moving forward without being dragged down by those kinds of arguments. I don't want a committee that is out of touch with the larger community, and I don't want a committee that is perpetually hung by a reluctant minority faction.  I want to see people who appreciate the importance of our new build tools (e.g. the (relatively) new blood in the cabal-install team, Halcyon, and stack) and feel the pain of the many paper cuts inflicted by today's GHC given the chance to get the becalmed HMS Haskell moving again!"
haskell,3bnz7a,acow,5,Wed Jul 1 00:12:01 2015 UTC,"You alluded to my recent attempt to improve syntax, during which Herbert introduced to the discussion a statement about how it would break things due to not being compatible with how cabal has always worked, then opened an issue on cabal to make it work that way.   Just to clarify, I never claimed that Cabal already implemented this. In fact, I stated it wasn't implemented yet in my post:    If I understand correctly, the initial proposal was to enable the new syntax by default and it mustn't break any code (full backward-compatible).   That would be a departure from how language extensions were handled in GHC in the past afaik, and if there's no language pragma to toggle this new syntax, Cabal has no way to know that a new language syntax is required and that thereby needs exclude (not implemented yet) the affected package versions from the install-plan configuration space.   Moreover, I repeated this in a subsequent post by linking to the newly created Cabal ticket  And for the record, I was neither for nor against your import-syntax proposal. My interest was solely in keeping up with the tradition to guard syntax extensions to the Haskell Report behind pragmas (there's alot of other syntax extensions that we could enable by default), as otherwise that would, IMHO, thwart the purpose of the other-extensions Cabal field and the language pragma facility introduced in H2010."
haskell,3bnz7a,hvr_,2,Wed Jul 1 06:00:07 2015 UTC,"As I said, you've earned the benefit of the doubt that you had the best of intentions, but I don't know how this isn't a strangely worded comment:   That would be a departure from how language extensions were handled in GHC in the past afaik, and if there's no language pragma to toggle this new syntax, Cabal has no way to know that a new language syntax is required and that thereby needs exclude (not implemented yet) the affected package versions from the install-plan configuration space.   You start off by calling this a departure, and saying how cabal would have no way to know, etc. with a parenthetical that was intended to make the entire paragraph hypothetical? Is that an argument you bring up for every language extension, given that the treatment of this one would be in no way different?  Even after reading your message and my restatement of it, Sven did not believe me when I said cabal did not work like this, nor had it ever. So, best case, this was worded so as to be incredibly misleading."
haskell,3bnz7a,acow,4,Wed Jul 1 06:32:33 2015 UTC,"It sounds like this has just been a misunderstanding. As far as I can see everyone is agreeing that new syntax should have new pragmas.  In another thread acow says:   Cabal should be improved, but if the dozens of extensions we've seen thus far haven't caused widespread havoc, then it seems unlikely that this one would.   I agree. (The ""should be improved"" referring to actually taking extensions into account in dependency planning.)"
haskell,3bnz7a,dcoutts,3,Thu Jul 2 14:20:52 2015 UTC,"Yes, I apologized to Herbert off-list for calling him out here. He, you, Ed, Gershom, Richie, and Austin were all on my list of people I'd call out by name because I'm familiar enough with your contributions to the community that I consider you to fill kind of ownership roles on various areas. I've been told that this came across too strongly here, so I will in the future give only Ed and G a hard time because, frankly, they deserve* it.  The passage you quoted was in the context of predictions of widespread breakage due to a syntax extension, which were in this case being wildly overstated if historical evidence is to be considered. However, setting aside predictions about breakage, inexplicable abuse, concerns about editor support, and a desire of some parties to not change things, the bike shedding was, I think, terminal to the proposal as opinions are very strong (the ""+1 if my way, -1000 if not"" feedback). GHC is what it is; I've learned my lesson. Perhaps these things can better be addressed by external tooling, so I'll try pushing on that end of things.  (* They know any guff I give them comes from a place of genuine care and respect.)"
haskell,3bnz7a,acow,12,Thu Jul 2 15:35:21 2015 UTC,"Fair enough.  Honestly I'd thought it went out to ghc-devs, but apparently it was just sent to the existing haskell-prime committee members to make sure there'd be no hard feelings over rebooting the process and for feedback a few hours ago, so I appear to be guilty of spilling the beans.  The next step, assuming things proceed normally, would be organizing nominations for such a committee publicly.  There's no insider thing going on here beyond someone far better at dealing with public affairs than I am asking ""hey we'd like to reboot your committee, would you mind?"" before making a broader announcement."
haskell,3bnz7a,edwardkmett,8,Tue Jun 30 20:26:43 2015 UTC,"Okay, my indignation is back in the bottle. Will uncork again at a more appropriate time."
haskell,3bnz7a,acow,8,Tue Jun 30 20:33:36 2015 UTC,You should come uncork it (or preferably a more suitable libation) at Hac Boston. ;)
haskell,3bnz7a,edwardkmett,4,Tue Jun 30 21:16:36 2015 UTC,"The dramedy that occurs whenever people try to change things. This is neither the time nor the place for an airing of grievances, and I'd like to give the folks doing this a chance to actually do something before wasting many words on it."
haskell,3bnz7a,acow,3,Tue Jun 30 22:38:41 2015 UTC,"I'm guessing the dramedy referred to was around this.  From where I was sitting it was a really unfortunate communications failure followed by a debate with time pressure and strong opinions on both sides.  There's a lot of other details to how it all played out, but that's the very, very high level simplistic view."
haskell,3bnz7a,dalaing,3,Tue Jun 30 22:55:08 2015 UTC,"The Foldable Traversable Proposal (FTP, aka BBP) that shipped with GHC 7.10.1 is a good example of how heated debates about change can get. You can tour the historical battlefield here on reddit or on the mailing lists. There was even a deleted post. It was pretty intense."
haskell,3bnz7a,acow,4,Tue Jun 30 23:01:15 2015 UTC,"Alright, I yield. I'm not going to get into this here as it's not my place to do so.  I should have kept my thoughts to direct message, but I want to be sure that anyone else who was or is frustrated by the community processes knows that they are not alone in that feeling. Keeping my remarks to a private channel when what I'm against is the amount of private decision making was too much irony for my constitution. I'm sorry if my portmanteau describing heated arguments culminating in a controversial satirical web page offended."
haskell,3bnz7a,acow,1 point,Tue Jun 30 23:24:56 2015 UTC,"There was even a deleted post. It was pretty intense.   A deleted post is intense? Admittedly I don't have context, but in isolation that seems pretty silly."
haskell,3bnz7a,codygman,1 point,Wed Jul 1 00:17:22 2015 UTC,"I think ""it"" here was referring to the debate as a whole. As in, the debate was so intense people deleted posts."
haskell,3bnz7a,acow,1 point,Wed Jul 1 01:28:13 2015 UTC,"Sorry, that was sarcasm. I think these debates should be taken with an unhealthy portion of salt."
haskell,3bnz7a,andrewthad,40,Wed Jul 1 02:02:19 2015 UTC,I think most of us already admit that we're writing GHC. No sense being in denial about it.
haskell,3bnz7a,Tekmo,16,Wed Jul 1 10:06:47 2015 UTC,"I don't think that is a good thing.  Having only one compiler means that we have a single point of failure for the language and no competition to spur improvements.  For example,  in the discussion on error messages the consensus was that GHC's poor design choices were blocking the entire community from exploring better error messages.  Had there been a competing well-maintained compiler implementation we might have had a better chance that at least one implementation could easily implement suggestions and drive the other to improve to do the same."
haskell,3bnz7a,acow,6,Wed Jul 1 10:41:16 2015 UTC,"I agree with you, but any credible alternative to GHC will have to support more than the most commonly cited standard (98). Denying this is arguably worse than yanking the standard forward to reflect how GHC is used today, as any compiler built to the standard will be missing out on huge swathes of the ecosystem, and likely struggle to maintain interest (evidence: there used to be more Haskell compilers in regular use).  Efforts like the haskell-suite were a commendable attempt to save things by teasing apart the core. I still hope this can happen, as the reuse would let new compilers hit the ground running."
haskell,3bnz7a,dllthomas,1 point,Wed Jul 1 13:12:19 2015 UTC,"Having only one compiler means that we have a single point of failure for the language[.]   While I agree with the rest of it, I'm not sure what sort of failure you're envisioning where ""single point of failure"" is really a relevant notion here..."
haskell,3bnz7a,Tekmo,6,Tue Jun 30 19:32:26 2015 UTC,"I mean failure in a very general sense, not in the sense of a program crashing.  I already gave the example of a poor design flaw in GHC."
haskell,3bnz7a,Fkald,1 point,Wed Jul 1 03:14:03 2015 UTC,"But that's not a problem with standardization, that's a problem with there not being any other compiler writers doing enough work (to catch up with GHC) to make a new standard an interesting question.  Even if the Standard mandated a new better error reporting, that wouldn't make GHC magically able to implement it."
haskell,3bnz7a,ephrion,2,Wed Jul 1 05:46:31 2015 UTC,"For instance, in this article, the author writes DSL's for use with persistent and persistent (original discussion here), but to do so required 14 language extensions."
haskell,3bnz7a,ephrion,1 point,Wed Jul 1 04:41:14 2015 UTC,"I've heard talk about Haskell 2017 being the next ""release"", with dependent types built in.  But that's far off."
haskell,3bnz7a,edwardkmett,5,Wed Jul 1 04:45:55 2015 UTC,Source?
haskell,3bnz7a,JonasDuregard,5,Sat Jul 4 19:54:32 2015 UTC,I saw a talk by Richard Eisenberg at Lambdaconf and that's what he said. IIRC he's working on implementing dependent types in Haskell.
haskell,3bnz7a,0v3rk1ll,14,Tue Jun 30 19:16:13 2015 UTC,"He's implementing them in GHC on that sort of timetable as part of his PhD dissertation, but it is unlikely to make it into the language standard any time in the foreseeable future."
haskell,3bnz7a,tomejaguar,5,Tue Jun 30 19:38:07 2015 UTC,"There are some widely used extensions that have been implemented for many years, that are still not in the standard. I doubt full-blown dependenent types will ever be in hte standard."
haskell,3boiif,mstksg,9,Tue Jun 30 21:32:33 2015 UTC,"Admittedly it's just a nice wrapper over forall m. Monad m => ReaderT (a -> m b) m r, but with a special not-always-a-monad-but-don't-tell-anyone ""transformer"" instance over an extra Traversable :)"
haskell,3boiif,simonmic,6,Tue Jun 30 21:33:30 2015 UTC,Cool. How does it compare to wizards ?
haskell,3boiif,codygman,4,Wed Jul 1 00:05:06 2015 UTC,"i think there's some overlap, but this is a lot more lightweight, and uses actual functions instead of typeclass magic and hackery to have different backends :)  instead of making an empty data type and writing a typeclass instance for it and fiddling around, just write your actual backend function :)  prompt is much more lightweight and first-class.  also i think wizard is more intended for user interaction and String -> IO String kind of things, whereas this library is intended for more general prompting, like database queries, state queries, etc.; you could probably make wizard work for the same, but it might not be what it was meant for."
haskell,3boiif,codygman,2,Wed Jul 1 00:52:37 2015 UTC,uses actual functions instead of typeclass magic and hackery to have different backends   Can you go into more detail about how wizards uses typeclass magic and hackery in your opinion? It will help me calibrate my architectural decision making.
haskell,3boiif,codygman,2,Wed Jul 1 10:09:00 2015 UTC,"Just looking into the ""run"" function:  run :: (Functor f, Monad b, Run b f) => Wizard f a -> b (Maybe a)   The backend isn't given by a first class function --- it's actually pulled from a global typeclass dictionary.  b is a type that's an instance, and f is some Functor representing a type-level specification of possible actions.  So to implement your own backend, you'd have to define several instances for several different combinations of b and f, and define a type b that can encode the structure of computation you want...  Compare that to  runPromptM myPrompt $ \str -> do_stuff_with_str"
haskell,3boiif,profunctor,3,Wed Jul 1 11:33:28 2015 UTC,"The typeclass approach has the advantage of guaranteeing that the result is an instance of Run, which could be (haven't checked) equivalent to saying ""this is an instance of functor, monad, etc"" which guarantees many properties. I think that is an advantage of the typeclass approach.  Would you agree or do actual functions have an advantage here I don't see as well?  Have you seen Next Level MTL? I used to think using typeclasses instead of functions was too magic and not worth it until I watched this video.  What are your opinions?"
haskell,3boiif,danharaj,2,Wed Jul 1 18:55:56 2015 UTC,"as far as I can see, Run is just used as a global method dictionary. the result isn't an instance of Run, Run is just used as a bag to throw in the functions you want to use.   I do agree that there are advantages of making things polymorphic over typeclasses, but I don't think this is the case here"
haskell,3boiif,Mob_Of_One,1 point,Wed Jul 1 19:17:47 2015 UTC,Alright thanks. I'll take a deeper look later as well.
haskell,3bqhdk,_skp,6,Wed Jul 1 09:21:56 2015 UTC,Previous instance of this discussion https://www.reddit.com/r/haskell/comments/2ao3ul/cabal_semantic_versioning_and_endless_experimental/
haskell,3bqhdk,chrisdoner,1 point,Wed Jul 1 09:25:14 2015 UTC,"Oh cool, thank you very much for pointing that out! I’ll add a link in my post."
haskell,3bqhdk,mightybyte,6,Wed Jul 1 09:28:20 2015 UTC,"Frankly I like the PVP's supermajor A.  It gives you an extra axis of control.  The major number isn't good enough for this kind of control because you're forced to bump it any time there is a backwards-incompatible change.  The supermajor is a number that maintainers have complete discretionary control over.  Here some possibilities of ways I can think of to use it:   A = 0 represents unstable/experimental/more-prone-to-change for some package-specific definition of what that means New A represents particularly large breaking changes, possibly requiring significantly more work to upgrade to Each A represents some kind of official release with a commitment for longer term support (i.e. continued security and bug fixes, etc)   I'm sure there are other useful schemes."
haskell,3bqhdk,hagda,2,Wed Jul 1 17:47:48 2015 UTC,"Very good point, thank you. What you said should be included in the PVP!"
haskell,3bqhdk,bergmark,2,Wed Jul 1 17:51:50 2015 UTC,which part exactly should be added to the PVP text?
haskell,3bo5vl,edwardkmett,1 point,Tue Jun 30 20:00:45 2015 UTC,Haven't heard anything about Hacphi yet this year. Is Hac Boston a replacement?
haskell,3bo5vl,LukeHoersten,2,Tue Jun 30 20:41:16 2015 UTC,"HacPhi has shifted to much later in the year due to the ""change in management."" The old organizers graduated and Richard Eisenberg, the new organizer, isn't around Philadelphia in the summer. I'd expect it to be around October like last year, but I haven't heard anything official."
haskell,3bnkcw,_skp,3,Tue Jun 30 17:30:11 2015 UTC,you might already have noticed that the major version got incremented. That means there’re compatibility breaking changes.   But this is 0.3; aren't the rules different before 1.0? Hmm! I can't find anything on the subject in the PVP. I had not previously realized that this part of semantic versioning did not carry over to the PVP. I guess I should re-read both documents and make sure I understand the other differences if any.
haskell,3bnkcw,gelisam,3,Tue Jun 30 19:13:14 2015 UTC,"Yeah, I think I mistaken the first number as /supermajor/. In the past it used to be that, but I guess it’s deprecated. I’ll have a talk about that on #haskell. Maybe I should have created 1.0? I never use the /supermajor/ stuff. I guess that nowadays, it stands for major. I’m confused."
haskell,3bnkcw,gelisam,3,Tue Jun 30 21:31:50 2015 UTC,"It's even more confusing because the PVP and semantic versioning don't even refer to the parts of the version number by the same name!  For the version number 1.2.3.4:   the PVP refers to 1.2 as the major version number, the PVP refers to 3 as the minor version number, and the PVP refers to 4 as the patch-level version number   but   semantic versioning refers to 1 as the major version, semantic versioning refers to 2 as the minor version, semantic versioning refers to 3 as the patch version, and semantic versioning doesn't like the 4.   The other difference, the one I was talking about, is that semantic versioning allows arbitrary breaking change between any two pre-1.0 versions. So, to clarify: I wasn't saying that you used the name major instead of supermajor or something like that, I was saying that I was surprised that a bump from 0.2 to 0.3 would mean that there is more compatibility-breaking changes than between 0.2.1 and 0.2.2, because I expected any pre-1.0 change to be allowed to make compatibility-breaking changes. I was mistaken, because the PVP doesn't say anything special about pre-1.0 versions. Which is good, because the Haskell ecosystem has a lot of pre-1.0 libraries!"
haskell,3bnkcw,kuribas,3,Tue Jun 30 22:27:49 2015 UTC,"You'll probably be also interested in my cubicbezier package.  It can approximate any curve with cubic beziers, transform them, evaluate them, find curvature, tangents, find intersections, convert from hobby splines, and  calculate overlapping paths (work in progress)."
haskell,3bnkcw,redxaxder,2,Thu Jul 2 10:56:37 2015 UTC,It looks like you don't allow the user to specify the slopes at the key points. Are they all made zero?
haskell,3bnkcw,redxaxder,2,Tue Jun 30 21:37:31 2015 UTC,"What do you mean the slopes? For Bézier, you can specify the input and output normals – are those the slopes you are talking about? :)"
haskell,3bnwyb,andrewthad,2,Tue Jun 30 18:58:09 2015 UTC,"I think I read /u/chrisdoner say they have plans for Emacs' haskell-mode to support pop-ups with custom syntax for strings/comments/quasiquotes. e.g. This would let you click on the string ""\""quoted\"""", see it as  ""quoted"", then edit it into ""quoted"" ""again"", and get ""\""quoted\"" \""again\"""" inserted back into your source.  of course, you are asking about Vim, and about something existing ;-)"
haskell,3bnwyb,sambocyn,2,Tue Jun 30 22:41:41 2015 UTC,"Yeah, emacs support for Haskell is vastly better than available vim tooling. It's worth learning spacemacs at least, it seems."
haskell,3bnwyb,ephrion,2,Wed Jul 1 04:20:25 2015 UTC,"I really need to invest some time into getting spacemacs running. The project looks pretty cool, and it seems like the best haskell tools are for emacs users."
haskell,3bmd1a,klaxion,4,Tue Jun 30 11:30:44 2015 UTC,"My understanding is that it is still very much a work-in-progress, but that it's currently possible to evaluate some simple expressions involving functions and data constructors. There isn't an FFI to Java yet, that I'm aware of."
haskell,3bmd1a,paf31,0,Tue Jun 30 14:35:32 2015 UTC,I guess he means JavaScript 😜
haskell,3bmd1a,minsheng,2,Wed Jul 1 02:44:01 2015 UTC,"No, Java :) Truffled PureScript is an attempt to use Truffle and Graal to interpret PureScript's functional core on the JVM."
haskell,3bmd1a,paf31,3,Wed Jul 1 04:57:51 2015 UTC,"Purescript does have Ints now; have a look at 0.7.0, released earlier today. There's a purescript reddit too, by the way."
haskell,3bmzn8,Shun_Y,3,Tue Jun 30 15:02:45 2015 UTC,"There are a couple things you can do. I'll go over two since I don't know what approach you're currently taking.  Approach 1: Use a volume mount  (this is an approach for development). In code:   docker run -itv `pwd`:/opt/myapp haskell:7.10 bash cd /opt/myapp cabal sandbox init // develop as normal (inside container)   This approach lets you keep the actual files on your local system while using docker as a development environment. You get the performance and caching of a typical cabal sandbox. (or you could be using stack, etc instead)  Approach 2: Cache the .cabal file (and dependencies) in layers  The basic idea here is that you can use the way docker caches layers to cache the .cabal file and the dependencies installed separately from your application code. Taken from the Dockerfile in this project on github  FROM haskell:7.10  # update package repository RUN apt-get update && \     apt-get install -y libpq-dev RUN cabal update  # Make sure our app directory exists RUN mkdir -p /opt/pulsar  # Set the base directory of the following RUN statements WORKDIR /opt/pulsar  # Make sure log directories exist RUN mkdir -p /var/log/pulsar  # Create Sandbox RUN cabal sandbox init  # Install Dependencies into sandbox. Each command is cached by Docker # so we don't have to reinstall everything unless we make changes to  # our .cabal file. COPY ./pulsar.cabal /opt/pulsar/pulsar.cabal RUN cabal install --only-dependencies -j4 --allow-newer  # Add Application Code COPY ./src /opt/pulsar/src  # Build Application RUN cabal build  # COPY assets and misc files into image COPY ./snaplets /opt/pulsar/snaplets COPY ./static /opt/pulsar/static COPY ./.ghci /opt/pulsar/.ghci  # By default, run our application when running a container based on # this image. Use command line flags to specify log directories. CMD [""/opt/pulsar/dist/build/pulsar/pulsar"",\      ""--access-log"", ""/var/log/pulsar/access.log"",\      ""--error-log"", ""/var/log/pulsar/error.log""]   If you're using a Dockerfile like this one, all you have to run to rebuild your application is docker build -t myapp . and then you can run it as usual with docker run. The only time you will reinstall dependencies is when you edit the .cabal file."
haskell,3bmzn8,biscarch,2,Tue Jun 30 19:00:02 2015 UTC,"Option #1 is the answer. No reason not to use a generic Haskell Docker image for development (or even one with a couple of extra things installed, but which you don't  change over the course of development) and then deploy by building a separate image that copies your executable into haskell-scratch.  All these published images that include compilers kind of irritate me. I know having extra stuff in a container doesn't affect runtime performance, but I do have to wait for it to download every time!  EDIT: one thing that would make the Docker dev process go more smoothly is mounting the Cabal cache so I don't have to run cabal update each time I start up a container."
haskell,3bmzn8,theonlycosmonaut,2,Tue Jun 30 21:37:18 2015 UTC,"Option #1 is the answer. No reason not to use a generic Haskell Docker image for development (or even one with a couple of extra things installed, but which you don't  change over the course of development) and then deploy by building a separate image that copies your executable into haskell-scratch.   That would be an interesting blog post."
haskell,3bmzn8,codygman,2,Tue Jul 7 22:20:53 2015 UTC,Ask and ye shall receive
haskell,3bmzn8,theonlycosmonaut,1 point,Fri Jul 10 03:52:26 2015 UTC,"Thanks! I haven't had time to go over it yet, but I'm looking forward to it."
haskell,3bmzn8,codygman,1 point,Sat Jul 11 08:29:20 2015 UTC,"I guess so; I always assumed this is what everyone did, but apparently not."
haskell,3bmzn8,theonlycosmonaut,1 point,Tue Jul 7 23:05:13 2015 UTC,"First of all, thank you for telling me these approaches in detail kindly :) I'll try Approach  and keep my mind this idea;  ""get the performance and caching of a typical cabal sandbox""."
haskell,3bmzn8,Taladar,2,Wed Jul 1 14:14:36 2015 UTC,What is the reason it can not use the cache? Did you actually change something requiring different dependencies or does it just pick up changes on Hackage you don't particularly care about while you want to avoid rebuilds?
haskell,3bmzn8,vagif,2,Tue Jun 30 15:22:46 2015 UTC,When I reorganize Dockerfile steps or put some steps together Docker don't use the cache because Docker consume container at each steps.  ex)   RUN cabal install alex happy RUN cabal install yesod-bin   ->   RUN cabal install yesod-bin RUN cabal install alex happy   or ->   RUN cabal install alex happy yesod-bin
haskell,3bmzn8,codygman,4,Tue Jun 30 16:29:37 2015 UTC,"Well you answered your own question :) Don't change Dockerfile every time :)  Also docker is NOT for active development, it is for automating deployment.  In other words you develop outside of docker and when you app is tested and ready you package it with docker and deploy to production environment. And in this case you do not need ghc, alex, happy, cabal install, you do not need yesod-bin etc."
haskell,3bmzn8,vagif,2,Tue Jun 30 17:05:47 2015 UTC,"Also docker is NOT for active development, it is for automating deployment.   I don't see any reasons not to use docker for development."
haskell,3bmzn8,codygman,1 point,Tue Jul 7 22:22:31 2015 UTC,"You probably mean for deployment (installation) of complete development environments, nor for development.  The examples are ghcjs + reflex library installations that are too complicated to do manually. So docker image with everything installed and configured is much easier.  But you generally do not need to alter the dockerfile and recreate docker images for your development."
haskell,3bmzn8,Taladar,1 point,Wed Jul 8 00:11:33 2015 UTC,"Yeah, I was talking about the ghcjs/etc type environments for development."
haskell,3bmls4,orbitalfox,3,Tue Jun 30 13:07:26 2015 UTC,Strangely enough I answered almost exactly the same question on Stack Overflow earlier: http://stackoverflow.com/questions/31135606/using-commercialhaskell-stack-with-a-proxy?noredirect=1#comment50286972_31135606
haskell,3bmls4,snoyberg,2,Tue Jun 30 13:46:00 2015 UTC,"Heh, very close in time! The title of the post you answered doesn't help finding it."
haskell,3bmls4,snoyberg,5,Tue Jun 30 15:19:47 2015 UTC,"If you want to track it, here's the issue for adding authenticated proxy support: https://github.com/snoyberg/http-client/issues/129  edit this should now be resolved on master"
haskell,3bj2la,callumrogers,12,Mon Jun 29 17:11:43 2015 UTC,"I've never seen the hackage badge on a readme like that, cute! We should have those for LTS Haskell, too.  [edit] issue created. https://github.com/fpco/stackage-server/issues/109"
haskell,3bj2la,drb226,8,Mon Jun 29 18:38:27 2015 UTC,Take a look at shields.io!
haskell,3bj2la,fridofrido,0,Mon Jun 29 19:00:42 2015 UTC,"What the hell is that? From the home page I cannot even decide whether it is a piece of software or not! Retina-ready, yes, but is it a glass? A logo? A build system? An app? A link aggregator? Seriously, I'm looking at that page for maybe 5 minutes now, and I still have absolutely no idea what it is about!  (the should-not-typecheck library, on the other hand, I think I understand. It's indeed a clever trick, unfortunately there is that limitation paragraph on the bottom.)"
haskell,3bj2la,drb226,3,Thu Jul 2 13:02:21 2015 UTC,"So as I understand it, this also basically tests that an expression contains no bottoms, since it deep forces it. Is that correct?"
haskell,3bj2la,ignorantone,4,Mon Jun 29 18:37:08 2015 UTC,"Yep, an (unfortunate) consequence is that any bottoms (except for those caused by deferred type errors) will be forced and propagated up through shouldNotTypecheck, failing your test. In previous versions, before I started forcing the test expression, I only evaluated to Weak Head Normal Form. Maybe another function (shouldNotTypecheckShallow?) that only evaluates to WHNF would be useful?"
haskell,3bj2la,theonlycosmonaut,3,Mon Jun 29 19:16:57 2015 UTC,Probably.  Criterion provides both nf and whnf: criterion library
haskell,3bj2la,TweetsInCommentsBot,3,Mon Jun 29 19:44:09 2015 UTC,"I asked and now I have received! Great stuff, going to keep this in mind."
haskell,3bj2la,chrisdoner,3,Mon Jun 29 22:31:15 2015 UTC,It's come full circle :p
haskell,3bj2la,jberryman,3,Mon Jun 29 23:19:41 2015 UTC,"@callumorphism   2015-06-21 23:43 UTC  @SamirTalwar Oh, I'm interested in that too. I've seen Haskell peeps hack doctest for this. Relevant reddit thread: https://www.np.reddit.com/r/haskell/comments/2t4q6m/unit_test_that_a_particular_expression_does_not/     This message was created by a bot  [Contact creator][Source code]"
haskell,3bk3k7,AtomicAnto,7,Mon Jun 29 21:37:27 2015 UTC,"So it seems like you can set your GHC startup entry assuming you can start winghci at all?  So I would take a look and maybe try to explicitly set that to the full ghc path?  It seems that the winghci project hasn't been updated since 2010, so I'm not sure how much mileage you'll get out of it? It may be great, but it may also be easier for you to just run ghci directly in a terminal :-)"
haskell,3bk3k7,sclv,2,Mon Jun 29 22:53:24 2015 UTC,I can't help with your current problem but just wanted to reassure you that these setup teething problems are worth it. I had the same trouble getting Haskell set up when I started but I'm so glad I persevered. It's a fantastic language and the most helpful software community I've encountered.
haskell,3bk3k7,created_to_post_this,3,Tue Jun 30 09:44:17 2015 UTC,"Hi, my advice would be to uninstall any Haskell related stuff you have and start using Stack.  Let us know if you have any problems or questions. I'll be watching this pretty closely for the next hour or so."
haskell,3bk3k7,codygman,8,Mon Jun 29 22:19:52 2015 UTC,"You are aware that WinGHCi is a special program to give a GUI to ghci on windows? https://code.google.com/p/winghci/  And that the problem this person has is likely not with the haskell toolchain, but with teaching winghci to find it?  And thus that installing stack as such may or may not have anything to do with their problem?"
haskell,3bk3k7,sclv,10,Mon Jun 29 22:50:06 2015 UTC,"Interesting, I'd never heard of WinGHCi (I've only recently been using Windows for anything). I tested things out, and:   Running WinGHCi.exe without GHC on the PATH resulted in the program freezing Running stack exec winghci.exe fixed it   My guess is that anything which will modify the PATH to include ghc(i).exe will work, but stack exec may be a nice, easy way to do that modification.  EDIT As a bonus, stack --resolver ghc-7.8 exec winghci and stack --resolver ghc-7.10 exec winghci are easy ways to switch between two different GHC versions."
haskell,3bk3k7,snoyberg,3,Tue Jun 30 06:43:45 2015 UTC,"No! My apologies, I'll try to be a bit more thorough next time.  Though I wonder if winghci is installable through stack without issue."
haskell,3bk3k7,codygman,3,Tue Jun 30 03:58:17 2015 UTC,Though I wonder if winghci is installable through stack without issue.   Looks like not as it requires special setup.
haskell,3bk3k7,codygman,3,Tue Jun 30 04:06:13 2015 UTC,I will try that as soon as I arrive home! Thank you!
haskell,3bk3k7,biglambda,2,Mon Jun 29 22:36:24 2015 UTC,Uninstalling it and reinstalling worked fine! thank you!
haskell,3bk3k7,codygman,1 point,Tue Jun 30 21:06:07 2015 UTC,Is stack a replacement for cabal?
haskell,3bk3k7,ForTheFunctionGod,1 point,Sat Jul 4 04:35:21 2015 UTC,"It is a replacement for cabal-install, but still uses the Cabal library. See:  https://www.fpcomplete.com/blog/2015/06/announcing-first-public-beta-stack  https://www.reddit.com/r/haskell/comments/3az605/why_is_stack_not_cabal/"
haskell,3bk3k7,ForTheFunctionGod,1 point,Sat Jul 4 05:17:03 2015 UTC,"Did you install the Haskell platform, or just GHC?"
haskell,3bk3k7,mallai,1 point,Mon Jun 29 22:46:52 2015 UTC,"As far as I remember, both of them"
haskell,3bpbdm,evohunz,10,Wed Jul 1 01:47:53 2015 UTC,Let me repharse the post: Java + Haskell features - Java features = Haskell. Who could have guessed?
haskell,3bpbdm,int_index,10,Wed Jul 1 11:23:02 2015 UTC,Some of those steps are pretty big. https://thoughtstreams.io/site_media/media/document/820ebf45-5783-47f9-a8ac-186464486603.jpg
haskell,3bpbdm,cameleon,3,Wed Jul 1 09:11:09 2015 UTC,The key is using consummate v's
haskell,3bpbdm,bergmark,9,Thu Jul 2 01:44:05 2015 UTC,"Remove type annotations, i.e. ""Foo bar(Foo self)"" turns into ""bar(self)"";   Type inference in the presence of subtyping and overloading is not known to be decidable. http://users.cis.fiu.edu/~smithg/papers/thesis91.pdf   Why this post? Well, I don't know."
haskell,3bpbdm,ForTheFunctionGod,6,Wed Jul 1 08:16:29 2015 UTC,He forgot about purity.
haskell,3bpbdm,joehillen,10,Wed Jul 1 02:49:11 2015 UTC,"This is pretty much a requirement if you have lazy evaluation - and then you need monads. Of course, purity is never going to make it. After all:   This is Haskell. No functors, monads, arrows, categories or lists needed.   A large segment of CS practitioners has a deep-seated aversion towards theoretically optimal solutions. You will see lazy evaluation (i.e. beta reduction), static typing, arbitrary precision arithmetic, buffer-overflow protection, correctness and equivalence-relation-semantics for == get constantly slammed for being too hoity-toity too.  I guess coding to the metal and tightening up the graphics on level 3 are just more important than the hundreds of millions of dollars of damage caused by trivial software faults. Sure, every now and then global IT security gets compromised or some nuclear reactor melts down, but I think we can all agree that it's far more important that c0derDude3187 can write cool pointer-stuff like *bp++ = TLS1_HB_RESPONSE and have ""23;45;80"" == 23 come out as true."
haskell,3bpbdm,ForTheFunctionGod,1 point,Wed Jul 1 08:51:36 2015 UTC,Purity <=> immutability?
haskell,3bpbdm,theonlycosmonaut,2,Wed Jul 1 08:44:43 2015 UTC,"Purity = (1) the output is completely determined by the input parameters and (2) functions have no effects besides computing their output value. userInput :: String would be a constant in Haskell, but with implicit IO, you could write  string userInput() { return readLine(); }   Variable mutation is a problem for the same reason: by reading/writing non-local state, functions influence each other via hidden channels.  (2) is a bit more muddy because some people count non-termination and failure via error as effects too."
haskell,3bpbdm,ForTheFunctionGod,1 point,Wed Jul 1 09:52:50 2015 UTC,"Ah yes, for some reason I ignored effecting code. Purity is only equivalent to immutability when the world isn't ever implicit?  Non-local state isn't allowed in immutability, is it?"
haskell,3bpbdm,theonlycosmonaut,2,Thu Jul 2 11:10:17 2015 UTC,"Purity is only equivalent to immutability when the world isn't ever implicit?   That sounds about right, but I think exceptions are a problem too because they introduce non-deterministic behavior: depending on which sub-expression is evaluated first, different kinds of exceptions may be thrown. IIRC, this is the reason exceptions (of the undefined-kind) can only be caught in the IO-monad, where you accept this sort of random behaviour. It's described in section of Tackling the awkward squad."
haskell,3bpbdm,ForTheFunctionGod,6,Thu Jul 2 17:04:24 2015 UTC,"I think those are big steps, more than just ""some"" steps away. :)"
haskell,3bpbdm,bb010g,5,Wed Jul 1 03:24:16 2015 UTC,"""Haskell, though not perfect, is of a quality that is several orders of magnitude higher than Java, which is a mess (and needed an extensive advertizing campaign and aggressive salesmanship for its commercial acceptance)"" - Edsger Dijkstra"
haskell,3bpbdm,mwscidata,3,Thu Jul 2 21:57:26 2015 UTC,"Where is my first class functions, higher order functions and higher order kinds? What about adt and pattern matching?"
haskell,3bpbdm,gilmi,6,Wed Jul 1 04:08:40 2015 UTC,"Probably in ""Add a lot of features to type system"" (emphasis mine). This kind of means some == a lot."
haskell,3bpbdm,BartAdv,3,Wed Jul 1 04:36:37 2015 UTC,I feel all the commenters in the thread but me failed to pick up the sarcarm. (that or I am seeing things)
haskell,3bpbdm,ekilek22,1 point,Wed Jul 1 15:18:58 2015 UTC,"It probably is but at the same time it's so hard to tell with blogs as they tend to be all over the place, mostly banal or trivial and rarely, but it does happen, insightful."
haskell,3bpbdm,abaquis,2,Wed Jul 1 23:40:56 2015 UTC,"More interesting would be an article investigating having a Haskell compile to JVM or .NET CLR. The real question is what is it about the JVM that makes it hard to have a Haskell - like language. Or has just no one done it yet.   I know there is Scala and Clojure - so we can get close, but they are not Haskell."
haskell,3bpbdm,mcapodici,2,Thu Jul 2 03:04:53 2015 UTC,"Others did try that. It is not easy.  The intention of the post is not to say ""Haskell is just Java with lasers"", is just to invite (stop scaring) new people: ""Haskell is not so different from Java, take a try""."
haskell,3bpbdm,jamlothar,2,Thu Jul 2 11:48:33 2015 UTC,I think there is more difference than syntax and math concepts: there is culture.
haskell,3bjguk,bartavelle,7,Mon Jun 29 18:53:41 2015 UTC,"I've seen the {-# LANGUAGE KitchenSink #-} joke pragma a few times now, and I'm starting to want it to be a real thing. My imagined behaviour is for GHC to (somehowTM ) figure out the language extensions necessary to make my program legal and turn them all on."
haskell,3bjguk,redxaxder,4,Tue Jun 30 14:11:09 2015 UTC,This is great. Have you thought about trying to move the permissions DSL to the type-level?
haskell,3bjguk,jkarni,2,Tue Jun 30 09:59:22 2015 UTC,"That would be awesome, but I don't know how !"
haskell,3bjguk,jkarni,3,Tue Jun 30 10:49:11 2015 UTC,"Something like this? https://gist.github.com/jkarni/948e59d2985d67c36453  There's still a lot of functionality missing, and I'm not sure if it's in the end worthwhile, but it's a thought."
haskell,3bjguk,jkarni,2,Tue Jun 30 11:20:24 2015 UTC,"I don't really see how I can write my rule here. Can you write how the API type would look like for something like that ?  ""something"" :> DN :> Capture ""id"" (MKey Foo) :> ""v"" :> Capture ""id"" (MKey Bar) :> Delete '[JSON] ()   And the where the access rule is :  \kr kv -> rw (FooAccess kr) :&& ro (BarAccess kv)"
haskell,3bjguk,ignorantone,4,Tue Jun 30 11:31:36 2015 UTC,"Right, it gets tricky when ""access captures"" are intertwined with non-access-related path elements (in the specific case of :&& separating them out would work, but for :|| it wouldn't).   I'll have to think some more ;)"
haskell,3bjguk,gclichtenberg,2,Tue Jun 30 11:39:15 2015 UTC,"Great, thank you!"
haskell,3bjguk,ephrion,2,Tue Jun 30 08:51:31 2015 UTC,The actual post is here: https://hbtvl.wordpress.com/2015/06/28/servant-persistent-and-dsls/  The link given in the reddit post is just to the blog front page.
haskell,3bjguk,TumbleSteed,2,Tue Jun 30 16:48:52 2015 UTC,"How did I miss this? Amazing post, thanks for writing it up :D"
haskell,3bjguk,beerdude26,4,Wed Jul 1 15:02:26 2015 UTC,"I am using servant, persistent and lens in this example, so there is quite a bit of boilerplate, as expected.   {-# LANGUAGE ConstraintKinds            #-} {-# LANGUAGE DataKinds                  #-} {-# LANGUAGE DeriveGeneric              #-} {-# LANGUAGE FlexibleContexts           #-} {-# LANGUAGE FlexibleInstances          #-} {-# LANGUAGE GADTs                      #-} {-# LANGUAGE GeneralizedNewtypeDeriving #-} {-# LANGUAGE MultiParamTypeClasses      #-} {-# LANGUAGE OverloadedStrings          #-} {-# LANGUAGE PolyKinds                  #-} {-# LANGUAGE QuasiQuotes                #-} {-# LANGUAGE TemplateHaskell            #-} {-# LANGUAGE TypeFamilies               #-} {-# LANGUAGE TypeOperators              #-}  module Main where  import           Control.Lens import           Control.Monad import           Control.Monad.Error.Class import           Control.Monad.IO.Class import           Control.Monad.Logger import qualified Control.Monad.Operational  as O import           Control.Monad.Operational  hiding (view) import           Control.Monad.Reader       (ask) import           Control.Monad.Trans.Either import           Data.Aeson import           Data.Int import qualified Data.Foldable              as F import           Database.Persist import           Database.Persist.Sql import           Database.Persist.Sqlite import           Database.Persist.TH import           Data.Text.Lens import           Data.Text                  (Text) import qualified Network.Wai.Handler.Warp import           Servant   This should be:  module Main where  import Servant import Persistent import Lens   The fact that Haskell requires this much effort to go from 0 to 1 is a flaw.  EDIT: Sorry to hijack your post."
haskell,3bjguk,TumbleSteed,9,Tue Jun 30 05:50:50 2015 UTC,I disagree. This is 0 to 1:  import Prelude test = map (+1) [1..10]   Writing a web app through servant and persistent and wiring them together with DSLs? That's going from 0 to 300.
haskell,3bjguk,beerdude26,-3,Tue Jun 30 06:46:39 2015 UTC,"Except we haven't written a web app through servant and persistent and wired them together with DSLs. We've done nothing.  EDIT: Of the 34 effective lines of code we've written so far, 0 of them include any application logic. In a perfectly expressive language, we wouldn't have any zero-logic lines of code. As it stands, we've taken almost 10 times as many lines of code as it would have taken to write a ""Hello World"" Sinatra app to express 0% of what our webapp does."
haskell,3bjguk,TumbleSteed,8,Tue Jun 30 07:00:04 2015 UTC,That's some strange logic. So constructing a road is the biggest waste of time imaginable right up until it is completely finished and has vehicles driving on it?
haskell,3bjguk,AlpMestan,-2,Tue Jun 30 08:14:23 2015 UTC,"The reason we use high level programming languages is to help express human ideas to a machine. Languages can and should be judged on their ability to effectively convey those ideas. While different languages/communities may have different ideas of what ""effective"" means, I don't think it's reasonable to call the part of a language that requires 34 lines of code to express the notion, ""I am using these 3 libraries"" effective or expressive."
haskell,3bjguk,TumbleSteed,7,Tue Jun 30 08:30:58 2015 UTC,"To be fair, if you look closely, there's 1 import for servant, 2 for lens and 4 for persistent. The code in the post uses many more libraries, but the focus really is on the 3 mentionned above."
haskell,3bjguk,beerdude26,-3,Tue Jun 30 08:39:03 2015 UTC,"More libraries sure, but most of those aren't there because a choice was made. They're just making up for a crappy base system.  For starters, there are 13 lines of language pragmas which do nothing but add functionality which is missing from the base language.  Then there are the following imports which add missing functionality from the base Prelude:  import           Control.Monad import           Control.Monad.Error.Class import           Control.Monad.IO.Class import qualified Control.Monad.Operational  as O import           Control.Monad.Operational  hiding (view) import           Control.Monad.Reader       (ask) import           Control.Monad.Trans.Either import           Data.Int import qualified Data.Foldable              as F import           Data.Text                  (Text)   Only after we've made it through 13 language pragmas and 10 import statements have we actually started making choices.  I want to use lens (I won't count this as a Prelude weakness, even though it is):  import           Control.Lens import           Data.Text.Lens   I want to use JSON:  import           Data.Aeson   I want a logger:  import           Control.Monad.Logger   I want Sqlite:  import           Database.Persist import           Database.Persist.Sql import           Database.Persist.Sqlite import           Database.Persist.TH   I want a web server:  import qualified Network.Wai.Handler.Warp import           Servant   Assuming loggers and databases should be separated from web servers, and assuming lens shouldn't be part of the Prelude, of 34 lines of code, only 10 of them are useful, and those 10 lines only express 5 ideas.  If you're willing to be more critical, convenience operators like lens should be a part of the Prelude, and the fact that we're reaching for 4 disparate libraries instead of something like Yesod indicates that Yesod isn't doing something right."
haskell,3bjguk,snoyberg,4,Tue Jun 30 09:00:28 2015 UTC,"convenience operators like lens should be a part of the Prelude.   Ah, the PHP approach. Just include everything and the kitchen sink in the base library of the language and when people want other behaviour, just use the mapReal function handily provided by the mapRealFixedlibrary."
haskell,3bjguk,snoyberg,3,Tue Jun 30 10:03:35 2015 UTC,"the fact that we're reaching for 4 disparate libraries instead of something like Yesod indicates that Yesod isn't doing something right.   I don't really want to get involved in this rant, but I'm just too curious...  How did Yesod get involved in this one at all?  And for the record: the Database.Persist and Database.Persist.Sql imports appear to be redundant. The Database.Persist.TH is necessarily separate because some people requested that it work that way, namely people using Persistent on iOS where the cross-compiler couldn't handle Template Haskell.  And since I've already made a longer comment than I thought I would: it sounds like ClassyPrelude.Yesod is the kind of evil you'll love :)"
haskell,3bjguk,TumbleSteed,3,Tue Jun 30 12:36:25 2015 UTC,"How did Yesod get involved in this one at all?   When it's not lens, people seem to like blaming yesod for all that's wrong in the world. I like both myself, so I suppose I am part of the problem :/   And for the record: the Database.Persist and Database.Persist.Sql imports appear to be redundant.   It does indeed build without Database.Persist, will fix the post tonight."
haskell,3bjguk,snoyberg,5,Tue Jun 30 13:07:53 2015 UTC,"I pinged Edward the other day saying we should release ClassyLensyYesodDiagramsPandoc, or some such like that, to just draw everyone's ire all at once.  EDIT s/really/release"
haskell,3bjguk,sambocyn,0,Tue Jun 30 13:47:00 2015 UTC,"Sorry to pull you into this one, even indirectly. The only reason I brought up Yesod is because it's one of the few Haskell web stacks that does most of this shit for you, and the fact that this article exists indicated that OP thought servant was doing something better than it.  I respect flexibility, but not at the cost of expression, and ""serving CRUD sites"" feels like a narrow enough domain that we shouldn't need to ask developers to reinvent the wheel every time. Frameworks like Yesod restrict you in some ways, but for 95% of all use cases, they push you towards a proper solution. We don't seem to complain when Haskell's type system limits our ability to express certain things, so it seems weird to apply the exact opposite logic to frameworks. I know the Haskell community is very exploratory, and that's cool in some respects, but it seems like we should be killing off web frameworks faster than we're creating them.  Also, while this is a bit of an awkward venue, I've been curious to ask you about ClassyPrelude. When it was released, the community seemed concerned about the conventions around its typeclasses, but it seems as though those have been largely fixed in the eyes of category theorists.  ClassyPrelude seems like a decent solution to most of the stuff I was bitching about, but I don't see it being used much. Are there down sides to using it, or is it mostly inertia + dependencies that keep people from using it?"
haskell,3bjguk,NiftyIon,3,Tue Jun 30 19:30:36 2015 UTC,"There's certainly pushback on ClassyPrelude. It's opinionated, but it's my opinion, so I like it :). Using it adds a heavy-ish dependency, so I don't use it in my libraries, but like to use it when writing my own apps. If you like it, I'd say use it, it certainly doesn't break things at all.  Overall: I agree with your desire to have minimal language settings and imports, I don't like having the same 60 lines starting every module in a project either."
haskell,3bjguk,aseipp,2,Tue Jun 30 20:22:44 2015 UTC,"because Ruby's base language ships with GADTs? I hate boilerplate too, but can't you just re-export the 100 modules you always need from a MyPrelude module?"
haskell,3bjguk,NiftyIon,4,Wed Jul 1 02:20:26 2015 UTC,"It's already possible to re-export modules. However, it would be particularly nice if it were possible to re-export qualified modules. People have thought about this on and off, such as here and here and a few other places linked to there. To be honest, it seems like the main reason this hasn't happened is that no one has decided to take it on; it seems like a fairly straightforward patch to GHC.  The other issue of the LANGUAGE pragmas is different, because I see real problems with an import statement enabling or disabling LANGUAGE pragmas. I'm not sure how you would reduce this boilerplate, or if it is necessary to reduce.  One option would be to define a ""modern"" Haskell, which goes beyond Haskell2010 and includes by default a number of extensions now considered completely commonplace. From the above list, I would say it is safe to enable by default ConstraintKinds, DataKinds, DeriveGeneric, FlexibleContext, FlexibleInstances, GADTs, MultiParamTypeClasses, TypeFamilies, and TypeOperators. I chose these because they seem like ones that add strictly more power and new syntax, and don't make Haskell2010 code break when it previously worked (I think?). GeneralizedNewtypeDeriving scares me a little, I'm not sure about PolyKinds, and TemplateHaskell/QuasiQuotes I've always felt were too hacky and cludgey to deserve to be part of a ""default"" set of extensions. With all of this in mind, we did previously have -fglasfow-exts which is now deprecated; this was before my time so I'm not actually sure what convinced people this sort of ""kitchen-sink"" approach is a bad idea. (Does anyone more experienced care to comment?)  Perhaps its time for a new Haskell standard and a new Haskell compiler to compete with GHC... if only."
haskell,3bjguk,aseipp,3,Tue Jun 30 06:09:19 2015 UTC,"Several of the extensions you listed (GADTs, TFs, DataKinds etc) in practice go through either constant tweaks or massive overhauls (e.g. we just got closed TFs, and we'll get injective ones soon). The whole point of it being an extension is that it is allowed to be something of a moving target, versus the standard. I don't know how amazingly the plan has worked out or what people think, but that's kind of the rationale.  In practice, this occurs quite frequently for type level features because the type checker is prone to overhaul and change. It's actually probably quite realistic to implement the Haskell you described, but you'd basically just have to define whatever behavior it implemented and never change it ever again for those features.  Then GHC will just have new extensions later, like -XClosedTypeFamilies or -XInjectiveTypeFamilies because your compiler doesn't implement them, just ""type families"".  Competition would be great here, but I'm not sure if this will quite 'fix' the heart of the issue.   With all of this in mind, we did previously have -fglasfow-exts which is now deprecated; this was before my time so I'm not actually sure what convinced people this sort of ""kitchen-sink"" approach is a bad idea. (Does anyone more experienced care to comment?)   Principle of least surprise, I'd say. It just makes it impossible to determine if your program will ever really 'work'. The meaning of that flag changes almost entirely in a lot of subtle (and not subtle) ways from GHC version to GHC version, because by being an extension a feature is allowed to be a moving target... Some programs that were valid may then become invalid because some extensions change the syntax (like StaticPointers). It may never be clear why a program was suddenly accepted now but rejected in the past (because now it uses BinaryLiterals or something). Or any other number of bad interactions over time, really - those are just very simple obvious cases."
haskell,3bj3gq,rwobben,3,Mon Jun 29 17:17:56 2015 UTC,"I often get this error if I forget an =, or I accidentally mix tabs and spaces."
haskell,3bj3gq,sccrstud92,1 point,Mon Jun 29 17:53:51 2015 UTC,"doubleEveryOther :: [Integer] -> [Integer] doubleEveryOther lst      | []                     = []      | len lst `mod` 2 == 0   =  doubleEveryOther' reverse lst       | otherwise              =  doubleEveryOther' lst       where doubleEveryOther' acc lst2            doubleEverYOther' acc []        = acc            doubleEveryOther' acc (x,y,xs)  = x : y* 2 : doubleEveryOther' xs   Check line six, the start of the where clause. Also you have a small typo in the type signature - need capital i Integer."
haskell,3bj3gq,timmy_tofu,1 point,Mon Jun 29 17:23:07 2015 UTC,"Thanks,   I changed it but the error message stays. I think the problem is in the last line (x,y,xs) where I meant to say 1 element, 1 element and the rest of the array."
haskell,3bj3gq,htebalaka,2,Mon Jun 29 17:59:01 2015 UTC,"You can use (x:y:xs) as the pattern I think you're asking for. You use mostly the same syntax for patterns as you do for constructing values from their data constructors.  There's also an error on line 3. The guard needs to be a Bool. You could do | null lst = [] to check that the list is empty, or the more idiomatic:  doubleEveryOther [] = [] doubleEveryOther lst     | len lst `mod` 2 ...   I don't think the first issue with cause a parse error but a type error; I thought the second might, but it seems like it's also a type error. The only thing that I can see that might cause the parser error is the where clause on line 6 like /u/timmy_tofu said. There's also another typo on line 7 (doubleEverYOther).  There are a few other type errors that I can see if you want to know what they are, but I dunno if you'd prefer to work them out yourself after fixing the parse error. It could just be spaces vs. tabs. When I was using SublimeText I found it sometimes inconsistently replaced sequences of spaces with tabs when auto-indenting."
haskell,3bj3gq,ignorantone,1 point,Mon Jun 29 18:42:12 2015 UTC,"Oke,   I have now this :   doubleEveryOther :: [Integer] -> [Integer]   doubleEveryOther [] = []  doubleEveryOther lst      | length lst `mod` 2 == 0   =  doubleEveryOther' reverse lst       | otherwise                 =  doubleEveryOther' lst       where doubleEverYOther' []        = lst        doubleEveryOther' (x,y,xs)  = x : y* 2 :  doubleEveryOther' xs    but now I see this error :  Occurs check: cannot construct the infinite type: t0 = (a0, a0, t0)     In the first argument of doubleEveryOther', namely xs'     In the second argument of(:)', namely doubleEveryOther' xs'     In the second argument of(:)', namely       `y * 2 : doubleEveryOther' xs'"
haskell,3bj3gq,andrewthad,1 point,Mon Jun 29 18:53:59 2015 UTC,"Typo: doubleEverYOther vs doubleEveryOther  doubleEverYOther' [] implies that the argument is a list.   doubleEveryOther' (x,y,xs) implies that the argument is a 3 element tuple.   The argument type must agree. You probably intended to use the cons operator (:) instead of the tuple constructor (,) : doubleEveryOther' (x:y:xs)"
haskell,3bj3gq,ignorantone,1 point,Mon Jun 29 19:41:46 2015 UTC,"Then I see  this error message :   *Main> doubleEveryOther [1,2,3] [1,4*** Exception: creditcard.hs:(18,12)-(19,73): Non-exhaustive patterns in function doubleEveryOther'"
haskell,3bj3gq,ephrion,2,Mon Jun 29 19:49:47 2015 UTC,The function names aren't the same. The Y is capitalized in one of them. doubleEverYOther is being treated as though it's a different function.
haskell,3bj3gq,theonlycosmonaut,1 point,Mon Jun 29 19:54:46 2015 UTC,"The exception is telling you that doubleEveryOther' was invoked with an input that does not match either of the two patterns that you defined. Can you spot the missing pattern?  You can look at the code and try and figure out which pattern is missing, or you can compile the code with -Wall, as in: ghc -c Main.hs -Wall. I recommend you do the first for a bit to exercise your brain. If you get frustrated, let the compiler tell you which pattern is missing."
haskell,3bf2ed,begriffs,8,Sun Jun 28 17:21:38 2015 UTC,"Do you happen to know why the tabula project is defunct? The idea really seamed brilliant. I'd just love to work on this kind of project.  I also have a more technical question: what are the papers I should read on this subject other than Conal Elliott's blog?  I'd be interested in particular in a ""general"" notion of compilation, in which we also parametrize the process over the shape of the machine in which we want our code to be run. Are there some ideas pushing in that direction?  Also, what are the optimizations done in the language of CCC? Is there a ""normal form"" of a computation in a CCC analogue to the normal form in a strongly normalizing typed lambda calculus?"
haskell,3bf2ed,meditans,7,Sun Jun 28 21:05:46 2015 UTC,"It sounds like although Tabula's technology was promising, and received strong initial investment, the business did not get enough traction.  You may also be interested in Adam Megacz's Generalized Arrows, which builds up type classes similar to those used in the talk."
haskell,3bf2ed,DavidJRHarrison,3,Mon Jun 29 06:12:31 2015 UTC,Comments in this EETimes article suggest that the increased power required for designs like these do not outweigh the other benefits.
haskell,3bf2ed,brooksbp,2,Mon Jun 29 06:30:37 2015 UTC,"Check out Dan Ghica's work on the ""geometry of synthesis"":  http://www.cs.bham.ac.uk/~drg/  Lab Lunch - Geometry of Synthesis"
haskell,3bf2ed,zeromap,5,Tue Jun 30 17:02:38 2015 UTC,"Really interesting talk, covers many of the things I find fascinating about Haskell/FP. I was wondering about generalizations beyond CCCs, such as resource-sensitive categories (with linear/uniqueness types), and non-closed categories. It would also be interesting to know about the performance implications of the requirement that the target category be closed."
haskell,3bf2ed,DavidJRHarrison,1 point,Mon Jun 29 06:00:43 2015 UTC,Genuinely curious - whats the point of this?  (EDIT: TIL what Field-programmable gate arrays are.)
haskell,3bf2ed,saltvedt,5,Sun Jun 28 21:13:28 2015 UTC,"I'd guess that a big motivation is being able to design circuits using Haskell, a much higher level language than VHDL or Verilog."
haskell,3bf2ed,ignorantone,1 point,Sun Jun 28 23:55:28 2015 UTC,The point is very simple: run Haskell programs insanely fast via massive parallelism. Think hundreds of thousands (or millions) of small evaluations happening at once.
haskell,3beiti,dalaing,8,Sun Jun 28 14:13:44 2015 UTC,"Great title, though it should be ""cofree for products."""
haskell,3beiti,davidwsd,3,Sun Jun 28 18:29:56 2015 UTC,What is the advantage to this over a transformation to a state monad?  Can you use Cofree to interpret other effects?
haskell,3beiti,davemenendez,4,Sun Jun 28 20:02:37 2015 UTC,"I'm not quite sure what you mean by ""transformation to a state monad"" - could you expand on that?  You could write add, clear and total in terms of a state monad.  In that case you don't get the DSL / interpreter separation, which a) has benefits in certain use cases and b) is the topic of this series.  You can use Cofree for a lot more than what I'm covering in this series - for these posts I'm just focusing on using them as an interpreter for a DSL.  I'll be covering the use of IO in the interpreters later on.  I've only just woken up and am pre-coffee - hopefully that goes part of the way to answering your questions."
haskell,3beiti,davemenendez,4,Sun Jun 28 23:57:48 2015 UTC,"Free is a functor from Haskell Functors to Haskell Monads, so we get these operations:  hoist :: (Functor f, Functor g) => (forall a. f a -> g a) -> Free f a -> Free g a mextract :: (Monad m) => Free m a -> m a   So we can write interp :: AdderF a -> State Int and then get extract . hoist interp :: Free AdderF a -> State s a.  Or we can write interp :: AdderF a -> Free SuperAdderF a and get a translation into another DSL that can be interpreted by something else.  I wrote about a similar trick for Prompt a few years back."
haskell,3beiti,davemenendez,4,Mon Jun 29 02:48:18 2015 UTC,"Thanks for clarifying (and that's a very cool post, by the way).  This series of posts is half about using Free for DSLs.  The main idea running through this series of posts is that Free gives us some nice advantages, like the separation of the usage DSL from the interpretation of the DSL, which lets us do things like build libraries on top of the DSL without having to specify which interpreter they'll be used with or using one interpreter for testing and the other for running in production.  I'm guessing from you comment and from the post that you linked to that none of that is news to you :)  The other half of the series is about using Cofree to get those same benefits for the interpreter (and how far we can push that).  This post is where some of the additional payoff comes into play, because now  - modulo improving some of the typeclass machinery -  we can develop several DSL / interpreter pairs and mix them together as we need to.  The series is more about what I think is a neat set of implementation techniques rather than a deep theory dive.  Hopefully in the next few posts I'll cover some of the surrounding techniques that I'm excited about / think have a bit of potential."
haskell,3beiti,hans2504,4,Mon Jun 29 03:12:55 2015 UTC,"Thanks. I look forward to the rest of the series.  If you look at it at the right level, these methods are actually pretty related. Consider these simple functors:  data F a   = F X (Y -> a) data CoF a = CoF { getCoF :: X -> (Y,a) }   Then a coalgebra on CoF is very similar to a natural transformation from F to State.  S -> CoF S == S -> X -> (Y,S) (forall i. F i -> State S i) == X -> (Y -> i) -> S -> (i,S)   That's why I'm curious whether Cofree can be used for other effects, like exceptions or nondeterminism."
haskell,3beiti,bartavelle,2,Mon Jun 29 04:45:41 2015 UTC,"Thanks! I just discovered the Free monad on this sub reddit a couple weeks ago and I've really enjoyed this series as well as the material by Gabriel Gonzalez  and Aaron Levin. In an attempt to get handle for this style of programming I'm trying to write a little text adventure game. As useful as all the blog posts have been, I find I'm flipping between about 6 articles while I work on this project. Does anyone have a good example of a full project that effectively uses this approach?"
haskell,3beiti,VincentJP,4,Sun Jun 28 20:36:42 2015 UTC,"I wrote a while ago a description of the implementation of the ""7 wonders"" game over XMPP. The game rules were described with an program from the operational package, which  is isomorphic to the free monad where the functor is Coyoneda Instr.  You basically have rules expressed in a given monad, and then several interpreters that can run them. Descriptive text is here (jump to ""Implementing the GameMonad""), interpreter building function is here and game rules are here."
haskell,3beiti,b00thead,3,Mon Jun 29 12:38:46 2015 UTC,"I don't know of any full projects off the top of my head, but feel free to PM me if you want someone to bounce ideas around with.  I've got indexed free and indexed cofree on my list of things to play around with, so I've got a set of tabs including some of Aaron's posts that I'm flipping between as well :)"
haskell,3beiti,MitchellSalad,3,Mon Jun 29 00:06:18 2015 UTC,"Rasterific use a free monad to describe the scene, and use two ""interpreters"", the rasterizer and the PDF output"
haskell,3bdrlj,joehillen,20,Sun Jun 28 06:54:54 2015 UTC,byorgey has a lot to answer for.
haskell,3bdrlj,dons,7,Sun Jun 28 11:37:54 2015 UTC,"""This library is a joke. But you can also use it actually. Like it works and stuff."""
haskell,3bdrlj,yitz,9,Mon Jun 29 00:33:23 2015 UTC,"Forget the cloud-to-butt extension, I want a monad-to-burrito extension!"
haskell,3bdrlj,hexbienium,19,Mon Jun 29 00:14:46 2015 UTC,"The sad thing is that in my original blog post I used ""burrito"" as a random, hypothetical, silly example of a bad monad analogy.  Then, Mark Dominus wrote this blog post explaining how actually, monads kinda are like burritos! But not only are burritos a hypothetical example of a bad monad analogy, it turns out that they actually are a bad monad analogy. (I'm happy to expand on why, if asked.  But maybe you should think about it first.  If you can't come up with some reasons why burritos are a bad analogy for monads, then there are additional levels of monad understanding to which you have not yet attained.) I am not 100% sure but I think Mark would agree and that his post was intended as a joke.  But now lots of people seem to be taking the ""burrito analogy"" seriously, which entirely misses the point of my original post.  I kind of get the feeling that many people who use the burrito analogy don't even know what the original context was."
haskell,3bdrlj,byorgey,12,Sun Jun 28 20:40:27 2015 UTC,"AFAICT, this library isn't taking the burrito analogy seriously, rather just using it as a pun for the name of a library that the documentation says was written as a joke."
haskell,3bdrlj,isHavvy,6,Sun Jun 28 22:08:25 2015 UTC,"I certainly haven't taken the burrito analogy seriously, and I reference Mark Dominus's blog post (which references your blog post) in the README of this library, with my tongue firmly in my cheek. This library is intended as a joke, mostly.  But I also wanted to explore, and cause others to explore, the concept of the IO type and the benefits it provides, by creating a similar type in a language that has not gone all-in on all of the things Haskell has gone all-in on (laziness, purity, referential transparency, so on). I wanted to approach some of the concepts of expressively typed functional programming paradigms from an unusual angle.  I expected comments about why Burrito is not nearly as good as Haskell's IO type, how it isn't really a monad, and so on. These comments have been educational and I'm glad to have received them, though I don't agree with the perspective on programming that they seem to come from."
haskell,3bdrlj,desiringmachines,5,Sun Jun 28 23:00:14 2015 UTC,"Fair enough, my comment was prompted by seeing the link to your library (which I admit I haven't looked at closely) but mostly directed at other references to burritos I've seen recently. What you're doing sounds great."
haskell,3bdrlj,byorgey,2,Mon Jun 29 14:00:59 2015 UTC,"I can come up with some reasons why they make a poor analogy but by nature of analogy they may be wildly different than yours. Since my understanding of monads is probably middling, I'd love for you to explain why they are bad analogies from your POV."
haskell,3bdrlj,ilmmad,1 point,Mon Jun 29 18:14:41 2015 UTC,"Sorry for the very delayed reply, I have been travelling and missed your comment.  Here are a couple reasons off the top of my head:   The burrito analogy strongly implies that a value of type m a somehow ""contains"" a value (or values) of type a.  But that is not true for all monads (e.g. there is no sense in which a value of type IO String contains a String). It is not actually very easy to take a burrito containing a burrito and merge it into a single-level burrito.  At least this is not in any sense a natural operation on burritos.  Perhaps you could argue that it is always easy to remove outer tortilla layers (but not the innermost one since the food will all fall out), but this is a bad analogy since in general join does not just ""remove"" an outer layer, but somehow merges the effects of two layers into one."
haskell,3bdrlj,byorgey,5,Mon Jul 13 20:42:15 2015 UTC,https://www.reddit.com/r/rust/comments/3bdoqj/i_wrote_an_io_monad_in_rust_its_called_burrito/
haskell,3bdrlj,crusoe,3,Sun Jun 28 06:55:32 2015 UTC,"Isn't it kinda pointless since ownership semantics in Rust prevent both race conditions and aliasing? So rust can be strict and have good memory safety, and not need things like monads which Haskell uses to enforce ordering."
haskell,3bdrlj,Tekmo,27,Sun Jun 28 15:41:43 2015 UTC,IO in Haskell has nothing to do with solving the problems of race conditions and aliasing
haskell,3bdrlj,crusoe,2,Sun Jun 28 15:57:23 2015 UTC,"Haskell is lazy and pure, so for Haskell monads solve sequencing of io operations.  Rust is strict and impure but has strong memory and alias guarantees. Ordering of io ops is a non issue. So what does a monad solve?"
haskell,3bdrlj,Tekmo,15,Sun Jun 28 18:36:01 2015 UTC,"Having first class IO lets you separate side effect order from evaluation order.  This separation in turn enables equational reasoning, which greatly simplifies proving code correct.  If you try to prove even the most basic equations correct in Rust you will run into a wall, because all the substitutions you would like to perform in the course of your proof change evaluation order, which in turn changes side effect order.  Contrast this with Haskell, where evaluation is benign, so there are far more behavior-preserving program transformations that you can use in your proofs.  Haskell programs are also easier to refactor than Rust programs, for the exact same reason: more behavior-preserving program transformations."
haskell,3bdrlj,crusoe,1 point,Sun Jun 28 18:48:46 2015 UTC,"Not necessarily arguing that, just that the overwhelming reason for the IO monad is not present in RUST, which is that Lazy messes with guaranteeing sequencing."
haskell,3bdrlj,sambocyn,3,Mon Jun 29 20:39:25 2015 UTC,"isn't the overwhelming reason just purity? like Signal in Elm and (I think) IO in Idris, both strict-by-default."
haskell,3bdrlj,Tekmo,2,Mon Jun 29 23:08:09 2015 UTC,"Also, I think Purescript is strict and purely functional"
haskell,3bdrlj,radix,3,Tue Jun 30 20:37:25 2015 UTC,"My understanding is that the monad laws by themselves do not fully solve the problem of order of IO operations. That's something that the IO type in particular guarantees, I think.  For example, if you have something like  do   x <- getLine   y <- getLine   return (y, x)   A runtime might evaluate the second getLine before the first getLine, since there's no data dependency between them. Haskell's IO type in particular guarantees that they will be run in the order specified, though.  Apart from that, monadic IO is super useful even in contexts other than Haskell. I use it to isolate my effects in Python code.  By using it consistently, it gives me these benefits:   easier to reason about my code since I know which functions have effects and which don't by parameterizing the concrete implementation of effect performance, I get:   much nicer unit tests than the status quo in Python the ability to write app code that is agnostic to how IO is performed, meaning I can e.g. use either Twisted or the blocking requests library for implementing an HTTP request operation, without changing my app code."
haskell,3bdrlj,Tyr42,2,Sun Jun 28 21:00:21 2015 UTC,"https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo  That code you have there is actually only using the Applicative instance, and we can write it as   (\x y -> (x,y)) <$> getLine <*> getLine   so can talk about this using the applicative laws, but I'm not sure what that buys us at this moment."
haskell,3bdrlj,darkroom--,1 point,Mon Jun 29 17:47:40 2015 UTC,"I think you can write that as (,) <$> getLine <*> getLine (I removed the lambda)"
haskell,3bdrlj,Tyr42,1 point,Tue Jun 30 00:59:45 2015 UTC,"Right, it's only tuple sections that are behind the language pragma."
haskell,3bdrlj,pdpi,10,Tue Jun 30 03:10:28 2015 UTC,"IO results in rust are already sort of an Either IOError T. Without a convenient bind operator, monadic error handling becomes somewhat more awkward to use.  EDIT: Actually, the stdlib already implements a bind equivalent (thanks, /u/desiringmachines)."
haskell,3bdrlj,desiringmachines,5,Sun Jun 28 15:55:22 2015 UTC,Rust's monadic types implement methods and_then() and and() which are analogous to the >>= and >> operators; what do you mean when you say it isn't convenient?
haskell,3bdrlj,pdpi,3,Sun Jun 28 23:03:59 2015 UTC,I'm a nincompoop and missed those. Thanks.
haskell,3biuvc,Max00355,4,Mon Jun 29 16:15:16 2015 UTC,First one listed as haskell isn't haskell lol. And why are the boxes with the code so much larger than the code?
haskell,3biuvc,sccrstud92,6,Mon Jun 29 16:29:00 2015 UTC,"No way to down-vote a snippet or otherwise comment on what's wrong with it, such as what /u/sccrstud92 mentions about the snippet not even being Haskell.  I'm also confused as to the effect voting on a snippet has, since the snippet in question has 0 votes at time of writing, where as the one below it has two."
haskell,3biuvc,emarshall85,-1,Mon Jun 29 16:32:43 2015 UTC,"Haha, is it really? I don't code Haskell and I did not post that one, but I removed it haha xD   The voting is used for the popular page where the code snippets are sorted. I will add down voting and commenting."
haskell,3biuvc,sccrstud92,2,Mon Jun 29 16:50:00 2015 UTC,I assumed that this was coded in haskell because it was posted on this subreddit. Oops.
haskell,3biqg6,mwscidata,5,Mon Jun 29 15:41:57 2015 UTC,I first thought it was a joke:   Haskell on a truly vast scale *clicks*  Not Found   The link gives 404.
haskell,3biqg6,utdemir,2,Mon Jun 29 16:33:11 2015 UTC,I love those Foundation books.
haskell,3biqg6,thecity2,1 point,Tue Jun 30 01:41:25 2015 UTC,What the hell?  The site links to this: http://www.geopense.net/distrib/FP.pdf  0_o
haskell,3biqg6,clrnd,1 point,Mon Jun 29 17:23:12 2015 UTC,"I did a quick scan over it and there was some stuff about Haskell and computation, but not enough to make sense of the title IMO."
haskell,3biqg6,codygman,1 point,Mon Jun 29 21:24:01 2015 UTC,"I just posted it because most of the feedback I've received on that article has to do with Haskell, which is virtually unknown in sociology/biology circles.  I'm not selling or advocating anything (not even computational psychohistory :), just interested in really, really huge systems."
haskell,3be4fi,maxigit,17,Sun Jun 28 10:45:48 2015 UTC,"Now the question is do [I] write cost as a getter   My recommendation is to never write a Getter directly. It is universally just slightly less useful than a function. Just a normal function into a Getter with to when you need to drop it in the middle of a lens chain in some particular concrete situation.  If you wrote  cost i = _quantity i * _price i   then  foo^.to cost   or     cost foo  would be both be perfectly fine to use.  You can avoid (^.quantity) with view quantity as well:  cost i = view quantity i * view price i   This may appeal more to your sensibilities, and lets you avoid needing access to the _'d record accessors.  Finally, you can worry a lot less about the 'hidden field accessors' being deep private details you shouldn't access directly here in Haskell -- mostly just because with the lens laws being what they are they don't have secret side-effects elsewhere in your structure that you aren't getting with the _foo versions.  No lens police will come arrest you for ""using lens incorrectly"" or ""not using it enough."" There are lots of people in the Haskell community who see no real value to them at all and still manage to get code written. =)  It is just a tool, sometimes one that is very useful, but sometimes the direct way is cleaner."
haskell,3be4fi,edwardkmett,2,Sun Jun 28 16:14:51 2015 UTC,"I've seen your recommendation about using to and that's what I did in my code. Then I needed Item to be an instance of Semigroup. Obviously it doesn't work, so I had to swap cost and price in the data definition.   data Item = Item { quantity :: Double, cost :: Double}  price i = i^.cost / i^.quantity   Now, all the legacy code uses price as a Getter and cost as a function (as well as _price. I have to change to cost to cost but I can get away of modifying price and _price by doing  _price i = _cost i * _quantity i price = to price   If I had done that initially with cost = to _cost .. I would have pretty much nothing to change in my code to refactor Item, hence my question.  About the ""lens police"", you've created a monster , and the same way Haskell creators didn't know lens would be even possible, a ""lens police"" might appears sooner that you think and you'll probably even be the first arrested ;-)"
haskell,3be4fi,edwardkmett,5,Sun Jun 28 16:45:48 2015 UTC,"Of course you can always make a price lens even with   data Item = Item { quantity :: Double, cost :: Double}  price :: Lens' Item Double price f (Item q c) = (\p -> Item q (q * p)) <$> f (c / q)   This is only a legal lens whenever quantity is non-zero, however."
haskell,3be4fi,kqr,8,Sun Jun 28 17:31:21 2015 UTC,"Does the Item module export _quantity and _price? If so, feel free to use them outside the module. Does the module not export them? Then only use them inside the module.  You mention you're used to Python, which I certainly understand. In Python, you have to make conventions for which things are allowed and which aren't. In Haskell, you specify these restrictions formally in the code (e.g. by not exporting things you're not supposed to use) and it's impossible to use things that aren't allowed to be used because the compiler checks this for you.  In other words: if it's in the namespace, don't be afraid to use it. It's there because it's meant to be used. If you weren't meant to use it, you wouldn't be able to even if you wanted to.    In this particular case, I would personally write  cost :: Getter Item Double cost = to (\i -> _quantity i * _price i)   where I see _quantity as shorthand for view quantity, from lens. So if _quantity is not visible in the current namespace, I'd substitute in view quantity instead."
haskell,3be4fi,emmanueltouzery,3,Sun Jun 28 12:33:57 2015 UTC,"To be fair, I haven't done any python for 10 years, and I only remember name starting with _ being private and I kind of used this convention since. But you are right, Haskell is not Python, and if it's in the scope, then it is in the scope."
haskell,3be4fi,emmanueltouzery,7,Sun Jun 28 12:56:06 2015 UTC,"you can absolutely have your fields as quantity with the lens being quantityL, that's what I do too. See: stackoverflow.com/questions/17132514/"
haskell,3be4fi,Taladar,4,Sun Jun 28 12:46:44 2015 UTC,"Interesting, but is it really worth it, or should  I just get used to use _quantity & co ?"
haskell,3be4fi,Taladar,3,Sun Jun 28 12:58:12 2015 UTC,"i guess it's more a matter of taste. It is probably important though that you see that you're not the only one with that idea. note that as you can see in the answers, lens changes the API to achieve this regularly, therefore there is some disruption, and it may also make it clear that only a small minority is interested in this."
haskell,3be4fi,Taladar,2,Sun Jun 28 15:27:30 2015 UTC,The advantage of the leading underscore is that you won't get warnings about not using the record accessors if you choose not to export them and only use the lenses in the module.
haskell,3be4fi,glguy,1 point,Mon Jun 29 06:43:01 2015 UTC,What do you mean ?
haskell,3be4fi,mallai,3,Mon Jun 29 17:00:33 2015 UTC,GHC will not warn about unused identifiers beginning with an underscore. For regular identifiers it will warn if they are neither used locally nor exported. This is an advantage over the suggestion of two regular identifiers with underscore suggested above if you plan to only use the lenses.
haskell,3be4fi,tomejaguar,2,Mon Jun 29 17:42:41 2015 UTC,Am I be wrong but are not the record accessors used by the code generated by TH for the lenses ? Does that not count as used ?
haskell,3be4fi,mcapodici,2,Mon Jun 29 19:54:51 2015 UTC,"I have not used the lens library in a while so I don't know how they generate the lenses today but depending on the method used they wouldn't necessarily use the named accessors, e.g. with something based on DeriveGeneric you could iterate over them without actually using the generated functions."
haskell,3bd66h,varosi,15,Sun Jun 28 02:35:32 2015 UTC,"Alright, I've implemented support for the --package option on master. Consider you have the following in foo.hs:  #!/usr/bin/env stack --resolver lts-2.9 --install-ghc runghc --package turtle {-# LANGUAGE OverloadedStrings #-}  import Turtle  main :: IO () main = echo ""Hello World!""   Running stack --resolver lts-2.9 --install-ghc runghc --package turtle foo.hs should have the desired effect (yay!). However, I really liked the idea of having the shebang just work so that this file could be made executable and run with ./foo.hs. Unfortunately, on Unix systems, this ends up with:   /usr/bin/env: stack --resolver lts-2.9 --install-ghc runghc --package turtle: No such file or directory   For more gory details, see Stack Exchange. One possibility to solve this is to provide an improved env utility that does proper argument parsing before passing off to stack. Another (fairly hacky) thing is to embed that functionality somehow in stack itself, such that it has special handling for the case where it's called with file name... somehow. There are many different things we could do here, but few that would be convenient, minimize system installed code, and be easily cross-platform.  If it's not obvious: thoughts are very welcome on how best to move forward here.  EDIT One more idea which I just tried implementing: have a separate runstack executable that takes a single filename as an argument, parses out command line arguments from stack from a comment line after the shebang, and reruns stack with those arguments. If that was too abstract a rambling, check out this Gist with the idea implemented (though the options parsing would need to be better for real usage)."
haskell,3bd66h,snoyberg,7,Sun Jun 28 07:55:28 2015 UTC,"Wow, great! You're lighting fast!  The idea about runstack is good and will fit very well to what we need. About arguments - they may be fit in a comment or pragma. The file will not be compilable anyway because of shebang, but it will be executable, which is alright.  May be it is lame question, but isn't it possible to call directly stack with:     #!/usr/bin/stack ...."
haskell,3bd66h,snoyberg,3,Sun Jun 28 09:09:51 2015 UTC,"Yes, but:   Users can have stack installed anywhere on the PATH. Using env like this avoids hardcoding an absolute path for stack (though it does hardcode a path for env). The argument parsing still wouldn't allow multiple arguments to be passed to stack, so some kind of hack like I implemented in the gist would still be necessary.   It would be possible to hack the main stack executable to have the same logic as runstack, as a fallback for when other command parsing fails. However, I'd rather not do that, as we could end up in a situation when a user accidentally runs a file when he/she intended to run a command, or vice-versa."
haskell,3bd66h,Tekmo,2,Sun Jun 28 09:12:38 2015 UTC,"Yes, you're right. ""runstack"" will be good and enough solution in my opinion."
haskell,3bd66h,snoyberg,3,Sun Jun 28 09:27:27 2015 UTC,"Yeah, I think you will eventually need to support embedding Stack information as a comment within the source file because otherwise you might hit limits on command line lengths.  However, the command line is still a good approach for most use cases.  Also, thanks a lot for doing this!"
haskell,3bd66h,snoyberg,6,Sun Jun 28 14:01:30 2015 UTC,"It's a pleasure, this looks like a really cool use case. I know that I've wanted to do things like this before. And anything that helps you promote Haskell more is a good thing :)"
haskell,3bd66h,madjar,2,Sun Jun 28 14:25:50 2015 UTC,"Pasting here for lack of any better place to comment: this feature has now landed on master, thanks to Manny, and will be included in the next release. More information at:  https://github.com/commercialhaskell/stack/wiki/Script-interpreter"
haskell,3bd66h,theonlycosmonaut,1 point,Tue Jun 30 06:34:06 2015 UTC,Very-very-very cool!
haskell,3bd66h,snoyberg,2,Fri Jul 17 18:06:26 2015 UTC,"I've seen your last idea in many context, and it usually works pretty well (https://github.com/madjar/manuscript/, https://github.com/madjar/nixbang, http://nixos.org/nix/manual/#sec-nix-shell)."
haskell,3bd66h,soenkehahn,2,Sun Jun 28 09:22:12 2015 UTC,Does #! happen in Windows? I guess under msys...? I confess I have hardly done any development in Windows since finally starting to dual-boot on both my machines :p.
haskell,3bd66h,dalaing,3,Sun Jun 28 12:23:17 2015 UTC,"I think it only kicks in when using some kind of Unix emulating shell, such as msys. With this proposal, on Windows you'd run runstack somefile.hs."
haskell,3bd66h,snoyberg,1 point,Sun Jun 28 13:13:37 2015 UTC,"Yes, you have MSys and CygWin."
haskell,3bd66h,bss03,2,Sun Jun 28 12:28:28 2015 UTC,"Having a working solution for this would be awesome. Some thoughts:   The dependencies could be put into pragmas to clarify that they are not normal discardable comments. At zalora we've toyed around with something similar (https://github.com/soenkehahn/runstaskell). The main difference in our approach was that scripts cannot have arbitrary dependencies, but can only depend on a defined subset of stackage, which would be installed by default. That has the obvious disadvantage of limiting the possible imports but has the advantage that script execution wouldn't prompt download and installation of packages. So you don't need a working network connection to execute scripts and you don't run into the situation that scripts can take much longer to execute than normal because they have to install a bunch of dependencies first. (We've abandoned runstaskell so I'm excited to see something like this in stack.)"
haskell,3bd66h,snoyberg,1 point,Mon Jun 29 04:38:58 2015 UTC,"Random, possibly hacky thought - could you add support for something like ~/.stack.yml as the place to look for configuration for ad-hoc scripts?  I guess that becomes shared mutable state for the system, so it might be a little bit past the ""too hacky"" point in the tradeoff :)"
haskell,3bd66h,theonlycosmonaut,1 point,Mon Jun 29 00:16:30 2015 UTC,"We already support a config file like that, as well as a ""global project."" Try running stack exec echo foo outside of a project and you should see something like:  Using resolver: lts-2.9 from global config file: /home/vagrant/.stack/global/stack.yaml"
haskell,3bd66h,snoyberg,1 point,Mon Jun 29 08:38:17 2015 UTC,"Unfortunately, on Unix systems   Actually, the latest UNIX specification specifically allows any behavior on a shebang line.  Without a shebang line (but with an appropriate environment) a UNIX shell (not necessarily /bin/sh) is used.  Ref: http://pubs.opengroup.org/onlinepubs/9699919799/idx/shell.html (2.1.1)"
haskell,3bd66h,the_abyss,1 point,Tue Jun 30 19:02:57 2015 UTC,"I can't believe I typed Unix, I meant Linux systems."
haskell,3bd66h,snoyberg,3,Tue Jun 30 19:53:44 2015 UTC,"Does this end up, in the long run, as a way to specify the entirety of stack.yml on the command-line? I imagine if you start to use Haskell scripts often, you'll end up pulling in more packages (depending on specific versions), using different compiler versions, etc.  Randomly throwing in ideas - maybe a theoretical stack runghc should look in some sort of special comment block to get its dependency information? Maybe stack.yml could be inlined into a haddock block attached to the module declaration? This might facilitate more easy one-file-script hand-arounds while avoiding the inevitable 'doesn't work on my machine' 'oh you need to use 7.10.5' conversations.  EDIT: and then add #!/usr/bin/stack and Bob's your uncle ;)"
haskell,3bd66h,theonlycosmonaut,6,Sun Jun 28 04:10:32 2015 UTC,Both this and OP's idea sound quite reasonable. Perhaps we can have a design discussion on the stack mailing list about what people want and then implement it? Seems like we can make something good really quickly.
haskell,3bd66h,Tekmo,2,Sun Jun 28 04:37:46 2015 UTC,"This would be awesome, thanks so much for your work."
haskell,3bd66h,chrisdoner,1 point,Sun Jun 28 04:57:06 2015 UTC,"It would be great, really!"
haskell,3bd66h,hiptobecubic,5,Sun Jun 28 05:18:26 2015 UTC,"While playing with this, I ran up against http://unix.stackexchange.com/questions/63979/shebang-line-with-usr-bin-env-command-argument-fails-on-linux, which makes me very sad."
haskell,3bd66h,Tekmo,3,Sun Jun 28 06:58:06 2015 UTC,I think for scripting it will be well enough if additional package dependencies could be passed on command-line.
haskell,3bd66h,Taladar,1 point,Sun Jun 28 05:21:37 2015 UTC,"I disagree, I think that'll lead to terrible ergonomics."
haskell,3bd66h,seantparsons,6,Sun Jun 28 12:22:13 2015 UTC,The #1 argument against Haskell as a scripting language is that it's not installed by default on most developer machines.  If stack can solve this problem Haskell can make serious headway against Python as a scripting language.
haskell,3bd66h,drb226,10,Sun Jun 28 03:51:25 2015 UTC,"Another component is the fact that even when you have Haskell setup, a script that worked yesterday might just fail today because of a different or missing package, which has been a demotivator in using my Haskell scripts in the past. A script I wrote months ago is a crapshoot whether it'll work today. Being able to specify ""this exact  LTS release"" means at least it can be consistent from run to run."
haskell,3bd66h,theonlycosmonaut,5,Sun Jun 28 11:39:24 2015 UTC,"I think this discussion comes up almost every week, but I'd like to disagree. I think writing throwaway, hacked together good-enough scripts in python is second-to-none. Almost all of the things I love about Haskell are somewhat irrelevant when the consequences of failure are practically zero and speed of execution isn't really important.  I think writing long-lived, maintainable, fast and easily understood software is much more likely to happen with Haskell than Python, but day-to-day throwaway script writing for munging data around and testing things out doesn't require any of those qualities."
haskell,3bd66h,snoyberg,10,Sun Jun 28 04:27:10 2015 UTC,"Actually, I still write throwaway scripts in Haskell.  The main reason is that these scripts often take a long time to run and I don't want to repeatedly wait 10 minutes to find out that there's an error in some downstream stage of my script."
haskell,3bd66h,tejon,4,Sun Jun 28 04:37:07 2015 UTC,"I'm currently using runghc which run almost instant on small Haskell scripts. So there is no problem with the speed/interactivity. But to run runghc I have to have installed GHC and some libraries (like Turtle). This is not that hard currently, because we have MinGHC for Windows, Halcyon for *nix and Platform Haskell for OSX. But the main point is if this installation process could be eased and automatized with ""stack"". Then you'll not need to install anything on the remote machine. Even you'll not need root rights. And the last - running on all OSes will be consistent and the same."
haskell,3bd66h,theonlycosmonaut,2,Sun Jun 28 05:11:58 2015 UTC,"Well, the shebang line is posix specific I think."
haskell,3bd66h,tejon,3,Sun Jun 28 11:18:16 2015 UTC,"Yes, but under Windows there is already MSys and CygWin. Jenkins support it by default, too. So such scripting will be useful in Jenkins, too."
haskell,3bckm7,dmjio,12,Sat Jun 27 22:56:03 2015 UTC,"There's a simpler API that doesn't require type class boiler-plate:  {-# LANGUAGE GeneralizedNewtypeDeriving #-}  import Control.Applicative import Control.Monad.Trans.Maybe import Control.Monad.IO.Class import System.Environment  newtype Env a = Env { unEnv :: MaybeT IO a }     deriving (Functor, Applicative, Monad, MonadIO, Alternative, MonadPlus)  getEnv :: Env a -> IO (Maybe a) getEnv env = runMaybeT (unEnv env)  env :: String -> Env a env key = Env (MaybeT (lookupEnv key))   Then the user would just write:  connectInfo :: Env ConnectInfo connectInfo = ConnectInfo     <$> env ""PG_HOST""     <*> env ""PG_PORT""     <*> env ""PG_USER""     <*> env ""PG_PASS""     <*> env ""PG_DB""   You can also embed arbitrary IO actions since Env implements MonadIO."
haskell,3bckm7,Tekmo,4,Sun Jun 28 03:22:40 2015 UTC,"I like this. The only issue I see is that if an environment variable is not set, there is no information relayed to the user about which key/variable is missing (as you'd find with aeson), but that would be pretty easy to add. Otherwise it looks like a simpler API. Also, the Var typeclass would still be necessary to ensure that types are correctly parsed from the environment. In the example above PG_PORT would still be a String, not a Word16. We'd also need to ensure that only Strings are set (not the String representation of a type). An example would be data Foo = Foo String deriving Show, given Foo ""bar"" we want ""bar"", not ""F \""bar\"""" set in the environment (which Var would provide, the (.=) enforces this). In the code above it would be nice to have ways to set the environment along with retrieving it, the typeclass just simplifies that I guess. I think the DynamoDB portion of the aws package uses type synonyms to make this association, what envy is doing isn't as sophisticated since everything is a String, or a number of some kind. I was thinking of using generics or TH to somehow derive the getting / setting instances of environment variables. So if we had data PGConfig = PgUser { pgUser :: String } | PgConfig { .. etc .. } then instance ToEnv PGConfig could create toEnv = makeEnv [ ""PG_USER"" .= ..., ... ] by reading the constructor name."
haskell,3bckm7,Tekmo,3,Sun Jun 28 04:23:44 2015 UTC,There's definitely virtue in the type class approach if you want to derive generic readers for a data type.  I was looking through the source code and it was closer to what I wanted than I thought.  The part that was confusing me was the type of fromEnv:  fromEnv :: Env -> Parser a   Doesn't Parser internally have a ReaderT Env to access the environment?
haskell,3bckm7,Tekmo,3,Sun Jun 28 04:35:00 2015 UTC,"Yea, that's a redundancy and should probably be removed.     instance FromEnv PGConfig where       fromEnv env = do         env2 <- ask There's really no reason to have a ReaderT if we're passing Env in already.  The core type can probably be simplified to just newtype Parser a = Parser { runParser :: Env -> ExceptT String IO a }, since we're just loading the environment once from getEnvironment :: IO [(String, String)], unless we'd rather enforce that the user use the ask function. That seems like a bad idea though."
haskell,3bckm7,tel,3,Sun Jun 28 04:41:04 2015 UTC,"I was going to suggest this instead:  class FromEnv a where     -- The string is the key you are reading from the environment     env :: String -> Parser a   Then you could do:  instance FromEnv ConnectInfo where     env = ConnectInfo         <$> env ""PG_HOST""         <*> env ""PG_PORT""         <*> env ""PG_USER""         <*> env ""PG_PASS""         <*> env ""PG_DB""   In other words, it would be very much in the same style as the binary library's get"
haskell,3bcpqn,ignorantone,3,Sat Jun 27 23:45:46 2015 UTC,"Can you provide some details for what you are trying to add the Alternative instance to?  I can work out that it is called MyParser, but that's about as far as I've gotten.  The deprecated module is pointing you towards something that doesn't need the Error typeclass anymore.  That's a library issue, which looks independent from anything to do with the compiler in this case.  My guess is that either your code or some code that your code depends on is making use of the deprecated module - ie is written in terms of Control.Monad.Error instead of Control.Monad.Except.  If you can link to a gist or pastebin of MyParser and anything it depends on (or a git repository), we should be able to sort this out."
haskell,3bcpqn,dalaing,1 point,Sun Jun 28 00:59:41 2015 UTC,"See my edit, I linked a gist"
haskell,3bcpqn,dalaing,3,Sun Jun 28 01:15:43 2015 UTC,"OK, nevermind my other comment, I just tried this in a sandbox with mtl and transformers installed into it.  If I do cabal clean then cabal build I get:  No instance for (Control.Monad.Trans.Error.Error Foo)   arising from the 'deriving' clause of a data type declaration Possible fix:   use a standalone 'deriving instance' declaration,     so you can specify the instance context yourself When deriving the instance for (Alternative Bar)   If I do another cabal build after that I get:  No instance for (Alternative (Either Foo))   arising from the 'deriving' clause of a data type declaration Possible fix:   use a standalone 'deriving instance' declaration,     so you can specify the instance context yourself When deriving the instance for (Alternative Bar)   I'm still poking around with that, will add more details if I find anything."
haskell,3bcpqn,dalaing,4,Sun Jun 28 03:27:56 2015 UTC,"Aha!  So, I think you've possibly found a bug, but I also have a workaround for you.  Ish.  If it lines up with what you need.  In Control.Monad.Trans.Error, there is  (Functor m, Monad m, Error e) => Alternative (ErrorT e m)   and in Control.Monad.Trans.Except, there is  (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m)   So you'll need a Monoid instance for Foo.  If you can live with using ExceptT instead of Either, you can use  import Control.Applicative import Control.Monad.Trans.Except import Data.Functor.Identity import Data.Monoid  data Foo = Foo  instance Monoid Foo where     mempty = Foo     mappend _ _ = Foo  newtype Bar a = Bar { unBar :: ExceptT Foo Identity a }   deriving (Functor, Applicative, Monad, Alternative)   and things might work out.  At the very least, they should compile."
haskell,3bcpqn,dalaing,1 point,Sun Jun 28 03:37:01 2015 UTC,"Thanks /u/dalaing ! I appreciate it.  Do you think I should report this as a GHC bug, or a library bug?"
haskell,3bcpqn,dalaing,2,Mon Jun 29 00:01:24 2015 UTC,"Not a problem.  I think it'd be a GHC bug, just because of the non-determinism between builds."
haskell,3bcpqn,ET999,1 point,Mon Jun 29 00:08:17 2015 UTC,"Now I'm unable to reproduce ""No instance for (Control.Monad.Trans.Error.Error Foo)""  I made an empty cabal executable project with Main.hs like this. It's in an empty sandbox, and the only global packages I have installed are those that come with GHC 7.10.1  cabal build says    No instance for (Alternative (Either Foo))   If you're able to reproduce it, feel free to add the bug to tracker. Or give me a hint and I'll try and reproduce and report."
haskell,3bbjtc,potomak,6,Sat Jun 27 17:24:22 2015 UTC,"Some suggestions:   An arrow from Scientific to Double/Float uses the function toRealFrac. Should this be realToFrac or toRealFloat? Since you have both Int and Word in one box, it might be useful to have Natural (the unsigned counterpart to Integer) in the same box as Integer."
haskell,3bbjtc,RyanGlScott,3,Sat Jun 27 18:54:59 2015 UTC,I hope the author would consider contributing the map to the Haskell Wiki (https://wiki.haskell.org) or at least adding a link on relevant pages.  (In general I request everyone to consider improving the Haskell Wiki with your content or links.)
haskell,3bbjtc,howardbgolden,1 point,Sun Jun 28 21:51:56 2015 UTC,"Interesting thing I just discovered was the Data.Int package with some smaller width ints (Int8, Int16, Int32) for when you're counting bits."
haskell,3bbjtc,josuf107,2,Mon Jun 29 18:10:49 2015 UTC,There is also Data.Word with the more commonly used unsigned variants of those.
haskell,3bazgv,chrisdoner,25,Sat Jun 27 14:12:54 2015 UTC,"I understand and like the reasoning behind tracking a relative vs an absolute path, but the file vs directory distinction is, if you'll pardon me stating this baldly, writing cheques it can't cash. As far as I can infer, the only reason for this to exist is to prevent gluing a path component onto the end of a name that you think should not be traversable.  Why do I think you've gone down a bad route with this part of the design? I can think of some unfortunate practical implications that make me very uncomfortable.   Now your type system misleads you into thinking that you statically know things about the association between names and the kinds of entities in the filesystem. In truth, it is possible and not even uncommon for a named thing to change type, perhaps even under your own control. Now I'm sure you as the author of this package are clever enough to know this, but faux invariants that can change behind the backs of the less experienced users of your package don't belong in a type system. I have seen innumerable bugs based on this category of faulty reasoning, so this isn't a theoretical hand-wavy concern. Consider an implication of the inevitable desire to plumb this out to IO. An implementation of getDirectoryContents that's ""type correct"" must return a heterogeneously typed list, or a pair of lists typed as (things that are directories, things that are files). (And what happens with exotic things like symlinks or named pipes? At the very least, the choice of File/Dir naming leads us quickly to dissatisfaction here.) Another implication of IO support will be that getDirectoryContents will have to lstat every entry before returning a result in order to categorise names correctly. This is obviously not desirable for performance reasons.   The bar for making statically enforced promises about how the world works is a high one, and this aspect of the path design does not, in my estimation, meet that bar. So 50% applause, 50% disapproval from me. Not bad :-)  (Guess who's spent a lot of his career messing with filesystems...)"
haskell,3bazgv,bos,3,Sun Jun 28 03:47:56 2015 UTC,"An implementation of getDirectoryContents that's ""type correct"" must return a heterogeneously typed list, or a pair of lists typed as (things that are directories, things that are files).   To be fair, you almost always want to process them differently: recurse (or not) into directories and  read/write/unlink files.   And what happens with exotic things like symlinks or named pipes?   Named pipes and file symlinks are files: you read/write/unlink them, not recurse into them.  Directory symlinks are inconvenient to deal with; many unix commands have special flags to recurse into them or not. So they should be categorized according to such a flag."
haskell,3bazgv,roche,2,Sun Jun 28 10:48:56 2015 UTC,"A similar argument was brought up internally when I presented it to the team, which was initially skeptical. (Concerns were that having a ""path"" meant that a thing existed on the filesystem and could be deleted or moved at any time.)  My response was and is that it's not supposed to be modelling the state of the current world, that's definitely an unrealistic goal (nor really worth pursuing IMO), and now that other members of the team have been using it in practice, they've had no trouble shaking this notion.  We already have such a directory listing function that returns a tuple, the overhead in exchange for type information is a fair trade-off. How often do you want to look in a directory but don't care what type the things are? To count them or something? Produce a checksum of the filenames? In which case you don't even need the path strings to enter your program's data structures, there's nothing semantic about them (and therefore wouldn't want a Path type for them). I'm not saying it never happens, but the usual case is pretty worth it.   The distinction isn't just ""don't accidentally append file </> dir or file </> file"" (which is of course handy) but the overall guiding of program writing.  Symlinks and pipes are a concept in the filesystem, but not in path formatting; there's nothing structurally distinguishing about paths that point to them that differs to regular files, so there's nothing worth modelling differently there.  Maybe it might mislead some newbies into thinking a Path is a resource rather than an address, but I think after using it that becomes obviously false."
haskell,3bazgv,augustss,36,Sun Jun 28 12:33:43 2015 UTC,Why do people keep rejecting '/' as a delimiter on Windows?  It has worked since the DOS days.
haskell,3bazgv,RyanGlScott,6,Sat Jun 27 15:38:00 2015 UTC,"I'm tempted to file an issue, but the GitHub repo has no issue tracker. :("
haskell,3bazgv,tejon,4,Sat Jun 27 18:47:47 2015 UTC,"Well what do you know, it does -- when quoted. TIL.  Leave off the quotes and it tends to be interpreted as delimiting a switch, which is probably why this isn't common knowledge (it's certainly why I never considered the possibility).  C:\>dir windows/system32 Parameter format not correct - ""system32"".   But dir ""windows/system32"" works, so hey."
haskell,3bazgv,augustss,19,Sat Jun 27 19:50:59 2015 UTC,"I'm talking about system calls, not the terrible command interpreter."
haskell,3bazgv,funshine,11,Sat Jun 27 21:00:46 2015 UTC,(</>) :: Path b Dir -> Path Rel t -> Path b t   YES!!!
haskell,3bazgv,RedLambda,14,Sat Jun 27 18:42:50 2015 UTC,"I wonder how \\servername\sharename\folder or C:\folder is represented then, and whether \folder constitutes a Path Abs _ or a Path Rel _, and whether ""\\servername"" </> ""\sharename"" </> ""\folder"" typechecks at all..."
haskell,3bazgv,ozgurakgun,9,Sat Jun 27 19:12:37 2015 UTC,"Perhaps ironically (and unless I am missing something) the link to ""stack"" on this article is wrong. And a similar technique could have helped avoiding this bug! :)  The current html is:   <a href=""github.com/fpco/stack"">stack</a>   Which is a relative hyperlink, and will take you to http://chrisdone.com/posts/github.com/fpco/stack instead of the intended http://github.com/fpco/stack."
haskell,3bazgv,benmos,5,Sat Jun 27 18:06:14 2015 UTC,"Thanks, that's a side-effect of modern browsers and their clever idea of showing www.reddit.com instead of http://www.reddit.com. When you copy-paste, it includes the schema in your clibpoard. Except when it doesn't. This was one of those doesn't times. :-)"
haskell,3bazgv,_AndrewC_,7,Sun Jun 28 12:38:42 2015 UTC,Glad to see someone else pick up this idea and run with it. I think it'd be great if we could standardise on something like this.
haskell,3bazgv,multivector,0,Sat Jun 27 14:26:19 2015 UTC,"Hehe. Some folk have a talent for saying what I mean to say, but in a tenth of the words. Seems I need to switch from OO English to pure FP English."
haskell,3bazgv,Kautiontape,2,Sat Jun 27 15:01:19 2015 UTC,"You've got me wondering what OO English and FP English even are, which is inconvenient because I'm not sure there's a meaningful answer to that..."
haskell,3bazgv,_AndrewC_,3,Sat Jun 27 16:24:15 2015 UTC,"OO English: Words are divided into a hierarchy, with each level being more specific to the level above it (e.g.: Red and Blue both extend from the Color word). Some words are polymorphic depending on context (e.g.: Bash could mean Hit or Party). Words can be modified to directly modify that word / sentence permanently. (""I like Red cars"" makes the context of the conversation about how other color cars are not good, but ""I like cars"" is the opposite) Structure is relatively arbitrary and the order of many words is irrelevant, and not every word in a sentence is completely necessary but doesn't hurt the meaning of the sentence (you, like, know what I mean, right?).   Functional English: Conversation is made up sentences that are derived from concisely defined atomic words. Words themselves have an explicit definition that is used as a modifier to the other words in a sentence. Hierarchy only exists as a categorization method, but vagueness is not allowed without using a particular modifier (Some Color flower). Words are never ambiguous, and any word reuse from language extension must be explicitly defined (""I enjoyed fun bash""). Structure is important and relevant to the understanding of the sentence, and extraneous words manipulate the meaning.   That's my attempt at it. I think we are definitely object oriented with language as a society, because a functional language would require a less fluid and more rigid definition. Plus, everyone would have to think of sentences in their entirety, so stream of consciousness is less viable, and language growth would be incredibly difficult."
haskell,3bazgv,tomejaguar,15,Sat Jun 27 17:34:50 2015 UTC,My meaning was more on the lines of :  description Haskell.English     is        terse       clear       esoteric     isn't       vague   whereas  Public class Object.Oriented.English extends Language.Fictional; implements Description;{     self.language.is {         frequency.approximate.sometimes (verbose logic.conjunction.and syntax-laden)               .modifer.degree(to_the_point_where)                .consequence.frequency.subfrequency(previous.sometimes(sometimes)) {                   language.clarity.obscured();              };     };       point.qualifier.however.admittedly {            language.Non_Fictional.English(language.context.spoken                                                          logic.conjunction.or                                                          language.context.written){                 attribute.feature.blessing(reason{                          poetic;                           logic.conjunction.and                           people's.nature.matches(it.modifier.closely);                 });                 logic.conjunction.both                  attribute.feature.curse(                        reason frequency.approximate.sometimes(language.clarity.unclear)                 );             }.language.meaning.ambiguous;      } };
haskell,3bazgv,_AndrewC_,5,Sat Jun 27 19:17:27 2015 UTC,This is a work of art.
haskell,3bazgv,_AndrewC_,1 point,Sat Jun 27 20:40:08 2015 UTC,Object Oriented English and pure Functional Programming English. My haskell programs tend to be about a tenth of the length of the same functionality in OO.
haskell,3bazgv,_AndrewC_,7,Sat Jun 27 16:34:11 2015 UTC,"Nice.   How would you feel about this and filepath being used as part of the proposed strongly typed FilePath? IIRC that has an IsString instance, though, which you point out can be a mistake, but using your path package under the hood should surely lead to useful benefits for everyone, without the need to wrap and unwrap the newtypes.   I suppose the slight distance allows folk to choose between complete freedom and careful construction, but complete freedom isn't always what it's cracked up to be, as our dynamically typed friends sometimes find.   (The only fly in the ointment might be that Abs and Rel could potentially cause name bumps if they came with base, whereas AbsPath and RelPath are clunkier.)   Thinking out loud as you post to the Internet is perhaps not always the best plan, but I'm coming to think that you'll see benefits to keeping the types here separate from the proposed FilePath.   I quite like the idea of being able to use some of filepath's combinators directly with your package, with automatic wrapping and unwrapping plus normalisation without me saying so explicitly."
haskell,3bazgv,roche,4,Sat Jun 27 14:55:57 2015 UTC,I'm in favour of leaving that proposal as is and not complicating it with additional type-safety ideas. Said elsewhere.
haskell,3bazgv,snoyberg,1 point,Sun Jun 28 12:37:03 2015 UTC,OK fair enough.
haskell,3bazgv,drb226,6,Sun Jun 28 15:42:55 2015 UTC,"How do you accept either an absolute or a relative path in your program?  After all, that's the point of relative paths. If I'm in /etc, I (the user) should be able to say both  ls /etc/nginx   and  ls nginx"
haskell,3bazgv,roche,7,Sat Jun 27 19:14:37 2015 UTC,Typically we do something like canonicalizePath and then treat it as an absolute path.
haskell,3bazgv,drb226,2,Sat Jun 27 21:39:09 2015 UTC,Leave it parametric in that type parameter.  fileExists :: Path x File -> IO Bool
haskell,3bazgv,_AndrewC_,5,Sat Jun 27 19:19:46 2015 UTC,"That works for the negative position. But in a program, you need to parse a String (obtained from getArgs) to something like  data APath = forall x . APath (Path x File)   which you would then pass to fileExists. I don't see this supported directly in the API. Sure, you can combine parseAbsFile and parseRelFile, but this requires extra effort and a conscious decision. OTOH, when using the POSIX API, the right thing happens automatically."
haskell,3bazgv,nikita-volkov,3,Sat Jun 27 20:12:58 2015 UTC,"You are correct, the Path library doesn't support this case very well (where you want a single value to represent either an absolute file or a relative file). The way I'd handle this is generally try and parse as rel file, if it works, then resolve the relative file against whatever directory it is relative to, so that ultimately I end up with an absolute file either way."
haskell,3bazgv,Taladar,2,Sun Jun 28 06:42:50 2015 UTC,"When using unix, the right thing happens automatically! Nevertheless, my world is a windows world. Maybe Microsoft will one day embrace-and-extend unix certification, but not for now."
haskell,3bazgv,maxigit,2,Sun Jun 28 01:00:10 2015 UTC,"While unfortunately I tend to agree with Bryan's opinion, it's still important that we don't settle with the way things currently are, when the suboptimal ""filepath"" package is the default approach. IMO we need to keep digging in search for the best practical solution and this package and ideas behind it is a good investment into that search, but I can't consider it the solution.  BTW, it looks like a part of this library could be abstracted over using the ""refined"" package, that is including the Template Haskell functionality."
haskell,3bazgv,Taladar,3,Sun Jun 28 05:39:22 2015 UTC,"Why only File and Dir? Why not add at least Link as a type since that should be supported in some form on most platforms by now.  I could also see socket, pipe, character and block devices as additional types on UNIX platforms so it might make sense to make types for those part of the library even if the library isn't doing anything with them itself, just so you don't get half a dozen locally defined, incompatible types for that purpose."
haskell,3bazgv,maxigit,5,Sat Jun 27 16:12:15 2015 UTC,Probably because the difference between files and those is somehow irrelevant.
haskell,3bazgv,Taladar,2,Sat Jun 27 17:31:24 2015 UTC,The distinction between link and non-link is often am important security and termination concern.
haskell,3bazgv,hiptobecubic,1 point,Sun Jun 28 10:49:48 2015 UTC,"Ok, but I'm not sure it has to be statically checked. For example my .vimrc is a link to .dotfiles/vimrc. If you make a distinction at the type level between link and non-link you won't be able to load my file because parseRelNonLink "".vimrc"" will fail.   What's is the point ? By doing so, you make links unusable and dismiss the whole point of links. If you really have security concerns, it's probably easier to either test it dynamically or forbid links at the OS level."
haskell,3bazgv,yitz,2,Sun Jun 28 11:23:57 2015 UTC,"This probably means Links should be a third axis, not part of the file/directory distinction.  The point of checking if something is a link is that symlinks can be used to trick programs that run with more privileges into overwriting important files the user would otherwise be unable to access.  The other point is that you should avoid traversing symlinks repeatedly (or at all) when doing recursive directory traversal since it can lead to infinite loops."
haskell,3bazgv,abaquis,5,Sun Jun 28 15:03:45 2015 UTC,Indeed. Although it stops being cross platform if you include POSIX-only stuff.
haskell,3bazgv,tomejaguar,3,Sat Jun 27 17:34:03 2015 UTC,"One thing I would need is a way to specify which version of filepath to use - not necessarily the one corresponding to the OS I happen to be running on currently. With filepath itself I can import whichever one I need. But path seems to hard-wire using the version for the current OS, unless I am missing something."
haskell,3bazgv,joehillen,2,Sat Jun 27 22:35:39 2015 UTC,Looks very useful. Thanks for implementing it and sharing.
haskell,3bazgv,logicchains,3,Sat Jun 27 14:33:44 2015 UTC,"Nice work Chris.  But whilst I'm on the subject I'll have a mini rant:  The filesystem is a horrible, stateful, imperative relic of a bygone era.  Let's have a functional, immutable, shared datastore yesterday, please."
haskell,3bazgv,sambocyn,5,Sat Jun 27 21:17:29 2015 UTC,It's not a bygone era if there is no modern replacement.
haskell,3bazgv,sacundim,3,Sun Jun 28 05:00:54 2015 UTC,Irmin?
haskell,3bazgv,tomejaguar,3,Sun Jun 28 04:45:23 2015 UTC,what would that look like?
haskell,3bazgv,phischu,3,Sat Jun 27 22:37:23 2015 UTC,"Kafka is an interesting idea somewhere in this space, though it's not so much ""immutable"" as append-only..."
haskell,3bazgv,rstd,2,Sat Jun 27 23:58:44 2015 UTC,"The summary is ""algebraic datatype database"".  It would look roughly like the heap of a functional programming language.  See also: http://www.reddit.com/r/haskell/comments/35x9e4/the_future_of_systemfilepath_and_systemfileio/cr92ijp"
haskell,3bazgv,Tekmo,2,Sun Jun 28 07:52:17 2015 UTC,Maybe like ipfs.
haskell,3bazgv,jaybee,1 point,Mon Jun 29 14:14:50 2015 UTC,"Lol, immutable datastore. Like a read-only filesystem? Also, what makes a data store functional?"
haskell,3bazgv,mightybyte,3,Sat Jun 27 22:38:21 2015 UTC,"Simple example: imagine that your shell was like a ghci REPL, and if you wrote:  > f = (+ 1)   ... that created an immutable file named f representing the function (+ 1).  Then if you wrote:  > x = 3   ... that creates an immutable file named x whose contents were the number 3.  Then you could write:  > f x 4   ... and it would apply the function stored in the file named f to the value stored in the file named x"
haskell,3bbp7v,qZeta,4,Sat Jun 27 18:11:34 2015 UTC,"is cross-compiling Haskell projects with dependencies a mess?   I could be missing something, but this has been my experience. I gave up on cross compiling and have been using docker containers for compiling to arm for instance."
haskell,3bbp7v,codygman,4,Sat Jun 27 22:30:09 2015 UTC,"using docker containers for compiling to arm   Please, tell me more..."
haskell,3bbp7v,SkippyDeluxe,5,Sun Jun 28 04:04:42 2015 UTC,I just use this:  https://github.com/sseefried/docker-build-ghc-android
haskell,3bbp7v,codygman,3,Sun Jun 28 05:04:53 2015 UTC,"Hm, interesting. I wonder how much work it would be to create a similar one for Raspberry Pi. Guess I need to learn Docker..."
haskell,3bbp7v,SkippyDeluxe,2,Sun Jun 28 07:05:20 2015 UTC,"Docker's pretty easy. You have a Dockerfile, a text file that says what the container will look like.  Then, you install that image description with docker build -t=myImageName ., run that where the Dockerfile is.  Running a container is done with docker run -i -t myImageName. -i stands for interactive and -t provides a TTY."
haskell,3bbp7v,beerdude26,4,Mon Jun 29 07:28:35 2015 UTC,"Yeah, I had a look over the weekend. I found an image here that almost did what I need. Then I managed to build a raspi cross-compiler by swapping out the Android toolchain with the one here. Worked like a charm!  Guess I should push the image publicly at some point."
haskell,3bbp7v,SkippyDeluxe,3,Mon Jun 29 14:48:34 2015 UTC,Nice! Definitely put it on Github.
haskell,3bbp7v,beerdude26,3,Mon Jun 29 14:56:43 2015 UTC,"Doesn't this just build a cross-compiling ghc? Don't you still run into the problem where cabal chokes because it can't run the binary compiled from Setup.hs in each package?  My solution: I have locally a quad-core cortex-a9 ARM host (Utilite Pro) with a 32GB SSD; I got it for about $150. It's reasonably fast at compiling (ghc took only a few hours). Instead of cross-compiling, I maintain a armv6j chroot environment (just a gentoo stage3 tarball), since armv6j (rpi) binaries run on the armv7a-hardfloat architecture without the need for any translation.  Ideal solution, allowing for the use of a faster cross-compiling ghc like in Docker: Cabal is close to being able to cross-compile. It needs a relatively small set of changes to allow you to give cabal the correct toolchain for cross-compilation. Supposedly, these are somewhere in https://github.com/sheyll/cabal , but I haven't succeeded in find the command line options the author mentions here: https://github.com/haskell/cabal/issues/1493"
haskell,3bbp7v,Keb_,2,Mon Jun 29 12:14:38 2015 UTC,"I'm not sure whether the author still works on the cabal fix. I would take matters in my own hand, but I don't have the time nor the wisdom to add the --with-host-* functionality to cabal-install :(."
haskell,3bbp7v,codygman,1 point,Mon Jun 29 13:24:14 2015 UTC,I never did anything complicated with it and just used GHC.
haskell,3bbp7v,SkippyDeluxe,3,Mon Jun 29 18:13:49 2015 UTC,"Did the hack mentioned in the first post of that issue not work for you (using the cached setup binary)? I struggled for a long time to build a cross-compiler from OS X to Raspberry Pi. When I finally got a working stage1 I ran into the same issue you did, found the same post, and managed to get a little further by following that advice. But shortly after I hit another snag, where all but the simplest packages refused to build. I seem to remember it had something to do with cpphs...? I wonder if I still have those notes around somewhere..."
haskell,3bbp7v,SkippyDeluxe,3,Sun Jun 28 04:00:57 2015 UTC,"Did the hack mentioned in the first post of that issue not work for you (using the cached setup binary)?   Sure, that worked, but it's rather annoying, see my original question in /r/haskellquestions:   Or do I have to get every package (and its dependencies) by hand, compile the Setup.hs, configure it with the correct gcc and ghc and install it into my application's sandbox? That would be quite cumbersome, and would probably take more time than to rewrite my application in Python.   Especially if your dependency graph isn't just a bunch of isolated nodes."
haskell,3bbp7v,garethrowlands,1 point,Sun Jun 28 06:46:48 2015 UTC,"Agreed, it is annoying. Sorry, I don't know of a better way."
haskell,3bawvw,eegreg,5,Sat Jun 27 13:42:04 2015 UTC,So true. Especially figuring out how to run ghci in multi-cabal file sandboxed project.
haskell,3bawvw,esmolanka,5,Sat Jun 27 14:36:03 2015 UTC,"If I'm reading the blog post right, congrats to Greg on the new job!"
haskell,3bawvw,MaxGabriel,2,Sat Jun 27 22:24:20 2015 UTC,"Yeah, Greg, nice gig you got yourself there ;)"
haskell,3bad7g,b00thead,11,Sat Jun 27 08:20:38 2015 UTC,Oh and GHCJSi as well! Interesting times ahead :-)
haskell,3bad7g,luite2,4,Sat Jun 27 08:21:20 2015 UTC,"But a GHCJSi release is almost certainly coming later than Stack integration, since it's really just a proof of concept. There's lots of missing functionality and code to be cleaned up. Although admittedly it's hard to resist the temptation to work on GHCJSi rather than on things that need to be fixed for the GHCJS release."
haskell,3bad7g,Crandom,4,Sat Jun 27 22:30:45 2015 UTC,"It's a ""later improvement"" and needs to wait on 7.10.2 so I wouldn't hold your breath."
haskell,3bad7g,martingalemeasure,7,Sat Jun 27 08:42:12 2015 UTC,"I was under the impression that 7.10.2 was ""any day now""?"
haskell,3bad7g,radix,6,Sat Jun 27 15:27:14 2015 UTC,"Yeah, not only is 7.10.2 going to be released very soon, Stack's development has been going SUPER fast: https://github.com/commercialhaskell/stack/pulse"
haskell,3bad7g,snoyberg,4,Sat Jun 27 16:35:28 2015 UTC,There are a few stack contributors excited to see this happen soon. We already have some support via a stack Docker image that bundles GHCJS. I'm hopeful that this will happen quickly. The milestone placement means that this feature won't block any releases.
haskell,3bad7g,Crandom,7,Sat Jun 27 18:31:44 2015 UTC,Fantastic!   PS: Stack is great. I can only do haskell in the spare 20 mins or so I have every so often - I now actually build way more stuff as those 20 mins aren't taken up trying to get cabal-install install to do what I want.
haskell,3bbji4,HighCode,3,Sat Jun 27 17:21:30 2015 UTC,"ghc-mod is used in an editor, see for example http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html for the use inside emacs. There is the possibility to use it via vim, sublime-text and atom, I think. There may be others. What is your setup?  ps. Unless you're trying to write a library which uses it, but I don't think that's the case."
haskell,3bbji4,meditans,2,Sat Jun 27 19:17:41 2015 UTC,"Well, I know that it is used by editors, though you can run it also from command prompt. I need to see some examples where it is run by command prompt over some Haskell source files."
haskell,3bbji4,meditans,2,Sat Jun 27 21:40:59 2015 UTC,"Ok, so I tried to use it via command line, using the syntax here http://www.mew.org/~kazu/proj/ghc-mod/en/ghc-mod.html  It seems to work for me (but I'm using linux). I tried the ghc-mod type command on a single file:  [meditans@localhost snippets]$ ghc-mod type listMonad.hs Main 9 1 9 1 12 15 ""[(Int, Char)]""   Is ghc-mod --help working for you?"
haskell,3b6vtp,simonmar,22,Fri Jun 26 13:27:14 2015 UTC,Would love to hear more about code hot-swapping.
haskell,3b6vtp,jberryman,38,Fri Jun 26 13:50:26 2015 UTC,"What I should do at some point is put together a bare-bones working example to show how it's done.  There's not a lot to it, but some of the details are a bit fiddly to get right, for example you have to link everything below the Haskell code with special linker options to expose all the symbols."
haskell,3b6vtp,kraml,6,Fri Jun 26 14:15:14 2015 UTC,"Excuse my beginner question, but I think I am missing something. Why do you use code hot swapping instead of simply shutting down the running process and start the new version? If you have many instances running, there is no downtime."
haskell,3b6vtp,JonCoens,7,Sat Jun 27 12:06:40 2015 UTC,Not all servers start up or shut down in trivial amounts of time. The costs of shutting down + starting up a Sigma server multiplied by the number of times we'd need to do it in a day make it a first-order problem.
haskell,3b6vtp,cameleon,9,Sat Jun 27 17:08:45 2015 UTC,"Nice post! You say:   We're careful to ensure that we don't change any code associated with persistent state in Sigma.   Does this mean you don't change the data format of persistent state at all? Or do you have some way to migrate it? And is this just ensured by careful programming, or do you use types somehow to enforce this?"
haskell,3b6vtp,CharlesStain,22,Fri Jun 26 15:18:53 2015 UTC,"There's a clear boundary between the code that doesn't change and the code we can swap - they're in different repositories - and the code we swap doesn't have any persistent state.  We typically restart the processes once a week or so to roll out new server code, and when we do that we can change any of the code, including the persistent state representation."
haskell,3b6vtp,augustss,8,Fri Jun 26 15:24:46 2015 UTC,"Haskell's FFI is designed to call C rather than C++, so calling C++ requires an intermediate C layer. In most cases, we were able to avoid the intermediate C layer by using a compile-time tool that demangles C++ function names so they can be called directly from Haskell.   Tell us more! :) Is such tool open-sourced anywhere?"
haskell,3b6vtp,augustss,11,Fri Jun 26 19:38:01 2015 UTC,"It's a simple bit of Haskell code that turns a C++ type into the mangled name, we call it from hsc2hs at compile-time.  Open-sourcing it is on our roadmap, but I can't tell you exactly when we'll get to it (hopefully soon)."
haskell,3b6vtp,ethelward,6,Fri Jun 26 19:59:42 2015 UTC,Why couldn't you modify the C++ to export C symbols?  That's what we do.
haskell,3b6vtp,augustss,5,Fri Jun 26 21:39:14 2015 UTC,"We started off doing that, but often it meant writing an extra C layer on top of the C++.  Calling C++ directly got rid of a fair bit of boilerplate."
haskell,3b6vtp,deech,7,Fri Jun 26 22:06:00 2015 UTC,"Using extern ""C"" was not enough?"
haskell,3b6vtp,danharaj,5,Fri Jun 26 22:47:38 2015 UTC,"I'm not sure extern ""C"" is enough when you have to deal with objects. Non-static methods always takes this as an hidden argument and I'm not sure it works so easily. More here."
haskell,3b6vtp,conklech,4,Fri Jun 26 23:09:31 2015 UTC,"No, if you're dealing with objects you need more than extern C."
haskell,3b6vtp,rdfox,5,Fri Jun 26 23:25:44 2015 UTC,"Most of the C++ code we need to call uses classes, so extern ""C"" doesn't work.  With the mangler tool we can directly call C++ class methods from Haskell (you have to pass this explicitly in Haskell, of course)."
haskell,3b6vtp,beerdude26,2,Sat Jun 27 05:40:41 2015 UTC,Does it depend on a compiler?   I'm not a C++ expert but TMK each C++ compiler is free to mangle however it pleases since that's not standardized.
haskell,3b6vtp,marlowrt,3,Sat Jun 27 13:24:32 2015 UTC,"Our tool implements the Itanium ABI name mangling scheme, which (I believe) is used by gcc, clang, and the Intel compiler on x86-64.  I'm sure someone will correct me if I'm wrong..."
haskell,3b6vtp,JonCoens,10,Sat Jun 27 16:21:00 2015 UTC,"I find the interaction with GHC particularly interesting. Was modifying GHC a practical way to solve problems because GHC is easy to hack on, or did your team rely on your thorough knowledge of the RTS to get things done effectively?"
haskell,3b6vtp,drb226,4,Fri Jun 26 18:10:25 2015 UTC,I don't think they mention (although you may know) that /u/simonmar was for a long time one of the principal GHC developers. Their experience will have been unusual in that respect.
haskell,3b6vtp,swingtheory,4,Sat Jun 27 00:26:11 2015 UTC,I'd sure like to hear more about that hot code loading. I didn't know we could do that. C++ mangling is another cool idea. I can work out how to do that I guess. But the hot code loading makes me want to go work for Facebook and quit my first day after I get my filthy hands on that technology.
haskell,3b6vtp,AIDS_Pizza,2,Sat Jun 27 04:10:15 2015 UTC,Check out the plugins and the hotswap packages :)
haskell,3b6vtp,jkozlowski,4,Tue Jun 30 07:06:28 2015 UTC,Can anyone involved speak to what sort of dev environment they use? Kinda curious what people being paid to write Haskell use.
haskell,3b6vtp,sambocyn,8,Fri Jun 26 18:37:06 2015 UTC,This project's development was done via Linux command line tooling. The developers were using their favorite flavor of emacs/vim and building using Facebook's build tool-chain.
haskell,3b9vix,codygman,8,Sat Jun 27 04:21:34 2015 UTC,"One possibility for making the queries faster (possibly unfair):  https://nikita-volkov.github.io/hasql-benchmarks/  A suggestion for next time: If you want anybody to poke at your benchmarks, I would strongly suggest having a git repo with a working build of every program ready to go and a script for running the benches.  Manually copying the Haskell code over and making a Cabal project scaffold, filling out the dependencies, etc. has cost me at least 15 minutes so far.  Edit: yeah, build is breaking. no idea what version of the mysql library you're using, no way to reproduce your results. Here's the build error I got:  wai-simple.hs:19:3: Not in scope: ‘MySQL.initLibrary’ wai-simple.hs:23:9: Not in scope: ‘MySQL.initThread’"
haskell,3b9vix,Mob_Of_One,3,Sat Jun 27 05:38:47 2015 UTC,"I'll definitely put it in a bit repo tomorrow, sorry about that."
haskell,3b9vix,emarshall85,3,Sat Jun 27 08:29:21 2015 UTC,Isn't hasql postgresql only? These seem to be MySQL benchmarks.
haskell,3b9vix,agrafix,1 point,Sat Jun 27 15:48:37 2015 UTC,"yes, it's pg only"
haskell,3b9vix,Mob_Of_One,1 point,Sat Jun 27 16:21:15 2015 UTC,"Yeah, it seems my only option in this case would be to make a hasql mysql binding or improve the persistent mysql binding in addition to the other suggestions in this thread."
haskell,3b9vix,agrafix,1 point,Sat Jun 27 17:59:42 2015 UTC,"Nuts, I thought it was both. :("
haskell,3b9vix,pursuit92,2,Sun Jun 28 04:21:57 2015 UTC,Here is a repo with a working build of the Haskell parts and a link to the repo with the Go stuff:  https://github.com/codygman/haskell-vs-go-rest
haskell,3b9vix,Taladar,5,Sat Jun 27 19:00:23 2015 UTC,Looks like theres something wrong with the martini part?   Non-2xx or 3xx responses: 164388
haskell,3b9vix,Taladar,1 point,Sat Jun 27 16:01:58 2015 UTC,Thanks I'll look into that.
haskell,3b9vix,lukerandall,2,Sat Jun 27 16:12:43 2015 UTC,Martini probably isn't the best framework to be benchmarking against - its been pretty much universally shunned by the Go community due to being very un-idiomatic and not very performant.
haskell,3b94w0,RivtenGray,9,Fri Jun 26 23:58:41 2015 UTC,"It's worth noting that that example is not real quicksort -- quicksort works in-place on an array, and uses mutation, whereas that algorithm is not in-place, it works on a list, and does not use mutation. (They do appear to acknowledge this, by referring to the C version they reproduce as ""true"" quicksort). See also this stackoverflow question.  Having said that: while the Haskell implementations of ""true"" quicksort they give on that SO question are certainly not as pleasing as the ""false"" one, I would still hugely prefer maintaining one of those to the one in C.  I can't actually think of an example where I'd prefer an OOP language to Haskell. Perhaps that's because I've drunk too much of the FP kool-aid, or because I just haven't used an OOP language for such a long time, or because I think OOP is a terrible idea."
haskell,3b94w0,hdgarrood,6,Sat Jun 27 01:56:38 2015 UTC,Try making a real-time strategy game (like Starcraft) in Haskell.  That's my current challenge.
haskell,3b94w0,Agitates,12,Sat Jun 27 02:37:33 2015 UTC,"I have some experience using FP for games progamming (see https://github.com/hdgarrood/multipac - it's PureScript, but we can safely ignore differences between PureScript and Haskell for purposes of this discussion, I think).  While it would initially seem that FP doesn't work well (""I have lots of objects that can each create new objects and mutate or destroy other objects all the time"") there is at least one solution that seems to work well enough: first define a data type representing all the ways the game's state can be updated (eg ""points awarded to player"", ""powerup consumed by player"", ""player killed""), then define a function getUpdates :: PlayerInput -> GameState -> [GameUpdate] which calculates what updates need applying, and a function applyUpdates :: [GameUpdate] -> GameState -> GameState which applies them all, and finally put the GameState in a mutable variable and write a little game loop.  Notably, we now have a program with just one mutable variable, which is a lovely position to be in.  There is also FRP, which seems more principled, and possibly better suited to larger systems; I can certainly imagine the above getting spaghetti-y. I haven't given that a real go yet, though.  My experience is that it's very good that Haskell stops you from going ""well, fuck it; let anything mutate anything else at any time"" because code like that is an absolute nightmare to debug when it goes wrong. Haskell usually nudges you in the direction of to coming up with a coherent model for your program early, rather than diving in and creating a mountain of crap before you realise what's happened."
haskell,3b94w0,hdgarrood,5,Sat Jun 27 02:50:56 2015 UTC,"I know how to make a game using FP. That's not the problem. The problem is making it performant.  For instance, a well known optimization technique is to use a struct of arrays rather than an array of structs. This is impossible in Haskell without using IO everywhere."
haskell,3b94w0,Agitates,9,Sat Jun 27 03:14:29 2015 UTC,The vector library does strict of arrays in pure code.  It's far from impossible.
haskell,3b94w0,sacundim,3,Sat Jun 27 20:07:03 2015 UTC,How does the struct of arrays rather than array of structs optimization make things faster?
haskell,3b94w0,codygman,12,Sat Jun 27 04:30:49 2015 UTC,"http://gamedevelopment.tutsplus.com/articles/what-is-data-oriented-game-engine-design--cms-21052  The principle is to design your data (and their layout) by how data is transformed in the program, rather than by some other organizing principle1 . So if you have entities with three attributes, and each one of those attributes are updated/transformed in bulk, then you might want to make an array for each of those attributes in isolation so that you can iterate over them with better cache locality.  1 As opposed to the more common organizing principle, which is to tie things that are logically connected together, such as by making an entity record/struct with all the attributes of that thing."
haskell,3b94w0,jeandem,5,Sat Jun 27 09:38:56 2015 UTC,Would a Haskell data type of mutable arrays accomplish the same cache locality?
haskell,3b94w0,codygman,10,Sat Jun 27 15:51:21 2015 UTC,Better for the cache.
haskell,3b94w0,sccrstud92,2,Sat Jun 27 05:37:53 2015 UTC,"Ah, fair enough then. I never got into a position where performance was causing much of a problem in a game I was working on, neither in Haskell nor any OO/imperative language, so I suppose I can't really add anything here. The closest I got to really worrying about performance was when some of my rendering code was very slow, but then I rewrote that particular bit in JavaScript using the FFI, and everything was OK again."
haskell,3b94w0,hdgarrood,1 point,Sat Jun 27 03:53:17 2015 UTC,What is wrong with a record of vectors?
haskell,3b94w0,sccrstud92,1 point,Sat Jun 27 05:38:48 2015 UTC,I worded that poorly. You really just can't use arrays/vectors in general in Haskell if you need to make lots of minor changes in sequence.
haskell,3b94w0,Agitates,5,Sat Jun 27 06:07:32 2015 UTC,You mean without a mutation type like ST or IO?
haskell,3b94w0,sccrstud92,5,Sat Jun 27 06:38:46 2015 UTC,I don't get it.  Why not?
haskell,3b94w0,tomejaguar,2,Sat Jun 27 07:29:05 2015 UTC,"Because every change will require you copying the entire vector again.  You have to use mutable vectors and IO everywhere if you want to try struct of arrays. Doing simple benchmarks with vectors (like adding 1 to each element), Haskell is always about 3 times slower than C. That's not bad, per se, but for performance critical games, it's not encouraging."
haskell,3b94w0,Agitates,-3,Sat Jun 27 08:03:22 2015 UTC,(╯ಠ_ಠ）╯︵ ┻━┻
haskell,3b94w0,I_Like_Spaghetti,15,Sat Jun 27 02:53:05 2015 UTC,┬─┬ノ(ಠ_ಠノ)
haskell,3b94w0,PleaseRespectTables,4,Sat Jun 27 02:53:31 2015 UTC,This bot had damn well better be written in Haskell.
haskell,3b94w0,tejon,6,Sat Jun 27 21:21:29 2015 UTC,"Real time strategy probably wouldn't be that hard in Haskell, since the graphics requirements wouldn't be that high.  A modern FPS shooter on the other hand... there's a reason C and C++ utterly dominate game development. There is simply nothing else that can compete when it comes to bare to the metal performance. Perhaps Rust, but it's too early to tell.   Haskell holds its own very well in language benchmarks, but C++ isn't going to be knocked off that perch any time soon."
haskell,3b94w0,zoomzoom83,3,Sat Jun 27 18:01:15 2015 UTC,Didn't John Carmack attempt to write a game in Haskell at one point? What happened with that?
haskell,3b94w0,yen223,6,Sat Jun 27 08:32:43 2015 UTC,"Had too much other things on his head. He did, however, realize that he can translate many of the things he learned from that experiment to other game projects even in a non-functional programming language.  GamaSutra article  Relevant part of his keynote"
haskell,3b94w0,Soul-Burn,3,Sat Jun 27 09:09:15 2015 UTC,"I'm no gamedev, but graphics-intensive games need manual memory management, no? it's not even just about mutation.  like write Starcraft in an OOP language like Java."
haskell,3b94w0,sambocyn,15,Sat Jun 27 23:26:28 2015 UTC,I'm not a super experienced Haskell programmer but it seems to be ill-suited to systems-level programming (like firmware stuff). Aside from that it's definitely sometimes necessary to use different data structures or algorithms than you use in imperative programming but I can't really help with examples. There's a pretty famous book on functional data structures here that might be worth looking at.
haskell,3b94w0,ganderso,11,Sat Jun 27 00:35:20 2015 UTC,"A fork of JHC was used to run Haskell code on a microcontroller, and implement an audio driver for NetBSD. Unfortunately the project was shut down, so it's more interesting than an example of suitability. http://ajhc.metasepi.org/"
haskell,3b94w0,absence3,7,Sat Jun 27 07:28:13 2015 UTC,I believe the author started using ATS instead.
haskell,3b94w0,codygman,6,Sat Jun 27 15:49:22 2015 UTC,"I mean of course you can write low level code in Haskell. You can do pretty much anything in any language. But you could also write a text editor in J, that doesn't mean it would be a good idea."
haskell,3b94w0,ganderso,4,Sat Jun 27 14:08:58 2015 UTC,One example of a data structure that doesn't work as well in Haskell is the disjoint-set data structure.
haskell,3b94w0,tavianator,3,Sat Jun 27 20:20:17 2015 UTC,disjoint-set data structure   Why do you think this doesn't work well in Haskell? Just because the traditional description of an algorithm or data structure happens to be in terms of imperative languages doesn't mean that something analogous couldn't be done in a purely functional language as well.
haskell,3b94w0,yitz,5,Sat Jun 27 23:10:23 2015 UTC,"Because the mutability is necessary for the performance (effectively constant membership test and union), which is the biggest selling point.  That said, if you can do it in OCaml, you can do it in Haskell, so... [1] (pdf) (slides).  On the other hand, this solution relies on something very much like diff arrays, which were deprecated and then removed from the array library because their performance was never adequate."
haskell,3b94w0,rpglover64,3,Sun Jun 28 12:33:50 2015 UTC,"the mutability is necessary for the performance    Many algorithms were classically described in a way that uses destructive update in what seems to be an essential way. The main reason is that until recently, most authors never really considered the purely functional setting. As far as I know, it is still an open question whether mutability is ever truly necessary for performance.  In the case of the disjoint-set algorithm, there is a hidden factor of O(log n) which is ignored: the algorithm relies on looking up an object in a random-access table of arbitrary size. But that operation has a theoretical optimal complexity of O(log n). Modern computers have built in parallel hardware (""RAM"") which make the operation appear to be O(1), but only if the size of the data fits within a fixed maximum size, so using that for computing asymtotics seems dubious. In any case, if you allow that for the imperative version, then you must certainly also allow the use of STArray and the like in pure Haskell code.  There are implementations on Hackage of the disjoint set algorithm that include the O(log n) lookups explicitly, and others that use imperative-style mutable arrays.  More generally, it is often possible to find an analogous (but different) purely functional algorithm with the same asymtotics as an imperative one. For example, see the derivation in Brodal and Osaki of a purely functional equivalent of Brodal's imperative priority queue algorithm with optimal asymtotics. Those are the same asymptotics as for a fibonacci queue which uses destructive updates in what appears to be an essential way."
haskell,3b94w0,yitz,8,Sun Jun 28 21:36:48 2015 UTC,I think the language itself IS better for pretty much anything. It's more that everything but the language sucks.  In particular when you have to use some cloud service/database/whatever is when it becomes questionable whether the language advantage is worth it. As compared to java for example which has fantastic cloud support/libraries/etc.
haskell,3b94w0,BobbyTabless,16,Sat Jun 27 11:57:08 2015 UTC,"I can. Anywhere that Lua is the best choice, Haskell is the worst. This isn't so much an FP vs OOP thing; Lua is as functional as you want it to be. It's a footprint thing. Shipping an embedded ghci  is about 1000 times bigger than Lua. Also Matlab doesn't need to loose any sleep over Haskell, neither does Excell. Let's not forget R, Julia, SQL or Bash. Basically any system that sacrifices everything else to do one thing well is unbeatable in its domain."
haskell,3b94w0,rdfox,9,Sat Jun 27 04:25:57 2015 UTC,Bash   Bash is an excellent interactive shell language. Now all it needs is to become a usable scripting language.
haskell,3b94w0,jeandem,8,Sat Jun 27 09:42:01 2015 UTC,"Bash is an excellent interactive shell language.   I disagree. It has several major flaws that let it fall short of anything that could be considered excellent.  The history handling is atrocious if you run several shells on the same user and system in parallel, it is missing many of the conveniences more modern shells have introduced (e.g. proper handling of recalling multi-line statements from history, not all condensed into one line),..."
haskell,3b94w0,Taladar,3,Sat Jun 27 16:03:52 2015 UTC,"I don't doubt you; you sound much more experienced than myself. What alternatives would you recommend? I use Linux (Ubuntu), if that matters."
haskell,3b94w0,jeandem,6,Sat Jun 27 16:06:03 2015 UTC,"Well, personally I have been using zsh for years. It has its own flaws but usually it works better than bash for interactive use. One of my coworkers uses fish and likes that one a lot too.  If you regularly work on remote systems via SSH I would also recommend tmux or screen (but if you are going to learn something new try tmux, it is the more active project) to be able to resume sessions if you get disconnected."
haskell,3b94w0,Taladar,1 point,Sat Jun 27 16:20:20 2015 UTC,Why? Why does it need to become that?
haskell,3b94w0,rstd,4,Sat Jun 27 11:49:47 2015 UTC,"It doesn't. It's my indirect way of saying that Bash is a shell language that isn't even good for shell scripts (as in, store-and-call-in-a-file scripts).  It's inspired by that tired old Emacs joke (is a good OS... just needs an editor)."
haskell,3b94w0,jeandem,9,Sat Jun 27 12:01:32 2015 UTC,And that's what spacemacs is for! :)
haskell,3b94w0,rpglover64,1 point,Sat Jun 27 12:26:07 2015 UTC,Blasphemy.
haskell,3b94w0,jeandem,3,Sat Jun 27 14:05:34 2015 UTC,"There was a recent discussion about Haskell, the language, where we tried to find flaws. The language itself is superior, but there is much space for improvement in the environment."
haskell,3b94w0,Vektorweg,3,Sat Jun 27 08:54:03 2015 UTC,"Yes. Oleg Kiselyov's write up about avoiding sharing is such an example. Here's a telling excerpt (emphasis added):   The fix that was supposed to help iterative deepening has made it worse.  Such an unexpected result was quite a puzzle. It seems GHC is just too smart. Apparently it notices that a thunk (\() -> e) can only be applied to the same argument. Therefore, the first time the thunk is forced by applying it to (), the result can justifiably be memoized: the next time around the thunk will be applied to the same (), and hence, will give the same result anyway.  The new fix is to deliberately confuse GHC. We obfuscate the tree-construction operations (>>=) and mplus with auxiliary functions app and app1."
haskell,3b94w0,redxaxder,3,Sun Jun 28 14:55:09 2015 UTC,"If it is just data structures/algorithms we are talking about, I think Haskell has no problem. Whatever mutable data structure you use in C, you can implement in Haskell, with real mutation going under the hood.  And the term ""elegant"" is questionable. Most non-Haskellers do not appreciate monadic side-effect management, but for Haskellers they are fairly elegant."
haskell,3b94w0,terrorjack,10,Sat Jun 27 01:39:59 2015 UTC,"The GC in GHC's runtime system doesn't handle mutable arrays very well, though: http://blog.ezyang.com/2014/05/ghc-and-mutable-arrays-a-dirty-little-secret/"
haskell,3b94w0,hdgarrood,2,Sat Jun 27 01:46:20 2015 UTC,I'd also like to know. I assume it would include games or anything that requires global state.
haskell,3b94w0,fuzzyslippers42,5,Sat Jun 27 02:32:41 2015 UTC,"Global state doesn't have to be a big deal. There are good strategies available. For example, put your global state in an IORef and pass it around in the Reader monad. This is what I do in the game I'm developing."
haskell,3b94w0,stolarj,2,Sat Jun 27 02:45:04 2015 UTC,Why do you use an IORef? Isn't the reader monad by itself enough?
haskell,3b94w0,codygman,3,Sat Jun 27 04:31:29 2015 UTC,Not if you need to mutate the state across threads or through FFI callbacks.
haskell,3b94w0,etrepum,4,Sat Jun 27 04:52:51 2015 UTC,Then ... state monad?  EDIT: Actually this is nonsense.  The state monad doesn't help with threading at all.
haskell,3b94w0,tomejaguar,4,Sat Jun 27 07:22:05 2015 UTC,"It's not enough, for modification you need a state monad and to be able to modify the state from a game loop and from callbacks for key and mouse events you need the IORef.  You can skip the IORef if you poll for events, but this has its own issues."
haskell,3b94w0,dan00,3,Sat Jun 27 10:18:42 2015 UTC,"The obvious answer is the main distinguishing feature of OOP: subtyping.  While you learn to ""program around that"" deficiency - just as you learn to program in objects in OOP -, modelling hierarchies is pretty bothersome and seldom done.  Haskell and Java/C# work from diametrically opposed assumptions: the former sees data as simple, dumb, and transparent, and lets you manipulate it in every way you wish, the latter package data into complex classes that only let you access it via their methods. Both of these strategies are fine as long as you stay within their paradigm, but will feel more light straitjackets if you try to go against them.  I'll give you two examples: one that favours Haskell and one that favours OOP.   String   In Haskell, String = [Char]. You can freely manipulate strings like you do lists. You can take the head, the tail, intersperse some character, take a sublist, take every odd-numbered element, filter, drop, etc. Because the String-manipulating functions are not bound to the String type, you can also write new ones and use them wherever you like. You can also make String an instance of new classes (e.g. Monoid or HasSize). This extensibility coupled with simplicity of data types does wonders for data reuse. First: had data types like [] been closed, they could not have been made instances of Monad or Applicative - things that came along years after Haskell's inception. Second: dumb datatypes without coupled code are very versatile. Because you only have data [] = [] | a : [a] and not EnterpriseArrayList, MyList2, or BufferedList, each outfitted with whatever bits and pieces its writer deigned to give it, the type has a certain universality to it.  It's simple and it can be widely used, without worrying about implementation details.  In Java, String doesn't expose its internal representation (it's an array) and only allows you to access the contents through whatever functions the library's writers considered. Even if you could write a new function by using only String's public interface, you can't bundle it into the String-class. There's no String.tail() and that's that. C# has extension methods to alleviate this problem, but they're just a cheap hack for a fundamental deficiency. Likewise, you can't make an existing class implement new interfaces, even if you have the necessary data. Scala ""solves"" this problem with the pimp-my-library-pattern, wherein you create a new class that implements your desired interface and then create an implicit cast between the old class and your new one.   Taxonomy   The standard example of inheritance is a taxonomy like Animal <- Mammal, Reptile, Mammal <- Cat, Dog, Cow, Reptile <- Snake, Crocodile, Dog <- Labrador, Chihuaha, GoldenRetriever. Animal has makeNoise and needsFood, which each particular animal overrides. In OOP, this scenario can be naturally and easily implemented: make abstract classes Animal, Mammal, and Reptile, and concrete classes Cat,DogCow, etc., and have them inherit. Because all will be a subtype of Animal, you can put different animals into the same list/map/set with no problems and when you call their makeNoise-methods, each animal will make its particular noise again.  One can encode all this in Haskell, but it's damn inconvenient and results in a truckload of boilerplate. First, you'll need a class for the methods:  class IsAnimal a where    makeNoise :: a -> String    needsFood :: a -> Food   Then you'll need existential types for every class: SomeAnimal, SomeMammal, SomeReptile, SomeDog, etc.  data SomeAnimal = forall a. IsAnimal a => SomeAnimal a data SomeDog = forall a. IsAnimal a => SomeDog a ...   If you want to give additional methods to dogs, you'll need to create another class  class IsAnimal a => IsDog a where    tailWaggingSpeed :: a -> MetersPerSecond   and have the corresponding existential class be  data SomeDog = forall a. IsDog a => SomeDog a   Then you'll need functions for each upcasting and downcasting operation, e.g.:  someDogToSomeAnimal :: SomeDog -> SomeAnimal someAnimalToSomeDog :: SomeAnimal -> Maybe SomeDog   For every concrete class, you'll have to create a regular data type and make it an instance of IsAnimal/IsDog/IsWhatever:  data Dog = Dog {dogMakeNoise :: String, dogNeedsFood :: Food} instance Dog IsAnimal where    makeNoise = dogMakeNoise    needsFood = dogNeedsFood   You can see what a nightmare this is. Even with Template Haskell, you can't abstract it away. Consequently, there are only two places where people tend to use this poor man's inheritance: exceptions and GUI widgets."
haskell,3b94w0,ForTheFunctionGod,8,Sat Jun 27 11:36:44 2015 UTC,"I think the second part of this post is a bit of a fallacy. It presumes that you need to create such hierarchies to solve problems. In my opinion, you never really do. Notice how your example doesn't correspond to any problem at all.   The usual imperative way of solving a problem is so ingrained in the minds of programmers, that they try to imitate a known solution, rather than thinking about the 'pure' problem, detached from the preconceptions of that known solution.  In my experience, there is never a need for hierarchies. This includes GUIs and exceptions. Of course, the Haskell solution might not look anything like the imperative solution (I call it ""turned inside out"")."
haskell,3b94w0,tempname12,2,Sat Jun 27 19:01:30 2015 UTC,"The naturality of such hierarchies comes down to subjective taste. I agree that you don't need them, but many would argue that they are natural and easy solutions to certain problems. Some things, like taxonomies, algebraic structures, or exceptions really do form hierarchies.  In my experience, people seldom try to implement a full-fledged OO hierarchy in Haskell - I'm with you on that. However, they often do re-implement parts of it. For example, when you don't need heterogeneous collections, but just common functionality + interface subtyping, you use typeclasses. If you only need heterogeneous collections, you use existential types.  Let's take algebraic structures with one operation:  class Algebraic a where op :: a -> a -> a class Algebraic a => Neutral a where one :: a class Algebraic a => Associative a class Algebraic a => Invertible a where inv :: a -> a class Algebraic a => Commutative a class (Neutral a, Associative a) => Monoid a class (Monoid a, Invertible a) => Group a   This is a hierarchy in all but name. You have attached to values (op, one, inv) and (multiple) inheritance. You don't have existential types because it's pretty unlikely that you'll need to store a bunch of them in the same collection. In fact, you'll seldom even need to store them as objects at all, so it's easier to attach them to values in their domain via the type class's hidden dictionary.  Exceptions are a more complicated example. Unlike algebraic structures, you do need them to be explicit values, and because you often want to catch entire categories of exceptions, you do need existential types. In fact, I adapted my example from Control.Exception. The only thing you don't need there is the type classes, because exceptions generally don't have specific methods attached to them.  So yes: you seldom need the whole shebang I wrote there, but I think that it would be erroneous to conclude that it's therefore useless. Sometimes, you only need type classes (as is most often the case in Haskell). Sometimes, you only need the existentials. Sometimes, you only need up/downcasting à la someDogToSomeAnimal/someAnimalToSomeDog. It's rarely done because it's so cumbersome, but sometimes, it'd be really nice to have all three."
haskell,3b94w0,ForTheFunctionGod,8,Sun Jun 28 03:18:29 2015 UTC,"Call me a cynic, but the OOP obsession with taxonomy usually ends up like this:  class Human extends FeatherlessBiped {     @Override     BroadFlatNail getNail(); }   In any case, there is a much simpler and straightforward model of taxonomical hierarchies than OOP-style inheritance and subtyping: an IS-A relationship is simply an injective function between the two related types:  data Rectangle a = Rectangle { height :: a, width :: a }  data Square a = Square { side :: a }  toRectangle :: Square a -> Rectangle a toRectangle sq = Rectangle (side sq) (side sq)  -- | A partial left inverse for 'toRectangle'.  Law:  -- -- > toSquare (toRectangle (Square x)) == Just (Square x) toSquare :: Eq a => Rectangle a -> Maybe (Square a) toSquare (Rectangle h w)     | h == w = Just (Square h)     | otherwise = Nothing"
haskell,3b94w0,sacundim,3,Sat Jun 27 21:14:41 2015 UTC,"Call me a cynic  Human extends FeatherlessBiped   Ohh, you dog."
haskell,3b94w0,tejon,1 point,Sat Jun 27 21:39:22 2015 UTC,"In any case, there is a much simpler and straightforward model of taxonomical hierarchies than OOP-style inheritance and subtyping   toSquare and toRectangle are downcasting and upcasting, respectively. However, they alone do not give you all the power you might desire. Without existentials, you can't have heterogeneous collections, and without the type classes, you can't well bundle code with the data types."
haskell,3b94w0,ForTheFunctionGod,3,Sun Jun 28 03:15:33 2015 UTC,"I agree that existential types are an awkward way to model this in Haskell, but I don't think your example is complete until you discuss the popular alternative. This is the money quote from the linked article:   See how this is going? Classes become data types, instances become functions. I’m just manually “expanding” what GHC does for you. Of course, the expansion is smaller than the original.   While I suspect you may be able to construct an example that is hard to model well in Haskell, I'm not sure this is it."
haskell,3b94w0,redxaxder,3,Mon Jun 29 17:11:56 2015 UTC,"I agree that existential types are an awkward way to model this in Haskell   Well, it's not so much that they're an awkward emulation... they are the actual semantics of Java calls. In a declaration  retT func (T1 param1, ..., Tn paramN)   retT is existentially quantified: If ret = IList, you'll get some List, although you won't know the concrete implementation.   Classes become data types, instances become functions   Reifying dictionaries is only conventient as long as you don't have too many methods and don't have functions like nextGrowthStage above. Now you could just lug around a bunch of big-ass dictionaries which have the class methods as member functions, but this wastes a lot of memory and you lose type safety. Let's say you model animals with a record:  data AnimalRec { makeNoise :: String, needsFood :: Food, growthStage :: a}   Then you create cat- and dog-objects:  dog = AnimalRec { makeNoise = ""woof!"", needsFood = Meat, growthStage = ??? } cat1 = AnimalRec { makeNoise = ""meow!"", needsFood = Meat, growthStage = ??? }   This is problematic for two reason:   You lose the type-level distinction between cats and dogs. You can't write growthStage in a satisfactory manner. If dogs have data DogStages = Puppy | AdultDog and cats have data CatStages = Kitten | AdultKat, you can't have them both. You could add a type variable to AnimalRec, but as you add more and more methods, you might well end up with data AnimalRec a b c d e f g h i j k l m n o p.   The guy wrote the blog posts probably had good intentions and I don't have a problem with him trying to convince others to scrap existentials, but it always gets quoted as if it were some authority. I'm no expert either, but to my lights, he hasn't shown why one should do without them. You can do it for some cases, but what's the benefit, really? Why is it an anti-pattern? It seems perfectly fine to me."
haskell,3b94w0,ForTheFunctionGod,1 point,Mon Jun 29 22:29:43 2015 UTC,"After I replied to you earlier I got curious about more complete approaches to OOP in Haskell and started googling around. I eventually landed here, although I haven't gone completely through it yet. It looks neat so far.   Let's say you model animals with a record:   In order to fully appreciate your point here I need to know more about what you want to be able do with these things. Because when you say I can't write some function in a satisfactory way, I get really tempted to try.  The bigger goal affects which alternatives I consider satisfactory. After all, if the corresponding Java solution involves explicit runtime type inspection I wouldn't feel so bad about using the same tools in Haskell.   Why is it an anti-pattern? It seems perfectly fine to me.   I think of it as an antipattern because your code gets longer and your types get more complicated (from my perspective). Since your interaction with a list of existentials limited to dictionary elements anyway, I don't see what you lose by storing a list of dictionaries instead.  Although, if you know of a compelling example for which this coversion doesn't simplify things that would be cool to see."
haskell,3b94w0,redxaxder,2,Mon Jun 29 23:54:49 2015 UTC,"Haskell is lazy, you can avoid typeclasses by ""homogenizing"" your list-of-animals:  [makeNoise dog, makeNoise cat]   dog and cat have different types, but (makeNoise dog) and (makeNoise cat) have the same type.  see https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/"
haskell,3b94w0,sambocyn,4,Sat Jun 27 23:33:13 2015 UTC,"Haskell is lazy, you can avoid typeclasses by ""homogenizing"" your list-of-animals   True enough, but if you have multiple functions, you end up shuffling reified dictionaries around. This method is also impossible to use when you can't abstract away the type, e.g.  class IsAnimal a => CanGrow a where     nextGrowthStage :: a -> a   I've read that blog post a couple of times over the years and while the author is welcome to his opinion, it's just an opinion, not gospel truth. He shows that existential types can be eliminated in some cases - but they cannot be eliminated in all cases. More importantly, he gives no motivation for why they should be eliminated."
haskell,3b94w0,ForTheFunctionGod,1 point,Sun Jun 28 03:08:12 2015 UTC,"not Gospel, but neither was the example I'm replying to :)  the motivation is simplicity (classes aren't first-class) and inference, I think."
haskell,3b94w0,sambocyn,2,Sun Jun 28 23:27:29 2015 UTC,"The obvious answer is the main distinguishing feature of OOP: subtyping.   Except that this isn't intrinsic to OOP, and was arguably a mistake to begin with (with regards to it having semantic meaning, at least)."
haskell,3b94w0,tejon,1 point,Sat Jun 27 21:34:43 2015 UTC,"I used ""OOP"" in the sense of ""Java-style OOP"".   Except that this isn't intrinsic to OOP, and was arguably a mistake to begin with   No argument from me there. Look: I'm not some sort of Java-fan. As a matter of fact, I'm the first to say that inheritance is almost always useless and not worth it as a trade-off against type inference, and that the same goes for the endemic plague of in-place mutation of objects that leads to the circle-ellipse problem and makes a mockery of the idea of subtypes. It's just that Java-style subtyping does have some uses."
haskell,3b94w0,ForTheFunctionGod,1 point,Sun Jun 28 03:41:41 2015 UTC,"why do you think subtyping doesn't have semantic meaning?  Subtyping has great semantics: for example, if you view types as PERs and PERs as sets of pairs then subtyping is just subsetting."
haskell,3b94w0,philipjf,1 point,Tue Jun 30 06:44:32 2015 UTC,"I didn't say subtyping doesn't have semantic meaning; I said it was arguably a mistake for it to have meaning, i.e. to be subtyping rather than merely subclassing. Smalltalk had hierarchical subclassing, but was thoroughly duck typed so it was just a method for code reuse. Java directly copied this paradigm, but then mixed it with meaningful types, which I think is the root of a great many issues with Java-style OO."
haskell,3b94w0,tejon,1 point,Tue Jun 30 09:56:17 2015 UTC,"I guess I am confused then.  The problem with Java is that it combines the sub-typing and subclassing (that is, inheritance) features into a single mechanism.  You are of course right that inheritance doesn't imply sub-typing.  However, that isn't an argument that sub-typing isn't a useful feature.  It might be that a type system based on parametric polymorphism (and specifically row typing) is better for oop then one based on sub-typing.  It might even be the case that having only one type is better for OOP than having many types, but that seems improbably to me."
haskell,3b94w0,philipjf,1 point,Thu Jul 2 02:59:07 2015 UTC,"The thread parent opened with:   The obvious answer is the main distinguishing feature of OOP: subtyping.   ...and went on to present examples of Java-style ""subtype == subclass"" single-inheritance, so that was the assumed context for my comments.  You're right that this definition was too narrow on both ends, not just the one I highlighted -- but you didn't bring that up immediately, and I think we were talking past each other for a moment there. :) I agree with all the points you just made.  (And there's a type vs. newtype joke in here somewhere.)"
haskell,3b7gn0,hvr_,44,Fri Jun 26 16:12:40 2015 UTC,I'm very much in favor of this.  Anything we can do to make base more strongly typed is a move in the right direction
haskell,3b7gn0,Tekmo,28,Fri Jun 26 16:29:02 2015 UTC,"But is the strong typing correct? The proposal is very ambiguous about how a FilePath is converted to and from Unicode, and that is the critical point. And it varies considerably between platforms.  The Eq instance has to be correct for each platform, too: on Mac OS X, a FilePath constructed from two different Unicode strings that have the same normal form must be equal, whereas on Windows they must be unequal.  And on POSIX, paths have little to do with Unicode at all. Paths are bytestrings. It is up to the application to decide how to interpret them as encoded human-readable strings, if at all.  This proposal will cause a huge amount of pain. It isn't worth it unless we get the semantics right. Having a more strongly-typed FilePath with broken semantics is worse than what we have now, not better."
haskell,3b7gn0,yitz,8,Sat Jun 27 21:11:01 2015 UTC,"This proposal will cause a huge amount of pain. It isn't worth it unless we get the semantics right. Having a more strongly-typed FilePath with broken semantics is worse than what we have now, not better.   is it even possible to get the semantics right without ending up with an overengineered set of types and requiring all sorts of Maybe/IO wrapped result types?"
haskell,3b7gn0,hagda,6,Sat Jun 27 23:19:32 2015 UTC,is it even possible to get the semantics right without ending up with an overengineered set of types and requiring all sorts of Maybe/IO wrapped result types?   Completely unrealistic.
haskell,3b7gn0,tailbalance,1 point,Mon Jun 29 11:52:28 2015 UTC,"is it even possible to get the semantics right without ending up with an overengineered set of types and requiring all sorts of Maybe/IO wrapped result types?   Yes. The system-filepath library already does it. Unfortunately, that library is deprecated, but that is basically how it should be done."
haskell,3b7gn0,yitz,3,Sun Jun 28 00:12:09 2015 UTC,For Mac it doesn't.
haskell,3b7gn0,tailbalance,1 point,Mon Jun 29 11:51:56 2015 UTC,True. /u/snoyberg also pointed that out elsewhere in this thread. That's a bug that would be easy to fix. But it does provide very nice machinery for an abstract FilePath type with platform-dependent conversions of that type to and from Unicode.
haskell,3b7gn0,yitz,1 point,Sun Jul 5 23:39:04 2015 UTC,"If the library does it right, why is it deprecated then?"
haskell,3b7gn0,rstd,5,Sun Jun 28 19:15:23 2015 UTC,https://plus.google.com/+MichaelSnoyman/posts/Ft5hnPqpgEx
haskell,3b7gn0,yitz,3,Sun Jun 28 19:37:46 2015 UTC,"Mainly because the package author isn't active in the Haskell community anymore. Michael Snoyman considered taking over the library, which had been the standard path type for the conduit and yesod ecosystems. But in the end he decided to switch those ecosystems back to Prelude.FilePath."
haskell,3b7gn0,semigroup,2,Sun Jun 28 22:00:25 2015 UTC,"That's not totally accurate AFAIK– the original author was the one to deprecate them (quoted from Google+):   I'm declaring bug bankruptcy on system-filepath and system-fileio, and deprecating them.  These libraries were written to support Linux file paths containing non-Unicode byte sequences, which was varying degrees of broken in GHC 6.10 through 7.2. GHC 7.4 greatly improved support for these type of paths, to the extent that system-filepath and system-fileio were really just a grossly overbuilt compatibility shim for people that needed to support old GHC versions.  Since the number of library developers who still need to support GHC <=7.2 is approximately zero, it's time to get rid of the shim and migrate back to the standard library.  This is something I'm very happy about, because I can stop researching obscure undocumented Windows-only UNC meta-prefixes and go back to pretending that Windows doesn't exist.  If anyone out there is interested in maintaining these libraries, I'd be happy to transfer maintainership.﻿"
haskell,3b7gn0,yitz,3,Wed Jul 1 14:07:46 2015 UTC,"I was well aware of this post. But in fact, system-filepath and system-fileio were still very much needed; they provide a mechanism for an abstract FilePath type and platform-dependent conversions between  FilePath and Unicode text.  I was very sorry to see those libraries deprecated, and that the conduit ecosystem so abruptly abandoned them as a result. But if in the end this causes GHC itself to have a better built-in FilePath type and better platform-specific conversions between that FilePath type and Unicode, it will all have been worth it."
haskell,3b7gn0,yitz,4,Sat Jul 4 22:35:05 2015 UTC,"What kind of equality would you expect  for FilePaths? In the worst case (inode-equality), it depends on the current environment state (including the contents of the filesystem), and obviously wouldn't be expressible as a FilePath -> FilePath -> Bool.  The other extreme is to not normalise at all and instead provide normalising functions, so you can use combinators (or define functions) such as  (==) `on` normalisePath \a b -> (==) <$> absPath a <*> absPath b   I.e. you'd need to be explicit what kind of normalisation you want, and you can control whether to persist that normalisation (e.g. when used as keys in a Map or HashMap)  Then there's the option of not defining any Eq/Ord instances at all for FilePath, but I'm not sure if that's even desirable, as it would tempt to define orphan instances."
haskell,3b7gn0,hagda,5,Sun Jun 28 06:53:52 2015 UTC,"What I want is an API that respects the expected application-level conventions on each platform.  My assumption was that the right way to do that was via the Eq instance. But now I see, from the continuing discussion on libraries, that the internal representation of a FilePath will probably be a ByteString on all platforms. In that case, the application-level conventions should be reflected by the API to convert FilePath to and from unicode, not by the Eq instance.  Furthermore, you are right that at least on posix-like platforms, there is the problem that the most natural convention to choose - the Glib/GTK convention - depends on current system state. See the glib manual and this discussion on the mozilla dev list.  So I suggest: let's do the best we can. Assume UTF-16 on Windows and UTF-8 on posix and Mac OS X. On Mac OS X, normalize unicode by default when converting it to a FilePath, and on other platforms do not normalize by default. Make sure that all options are available on all platforms, not just the default. Decide what to do about the fact that some of the above operations are partial functions.  Make sure that it is also possible to convert FilePath to and from ByteString so that it's possible to do whatever you want if our usual conventions don't work for you. Even here, there should be some interface that ensures that you won't accidentally create (on any platform) a FilePath intended to be used on Windows with an odd number of bytes."
haskell,3b7gn0,yitz,2,Sun Jun 28 09:12:42 2015 UTC,"Make sure that all options are available on all platforms, not just the default.   What shall be done about platforms other than POSIX, OSX and Win32, like e.g. JavaScript/GHCJS or some of those not-quite-POSIX embedded operating systems?"
haskell,3b7gn0,RyanGlScott,2,Sun Jun 28 10:53:42 2015 UTC,Are there different path semantics there that could not be supported with an API like the one I described? If so - what else would be needed?
haskell,3b7gn0,ForTheFunctionGod,19,Sun Jun 28 21:57:36 2015 UTC,"After reading the proposal, I have some questions:   Would the toFilePath function be partial? That is, would toFilePath throw a runtime error if a badly formatted filepath was given as an argument? Similarly, would Template Haskell functions (à la path) be added so that badly formatted filepaths can be detected at compile-time? Another feature of path that I find useful is the use of phantom types for marking what kind of path it is, e.g., Path Rel Dir or Path Abs File). Is there a reason that the proposal decides against this?"
haskell,3b7gn0,sccrstud92,9,Fri Jun 26 20:09:15 2015 UTC,"Another feature of path that I find useful is the use of phantom types for marking what kind of path it is, e.g., Path Rel Dir or Path Abs File). Is there a reason that the proposal decides against this?   There's two pertinent questions w.r.t. to the encoding of invariants:   What benefit does it bring?   In my opinion, a distinction between relative and absolute paths isn't terribly useful, because they're not categorically incompatible. For instance, you could append a relative path to an absolute one or a relative one to another relative one. In the case of separation between directories and files, outlawing something like ""file1.txt"" <> ""folder"" might be nice, but impossible, as both are valid directory names.   How difficult is it to implement?   I once tried to encode valid Windows filenames and can tell you that that's a rabbit hole from which you don't emerge once you go into it. You have your FAT constraints, your NTFS constraints, filenames that NTFS allows but the Windows shell doesn't, protected names (COM1, COM2, LPT,...), alternate data streams, maximum lengths for filenames/path segments/paths,... It's a nightmare.  The obvious objection would be that one need not encode all of this stuff in FilePath, but then you're left with a system that enforces some constraints, but not all,. It is, consequently, no good, because passing a FilePath deemed valid by the type system to a function like writeFile will not guarantee the operation's success. The underlying system call can still throw an error due to its internal checks.  So I'm with /u/hvr_ on this issue and say that one can do all this in a library, but that it's better to avoid overcomplicating Prelude."
haskell,3b7gn0,hagda,2,Sat Jun 27 10:55:55 2015 UTC,"In my mind, you have relative and absolute paths differentiated for similar reasons you differentiate Vectors and Points."
haskell,3b7gn0,mjmrotek,4,Sun Jun 28 19:29:20 2015 UTC,...or timestamps and time differences?
haskell,3b7gn0,ndmitchell,1 point,Sun Jun 28 23:03:46 2015 UTC,"In my opinion, a distinction between relative and absolute paths isn't terribly useful, because they're not categorically incompatible. For instance, you could append a relative path to an absolute one or a relative one to another relative one.    Perhaps paths could be a category? Like:  Path Root Directory . Path Directory File = Path Root File   I swear I saw someone mention this concept somewhere, but I can't find it now.   In the case of separation between directories and files, outlawing something like ""file1.txt"" <> ""folder"" might be nice, but impossible, as both are valid directory names.   I think it should be up to the programmer to decide at the moment of the path's creation whether it's supposed to be a file or directory path. Perhaps something could be done with TH to validate literals for a given platform."
haskell,3b7gn0,yitz,5,Mon Jul 6 04:11:20 2015 UTC,"Remember Windows has absolute paths, drive relative paths, path relative paths and fully relative paths. Makes it a much more complex type system..."
haskell,3b7gn0,absence3,2,Sat Jun 27 11:35:26 2015 UTC,"And UNC paths, and Cygwin paths..."
haskell,3b7gn0,ndmitchell,2,Sat Jun 27 20:58:21 2015 UTC,"Isn't saying ""Windows has Cygwin paths"" a bit like saying ""POSIX has (lib)Wine paths""?"
haskell,3b7gn0,chrisdoner,2,Mon Jun 29 08:01:30 2015 UTC,Yes/no. There are certainly places where you have to talk/think in terms of paths as they are interpreted by Cygwin.
haskell,3b7gn0,Taladar,8,Mon Jun 29 12:19:52 2015 UTC,"Would the toFilePath function be partial? That is, would toFilePath throw a runtime error if a badly formatted filepath was given as an argument?   No. It was considered, but it would complciate things, as whether a filepath is valid may depend (beyond the current OS) on the current locale settings as well as the filesystem used (Linux supports dozens of filesystems) etc. So in the interest of KISS, the default conversion functions are pure and total. IOW, a FilePath doesn't encode any invariants regarding the validity of a filepath.   Similarly, would Template Haskell functions (à la path) be added so that badly formatted filepaths can be detected at compile-time?   Defining smart QuasiQuoters is definitely possibly, but simply not part of this proposal, as this proposal aims to be minimal (with the intent to become part of a future Haskell Report, for which TH/QQ is very likely out of reach)   Another feature of path that I find useful is the use of phantom types for marking what kind of path it is, e.g., Path Rel Dir or Path Abs File). Is there a reason that the proposal decides against this?   Yes, for simplicity. To quote what I already wrote on the mailinglist:   Trying to redesign the FilePath type to also include dir/file distinction seemed too daunting, as there's quite some additional design-space area to explore (do drive-letters deserve a separate type? do we use DataKinds? What invariants can/shall be represented at the type-level? what errors are caught at the type-level, which are caught at runtime? etc...), parts of which may require type-system extensions, while just having a KISS-style opaque FilePath evades this."
haskell,3b7gn0,absence3,10,Sat Jun 27 09:34:54 2015 UTC,"I'm in favour of this KISS approach; get the type opaque. That's a big enough upheaval by itself.   Indeed, the typed path design space is still being explored; path is my synthesis from experience on work projects, others have and are trying varying approaches."
haskell,3b7gn0,RedLambda,5,Sat Jun 27 10:31:08 2015 UTC,"No. It was considered, but it would complciate things, as whether a filepath is valid may depend [...] the default conversion functions are pure and total   I would consider at least distinguishing between valid and invalid inputs on a very basic level, e.g. do not allow empty strings to be converted to filepaths. This would result in eliminating a rather large class of bugs that can result from passing those empty filepaths to deletion or similar functions and I do not think the OS exists where empty strings are valid paths (well, technically they could be considered valid relative path components but still, I think this would be worth it)."
haskell,3b7gn0,Taladar,3,Sat Jun 27 15:51:08 2015 UTC,I think AmigaOS uses empty string for current directory FWIW.
haskell,3b7gn0,conklech,1 point,Mon Jun 29 07:57:51 2015 UTC,"I don't think you can easily distinguish valid/invalid FilePaths easily at construction time, as you'd have to know which (mounted) filesystem they're gonna be applied to. Linux for one is quite liberal on what values a valid char pathname[] may contain, and only when the fs layer for the respective filesystem gets passed the bytestring you may get an invalid-argument response.  So I think the current proposal, i.e. not trying to be clever with FilePaths and consider them opaque handles is the safe and reasonable thing to do."
haskell,3b7gn0,conklech,1 point,Tue Jul 7 07:04:38 2015 UTC,"I was mostly thinking of the case where some form of configuration returns an empty string for a file path and you end up passing it to some function or external command which interprets that as ""no argument given, work on current directory"".   An empty string should be easy to distinguish from a non-empty string at construction time."
haskell,3b7gn0,adamgundry,4,Tue Jul 7 08:33:49 2015 UTC,"Phase 2  Have GHC warn when a String-value is used where the FilePath synonym is expected  TODO needs investigation if it's feasible to implement   Is that possible even in principle? If it were, couldn't we implement it as an error and thereby replace some of the use-case for newtypes that don't have different instances?"
haskell,3b7gn0,ndmitchell,9,Fri Jun 26 16:46:24 2015 UTC,"GHC keeps track to a certain extent whether a type-synonym was used, e.g.  λ:2> let x = ""foo"" :: FilePath x :: FilePath λ:3> x ""foo"" it :: FilePath λ:4> x <> x ""foofoo"" it :: FilePath λ:5> x ++ x ""foofoo"" it :: [Char]   That's why I think that GHC could actually warn when it has to drop the type-synonym color. But I haven't looked into it in detail yet. That's why it's marked as a TODO item."
haskell,3b7gn0,adamgundry,3,Sat Jun 27 09:39:34 2015 UTC,"That's a good observation. Is that behavior, i.e. when inferred types retain or lose a synonymous annotation, documented anywhere?"
haskell,3b7gn0,ForTheFunctionGod,6,Sat Jun 27 16:36:02 2015 UTC,"Not really, because it is very much dependent on the whim of the typechecker. GHC tries to preserve synonyms if possible, in the interests of nice inferred types and good error messages, but it makes no guarantee to do so.  I'm very skeptical that such a warning could be implemented in a robust way, without a great deal of work. One could probably get GHC to warn whenever it reduced the FilePath type synonym, but that would give rise to false positives."
haskell,3b7gn0,yitz,3,Mon Jun 29 06:56:10 2015 UTC,Could you give some examples of the kind of false positives you'd expect?
haskell,3b7gn0,yitz,4,Mon Jun 29 12:23:06 2015 UTC,"Well, even the x <> x example given by /u/hvr_ requires a reduction of the type synonym behind-the-scenes, in order to solve the Monoid FilePath constraint. And indeed, it's not obvious that class instances for [Char] will continue to be available for the new abstract type. I've been trying to construct more compelling examples, but GHC is impressively good at retaining synonyms!  Perhaps there is a way to distinguish between type synonym reductions that are visible in the types of subexpressions, and those that are not, and use that as a heuristic for displaying a warning."
haskell,3b7gn0,snoyberg,7,Tue Jun 30 16:43:12 2015 UTC,"FilePath was already an abstract type in the now deprecated system-filepath. It seemed to work well enough, although the conversions to and from lazy BytString/string ByteString/String/FilePath were bothersome. The neat Monoid-instance and the argument from memory economy seem pretty convincing, so I'm all for it."
haskell,3b7gn0,yitz,3,Sat Jun 27 10:41:10 2015 UTC,"If this proposal were implementing system-filepath, that would be great. But unfortunately, it sounds like it is not."
haskell,3b7gn0,redneb8888,6,Sat Jun 27 21:16:49 2015 UTC,"Which parts of system-filepath are you missing or seeing in conflict? This proposal doesn't ""implement filepath"" either, it just describes how filepath is going to interact with the new FilePath type, and how it can aid during the transition.  Can't system-filepath be implemented using this proposal's opaque FilePath in place of system-filepath's Filesystem.Path.FilePath type?"
haskell,3b7gn0,redneb8888,3,Sun Jun 28 06:31:46 2015 UTC,"The central feature of system-filepath is a FilePath type which implements the application-level semantic conventions for paths on each of the major platforms. So, for example, FilePaths constructed from two unicode strings with the same normalization are equal on Mac OS X and unequal on Windows."
haskell,3b7gn0,ndmitchell,3,Sun Jun 28 21:52:52 2015 UTC,Can you point to the code in system-filepath that implements this? I don't remember seeing it.
haskell,3b7gn0,Fylwind,2,Mon Jun 29 13:50:46 2015 UTC,"Huh. You're right, it doesn't actually do the normalization step:  darwin = Rules { ... , fromText = posixFromText     ... }   which just splits the text into path pieces and unpacks each as a String, skipping the required normalization step. That's a bug.  But in any case, system-filepath does provide a great example of machinery for platform-dependent file paths and platform-dependent Text and String coercions, which is the point here."
haskell,3b7gn0,hagda,3,Tue Jun 30 06:44:00 2015 UTC,"I strongly support this idea. It would be nice if this is implemented in a way that would make it possible to use one FilePath type in another platform, e.g. use the unix FilePath in a windows system, similar to how the filepath package works."
haskell,3ba7s7,emmanueltouzery,6,Sat Jun 27 06:56:14 2015 UTC,"Parameterize your parser by the blockquote nesting level. A parser with nesting level n parses n times > at the start of each line. When you see more > after that, increase the nesting level appropriately."
haskell,3ba7s7,julesjacobs,3,Sat Jun 27 09:43:01 2015 UTC,"this is actually what I do now, but it doesn't really solve the problem. It's just how you store the data in the AST but it doesn't really help with the parsing. So what I do now is as you suggest, I have BlockQuote Int matching a single line, and then I have a little post-processing that merges consecutive blockquotes that have the same depth. But that merging is duplicating logic that would be handled by the parser normally.  The problem is that either you have content1, carriage return, content2, or >, content1, >, content2, and then different levels of blockquotes and so on.  I think I'll parametrize my whole AST on the blockquote contents: Document a. The first time I'll parse to Document Text, then in a second pass I'll change to Document Document by parsing each blockquote block one by one."
haskell,3ba7s7,julesjacobs,3,Sat Jun 27 10:35:13 2015 UTC,"I think you might have misunderstood what I meant. With the approach that I meant you don't need any post-processing. Parameterize all your parser combinators by the nesting level of blockquotes in front. For example if you had a list parser:  list = ... some parser code here ...   You change it to this:  list n = ... some changed parser code here ...   This is supposed to parse a list under n nestings of blockquotes, e.g. list 3:  > > > * one > > > * two > > > * three > > > * four   Inside the parser you start every line with n times >."
haskell,3ba7s7,julesjacobs,1 point,Sat Jun 27 10:48:49 2015 UTC,"You're right I didn't follow you. Ok I get it now. I don't know, I think it won't work that well in practice. I have the feeling it'll get messy I think when the blockquote level changes and to find which level I should take into account at a newline, and I don't like the idea of polluting each parser with that. I also worked with an idea like that of providing the parsers with a transforming function (I was giving them sepBy endOfLine or sepBy (endOfLine >> string ""> "") to simplify), but it made everything messy and harder to follow and didn't even really work well.  Still I'm keeping this in my mind, though it won't be my first choice right now."
haskell,3ba7s7,julesjacobs,2,Sat Jun 27 11:05:34 2015 UTC,"Changing the blockquote level is easy. You define the blockquote combinator like this:  blockquote n = markdown (n+1) <$> BlockQuote   where markdown is your main parser. In words: ""to parse a blockquote under nesting level n, parse markdown under nesting level n+1 and wrap the result in a BlockQuote constructor"".  I think this is the simplest approach; handling this with post-processing seems like a (more complicated) hack to me, but YMMV."
haskell,3ba7s7,julesjacobs,1 point,Sat Jun 27 13:09:26 2015 UTC,"yes but every parser under markdown (list, paragraph, ...) but be able to receive that n and therefore I spread the problem in all of my parsers except if I misunderstand you? individual parsers are multiline aware (lists spread on several lines, paragraph too, ..). Therefore each of them would have to know about that level and that would make each of them more complicated."
haskell,3ba7s7,codygman,3,Sat Jun 27 13:27:17 2015 UTC,"Yes, the parsers that span multiple lines would need to be aware of this. It would not make them significantly more complicated. You just have a parser start n which parses n times >, and insert that in the correct places. If you wanted you can even wrap everything in a reader monad to hide the n parameter, but I don't think that's even worth it. Of course it's a bit of complexity, but what's the alternative? Doing it in postprocessing or with raw string mangling seem significantly more complicated, fragile, and hacky to me.  By the way, do you want to be able to support blockquotes inside a list? (as opposed to a list inside blockquotes)"
haskell,3ba7s7,codygman,2,Sat Jun 27 13:41:32 2015 UTC,"Ok you convinced me to try. Also, I coded the transformation way and it's messing with the AST in ways that I don't like. I'll try that too and report. Thanks for the tip!"
haskell,3b9tlb,Quantumplation,4,Sat Jun 27 04:01:40 2015 UTC,"These were the only things I would change after spending a few minutes reading your code. Don't just accept them as better, because these are some picky nits.   I would flip the order of the args to withToken. Typically, from what I have seen, withX functions have types X -> Thing -> Thing. This allows you to partially apply like withX myX to get a Thing -> Thing function, and it is really easy to chain a bunch of those together if necessary. This is an example of the ""the data structure goes last"" rule (which is nothing hard-and-fast, keep in mind). I think that your case v of statement in handleResponse can be shortened using a prism (you are already using Lens so why not). I don't know if aeson provides prisms for Value or not. The only reason modify from handleResponse returns a Maybe is because you pass it to alter. However, you know it always returns a Just, and this forces you to use fromJust later. I would suggest removing Just $ from the definition of modify, eliminating your usage of fromJust, and passing (Just . modify) to alter instead. Right now, the first thing you fail to parse will crash everything and prevent (unrelated?)  UUIDs from being handled. Is this what you want? I do not know. The name of the function force makes me think that you are forcing the evaluation of something, like in the deepseq package, but this is not what you are doing. I would name it fromSuccess, but this is a REALLY small deal.   Obviously, like you mentioned, using 4 string representations is quite a hassle, and the biggest improvement would probably come from eliminating some of them, but I don't have a good solution for that at the moment."
haskell,3b9tlb,sccrstud92,3,Sat Jun 27 06:36:57 2015 UTC,"I feel like having so many string representations is a big hassle when it comes to learning Haskell, and writing real apps with it. In an app I wrote that uses vty-ui, Aeson, and Parsec, I have to deal with [Char], ByteString, Lazy ByteString, Text, and Lazy Text, because all the various libraries I use require these different representations in different places.  Of course we should maintain the separation between ByteStrings and Text, but having to care about Lazy vs Strict and also dealing with [Char] is so frustrating, and I don't think there's any way to avoid it yet."
haskell,3b9tlb,radix,1 point,Sat Jun 27 16:43:36 2015 UTC,"Off the cuff, perhaps if you had a type class like  class ImplicitlyCastable a b where     cast :: a -> b   and a statement you could include at the top of your file which to turn on one implicit cast, such as  allow ImplicitlyCastable [Char] Text   which allowed it to transform your code and insert the extra calls to cast.  This still has the well-typedness of Haskell, and you're being very explicit about it so you don't get hit with performance issues that you didn't explicitly ask for."
haskell,3b9tlb,sccrstud92,1 point,Sat Jun 27 17:14:06 2015 UTC,"Thanks for your advice, i've applied some of those refactorings and it's looking better!  I learned about the mapMaybe function, which allows me to get rid of the force method and handle things far cleaner.  I'm not sure what you meant by using a Prism... I'm still rather lost when it comes to Lenses."
haskell,3b9tlb,psycotica0,1 point,Sat Jun 27 17:15:09 2015 UTC,"I feel like the whole thing I'm doing with Map ByteString Count could be done with some State Monad or something, but i can't wrap my head around how to do so."
haskell,3b9tlb,psycotica0,1 point,Sun Jun 28 02:32:22 2015 UTC,"You could use StateT if you wanted, but what you have right now isn't too complicated."
haskell,3b9tlb,psycotica0,1 point,Sun Jun 28 04:35:14 2015 UTC,How would I go about doing that? It seems like a good exercise to understand the StateT monad.
haskell,3b9tlb,psycotica0,1 point,Sun Jun 28 04:51:30 2015 UTC,"Full disclosure, I really like folds, but I think the way you're handling this with the fold is actually a pretty natural way to do it, and it's not hiding anything.  First off, a lot of people talk about the State Monad, but it's rarely applicable in small programs. The benefit of using State is that you can have a bunch of functions that (kinda) transparently pass this object through them without having to care about it.  In your case, the Map is only going two levels deep, and one of those levels doesn't use it. Not a lot to keep track of.  The second thing is that the state in the State Monad is whatever you put in it, whether that's an Integer or an IORef or whatever. In your case what you want is a Map, so your state would be a Map, so there's still an explicit Map in there.  Off the top of my head, these would be the changes:    Rather than using a foldM, you'd use mapM on handleUUID. That would give you a StateT, which you'd need to immediately use evalStateT on with the initial state (the same empty map) to get the result. handleUUID would take in only buckets and count, and the state would be implied by the type, and it would call handleResponse directly passing in only details, since the state is again implied Handle response would have most of the changes:   You'd have to precede both IO calls with calls to liftIO to be able to use them The pure lookup for count would be replaced with a lookup fmapped on a ""get"" The alter would turn into a modify that called alter The function would return () instead of the new list    I think that's the rough framework of changes required. I don't think it'd make things better or clearer, and personally think your foldM approach is the better one."
haskell,3b9tlb,psycotica0,3,Sun Jun 28 14:33:46 2015 UTC,"In bucket keys you have:  bucketKeys = do     contents <- readFile ""bucket_key.secret""     return $ lines contents   This pattern can be rewritten   bucketKeys = fmap lines $ readFile stuff -- or  import Data.Functor ((<$>)) bucketKeys = lines <$> readFile stuff   This is a style thing, and if you find your clearer, then that's fine.  Also:  handleUUID bucket counts uuid = handleResponse counts =<< getRequestBody bucket uuid   My review is now complete and kept in this and other comments"
haskell,3b9tlb,psycotica0,3,Sun Jun 28 12:50:15 2015 UTC,"In main, you can similarly turn:  -- This buckets <- bucketKeys mapM_ handleBucket buckets -- Into This import Control.Monad ((=<<)) putStrLn ""Start..."" mapM_ handleBucket =<< bucketKeys putStrLn ""Done""   Again, it's up to you which you find clearer. I just don't like variables that are only used on the next line unless they add commentedness or clarity. Or split a line up. In this case it's not shorter or clearer, in my opinion. In a longer method it would, though, cause me to look to see if buckets was being used elsewhere in the code."
haskell,3b9tlb,psycotica0,2,Sun Jun 28 12:58:03 2015 UTC,"I don't know if this is just hear-say but with an executable like this I think you can get some extra-aggressive optimizations from only exporting the main function from the module.  Since that's the only one an executable needs, declaring that that's the only export lets the compiler know none of the rest of the functions in the file need to be kept intact so long as they serve the same purpose to main, allowing inlining etc."
haskell,3b9tlb,psycotica0,2,Sun Jun 28 13:02:59 2015 UTC,"handleResponse is tricky for me:  First off:  writeFile file $ (BL.unpack . encode) v -- is writeFile file $ BL.unpack $ encode v   Second, the function feels weird to me because except for writing the data out, it's a pure function wrapped in IO.  At the very least, since the pure parts don't depend on the IO parts at all, I might move all of the lets into the where. This makes it clear that they're purely computed from the inputs and no side-effects.  Then you could have at the top level:  import Data.Functor ((<$)) handleResponse counts v = newCounts <$ do     putStrLn $ ""Writing "" ++ file     writeFile file $ (BL.unpack . encode) v where eventType = ... count = .... file = .... newCounts = ....   The reason I prefer this is because it isolates the IO parts and makes it clear that we print a thing and write a thing based only on pure inputs, and then we return another pure result.  (If you're not familiar, (<$) is ""fmap const"", which means ""do the thing on the right, but then throw out its result and return the pure thing on the left""  Also  modify = maybe 1 succ -- Or if you hate that modify = maybe 1 (+1)"
haskell,3b9tlb,psycotica0,2,Sun Jun 28 13:44:54 2015 UTC,"getRequestBody:  Again, we have some one-use pure variables, but they're a little more ok here. At least the ones after the getAuth depend on its output, so they can't trivially be turned into where.  But, that's not to say I don't have opinions I again want to remind you you're free to ignore!  Like before, the only IO in this function is getAuth. I like to make that clear. All of the rest of the function is just transforming the result of that call, without using any inputs. This makes it easy to instead use our friend fmap (in the form of (<$>)).  getRequestBody bucket uuid = ourDecode <$> (getAuth defaults $ messageUrl bucket uuid) -- I don't remember if the () are needed. where ourDecode = fromMaybe emptyObject . decode . BL.fromStrict . encodeUtf8 . getBody   For me this says ""We compute the messageURL, then get the auth. From that we get the body, encode it, make it a BL, decode that, and then if that failed make it empty. Again, if that's not as friendly for you, then use your thing."
haskell,3b9tlb,psycotica0,1 point,Sun Jun 28 13:59:55 2015 UTC,"getUUIDs is very similar to this method. If you are trying my opinions, I'll leave this as an exercise to the reader."
haskell,3baoyy,Danh91,4,Sat Jun 27 11:45:30 2015 UTC,"If you're interested in trying out test frameworks/writing unit tests/refactoring in a lot of different languages take a look at the Gilded Rose refactoring kata. It has a Haskell version, it's very enlightening to do it in lots of different languages and compare the results."
haskell,3baoyy,Crandom,1 point,Sat Jun 27 13:11:10 2015 UTC,Thanks. I'll have look
haskell,3baoyy,jP_wanN,3,Mon Jun 29 23:30:05 2015 UTC,Todo list application.
haskell,3baojm,quiteamess,8,Sat Jun 27 11:38:50 2015 UTC,"The pegs could have the shape of apply, fmap, the Haskell-logo   Time to learn woodworking, I suppose! But why stop there? Instead of just <*>, <$>, and >λ=, you could take on the operators of the lens library. Children will have hours upon hours of fun with <<<>~, <%@~, %%@=, and the upcoming <>?+~%%~##>=, which of course updates a lattice induced by a co-semirepresentable profunctoral quasigroupoid in the category of post-colonial zygohistomorphic prepromorphisms."
haskell,3baojm,ForTheFunctionGod,2,Sun Jun 28 15:11:31 2015 UTC,"I thought about 3D printing. The problem is, that the symbols are not connected, which would make the whole thing difficult. Ligature characters might work then.   This kind of toy would be appropriate for 'think geek'. For children I would prefer a cokemett wind-up doll."
haskell,3baojm,Gurkenglas,2,Sun Jun 28 22:06:33 2015 UTC,"Maybe a meatspace version of Scratch, with extending blocks where needed and a way to take a picture of an assembly and turn it into a source file."
haskell,3b88xa,PM_ME_UR_OBSIDIAN,6,Fri Jun 26 19:36:08 2015 UTC,"Entry level FP here (meaning < 5 years real-world experience). I worked a variety of roles in mobile and web, with PHP/Java/Groovy/Obj-C/C++/C/JS/etc. I attended FP meetups and networked my butt off, eventually landing a gig writing Clojure due to my JVM experience and Haskell knowledge. The next step will be to move onto a Haskell role in a few years, but so far I'm pretty happy slinging LISP. I have some support from the team to introduce core.typed into our codebase.  You're actually a bit of an anomaly since you've had F# exposure so early on, and at more than just one job. Whatever you did for the first two companies, do it again! If you're in a large metro area, make sure to attend tech meetups and apply similar strategies as for any software job. Keep track of companies that you'd want to work for and that use tools you're interested in. Tailor your resume, github, blog, and linkedin accordingly."
haskell,3b88xa,pythonista_barista,5,Sat Jun 27 15:05:26 2015 UTC,"If you are productive in a functional language, one option would be to seek out a tiny startup where you'll be a big enough part of the development team to influence language choices. Perhaps you join someone to develop a non-trivial front-end and use PureScript for a part of it? Or a well-defined backend module in Haskell? You can start small and go from there. That said, if you're just starting out in your career, building knowledge and experience with technologies that will reliably get you jobs that put food on the table is probably not a terrible idea (while pursuing your functional skills on the side)."
haskell,3b88xa,cbaatz,7,Sat Jun 27 08:55:19 2015 UTC,"At Front Row Education we hire Haskellers through either http://functionaljobs.com/, Hacker News  ""Who's Hiring"" posts or Angel List. Now trying underdog.io as well. Try those out, there's a lot of demand for FP talent in the Bay right now."
haskell,3b88xa,akurilin,1 point,Fri Jun 26 19:39:55 2015 UTC,"This may be an unanswerable question, but what skill level with Haskell would you consider as adequate for a potential hire?"
haskell,3b88xa,ephrion,1 point,Sat Jun 27 04:29:10 2015 UTC,"It really depends on the company's needs and budget.  Sometimes you need a hardcore specialist in the stack that you're using, and you need him asap.  Sometimes you're happy with a hire who's not familiar with your technologies, but who just generally seems very capable of learning really fast. Maybe you have the time and and expertise to bring that person up to speed for the long term, so it's a worthwhile investment for the company.  Sometimes you have 12 months left in the bank, and a hire becoming finally productive after 6 months will probably kill your company.  Being sharp, disciplined, humble, interested in the craft and aggressively productive are all qualities that span beyond just Haskell. Having them should easily earn you a spot in most shops."
haskell,3b88xa,akurilin,1 point,Sat Jun 27 08:48:48 2015 UTC,"I've been studying Haskell for about three years, but I've only written about ~100 lines in it. I think I'd make a killer junior engineer... if someone would let me."
haskell,3b88xa,akurilin,7,Sat Jun 27 08:52:30 2015 UTC,"That'd certainly be concerning to me as a ""hiring manager"". In my experience, you work on solving problems 90% of the time and you read / research / deliberately improve your skillset the remaining 10%. Many, many developers think they ""know"" a technology just by reading it, and then proceed to completely disintegrate when asked to actually accomplish something valuable to the business in a limited time frame.  If you have time, it really helps if you can put together sample non-trivial applications as part of your portfolio, and OSS contributions as well. If you can show that you can be very productive, and not just a theoretician, then you have a much stronger chance of getting companies' attention. Whatever you can do to demonstrate that you can solve problems for a business will greatly work in your favor."
haskell,3b88xa,howardbgolden,5,Sat Jun 27 09:04:22 2015 UTC,"I suggest you write some ""how to"" documents on a blog. Pick a Haskell library that interests you and explain it with examples. This will demonstrate your ability to solve problems and communicate. Trying to teach something is an excellent way to really learn the subject! Of course, the blog exposure will be a great way to get attention of potential employers."
haskell,3b88xa,codygman,3,Sat Jun 27 16:35:56 2015 UTC,"Whoa. You should definitely try writing a 2000+ line application, you might be surprised how much Haskell you know."
haskell,3b88xa,codygman,2,Sat Jun 27 16:10:26 2015 UTC,"At this point in my Haskell journey, what I'm missing is mentorship. I've got this big great soup of concepts inside my head, but I need some guidance on how to arrange it into well-designed programs."
haskell,3b88xa,akurilin,3,Sat Jun 27 17:02:14 2015 UTC,"I've got this big great soup of concepts inside my head, but I need some guidance on how to arrange it into well-designed programs.   I think this is where you really need to stop learning and make shitty horribly architected Haskell programs and feel the brunt of those mistakes.   It helps to have a mentor though. I'm not sure if I qualify but I'd be happy to help you start on some sort of project."
haskell,3b88xa,Tekmo,4,Sat Jun 27 18:26:07 2015 UTC,"I think mentorship is nice because you learn from the mistakes of others.  I appreciate your offer, however I don't think I have enough time outside of work to maintain a mentor-mentoree relationship over the internet :) This is why I'm looking for a functional job - it would give me a good space for getting mentored."
haskell,3b88xa,ksteinberg,2,Sat Jun 27 19:54:34 2015 UTC,"IMHO this is going to be rough for you to pull off. Companies generally prefer to hire people who can show evidence that they will do the job well. If you're putting the burden of proof on the company itself, then you're forcing the hiring team to take a big leap of faith on you.  This might work in the current market, given a sufficiently desperate organization. In general however, any candidate with projects, or a proven track record of solving the problems we want them to solve will be miles ahead of you in the hiring process. In order order to easily get the job you want, you must already be doing that job."
haskell,3b88xa,twistier,1 point,Sat Jun 27 20:10:45 2015 UTC,"Well I do have a functional job on my resume already, it's just not in Haskell :)"
haskell,3b88xa,ksteinberg,9,Sat Jun 27 20:23:35 2015 UTC,"The best strategy for finding functional jobs is also the best strategy for finding programming jobs in general: have a track record of open source projects and contributions and spend some time to communicate your work with others (either through blogging, conference talks, meetups, or sharing on social media)."
haskell,3b88xa,_AndrewC_,3,Fri Jun 26 20:34:35 2015 UTC,"There are no entry level functional programming language jobs (yet?). What you have (in the U.S.) at least is: companies want a Senior Developer in some particular technology X, with an FP background too. My suggestion is to learn FP concepts from FP languages, then immediately drop that and focus on a marketable language, from which you can utterly school other programmers (and lead ""OOP Architects"") using the FP paradigm :D. But you won't get payed accordingly for that in the short term[1], trust me on this.  [1] What happens is half of your colleagues ignore your work and pretend it doesn't exist, or that it's some weird style of non-OOP. The other half constantly try to learn your technique. This goes on for a few years, then magically you're delivering better systems incorporating those techniques and can talk about them in such a way as to demonstrate their value -and then you get blamed for destroying QA and maintenance jobs (if in a large company). I saw the writing on the wall as to the sluggishness and long-term frustration of such a career progression, and I left the industry to work at my own startup instead."
haskell,3b88xa,dalaing,6,Fri Jun 26 21:30:07 2015 UTC,"There are no entry level functional programming language jobs   At least one counter-example exists: Jane Street Capital. They are known to have a pretty tough interview process, but I know they have devs with quite a variety of experience levels."
haskell,3b88xa,kamatsu,5,Fri Jun 26 23:03:06 2015 UTC,"Yah. You got me. I interviewed with them in the past. I was never a total algorithmist, and I'm not willing to cram for weeks to ""fill a CollabEdit buffer"" for a rare  chance at a flight to NYC to do the same mental meat grinder in some kind of day long grilling that attempts to trump Google's. For someone like me, it's better to take the practice and  focus on applying it outside of FPL's in the real world, or startups. I'm also certain that the vast majority of early career FP'ers fall under this category in U.S."
haskell,3b88xa,geophf,2,Fri Jun 26 23:14:56 2015 UTC,"I think it's entirely reasonable if Jane Street are harder to get into than Google. If something goes wrong at Google someone's search our video is messed up. If something goes wrong on the stock market, millions can be lost in a few seconds."
haskell,3b7h27,andrewthad,1 point,Fri Jun 26 16:15:44 2015 UTC,I don't see the big deal in letting users replace gmp in nonfree software.
haskell,3b8c5a,dnkndnts,6,Fri Jun 26 20:00:22 2015 UTC,"Obviously there's some distinction, since I can't just replace + with * in my  code and expect coherent answers. What is that distinction?   While you wouldn't get the answer you wanted, why wouldn't you get a coherent answer?  The most obvious distinction I can think of is what sets arithmetic plus/multiply out of the domain of a boolean algebra, + does not distribute over *. In a boolean algebra, 1 + (2 * 3) would equal (1 + 2) * (1 + 3). So in this sense + obeys one fewer law than * does as * still distributes.  I'm not sure if it makes sense to say that + should not encompass operations like ""multiply"" or ""product"". It's really hard to come up with things + has that * does not."
haskell,3b8c5a,Kaidelong,1 point,Fri Jun 26 21:56:29 2015 UTC,"The most obvious distinction I can think of is what sets arithmetic plus/multiply out of the domain of a boolean algebra, + does not distribute over *. In a boolean algebra, 1 + (2 * 3) would equal (1 + 2) * (1 + 3). So in this sense + obeys one fewer law than * does as * still distributes.   This is interesting to me, because if I define plus this way, then the term ""plus"" doesn't exactly have meaning unless I also define a corresponding * operation where * distributes over +, but not vice versa. It seems a bit strange, but it is indeed true that in every one of my examples at the start, + does have a corresponding * operation.   I'm not sure if it makes sense to say that + should not encompass operations like ""multiply"" or ""product"". It's really hard to come up with things + has that * does not.   Well you just came up with one! But there are more: for example, the lambda \x -> x + n is capable of describing all natural numbers >= n, but \x -> x * n is not."
haskell,3b8c5a,Kaidelong,2,Fri Jun 26 22:09:53 2015 UTC,"Well, the first was something + didn't have, that * did. I'm wondering if the second might be expressible in terms of pure algebraic laws, it relies on knowing things about the carrier set."
haskell,3b8c5a,Kaidelong,1 point,Fri Jun 26 22:45:15 2015 UTC,"I think (I'm not sure -- I have no formal education in category theory) that the Product / Coproduct describes an abstract version of the second. When we start endowing these two abstract functions with some more properties (e.g., commutative, distributive, etc) we eventually arrive at two operations which we'd all agree are plus and multiply -- and which have a solid theoretical foundation for being distinct from one another in a non-arbitrary way.  nLab does seem to give special Product / Coproduct treatment in its definition of distributive category."
haskell,3b8c5a,Roboguy2,4,Fri Jun 26 23:06:06 2015 UTC,"Hey, this is what I came up with, and it's rough, so bare with me.  We can dictate this property in terms of a relation, >=(n,m). We now have a straightforward way of putting it: >=(n+m,n) on the naturals.  So my thought was, is there something analogous for *? As it turns out, there is. Instead of ""all greater natural numbers than n"" you end up with ""all natural numbers divisible by n"".  There might be a pretty deep rabbit hole to go down here, in particular why the rational numbers tie these two things together. However, interesting observation too. + also yields all the numbers divisible by n, while * does not get you the greater than relationship."
haskell,3b8c5a,weisbrot,2,Sat Jun 27 02:42:31 2015 UTC,"Hmm, I'm not sure I see the connection with categorical products and coproducts. What category would this be in? I'm thinking that the objects would be numbers but it isn't clear to me how the corresponding universal properties would fit in, if products or coproducts are identified with addition or multiplication (what would the projection/injection maps be?).  I might be missing something though, since I don't have formal category theory education either. Maybe, a bit more indirectly, you could say something about a functor from a category with products/coproducts and a concept of size, say the category of finite sets, to a category such as the category of finite ordinals (or maybe the simplex category). A Cartesian product of two finite sets A and B would result in a set with a cardinality of |A|*|B| and the disjoint union of them gives you set with a cardinality of |A|+|B|.  That's the first connection that came to mind, but it would only apply to natural numbers though."
haskell,3b8c5a,Roboguy2,4,Sat Jun 27 02:58:09 2015 UTC,"not sure what you want exactly, but:   coproduct seems to have virtually none of these properties   is not really true. coproducts are associative up to isomorphism (which is good enough for category theory), and if the category has an initial object (for example in an abelian category), than this is neutral with respect to the coproduct (again up to isomorphism)."
haskell,3b8c5a,weisbrot,2,Sat Jun 27 01:45:01 2015 UTC,"I think associativity up to isomorphism is only true in (the opposite of) a monoidal category, not for coproducts in general.  EDIT: Actually, thinking about it some more, I think the tensor product of a monoidal category is a different concept and it does make sense to me that you are right that categorical products and coproducts would be associative up to isomorphism in general."
haskell,3b8c5a,tactics,3,Sat Jun 27 03:03:34 2015 UTC,"well, you're kind of right, because in fact any category with coproducts and initial object is 'co-monoidal' (or whatever). for associativity look at this diagram and turn around the arrows."
haskell,3b8c5a,gelisam,1 point,Sat Jun 27 03:34:31 2015 UTC,"After some more reading, it does appear that Product (*) and Coproduct (+) are what I was looking for. As far as I understand, as soon as you show that you have initial / terminal objects, they immediately become commutative monoids. So yeah, if that's the case, then this is indeed exactly what I wanted."
haskell,3b8c5a,Roboguy2,3,Sat Jun 27 17:44:50 2015 UTC,I don't think addition and multiplication are any different mathematically until you try to relate the two notions. The key difference is that multiplication distributes over addition and not vice versa.
haskell,3b8c5a,Roboguy2,7,Sat Jun 27 03:09:28 2015 UTC,Commutative monoid?
haskell,3b8c5a,Roboguy2,2,Fri Jun 26 20:17:47 2015 UTC,"It's certainly true that plus is a commutative monoid, but I don't think this is quite what I'm looking for: plus is also monomorphic, which doesn't seem to make an appearance here, and * on the naturals / integers / rationals is also a commutative monoid, and it doesn't feel right that the proper abstraction for + should include *.  EDIT: I mean partially-applied plus is monomorphic. As far as I know, this property is distinct (not derivable) from the others I've mentioned, yet very important, since it means x + a = z and x + b = z implies a = b."
haskell,3b8c5a,tailcalled,5,Fri Jun 26 20:47:17 2015 UTC,"What do you mean by monomorphic? This? Or do you mean that its type is of the form S x S -> S for some S? If that's the case, that is closure, which is one of the requirements of a monoid (and, more generally, semigroups and magmas).  Also, abstracting generalizes things. As a result, commonalities are identified between different operations so I don't think it's necessarily a problem that + and * would be viewed as similar. It pretty strongly depends on what you mean by ""the proper abstraction.""  If you want to differentiate them though, you could take into account that * has an absorbing element and + doesn't. Going the other way, + forms a (commutative) group (if negatives are included at least) but * doesn't."
haskell,3b8c5a,weisbrot,1 point,Fri Jun 26 21:03:30 2015 UTC,"I have this in an edit, but apparently reddit is being super slow actually processing it, so I'll just post it here again:   I mean partially-applied plus is monomorphic. As far as I know, this property is distinct (not derivable) from the others I've mentioned, yet very important, since it means x + a = z and x + b = z implies a = b."
haskell,3b8c5a,tailcalled,3,Fri Jun 26 21:04:26 2015 UTC,"I think that's given by ""division"" in a group. If x + a = z and x + b = z, we know that x + a = x + b. Since all elements of a group have inverses, we can say (-x) + (x + a) = (-x) + (x + b) and arrive at a = b that way.  (Also, I edited my comment to include a couple differences between + and *)"
haskell,3b8c5a,weisbrot,4,Fri Jun 26 21:28:43 2015 UTC,"But plus on the naturals does not form a group. There are no inverses. Yet it still has this property. And we still call it ""plus""."
haskell,3b8c5a,danharaj,3,Fri Jun 26 21:35:18 2015 UTC,Good point. You could say that natural number addition forms a cancellative commutative monoid.
haskell,3b8c5a,abaquis,7,Fri Jun 26 21:45:42 2015 UTC,"All of your examples form a module over some rig. That may be what you're looking for, though you will need to adjust it a bit - for instance by requiring it to be cancellative - if you want all the properties to hold."
haskell,3b8c5a,tailcalled,1 point,Fri Jun 26 20:20:53 2015 UTC,the naturals are not a module
haskell,3b8c5a,_AndrewC_,5,Sat Jun 27 02:10:36 2015 UTC,"Yes they are, over themselves. Note that I wrote rig, not ring."
haskell,3b5kv0,dagit,3,Fri Jun 26 03:51:18 2015 UTC,"I realize this was on /r/programming and /r/compsci recently, but I figured a lot of people here may not have seen it on those subreddits. It's really a high quality list. I think we can all learn a thing or two from the resources there.  Enjoy!"
haskell,3b8fg2,TheDryMan,6,Fri Jun 26 20:25:48 2015 UTC,"I'm new to Haskell myself, but I can point to some minor things that will make your code more 'Haskelly'.  iterate n a  = take n $ repeat a -- Oh... In fact: replicateM n a = sequence (iterate n a) -- e.g.  takeAllLines = replicateM 9 takeOneLine -- needs Control.Monad   Hoogle is your friend for finding these little things. I frequently forget the name of iterate myself...  Stylistically, two things. First, pattern matching  in functions definitions (quick examples) is much more usual than case expressions. Second, where clauses are somewhat more usual for helper functions than let ... in, (I think) especially functions that don't use your parameters. Combine these two and your code will 'scan' much faster by good Haskellers, getting you better advice than mine :)  Example:  sumAllPosibilites s = Seq.foldrWithIndex sum 0 s   where sum _ (FieldPossible n) c = Set.size n + c         sum _ _ c = c   Also, here, as you aren't using the index you could import Foldable and use foldr. Importing a module for one function seems to be more the rule than the exception in Haskell, especially for anything in the Typeclassopedia."
haskell,3b8fg2,jmillikan2,4,Fri Jun 26 23:58:58 2015 UTC,"Definitely needs work if you're aiming for a functional style. Here is a tour of a number of SuDoKu solvers in Haskell. Code lines begin with > everything else is a comment.  Of note, four different solving methods are written in a total 156 lines.  Why do you want output while inputting the grid? Generally that's irritating. Otherwise, your input function could be simplified to:  takeAllLines = map (map $ (:[]) . check) <$> replicateM 9 (init <$> replicateM 10 getChar)"
haskell,3b8fg2,WarDaft,1 point,Sat Jun 27 00:53:04 2015 UTC,You can use hlint to check your code.
haskell,3b8fg2,a66ath,1 point,Sat Jun 27 19:41:43 2015 UTC,"I agree with other people so far about some stuff, I'll try to cover some bits without changing the goal of the program:   takeOneChar returns a string. That feels weird to me. It should return a char. Read is typically used for consuming the output of Show. It doesn't have to be, but it tends to be. The code you've got reads an int, and should probably be in a special ""String -> Field"" function and not Read. In the read definition you shouldn't need to have a type on the read in the FieldNum case, since the type of that data is in the definition of FieldNum multiListToField's l1 is called concat it seems to me that multiListToField could be mitigated by only ever having fields and Sequences. You could parse the input directly into a Field and just always be building up a sequence of fields. Fewer lets and more wheres, just in general. I know they seem weird now, and I think I did the same thing when I started, but they do grow on you In seqIndexHasDigit, the ""elem"" variable isn't needed, since you can just put the expression in the case, but beyond that ""elem"" isn't a good name since that's a function in Prelude. checkListForDigit, you should use the any function. It does what you want   Relatedly, there's never a reason to do ""boolValue == True"". That's just ""boolValue""  canHaveDigit:   A reimplementation of foldr (++) [] from above, still concat It looks like you're using Set.toList . Set.fromList for I can only assume uniqueness. Data.List export nub, which does uniqueness.  propositionUnique   Oh, you do know about any. Well, just to make things more confusing, any id is a function called or checkListForProposition looks like all, but checkOne would either have to return True where it currently returns c, or we could filter those out first using a filter.  In normalize field, my version of Set doesn't have elemAt, and the concept of an ordering to a set grumps me. I feel like I'd prefer findMin or findMax. That might just be me. Currying. There are a few places where you've done something like (\l -> fnc s (x,y) l), where you could have just done (fnc s (x,y))   I'm now on line 111, and I have to go out for a bit. I'll pick up when I get back, if you like"
haskell,3b8fg2,psycotica0,1 point,Sun Jun 28 15:47:21 2015 UTC,"Going to and from set is unfortunately more efficient than nub because it makes use of Ord. For small inputs it won't matter, though."
haskell,3b8fg2,hiptobecubic,1 point,Sun Jun 28 16:21:13 2015 UTC,"Oh, that's interesting. Makes sense.  Still weird, but yeah. My bad."
haskell,3b8fg2,psycotica0,1 point,Wed Jul 1 12:22:40 2015 UTC,"I'm back now, sorry it took so long   In a couple places, like line 120, you do case (e) where you could do case e. fnc from line 132 looked like it could be done with a fold, but when I looked into it, it was slightly more subtle because the Left case exited early. So, you could build a foldl that carried Left forward, but that wasn't awesome. Then I realized we're really in the Either Monad. So, you can do this:  import Control.Monad (foldM) fnc cs s' = foldM solveOneNumberInSequence s' cs   I'll go through this. If you already know what I'm talking about, or if you don't care, feel free to not listen. Note, the s' there is not Right s like you have in your input to fnc, but is just s, since foldM takes care of wrapping the base case for you.  The Monad definition for Either is such that Right a carries forwards in >>=, and Left b does not. So, what the fold will do is call solve with the input case and the current item, and if that returns Right then it will extract that and pass it in to the next item, and if it returns Left it will just return left from the whole thing.  It's possible I'm missing some subtle part of fnc, but I think this has the same semantics. Let me know if I'm wrong, or that's too much. Moving on.  Line 140, sum is already the name of a function. You can shadow it, as you are doing, but typically I prefer not to. When I was scanning through I saw sum and said ""Woah, that's not how you call that"" until I realized you had redefined it. Also in sumAllPossibilities, you're using foldrWithIndex, but not using the index. Seq implements Data.Foldable, so you can use foldr from there. That being said, you can also use fmap to turn each item into the set size or 0 otherwise, and then use sum from Data.Foldable to do the summing part. More roundabout, but also quite clear, in my mind. ""I turn it into a size, then sum them"". Some people disagee with me. doIterationsRec on line 148 takes in an Either String, and if it's passed in a Left it just returns it. That usually means the caller should be choosing to call this function or not, rather than passing a value in that means ""don't do anything"". I thought this looked like another foldM, but we're going until a condition, rather than iterating over a collection. So, I couldn't find anything that would help with this beyond just doing the recusion. You can still use the Monad instance to help, though:  doIterationsRec :: Int -> Seq.Seq Field -> Either String (Seq.Seq Field) doIterationsRec p s   | sumAllPossibilities s /= p = solveOneIteraction s >>= doIterationsRec (sumAllPossibilities s)   | otherwise = Right s   Notice that I no longer pass an Either in, and that I've switched the order of the arguments around to make the (>>=) nicer. In this case, the function is only ever called if there's a Right, so I don't have to case that out, and can then use guards because of that, and Lefts are automatically returned by the Monad instance for Either. At this point I've seen a lot of:  case e of     (FieldPossible f) -> *some thing involving f*     otherwise -> *default value*   Seems ripe for a helper function.  checkSeqElement num e = fieldCase False (\f -> Set.size f == num)  The algorithm of findSmallestToGuess starting on line 159, where we start by looking for anything with two possibilities, and then try more, seems unnecessarily expensive. I know it will shock you by now what I'm going to suggest, but I think you can use foldWithIndex and accumulate the index and the value, and use that to find the index of the smallest set in one pass through the sequence. In guessAndChange you define i, then read i, then old = read i, and while the i in the definition of read i is different than the i in the application of read i, it looks super confusing. And, if someone isn't paying attention, they might mistake the i in the (Seq.index s i) inside the read function as the i that was defined on the line above.  Also, read is also a function from the standard library, so it looks weird to see it used in that way.  I'm actually going to suggest something else, which is that read is only called in the one-line definition of old, and using the i that is defined above. If you replace read i with old, the code will be the same and compute the same thing, and won't have that extra function hanging around confusing things. On lines 183 and 184, you should be able to do Right $ upd $ FieldNum $ Set.elemAt n old and cut down on parens. Also, on 183 you can decide if you prefer what you have or concat [""No options left: "", show i, "" try:"", show n] solveWithGuessing on 187 immediately starts with more Either Monad applications. You're first testing you input again to see if it's Right or Left, followed right after by testing the result of that to see if that was Right or Left, which in the Right case is more testing. It gets so much better with >>=  If the things I've said so far don't help, you should read http://learnyouahaskell.com/a-fistful-of-monads#walk-the-line and know that the Either instance for Monad works the same way, except that failure can have data (Left a), rather than just Nothing.  Now, at some points in there it looks like you're actually handling Left, which the Monad stops you from doing, but that can still be done from outside. I'd have to play with it to see the right way, and I encourage you to try. solve should use >>= again. In prettyShow line 219 you have show (n) when you should only need show n Your function body calls one thing if Right, and another if Left, which is the either function.  in either id (\s' -> Seq.foldrWithIndex str """" s' ++ \n"")   If you prefer, you could also put that lambda in a function.  Actually, looking at it, it looks like you are always putting the accumulator at the end of the string, so it looks like you should actually do:  in either id $ Seq.foldrWithIndex str ""\n"" s'   Which saves another ++ at the end. Also, if you'll excuse me, I'm going to write prettyShow just to see how I'd do it:  import Data.List (intercalate) import Data.Foldable (toList) prettyShow s = either id display s ++ ""\n"" where display = concat . zipWith (++) (fmap nl [0..]) . fmap myShow . toList nl = -- the same definition you had myShow (FieldNum n) = show n myShow (FieldPossible n) = concat [""{"", intercalate "","" $ fmap show $ toList n, ""}""]   I've probably made an error in there, since I didn't actually compile it, but I think it does the same thing.  I split out the show into a function, and used intercalate instead of foldr to put commas inside the set. Then I used zipWith (++) to put one of those in front of each element, and finally put it all together with concat.  Unfortunately, I couldn't get rid of the ++ ""\n"", on the end, but then I realized you probably wanted that in the left case anyway, so I didn't feel as bad.  Now, that function above shouldn't necessarily be taken as ""right"". I write (perhaps surprisingly) for things to be read and understood by my brain, and it's probable that there's a more computationally efficient implementation that what I've written. Perhaps even your original.   Anyway, that's the end of my review. You can take from it what you like, and disregard the rest.  Let me know if you have questions..."
haskell,3b498l,bitmadness,37,Thu Jun 25 21:04:41 2015 UTC,"I'm not sure if this topic includes the Prelude, but I would replace String with Text everywhere  Edit: ... and add a Semiring super-class to Num"
haskell,3b498l,Tekmo,10,Thu Jun 25 21:33:55 2015 UTC,Have you seen TextualMonoid?  ( ͡° ͜ʖ ͡°)
haskell,3b498l,Spewface,5,Thu Jun 25 21:39:26 2015 UTC,Is there the possibility of that making it into the Prelude? What about cases where old code uses ++?
haskell,3b498l,joehillen,7,Thu Jun 25 21:59:06 2015 UTC,"I doubt it. The code is ridiculously overloaded and creates many new classes. But we can still just include the lib and use it! Also, this is just an alternative to mono-traversable, which is the main go-to for working with String-like data in a common interface."
haskell,3b498l,Spewface,3,Thu Jun 25 22:08:11 2015 UTC,"He probably did see one of the many classes like that on Hackage. Such kitchen-sink classes have been made for years, and they remain as undesirable today as ever (but will continue being created, of course!)."
haskell,3b498l,chrisdoner,11,Fri Jun 26 08:33:14 2015 UTC,"More generally, all instances of List should be replaced with a ListLike  class so that we can use efficient/specialized data representations with built in functions when we need to without having to convert them to an inefficient form.  I brought this up at a meetup once and I was surprised how many people didn't understand why linked-lists get so much hate:   https://kjellkod.wordpress.com/2012/02/25/why-you-should-never-ever-ever-use-linked-list-in-your-code-again/ https://www.reddit.com/r/haskell/comments/2k2z1t/discontiguous_data_structures_are_the_root_of_all/"
haskell,3b498l,joehillen,19,Thu Jun 25 22:06:58 2015 UTC,"The misconception is that List's purpose is to be a linked list. It's actual purpose is to be like an iterator, and it is alright for that purpose."
haskell,3b498l,julesjacobs,9,Fri Jun 26 00:47:54 2015 UTC,"It's kinda bad for that too, since it doesn't get fused away in left folds and thus cause allocation, unlike iterators in other languages."
haskell,3b498l,tibbe,17,Fri Jun 26 10:18:09 2015 UTC,"Actually, there is an IsList class already and you can overload all list literals to use this class if you enable the OverloadedLists language extension.  More details here"
haskell,3b498l,Tekmo,9,Thu Jun 25 22:08:44 2015 UTC,Isn't there a problem here in that IsList only has toList and fromList which call pack and unpack whenever you use a function in the Prelude? Thus killing performance.
haskell,3b498l,joehillen,2,Thu Jun 25 22:16:10 2015 UTC,I believe you mean the OverloadedLists extension.
haskell,3b498l,Taladar,1 point,Fri Jun 26 07:29:56 2015 UTC,"Oops!  Yes, you're right.  Fixed"
haskell,3b498l,Tekmo,13,Sat Jun 27 04:49:22 2015 UTC,"When you do so in both positive and negative position expect inference to basically just stop working -- for almost everything.  And even if you are willing to pay that price, then this isn't as nice a state to program with you might think it would be.   Worse, once you ""can"" start programming parametrically in the choice of list-like thing you tend to start doing so.   The best way to construct something using a Bytestring, Seq a, Text and String are rather radically different. Naive attempts to cons on the front are perfect for String and Seq, but are pathological for the other two cases. Chopping up a Bytestring or Sequence into smaller pieces is great on Bytestring, but those cuts are linear time in other cases, partially because Text doesn't give you fast slicing. Appends are fine for Data.Sequence, good left biased for lazy bytestrings and lazy text.."
haskell,3b498l,edwardkmett,7,Fri Jun 26 08:10:38 2015 UTC,"I guess my real frustration here is that if I decide to use Vector or Text for my application I can no longer use any functions in base without having to convert it to an inefficient representation, which always takes O(n). There is useful stuff in base, and it's annoying to have to import specialized versions of the functions or implement my own whenever I want to use Text, despite those functions being semantically the same.  Maybe what I really need/want is a way to be able to swap out base with base-text or base-vector or base-vector-text in ghc."
haskell,3b498l,joehillen,4,Fri Jun 26 15:22:07 2015 UTC,IMO just import the functions qualified.  V.map for vector.  Sure it is 1 or two more characters.  Or you could just Import Prelude excluding those functions and then import vector unqualified.  But in reality how often do we switch data structures for a piece of code and require no changes except an import?
haskell,3b498l,neitz,4,Fri Jun 26 21:14:44 2015 UTC,"Naive attempts to cons on the front are perfect for String and Seq, but are pathological for the other two cases.   You could queue up the slow operations and perform them all at once when another operation is invoked, like how the Okasaki queue operates."
haskell,3b498l,naasking,8,Fri Jun 26 12:22:32 2015 UTC,... which is predicated on knowing which operations are slow on the particular type you are working with.
haskell,3b498l,edwardkmett,4,Fri Jun 26 14:49:21 2015 UTC,This would be encapsulated within the type's implementation.
haskell,3b498l,naasking,1 point,Fri Jun 26 15:34:05 2015 UTC,"This is the one problem that OOP has been able to solve better than other types of languages.  Of course, Scala is the only language which really gets it right, and only because of its labyrinthine standard library."
haskell,3b498l,nosewings,3,Fri Jun 26 20:56:33 2015 UTC,Yep. All you have to is basically give up inference.
haskell,3b498l,edwardkmett,2,Fri Jun 26 20:59:07 2015 UTC,Scala is nothing if not a language of compromises.
haskell,3b498l,nosewings,5,Fri Jul 3 06:36:09 2015 UTC,... and add a Semiring super-class to Num   Float is not a semiring.
haskell,3b498l,nosewings,4,Fri Jun 26 07:45:53 2015 UTC,"I am not familiar enough with the concept of a semiring to judge what the problem is but while we are at it, Float should not have an instance of Eq either."
haskell,3b498l,Taladar,1 point,Fri Jun 26 17:14:45 2015 UTC,"I've discussed this here recently, and the takeaway ended up being that Eq doesn't actually have any laws, so the Eq instance for Float is technically valid."
haskell,3b498l,nosewings,3,Fri Jun 26 17:26:21 2015 UTC,"Well, it is technically valid but any good article on floating point tells you that you shouldn't compare the in memory representation of two floating point numbers but use some epsilon value and if they are that close together you consider them equal."
haskell,3b498l,Taladar,1 point,Fri Jun 26 17:35:29 2015 UTC,"Right, but surely we shouldn't prevent the programmer from doing a straight equality check?"
haskell,3b498l,nosewings,1 point,Fri Jun 26 20:58:13 2015 UTC,"As long as we are talking about floating point only, why not?"
haskell,3b498l,Taladar,1 point,Fri Jun 26 21:36:39 2015 UTC,"Because even if it's not best practice in most cases, that's not really something the standard library should be deciding for you."
haskell,3b498l,nosewings,2,Fri Jun 26 21:38:56 2015 UTC,How about going the usual Haskell route of preventing the programmer from doing the convenient but wrong thing and having some function like unsafeDirectFloatingPointComparison hidden away somewhere in a module you need to import explicitly?
haskell,3b498l,Taladar,2,Fri Jun 26 21:47:44 2015 UTC,"unsafe is usually reserved for functions which are, in general, unsound in a type-theoretic sense, not just easy to misuse."
haskell,3b498l,nosewings,1 point,Fri Jun 26 23:20:13 2015 UTC,"the derived Eq instances, and most of the manual instances I write, satisfy being an equivalence relation.  the documentation is lawless, but we should just fix the docs. (unless it's left unspecified in the haskell report or something? but then it shouldn't be called Eq).  that's (symmetry in particular) what makes Eq better than when I write equivalences in Java. you can't have some class with an Eq method that always returns true or false, when it's on the left."
haskell,3b498l,sambocyn,2,Sun Jun 28 23:11:08 2015 UTC,"I agree that Eq instances should probably be required to represent equivalence relations. But then what do you do with Float? Do you violate IEEE? Or do you simply not include an Eq instance, instead forcing the programmer to use a newtype?"
haskell,3b498l,nosewings,1 point,Fri Jul 3 06:34:17 2015 UTC,"hmm, shouldn't you always be explicit what precision the equality has for floating-point numbers? like eqFloat range x y."
haskell,3b498l,sambocyn,2,Fri Jul 3 07:29:01 2015 UTC,"Yes, but the programmer should still be able to do a direct comparison if desired.  The more basic problem is that equality of Floats is not reflexive, because NaN == NaN evaluates to False."
haskell,3b498l,nosewings,48,Fri Jul 3 07:44:36 2015 UTC,No exceptions.  What's the point of having such a powerful type system if it is not only possible but actually considered okay to just shoot it in the face?
haskell,3b498l,WarDaft,20,Thu Jun 25 21:29:40 2015 UTC,I'd go even further. No partial functions. Totality checker by default.
haskell,3b498l,tailbalance,4,Fri Jun 26 01:53:07 2015 UTC,Doesn't this also exclude some total functions?
haskell,3b498l,sccrstud92,10,Fri Jun 26 01:58:20 2015 UTC,Not if you ask /u/pigworker.
haskell,3b498l,nosewings,18,Fri Jun 26 08:19:38 2015 UTC,"Thus invoked, I thought I'd pipe up and observe that to go total, you'd really need to change a lot more than one thing about Haskell. In particular, what Haskellers like to call ""pure"" is really the blessed monad of failure-finite-and-infinite: possible outcomes include defeat and stalemate as well as victory. And it is blessed with a very great blessing, namely the ordinary notation of functional programming. ML blesses a rather skankier monad, but the same applies.  The point about total programming is not that you never program with failure or looping, but that you document these things honestly. To make that work in Haskell, it would become necessary to do monadically what is currently done in the blessed ""pure"" syntax, which is very far from a cost-free change.  So, the thing to think about, or at least what I think is the thing to think about, is how to arrange for the blessing of a monad to be localisable.  I'd also note that total programs require inevitably pessimistic documentation of risk: that is the impact of the negative results, not the ""exclusion"" of functions altogether. In a partial setting, risk is everywhere; in the total setting, you can sometimes do better. How much better depends on the precision of your language for documenting risk. That's why total programming really benefits from dependent types, and not just the other way around."
haskell,3b498l,pigworker,3,Fri Jun 26 10:44:25 2015 UTC,Are there any total languages you would recommend looking at?
haskell,3b498l,bb010g,7,Sat Jun 27 00:33:35 2015 UTC,"I'd recommend looking at Agda, Idris and Coq. I think Idris is the most getting-stuff-done of the three. Coq is much the better theorem prover. Agda currently gives the best type-directed programming experience (but Idris is catching up). There is considerable room for improvement all round.  Mostly, I don't do language advocacy. More than my job's worth."
haskell,3b498l,pigworker,4,Sat Jun 27 01:10:17 2015 UTC,"It depends on how it's implemented.  Most functions you normally use are still perfectly acceptable. The average programmer rarely needs more than straightforward structural recursion, which can easily be decided by the typechecker.  More nuanced recursion schemes are problematic. When the recursion acts on some invariant that depends on the arguments, but explicit in their structure, you will have a hard time. The simplest example would be something like the gcd function, and the next simplest is mergesort. In the gcd, the recursion is on the fact that every subsequent argument is smaller in absolute value. (And if you pass in 0, this invariant breaks, and you get stuck in a loop). The mergesort recursion scheme relies on the fact that a ""sublist"" of a list is shorter in length.  Lastly, there is the minor issue of general recursion. Almost no programs you'll write in software will require general recursion. But at least, you can't write an evaluator for the language you're working in."
haskell,3b498l,tactics,2,Fri Jun 26 02:46:41 2015 UTC,"Not really. This is one thing Idris handles beautifully IMO.  It's definitely the case that not all total functions can be certified as such by a totality checker, but this is fine because we're only trying to keep as much in the total fragment as possible/practical, but not more. You won't be obligated to make all functions total, only encouraged to be aware of what is or isn't certifiably total. Generally this means using %default total at the beginning of every file, and then explicitly marking certain functions as partial where necessary (or %assert_total them), but all of that can be skipped if you don't care to worry about totality."
haskell,3b498l,BlackBrane,4,Fri Jun 26 10:56:46 2015 UTC,In fantasyland I'd still like partial functions. Just so long as my SMT solver can prove main is total.
haskell,3b498l,zoomzoom83,1 point,Fri Jun 26 02:42:37 2015 UTC,Is this even possible in the real world?
haskell,3b498l,tsahyt,2,Fri Jun 26 09:41:14 2015 UTC,"That sounds very annoying. I often write functions which are only used internally to implement others and for which I know that the input will be of some form. In that case it's great to be able to add an extra ˙func _ = error ""Something broke the assumption at <LINE>""`"
haskell,3b498l,Darwin226,3,Fri Jun 26 08:25:45 2015 UTC,It’s ghc. There’s always going to be LANGUAGE PerlPlease or something.
haskell,3b498l,tailbalance,7,Fri Jun 26 08:48:55 2015 UTC,"I suppose your question was rhetorical, but the paper on imprecise exceptions answers it.  See page 3."
haskell,3b498l,massysett,10,Thu Jun 25 23:55:08 2015 UTC,"I still consider Exceptions to be a useful feature, to a degree.   There are some types of errors that can happen that I simply do not want to have to plumb through my stack, nor do I care about recovering from since they are likely to be critical failures. But I do want to be able to have some basic ability to catch them and gracefully report them to the user before dying.  Things like network failures, disk failures, printer on fire.... These are simply not expected conditions I'd normally want to encode as possible failures in my types."
haskell,3b498l,zoomzoom83,20,Thu Jun 25 23:51:00 2015 UTC,"As someone who writes a lot of network code, and deals with a lot of poorly written network code, I think ignoring failure conditions is a really bad idea. I'd so much rather have IO Either a b than IO b for these kinds of operations in Haskell. Same goes for disk failures and printer IO failures. All of that stuff needs to be handled if you want to write a program that doesn't suck."
haskell,3b498l,radix,14,Fri Jun 26 02:16:46 2015 UTC,"The problem is that pretty much every IO could potentially fail. My output buffer could be full, my disk could have bad sectors, the network could be down, and stray cosmic ray could flip a random bit of memory. You're dealing with ""The World"", and the world has an almost infinite range of possible things that could go wrong that I don't care about.  There is (almost) no such thing as an IO without a failure case. So every single side-effecting function would then inherently become ""IO Either a b"", at which point you might as well roll that up into a monad transformer and call it ""MyIO"" and be back at square one, because if you squint that's effectively what IO already is.  I want to encode expected failures as part of my type system, things that are part of my normal flow control. ""File not found"", ""DNS name not resolved"", things that I would reasonably expect to happen.  Except in extremely low level code, things like ""The disk controller failed"" or ""Somebody tripped over the network cable"" are not expected conditions, and I don't ever care about dealing with them. They are out of band signals that I want to be able to catch at a very high level and provide a graceful ""500 - Server Error"" page instead of completely crashing.  The problem, I suppose, comes down to the fact that every use-case has a different definition of what should be considered ""Flow Control"" and ""Exceptional""."
haskell,3b498l,zoomzoom83,9,Fri Jun 26 02:35:13 2015 UTC,"If you leave error (and Monad's fail / MonadFail) in the language, then you still have a mechanism to easily ignore it. You just have to change x <- doIO to Right x <- doIO, and your program will continue to have the blow-up-when-something-goes-wrong behavior. Granted, that throws away useful error messages that occur in the Left, but there's probably a way to improve that by default in the IO monad and a cooperating error type.  The problem is that too many programs don't handle errors when they should. Putting it in the type system helps us keep track of whether we have handled all the errors, without making it unduly hard to write quick hacks that don't handle errors."
haskell,3b498l,radix,2,Fri Jun 26 04:52:46 2015 UTC,"If you're referring to the error function that simply blows everything up even in a pure function - In that case, yes I agree this should not be used. (Nor should blindly deconstructing Right for the same reason).    The problem is that too many programs don't handle errors when they should. Putting it in the type system helps us keep track of whether we have handled all the errors, without making it unduly hard to write quick hacks that don't handle errors.   Sure, but how far down the rabbit hole of type safety should you go? I could argue that corrupt ECC memory is a potential error and you should encode it in your type system. But short of kernel level code, I probably don't care, and cannot reasonably do anything with it, so there is no benefit whatsoever for me having to add plumbing for it.  Functions should provide type-system guarantees for things that could reasonably be expected to occur, everything else is just noise that gets in the way of handling things that are important. The best I can ever do is to bubble them up and deal with in a panic handler whether the plumbing is implicit or explicit."
haskell,3b498l,zoomzoom83,3,Fri Jun 26 06:42:17 2015 UTC,I will argue against an ECC memory failure as an error type. I will argue that connection lost and file not found should be encoded. I only want to address the errors that do need to be dealt with.
haskell,3b498l,radix,4,Fri Jun 26 12:39:32 2015 UTC,"But the users of your program might!   You're dealing with ""The World"", and the world has an almost infinite range of possible things that could go wrong that I don't care about."
haskell,3b498l,dhjdhj,2,Fri Jun 26 03:32:08 2015 UTC,"But the users of your program might!   Which is why I still want a mechanism to deal with exceptional scenarios gracefully, without polluting my normal flow control with scenarios that cannot be handled at that level."
haskell,3b498l,zoomzoom83,1 point,Fri Jun 26 04:07:15 2015 UTC,Agreed
haskell,3b498l,dhjdhj,2,Fri Jun 26 11:07:53 2015 UTC,"""The World""  https://www.youtube.com/watch?v=CamPXxfl7Lw"
haskell,3b498l,clrnd,4,Fri Jun 26 14:22:04 2015 UTC,"Not to be argumentative, but what you just said was, essentially, ""As someone who writes code where X is important, I think not doing X is a very bad.  You have to do X if you don't want your program to suck.""  This is probably true for the programs you often write.  But don't fall into the trap of thinking success means the same thing for everyone.  There are plenty of situations where letting errors blow up at runtime is a valid tradeoff, for example."
haskell,3b498l,cdsmith,8,Fri Jun 26 03:36:53 2015 UTC,"There are all kinds of things I want to say:   This is Haskell. Haskell focuses a lot on safety. Let's not throw it out just because there's some IO involved. I didn't say anything about avoiding errors at runtime. I didn't mention totality. So you can still have error if you want. I was just backing up my argument with some experience with both using and trying to write software that doesn't suck. Getting completely unhandled errors, as a user, sucks."
haskell,3b498l,radix,1 point,Fri Jun 26 04:49:33 2015 UTC,This is precisely the different in priorities between application-level code and systems-programming code
haskell,3b498l,Platz,2,Fri Jun 26 15:41:04 2015 UTC,"It depends. As a user, I want applications to provide information to me about what went wrong. If I'm using some application, whether GUI or command line or whatever, I want to know that the application couldn't save my file or make a network connection, and I want it to be presented to me in a useful way. If I'm writing a backend distributed system, I want to make sure that my program gracefully handles unavailability of remote services. So in some sense, it's an application concern.  But it is also often possible to abstract away these concerns from core logic in an app. You can define your core logic in some monad other than IO (or even other things than a monad), and then have the IO layer do appropriate things with the errors."
haskell,3b498l,radix,15,Fri Jun 26 17:04:49 2015 UTC,"People need to distinguish what they mean by exceptions.  There are three different kind of exceptions that one could be referring to:  1) Checked impure exceptions, which have type:  -- `UnexceptionalIO` is from the `unexceptionalio` package ExceptT e UnexceptionalIO a   2) Unchecked impure exceptions, which have type:  IO a   3) Checked pure exceptions, which have type:  Either e a   4) Unchecked pure exceptions (i.e. error), which have any type:  a   The latter are the worst kinds of exceptions because they don't show up in the type!  All other forms of exceptions are okay in that you at least get some warning (even if it's just IO, at least it's something)."
haskell,3b498l,Tekmo,9,Fri Jun 26 03:08:52 2015 UTC,"When people complain about ""exceptions in Haskell"" they're generally talking about 2 and 4.  You can't forbid 1 and 3 after all!  They come for free as soon as you have sum types."
haskell,3b498l,tomejaguar,7,Fri Jun 26 08:45:30 2015 UTC,My own posts have been about unchecked synchronous IO exceptions (I think you left out asynchronous exceptions from your list).
haskell,3b498l,radix,2,Fri Jun 26 04:55:25 2015 UTC,"Well, if you like the taste of irony, the best use I can think of for exceptions is to allow you to write functions which lift normal higher order to ones working on functions that explicitly encode their error possibilities via types. I don't know if there is a library for this already or not.  This is a very incomplete example, but consider:  eitherThrow (Left s) = error s eitherThrow (Right a) = a  catchEitherProducer :: (a1 -> Either [Char] c) -> ((a1 -> c) -> IO a) -> IO (Either String a) catchEitherProducer fe r = catch ((Right <$>) $ r $ eitherThrow . fe) (\e ->     let err = show (e :: ErrorCall) in return $ Left err)   Now you'd probably want to flesh it out with a custom Either error type, likely rearrange arguments for better lifting convenience, and probably make a general CatchProducer type class, but I don't like exceptions, so that exercise is left up to the reader.  I don't know if this can be written without exceptions though, because we're basically tearing apart a case statement so we have one case in one place and the other case in another altogether. Cont might help here."
haskell,3b498l,WarDaft,2,Fri Jun 26 01:29:09 2015 UTC,There is a standard function called try which does this for you.
haskell,3b498l,Crandom,4,Fri Jun 26 07:33:53 2015 UTC,There is a standard library function called X which does this for you.    Thanks for summing up my Haskell learning experience.
haskell,3b498l,kqr,3,Fri Jun 26 07:55:44 2015 UTC,"Control.Exception.try is in base - not much more standard than that?   But yes, that is my experience with haskell too. I generally ""invent"" something then paste the type signature into hoogle to see what it's called."
haskell,3b498l,Crandom,1 point,Fri Jun 26 08:05:41 2015 UTC,"Sure, try is, but I was talking about more my general experience, not specifically with try."
haskell,3b498l,kqr,2,Fri Jun 26 09:45:38 2015 UTC,"Try does not do this exactly. Try takes a function which produces unchecked exceptions and gives you a checked type signature as a result.  The purpose of catchEitherProducer is to take a function that produces checked errors in its type and use it as if it were the type of an error free function (or unchecked errors, if you prefer), then safely collecting the error in the resulting type of the operation the now error type free function was passed to.  Try does make it easier to write this, thank you for pointing that out, and it does have a much cleaner definition... but even still you have to use exceptions to complete it.   eitherThrow (Left s) = error s eitherThrow (Right a) = a  catchEitherProducer :: (a1 -> Either [Char] c) -> ((a1 -> c) -> IO a) -> IO (Either ErrorCall a) catchEitherProducer fe r = try . r $ eitherThrow . fe"
haskell,3b498l,WarDaft,1 point,Fri Jun 26 18:04:38 2015 UTC,"Actually, I wonder if this can be counted as a language feature/bug. It is somehow represented in the created AST, but its practically not supposed to work in the original type system of the language."
haskell,3b498l,Vektorweg,18,Fri Jun 26 17:08:31 2015 UTC,"I'd adopt some of the niceties of Clojure:   Let -, !, and ? be part of named identifiers so you could write foo? instead of isFoo, or bar! instead of sideEffectingBar, and gooble-gobble instead of goobleGobble. The nice thing about this casing style is that you don't have to use the shift-key nearly as much. The downside is that it would require spacing for some operators where it didn't before, but I kind of loathe a lack of spacing between named identifiers and operators. Have syntax for sets, map-like structures, and symbols I don't know how I'd do this, but it would also be nice to have a way of rebinding global variables such as the stdin/stdout/stderr handles so that you could easily redirect putStrLn et al elsewhere. Being able to hot-load code into a running process via the REPL, assuming that it typechecks with the rest of the program. Also, being able to poke at a running process with a REPL is nice for debugging purposes. Built-in docstrings / metadata support. Haddock feels a bit like a hack to me in this regard.   Not clojure-based wishes:   Just supporting more extensions by default. Fundeps, GADTs, multi-param type classes have been around for ages, and they clearly provide a lot of value. Let's just make them official. Real built-in C++ FFI support. Surely we've got the appropriate machinery in place with multi-param type classes and functional dependencies to be able to make this a reality? There are so many libraries that could be used better if we had this. Less verbose module/import syntax. module Foo where could just be module Foo, the where doesn't add much. Make map just be fmap already. Make ++ just be mappend already, or else put <> in Prelude. Strict fields by default without having to use !, lazy fields by adding ~. Some sort of default args / named parameter support that doesn't feel janky."
haskell,3b498l,semigroup,4,Fri Jun 26 13:10:58 2015 UTC,"I would indeed prefer allowing - and ? in identifiers. Not sure the need of ! since we already declare IO with the type. (well, maybe unsafePerformIO could be renamed unsafe!!performIO!!!...)  +1 for hotloading code, even in contexts other than the REPL. There's a recent Facebook blog post that indicates they're doing that: https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/  better documentation syntax indeed. It bugs me that so many languages have the convention of putting function documentation before the function declaration, where you don't even know what function we're talking about yet..."
haskell,3b498l,radix,3,Fri Jun 26 17:16:54 2015 UTC,"Fundeps, GADTs, multi-param type classes have been around for ages, and they clearly provide a lot of value. Let's just make them official.   Fundeps or Type Families? Combined with GADTs, Type Families are nicer, and there is a lot of overlap between Fundeps and Type families (I think GHC treats them the same).   These sorts of questions are why these extensions haven't been incorporated yet."
haskell,3b498l,kamatsu,2,Sat Jun 27 11:17:38 2015 UTC,"Yeah, I'm pretty sure they're the same under the hood (or at least used to be)-- I'd opt for both I guess... I feel like each route can be more elegant depending on the circumstances.  I'm quite aware (and glad) that the official language is conservative about adopting new extensions into the fold, and that answering questions like this are crucial to that process, but I use a number of these extensions so extensively that it's really just selfishness on my part so that I wouldn't have to do so much typing :)"
haskell,3b498l,semigroup,1 point,Sat Jun 27 18:41:46 2015 UTC,This guy gets it.
haskell,3b498l,rdfox,1 point,Sat Jun 27 05:18:59 2015 UTC,"Haskell has ADTs, where Clojure would need untyped dicts. I tend to have a sweet-tooth for syntax, and I don't see a need for Map literals. band Set syntax exists as OverloadedLists (except for the slight loss of inference)."
haskell,3b498l,sambocyn,1 point,Sun Jun 28 23:17:37 2015 UTC,"doesn't GHC have a ""setHandle"" like function that redirects in later calls to putStrLn?"
haskell,3b498l,sambocyn,1 point,Sun Jun 28 23:18:52 2015 UTC,"for syntax, I'd go FULL AGDA and provide for non-alphanumeric characters to be freely mixable with alphanumeric characters (counting as not an operator). I already put spaces between operators and operands.  and mixfix..."
haskell,3b498l,sambocyn,1 point,Sun Jun 28 23:21:58 2015 UTC,"I like syntactic consistency (the where clause introduces declarations), but here I agree with ""module Foo""."
haskell,3b498l,sambocyn,15,Sun Jun 28 23:24:39 2015 UTC,Rename pure and return to wrap.
haskell,3b498l,enzain,6,Thu Jun 25 22:59:46 2015 UTC,"Now that Monad is strictly a subtype of Applicative, is there a need for return?"
haskell,3b498l,lyinsteve,16,Fri Jun 26 01:16:17 2015 UTC,"Eventually we may remove return from Monad and move it to a top level definition, so we can reduce its constraint to Applicative at the least.   This would be beneficial from a type inference standpoint, but I anticipate pain. We're going to run a trial balloon for this sort of thing with the movement of mapM from the Traversable class to the top level (spread over a couple of releases) and see how folks react to that before we consider doing so though."
haskell,3b498l,edwardkmett,2,Fri Jun 26 08:08:55 2015 UTC,"On the bright side, we can mostly ignore that return is a method. I.e. we don't even have to override it when defining Monad instances (from post-AMP base-4.8/GHC 7.10 on). In fact, we could easily have a future Haskell Report and the associated haskell201x package consider return to be a top-level binding rather than a class-method, even if base continues to provide it as a method Monad(return) for the forseeable future.  In other words, the next version of the Report that incorporates the AMP doesn't have to contain this Monad(return)-wart."
haskell,3b498l,hvr_,10,Wed Jul 1 07:47:47 2015 UTC,"no, they are identical"
haskell,3b498l,enzain,5,Fri Jun 26 01:24:09 2015 UTC,Then that's something I'd change 😉
haskell,3b498l,lyinsteve,5,Fri Jun 26 01:31:50 2015 UTC,"And rename coerce to untag, perhaps."
haskell,3b498l,_AndrewC_,1 point,Fri Jun 26 05:50:45 2015 UTC,"And replace (>>=) with bind :: (a -> m b) -> m a -> m b, in keeping with the usual argument order for higher-order functions."
haskell,3b498l,nosewings,1 point,Fri Jun 26 21:01:54 2015 UTC,"I like the ""return"" name very much. I think it's just great to see how often monadic code in Haskell looks exactly like it's equivalent in a nonfunctional language."
haskell,3b498l,Kaligule,13,Sun Jun 28 17:30:04 2015 UTC,"a better record system, definitely. one like PureScript's or Elm's."
haskell,3b498l,gilmi,12,Fri Jun 26 07:21:47 2015 UTC,shouts from the bleachers PI TYPES!
haskell,3b498l,Spewface,15,Thu Jun 25 21:37:37 2015 UTC,"Well, thinking big, perhaps it would have been neat if the language was total, distinguished data from codata, and had a Partial monad for Turing-complete programs..."
haskell,3b498l,sacundim,11,Thu Jun 25 22:27:18 2015 UTC,fix foldl
haskell,3b498l,joehillen,42,Thu Jun 25 22:07:23 2015 UTC,fix foldl isn't even well-typed :(
haskell,3b498l,prophile,5,Thu Jun 25 22:15:13 2015 UTC,harr harr
haskell,3b498l,joehillen,33,Thu Jun 25 22:19:07 2015 UTC,"A simple one - Swap "":"" and ""::"" :)"
haskell,3b498l,sordina,13,Fri Jun 26 02:09:36 2015 UTC,I think we can call this proposal the S:::P
haskell,3b498l,theonlycosmonaut,1 point,Fri Jun 26 07:33:56 2015 UTC,"Context please? As long as it's an... appropriate reference, at least."
haskell,3b498l,Enamex,2,Fri Jun 26 17:32:33 2015 UTC,"AMP, FTP... logical progression. 'Swap : and :: proposal'"
haskell,3b498l,theonlycosmonaut,5,Sat Jun 27 03:44:19 2015 UTC,"so, idris?"
haskell,3b498l,agcwall,10,Fri Jun 26 04:34:30 2015 UTC,Sml had them swapped before Haskell even existed
haskell,3b498l,jmite,9,Fri Jun 26 06:11:14 2015 UTC,Sounds like a line from a Robert Harper post.
haskell,3b498l,chrisdoner,2,Fri Jun 26 08:40:34 2015 UTC,Scala does the same. It is actually the correct mathematical syntax.
haskell,3b498l,Die-Nacht,3,Fri Jun 26 13:24:14 2015 UTC,It is actually the correct mathematical syntax.    After Haskell lead me to read more and more math documents in recent years I am not convinced such a thing exists...at least not one more than 90% of all mathematicians can agree on for any given bit of notation.
haskell,3b498l,Taladar,3,Fri Jun 26 17:17:58 2015 UTC,"I thought this notation was accepted by all:  f: x → y  Examples of this: http://ncatlab.org/nlab/show/morphism  For other concepts I've seen conflicting syntax but ""type"" syntax seems to be accepted by everyone."
haskell,3b498l,Die-Nacht,2,Fri Jun 26 17:54:22 2015 UTC,Same in Rust
haskell,3b498l,pi3r,2,Fri Jun 26 16:18:24 2015 UTC,Where is that? You mean the : (also |) in set-builder notation?
haskell,3b498l,Enamex,1 point,Fri Jun 26 17:33:47 2015 UTC,Huh? Not sure what you mean. I mean type notation:  def f : Int => String = ... or  val x : Int
haskell,3b498l,Die-Nacht,1 point,Fri Jun 26 17:49:53 2015 UTC,"Huh? Not sure what you mean. I mean type notation: def f : Int => String = ... or val x : Int   I mean why is it ""the correct mathematical syntax""?"
haskell,3b498l,Enamex,3,Fri Jun 26 19:01:03 2015 UTC,"If you read any math papers (specially category and set theory), you will see things like:  f: x -> y  For example: http://ncatlab.org/nlab/show/morphism"
haskell,3b498l,Die-Nacht,1 point,Fri Jun 26 19:17:16 2015 UTC,Haven't seen that notation since my introductory Algebra course.
haskell,3b498l,Enamex,1 point,Fri Jun 26 21:49:00 2015 UTC,"Interesting, I don't know of any other type notation (in math).   What notation have you been seeing?"
haskell,3b498l,Die-Nacht,2,Fri Jun 26 21:59:17 2015 UTC,"No particular syntax. My exposure to math is very basic compared to everyone here (think introductory Calculus-basic, certainly not type theory-lvl); and, where applicable, we always wrote about 'domains and co-domains', literally, instead of signifying in symbols that f 'maps' from one to the other. In fact, I haven't heard functions being called 'maps' since Intro Algebra where that exact notation was used (but more like f: x |-> y where the |-> is smaller and more arrowy)."
haskell,3b498l,Enamex,24,Fri Jun 26 22:57:39 2015 UTC,"A complete overhaul of the Prelude. The Applicative=>Monad proposal is a good start, but there's a lot that could have been done better:   Build the Base library around OverloadedLists and OverloadedStrings from the start, with (as /u/joehillen suggested) some kind of ListLike typeclass (supporting cons, head, and tail) used in most of the places where lists are used, as well as a StringLike typeclass everywhere the Prelude uses strings. Make most of the Prelude IO actions strict by default. Lazy IO can still exist, but only when it's explicitly used. Better numeric types, and better ways to convert between them without having to go through Rational as an intermediate step Monad transformers, or something with similar functionality that is less order-dependent, as a fundamental concept in the same way that Monads are, perhaps with special syntax and/or type system support to reduce the lift noise and other weirdness."
haskell,3b498l,ar-nelson,10,Thu Jun 25 23:14:23 2015 UTC,"Locally scoped imports. And then really locally scoped imports in the OCaml style  Vector.(generate 100 id ! 30)   The syntax probably won't play nicely with Haskell, but it'd be nice to reduce the pain of qualified imports. I'd even suggest that ""local imports"" wouldn't work unless they were also imported qualified at the top of the file. This will mean it remains easy to see all of the dependent modules for a file and reduce syntactic burden locally within the file.  import Data.Vector as Vector -- because as long as we're playing with import syntax  {- ... -}  someDumbFun1 : Int -> Int someDumbFun1 = Vector.(generate 100 id !) -- section syntax complies?  someDumbFun2 : Int -> Int someDumbFun2 = (vec !) where   open Vector   vec = generate 100 id  someDumbFun3 : Int -> Int someDumbFun3 = (generate 100 id !)  -- error: generate and (!) are unknown"
haskell,3b498l,tel,3,Fri Jun 26 13:20:00 2015 UTC,I've never seen that OCaml syntax before. That's pretty sweet.
haskell,3b498l,nosewings,10,Fri Jun 26 21:12:37 2015 UTC,"Remove record syntax.  There are a lot of opportunities to do the right thing with records now, but the existing record syntax means that whatever happens will face a 5 year long gradual migration, and that leads to a lack of motivation to get the process started."
haskell,3b498l,cdsmith,3,Fri Jun 26 03:22:10 2015 UTC,What's wrong with record syntax?
haskell,3b498l,nosewings,2,Fri Jun 26 08:00:27 2015 UTC,I think cdsmith is saying the existence of record syntax is a psychological impediment to getting something better.
haskell,3b498l,tomejaguar,1 point,Fri Jun 26 08:53:56 2015 UTC,Like what?
haskell,3b498l,nosewings,9,Fri Jun 26 08:55:35 2015 UTC,"For example, different records using the same field name is a common request."
haskell,3b498l,tomejaguar,4,Fri Jun 26 08:58:11 2015 UTC,Be careful what you wish for... https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
haskell,3b498l,adamgundry,1 point,Fri Jun 26 11:42:31 2015 UTC,"I don't get it. That ext. was the first thing to occur to me; /u/cdsmith , is that what you meant?"
haskell,3b498l,Enamex,1 point,Fri Jun 26 17:31:57 2015 UTC,"Mm, found this : https://github.com/nikita-volkov/record ."
haskell,3b498l,Enamex,12,Sun Jun 28 11:53:44 2015 UTC,"I'd give Haskell Elm's record syntax. They're so easy to use, gentle in their transition from OO, and based on some really nice type theory."
haskell,3b498l,jmite,23,Fri Jun 26 06:13:05 2015 UTC,"A proper, ML-like module system instead of the current sad state of affairs."
haskell,3b498l,srhb,4,Thu Jun 25 21:56:59 2015 UTC,"Having programmed in Agda, this is the one thing I miss the most when coming back to Haskell."
haskell,3b498l,nosewings,4,Fri Jun 26 07:59:33 2015 UTC,This.   I like to believe that a proper module system (whatever it looks like) would also help with the current extreme fragility of the package ecosystem.
haskell,3b498l,fridofrido,10,Fri Jun 26 08:37:31 2015 UTC,"Aren't ML users frustrated with the module system they have too? The fact that ML has two different languages, a function-level and a module-level language, has been a complaint."
haskell,3b498l,kyllo,6,Fri Jun 26 02:35:47 2015 UTC,"The module systems of the ML languages aren't perfect, but compared to ML, Haskell doesn't feel like it has anything worth even being called a module system."
haskell,3b498l,twistier,4,Fri Jun 26 04:37:22 2015 UTC,Compared to C and similar languages with textual includes Haskell feels much better though.
haskell,3b498l,Taladar,12,Fri Jun 26 07:33:30 2015 UTC,"And compared with punch cards, C feels much better. I think we should be a bit more ambitious than that :p"
haskell,3b498l,TarMil,7,Fri Jun 26 08:21:24 2015 UTC,"The point was that Haskell very much has a module system, it might not be an ML style module system but that is just because the term means vastly different things to different people. C was meant as an example of a language which actually doesn't have a module system."
haskell,3b498l,Taladar,7,Fri Jun 26 11:44:01 2015 UTC,"if then else syntax.  It's not composable, it doesn't play well with do notation and nesting if's becomes an ugly mess.  If should be a function in the prelude.  MultiWayIf is a bit better, even though I rarely use it."
haskell,3b498l,kuribas,4,Fri Jun 26 09:22:24 2015 UTC,Mixfix support then?
haskell,3b498l,Peaker,1 point,Fri Jun 26 10:41:24 2015 UTC,"Sorry, but what's that? All I could find are academic stuff, way above my level."
haskell,3b498l,Enamex,3,Fri Jun 26 16:57:21 2015 UTC,"Instead of the approach where most functions are ""prefix-application"" (f x y) and operators are ""infix-application"" (x * y), each name gets its own user-defined associated application syntax.  So you can declare f's application syntax is: _f_ making it an infix function (Each underscore represents a slot for an argument to be given).  Or you could declare a function called if_then_else_ and declare an ordinary function that behaves syntactically like Haskell's if syntax.  This kind of application syntax was originally done way back in Smalltalk, where the name of object methods was the concatenation of all the parameter names. So in Smalltalk:  openWindowIn: frame title: ""Hello world"" size: s.   And the name of the method is openWindowIn:title:size: (I might be getting details wrong here)."
haskell,3b498l,Peaker,2,Fri Jun 26 17:16:09 2015 UTC,"Very interesting. Smalltalk always sounds like this strange left-in-the-dust pioneer every time it's mentioned. That sounds, a bit, like Obj-C functions, I think?"
haskell,3b498l,Enamex,2,Fri Jun 26 17:40:22 2015 UTC,"Obj-C copied it from SmallTalk, yeah."
haskell,3b498l,Peaker,1 point,Fri Jun 26 18:03:45 2015 UTC,"Smalltalk actually enjoyed some popularity in the 80s and early 90s, until Java came along claiming to be the same thing with curlier braces and turned OO into a nightmare of semantically-meaningful single inheritance. (Smalltalk used inheritance for code reuse, but it basically didn't have a type system at all, only the clever illusion of one.)"
haskell,3b498l,tejon,1 point,Fri Jun 26 19:29:43 2015 UTC,I believe mixfix refers to the way if/then/else are in between (or mixed with) their arguments.
haskell,3b498l,Taladar,2,Fri Jun 26 17:25:04 2015 UTC,"So basically you want Lisp's case function? Aka that which is implemented via guard syntax in Haskell?  A variant of the lisp-y function can be written in Haskell, of course:  case' ((p,x):xs) = if p then x else xs   not sure if that's exactly what you want it to be. Alternatively, if you are only bothered about wrapping up the ""if then else"" into a function there's ofc:  if' p a b = if p then a else b"
haskell,3b498l,Stratege1,1 point,Fri Jun 26 13:42:11 2015 UTC,"I thought about combining case and if syntax. It'd look like this:  -- pattern matching works as usual: if foo in     Bar a -> a     Baz a b -> b     Qux a | someCond-> doStuffWith a     | otherCond -> 0 -- guard without pattern, equivalent to `_ | otherCond -> ...`     | else -> -1 -- `else` takes the place of what currently is `otherwise`  -- if you're just using conditions, you only need to write `if` if | cond -> res1    | else -> res2   I haven't put too much thought in it though, so I don't know if this would introduce some sort of ambiguity. if ... in could obviously be replaced with case ... of. It might also be possible to do some syntactical quirk with else so that both else -> foo as well as | else -> foo are correct (so it becomes _ or True, depending on the usecase)."
haskell,3b498l,Regimardyl,3,Fri Jun 26 14:01:42 2015 UTC,if ... then ... else ... is already just case ... of True -> ... ; False -> ....
haskell,3b498l,tomejaguar,7,Fri Jun 26 14:27:38 2015 UTC,"Add Nat & Natural as unsigned counterparts to Int & Integer.  Change all indexing functions to take Nat such as (!!),(!) take, drop, takeWhile, dropWhile, replicate, etc...  No more exceptions getting thrown!"
haskell,3b498l,recursion-ninja,4,Fri Jun 26 12:20:24 2015 UTC,"Well, no exceptions for negatives. Out-of-bounds remains an issue."
haskell,3b498l,tejon,2,Fri Jun 26 19:33:11 2015 UTC,Word/Natural are already there. (And Nat for type-level ints.)
haskell,3b498l,tailbalance,17,Sat Jun 27 04:41:59 2015 UTC,Strict evaluation & dependent types.
haskell,3b498l,julesjacobs,17,Thu Jun 25 21:56:28 2015 UTC,So Idris?
haskell,3b498l,emarshall85,6,Fri Jun 26 03:23:51 2015 UTC,"What about something like double bang patterns for deep strictness, single bang patterns for WHNF?"
haskell,3b498l,WarDaft,2,Fri Jun 26 01:45:56 2015 UTC,That's still the wrong default. Making laziness explicit in the type with a Lazy t type seems far better to me.
haskell,3b498l,julesjacobs,5,Fri Jun 26 08:20:15 2015 UTC,You can't make things locally lazy. That would require a lazy version of every single function you plan to use in those lazy sections of your code. You can make things locally strict though simply by forcing evaluation. Thus laziness is the correct default.
haskell,3b498l,Taladar,5,Fri Jun 26 17:21:31 2015 UTC,Why do you want strict evaluation?
haskell,3b498l,jberryman,2,Fri Jun 26 13:41:47 2015 UTC,"Don't know about /u/julesjacobs, but personally I find strict evaluation easier to understand."
haskell,3b498l,tomejaguar,3,Fri Jun 26 13:58:41 2015 UTC,Then why not write OCaml/SML instead of Haskell?
haskell,3b498l,capitalsigma,2,Sat Jun 27 21:50:05 2015 UTC,I find purity to be the most important thing.
haskell,3b498l,tomejaguar,1 point,Sun Jun 28 07:46:33 2015 UTC,"Optional laziness seems so much more appropriate. People speak of modularity, but I always seem to write my code with strict evaluation in mind since I may add in strictness annotations later."
haskell,3b498l,Agitates,15,Thu Jun 25 23:47:50 2015 UTC,"I think the ambitious question here is: can we somehow have our cake and eat it?  It would be nice to have a language and library ecosystem that was as neutral as possible about the choice.  The problem is that if you make the language strict by default, then the ecosystem will grow up around that so that we'll repeatedly find ourselves in situations where we really could use a lazy version of some type or library, and are forced to reimplement basically the same thing but with laziness.  And then we will implement the laziness only in the spots where we need it... and somebody comes along and finds that they need it to be lazy in different spots.  So basically, it would be good to have a language where this choice can be delayed further.  Maybe some sort of endofunctor that takes lifted types into unlifted counterparts?"
haskell,3b498l,sacundim,5,Fri Jun 26 01:07:47 2015 UTC,"Tough question. I can't complain about the language. I tried once to think about a better language, but all my improvement ideas ended up being not so good ideas or where not strictly language-related."
haskell,3b498l,Vektorweg,4,Thu Jun 25 21:54:30 2015 UTC,Flip the use of : and ::.
haskell,3b498l,augustss,1 point,Fri Jun 26 18:28:07 2015 UTC,"Hmm. ""Why doesn't SHE do that already?"", I ask myself."
haskell,3b498l,pigworker,2,Fri Jun 26 19:16:00 2015 UTC,Because She still wants to be Haskell.
haskell,3b498l,augustss,1 point,Fri Jun 26 20:25:12 2015 UTC,Indeed SHE does. It'd certainly be a pain to swap : and :: in a module just because I decided to switch to my own funny dialect in order to write fewer goddamn boilerplate superclass instances.
haskell,3b498l,pigworker,8,Fri Jun 26 21:08:37 2015 UTC,"This is a pretty minor thing and isn't really Haskell-specific, but I'd like to be able to write something like  ""0 < x < 1"" and have it de-shugar to ""0 < x && x < 1""."
haskell,3b498l,elihu,10,Fri Jun 26 04:17:19 2015 UTC,"Unfortunately, this would probably require either promoting Ord methods to special syntax, which is hackish, or else doing something way too complex that will break type inference and other properties."
haskell,3b498l,cdsmith,3,Fri Jun 26 05:34:21 2015 UTC,"Or TH, which might be the most reasonable solution. Not sure."
haskell,3b498l,kqr,6,Fri Jun 26 07:59:10 2015 UTC,"I remember an interval library that let you write something like  x `inside` (0 <..< 1) x `inside` (0 <=..< 1)   etc. It's not quite as pretty syntactically but that shouldn't be too hard to fix. I personally prefer the syntax x ∈ (0,1) over 0 < x < 1 anyway, so for me that's a nice way to put this condition into Haskell code."
haskell,3b498l,tsahyt,3,Fri Jun 26 09:35:36 2015 UTC,"(∈) :: Ord a => a -> (a,a) -> Bool x ∈ (a,b) = a < x && x < b"
haskell,3b498l,redxaxder,2,Fri Jun 26 13:03:43 2015 UTC,"Unicode operators are a nice feature. But that only works for open intervals. This was what I was talking about. It's not quite as nice syntactically but it's a bit more flexible.  Ideally I'd like to write x ∈ [0,5) for half open intervals too, although most editors would complain about mismatched parentheses. Aside from the a (∈) = member function alias, the package above has pretty much everything I need when it comes to interval arithmetic."
haskell,3b498l,tsahyt,2,Fri Jun 26 14:35:26 2015 UTC,This makes me uncomfortable.
haskell,3b498l,dsfox,8,Fri Jun 26 05:34:01 2015 UTC,The import syntax.  http://instantrimshot.com/
haskell,3b498l,acow,8,Thu Jun 25 21:18:43 2015 UTC,I think the import syntax wouldn't be that annoying if we wouldn't need to import so many modules.
haskell,3b498l,Vektorweg,3,Thu Jun 25 21:58:51 2015 UTC,Here's where an IDE would help.
haskell,3b498l,tdox,2,Fri Jun 26 05:49:58 2015 UTC,And by help you mean work around the problem.
haskell,3b498l,Taladar,3,Fri Jun 26 17:26:52 2015 UTC,See also https://www.reddit.com/r/haskell/comments/2chb2h/fantasy_world_haskell/
haskell,3b498l,tomejaguar,1 point,Fri Jun 26 08:59:14 2015 UTC,"I was googling for that earlier, mostly to try to find this comment, particular the parts around records and sums.  Although I'd be keen on a split between data and codata as well - I can imagine having both might have an unintended consequences for those teaching / learning Haskell."
haskell,3b498l,dalaing,6,Fri Jun 26 10:40:41 2015 UTC,"I want a lisp-like syntax  I know it might put some people off, but it's really cute if you get used to it"
haskell,3b498l,dramforever,16,Fri Jun 26 04:11:25 2015 UTC,"Oh c'mon, you can just put some parens  ((putStrLn (((<>)) (""Hello, "")                    ""world""))))))"
haskell,3b498l,tailbalance,5,Fri Jun 26 08:55:47 2015 UTC,D:
haskell,3b498l,eigengrau82,2,Fri Jun 26 06:15:46 2015 UTC,"Some minor parsing changes. I would really love being able to roll my own mixfix operators, and it would be great if you could override the default assumption that alphabetic functions are prefix. This would allow some very nice DSL applications.  And of course, dependent typing for mere mortals, by adding bread & butter dependent types like fixed length lists to base, and by supplying ready-made theorems that make it easier to deal with type-level numerals, so that GHC would know, out of the box, that(α + β) ~ ((α + 1) + (β - 1)).  Edit: I found out that there are some plugins available which will leverage the GHC 7.10 plugin system to teach GHC some facts about arithmetics. NB, I just tried ghc-typelits-natnormalise, and it seems to work great thus far \o/"
haskell,3b498l,eigengrau82,2,Fri Jun 26 07:04:43 2015 UTC,"Allow partially applied type synonyms and type-level lambdas. I don't know how they'd work, but I can dream!"
haskell,3b498l,spindakin,2,Fri Jun 26 09:30:38 2015 UTC,"I would love to have some sort of ""inferred application context"". In most Haskell, we have (at least) three contexts of programming - pure, with spaces for application and let for binding; applicative, with <*> for application; and do notation with its own form of binding. I would like a unified notation that is driven by the types to work out what I mean.  I don't have a proposal for how to do this, and many have pointed out places where this is problematic. I haven't given up hope though."
haskell,3b498l,ocharles,1 point,Fri Jun 26 13:24:13 2015 UTC,"Conor McBride was working on something like this with his language Frank, IIRC."
haskell,3b498l,kamatsu,2,Sat Jun 27 11:24:28 2015 UTC,"Anything to ease the burden of overlapping names. Meaningful typeclasses, undisciplined typeclasses (we already have Num, don't we?), some other kind of overloading facility, or something else entirely -- I don't care -- I just hate having to type Vector.length.  And while I'm fantasizing:   more flexible names mixfix operators make := the assignment symbol, so the equality test can be named (=) anything to make effectful programming less clunky -- no more readTVar and the like"
haskell,3b498l,nosewings,9,Fri Jun 26 08:06:02 2015 UTC,"make := the assignment symbol, so the equality test can be named (=)   What assignment symbol? As far as I understand, = is an equality. The left hand side can be substituted for the right hand side and vice versa. That's what makes equational reasoning work. It's judgmental equality, but equality nonetheless. Meanwhile, (==) is not an equality per se, but a comparison operator."
haskell,3b498l,tsahyt,1 point,Fri Jun 26 09:39:14 2015 UTC,I'd remove boxing from the implementation and specialize all the things like a c++ compiler.
haskell,3b498l,Peaker,3,Fri Jun 26 10:42:11 2015 UTC,"You'd have to give up polymorphic recursion, ExistentialQuantification, RankNTypes, and either type classes with polymorphic methods (such as Functor and Monad) or separate compilation.  (You might want to take a glance at Rust.)"
haskell,3b498l,glaebhoerl,1 point,Fri Jun 26 12:18:24 2015 UTC,"Well, you could have boxing for a small subset of the values that need those features. Even then, I think the boxes could be metadata describing the memory layout of the unboxed values which could still use far less indirection than Haskell boxes currently use."
haskell,3b498l,Peaker,1 point,Fri Jun 26 12:38:56 2015 UTC,"Well, you could have boxing for a small subset of the values that need those features.   This is a solid goal and simple to state, but not necessarily so simple to specify. For example, consider what happens if you lay out the fields of polymorphic datatypes unboxed, like C++ does, and then quantify over the type variable. Now you no longer have a statically known size for the type, nor (in the general case) offsets for its members. (Rust's approach here is to make indirections explicit, together with the so-called ""dynamically sized types"" scheme - essentially it enforces that types without a statically known size must be behind an indirection.)   Even then, I think the boxes could be metadata describing the memory layout of the unboxed values which could still use far less indirection than Haskell boxes currently use.   I believe this is what's known as intensional type analysis (not to be confused with intensional type theory)."
haskell,3b498l,glaebhoerl,2,Fri Jun 26 16:43:09 2015 UTC,Are those two things linked?  Why can't Haskell specialise all the things now?
haskell,3b498l,tomejaguar,1 point,Fri Jun 26 10:55:39 2015 UTC,"Unboxing requires specialization, because losing the unified boxing, values of different types are laid out differently and behave differently. A single polymorphic function cannot (easily) handle values of different types. So you have to specialize the function for each set of types it was called at, each handling a particular set of unboxed types.  This is the strategy all C++ compilers take, and I believe it is far superior to the boxing strategy used by GHC."
haskell,3b498l,Peaker,1 point,Fri Jun 26 11:57:24 2015 UTC,The ability to export record functions as getters only.
haskell,3b498l,Die-Nacht,1 point,Fri Jun 26 13:55:14 2015 UTC,Add the types Bits(n) and Range n .. m Then use Range values to create arrays/vectors. The cost of bounds checking would go to near zero. Also if the compiler knows that a value is bounded it is possible to emit code with fewer thunks.
haskell,3b498l,crmills_2000,1 point,Fri Jun 26 16:15:16 2015 UTC,"Something like Common Lisp's eval-when would be nice, i.e. a construct to easily wrap an expression in to tell the compiler to evaluate it at compile time and replace it with the resulting value.  This would be useful to allow smart constructors to reject constants in the code if they are syntactically invalid, to compute lookup tables,...  I know you can probably already do so via Template Haskell but that always feels like a completely different language. I am thinking of a stream-lined construct that works for everyone, even those who don't know the details of Haskell's AST."
haskell,3b498l,Taladar,1 point,Fri Jun 26 17:31:08 2015 UTC,"Liquid Haskell or TH, maybe?"
haskell,3b498l,Enamex,1 point,Sat Jun 27 11:33:54 2015 UTC,"The tendency toward ""operator soup"". People always seem compelled to come up with clever operators to support their use case but all you end up with is syntactic noise that is impossible for a newcomer to your library to understand. Try mixing conduit, hunit, and lens. Ugh. Is it so bad to just write fmap function structure?  I have a hunch a lot of this would go away if (+) (or at least (++)) evolved to be mappend or similar."
haskell,3b498l,afcowie,1 point,Mon Jun 29 03:03:32 2015 UTC,"Btw, minor thing, but it is really annoying that in result type of random the accumulator is the second element of the tuple, while in mapAccumL, it is the first element... These should use the same convention (I would choose the mapAccumL one)."
haskell,3b7ltx,athanclark,9,Fri Jun 26 16:50:22 2015 UTC,"That's a trick known for quite some time, see http://okmij.org/ftp/Haskell/polyvariadic.html  Perhaps this belongs to /r/haskelltil"
haskell,3b7ltx,int_index,5,Fri Jun 26 17:53:43 2015 UTC,TIL there was an /r/haskelltil
haskell,3b7ltx,orangemintsodapop,1 point,Sat Jun 27 00:55:41 2015 UTC,Blast! Sorry about that ._.
haskell,3b43sc,cowboysauce,10,Thu Jun 25 20:24:22 2015 UTC,"Types don't form a semifield. They form a semiring. Apparently, this is cited from a mistaken post here."
haskell,3b43sc,tactics,7,Fri Jun 26 03:38:02 2015 UTC,"See also:   combinatorial species  is an abstract, systematic method for analysing discrete structures in terms of generating functions. Examples of discrete structures are (finite) graphs, permutations, trees, and so on;"
haskell,3b43sc,ttt72,5,Thu Jun 25 20:44:01 2015 UTC,"If you're the type of person who likes to watch videos instead of (or in addition to) reading articles, this video covers pretty much the same concepts: https://www.youtube.com/watch?v=YScIPA8RbVE (and coincidentally(?) has essentially the same title)."
haskell,3b43sc,Nebu,3,Fri Jun 26 07:48:04 2015 UTC,"Relatedly, for those who haven't seen it, there are only 4 inhabitants of  ∀ a b c . (b → b → c) → (a → b) → (a → a → c)   You can reason it out for yourself, but it was also explained using the Yoneda lemma here by /u/pcapriotti.  I'm still not 100% sure what it means in the algebra / calculus of algebraic data types, but I still think it's really cool :)"
haskell,3b43sc,dalaing,2,Thu Jun 25 22:56:29 2015 UTC,"it's a constructor for church pairs, but with some intermediate case analysis and some less polymorphism."
haskell,3b43sc,psygnisfive,3,Fri Jun 26 00:51:47 2015 UTC,"The bit that I'm not sure about is how to interpret the number of inhabitants of type when parametricity is in play.  We know that  a -> b   has b^a inhabitants, as long as we know what a and b are.  There's some kind of leap from that to  (b → b → c) → (a → b) → (a → a → c)   having 4 inhabitants if we can't know anything about a, b, or c that I find interesting.  Even      ∀ a. a -> a -> a having 2 inhabitants instead of aaa inhabitants is kind of fascinating to me.  I understand that Yoneda helps there, what I'd really like is some kind of interpretation.  I was trying to puzzle out something with roots of unity before I got around to asking if anyone knew :)"
haskell,3b43sc,dalaing,4,Fri Jun 26 02:17:03 2015 UTC,"try writing the programs. let's start with forall a. a -> a -> a.  f :: forall a. a -> a -> a f = _   I'm putting an underscore to indicate what we need to fill in. Ok, so, how to proceed? well we can only do a lambda, so:  f :: forall a. a -> a -> a f = \x -> _   and now the hole has the type a -> a, so again only a lambda can work:  f :: forall a. a -> a -> a f = \x y -> _   and now the hole is of type a. we don't know how to make an a, since we don't know what a is, so the only thing we can do is try to use an a we've already got. so we can pick either x or y. so in either  f :: forall a. a -> a -> a f = \x y -> x   or  f :: forall a. a -> a -> a f = \x y -> y   it's not aaa because that's not the right exponential, it should be (aa)a, but it's not equal to that either because we don't know what a is, so we can't use the size of a. parametric polymorphism is a kind of subset type that picks out certain subsets of each more-specific type, namely, the subsets with code that's the same regardless of specificness. so the size of forall a. T is not obviously related to the size of [A/a]T for some A. that is to say, forall a. T is the set of programs { p | for all A, p :: [A/a]T } which will not obviously be related in size to [A/a]T.  additionally, keep in mind that this is programs not functions, so while Void -> Void -> Void has only one function, namely, the empty function, there are two programs (they just happen to be exensionally equivalent). so (00)0 is, counterintuitively, not equal to 1 but equal to 2. then again, base-0 exponentials are ill-defined normally, so who knows :)"
haskell,3b43sc,psygnisfive,2,Fri Jun 26 03:25:21 2015 UTC,"Yeah, I understand all of that quite well.  It looks like I'm epically failing to communicate my point :)  Ironically, in the comment thread I linked to, I was struggling to point out that I was talking about the parametric type rather than the concrete types :)  I'm just fascinated that Yoneda gives us something that we can use fairly mechanically with some (all?) of these kind of functions in the count-the-inhabitants-of-types space.  Edit:  Not sure if this will help clarify things or make it worse - in my above comment, by ""struggling to interpret"", I guess I meant ""struggling to map from the types to the arithmetic on the inhabitants of types in an intuitive way"".  We can use Yoneda, but I'm wondering if the arithmetic-on-inhabitants metaphor holds when we do it for some reason."
haskell,3b43sc,dalaing,3,Fri Jun 26 03:34:31 2015 UTC,"i edited it to reflect parametric types a bit more.  also it's not so much that yoneda gives us this, but rather than yoneda helps us reason about it at times. the proof you mention uses yoneda in a very particular way that relies entirely on the fact that the type has the form  forall a. (T -> a) -> F a. yoneda tells us that this is equivalent to F T."
haskell,3b43sc,psygnisfive,2,Fri Jun 26 03:35:38 2015 UTC,"well, it does, but you have to understand that forall is not going to preserve the sizes underneath it, that's all. there's no intuitive mapping for forall."
haskell,3b43sc,psygnisfive,2,Fri Jun 26 03:56:20 2015 UTC,"so (00)0 is, counterintuitively, not equal to 1 but equal to 2. then again, base-0 exponentials are ill-defined normally, so who knows :)   Nothing to do with that, () -> () -> () is the same and 11 is well defined as 1."
haskell,3b43sc,anvsdt,3,Fri Jun 26 16:37:44 2015 UTC,"denotationally, but programmatically, there are three inhabitants namely  \x y -> x \x y -> y \x y -> ()"
haskell,3b43sc,psygnisfive,1 point,Fri Jun 26 17:09:45 2015 UTC,"Maybe it makes more sense if you stop thinking this must work for some type a and instead think this must work for all types a.  The only inhabitant of a -> a is id: since we don't know anything about the value we are given, there's nothing we can do to it other than return it as-is.  It doesn't make sense to look at ""aa"", as whatever a is has nothing to do with the function -- only with a single, concrete application of the function to some value of type a."
haskell,3b43sc,13467,3,Fri Jun 26 02:50:12 2015 UTC,"I understand all of that - I was just reaching around for whether there was some way to bring universal qualification / parametricity across into the counting-of-inhabitants-of-types side of things.  Edit: I find the fact that you can mechanically derive that number of inhabitants via Yoneda in some (all?) cases pretty exciting, I just want to build more of an intuition for it."
haskell,3b43sc,dalaing,2,Fri Jun 26 03:12:11 2015 UTC,"Edit: I find the fact that you can mechanically derive that number of inhabitants via Yoneda in some (all?) cases pretty exciting, I just want to build more of an intuition for it.   I thought that was the case so I tried to push my luck a bit. Here's an inconclusive braindump:  forall a. a forall a. (0 -> a) -> Id a Id 0 = 0  forall a. b forall a. (0 -> a) -> Const b a Const b 0 = b  forall a. a -> a forall a. (0 -> a) -> Endo a Endo 0 = 0 -> 0 = 1 (alternatively) forall. (1 -> a) -> Id a Id 1 = 1  Fix a = (a -> a) -> a forall a. (a -> a) -> a forall a. (0 -> a) -> Fix a Fix 0 = (0 -> 0) -> 0 = 1 -> 0 = 0 (which makes sense since we're assuming totality/consistency)  Cont a r = (a -> r) -> r forall a b. ((a -> b) -> b) -> a forall a b. (0 -> b) -> Cont a b forall a. Cont a 0 forall a. (0 -> a) -> Cont a 0 Cont 0 0 = (0 -> 0) -> 0 = 0 (which makes sense since excluded middle/double negation elimination breaks parametricity)   Then I realized that what I was doing is pretty much how you construct limits out of Yoneda, by noting that Const 1 a ~ 0 -> a:  f :-> g = forall a. f a -> g a Hom a b = a -> b  (there are equivalent given parametricity) Limit f = forall a. f a Limit f = Const 1 :-> f = forall a. 1 -> f a = forall a. f a Limit f = Hom 0 :-> f = forall a. (0 -> a) -> f a = f 0 -- by Yoneda   I'm not sure if this is evidence that you can use Yoneda to compute the number of inhabitants in all cases, but you surely(?) can when you can state your universal quantification in terms of a covariant functor (but what about Endo, Fix and Cont then?!), just set the quantified variable to 0.  Which makes intuitive sense to me, because forall a. ... has to work for all choices of a, so it can't have any more inhabitants than the case where a has 0. But things get wtf about now, because forall a. a -> a -> a has two inhabitants, and 0 -> 0 -> 0 = 0 -> 1 has one. If we say that 0 -> 1 has two inhabitants, absurd :: 0 -> a and const () :: a -> 1, then everything starts to work again:  forall a. a -> a -> a 0 -> (0 -> 0) 0 -> 1 2  forall a b c. (b -> b -> c) -> (a -> b) -> (a -> a -> c) (0 -> 0 -> 0) -> (0 -> 0) -> (0 -> 0 -> 0) (0 -> 0 -> 0) -> 1 -> 0 -> 0 -> 0 (0 -> 1) -> 1 -> 0 -> 1 2 -> 1 -> 2 2 -> 2 4   I guess this ties in with /u/psygnisfive's comment here, but my brain started to melt so (╯°□°）╯︵ ┻━┻"
haskell,3b43sc,anvsdt,2,Fri Jun 26 18:06:16 2015 UTC,I'm not sure where you're getting all these 0's from
haskell,3b43sc,psygnisfive,2,Fri Jun 26 18:17:43 2015 UTC,"It took me way too long to see why there were more than 2 inhabitants (switch the 'a's or not). I'm so used to working linearly, I didn't think to duplicate the first or second argument. I wonder how the number of inhabitants change generally for sub-structural type systems?"
haskell,3b43sc,dogodel,2,Fri Jun 26 16:21:38 2015 UTC,"This can be extended to the dependent function type which is sort of a multiplication of a series of types (indexed by the values of the input type), thus dependent functions are Pi types.  The dependant pair can be thought of as a sum of a series of types indexed by the values of the fst type. Thus dependent pairs are sigma types.  To have such a nice reason the dependent function and pair are named that way made me appreciate the type theorists more :)"
haskell,3b43sc,Peaker,1 point,Fri Jun 26 10:37:22 2015 UTC,The duality of And and Or to Product and Sum types has been known for quite a long time.
haskell,3b43sc,Oremorj,16,Thu Jun 25 21:41:48 2015 UTC,"I don't think you mean duality, I think you mean correspondence."
haskell,3b43sc,psygnisfive,2,Thu Jun 25 22:43:37 2015 UTC,Yep. Here's the math.  edit: here's the relationship between many other types and logic
haskell,3b4954,tailcalled,4,Thu Jun 25 21:04:00 2015 UTC,"This is the idea behind Cartesian closed categories.  You write what looks like a lambda calculus expression but these lambda expressions are ""overloaded"" to work with anything that implements the CCC type class, which would look something like this:  -- The exact specifics of this type class may vary, but you get the idea class Category cat => CCC cat where     apply :: cat (a -> b, a) b     curry :: cat (a, b) c -> cat a (b -> c)     fst   :: CCC (a, b) a     snd   :: CCC (a, b) b     pair  :: CCC a b -> CCC a c -> CCC a (b, c)  instance CCC (->) where ...   So if you wrote an expression like this one:  example :: \a b -> a   The inferred type would be:  example :: CCC c => c () (a -> b -> a)   ... and it would desugar to operations using the CCC type class:  example = curry (curry (snd . fst))   This desugaring process is a solved problem and there's a mechanical way to turn any lambda expression into something that implements the CCC type class.  In fact, you're not the first one to pursue a practical implementation of this idea.  Conal Elliot had a similar idea which he popularized in a series of blog posts:   http://conal.net/blog/posts/haskell-to-hardware-via-cccs http://conal.net/blog/posts/overloading-lambda http://conal.net/blog/posts/optimizing-cccs http://conal.net/blog/posts/circuits-as-a-bicartesian-closed-category   Really, all that's missing to implement your vision is an OverloadedLambdas language extension that generalizes all lambda expressions to instances of something like the above type class.  This is also why people say that lambda calculus is the ""internal language"" of cartesian closed categories."
haskell,3b4954,Tekmo,4,Thu Jun 25 21:17:51 2015 UTC,"I know a lot about CCCs, but there are a lot of categories we might be interested in that aren't CCCs. For example, linear type theories are, as far as I know, only CC (though you can construct a CCC by using !a -o b as morphisms). You are right that a nice syntax for CCCs would definitely be included in this language, though."
haskell,3b4954,winterkoninkje,5,Thu Jun 25 21:25:10 2015 UTC,"If you want to be general about it, then you need to get into topos/logos theory. CCCs are great for ""normal"" lambda calculus, SMCCs are great for linear, LCCCs are great for dependent types,...; but we need a nice clean way of generalizing over all these different constructions.  Of course, once we start taking topos theory seriously, that means a lot of the pretty lies we've been telling ourselves have to go away. For example, to pick a well-worn hobbyhorse: ∏ is not ∀, and ∑ is not ∃; claiming otherwise is an attractive fiction, but a fiction nevertheless. The HoTT-style approach manages to distinguish ∑ from ""∃"", which is something at least; but they still fail by identifying ∏ and ∀. Truncation isn't the (whole) story."
haskell,3b4954,julesjacobs,4,Fri Jun 26 04:52:23 2015 UTC,"Can you give a layman's explanation of how we should look at ∏, ∀, ∑, ∃? Is is the same difference that Conor McBride advocates? In that case can't you get ∀x:A. ... by doing ∏x:A'. ... where A' is A but with all elements made equal?  data A' where    val : A -> A'    all_eq : x:A' -> y:A' -> x = y"
haskell,3b4954,winterkoninkje,3,Fri Jun 26 08:38:27 2015 UTC,"In general, I think the key idea behind (what logicians mean by) ∀/∃ is the fact that they are parametric. In addition, when ∃ is thought of as a pair, we can erase its first component, thus computationally-speaking we can only project out the second component; this in turn entails that the first component of ∃ is not allowed to ""escape"". I think System F captures these intuitions pretty well.  On the other hand, ∏/∑ are indexed families. When we say ∀x:A.P(x) we mean that we have a single thing of type P(_), and we can plug any a:A in for x after the fact. Whereas, when we say ∏x:A.P(x) what we mean is that we have an A-indexed family of things (e.g., when A is the natural numbers, we could have a series P(0)*P(1)*P(2)*...), but there's no guarantee that the different elements of the family have anything to do with one another, nor anything to do with the index we used to pick them out. We can always scramble things up and use the family ∏y:B.P(f(y)) instead.  Logically-speaking, just because we can prove that something must exist (∃), that doesn't mean we can actually get our hands on it. That is, we can prove ∃x:A.P(x) without actually exhibiting a specific concrete a:A such that P(a). But since we didn't necessarily construct an a:A, we can't project out the x. Accepting this is what constructive logic is all about. Whereas, in order to prove ∑x:A.P(x) we do have to construct the witness a:A such that P(a); and consequently, it's perfectly safe to project out the x."
haskell,3b4954,julesjacobs,2,Sun Jun 28 01:56:37 2015 UTC,"No, because according to your ∀, it is the case that ∀x: A. x=x.  Instead, let [A] denote the -1-truncation of A - that is, the type that is A with all elements made equal. ∀x:A. B is then ∏x:A. [B]. When B is a mere proposition, this is equivalent to ∏x:A. B, but otherwise it is not.  (One could also just restrict ∀ to only work when the result is a proposition; this is not the case for ∃.)"
haskell,3b4954,julesjacobs,2,Sat Jun 27 20:43:59 2015 UTC,"No, because according to your ∀, it is the case that ∀x: A. x=x.   Isn't that how it's supposed to be? Do you mean∀x: ∀y: A. x=y. Yes that would be true, but the = would be at type A' not A.   Instead, let [A] denote the -1-truncation of A - that is, the type that is A with all elements made equal. ∀x:A. B is then ∏x:A. [B]. When B is a mere proposition, this is equivalent to ∏x:A. B, but otherwise it is not.   I thought the idea of ∀ was that the argument is irrelevant, not the result? For example if you write a function that needs some integer argument to make the proof go you do ∀n:Int ...  I guess I have no idea what ∀ is supposed to mean as opposed to ∏..."
haskell,3b4954,julesjacobs,2,Sat Jun 27 21:09:54 2015 UTC,"Isn't that how it's supposed to be? Do you mean∀x: ∀y: A. x=y. Yes that would be true, but the = would be at type A' not A.   Whoops, yes. Anyway, no, that's not the way it's meant to be.   I thought the idea of ∀ was that the argument is irrelevant, not the result? For example if you write a function that needs some integer argument to make the proof go you do ∀n:Int ...   The idea of ∀ is that the result is a mere proposition, i.e. that all the proofs are equal. Essentially, ∏ and ∑ would be about types while ∀ and ∃ would be about mere propositions."
haskell,3b4954,winterkoninkje,2,Sat Jun 27 21:14:29 2015 UTC,I've not yet heard them described in that way. Do you have a reference where I can learn more about this?
haskell,3b4954,edwardkmett,3,Sat Jun 27 21:23:03 2015 UTC,"The HoTT book. On page 118, they write:   Definition 3.7.1. We define traditional logical notation using truncation as follows, where P and Q denote mere propositions (or families thereof):  T :≡ 1  ⊥ :≡ 0  P ∧ Q :≡ P × Q  P ⇒ Q :≡ P → Q  P ⇔ Q :≡ P = Q  ¬P :≡ P → 0  P ∨ Q :≡ ||P + Q||  ∀(x : A). P(x) :≡ ∏x:A. P(x)  ∃(x : A). P(x) :≡ ||∑x:A. P(x)||"
haskell,3b4954,edwardkmett,1 point,Sat Jun 27 21:55:22 2015 UTC,Thank you. So ∀ is the same as ∏ then? I guess I have to delve into topos theory to really understand what winterkoninkje meant.
haskell,3b4954,edwardkmett,2,Sat Jun 27 22:41:41 2015 UTC,"But again, aren't there important categories that aren't well-described by the structures of topos theory?  I'll have to qualify this by saying that my knowledge of topos theory is rusty, but consider Kleisli categories."
haskell,3b4954,Oremorj,2,Fri Jun 26 09:34:40 2015 UTC,"The general motivation behind topos/logos theory is to discover the sorts of categories that give rise to particular logical constructions; that is, any sort of logic or programming language can be thought of as being the internal language of some sort of category, and the study of such internal languages is what topos/logos theory is all about. Sure, there are plenty of categories that don't show up on that little diagram I made, but that just underscores the point: for these other categories, what sort of ""programming language"" would you make out of them? We could always try to build an implementation of all of category theory and use that, but then we'd be working in the external language of mathematics, we wouldn't be working in the categories of interest.  Ultimately we want/need both the internal and external perspectives, as they each shed light on different things. It's just, what the OP was talking about sounds more like trying to capture the internal languages of various categories."
haskell,3b4954,Oremorj,1 point,Sun Jun 28 00:37:19 2015 UTC,"Huh, I guess I failed to mention that I would expect it to have a system for writing syntax extensions to accomodate new structures. Illusion of transparency and all that."
haskell,3b4ztr,deech,3,Fri Jun 26 00:43:36 2015 UTC,"couldn't you achieve that with manyTill? btw why do you use parsec not attoparsec? I migrated recently because parsec is not maintained anymore (not that much anyway AFAIK) but started to regret because I can't give to my users anymore a precise location for a parse error (for me as a developer it isn't a problem, it's more for users of the app). Starting to think attoparsec for computer-generated input, parsec if the end-user types the input."
haskell,3b4ztr,emmanueltouzery,4,Fri Jun 26 07:11:28 2015 UTC,"It bothers me that we don't have a fully-backtracking-by-default parsing library (and attoparsec doesn't count, there are corner cases where it still does not backtrack)"
haskell,3b4ztr,Tekmo,9,Fri Jun 26 03:20:18 2015 UTC,"Actually, we do!  http://code.haskell.org/~malcolm/polyparse/docs/  https://hackage.haskell.org/package/polyparse"
haskell,3b4ztr,sclv,2,Fri Jun 26 04:18:29 2015 UTC,"Would you happen to have a link to some documentation of these corner cases? I'm currently writing an attoparsec parser and getting some really strange results, which this might just provide an explanation for."
haskell,3b4ztr,jlimperg,1 point,Fri Jun 26 10:33:33 2015 UTC,Here is one issue
haskell,3b4ztr,Tekmo,2,Fri Jun 26 22:20:48 2015 UTC,"I'd like to throw in some more desiderata:   Don't use backtracking, instead explore all variants concurrently. Backtracking requires to keep the entire input in memory (also known as a memory leak). Proper prioritized choice, not the kind of committed choice that PEGs have. Parse context free grammars in polynomial (cubic) time, and deterministic grammars in linear time (and while we're at it: parse nondeterministic but regular grammars in linear time). Support left recursion."
haskell,3b4ztr,julesjacobs,4,Fri Jun 26 11:58:48 2015 UTC,"Check out uu-parsinglib; it does the first two, at least on context-free grammars."
haskell,3b4ztr,massysett,3,Fri Jun 26 12:30:52 2015 UTC,Early?
haskell,3b4ztr,rpglover64,1 point,Fri Jun 26 14:01:50 2015 UTC,Earley is n3 all the time.
haskell,3b4ztr,edwardkmett,4,Fri Jun 26 15:06:34 2015 UTC,"From the library page:   The worst-case run time performance of the Earley parsing algorithm is cubic in the length of the input, but for large classes of grammars it is linear. It should however be noted that this library will likely be slower than most parser generators and parser combinator libraries.   From Wikipedia:   The Earley parser executes in cubic time in the general case O( n3 ), where n is the length of the parsed string, quadratic time for unambiguous grammars O( n2 ), and linear time for almost all LR(k) grammars.   Also to consider: derp (though unmaintained and more of a proof-of-concept, and marpa (which is a C library with a Perl wrapper, based on Earley's algorithm with performance improvements)."
haskell,3b4ztr,rpglover64,2,Fri Jun 26 16:26:00 2015 UTC,Derp. I was thinking of the asymptotics of CYK. Earley is O( n3 ) in the worst case for CFGs like anything that can handle them of course.
haskell,3b4ztr,edwardkmett,2,Fri Jun 26 20:33:02 2015 UTC,"Don't use backtracking, instead explore all variants concurrently. Backtracking requires to keep the entire input in memory (also known as a memory leak).   Sounds like this would eat a lot more memory than BT ?"
haskell,3b4ztr,bartavelle,3,Fri Jun 26 13:44:18 2015 UTC,"Actually it's much less memory. A backtracking parser has to remember a lot of things to be able to backtrack. If you have a production like this:  S = A | B | C   Then it will first try A and parse the rest of the string, but just in case it has to backtrack it also has to remember the state to try B and C later. Basically it has to save state for every production for every position in the input string. It turns out that in practice most grammars look like this:  S = ""if"" A | ""while"" B | ""for"" C   So what will a backtracking parser do when it sees ""if""? It will enter the ""if"" A branch, but just in case it has to try out the other branches it has to save the state. Parsec works around this by using committed choice: once you've chosen the ""if"" A part it will never even try to enter the ""while"" B part unless you've wrapped the parser in a try. So the only reason parsec is palatable is that almost all grammars look like this. Of course in other cases like ""for"" A | ""foreach"" B that won't work because you can't see which branch you need from the first character. Or more complicated cases like number = digits | digits ""."" digits. For that you need backtracking.  How would a parser that explores all branches concurrently handle this? When it sees ""if"" it explores all 3 branches and it will immediately see that ""while"" and ""for"" won't match, so those branches will terminate immediately. So no state needs to be stored at all. Furthermore unlike parsec it will still give the correct result even if some of the branches don't immediately terminate. In ""for"" A | ""foreach"" B both of the branches will be explored but at the 2nd character one of them will terminate (without having to save state for backtracking). Yet it will also work correctly for any A | B. It also has advantages for error reporting because it's natural to base your error message on the branch that went furthest in the input rather than the one that happened to be tried last while backtracking. See also Parsec: “try a <|> b” considered harmful.  Somewhat related is that grammars in practice are deterministic. They will only ever parse a given string in one way. Context free grammars assume non-determinism by default. If you have A | B and both A and B match you'll get two parse trees. There is a semantic mismatch between CFGs and programming language syntax. Instead I would propose the following 3 variants:  A | B      -- disjoint union A / B      -- prioritized union A || B     -- union   With A | B we are telling the parser that at most one of A,B will ever match. If it turns out that both match we will get an error. With A / B it is allowed that both match, but the returned parse tree will the the parse tree of A rather than of B. With A || B we will get both parse trees.  You'll similarly need 3 variants of the sequence operator, since that's the other place where nondeterminism can be introduced.  This way you can distinguish between deterministic and non-deterministic parsers with the type. DeterministicParser a will always return at most one parse result type Maybe a and NondeterministicParser a will return a list of parse results [a]."
haskell,3b4ztr,julesjacobs,2,Fri Jun 26 18:26:01 2015 UTC,"To explore all variants concurrently you're looking more at something like uu-parsinglib. That can do this today.  To support LL-style grammars in linear time and handle all CFGs w/ left recursion you're going to need a real GLL library. This proves to be quite tricky in practice. Spiewak has some combinators in scala that purport to offer GLL parsing, but they don't hit the correct asymptotics due to their lack of FIRST sets.  I'm willing to give up an extra couple of log factors in practice to get parallel and incremental parsing on top of that. This drives me to things closer to a Valiant parser. It is vastly simpler than the graph structured stack needed by the GLL and can me built into a form of parsing combinator."
haskell,3b4ztr,edwardkmett,2,Fri Jun 26 15:06:20 2015 UTC,"I don't think Valiant's algorithm is practical at all. The asymptotics are good for general context free grammars, but the asymptotics are bad for practical grammars (almost cubic vs linear), and the constant factors are absolutely horrendous. The advantage of Earley/GLL parsing is that grammars are almost deterministic in practice, and their performance scales with the amount of determinism. Valiant's algorithm will basically parse every substring against every production. In the worst case that doesn't matter because you have to do that anyway, but for practical grammars that is way more work than necessary. Valiants algorithm also has the same memory leak problem as backtracking, IIRC. There's also a general problem with parallel parsing: you chop the string up into pieces, but for a piece in the middle you don't know the parser state going into it, so you basically have to parse it for every possible parser state, only to plug in the state that is actually there at the end."
haskell,3b4ztr,julesjacobs,3,Fri Jun 26 18:11:04 2015 UTC,"Interesting.   My experience is pretty close to that of Koen Claessen and Jean-Philippe Bernardy in Efficient Parallel and Incremental Parsing of Practical Context-Free Languages that with a good sparse matrix multiplication routine and having separated out Kleene stars, Valiant is n log2 n in practice. So now I can do an initial parse in n log2 n time in which I get to exploit parallelism and update it incrementally in ~ log3 time. By working in a modified finger-tree you can get rid of all that sequence-algebra nonsense as well.  Valiant's parser effectively glues together two partial parses through an intermediate terminal. That terminal rather drastically filters the space of 'live' parses down to something logarithmic'ish in practice. So you are only usually dealing with two logarithmic 'frontiers' you are zipping up, not all n states."
haskell,3b4ztr,edwardkmett,2,Fri Jun 26 20:39:31 2015 UTC,"Ah, you're using sparse matrices, I was assuming dense matrices. With sparse matrices you would most likely indeed get good asymptotics for all practical grammars, depending on how many entries you end up computing that a left-to-right parser wouldn't need to compute. The constant factors are still an issue I think. Until we're going to get more than n=8 cores it's kind of difficult to get actual speedup out of parallel algorithms with worse constant factors :(  For parallel parsing it could work better to chop up the input into n chunks and then parse those left to right with a kind of modified Earley and hope that most of the unneeded alternatives die quickly. The trouble with subdividing it until the end is that you end up doing a lot of unnecessary work. The substring if(p){ x = 1+2; } could be parsed in at least 3 ways. Maybe it's part of the actual program, maybe it's sitting in a comment, maybe it's sitting in a string literal. When you don't know the context you have to parse it in all 3 ways (or invent heuristics to avoid that). A left-to-right algorithm already knows whether it's part of the program, a comment, or a string literal, so it only needs to parse it in one way. For incremental parsing you would need to subdivide it at least almost until the end to get mileage out of it (perhaps a structural editor is the correct answer here...).  It's certainly a more interesting approach than I initially thought because of sparse matrices! Can you perhaps do left to right parsing with the same approach by introducing one terminal at a time? (this is also nice for parsing data that is being streamed from the network or disk) Can you modify it to get some kind of monadic parsing back while retaining incrementality & parallelism in practice (if the substring parsed under the bind is short)?"
haskell,3b4ztr,julesjacobs,2,Fri Jun 26 21:49:53 2015 UTC,"The parallelism is basically just a side-effect. I care about incremental parsing. Parallel comes along more or less for free w/ that and some workstealing.  I have a form of monadic parser that also builds on top of this, but it is tricky to describe in practice.   You need to use observable sharing repeatedly and if you have a lot of context sensitivity it can be pretty terrible. It is ensured to make progress though at least one symbol at a time. =)  If your grammar has some form of VPL that it respects, then you can rather dramatically improve the cost of the monadic fragments.  Basically the idea is you add an extra kind of production to your grammar. Instead of just CNF style  A := BC | x   X := B >>= f   is added to the grammar. Then with a normalization step we can 'shove' all the >>='s over to where they consume at least one terminal by using the first monad law.  Then we can observe sharing on our 'sub-universe' of new productions each time we recurse under a >>=."
haskell,3b4ztr,edwardkmett,2,Sat Jun 27 02:42:06 2015 UTC,"To answer a couple of questions, I didn't use:   any of the other backtracking parser libraries because I was keeping my dependencies low. manyTill because it doesn't keep the results of the both parsers, untilP does. TMK, there is no combinator in parsec that does this."
haskell,3b4ztr,danbst,1 point,Fri Jun 26 11:20:18 2015 UTC,"as I showed in https://gist.github.com/deech/28734a84cb4b3fdc0714#comment-1481758  why not  naiveP2 = many $     (,) <$> (many1 alphaNum) <*> (space *> char '{' *> manyTill anyChar (try ending))   where    ending = endOfLine *> char '}' *> endOfLine"
haskell,3b4ztr,danbst,1 point,Sat Jun 27 09:09:25 2015 UTC,"Yours is certainly more concise, and I haven't tested it but it seems like it would fail on the following input:  foo {    ...    }  }"
haskell,3b4ztr,sccrstud92,1 point,Sat Jun 27 13:21:17 2015 UTC,"so, proper solution is a bit trickier. We need manyTill, try and lookAhead  naiveP = many $     (,) <$> id <*> (manyTill anyChar (try ending))   where    id = many1 alphaNum <* space <* char '{'    ending = many space *> char '}' *> (many space *> lookAhead (id *> return () <|> eof))"
haskell,3b4ztr,JoCou,1 point,Sat Jun 27 18:30:57 2015 UTC,"Did you try try? I don't know if it does what you want because I haven't used it, but it would be my first attempt."
haskell,3b2llv,alehander42,12,Thu Jun 25 13:41:19 2015 UTC,"I just want to point out the existence of the MyPy project, which aims to be a ""gradual"" static type checker for Python. It's not a new language, and doesn't change the runtime -- just does type-checking on annotations you add to your Python code.  Guido is apparently interested in it, since he co-authored PEP 0484 along with the MyPy main developer.  Of course it's basically along the lines of Scala: subtyping, Any, etc. Still, I'd rather use it than plain old Python code, if I could (sadly they don't support Python 2)."
haskell,3b2llv,radix,3,Thu Jun 25 16:15:43 2015 UTC,"You can use type annotations in Python 2 with IntelliJ/PyCharms. It uses docstrings. I found it helpful, and it helps to have better completion and code navigation.  https://www.jetbrains.com/pycharm/help/type-hinting-in-pycharm.html"
haskell,3b2llv,jjeeb,2,Thu Jun 25 18:41:42 2015 UTC,"I am aware of the existence of MyPy and PEP 0484. The title is more tongue in cheek, because that was like a thought(and code) experiment about a more functional python with types in an alternative dimension."
haskell,3b2llv,christian-marie,3,Thu Jun 25 16:19:16 2015 UTC,"Does it always have to turn into a superiority complex circle jerk or ""Hey, look at this project, it's better or got there first""?  I personally think this is a rather interesting and obviously experimental project. I personally came here hoping for intelligent discussion of the thing that was posted. Anyway, thanks for sharing."
haskell,3b2llv,conklech,7,Thu Jun 25 22:20:10 2015 UTC,"I don't know what you're talking about, because you posted a vague top-level comment rather than identifying or replying to anything specific.  But I think you may be misunderstanding somebody. This community has a lot of deep roots in academia, where citation and discussion of prior work is an important part of the culture. It serves to cross-reference, reduce duplication of effort, and increase communication within and across disciplinary boundaries. There are few absolutely new things under the sun, and that's fine. Discussing an ideas roots or parallels is a gesture of mutual respect, not superiority.   I can't speak for others, but I sometimes point out relevant prior (or subsequent) work because (1) I'd like the same response to my own work--many eyes make research easier; and (2) I think it's helpful for other interested readers to see relevant material."
haskell,3b2llv,christian-marie,5,Thu Jun 25 22:45:01 2015 UTC,"That is a fair point, thank you for making it. I suppose it was a misunderstanding, so, apologies for my hasty conclusion and outburst.  I think this was less about this thread and more about a perceived pattern, in hindsight.  I was writing less about mentioning prior art, and more about nobody actually discussing the thing which the OP wanted to share (presumably to get feedback)."
haskell,3b2llv,radix,2,Thu Jun 25 23:13:06 2015 UTC,"I assume christian-marie must have been talking about my top-level comment. I'm sorry about that. I didn't intend for it to be dismissive, I was just pointing out another area of development that I thought was relevant."
haskell,3b2llv,Oremorj,-7,Fri Jun 26 01:59:18 2015 UTC,"He would fail immediately, becuase HM is a proper subset of System F...? (Well, alright Haskell is not really System F, but, y'know...)"
haskell,3b2llv,Oremorj,1 point,Thu Jun 25 21:40:29 2015 UTC,"""The title is more tongue and cheek, because that was like a thought(and code) experiment about a more functional python with types in an alternative dimension.""  Of course that can't work with the current Python semanthics : )."
haskell,3b4iou,bkeroack,4,Thu Jun 25 22:17:03 2015 UTC,"You can use turtle:  {-# LANGUAGE OverloadedStrings #-}  import Turtle  retry :: Int -> IO ExitCode -> IO () retry 0 _  = return () retry n io = do     c <- io     case c of         ExitFailure -> retry (n - 1) io         _           -> return ()  main = do     retry 3 (proc ""cmd1"" [""arg1"", ""arg2""] empty)     retry 3 (proc ""cmd2"" [""arg1"", ""arg2""] empty)   One of the advantages of turtle is the beginner-friendly tutorial"
haskell,3b4iou,Tekmo,1 point,Fri Jun 26 03:17:49 2015 UTC,turtle is awesome! Thank you!
haskell,3b4iou,Tekmo,1 point,Mon Jun 29 23:10:09 2015 UTC,You're welcome!
haskell,3b4iou,muyfine,4,Mon Jun 29 23:40:54 2015 UTC,Use shelly!  http://lpaste.net/135230 http://haddock.stackage.org/lts-2.15/shelly-1.6.1.2/Shelly.html
haskell,3b4iou,beerdude26,3,Thu Jun 25 22:38:44 2015 UTC,"Whichever you choose, be sure to post the code snippet here! Or create your own Hakyll blog and host it on Github Pages ;)"
haskell,3b4iou,sccrstud92,2,Fri Jun 26 06:41:08 2015 UTC,"Thanks for everybody's help! I ended up doing something similar to this:  abort = do         putStrLn ""Retries exceeded; aborting""         exitFailure  retry :: Int -> String -> IO () retry 0 _ = abort retry n s = do         c <- shell (T.pack s) empty     case c of                 ExitFailure x -> retry (n - 1) s                 _ -> return () retry4 = retry 4  main = do         let ccl = createCommandList         r <- sequence_ $ map retry4 ccl         putStrLn ""Done!"""
haskell,3b4iou,srenatus,2,Mon Jun 29 23:16:05 2015 UTC,https://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html
haskell,3b4iou,simonmic,2,Fri Jun 26 02:15:32 2015 UTC,"Development.Shake.Command is nice, too."
haskell,3b3vfc,spirosboosalis,5,Thu Jun 25 19:23:02 2015 UTC,"I've built it in many variations in various settings before but never packaged it.  e.g.  http://lpaste.net/79582#line22  The laws are just the Traversable laws with a ""natural transformation"" substituted in."
haskell,3b3vfc,edwardkmett,6,Thu Jun 25 19:51:16 2015 UTC,"Incidentally, this ""Strongly-typed bound"" script is one of my favorite pieces of Haskell code. I started a video series on it a while ago. I filmed most of the second episode, but got stuck on the editing. Making videos is hard..."
haskell,3b3vfc,gelisam,5,Thu Jun 25 20:21:02 2015 UTC,"Thanks. =)  FWIW- Nowadays I'd implement the lam smart constructor in there quite a bit differently. I'd borrow from http://comonad.com/reader/2014/fast-circular-substitution/ rather than use the unsafePerformIO mess I pasted there.  (That isn't to say I'd throw over bound for fast circular substitution, but that if i wanted a pseudo-hoas style lam, I'd get it into bound using that approach.)"
haskell,3b3vfc,edwardkmett,1 point,Thu Jun 25 20:52:03 2015 UTC,"cool :)  ""H"" is for ""heterogeneous""?"
haskell,3b3vfc,AndrasKovacs,3,Thu Jun 25 23:51:13 2015 UTC,"It's for ""higher"" or ""higher-order""."
haskell,3b1yuk,chrisdoner,7,Thu Jun 25 09:03:13 2015 UTC,"I'm posting the thread because I don't know what the Haskell community (at least, this reddit subsection of the Haskell community) thinks about the Haskell Platform and what the default download choice should be on haskell.org. Currently we have this. My comment is here.  EDIT: My follow-up proposal here."
haskell,3b1yuk,dnkndnts,33,Thu Jun 25 09:50:59 2015 UTC,"Just my two cents: my experience with HP has not been positive. On a recent project at our company, I wrote the backend in Haskell (I don't use HP). Our sysadmin (who knows nothing about FP) comes along to make some continuous integration system with Travis or something, and comes to me complaining that nothing builds properly on this system that I was claiming was so awesome.  I then have to spend time trying to figure out why it's not building properly on the CI environment: turns out he was using Haskell Platform, which had super outdated versions of all the libraries which were incompatible with the current versions I was using. So then I have to explain to him why the big, colourful page with nice CSS is actually wrong, and he shouldn't download HP, but should actually download raw GHC (which has big freaking red text that says ""STOP! Please download Haskell Platform, not this!"") so that we can use libraries which aren't 11 months out of date.  He wasn't impressed. And I was left feeling like an idiot."
haskell,3b1yuk,sclv,2,Thu Jun 25 11:26:28 2015 UTC,"Because even if you don't download the platform, you should download a minimal distribution such as ghc-for-os-x or minghc, and not the raw compiler. As I explained three times in this thread.  And the message itself hasn't been updated because it's been there for years and we've had nobody doing any work the ghc website for most of that time."
haskell,3b1yuk,sclv,1 point,Fri Jun 26 02:42:35 2015 UTC,"If you look at the other replies on this thread you'll see that we do now have a volunteer working on it, and we put out a call for help with it some months ago. And furthermore, that there is a proposal to change that text.  You're kicking in an open door outside of the attitude you're bringing with you.  The typical answer to ""why hasn't X good thing been done"" is ""we run on volunteer steam and it wasn't noticed or it was but there was nobody with the spare cycles to do it, please volunteer to help.""  And the more stuff that gets thrown at volunteers about how things aren't perfect, and the more outraged and entitled sounding it is, then the more mental cycles those volunteers lose to dealing with it, and the less appreciated they feel, and the less rewarding that volunteering is, and the less likely more people want to help, because they see what what a world of irritation they're in for just for trying to help.  (sorry for dumping all this in a response to you in particular, btw. i'm expressing a general frustration at the tone of these discussions.)"
haskell,3b1yuk,snoyberg,1 point,Fri Jun 26 02:51:28 2015 UTC,"Where is the source code controlling the GHC download pages (e.g., https://www.haskell.org/ghc/download_ghc_7_10_1) kept? I'd be happy to send a PR for some modified, likely non-controversial text."
haskell,3b1yuk,sclv,1 point,Fri Jun 26 02:54:16 2015 UTC,"To my knowledge the site isn't even in svn. And bear in mind this text isn't just on one file, it is at the top of the download page for each individual compiler release. I think it suffices to replace the text for just the current release as a start given that people apparently find this particularly troublesome. I'll make sure there's some followup here, but given the way this issue was raised I'm not very happy about this whole process."
haskell,3b1yuk,snoyberg,2,Fri Jun 26 03:00:59 2015 UTC,"I agree, the process could definitely be improved. This is the kind of thing I was hoping a centralized issue tracker for haskell.org would be good for. As it stands now, I think the people in this discussion who originally raised concerns had no idea what the right process was for trying to get this changed."
haskell,3b1yuk,sclv,2,Fri Jun 26 08:22:15 2015 UTC,"To be honest, this isn' t just about ""where is the right place to go"". It is about, no matter where you go, perhaps you should ask nicely and be friendly to volunteers.  For example instead of saying ""why hasn't this been done yet (when it hasn't been raised)?"" and ""this is important whether or not you have any resources"" (ick), people could say ""i know that you run on all volunteer steam (and these volunteers have day jobs and other responsibilities as people) and i see the entire ghc page looks like it hasn't had any serious work since 2008 but it would be very helpful if...""  and all of a sudden that just makes everyone's day a little brighter, instead of more exhausting and miserable."
haskell,3b1yuk,Taladar,1 point,Fri Jun 26 14:39:35 2015 UTC,A complete redesign is not necessary to change the link to the main Haskell download page.
haskell,3b1yuk,sclv,4,Fri Jun 26 14:45:42 2015 UTC,"How is this different than if you used e.g. Java 7 and your ops team deployed in a Java 6 environment?  Communication between teams to keep everyone on the same page in terms of version compatibility, etc. is something that always needs to be taken into consideration."
haskell,3b1yuk,bartavelle,8,Fri Jun 26 14:58:32 2015 UTC,"How is this different than if you used e.g. Java 7 and your ops team deployed in a Java 6 environment?   Basically ""java"" is GHC. There is no such things as the platform.  It is very hard for a sysadmin to have her developers use the java stuff that's available by default in her distribution. They mostly want to use maven and download the whole world, just like with cabal. And that's exactly like your haskell developers that want to use ""fresh"" libraries."
haskell,3b1yuk,acow,3,Fri Jun 26 06:31:19 2015 UTC,"If someone told me to use FooBar 7.8.4, I'd think that was pretty specific. If I went to download it, and the page said ""Stop!"", then told me what I should be using instead, I'd probably end up doing the wrong thing, too."
haskell,3b1yuk,sclv,5,Thu Jun 25 16:39:36 2015 UTC,"You still have to indicate what version of e.g. lts haskell your project is intended to build against or whatever, regardless.  ""Build against all the new stuff"" isn't a legit thing to say to an ops team."
haskell,3b1yuk,acow,5,Thu Jun 25 17:04:53 2015 UTC,"That's certainly true, but you just said Java, which is more like GHC than an LTS collection of a thousand user-contributed packages. The confusion with the sys admin could have been avoided by OP, but the confusion due to the downloads situation (""So then I have to explain..."") is on the haskell.org website."
haskell,3b1yuk,sclv,-1,Thu Jun 25 17:04:51 2015 UTC,"no it isn't.  the haskell.org website doesn't say ""stop"" and in fact it points at multiple resources. https://www.haskell.org/downloads  The ghc website says ""stop"" -- and indeed it is not recommended to download the raw ghc compiler. Perhaps it would be better to fix that website to point to the haskell.org/downloads page rather than the platform page directly -- but that's a secondary concern.  Regardless, if you have an ops team that doesn't know your language and setup, you need to point them to very specific steps of where to go for what, not just throw them to the google wolves to find their way."
haskell,3b1yuk,acow,8,Thu Jun 25 17:33:41 2015 UTC,"I don't think we're going to agree, which is why I'm in favor of Chris's idea to have a survey. But to clarify, GHC's page is on haskell.org and this entire thread has been clear when talking about downloading GHC other than you bringing up LTS. I do think that downloading GHC by itself is the best way to get going on OS X and Linux, while MinGHC is the best choice for Windows."
haskell,3b1yuk,sclv,0,Thu Jun 25 17:39:01 2015 UTC,"The confusion is this thread has been about the /downloads page, not the ghc site, which is managed separately, and indeed needs work. The only disagreement has been distinguishing between 'raw' downloads of the compiler alone and so-called 'minimal' distributions.  And my general point, of course, that one must always have clear communications with their ops team.   Btw, work on improving the ghc site is underway. Do you want to get involved? :-p"
haskell,3b1yuk,acow,5,Thu Jun 25 18:17:35 2015 UTC,"No, thank you, I am staying as far away from GHC dev as I can.  What time I can dedicate to infrastructure stuff is going to stack-related things as they've got a lot of the right pieces in place to really smooth things out, and I'd like to figure out how to port the signed binary cache I have for my Nix tooling to stack."
haskell,3b1yuk,Tekmo,3,Thu Jun 25 18:48:44 2015 UTC,"the haskell.org website doesn't say ""stop"" and in fact it points at multiple resources. https://www.haskell.org/downloads   He's referring to this page which still says:   Stop!  For most users, we recommend installing the Haskell Platform instead of GHC. The current Haskell Platform release includes a recent GHC release as well as some other tools (such as cabal), and a larger set of libraries that are known to work together.   How do we fix that?"
haskell,3b1yuk,sclv,5,Thu Jun 25 19:01:03 2015 UTC,"We've got some volunteers to redesign the GHC pages. As part of the redesign, we can pick whatever new text we want. I suggest that the text instead point to the /downloads page rather than the platform page. That way we can all argue over the best way to present the options in just one place, instead of many :-)  Anyway, as the redesign takes place, feel free to chime in on glasgow-haskell-users and proffer all yr suggestions :-)"
haskell,3b1yuk,Taladar,5,Thu Jun 25 19:10:11 2015 UTC,"The ghc website says ""stop"" -- and indeed it is not recommended to download the raw ghc compiler. Perhaps it would be better to fix that website to point to the haskell.org/downloads page rather than the platform page directly -- but that's a secondary concern.   Actually the raw compiler has been consider superior to the platform for a long time now by many. Stack is the first option that might turn out better but it certainly isn't a secondary concern that the GHC download page uses scary language to point people in the wrong direction."
haskell,3b1yuk,sclv,1 point,Thu Jun 25 20:36:52 2015 UTC,"You have confused the raw compiler, which is just the compiler, with a minimal distribution, that at least comes with the cabal install binary. The raw compiler is intended mainly as an upstream distribution source for binaries. For end-users, some distribution is recommended, be it minimal or otherwise."
haskell,3b1yuk,Taladar,6,Thu Jun 25 20:55:04 2015 UTC,"cabal-install directly off Hackage has a bootstrap script that worked fine for me for years, certainly a lot better than the platform ever did.  I suppose for platforms like Windows, which treat people who want to use a compiler like second class citizens, a distribution was necessary. For Linux the least troublesome route was the raw GHC compiler + cabal-install with bootstrap.sh script."
haskell,3b1yuk,mightybyte,8,Thu Jun 25 18:20:41 2015 UTC,"I agree with your comment.  Any time someone comes to me with dependency problems my first move is to get into an environment with as few packages installed as possible.  Like other people have mentioned that usually includes uninstalling the Haskell Platform and installing GHC directly.  I don't mind linking to the Haskell platform, but I think that the link to a direct GHC installer should be presented alongside if not above the platform.  We should focus most of our manpower on promoting and improving the method of install that has the highest probability of success, and my experience indicates that that is GHC."
haskell,3b1yuk,mallai,8,Thu Jun 25 18:41:13 2015 UTC,"MinGHC should definitely be included alongside the platform. It's a choice. I switched to MinGHC simply because the platform was outdated. If the platform keeps up with MinGHC in terms of having a release for every single GHC release, then it will still remain relevant given all the improvements in cabal-install re: true isolation of sandboxes. I expect to see some convergence between the two. MinGHC has MSYS packaged in, which is important. Platform Users need to install it manually. Such distinctions should be highlighted on the downloads page. (like choose Platform if you want.... choose MinGHC if you want...).  Finally, there's also the 'stack' tool which can install GHC for people. It is quite new etc. but at some point it could be offered as a choice too."
haskell,3b1yuk,beerdude26,4,Thu Jun 25 20:37:05 2015 UTC,"MinGHC 4 life. Works flawlessly. Doesn't fight with msysgit on Windows, either."
haskell,3b1yuk,fridofrido,5,Thu Jun 25 12:56:53 2015 UTC,"I'd prefer that you remove the ""Other downloads"" part, in any case. We shouldn't present two conflicting alternatives.   I disagree 110%. I want to be able to find all possibilities on the download page, independently of what the community decides is the best. What is best for some people maybe not the best for other people. Personally I disagree a lot of decisions the ""community"" did in the last few years. Quite possibly I'm not completely alone with that.  Some other comments: I rather dislike all these ""modern"" webpages, especially for pages presenting information, kind of goes against the original information-dense concept of web.   Also usability (questions for both the old and new versions): Does this page work without JavaScript? Does it works from a terminal browser like links? Does it work for a blind person?   (compare say with this page: http://cr.yp.to/ - maybe it's ugly, but works for everyone and easy to navigate. Needless to say, I also liked the old wiki front better)"
haskell,3b1yuk,fridofrido,8,Thu Jun 25 14:10:19 2015 UTC,"If you want to include all the alternatives, you have to explain why they are alternatives and how the implementations differ. We need a story for this. In the absence of that, it just confuses people and makes us look stupid."
haskell,3b1yuk,fridofrido,4,Thu Jun 25 21:14:40 2015 UTC,"Indeed. But maybe we need that story for ourselves, anyway? I guess ""medium-level"" Haskellers also need those explanations. Maybe even I myself need those explanations? So I think we should explain it anyway.   We could say that a magic 1-click thing just works (tm), but it would be a fat lie in todays environment. It was almost true for the Platform when the Platform started, but it is not true anymore. Same thing, I don't think sandboxes are a magic solution, or even any kind of solution (I think sandboxes are treating the symptoms, instead of even trying to do anything about the underlying issues)."
haskell,3b1yuk,theonlycosmonaut,2,Thu Jun 25 12:23:57 2015 UTC,"But maybe we need that story for ourselves, anyway?   Yeah, I agree, you changed my mind. I continued the mailing list discussion here. Thoughts welcome."
haskell,3b1yuk,Taladar,3,Thu Jun 25 16:52:34 2015 UTC,"The new proposal sounds much better! Maybe a short list of pro and contra points for each installer would help people to decide (eg. the platform is not bleeding edge which can cause problems when installing bleeding edge packages, on the other hand it comes with a curated set of libraries, etc)"
haskell,3b1yuk,fridofrido,1 point,Thu Jun 25 17:18:18 2015 UTC,"I like this idea. Provide people with simple information so they can make a decision! It also wouldn't hurt to put a label on one option saying 'we recommend most people do this', as long as the reasons are clear."
haskell,3b1yuk,sclv,4,Thu Jun 25 17:24:43 2015 UTC,It was almost true for the Platform when the Platform started   It was never true for the platform. The platform only ever 'just worked' if you happened to need the exact versions of the dependencies that were included in the platform because it pollutes the global package database with those versions. Of course that exact version match was extremely unlikely.
haskell,3b1yuk,Endzior,1 point,Thu Jun 25 17:32:42 2015 UTC,"That why I said ""almost""... Anyway, platform was less outdated those days and the package ecosystem was also a bit less fragile. So the general experience with the Platform was much better a few years ago than now (haven't tried the brand new one yet)."
haskell,3b1yuk,Mob_Of_One,-2,Fri Jun 26 14:31:22 2015 UTC,"No, it isn't unlikely, to the extent that authors write platform compatible packages, as very many do."
haskell,3b1yuk,MtnViewMark,3,Thu Jun 25 18:24:06 2015 UTC,I can not express how much I agree with this comment.
haskell,3b1yuk,Mob_Of_One,6,Thu Jun 25 18:35:34 2015 UTC,"The irony of asking for help with how Haskell Platform is presented is that a Haskeller got an artist to volunteer her services for a new page design for HP and Mark drove her off by being unresponsive. Now it'll be difficult to get her to have anything at all to do with the Haskell community unless it's with somebody that has been vouched for.  I looped in the founder of TravisCI to help with http://community.galois.com/pipermail/haskell-infrastructure/2015-June/000896.html and Mark never replied to Mathias asking for a URL to the Haskell Platform build so he could bump the timeout for us.  Why are we trying to dump more resources into a tool that hasn't worked well and that we constantly have to tell users not to use? Blaming library authors for not using ancient versions of libraries doesn't fix anything. The tools need to work with the ecosystem (ie, the humans), not the other way around."
haskell,3b1yuk,yitz,1 point,Thu Jun 25 18:42:40 2015 UTC,I don't why you have this idea of history - but it isn't what happened at all.
haskell,3b1yuk,yitz,2,Thu Jun 25 15:19:39 2015 UTC,I replied to your email.
haskell,3b1yuk,MtnViewMark,4,Thu Jun 25 22:33:14 2015 UTC,"Currently we have this   Just to make it clear: what we currently have on haskell.org does not necessarily represent any sort of community consensus or status quo. It was recently slipped through inside what was advertised as a (much needed and very well done) restyling of the haskell.org site.  That doesn't mean it's a bad approach or that most people disagree with it. But there needs to be a discussion about what a standard Haskell installer for Haskell should be like.  The Haskell Platform was created to address exactly this issue, and it definitely had wide community consensus for a while. The problem is that the Haskell Platform was neglected. Right now, I don't see any great option, including Haskell Platform itself.  In our shop we actually use Haskell Platform and it works great for us. But I recognize that some people have a more negative experience. I believe that most of that negativity is caused by a huge amount of false information that is currently out there on the net. Nevertheless, the negative experiences are a reality we must deal with.  Best would be if someone takes the bull by the horns and either fixes the Haskell Platform, or provides a good alternative. For some definition of ""fix"" and ""good"". The neglect of HP might have been a blessing in disguise - there is a lot of great new stuff out there that can be used.  Otherwise, we need to discuss and decide what is the best default installer for Haskell from among what exists right now, and go with that."
haskell,3b1yuk,Taladar,7,Fri Jun 26 02:22:08 2015 UTC,"It was recently slipped through inside what was advertised as a (much needed and very well done) restyling of the haskell.org site.   That's inaccurate. I redesigned the whole site from scratch, including content and the look and feel. In fact, it was running on haskell-lang.org for some months before I was approached to have my site be the new haskell.org.  The rest of your comment I agree with. I've always used plain old GHC since 2007. I'm out of the picture on installing Haskell, so I go off what other people's experiences say and there is enough negativity and technical complaints about HP that makes me question it. I want a single Right Choice as much as everyone else."
haskell,3b1yuk,theonlycosmonaut,1 point,Fri Jun 26 02:46:41 2015 UTC,"Well I guess what I said is a complement then. Because in my opinion, every single content re-write faithfully reproduced - and clarified - what the previous haskell.org site was trying to communicate, except for that one."
haskell,3b1yuk,Taladar,2,Thu Jun 25 12:31:24 2015 UTC,"Based on discussion last Spring about the Platform, we've instituted a number of changes in the platform:  1) Timeliness: We will now coordinate HP releases with GHC releases. (HP RC1 candidates were out the same time as 7.10.2 RC1 candidates!).  2) Latest Packages: Starting with the 7.10.2 release we will now bump every included packages, by default, to the latest version, and include any dependent packages it needs.  Next release we are looking at a way to produce versions of the Platform without OpenGL dependencies(*), and perhaps a minimal package set version as well. This way, there can be consistent installation machinery no matter what your preference for pre-built packages is.  Note: #1 & #2 are major changes to the original HP charter and plan, established before I got involved. The original HP team has very good rationale for their release schedule and conservative package policy - but now it is time to change them.  (*) If you install from the bindist tarballs, you can install HP, with the OpenGL packages, without having OpenGL on your system, and as long as you avoid those packages, you're fine."
haskell,3b1yuk,yitz,0,Thu Jun 25 13:34:39 2015 UTC,Are there any plans to stop the platform's pollution of the global package database with so many more packages than absolutely necessary?
haskell,3b1yuk,Taladar,2,Sat Jun 27 21:28:02 2015 UTC,"Isn't that the exact point of the platform? Surely nothing is absolutely necessary except for GHC, base, and cabal-install, and everything else is just (arguably) convenience."
haskell,3b1yuk,yitz,2,Fri Jun 26 03:23:52 2015 UTC,"Well, that is the point. Any package in the global package database is not so much convenience as a stumbling block for the vast majority of cabal-install operations in any package database (global, user, sandbox), namely all those involving at least one package which depends on at least one dependency in a different version than the one installed globally.  All that is needed in the global package DB are GHC's dependencies and a few other packages (ghc-paths comes to mind but I am sure there are others). cabal-install is not one of them, for that we just need the binary and even the bootstrap.sh script included in its distribution acknowledges that fact by allowing installing it into a sandbox since 1.22.  If the platform were to create a separate package database or shared sandbox for its extra packages beyond those few it might be a lot more useful and a lot less of a hindrance than it is right now. I am thinking of some mechanism that would allow installation of other packages that are incompatible with the platform in parallel to its packages in a separate sandbox."
haskell,3b1yuk,Taladar,1 point,Fri Jun 26 06:34:01 2015 UTC,"Theoretically, packages installed by HP in the global package database are not a stumbling block. They are intended to be reasonable defaults, but there is no requirement to use them. It is simple to override them. And most of the time you don't even need to - the solver often figures out on its own that it needs to use a different version.  But if HP falls too far behind and its packages are almost never at the version needed, those defaults are not ""reasonable"" anymore. That is the current problem with HP."
haskell,3b1yuk,drb226,2,Fri Jun 26 14:36:09 2015 UTC,In my experience the solver is not very good at figuring out that reinstalling some packages that have outdated versions in the global package database in a sandbox is the better option. This is particularly true if we are talking about a dependency of something where we do have a usable version in the global package database and cabal's extreme aversion to reinstalls is invoked.
haskell,3b1yuk,bartavelle,1 point,Fri Jun 26 17:09:49 2015 UTC,"We find the opposite is true - the best way to get a build plan that correctly prioritizes HP's recommended package versions is to force cabal to use those versions by specifying installed constraints for the HP packages. Otherwise, cabal is too eager to replace the recommended versions with newer ones.  On the other hand, if what you prefer for a particular build is the latest, without regard for the HP recommend versions, then just say so with source constraints, and cabal will do that.  In general, the solver has been getting gradually better, but that is overshadowed by the effect of HP getting more and more out of date. That makes the solver's job get harder and harder, whatever your version preferences may be."
haskell,3b1yuk,CharlesStain,5,Sat Jun 27 21:41:15 2015 UTC,Is it too early to present stack as a default option? It seems to be the easiest way to get a full Haskell stack running on a system at the moment.
haskell,3b1yuk,drb226,3,Sun Jun 28 10:56:36 2015 UTC,"On one hand, stack did just come out of beta two days ago.  On the other hand, it works and it's fantastic."
haskell,3b1yuk,MtnViewMark,1 point,Sun Jun 28 22:13:11 2015 UTC,"I second this. Just tried it today, and beside the fact that ghc-mod doesn't know how to find the sandbox it was awesome.  It solves all my problems on Linux."
haskell,3b1yuk,sclv,6,Thu Jun 25 14:07:01 2015 UTC,"I like it very much; it's well blended into the existing theme and it feels ""modern"", which I think it's the ultimate idea we would like to convey, to shake the label ""academia"" off our shoulders ;)"
haskell,3b1yuk,snoyberg,4,Thu Jun 25 21:43:45 2015 UTC,"Here's an idea. What if ""Haskell Platform"" installed ghc, cabal, and stack. At any given point in time, HP just installs the HP set of packages, fixed to their latest LTS Haskell versions. Then stack can do its usual thing on top of that. People who still prefer just cabal can use that."
haskell,3b1yuk,radix,2,Thu Jun 25 17:08:25 2015 UTC,"This is a fine idea for a direction - and some of us have been talking about it... but remember that a) stack is barely out the door and, and b) one downside is that the 'batteries included' libraries that HP provides take a long time to build - and make for a somewhat slow start up experience if you must compiled them afresh for each project."
haskell,3b1yuk,drb226,4,Thu Jun 25 09:26:21 2015 UTC,"I think the long term vision of bringing LTS and platforms into sync (reliant on us regearing the platform release schedule) is an excellent one that should really help get us into a more unified place again. I know there will be hurdles getting there, but if both teams think it is feasible, it will help resolve a lot of the various technical tensions that have been pulling at us."
haskell,3b1yuk,vagif,3,Thu Jun 25 21:59:34 2015 UTC,"I've been on board with this from the beginning. In fact, in my first blog post on the matter, I mentioned the relevance to GPS Haskell, and pointed out:   The goal of this project is to be a testing ground for what GPS Haskell will become. GPS Haskell involves multiple moving parts: Stackage, the Haskell Platform, and Hackage. It's difficult to coordinate work among all those parts and keep stability. Stackage is well set up to support experiments like this by having the multiple snapshot concept built in. The goal is to try out this idea, shake out the flaws, and hopefully when we've stabilized it, the Haskell Platform and Hackage will be ready to adopt it."
haskell,3b1yuk,acow,1 point,Fri Jun 26 03:07:56 2015 UTC,I decided an upvote wasn't enough. This sounds awesome!
haskell,3b1yuk,TumbleSteed,3,Fri Jun 26 04:15:24 2015 UTC,"Right. My idea was to distribute the libs precompiled in the global database as usual for HP. As long as the versions match what stack needs for a given project, it can make use of them since they are in the global db. (No need to recompile in that case.)"
haskell,3b1yuk,sclv,14,Fri Jun 26 10:34:30 2015 UTC,Stack is what haskell platform should have been.
haskell,3b1yuk,TumbleSteed,5,Fri Jun 26 04:37:09 2015 UTC,"And thankfully it is blazing its own trail. We'll be able to link to it to get someone started as step 1, and won't have to apologize for confusion and breakage as step 2."
haskell,3b1yuk,sclv,4,Fri Jun 26 03:27:50 2015 UTC,"EDIT: I was corrected on a number of points here, and while I still support deprecating the platform in favor of stack, it is because stack is easier, more flexible, and makes the ""right decisions"" out of the box, not because there are fundamental limitations with the Haskell Platform.    Seconding this one hard. Haskell Platform's a mess.   It pins some libraries, but not others. It splits your libraries between ""OS level"" and ""user level"". It has no notion of handling multiple versions of GHC. Cabal allows you to install multiple versions of a package at the detriment of it eventually destroying your installation. Upgrading to a new version of Haskell Platform or GHC requires completely wiping your old install. It doesn't support best practices like Stackage/LTS Haskell/Nix.   I've been using Haskell for about six months now, and despite doing an unreasonably large amount of reading and experimentation with different setups, I've borked my system almost a half dozen times.  With stack, you type ""stack build"" and everything gets taken care of. It is the only reasonable way of managing a Haskell workstation without requiring users to first ""see the matrix"".  Wait a bit on this release, deprecate the platform, and start pushing stack with the ferocity of an angered god."
haskell,3b1yuk,TumbleSteed,3,Thu Jun 25 15:27:58 2015 UTC,"What you're describing as the platform isn't. If anything this is a failure of our documentation, or the result of you being provided bad information. In order:  The platform is a blessed set of libraries, versions, and a compiler.  It doesn't ""pin"" anything.  It doesn't split libraries -- the global vs. user vs. sandbox distinction is baked into the standard way packages are handled in GHC (and cabal-the-library).  There is a perfectly legit way to switch between versions of ghc, and you can have multiple platform ghc installs side by side.  Cabal warns you to not install packages that step on one another's toes -- if you want to break your environment you have to override its warnings.  Upgrading doesn't require wiping your own install -- as I noted, they can live side by side just fine, and there are even scripts to switch between them."
haskell,3b1yuk,sclv,1 point,Thu Jun 25 17:13:43 2015 UTC,"EDIT: I was corrected on a number of points here, and while I still support deprecating the platform in favor of stack, it is because stack is easier, more flexible, and makes the ""right decisions"" out of the box, not because there are fundamental limitations with the Haskell Platform.     ""Pin"" and ""bless"" can be used interchangeably since you can't install two versions of a library side-by-side. Idiomatic use of GHC/cabal requires sandboxing if any package on you system is incompatible with any other. Activate-hs has no notion of managing user-level or sandbox-level packages. ""I'm sure switching out these 6 libraries won't break anything else!"" Cabal wouldn't need those warnings if it handled sandboxing, rather than just support it. And upgrading most certainly means a wipe if you don't want your user-level packages to break.   You can hack around this by writing custom scripts that store and retrieve user-level installs with each installed version of Haskell Platform, but that still doesn't solve the sandboxing issue. For that, you either need to sandbox everything and take the disk space/compilation time hit, or share sandboxes between packages that work on the same version.  But by that point you'd realize that that's exactly what stack does, and you wouldn't be debating this with me.  Stack is a solution, not an alternative, and you're being disingenuous by treating Haskell Platform as something that isn't strictly inferior to stack."
haskell,3b1yuk,magnusg7,5,Thu Jun 25 17:57:32 2015 UTC,"""Pin"" and ""bless"" can be used interchangeably since you can't install two versions of a library side-by-side.   Yes. Yes you can. You can install as many versions of a library as you want. You can't install the same version of a library (but with different dependencies), although work is underway to allow that too. If you have multiple versions installed and exposed, by default ghc will pick the latest. But you can change that with ghc-pkg hide and expose, and furthermore, cabal does that for you behind the scenes.   Idiomatic use of GHC/cabal requires sandboxing if any package on you system is incompatible with any other.   No. As per the above. But yes, sandboxing can often help.   Activate-hs has no notion of managing user-level or sandbox-level packages. ""I'm sure switching out these 6 libraries won't break anything else!""   Sure. But that's a far cry from your claim that you can't have multiple ghcs side by side at all.  And in fact, if you switch between compilers, you switch between package repos as well, since they are versioned by compiler.   Cabal wouldn't need those warnings if it handled sandboxing, rather than just support it.   No, it would still need those warnings if you did something that might hose your sandbox.   And upgrading most certainly means a wipe if you don't want your user-level packages to break.   As above, packages are stored in the database by compiler version.  I don't see why, with all of six months in Haskell under your belt, you are insistently and actively conveying disinformation in this thread.  You're right that improvements can be made, and I haven't bashed stack once in this thread. I'm just trying to dispel things that are clearly false about the existing toolset."
haskell,3b1yuk,thesmithdynasty,4,Thu Jun 25 18:21:37 2015 UTC,"As above, packages are stored in the database by compiler version.   I was unaware of this bit and it actually changes a number of my thoughts on the matter. I was under the impression that cabal only stored ""package+version"" information. I'll edit my previous posts to correct them.  I still stand by my stance of wanting to deprecate the platform, since I think stack completely subsumes Haskell Platform in a way that's simpler, more flexible, and makes it hard to shoot yourself in the foot, but now we're talking UX, not bug fixing."
haskell,3b1yuk,emarshall85,2,Thu Jun 25 19:07:55 2015 UTC,"Glad I could clear things up -- my frustration has not been over different evaluations of stack -- it is just that I want to make sure people don't get the wrong idea about what is possible with various other tools already, albeit not necessarily with as ""one button"" of a user interface."
haskell,3b1yuk,gbaz1,3,Thu Jun 25 19:17:02 2015 UTC,I really like it. Keep up the good work!
haskell,3b1yuk,SeriousJope,3,Thu Jun 25 20:26:36 2015 UTC,Looks awesome!  It definitely looks more modern.  Only suggestion would be to add arch linux to the list of linux distros:  sudo pacman -S ghc cabal-install haddock happy alex
haskell,3b1yuk,acow,3,Thu Jun 25 20:52:43 2015 UTC,"It's a bit late, so perhaps this isnt' the best time to comment. I doubt I'd remember to comment later, though.    The color of the ""Download Haskell Platform"" banner at the top threw me off. It's nice and subtle, but I didn't notice it being used on any of the other pages, which made it stick out a bit to me. My eyes had to do far too much traveling to get to important information. I basically had to do move down, right, down, and finally right again before I saw distro options before then having to move left again to see details. The linux section seems inconsistent compared to the Mac and Windows sections. I suppose the point is that there are multiple distributions, but I wonder if it wouldnt' suffice to have the generic installer be default, then have ""other ways to install"" have the distro-specific stuff? No 32bit install for generic linux or Mac, despite one being available for Windows.  The transition from download link (The triple down arrow, that is) to instructions feels jittery. The page scrolls, then the new div appears. It's a bit jarring, to be honest.   I really appreciate the effort made here, and think there's a lot of potential. Had I not been a web developer, I don't know that I'd have been as picky, but as it so happens, I am, so small things on web pages bother me. :-\ . Looking forward to new iterations, even if I personally don't have a use for Haskell Platform."
haskell,3b1yuk,yitz,2,Thu Jun 25 17:28:28 2015 UTC,"That's really nice feedback, thanks! A good eye for design is always appreciated."
haskell,3b1yuk,drwebb,2,Thu Jun 25 22:24:23 2015 UTC,"The current page is less flashy but I think it better shows what kind of options you have when installing ghc. I would not recommend using Haskell Platform as the default option for windows, MinGHC has worked a lot better in my experience."
haskell,3b1yuk,soenkehahn,3,Fri Jun 26 03:00:14 2015 UTC,"I'm considering posting a survey to clear this ""getting Haskell"" question up. Would anybody who currently does not use/recommend the Haskell platform like to contribute questions of things that you think should be fixed? I don't have a good grips on people's gripes, nor, it seems, does anyone, really. Before posting the survey we can check with everyone that it's complete.  We could post this to haskell-cafe and pin it here on this subreddit."
haskell,3b1yuk,gbaz1,3,Fri Jun 26 03:40:54 2015 UTC,"Please don't let the survey grow too much. There are separate issues here: 1) a survey on how to get Haskell today; 2) What do people want from the HP.  There have been some tentative efforts at getting a feel for issue 2 (eg a slimmed down HP), but nothing public has come of them yet. So let's keep that effort going as a separate concern if folks are interested, but the simple question of how to get Haskell should be kept simple.  Run the survey, and we can have a downloads page with the majority recommendation given the headline, and an ""Other Options"" section farther down the page that has a link and one sentence synopsis for other options."
haskell,3b1yuk,concatintersperse,2,Fri Jun 26 10:49:40 2015 UTC,"A survey is not the right approach currently. The problem is that there is a huge amount of confusion and misinformation about cabal and Haskell Platform going around the net. It's suffering from the Google amplification effect. So if you create a survey at this point, at best the results will be based on confusion, and at worst you will contribute even more links to wrong information.  Besides cabal and Haskell Platform, there is a lot of other great new stuff out there. What we need to do is to figure out how to put together what we have into an excellent default Haskell install across all platforms."
haskell,3b1yuk,gbaz1,1 point,Thu Jun 25 14:53:23 2015 UTC,"If anyone wants create a voting platform / survey for Haskell, it's my suggestion to create litlte Haskell service to do that maybe put it on www.haskell.org. You can PM me if you want more information of what we did for the recent commercial haskell survey. The concept came up a few times in the survey suggestions field that we put in early survey runs. Like other things Haskell, it should be up for community involvement and it's going to be so much easier to look at the results.  We sent out the survey as a community service by publishing the data and by the fact that we used our mailing list. The next level of community involvement would be a system where people can participate in suggesting survey questions, and making the survey more publically availible."
haskell,3b1yuk,Mob_Of_One,1 point,Thu Jun 25 17:21:56 2015 UTC,"I'm grateful for every effort to make installation of Haskell easier. But I think at any given point we should strive to recommend what we (the community) use ourselves. So I would very much welcome a survey to find out what that is. And if it were me I would keep questions about problems or possible improvements of any one solution (Haskell Platform, stack, etc.) out of that survey."
haskell,3b1yuk,WarDaft,2,Sat Jun 27 22:12:10 2015 UTC,"My two cents: I hope good discussion comes out of this, but I don't think that the ""reddit subsection of the Haskell community"" is necessarily a good representative pool of ""Haskell users"".  Furthermore, I don't think that we'll eventually make a straight ""up or down"" choice of a winner here because this is a conflicted situation. What we have now is a messy compromise. What I hope we can get to is a less messy compromise.  And we should bear in mind that this proposed redesign is also tied to plans to reboot the Haskell Platform process into a more regular release cycle."
haskell,3b1yuk,yitz,5,Thu Jun 25 23:02:57 2015 UTC,"My two cents: I hope good discussion comes out of this, but I don't think that the ""reddit subsection of the Haskell community"" is necessarily a good representative pool of ""Haskell users"".   I agree, let's make a survey and ask everyone. Then the good discussion can be based on data and shared knowledge of the issues at hand."
haskell,3b1yuk,WarDaft,-2,Mon Jun 29 03:57:46 2015 UTC,"BTW, the definition of ""primes"" that is used there is certainly a popular one. However, contrary to popular belief, this is not an implementation of Erastostenes' sieve. In fact, it boils down to a naive check of divisibility by all prime numbers smaller than the number which is checked.  It indeed works, but it is probably not an algorithm one wants to use as a showcase for Haskell."
haskell,3b1yuk,yitz,2,Thu Jun 25 13:38:55 2015 UTC,https://github.com/haskell-infra/hl/issues/46
haskell,3b1upa,j0sejuan,4,Thu Jun 25 08:01:40 2015 UTC,"Why do you have the CounterBehavior and RandomBehavior types?  You can simplify your counterToBehavior and randomToBehavior functions to these types:  counterToBehavior :: (MonadIO m, Num a) => a -> Behavior m a randomToBehavior :: (MonadIO m, Random a) => Behavior m a"
haskell,3b1upa,Tekmo,3,Thu Jun 25 15:40:12 2015 UTC,"Both are the types used by their modules and xxxToBehavior transform it to the abstraction (eg. counter need Num a but could be more complex).  Anyway, your comment help me more to see my problem as ""currying modules"". Thank you! :)  (I need practice it)"
haskell,3b1upa,Tekmo,1 point,Thu Jun 25 17:48:40 2015 UTC,You're welcome!
haskell,3az605,Evil_is_live,27,Wed Jun 24 17:54:26 2015 UTC,New-haskeller feedback of stack
haskell,3az605,Crandom,21,Wed Jun 24 20:39:03 2015 UTC,I no longer fear haskell builds.   This is exactly the reaction that stack is going for.
haskell,3az605,drb226,13,Wed Jun 24 21:39:44 2015 UTC,"I've been using Haskell for about 6 months now, and I just gave stack a try, and it's basically ""holy shit"" levels of good. Whenever I try out a new technology, I expect a little pain while I work out its quirks and then hopefully settle on a plateau that's higher than where I was before. Stack feels like running without ankle weights, and it integrates flawlessly with the rest of my workflow. Everyone who hasn't tried stack needs to try it now.  Haskell's usability situation is the worst I've ever encountered in a ""mainstream"" language.   The Prelude sucks Modules/records suck No binary downloads No proper editor/IDE (Vim/Emacs don't count) Package discoverability sucks Artifact packaging/distibution sucks There always seems to be at least two libraries doing the same thing which your project depends on both of (exceptions/lifted-base, blaze-builder/cereal/binary, pipes/conduits, etc.) Learn You a Haskell doesn't quite cut it for getting people started There is no Haskell specific literature teaching people how to really exploit/avoid the pitfalls of laziness. There is no good intermediate to advanced literature on effective Haskell design Only has an ""okay"" library selection   But stack singlehandedly crossed ""Managing a Haskell dev machine sucks"" off the list, and a few of those other bullet points are starting to come under scrutiny, as well.  I don't think Haskell will ever be the sexy thing that Ruby or NodeJS is, but each bullet point that gets checked off the list takes it one step closer to supplanting Java (and Python, to a lesser extent)."
haskell,3az605,TumbleSteed,8,Thu Jun 25 06:52:38 2015 UTC,"I think that some of these claims are not complete fair to Haskell:   You can work with Haskell in a great amount of environments. I think that EclipseFP or HaskForce (for IntelliJ) work really well. Right now I am using Atom and a handful of Haskell plug-ins, and I get all kinds of help from it (completion, type inspection...). Of course there are several libraries doing the same thing! This happens in most languages: how many libraries are there for treating dates in Java? How many async libraries are there for Python/Ruby/Java? While the literature on Haskell has been historically small, it is growing in the last years. I myself wrote Beginning Haskell, focused on explaining things such as project management with Cabal, designing using GADTs and other things. The book by Simon Marlow on parallel and concurrent programming, and Real World Haskell dive into the problems of laziness, and they are both free. Furthermore, there are several freely available on-line courses to get started with Haskell! Even though Hackage lacks things such as looking at the newest packages, or some kind of community-based voting to highlight the best packages, I think it really works in terms of discoverability! My usual workflow is to go there, find some package with keywords of what I want to achieve, and usually I get one or two hits. Of course, you have packages such as adjunctions or lifted-base which are complicated to describe, but usually you pull those are requisites of other packages.   I think the main difference with Ruby or NodeJS is that Haskell has grown as a programming language on itself, whereas the others became popular in a specific scenario with a specific set of libraries/frameworks (think of Ruby on Rails)."
haskell,3az605,serras,0,Thu Jun 25 11:16:24 2015 UTC,I think php had wiki style annotations to their online documentation in the late 90's. It would be great if Haskell was less than 20 years late.
haskell,3az605,hastor,7,Thu Jun 25 15:45:39 2015 UTC,In the spirit of a previous post let's classify the inconveniences:   Prelude: libraries Modules/records: language Binary downloads: tooling (though Halcyon does exist) Editor: tooling Package discoverability: tooling Artifact packaging: tooling I guess (I don't know what you mean) Two libraries doing the same thing: libraries LYAH: teaching materials Literature on laziness: teaching materials Literature on design: teaching materials Library selection: libraries
haskell,3az605,tomejaguar,7,Thu Jun 25 08:26:09 2015 UTC,why dont vim nor emacs count as proper editors?
haskell,3az605,hagda,1 point,Thu Jun 25 08:41:33 2015 UTC,"They are proper editors. But they take a long time to learn. If I just want to have ide-like features in an editor, having to invest time in learning vim or emacs may not be feasible. Not everyone likes modal editors either."
haskell,3az605,Crandom,4,Thu Jun 25 11:53:34 2015 UTC,IntelliJ has several Haskell plugins now if you want a traditional IDE
haskell,3az605,Tekmo,1 point,Thu Jun 25 18:03:53 2015 UTC,"Sadly they all depend on ghc-mod which is very hard to get working properly, especially with 7.10 :( I'm not sure how it interacts with stack either."
haskell,3az605,Crandom,1 point,Thu Jun 25 18:37:57 2015 UTC,Emacs isn't modal.
haskell,3az605,szabba,2,Thu Jun 25 15:26:47 2015 UTC,"Ok, s/modal/scary/ :p"
haskell,3az605,Crandom,3,Thu Jun 25 16:08:09 2015 UTC,"I'll have you know that substitution syntax comes from ed an early ancestor of vim, sed and sam."
haskell,3az605,szabba,1 point,Thu Jun 25 18:48:22 2015 UTC,"You should go with Atom or Sublime Text then, they work ok out of the box. If you don't want to spend time with your most basic tools, no IDE in the world will be really useful."
haskell,3az605,Kaligule,1 point,Sat Jul 4 11:39:42 2015 UTC,"Two different string types is one of my pet peeves, but perhaps that goes under Prelude sucks?"
haskell,3az605,SeriousJope,1 point,Thu Jun 25 07:50:21 2015 UTC,"5 types of string, actually, 4 of which are useful. (String, lazy and strict Text, lazy and strict Bytestring).  Other than String, this is pretty much the right decision, because dealing specifically with text and dealing with bytes of generic binary are two different use cases.  Also, only one of these (String, the design mistake) is in Prelude."
haskell,3az605,rpglover64,8,Thu Jun 25 12:08:24 2015 UTC,String is useful if you want to write a loop over a computed sequence of characters because the laziness is quite fine grained. But I think it makes more sense to use [Char] rather than the type synonym then.
haskell,3az605,kamatsu,2,Thu Jun 25 13:21:27 2015 UTC,Agreed.
haskell,3az605,rpglover64,4,Thu Jun 25 13:48:25 2015 UTC,Bytestring hardly qualifies as a string type in the sense people usually mean when they talk about strings in any language other than C.
haskell,3az605,kqr,5,Thu Jun 25 12:45:34 2015 UTC,"Bytestring isn't a string, it's something similar to a poorly named byte array."
haskell,3az605,Crandom,1 point,Thu Jun 25 16:09:42 2015 UTC,That's why there is the class ByteArray in vincenthz's memory which is heavily used in his new crypto library cryptonite.
haskell,3az605,ibotty,1 point,Thu Jun 25 17:48:25 2015 UTC,"No proper editor/IDE (Vim/Emacs don't count)   You also forgot that you need to be able to read and write,  that takes a long time to learn. Mainstream programming language should be visual, like scratch ;-)."
haskell,3az605,maxigit,23,Thu Jun 25 19:26:49 2015 UTC,I've read this post twice and now know why stack isn't cabal. But why wasn't it a fork of Cabal? This article doesn't seem to explain it.
haskell,3az605,Jookia,21,Wed Jun 24 19:11:52 2015 UTC,It uses Cabal the library but reimplements all the commands/UI in the executable cabal-install. It makes no sense to fork cabal-install as it would basically need to all be changed. The bulk of the logic in cabal the tool is in the Cabal library which stack is using.
haskell,3az605,Crandom,36,Wed Jun 24 20:43:01 2015 UTC,"I assume you mean why wasn't it a fork of cabal-install (you have to be clear on the naming). It started out with a Makefile a client was using to build multiple packages at once, and for our own projects, an internal Haskell script called fpbuild that would know how to unregister and upgrade packages properly when we updated. That was used for a couple years at FPCo. Then it became a Haskell project based on Shake that knew better how to read cabal files and figure out incremental building dependencies. Then we had a bunch of code in a number of projects for dealing with packages, using, modifying or replacing the Cabal library, with newer, more efficient data types and a coherent logging story among other things. Then we had all these tools lying around, so we re-implemented or merged them into the stack library, then made an executable which focused all our goals into one place. With regards to cabal-install, almost every feature is implemented differently, with different libraries and/or different places to put or get things, and with our own types for packages, package names, versions, etc. it uses modern libraries and extensions. See the library. In all, a fork of cabal-install wouldn't look anything like cabal-install, source-wise or behaviour-wise, it'd have to have a new name (e.g. ""stack"" ;-) and would be a waste of time trying to ""upgrade"" instead of just starting from what we wanted to achieve and implementing it. The motivation was never “let's do this differently from cabal-install”, but rather “let's look at the user workflow (for newbies and big business projects) from scratch and then make a tool that fits it.” Stack is a few years' worth of commercial and newbie client tooling experience and feedback packed into one tool."
haskell,3az605,chrisdoner,13,Wed Jun 24 21:29:25 2015 UTC,"Wow, that's great.  To me, evolving a tool from the real life needs of multiple clients seems like a much more compelling reason for the creation of stack than the survey.  I think I'm just generally distrustful of the interpretation of free text in surveys (documentation had similar quantitative results to package management, for instance) and survey design is tricky in general (especially if there might have been a result in mind at the start).  I still think the survey was a good thing, and a good additional reason for stack.  I just like the real-world case more - especially since it means you had more data about the details of what people wanted rather than just ""something other than what we have now""."
haskell,3az605,dalaing,6,Wed Jun 24 23:29:27 2015 UTC,Thanks for the explanation!
haskell,3az605,Jookia,12,Wed Jun 24 22:10:32 2015 UTC,Is there a Stack tutorial that I can link to when recommending Stack to new Haskell programmers?
haskell,3az605,Tekmo,9,Wed Jun 24 23:59:02 2015 UTC,"There are two main use cases for stack.   You want to write your own stack.yaml for a project A stack.yaml is already written for the project you want to work on   In the latter case, all they have to do is follow the download instructions and run stack test on the project. Stack's messages should guide the user from there if anything needs to be set up.  In the former case, I don't know if any good ""tutorials"" exist yet. You can refer to the readme, and read up on the stack.yaml wiki page. Stack's messages again should help guide you in writing a stack.yaml for an already-cabalized project. If you'd like to use stack to start a brand new project, then try stack new, although I don't think this command is very polished yet.  Generally, I'd link newbies to the readme for now.    There's also a third use case that stack wasn't quite designed for but can still handle quite well:   You want to use stack to experiment with arbitrary Haskell code   In that case, create a new folder, and write this as your stack.yaml file:  resolver: lts-2.15   Then you can stack install $dep for any given LTS Haskell dependency you use in your scripts, and stack runghc $hsfile for any given .hs file you've got. If you want anything more complicated than that, then you might as well create a project for it."
haskell,3az605,drb226,5,Thu Jun 25 02:07:52 2015 UTC,The README is exactly what I was looking for.  Thanks!
haskell,3az605,Tekmo,2,Thu Jun 25 02:10:07 2015 UTC,For all my projects I've just been using stack init without any problems. The only time I write my own stack.yaml is when I need to add dependencies not on stackage.
haskell,3az605,codygman,3,Sat Jul 4 05:27:08 2015 UTC,"I was actually wondering the same thing as /u/Tekmo (but in this case I am the newish the programmer), but not finding anything, I just downloaded it and started using it.   I have to say that I am blown away: I typed in stack build after cloning a git repo of a haskell project and stack guided me the whole way. First it told me I needed to run stack init, and then, guessing again, I tried build after that. At that point, stack recommended I run stack setup because of a wrong GHC version, so I did that too.   Finally, I ran stack build and it ran through to completion on a project that I had struggled mightily to build on my own in the past.   I am always hesitant with new tools, but my first impression has been really good."
haskell,3az605,erewok,26,Sun Jun 28 16:58:33 2015 UTC,"In practice with stack: I set up a XMonad configuration project and get up and running using stack new in just about less then 10 minutes. This was something I had just given up on ever maintaining using cabal (pre-sandbox admittedly). I think I had given up on ever maintaining it before sandboxes just came out. The processes of going through setting up the sandboxes was just that little too much against my resolve to actually change something to make me actually do it. Plus the thought of wasting all that disk space just because I wanted to maintain a couple files.  With stack, I know I'm going to be able to reproduce my build in the future. There was no big compile setup because I choose a version of nightly which I have been running for the past week. Everything just works.  We're very excited here at FP Complete to see the positive uptake with stack. I hope this makes it clear why we went ahead and built this instead of continuing to try to improve cabal."
haskell,3az605,drwebb,8,Wed Jun 24 18:49:07 2015 UTC,do you manually move the xmonad executable to  .xmonad folder? And how do you handle auto recompiles?  ( Mod+Q) ?
haskell,3az605,arianvp,7,Wed Jun 24 20:45:27 2015 UTC,"I'm pushing some changes soon to provide user specified path to thestack install command. No more manual copying things, yay.   I guess I would try running another stack install for the recompile, but I never really used the feature much myself."
haskell,3az605,drwebb,1 point,Wed Jun 24 21:08:01 2015 UTC,"It might be useful if there was a field in the .cabal file or stack.yaml to inform stack/cabal-install of the fact that the installed binary requires the libraries during normal operation (e.g. xmonad when recompiling, propellor and similar projects) so the install tool could automatically generate a wrapper script that sets up an environment where the binary can call the compiler with the proper sandbox.  I did something similar for xmonad with a GHC wrapper script in the PATH before the regular GHC that checks whether the parent process is xmonad and then calls GHC with the proper parameters."
haskell,3az605,Taladar,3,Thu Jun 25 13:36:26 2015 UTC,I'm very excited to try Stack out! I have all but stalled development on a couple of hobby projects because when I got a new computer cabal-install stopped building them locally and I couldn't be arsed to figure out which packages it gets the wrong versions of and so on. High hopes for Stack!
haskell,3az605,kqr,6,Wed Jun 24 20:56:48 2015 UTC,"This doesn't make it clear... You're pointing out what you like about stack, but this still doesn't spell it out why you built a new tool from scratch rather than improving cabal."
haskell,3az605,hagda,3,Wed Jun 24 20:48:14 2015 UTC,"By ""this"" I presume he meant the blog post (meant to answer that specific question), and not necessarily his comment (meant to provide a relevant anecdote).  If the blog post leaves the question unclear, then by all means, let us know and we'll try to clarify further, if possible."
haskell,3az605,drb226,1 point,Wed Jun 24 21:36:40 2015 UTC,Spelled out here.
haskell,3az605,chrisdoner,4,Wed Jun 24 21:35:49 2015 UTC,"""Improving"" cabal-install basically means throwing everything out and starting over. This is what the people at FPCo did, and at that point it makes sense to also create a new name.  Mind you that ""throwing everything out"" from cabal-install is not as drastic as it sounds – ""the good parts of Cabal"" lie in the Cabal library, not the cabal-install program. Stack still uses the Cabal library."
haskell,3az605,kqr,6,Thu Jun 25 08:32:31 2015 UTC,Can it be used to build GHCJS yet?
haskell,3az605,logicchains,5,Thu Jun 25 06:08:14 2015 UTC,There is some preliminary discussion on github.
haskell,3az605,Crandom,3,Thu Jun 25 06:42:49 2015 UTC,"Thanks for this writeup. I am very positive about the future of stack (being myself a very minor contributor), and I think that it is a huge win for the GHC haskell ecosystem."
haskell,3az605,andrewthad,3,Wed Jun 24 22:28:45 2015 UTC,Note that this doesn’t mean users have to painstakingly write out all package versions longhand. Stack supports naming package snapshots as shorthand for specifying sets of package versions that are known to work well together.   What are the ways in which I can get these snapshots? Ideally I think I'd like this to be something I can run locally using the current state of hackage.
haskell,3az605,nkpart,3,Wed Jun 24 22:58:44 2015 UTC,Was there some expectation that stack should have been cabal?
haskell,3az605,theonlycosmonaut,4,Thu Jun 25 04:56:31 2015 UTC,"There are really three things that people talk about when they say “Cabal”   Yeah, it feels pretty overloaded.  cabal install cabal-install"
haskell,3az605,jeandem,6,Wed Jun 24 23:31:55 2015 UTC,But that's just one thing!
haskell,3az605,srhb,1 point,Thu Jun 25 00:11:30 2015 UTC,Feels meta though.
haskell,3az605,jeandem,4,Thu Jun 25 00:38:59 2015 UTC,"But you can do stack install stack too, so long as you put stack in $HOME/.local/bin. And that's recommended."
haskell,3az605,technicolorNoise,2,Thu Jun 25 01:43:14 2015 UTC,Why? To have a user-local stack install that's the most up to date?
haskell,3az605,hiptobecubic,5,Thu Jun 25 03:31:27 2015 UTC,Yes. So you literally only need to run stack install stack to upgrade.
haskell,3az605,radix,1 point,Thu Jun 25 03:35:32 2015 UTC,"Though it doesn't work if you have your global stack.yaml set to use a recent nightly build, since stack doesn't build from source with ghc 7.10.  EDIT: 7.10.1 specifically. It's a ghc bug that'll be fixed in 7.10.2 apparently."
haskell,3az605,technicolorNoise,1 point,Thu Jun 25 04:27:35 2015 UTC,"And it's specifically a Mac OS X issue, it works on other OSes (our Travis build tests on Linux, for example)."
haskell,3az605,snoyberg,1 point,Thu Jun 25 08:45:36 2015 UTC,What would have felt equivalent to that would be something like cabal-install cabal-install. The lack of the hyphen in the first part makes it feel meta and disoriented.
haskell,3az605,jeandem,4,Thu Jun 25 20:02:48 2015 UTC,"cabal install cabal-install might very well be one of my favourite commands to type. There's something inherently fun in it that can't be matched with stack install stack.  You will be missed, cabal-install."
haskell,3az605,kqr,3,Thu Jun 25 08:37:24 2015 UTC,"I think the way the article has to say ""Cabal-the-tool"", ""Cabal-the-spec"" and ""Cabal-the-library"" in order for us to understand it is evidence enough that stack shouldn't be cabal."
haskell,3az605,BethAr,12,Wed Jun 24 20:33:42 2015 UTC,"I don't think so. It's just evidence that Cabal-the-tool hasn't really had much competition up until now, and Cabal-the-library still doesn't have any competition. It's just been easy to take for granted that the spec, lib, and tool are not all the same. Now along comes a contending tool and we suddenly find the need to disambiguate in order to clarify the proper point of distinction."
haskell,3az605,drb226,7,Wed Jun 24 21:44:50 2015 UTC,"Honestly, I have to disambiguate every time I want to introduce someone to Haskell, and that necessity predates stack by many years."
haskell,3az605,BethAr,1 point,Wed Jun 24 22:11:28 2015 UTC,"FWIW, back when it was first invented, people were very explicit about distinguishing the tool vs the library/spec. It's just that, over the years, people have gotten lazy about / forgotten about that distinction.  Granted, it doesn't help that the cabal-install package provides the cabal executable for commandline use of the Cabal package. Names are hard."
haskell,3az605,winterkoninkje,7,Fri Jun 26 01:41:35 2015 UTC,"Why is this evidence? Just because the term ""cabal"" happens to be overloaded we need a new name/tool (which ironically happens to be an even more overloaded term)?"
haskell,3az605,hagda,2,Wed Jun 24 20:50:39 2015 UTC,"It's not ""overloading"" that's the problem (i.e. calling different things by the same name).  It's calling three closely related things by the same name and people not realising that they are actually different."
haskell,3az605,tomejaguar,2,Thu Jun 25 08:06:13 2015 UTC,stackabal then? :-)
haskell,3az605,Ancipital,6,Fri Jun 26 04:18:58 2015 UTC,I think it's evidence that cabal shouldn't be cabal.
haskell,3az605,tomejaguar,-4,Wed Jun 24 20:52:27 2015 UTC,cabal is dead. Long live stack!
haskell,3aztl6,mightybyte,7,Wed Jun 24 20:48:25 2015 UTC,"Some constructive criticism.  Could you start the stream a few minutes before the actual start of the talk? I came here at 7pm and kept refreshing every few minutes, and still managed to miss the beginning.  When you stopped the stream during the break, the livestream interface started to play the next video in the queue, which meant I again had to refresh every few minutes to see if the new stream was up or not. Leaving the video on but the sound off would have provided a better user experience."
haskell,3aztl6,gelisam,4,Thu Jun 25 00:59:52 2015 UTC,Thanks for the comments.  We'll keep that in mind next time.  Still trying to get the hang of this live stream setup...
haskell,3aztl6,radix,6,Thu Jun 25 02:24:39 2015 UTC,"This is a great idea! I'm not sure I'll be able to watch tonight, but I'll try. Is there any chance of audience participation in Q&A?"
haskell,3aztl6,howardbgolden,3,Wed Jun 24 20:52:21 2015 UTC,"I suppose there is in the future, but we'll have to think about how to best set that up...so probably not tonight.  We welcome suggestions / brainstorming about how we might best leverage this.  Edit: I guess one approach could be to post questions to this reddit thread and we could try to have someone ready to ask the ones with the most upvotes.  We'll see what we can do."
haskell,3aztl6,zorasterisk,4,Wed Jun 24 20:56:44 2015 UTC,Link to the stream:  http://original.livestream.com/pivotallabs
haskell,3aztl6,broma0,4,Wed Jun 24 23:09:00 2015 UTC,Will this stream be saved so it can be watched at a later time?
haskell,3ayd95,jpvillaisaza,9,Wed Jun 24 14:19:39 2015 UTC,Abstract. This blog post is a tutorial for writing emacs extensions calling Haskell functions using haskell-emacs. The introduced extension calls from emacs into the Cabal library to parse the build targets of a cabal file and passes them back to emacs.
haskell,3ayd95,m0rphism,2,Wed Jun 24 19:38:33 2015 UTC,thanks! loved the mockup.
haskell,3ayd95,sambocyn,7,Wed Jun 24 20:36:10 2015 UTC,"I really like the idea of using Haskell to write emacs extensions. As shown in this blog post, it is already possible to call Haskell from elisp. What I'm missing is the other direction: calling emacs functions from Haskell. Does someone know if this is already possible somehow?"
haskell,3ayd95,m0rphism,1 point,Wed Jun 24 19:44:19 2015 UTC,What is the use case of that?
haskell,3ayd95,kraml,6,Wed Jun 24 21:19:37 2015 UTC,"The use case, I had in mind, was writing emacs extensions entirely in Haskell.  At the moment, haskell-emacs does not support passing elisp functions as arguments to haskell functions. So without any other way of calling elisp functions from Haskell, I see no way to control emacs from Haskell directly, e.g. by performing an IO action to move the emacs cursor.  A workaround might be to return those actions as strings of elisp expressions to emacs and then eval them. But I'm not sure yet if this approach could be extended to provide a generic interpreter, which is flexible and fast enough to allow for conveniently writing arbitrary emacs extensions entirely in Haskell.  Personally, I'm pretty paranoid when I'm programming in a language without types. So if I could rely solely on Haskell, that would make it significantly more comfortable for me to write an emacs extension ;)"
haskell,3ayd95,m0rphism,1 point,Wed Jun 24 22:21:03 2015 UTC,"Let's use a ELisp monad to write typed code which can translated into elisp action. (The mechanism for passing the intended elisp code to Emacs and evaluating it would be orthogonal to the code of the module then.)  (Perhaps, that's similar to a ""shell monad"" mini-project I've seen announced by Joey Hess in his blog.)"
haskell,3ayd95,imz,1 point,Thu Jun 25 06:40:39 2015 UTC,Possible but not implemented: http://www.reddit.com/r/haskell/comments/38704v/is_the_yi_editor_dead/crsszmt
haskell,3ayeyd,concatintersperse,21,Wed Jun 24 14:33:44 2015 UTC,Should also picture Gordon FreeMonad
haskell,3ayeyd,dimsuz,15,Wed Jun 24 22:05:50 2015 UTC,"We now have direct confirmation of a disruptor in our midst, one which has acquired an almost messianic reputation in the minds of certain citizens.  Its figure is synonymous with the darkest urges of instinct, ignorance and decay.  Some of the worst excesses of the 1997 Haskell Workshop in Amsterdam incident have been laid directly at its feet.  And yet unsophisticated minds continue to imbue it with romantic power, giving it such dangerous poetic labels as the One Free Monad, the Opener of the Way.   Let me remind all citizens of the dangers of magical thinking.  We have scarcely begun to climb from the dark pit of our combinational species' evolution.  Let us not slide backward into oblivion, just as we have finally begun to see the light.  If you see this so-called ""Free"" Monad, blog about it. Civic deeds do not go unrewarded.  And contrariwise, complicity with its cause will not go unpunished.   Be wise. Be safe. Be aware. Avoid success at all costs."
haskell,3ayeyd,darchon,15,Wed Jun 24 23:13:25 2015 UTC,http://images.uncyclomedia.co/uncyclopedia/en/f/fb/Halflife-Haskell.jpg
haskell,3ayeyd,joeyadams,11,Wed Jun 24 16:28:59 2015 UTC,This one too :) http://www.superbwallpapers.com/games/half-life-42772/
haskell,3ayeyd,bartavelle,8,Wed Jun 24 14:57:42 2015 UTC,Hipster Logo Generator: http://i.imgur.com/dUmL8KT.png
haskell,3ayeyd,Platz,7,Wed Jun 24 17:56:57 2015 UTC,"""Late""? Why are the Latin letters upside-down?  /s"
haskell,3ayeyd,conklech,9,Wed Jun 24 20:36:36 2015 UTC,"My first thought was, ""That's a weird way to typeset 'LaTeX'."""
haskell,3ayeyd,rpglover64,2,Thu Jun 25 03:58:58 2015 UTC,"I'm not a big haskell user so they may have different contextual meaning, but in general...  https://en.wikipedia.org/wiki/Existential_quantification https://en.wikipedia.org/wiki/Universal_quantification https://en.wikipedia.org/wiki/Contradiction"
haskell,3ayeyd,SexDrugsAndMath,4,Thu Jun 25 01:20:11 2015 UTC,"Yep! In this context the one on the bottom is called, well, ""bottom,"" and represents a number of things including nontermination.  (The ""/s"" is code for ""that was sarcasm. But that's okay.)"
haskell,3ayeyd,conklech,3,Thu Jun 25 01:30:08 2015 UTC,"Oh jesus, the sarcasm, it hurts."
haskell,3ayeyd,SexDrugsAndMath,3,Thu Jun 25 01:32:19 2015 UTC,"well there was no ""open sarcasm"" tag so i couldn't parse it right :-P"
haskell,3ayeyd,sclv,3,Thu Jun 25 04:25:08 2015 UTC,"Reading Reddit comments requires a backtracking parser. Unlike HTML5, where parsers must accept certain non-closed tags and insert closing tags as appropriate, Reddit markup requires parsers to accept non-opened tags and insert opening tags as appropriate."
haskell,3ayeyd,conklech,1 point,Thu Jun 25 18:16:51 2015 UTC,"The top symbol should've been ¬, then it would've been ∃⊥∀¬ :-)"
haskell,3ayeyd,want_to_want,5,Thu Jun 25 10:58:51 2015 UTC,That was my archlinux/xmonad wallpaper for so very long.
haskell,3ayeyd,agumonkey,2,Wed Jun 24 15:05:59 2015 UTC,"Where are 2880x1800, 1920x1200? :("
haskell,3b0lbj,SrPeixinho,4,Thu Jun 25 00:27:26 2015 UTC,"I'm not sure that I got your point, but the case of zipN (or, more precisely, zipWithN) was considered by Martin Odersky in his paper “Type Classes as Objects and Implicits” for Scala programming language (cf. 6.4—6.5). This can be easily found on Internet."
haskell,3b0lbj,ulysses4ever,4,Thu Jun 25 06:51:19 2015 UTC,"You might find the treatment of n-tuples in the generics-sop library of interest: http://hackage.haskell.org/package/generics-sop (see also the paper, linked from the Hackage page)."
haskell,3b0lbj,edsko,7,Thu Jun 25 09:53:41 2015 UTC,I find it very difficult to understand your code. Is there any particular reason you are not using meaningful variable names nor indentation? Is this computer-generated code?
haskell,3b0lbj,gelisam,1 point,Thu Jun 25 00:52:03 2015 UTC,"This is computer generated code, sorry! If I just posted the actual definition, I'd need to also post a ton of dependencies, or else it wouldn't be any more helpful:  zipWith = deriveZipWith List   I'll be posting this stuff with proper context sometime soon...  Edit: To be clear, I just wanted to post in a way you could put in a lambda calculator and validate. Don't try to understand it without context, as it would be very difficult. Some of my SO questions track how I got there."
haskell,3b0lbj,gelisam,2,Thu Jun 25 01:14:43 2015 UTC,"Don't try to understand it without context, as it would be very difficult.   Okay, so what is it you are asking for then? I thought you wanted to know whether there was a type system in which the specific expressions you gave were well-typed. But without understanding which kind of things your expressions are doing which work in the untyped lambda calculus but not in the simply typed lambda calculus nor in System F, that question reduces to: is there a type system in which arbitrary expressions from lambda calculus can be given a type. Is that what you are asking for?  You mention that one of your functions is total. Are you looking for a type system in which all well-typed expressions are guaranteed to terminate, like the STLC and System F, or are you merely looking for something in which evaluation preserves the types?"
haskell,3b0lbj,sccrstud92,1 point,Thu Jun 25 15:32:20 2015 UTC,"No, not those expressions. I'm asking for someone with the proper experience what is the overall process for doing so, how hard it is, and what systems could be used. All in a very informal way. Now I'm glad you couldn't read those expressions, then, because if you spend your time working on typing them I'd feel very bad! I don't want to give anyone work. Just overall opinions."
haskell,3azcae,HighCode,6,Wed Jun 24 18:38:55 2015 UTC,"There's a Windows fork of hdevtools here.  Also I recommend replacing Cygwin with MSYS2.  Also what do you need hdevtools for? Because if it's SublimeHaskell, you don't really need it if you've got ghc-mod (or better still, use the new fork and hsdev)."
haskell,3azcae,tejon,1 point,Wed Jun 24 19:28:54 2015 UTC,Thanks for the info!
haskell,3awgj1,mnik,14,Wed Jun 24 01:33:09 2015 UTC,"Works great! :-)  I like how it has a bit more ""smartness"". By giving a command ""build"" or ""test"" you state your intent and the tool ""makes it happen"". If that means downloading GHC, initializing sandbox, figuring out which stackage version, and building all deps (also for test target), it just does all that's necessary. Previously, I was using ""stk sandbox"" to have shared sandboxes but this is all automatic now. Also, a great feature is being able to configure many projects using a single stack.yaml file."
haskell,3awgj1,mallai,10,Wed Jun 24 02:25:11 2015 UTC,"I love this. It's made my experience with Haskell so much nicer.  Unfortunately, there aren't any vim plugins that work with stack, so I need to have a cabal sandbox directory anyway. I'm hoping that'll get resolved soon. Otherwise I may have to learn emacs..."
haskell,3awgj1,ephrion,6,Wed Jun 24 16:34:41 2015 UTC,"Or help make a Vim plugin :)  Actually, please do this, I don't want to have to learn emacs again."
haskell,3awgj1,snoyberg,8,Wed Jun 24 17:26:58 2015 UTC,You could try spacemacs to get the best of both worlds.  I switched after years of vim and I am very happy with it.
haskell,3awgj1,snoyberg,2,Wed Jun 24 18:41:14 2015 UTC,I think I'm going to have to.
haskell,3awgj1,sgraf812,2,Wed Jun 24 20:55:18 2015 UTC,"I particularly like that it works out of the box and already has awesome plugins which actually work with another. I never found a good default configuration for vim which just worked.  I don't know anything about emacs, but with evil mode it is just a better (yet slower) vim to me."
haskell,3awgj1,bb010g,1 point,Thu Jun 25 08:10:29 2015 UTC,Have you checked out neovim?
haskell,3awgj1,ephrion,3,Sat Jun 27 01:53:48 2015 UTC,"But vimscript is scary! ;)  Is there already some discussion or effort on this that I can join in on? IIRC the reason the current vim plugins don't work is a dependency on hdevtools and ghc-mod, both of which are dependent on cabal. There's not much documentation on using ide-backend, so I'm not really sure where to start."
haskell,3awgj1,snoyberg,1 point,Wed Jun 24 18:34:18 2015 UTC,I don't think the discussion has started yet. Wanna kick off a thread on the haskell-stack mailing list?
haskell,3awgj1,codygman,1 point,Wed Jun 24 20:55:05 2015 UTC,"You can likely replace calls to ""cabal"" with ""stack""."
haskell,3awgj1,Jurily,15,Thu Jun 25 01:32:54 2015 UTC,And the award for least searchable name for a serious project goes to...
haskell,3awgj1,Kaligule,37,Wed Jun 24 03:51:34 2015 UTC,R.
haskell,3awgj1,Taladar,10,Wed Jun 24 05:31:48 2015 UTC,Give C some credit here. It clearly was the first major language using a one letter name.
haskell,3awgj1,dllthomas,2,Wed Jun 24 13:15:46 2015 UTC,"I don't know what the threshold is for ""major language"" but B preceded C."
haskell,3awgj1,Jurily,3,Wed Jun 24 14:31:33 2015 UTC,In 1969? 3 users.
haskell,3awgj1,Kaligule,2,Wed Jun 24 15:12:18 2015 UTC,https://en.wikipedia.org/wiki/B_%28programming_language%29
haskell,3awgj1,autowikibot,2,Wed Jun 24 21:44:27 2015 UTC,"B (programming language):       B is a programming language developed at Bell Labs circa 1969. It is the work of Ken Thompson with Dennis Ritchie.  B was derived from BCPL, and its name may be a contraction of BCPL. Thompson's coworker Dennis Ritchie speculated that the name might be based on Bon, an earlier, but unrelated, programming language that Thompson designed for use on Multics.   B was designed for recursive, non-numeric, machine independent applications, such as system and language software.      Relevant: Little b (programming language) | Programming Language for Business | Ken Thompson | Martin Richards (computer scientist)   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3awgj1,Kaligule,1 point,Wed Jun 24 21:45:07 2015 UTC,"Oh, I didn't even think of C. But C became so popular that you actually find lots of documentation."
haskell,3awgj1,Taladar,2,Wed Jun 24 21:43:54 2015 UTC,I think C gets away with it by being a very simple language. Almost everything you ever want to know about C is either platform specific (like calling conventions) or part of some C library.
haskell,3awgj1,snoyberg,13,Wed Jun 24 21:55:36 2015 UTC,"Alright, let's rename it to caballero."
haskell,3awgj1,BethAr,9,Wed Jun 24 07:38:32 2015 UTC,¡caballero configure!  ¡caballero instale!
haskell,3awgj1,theonlycosmonaut,26,Wed Jun 24 23:51:59 2015 UTC,Go.
haskell,3awgj1,cyrusol,3,Wed Jun 24 04:27:00 2015 UTC,Search for golang.
haskell,3awgj1,TumbleSteed,12,Wed Jun 24 05:28:15 2015 UTC,"stack haskell   I'm a fairly drunk, but if we're being contrarians, I want to be a part of this get together."
haskell,3awgj1,kqr,1 point,Wed Jun 24 05:33:41 2015 UTC,3/10 relevant hits when searching for that.
haskell,3awgj1,theonlycosmonaut,1 point,Wed Jun 24 12:19:25 2015 UTC,I do. I was just snarking!
haskell,3awgj1,BethAr,7,Wed Jun 24 06:02:05 2015 UTC,"I agree with this. It is not only difficult to search for stack in general, it is also difficult to search for it within a Haskell context. It is such a common word in programming.  Would the guys at FPCO reconsider the name? Good naming is not superfluous, look at the difficulties new people have with Cabal ""the Library"" and cabal-install."
haskell,3awgj1,snoyberg,10,Wed Jun 24 04:01:27 2015 UTC,"Actually, it's not a name any of us at FP Complete came up with, it was /u/ndmitchell. But I did some tests initially, and if you search for ""haskell tool stack"" you get pretty good results."
haskell,3awgj1,Jurily,2,Wed Jun 24 04:59:06 2015 UTC,But first you have to search for the correct search term.
haskell,3awgj1,BethAr,1 point,Wed Jun 24 13:48:31 2015 UTC,"Ok, that's fair, the results are indeed meaningful."
haskell,3awgj1,enigmo81,3,Wed Jun 24 17:01:06 2015 UTC,"The tooling work we we did over the years on a shake based build tool (shake-install) was going to be renamed hake... until stack came out and hopefully made it irrelevant. But I thought it was a good name and a bit clever:   Haskell Make Hake is a fish similar to Haddock (the Haskell documentation tool) 4 easy to type characters, alternating between hands https://hake.io was available :-)"
haskell,3awgj1,BethAr,2,Thu Jun 25 14:40:15 2015 UTC,"hake is not bad, it is certainly more particular to Haskell than stack, but after the suggestion of caballero, I wouldn't wish for anything else."
haskell,3awgj1,baguasquirrel,5,Thu Jun 25 22:06:44 2015 UTC,"Maybe ""stack build tool""? I'm feeling lucky worked for me there."
haskell,3awgj1,sambocyn,10,Wed Jun 24 05:02:23 2015 UTC,STACKs That Aren't Cabal m'Kay?  my attempt at a recursive acronym.
haskell,3awgj1,literon,5,Wed Jun 24 08:52:53 2015 UTC,"That has SBT as acronym, and I doubt we want people to relate it to the Simple Build Tool of Scala."
haskell,3awgj1,baguasquirrel,3,Wed Jun 24 07:11:45 2015 UTC,"On a somewhat tangential note... is ""stack"" supposed to be ironic? I was under the impression that Haskell didn't have a stack in the traditional sense, that it had thunks that executed. Serious question."
haskell,3awgj1,theonlycosmonaut,17,Wed Jun 24 05:00:44 2015 UTC,"I think the stack here refers to your 'technology stack' as exemplified in abbreviations like the LAMP stack (linux/apache/mysql/php). What layers of technology do you have stacked on top of each other to create your solution?  ...I just realised it's probably actually a reference to stackage, which was a pun on hackage, which was a pun on package, for which we definitely do not have a manager. Ah, software."
haskell,3awgj1,TimTravel,5,Wed Jun 24 06:05:35 2015 UTC,"...I just realised it's probably actually a pun on stackage, which was a pun on hackage, which was a pun on package, for which we definitely do not have a manager. Ah, software.   Huh."
haskell,3awgj1,alt_account10,2,Wed Jun 24 07:33:25 2015 UTC,"I'll relate you what /u/theonlycosmonaut wanted to say, in reverse:   for which we definitely do not have a manager   Haskell does not have a package manager, cabal ain't one.   hackage, which was a pun on package  stackage, which was a pun on hackage"
haskell,3awgj1,tejon,1 point,Wed Jun 24 18:44:29 2015 UTC,for which we definitely do not have a manager   Full disclosure: I lol'd.
haskell,3awgj1,Peaker,6,Wed Jun 24 18:14:25 2015 UTC,"As a tangent, GHC does use a stack (as evident by the infamous ""Stack overflow"" errors that used to happen before they made the stack grow indefinitely). It's just not a traditional call stack."
haskell,3awgj1,Enamex,6,Wed Jun 24 06:18:10 2015 UTC,So does this now come recommended for beginners instead of cabal?
haskell,3awgj1,Crandom,6,Wed Jun 24 09:01:05 2015 UTC,I would recommend it. My friend I've being trying to get to use haskell as had way more success with stack than cabal.
haskell,3awgj1,Enamex,6,Wed Jun 24 10:24:11 2015 UTC,"Sooo, a noob tutorial is on order, I'm guessing? Please? (Assume we know practically nothing about using cabal-the-tool...)"
haskell,3awgj1,codygman,2,Wed Jun 24 18:28:19 2015 UTC,"I decided to use stack on a project for the first time today, here is what I did:  cabal init # if you don't have a cabal file yet stack init stack build   From their you can choose to develop with 'stack ghci' or install with 'stack install'."
haskell,3awgj1,emarshall85,2,Thu Jun 25 01:38:59 2015 UTC,May have missed it do we finally have an uninstall command? It's always felt odd to have to ghc-pkg unregister and remove binaries manually.
haskell,3awgj1,eegreg,1 point,Thu Jun 25 00:27:49 2015 UTC,not yet https://github.com/commercialhaskell/stack/issues/361
haskell,3awgj1,emarshall85,5,Thu Jun 25 16:59:12 2015 UTC,"How do I get extra build tools?  stack will automatically install build tools required by your  packages or their dependencies, in particular alex and happy.   Nice.   I'm still a bit dubious about (seemingly) being forced to use stackage to  use this. Last time I tried (about a month ago), I had trouble building packages that worked just fine with cabal sandboxes. I probably could have fixed them by using a stack.yaml with extra-deps, but that seems like a step in the wrong direction, in particular because it wouldn't (appear to) allow version ranges.  update: As I was typing this, I read the FAQ. I'll update this comment if that turns out to give me what I want.  another update:  I was able to set the following in ~/.stack/stack.yaml:  package-indices:     - name: Hackage       download-prefix: http://hackage.haskell.org/packages/archive       http: http://hackage.haskell.org/packages/archive/00-index.tar.gz   By using hackage, I lose out on:    git-based indexes, which should update faster by only updating incrementally. signed packages   However, I (hope) I know don't have to bother with extra-deps in a local stack.yaml, and can simply use PVP to sort out dependency constraints. The reason I'm so adverse to extra-deps is that it feels much like a requirements.txt file in python with hard-coded version numbers, which means (presumably) that I lose out on the ability to stay in sync with non-breaking version changes upstream.  yet another update: I still get pegged with an lts resolver when using stack new, despite having resolver: ghc-7.10 in ~/.stack/stack.yaml. I really hope this is a configuration issue or bug, rather than vendor lock-in.  last update (I think): resolver is specified at the project level. Feels like I should be able to specify a global default though. Visiting the stack issues page...  Using hackage is apparently a bad idea. Presumably, I could use both stackage and hackage, but looking at the default hack.yaml, it seems stackage overloads the name ""Hackage"". I suspect that can be over come, but given that stuff ""just works"" for me right now with cabal-install and was supposed to ""just work"" what hack, I'm not inclined to try. So really, there doesn't seem to be a clear migration path from cabal-isntall to stack unless you're willing to stay within their ecosystem (LTS/Nightly) + stackage, which doesn't seem to be (at the moment) as current as regular hackage. Back to cabal-install I go..."
haskell,3awgj1,snoyberg,5,Wed Jun 24 09:05:27 2015 UTC,"Perhaps some clarifying points will help here:   Stackage in no way replaces Hackage. Hackage is a set of package name/version combinations correpsonding to tarballs. stack uses Hackage's definitions, but instead of going directly to Hackage, uses a mirror on S3 (and a Git repo by default instead of the tarball). You can swap that for hackage.haskell.org if you'd like (as you showed above), and everything will work just fine. stack has a philosophy of explicit rather than implicit dependency tracking. Mathieu has a blog post coming out soon explaining why this is a powerful feature, but in short: all of our tooling can be smarter if it's not constantly trying to guess a build plan stack fully supports the cabal-install approach of dependency solving. You just have to do it as an explicit rather than implicit step. Just run rm -f stack.yaml && stack init --solver. It's not the default behavior since experience has shown LTS Haskell to be a better default for most people, but it's a fully supported workflow."
haskell,3awgj1,emarshall85,8,Wed Jun 24 10:05:07 2015 UTC,"Thanks for the reply.    all of our tooling can be smarter if it's not constantly trying to guess a build plan   Shouldn't that be ""dumber"", since not having to guess a build plan means one less thing to think about? Your comment also doesn't address my other concern:   I lose out on the ability to stay in sync with non-breaking version changes upstream.   Maybe Mathieu's up coming blog post will convince me otherwise, but at the moment, this seems like more of a hinderance than a benefit. Even Elm seems to be able to deal with version constraints without having to explicitly pin down version numbers."
haskell,3awgj1,mboes,6,Wed Jun 24 10:51:29 2015 UTC,Posted.
haskell,3awgj1,conklech,2,Wed Jun 24 17:17:53 2015 UTC,That's a very helpful and constructive article; I see someone else submitted it for /r/haskell comments here.
haskell,3awgj1,emarshall85,1 point,Wed Jun 24 17:58:46 2015 UTC,Thanks. Reading this now.
haskell,3awgj1,snoyberg,5,Wed Jun 24 21:49:39 2015 UTC,"Shouldn't that be ""dumber"", since not having to guess a build plan means one less thing to think about?   What I mean is that commands like stack test are able to automatically install dependencies, since it already knows what the right thing to do is. In a world without an explicit dependency choosing step, each action can potential break everything, because you have the potential for a brand new plan to be chosen.  I'd recommend actually trying out the approach I mentioned, I don't think in practice it is much of a hinderance at all. In fact, with the following alias I think you get almost identical behavior to what you have with cabal:  alias update='stack update && rm -f stack.yaml && stack init --solver'   All of this is of course based on the premise that automatically choosing new build plans because something changed on Hackage is a good thing, which I'm not a subscriber to."
haskell,3awgj1,emarshall85,3,Wed Jun 24 11:06:01 2015 UTC,"Thanks. I'll probably give stack's native nightly a go (as I want ghc 7.10.1) and see what happens. Last time I did, it wasn't pretty, but that was weeks ago, so maybe things have shaped up."
haskell,3awgj1,snoyberg,5,Wed Jun 24 11:25:30 2015 UTC,"If you get some unpleasant results, please report them. stack is designed to handle just about all Haskell dev use cases, so if it's giving you trouble, it's something we should try to address."
haskell,3awgj1,conklech,7,Wed Jun 24 11:28:35 2015 UTC,"please report them   It's also worth noting that /u/snoyberg and the others involved in this project are very active, responsible, and constructive on their issue trackers. As the kids say: ""+1 would report issue again"""
haskell,3awgj1,andrewthad,5,Wed Jun 24 16:41:06 2015 UTC,I can also confirm that this is true.
haskell,3awgj1,ozgurakgun,6,Wed Jun 24 17:05:33 2015 UTC,The only good thing about cabal was its name. Goodnight sweet prince.
haskell,3awgj1,eegreg,1 point,Wed Jun 24 12:54:16 2015 UTC,"I am trying stack at the moment, and it seems to install executables inside ~/.local/bin by default. Two questions: 1) Why is this a sensible default? 2) How can I override it?"
haskell,3awgj1,ozgurakgun,1 point,Thu Jun 25 11:04:10 2015 UTC,https://github.com/commercialhaskell/stack/issues/342
haskell,3awgj1,eegreg,1 point,Thu Jun 25 16:58:18 2015 UTC,"So, it is ""in progress""? I did come across that thread before asking the question but couldn't quite understand what the decision was.  Thanks for responding."
haskell,3axg4u,raguay,9,Wed Jun 24 07:36:01 2015 UTC,"For those who, like me, had never heard of Jade before: Jade is a template language (as in HTML templates, not Template Haskell) for node.js.  (hmm, there are many things I've never heard of these days. I guess I only stay current on Haskell-related news...)"
haskell,3axg4u,gelisam,3,Wed Jun 24 12:20:44 2015 UTC,"After a quick look, I don't see any jade converter in hackage. You are probably better off adding a generation step in your build and just use node/go tools. Unless you want to write your own parser/generator."
haskell,3axg4u,sbergot,4,Wed Jun 24 13:47:47 2015 UTC,"I didn't find anything for Jade, but hamlet seems pretty close (in spirit anyway)."
haskell,3axg4u,emarshall85,1 point,Wed Jun 24 09:55:13 2015 UTC,"I looked at hamlet, but it is a templator. Jade is more of a shorthand for html. Similar to Sass is for CSS. I saw questions about making a parser in Haskell for a Jade interpreter, but I can not find if that person was successful or not."
haskell,3axg4u,emarshall85,4,Thu Jun 25 05:59:28 2015 UTC,"I'm not sure I understand. After all, the jade homepage even calls Jade a templating engine.   If you're just wanting to run some code through a preprocessor that outputs HTML, seems like you could just stick with Jade. If you're wanting to go all Haskell, seems you can either write a parser for Jade yourself or write a small one off to something like hamlet (mentioned above), or lucid.  This is what the Jade example would look like in Lucid (with a bit of help from raw-strings-qq):  {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE ExtendedDefaultRules #-} {-# LANGUAGE QuasiQuotes #-}  import Lucid import Text.RawString.QQ  index pageTitle youAreUsingJade = renderToFile ""index.html"" $ do     doctypehtml_ `with` [lang_ ""en""] $ do         head_ $ do             title_ pageTitle             script_ [type_ ""text/javascript""]                  [r|if (foo) {                        bar(1 + 5)                    }                 |]       body_ $ do           h1_ ""Jade - node templating engine""           div_ [id_ ""container"", class_ ""col""] $ do               if youAreUsingJade                   then p_ ""You are amazing""                   else p_ ""Get on it!""           p_ [r|Jade is a terse and simple                   templating language with a                    strong focus on performance                   and powerful features.                |]  main = index ""Jaee"" True"
haskell,3axg4u,emarshall85,3,Thu Jun 25 15:52:48 2015 UTC,"Or in hamlet (In a separate file. Alternatively, with a quasiquoter):  $doctype 5 <html lang=""en"">     <head>         <title>#{pageTitle}         <script type=""text/javascript"">             if (foo) {                 bar(1 + 5)             }      <body>          <h1>Jade - node template engine          <div id=""container"" class=""col"">          $if youAreUsingJade              <p>You are amazing          $else              <p>Get on it!          <p>              Jade is a terse and simple              templating language with a               strong focus on performance              and powerful features.   I rendered using this:  {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TemplateHaskell #-}  import Text.Hamlet (hamletFile) import Text.Blaze.Html.Renderer.String (renderHtml)  template pageTitle youAreUsingJade = $(hamletFile ""template.hamlet"")  main = putStrLn $ renderHtml $ template (""Jade"" :: String) True """"   I'm sure it's not 100% right, but the output is corect (though for this I output to stdout instead of a file, which would be a trivial change)."
haskell,3axg4u,emarshall85,1 point,Thu Jun 25 16:34:09 2015 UTC,"These are great as a templating solution. But, I do not want to translate my 100+ jade files to another form. The jade files are formatted as an example:  h3 Alfred Tutorials  mixin article($title, $link, $excerpt, $date)     div.entry         div.tutorial_wrap             div.tutorial_div                 a[href=$link]                     h3 #{$title}                 h5 #{$date}                 p.tutorial_excerpt #{$excerpt}     div.clear   +article(""Running Automator and AppleScripts in Bash"", ""/posts/tutorials/Alfred/Running-Automator-and-AppleScripts-in-Bash"", ""Learning to run Automator and JavaScript for Automation scripts in Alfred."", ""November 14, 2014"") +article(""Optimizing PHP for Scripts"", ""/posts/tutorials/Alfred/optimizing-PHP-for-Scripts"", ""Get PHP to run faster!"", ""November 12, 2014"")   As you can see, this is much different than the formats given above. Also, I was wanting to compare my current go version with the Haskell version. If I pre-process it, it would not be a fair comparison."
haskell,3axg4u,tWoolie,1 point,Fri Jun 26 09:00:38 2015 UTC,"Which is why I mentioned just continuing to use jade. If you're just using it as a preprocessor to output html files then you could just add jade to a Makefile (or grunt, or Install.hs) and be done with it. No conversion necessary.  Failing that, your best bet is to write a parser yourself (which you don't, from your other comments seem opposed to)."
haskell,3ax6wd,conradparker,4,Wed Jun 24 05:42:37 2015 UTC,This is quite the type tetrising achievement.  Well done to whoever managed this. I've actually wanted this in the past for snap streaming and ended up just using the iterator interface.   Edit: it was Patryk! That makes sense.
haskell,3ax6wd,christian-marie,1 point,Wed Jun 24 22:36:30 2015 UTC,I know right. I tried doing this awhile back and my brain melted trying to get it to typecheck.
haskell,3ax6wd,jb55,3,Thu Jun 25 15:57:00 2015 UTC,Documentation is very broken. Hi Conrad :)
haskell,3ax6wd,manpacket,2,Wed Jun 24 06:44:13 2015 UTC,Aren't enumerators deprecated in favor of conduits?
haskell,3ax6wd,Peaker,7,Wed Jun 24 06:24:42 2015 UTC,"or in favor of pipes, depending on whom you ask :)"
haskell,3ax6wd,gclichtenberg,1 point,Wed Jun 24 16:39:25 2015 UTC,"Customary to ask the deprecator, I think :)"
haskell,3ax6wd,Peaker,3,Wed Jun 24 18:52:56 2015 UTC,There doesn't seem to be any way of deducing the reason or even the date of deprecation from the Hackage material. Where is it discussed?
haskell,3ax6wd,michaelt_,2,Wed Jun 24 19:44:07 2015 UTC,I think the motivation for this is being able to use pipes with the snap framework.
haskell,3ax6wd,jystic,2,Thu Jun 25 01:02:39 2015 UTC,Won't be good for much longer then - as that's moving to io-streams!
haskell,3ax6wd,ocharles,1 point,Fri Jun 26 13:26:31 2015 UTC,"I'll be pretty excited when that actually happens, been on the cards for a while now, I appreciate these things take time though :)"
haskell,3ax6wd,jystic,1 point,Tue Jun 30 04:16:10 2015 UTC,"Yes, the whole point was to get snap working with pipes, although progressing deprecation of iteratees was a welcome bonus!  We're using snap to stream pretty significant amount of data (2TB+) and waiting for io-streams to materialise simply isn't an option when you're paid a daily rate to do it :)"
haskell,3aufaj,alexander_b,40,Tue Jun 23 16:25:42 2015 UTC,"I think he's totally right that using a truly pure language is best. And his argument is explicitly to language designers, and I think it's totally on-point there.  But for practitioners, it's complete rubbish. If I'm forced to write code in an imperative language, then it is definitely better to try to write pure functions than to completely ignore the idea of purity. Many people who know Haskell but work in other languages would agree"
haskell,3aufaj,radix,7,Tue Jun 23 17:09:17 2015 UTC,"I am not trying to be an ass, but I think the idea is 'get more people to stop using impure languages' or 'design more pure languages'.  The glass half full half empty argument is the same argument over and over, given a max and a min you can always compare one relative to the other. It's not really the argument that counts, it's what people do after they listen to it.   If I'm forced to write code alone, then purity is no problem. If I have to write code with other people without the future having already been written into the past, then we are all guessing what the other one is going to do, and in the midst of development, lots of things can still be up in the air over what is considered a side effect and what isn't, depending on the complexity of the project."
haskell,3aufaj,radix,19,Tue Jun 23 17:21:39 2015 UTC,"Yeah, I just have this paranoid fear that imperative programmers will skim this article and say ""welp, that saved me from having to bother with functional programming!""."
haskell,3aufaj,jhoxray,7,Tue Jun 23 17:29:26 2015 UTC,"I was thinking recently about the approaches used to teach functional programming and I think we are doing it all wrong from the start (based on my own experience). Most of Haskell learning is either:   Take imperative approach and try to lure typical imperative thinking into functional. Starts with ""Hello world"", ghci calculator, list manipulations etc and then progresses to the dreaded Monads, arrows etc Very formal abstract math based syntax description etc.   I think there's actually huge issues with both - 1st one forces you to try to connect your imperative patterns with something similar in Haskell and you fail miserably - steep learning curve, trouble with monads etc etc. 2nd is only useful for people with very strong math (= category theory) background.  However, I had an ""enlightenment"" moment after catching up on some semi-popular category theory (goes really easy if you had some math in school and remember what a Group & Ring is after reading in wikipedia) reading and then telling myself to forget ALL the imperative thinking and simply following very logical and beautiful Category -> Functor -> Monad hierarchy.  Which made me thinking - 1st way of teaching is probably necessary evil for the current programmers, but should really really be discouraged for NEW programming teaching. Instead, we should find ways to have popular explanations of the Category theory as early as kids in high school (I believe it is quite possible) and make links into Haskell / functional programming from there and almost NOT teach imperative at all. Type of thinking patterns are completely different and trying to build links between them is counterproductive."
haskell,3aufaj,radix,8,Tue Jun 23 18:07:32 2015 UTC,Julie and Chris's new Haskell book is actually starting off with lambda calculus in the first chapter. I think that's pretty cool. :) http://haskellbook.com/images/sample.pdf
haskell,3aufaj,conklech,1 point,Tue Jun 23 19:32:23 2015 UTC,"That book looks generally interesting. I find their comment about spaced repetition and iterative deepening interesting; many of us are deeply inclined to think and write ""from first principles,"" which is probably pedagogically unsound."
haskell,3aufaj,chrisdoner,16,Tue Jun 23 21:26:13 2015 UTC,"welp, that saved me from having to bother with functional programming   I'm not sure people with that attitude would be motivated to spend time learning it anyway."
haskell,3aufaj,radix,11,Tue Jun 23 17:39:58 2015 UTC,"Caveat: I am liable to take this personally since I have put a lot of effort into bringing pure FP to imperative/OO programmers (Effect, multiple talks , Sumtypes). I totally agree that we need to be bringing more people to enforced pure FP, but I very strongly think that bringing the pure FP to them is a step in the right direction.  edit: by ""this"", I meant Erik's rant against FP-in-imperative-languages, not your comment  I only take issue with Erik's rhetoric, not with his intent. And I think they're inconsistent. The introduction lambasts the middle ground, but then the rest of the article is all about how you should have strictly enforced pure FP. That's not an argument against the middle ground, it's completely on the side of enforced pure FP. I agree with bringing strictly enforced pure FP to everywhere. I don't agree with ""The slightest implicit imperative effect erases all the benefits of purity, just as a single bacterium can infect a sterile wound"".  To kind of respond to what you actually said ;-) I find Erik's early rhetoric to be damaging to the advocacy of FP to the masses of programmers. In fact, Haskell has long been a source of great ideas introduced to other languages, and as that has continued, so has Haskell's own popularity."
haskell,3aufaj,chrisdoner,7,Tue Jun 23 19:22:45 2015 UTC,"I generally find Erik is inconsistent with his opinions on FP, it's hard to know where he stands from one month to the next."
haskell,3aufaj,keithb,5,Tue Jun 23 21:14:05 2015 UTC,"I find that his position is very consistent: no-one else's context matters, Erick's world is the definitive exemplar of programming.   The specialisation of that to particular cases varies from time to time, of course, depending on who's concerns he needs to dismiss this week."
haskell,3aufaj,augustss,1 point,Tue Jun 23 21:27:36 2015 UTC,"You have to understand that Erik wants to shock people, so he changes what he says to be the most upsetting for his audience."
haskell,3aufaj,tomejaguar,1 point,Wed Jun 24 08:48:17 2015 UTC,"I think he just likes to continously, but gently, troll."
haskell,3aufaj,conklech,3,Wed Jun 24 05:39:07 2015 UTC,I dunno; they sound sufficiently lazy that they could be convinced!
haskell,3aufaj,conklech,6,Tue Jun 23 18:54:47 2015 UTC,"In all seriousness, my personal laziness was and is a huge factor in my affection and dedication to Haskell and the Haskell community. I'm a lawyer, not an engineer; no other language or community that I know of enables me to do as much interesting programming with as little attention to irrelevant bullshit (to use a technical legal term, sorry) and ""debugging."""
haskell,3aufaj,radix,6,Tue Jun 23 19:34:06 2015 UTC,"I can't really comment with any kind of stance, after I started doing functional programming everything clicked together so much more elegantly. It just makes sense, but that's to me.   I can't really look at it from the perspective of an imperative programmer, aside from wanting to get things built step by step, without always knowing confidently whether each step will work. I use that methodology for building some things still, so it's good for navigating some kinds of problem solving territory, but I can't really say whether one is better over the other, and who it's better for, if that question even has an answer definitively.   I don't think anyone should have to learn anything, if it's hard to learn and hard to reason about for the individual, then maybe there is a good reason for that. Maybe it's just so counter-intuitive to how they know how to reason, that learning it would actually make them less effective at their craft. I can't really say I have opinions on it.   I mean the biggest reason I like functional programming is because it's cool. It's cool how things fit into other things, and it's cool to abstract things and make new things and invent layers of things. But imperative programmers do that too to some degree (since I can still read their code), I just don't really know how it feels to build things that I consider cool or well designed in an imperative language.   This is more the side of programming I think about, all the stuff that makes me make the decisions I do, without me always being aware of why I make those decisions. It was linked recently on hackernews or proggit about programming and superstition, and I don't like doing things out of superstition, so I don't really think it's fair to cover purely functional languages with a blanket of pristine aesthetic beauty and determine the question answered once and for all.     Semi-apologies for the tangential deviation."
haskell,3aufaj,keithb,2,Tue Jun 23 17:43:25 2015 UTC,"I guess the only thing I have to say in response to this is that I disagree about there being no concrete and direct benefits to functional programming. Reasoning is, well, possible with pure FP."
haskell,3aufaj,sclv,1 point,Tue Jun 23 19:24:34 2015 UTC,"Reasoning is, well, possible with pure FP.   In the very narrow sense of “reasoning” that people who make this claim seem to mean (what is that you think C++ programmers do? examine chicken entrails? roll dice? and yet the world is equipped with many working C++ programs) that's certainly a difference. Showing that the difference, and what you have to go through to get it, is a net benefit I have not seen done."
haskell,3aufaj,keithb,2,Tue Jun 23 22:45:09 2015 UTC,"s/reasoning/local reasoning/ and the statement makes more sense.  In a pure context, you only have to consider the things ""around"" a chunk of code to know the entirety of how that code operates.  In a context with unrestricted mutation, ""spooky action at a distance"" is possible and one needs to consider the state space of the ensamble of code throughout the program."
haskell,3aufaj,tomejaguar,0,Wed Jun 24 00:15:25 2015 UTC,"Yes, I know very well what /u/radix means by “reasoning”—now show under what circumstances this is a net benefit to the programmer, given what has to be done, and what given up, to gain that facility. Haskell advocates talk as if having this facility is obviously an unalloyed, all-conquoring good in all circumstances, without further discussion."
haskell,3aufaj,keithb,3,Wed Jun 24 06:11:13 2015 UTC,"keithb.  We get it.  You are irritated by Haskell and you are irritated by Haskellers.  However, this is a Haskell forum for people interested in Haskell so they are allowed to be somewhat informal when it comes to talking about Haskell here.  I would like to cordially suggest you rethink your confrontational, negative, moany attitude.  You are treading very close to trolling territory."
haskell,3aufaj,sclv,-1,Wed Jun 24 12:39:59 2015 UTC,Bear in mind that I once paid for my software engineers to do a haskell course because I thought it would be good for them.   What I mainly am is disappointed with haskell and haskell advocacy. Both could be so much better.
haskell,3aufaj,swaggler,2,Wed Jun 24 13:11:34 2015 UTC,"If you know well what he meant by reasoning, then why did you ask a question that indicated otherwise? I didn't intend to get into an argument with you and I don't want to get suckered into one -- I tried to be helpful and clarify things. In response, I got a blast about how I didn't make  a case about why this is a ""net benefit"" etc.  I wasn't acting as a ""haskell advocate"" here or whatever, just a participant on a discussion trying to clarify some terminology. If you don't need that terminology clarified, good."
haskell,3aufaj,Tekmo,2,Wed Jun 24 15:03:04 2015 UTC,"The ""haskell is persecuting me!"" complex is tired."
haskell,3aufaj,radix,2,Thu Jun 25 11:20:18 2015 UTC,/u/radix probably means equational reasoning
haskell,3aufaj,kuribas,1 point,Wed Jun 24 00:29:03 2015 UTC,"yes, pardon my own rhetoric :)"
haskell,3aufaj,Tekmo,1 point,Wed Jun 24 01:04:16 2015 UTC,"I think people miss the point of the article.  He is not claiming that imperative programming is inherently evil, just that it isn't the right model when dealing with parallelism, concurrency and big-data.  And that a mostly functional model is still an imperative model with all the drawbacks of an imperative model."
haskell,3aufaj,AndrasKovacs,29,Fri Jun 26 11:11:14 2015 UTC,"I think a lot of people don't understand Erik Meijer's target audience.  He's not addressing people who desire to program using as much purity as possible.  He's targeting people who have become complacent, thinking that their limited brand of purity is good enough for all practical purposes.  These people often advise others against even more pure alternatives like Haskell because they believe that the extra purity is ""not worth it""."
haskell,3aufaj,jerf,10,Tue Jun 23 18:44:54 2015 UTC,"I found this article largely unconvincing when it was published. It's one thing that one can use impurity to introduce more impurity, but people generally don't try to undermine the language they're working in, or they only try to do this when they're newbies coming from another language/paradigm. The same thing applies to Haskell, with unsafePerformIO etc.   We could instead talk about sound principles of language design, and it's indeed plausible that shoehorning purity annotations into an otherwise wildly impure language might be just too unwieldy and not very practical. But that's only tangentially related to whether incrementally more functional code yields incremental maintainability and correctness, which I think is the case (see e. g. Carmack's article).  If I wanted to be a bit snarky here, I could construct an analogous argument with respect to Haskell's type system: Haskell's ""mostly functional"" style clearly doesn't work; since every type is inhabited by bottom, static guarantees don't actually guarantee anything, and the type system is useless as a tool for reasoning about programs."
haskell,3aufaj,AndrasKovacs,11,Tue Jun 23 18:02:00 2015 UTC,The snarkiness of your last paragraph would be much greater if we didn't seriously see that argument made with some frequency and varying levels of seriousness in /r/haskell.
haskell,3aufaj,pigworker,6,Tue Jun 23 18:33:26 2015 UTC,"I'm personally all for total programming too, BTW, it's just the exaggerated purist disposition that I disagree with."
haskell,3aufaj,AndrasKovacs,4,Tue Jun 23 18:50:27 2015 UTC,"It's just distressing to see people arguing over what the deal (puritywise) should be, globally, when the point is that the deal can be documented accurately and renegotiated locally."
haskell,3aufaj,capitalsigma,1 point,Tue Jun 23 21:49:43 2015 UTC,"To be completely precise here, I'm agree with your point (because I am a fan of your work and have some idea of what your points tend to be) and the disposition I disagree with (the one expressed in the article) is that somewhat pure and somewhat functional solutions are useless, because I think they are useful and better than nothing."
haskell,3aufaj,keithb,1 point,Tue Jun 23 22:40:03 2015 UTC,"In fact, Bob Harper said the same thing."
haskell,3aufaj,TimTravel,-2,Mon Jun 29 14:00:07 2015 UTC,"My objection to the haskell type system is that it isn't nearly strong enough. Since I don't make my living by solving data structures and algorithms homework problems the constraints that it can express aren't super useful to me and the constraints that would be useful to me it can't express. And my objection to the rhetoric surrounding haskell's type system is that if the people spouting it really believed what they were saying they would immediately abandon haskell for a language with a stronger type system. Doubly annoying is that they don't recognise that the very reasonable reasons why they don't do all their work in, say, agda, are pretty much the same reasons that I don't do all my work in haskell."
haskell,3aufaj,keithb,2,Tue Jun 23 21:33:02 2015 UTC,"And my objection to the rhetoric surrounding haskell's type system is that if the people spouting it really believed what they were saying they would immediately abandon haskell for a language with a stronger type system. Doubly annoying is that they don't recognise that the very reasonable reasons why they don't do all their work in, say, agda, are pretty much the same reasons that I don't do all my work in haskell.   This is an interesting argument. It's a matter of where you draw the line of how much efficiency you're willing to trade in exchange for compiler guarantees. I find Haskell helps me catch many bugs that would be more difficult to find in other languages, so I like it. Programming is at least 3/4 debugging so it's natural to optimize for that case."
haskell,3aufaj,TimTravel,2,Wed Jun 24 06:41:53 2015 UTC,"programming is at least 3/4 debugging    Is it, though? My industrial experience is in a tradition of dynamic (or weak static) typing with intensive automated testing and I do very little debugging, certainly not anything like 45 minutes in an hour of programming, or 6 hours in an 8 hour day.   And, I've found that haskell like won't let me say what I need to say in the type system so I end up writing tests anyway."
haskell,3aufaj,keithb,2,Wed Jun 24 08:27:39 2015 UTC,"For small programs where you sort of find out what you want it to do as you write it, you have to constantly change your test cases as you change your code functionality. The more likely it is that the compiler can catch bugs, the less important test cases are.  Maybe it's a question of definitions? I count everything from testing for a bug and fixing it as ""debugging"". The significant majority of my time is spent debugging for nontrivial programs. I haven't taken statistics on how much. There are many times when I program where there is an error which would be clearly labelled by a strict compiler."
haskell,3aufaj,Oremorj,3,Wed Jun 24 09:04:14 2015 UTC,"For small programs where you sort of find out what you want it to do as you write it, you have to constantly change your test cases as you change your code functionality.   This is not my experience. I have worked on multi-year efforts accumulating many person-decades of programming effort with intensive automated testing as a primary quality and design tool. What I've seen is that there is a leading edge of tests that change frequently, and then less frequently and then become part of an ever-growing and largely static body of regression tests.   I count everything from testing for a bug and fixing it as ""debugging"".    Me too, although I prefer to talk about diagnosing a failure and fixing the underlying defect. And in the teams that I've seen that use intensive automated testing as a primary design and quality tool there just isn't very much of that. And nothing remotely like 75%."
haskell,3aufaj,balefrost,2,Wed Jun 24 10:11:35 2015 UTC,"You still have to count the total effort spent writing and maintaining those tests, though. Otherwise you're just talking about completely different things and the comparison becomes totally invalid.  IME, Haskell code tends to require a lot fewer tests than equivalent Java/Python/etc. code. Of course a big factor here is the absurdly high level of abstraction in Haskell -- which means that a lot of what is pure boilerplate in other languages is extrinsic to the ""interesting"" bits of the program in Haskell -- and so you can test the ""interesting"" bits without having to worry about all that incidental complexity. YMMV."
haskell,3aufaj,TimTravel,1 point,Wed Jun 24 11:29:28 2015 UTC,"I count everything from testing for a bug and fixing it as ""debugging"".   I like it. ""What are you doing to those metal burrs?"" ""I'm deburring.""  ""What are you doing to those implementation bugs?"" ""I'm debugging."""
haskell,3aufaj,balefrost,1 point,Wed Jun 24 11:38:04 2015 UTC,I don't get it.
haskell,3aufaj,AndrasKovacs,2,Wed Jun 24 12:19:40 2015 UTC,"Deburring is an actual process used in metalworking. After working a piece of metal, there are often rough metal ""burs"" that need to be removed. You use a deburring tool to remove these burs.   I think most people would define ""debugging"" as ""using a debugger"". You seem to indicate that you consider debugging to be the whole process... from finding the bug through fixing it.   Your definition of debugging seems similar to the definition of deburring, which I like."
haskell,3aufaj,keithb,2,Wed Jun 24 12:26:03 2015 UTC,"I do a lot of work in Agda, but the reason I don't write executable software in Agda or Coq is because they are just massively impractical for that purpose, as they are. It would be great if we had a language with a powerful type system and strong support for software development. We don't have it."
haskell,3aufaj,conklech,2,Tue Jun 23 22:33:14 2015 UTC,"No, we don't. And haskell certainly isn't it. Do a s/Agda/haskell/g on your comment and you've got a pretty close statement to how I and many of the serious-minded practitioners of software development that I know feel about haskell. We'd love it (or something  a lot like it) to be the answer, and it just isn't."
haskell,3aufaj,BethAr,1 point,Wed Jun 24 06:11:50 2015 UTC,"This isn't much of an argument. Haskell has a sizable and active industrial/commercial community; a community of ""serious-minded practitioners."" It has tooling, a killer compiler, and a pretty broad library collection. Sure, the ""serious-minded practitioners"" you have in mind may not have much use for it, but you haven't said who they are, why they don't, and what you, I, or anyone else should do about it.  I really appreciated both sides of your conversation with /u/tomejaguar elsewhere in this thread, by the way. As he says, you've clearly got constructive ideas; I'd like to hear them."
haskell,3aufaj,phazer,1 point,Wed Jun 24 16:51:11 2015 UTC,"Oh please, I would argue that we use Haskell precisely because we are ""serious-minded practitioners"". If you tolerate working with the crap that is out there, I hardly think you are serious."
haskell,3aufaj,AndrasKovacs,1 point,Wed Jun 24 18:02:35 2015 UTC,Idris is trying to fill that void. Have you tried it?
haskell,3aufaj,ezekiel,1 point,Wed Jun 24 08:11:14 2015 UTC,"Yes, but it's not production ready. It has a lot of hard edges; to name just one issue which I think is crucial: type checking is unacceptably slow. I measured 3 seconds to check a 80 line source file on a fairly fast computer (Core i7 3770)."
haskell,3aufaj,clarkd99,7,Wed Jun 24 08:26:53 2015 UTC,"""Mostly functional"" programming does indeed work very well, at least when it is a combination of:   Top level function (""main"") that does nothing except call the other functions (or run the main loop) Many small pure functions (95% of the code) One or two small functions that do nothing except write (file, printer, network) One or two small functions that do nothing except read A few small functions that change properties of an object that is an input to the function.   This is not an attempt at duplicating Haskell style purity. This is an attempt to build a many-featured system from understandable, testable, self-contained components.  I've been ""mostly functional"" like this for ten years and it not only works, but is readable, maintainable, and performant."
haskell,3aufaj,balefrost,-25,Tue Jun 23 23:02:24 2015 UTC,"I am a language designer and your accolades for functional programming are ridiculous (I was thinking of the anti-spell from Harry Potter).  The language/database system I am creating has been written in C. It has many hundreds of ""purely functional"" functions (the same input always returns the same values). I have hundreds/thousands of functions that change only the object structure that is passed to it (OOPS anyone!). I have other functions that don't fall into either of these categories. Does this mean that C is functional? Object oriented? Partly functional? If I want lazy execution (I have a byte code interpreter in my program), I can delay any expression or function I want to any time I want it executed. Funny thing is, I appreciate my programs executing when they are told so, so I rarely invoke my right to lazy evaluation (values tend to take a lot less space than functions).  I can implement any level of ""undo"" I want, but I don't need that capability so it isn't included in my project yet (or never). I don't actually need to get rid of all the intermediate results because I have ""varying variables"" unlike ""immutable variables"" in Haskell. I can ""pass"" function pointers to other functions (higher order functions) but I only do so in a few special cases. I have implemented my own automatic memory manager (something like a GC but no global waits, pointer chasing or random pauses). I can't think of anything that can be done in Haskell that I can't do in just plain old C. Is C the ""God"" language? Did I also say I have created automatic multi core, concurrent execution with code that is exactly like single user code without any user level locks or any concurrency annotations in the programming language. I guess I don't need Haskell's immutability for concurrency after all.  All my global state is read only and available to all threads at all times. (Yes I mean in C. Once the threading starts the global data can't be changed because I say so.) The independent servers that run on concurrent threads have their own local memory managers and can change local state without any locks at all. Globally available functions have no side effects. All global resources have critical sections that make their code also mutable without any problems. My design minimizes the use of global resources or queues their requests and does the work asynchronously. Data can be passed from server to server using a message queue that can deliver millions of messages per second but most of the work is done concurrently at the local level.  I challenge your ""real world experience"" and your thesis that Mathematics should be the language that programs computers. Haskell was first made available in 1992, over 23 years ago, and according to Wikipeda, over 5,400 libraries and tools are available for Haskell programming. What language would be called a success that has more than 5,000 libraries of functions and not a single major program that was completely created in it? The only answer I know of is Haskell that was made and promoted by a group of publicly paid professors with next to no ""real world experience"" between them.  Purely functional programming is a small subset of the code that can be created in a language like C. Haskell should be compared to niche languages like APL or SmallTalk rather than real world languages like C, C++, Java, C# etc. If you are an academic and want to print a Fibonacci sequence, Haskell was made just for you.  I have completed over 1,000 programming projects (big and small) for over 65 different companies spanning 35 years. I have programmed in at least 20 languages for over 10,000 lines of code each and written 100,000's of lines of C and assembler. I designed and coded a language/database that sold over 30,000 copies in 1987 alone."
haskell,3aufaj,clarkd99,10,Wed Jun 24 00:20:38 2015 UTC,"I can ""pass"" function pointers to other functions (higher order functions)   But that's not what people usually mean when they say ""higher order functions"". A function pointer is only half of a closure, and higher-order functions without closures are of limited value. C++ functor objects are much better (and C++ lambdas are better yet), and since you usually use them via template instantiation, they're usually faster than function pointers, too.   I can't think of anything that can be done in Haskell that I can't do in just plain old C.   And from a computation point of view, everything you can do in C can also be done in Haskell. It's not about what you can or can't do, but about how you express what it is you are trying to do. Haskell makes it easy to see what parts of your codebase are effectful and which are not. Religious wars aside, statically typed languages allow you to lean on the compiler when refactoring; the type system guides you to correctness. Haskell kicks that up a notch.   Is C the ""God"" language?   No. No language is the ""God"" language. OK, maybe Lisp.   What language would be called a success that has more than 5,000 libraries of functions and not a single major program that was completely created in it?   Depends on what you mean by major. It's definitely used in industry. For example, XMonad might not be super popular, but it is real software, written in Haskell, in a domain that is usually dominated by C and C++. To say that Haskell is only used for toy programs is being intentionally ignorant.    I have completed over 1,000 programming projects... (etc. etc.)   That is an argument, but it's a weak argument. You're saying ""I disagree with Erik's arguments, but rather than debate the technical merits directly, I'll just point out that I'm an expert."" Your expertise is impressive, and I'd love to hear more about your homemade programming language, but this paragraph is particularly grating.   Features from Haskell have been slowly bleeding over into more mainstream languages. C# has been gaining many of these. Even Java has recently adopted closures and lazy sequences. Haskell isn't successful because of how many business apps are written with it; it's successful because it's changing the landscape of programming languages. That's far more impressive, in my opinion."
haskell,3aufaj,balefrost,-10,Wed Jun 24 01:59:35 2015 UTC,"""Higher order functions"" are called that because they can be passed as a parameter to a function like a variable and you can do that in C. A closure is a group of variables and a function pointer. A structure and a function pointer in C. I never really mentioned C++ but I have read that templates are very slow to compile and execute.  I have built a SQL database into my language that is also fully OOPS. Do you know of a Haskell library that allows multi-million row, automatically indexed tables inside Haskell?  My interpreter compiles to ""polish prefix notion"" (Lisp) and that works very well for an execution engine but I wouldn't want to write source code in it! First saw Lisp in 1975 but I am glad it works for you.  If you think I am ""intentionally ignorant"", please look at the top 500 open source projects on Github and tell me how many are fully written in Haskell? Would I even be wrong if you even found 10? I don't mean Haskell on the front end and an outside database looking after all the data persistence and multi-user coordination on the back end. Please, show me just how ignorant I am.  I know that Eric got his Phd in the early 90's and taught as a professor in Holand until about 2000. He wanted ""real world experience"" and he then worked for about 7 years at Microsoft (there could have been another company in there for a few years). He has only recently been out consulting on his own for the last few years. Did you listen to his foul mouth rant about Agile programming last summer? I don't think Eric has ever looked over the shoulder of a secretary to make sure his UI was working the way he had imagined.  I say that Eric has no clue about the real world of programming and that his ""guru"" rep is not deserved. I would love to have a full blown debate about functional programming at whatever level he wanted. I think the style and substance of his public rants are over the top from someone that ""just hasn't been there"". He is a disgrace to all of us.  Most of the things that people toot as ""functional programming inspired"" are just new names for features that have been in many languages over the years. Haskell introduced very few band new things but it is a unique collection of features where Mathematical notation is emphasized along with immutable data. In my ""rant"", I spoke about global state that is immutable in my C project.  I have lots of very concrete arguments against the religious fervor of functional programming but the space limits me. Ask a direct question and I will reply."
haskell,3aufaj,clarkd99,1 point,Wed Jun 24 02:54:47 2015 UTC,Argument against fervor seems reasonable. What specific part of the FP mindset do you think is the most overhyped?
haskell,3aufaj,balefrost,0,Thu Jun 25 02:14:21 2015 UTC,I use immutable global data and pure functions in my C project. C is definitely not a functional language. Why do people insist on using either of these as evidence for the adoption of functional programming?  C also allows me to easily use mutable data and non pure functions whereas functional programming makes this harder but still possible (monads). The argument for functional programming should be why programming with a subset of tools is superior to a full set of tools. Pure functions can and have been normal functions in all programming languages since the late 1950's.  Functional advocates imply that Math like notation and concepts are inherently better than more traditional languages. I took APL in 1976 and loved it. It was totally unlike any other PL I had seen but it turned out to be useful in only limited problem domains. APL was very much about programming using Math. I have seen no arguments or empirical data to suggest that Math notation or concepts are better than the status quo. A PL is a very well defined description of the instructions a programmer wants executed. Why the need for Math syntax? This isn't a swipe at Math. I use anything from anywhere that benefits my programming and that includes Math.  Lazy execution is another one. I understand what it means. I could program it if I wanted in C. I have never had the need for it. I have never heard any good argument why mainstream programs would be better off using it for all computations.  I have much more if you are interested.
haskell,3aufaj,clarkd99,3,Thu Jun 25 14:17:02 2015 UTC,"The argument for functional programming should be why programming with a subset of tools is superior to a full set of tools.   I think this is at the crux. Your point, which seems correct, is that C lets you program functionally AND imperatively, so why not always use C (or a similar language)?  I think the FP proponent would say that ""less is more"". And it honestly can be. Take multithreading, which is a point that Erik was using. When data is mutable, sharing it becomes complicated. You can use locks, you can use lock-free data structures, or you can use some other kind of thing to ensure that the data is never corrupted or misread. But if you're willing to give up mutability, then sharing those immutable structures is trivial. And you can avoid antipatterns like defensive copying. And with immutable structures, you can implement other useful systems, like software transactional memory or persistent message queues. But you really have to give up mutability, and if you end up cheating (either accidentally or intentionally), you'll probably have a hard time tracking down the root cause.  Sure, you might personally be able to walk the fine line. You might have the discipline to never make mistakes. But in a team with developers of different skill levels, where the roster changes over time, and where not everybody can resist the urge to just cheat a little here and there, stricter languages can be extremely beneficial. This is, in fact, one of the big reasons that I prefer statically typed languages - I like having the protection of the type system. People can certainly build incredibly complex things in dynamically typed languages (I work with people who maintain a very large and very sophisticated Javascript codebase). But such a codebase requires extra diligence to not spin out of control. Not every team has that diligence. And, personally, I know that I'm going to make mistakes. I'd prefer to have something there to catch me.  FP is incredibly successful. Where? SQL. Oh sure, it doesn't look anything like Haskell. But SQL queries are functional and abstract. The developer is given very little control over what the database engine will actually do. And sure, we need to run query plans and tweak indices until the database actually does what we want... but the database engine is taking on a lot of the responsibility itself, and it's probably doing a better job than we could do by hand. Yes, a human could probably out-optimize a database engine, but would take far longer to do the work. This is probably a case where putting the machine in control is a good idea.  Personally, I'm a bit torn on this article. I think Erik is being overly dramatic. The doomsday picture that he paints is patently not the case; some people have been writing ""mostly functional"" code for decades. I think he commits the great sin of monads, which is to build them up into something divine and perfect (when in fact they're much more mundane, if a bit eccentric). But I do think he has a valid point in there.   For example, consider garbage collection. Garbage collection was long believed to be too slow and too uncontrolled to be useful in real software. Everybody needed complete control over their allocations in order to not leak memory like a sieve. But now, GC languages are here to stay. There are plenty of developers that have never had to take the address of anything. Garbage collection turns out to be fine for a lot of software.   The point that Erik is making is that control over memory is just one of those things we could give up. We could give up explicit threading, too. Let the compiler and runtime handle those details. Taking the details away from the developer lets them focus on the problem they're actually trying to solve, while simultaneously allowing the compiler and runtime to operate in the most efficient way. Removing developer control also removes the ability for the developer to sabotage the runtime.  Having said that, I don't necessarily think that Haskell is the ideal working man's language. I don't have a ton of experience with it, but I can see how it can be hard. But Haskell being less than perfect doesn't necessarily discount the idea of pure FP.   Ultimately, I can imagine two broad camps. One camp, which I think you inhabit, wants to retain complete control. You believe that you can do better than the machine, and are willing to pay the price in complexity to achieve that. You get to tell the machine exactly what you want it to do, and the machine will comply. This approach demands perfection, and you're willing to give that. I think the FP camp is more on the opposite end of the spectrum. They don't mind giving up control. In fact, they want to let the machine take on more responsibilities. They want to tell the machine what result they want, and let the machine figure out the details. They'd rather spend half a day fighting the compiler than accidentally introduce a bug or unintended effect.   When I related this story to a colleague that I greatly respect over lunch today, he flat out said that C should not be used for new projects anymore. And while I pointed out some of the cases where you don't really have another choice (microcontrollers being one of the better examples), I basically agreed with him. Most people don't need the level of control that C provides; certainly not across an entire codebase. Maybe Erik is just a raving lunatic. Or maybe he sees further into the future than the rest of us. Maybe true nirvana will be achieved by ceding more and more control to the machine.  But I don't necessarily think that Haskell is nirvana."
haskell,3aufaj,balefrost,1 point,Fri Jun 26 02:17:13 2015 UTC,"Thanks for the detailed reply.  I designed my language/database for concurrency from the ground up. There are 3 ways to provide concurrency with the best method being the first.   Group your data and keep each group totally separate. Give each group it's own local memory. Allow each group to only run on a single thread (green or OS). If a group of data is immutable then you can use it from multi threads without problem. Write as many pure functions as you can as they can be used without problem from anywhere. Global resources need enclosed in a critical section (locks) to serialize access by multiple threads. Design your system by minimizing global resource access.   I didn't invent these 3 points (got them from Joe Duffy, a senior PL developer at Microsoft) but I had already worked them out myself. Please note that #2 is exactly what FP does all the time even when not needed. The above 3 points can accommodate BOTH mutable and immutable data. If a program can be written in ""pure"" form, I have always done that in C (since 1975). If the data can be immutable, that is exactly what I make it.  The difference is that most projects need mutable data and FP tries to make you jump though hoops to solve those problems. (Or just put all the mutable data in a database which isn't an argument for the superiority of FP but it can work.)  The language I am creating with my C project allows all code to be written as if run by a single user on a single thread. There are no lock annotations, functions or commands. There are no instructions to allocate memory or de-allocate it. Persistence to the disk of any object is automatic. No open/read/write/close access to files. There is a persistent queue of messages and all Servers (my name for a macro scale group of data and functions) execute concurrently on any number of cores. SQL is implemented by translating the SQL into my language and then running it. All database tables or data live side by side with the code.  I am not saying that you can't get concurrency by using FP and immutability. I am saying that my system is a real world example where you can have mutable data and automatic concurrency without any special coding at all. Eric implies otherwise.  My language implements automatic memory management but I don't use GC algorithms. I don't globally track down live pointers nor do I have any memory collection pauses. I use a combination of 5 different memory managers and as many local memory managers as are needed. Memory is automatically de-fragmented using multiple methods.  It can get a little confusing when I talk about my project because most of my comments have been from my C project point of view. The language I am creating is very different from C. I take away (like you mentioned for Haskell) many things other languages allow like threading, memory management, persistence to the disk, database connections, pointers and many other features of languages like C or Haskell. The language I am creating was never intended to compete with C++, C or Haskell.  I agree that application programs should never be written in C, C++, Rust, Go etc. Tools and languages (like mine), however, can't be created in anything but these languages.  Before I conclude, let me say how nice it was to get such a detailed response, much appreciated.  In conclusion, languages like Haskell didn't come up with the idea of pure functions and immutable data. Both of these are available in ALL programming languages and have been since 1950's. If Haskell wants to win the debate on it's superiority, it will have to prove that all coding can and should use only these 2 techniques and forgo all others. Haskell debaters will have to prove that Math syntax and concepts are superior to all other PL constructs. I am not arguing that pure functions or immutable data isn't useful, it just isn't sufficient.  Please note that I haven't argued that C is the best language for any type of programming. I have only showed examples from C that refute the points that Eric has made about the superiority of FP."
haskell,3aufaj,jeandem,1 point,Fri Jun 26 13:39:11 2015 UTC,"I never thanked you for explaining your viewpoint. If you end up writing blog posts about your project, you should definitely post them to this sub."
haskell,3aufaj,cowboysauce,6,Wed Jul 1 19:51:15 2015 UTC,This post has a lot of information. Except for the info on why you are on /r/haskell.
haskell,3aufaj,TimTravel,3,Wed Jun 24 08:59:52 2015 UTC,Purely functional programming is a small subset of the code that can be created in a language like C.   Can you provide an example of something that can be done in C that cannot be done with Haskell?
haskell,3aufaj,sambocyn,3,Wed Jun 24 05:24:41 2015 UTC,"You can optimize C more easily. If you ignore performance then all nontrivial languages are equal, but performance matters in many practical cases. Personally I'm willing to trade a little performance to facilitate debugging (and therefore development time), which Haskell does for me."
haskell,3aufaj,clarkd99,1 point,Wed Jun 24 06:47:32 2015 UTC,"sounds like you're really good at C, but do you know Haskell?  the standard typeclasses, how to purify a module, dataflow with polymorphic data structures, etc?  if you know the basics, and aren't impressed (I was), you should check out haskellforall.com . there's dozens of tutorials on advanced haskell features, well-motivated and clearly-explained. to take just one, stuff like Free Monads can make  ""separation of concerns"" in complex programs easier, and thus increases readability and test ability.  also, you can skim through this huge list of haskell features (http://dev.stephendiehl.com/hask/), with examples, and see if anything catches your eye.  since you know so many other diverse programming languages, it shouldn't be take too long to establish an informed opinion."
haskell,3aufaj,gelisam,-13,Wed Jun 24 08:31:11 2015 UTC,"If you want to down vote my post, at least leave a comment. I find anonymous voting a very cowardly invention. I prefer debate and logic, do you?"
haskell,3aufaj,conklech,17,Wed Jun 24 01:16:19 2015 UTC,"If you want to down vote my post, at least leave a comment.   I was hoping that this comment would begin with ""I'm not one of your downvoters, but <insert constructive criticism here>"". Unfortunately, after reading your comment more carefully, I was compelled to downvote as well.  I downvoted your comment because of your tone. I can see that you have an intelligent argument in there, some concrete examples of how to tame effects by being mostly functional but not purely functional. However, the way in which you expose your argument, by promoting your own accomplishments and belittling the accomplishments of others, discourages me from continuing the discussion.   I find anonymous voting a very cowardly invention.   Downvoting without leaving a comment is a good way to minimize the impact of trolls, as leaving a reply would go against the common wisdom, ""do not feed the trolls"".  To avoid being mistaken for a troll in the future, please try to watch your tone more carefully."
haskell,3aufaj,clarkd99,5,Wed Jun 24 02:32:06 2015 UTC,"Looking at your user profile, you've had this sort of problem occasionally over in /r/programming. People are a little bit touchier here in /r/haskell simply because it's a language-specific community; spirited attacks on Haskell or its community understandably trigger many readers' troll-detection heuristics.  You're perhaps not interested in feedback on your tone and so forth; you say you ""prefer debate and logic."" Sure; so do I. But you didn't start off with debate and logic: you started off with a lot of personal comments about your work and your (low) opinion of Haskell. Something like 80% of the sentences in your top-level comment are about ""I"" or ""me"" or ""my design.""  That sort of comment is really difficult to engage with constructively. We really pride ourselves on being a friendly community; not feeding trolls, and avoiding in-my-personal-opinion discussions, are both part of that."
haskell,3aufaj,conklech,0,Wed Jun 24 17:08:25 2015 UTC,"Please take a look at the ""tone"" of Eric's article to which I was referring. Can you honestly say that my ""tone"" was more over the top than his?  I intentionally used my current and personal experience to show that I wasn't just talking about some book learned topic. In fact, I question Erik's actual end user experience on why we should all switch to not just mostly pure but totally pure code. I also have been working full time for the past 3 years on a language/database system and I think I have some practical expertise to share.  If this is seen on the Haskell part of Reddit instead of just programming then the same article must be connected to both. I have never been to the Haskell part of Reddit.  I have strong opinions but I can't see how I could be called a troll. I care very deeply about this particular issue and I have been a professional programmer for 35 years. I think there are many people who give Eric more credit than I believe he deserves."
haskell,3aufaj,balefrost,2,Wed Jun 24 20:58:35 2015 UTC,"Thank you for your reply.   I have never been to the Haskell part of Reddit.   If you haven't before, you have now. Welcome! Sorry things got off on the wrong foot. Reddit is odd in that it's composed of a lot of semi-independent communities. You can tell which one you're in from the URL (reddit.com/r/haskell/...) or by looking at the top left-hand corner of the page.   I have strong opinions but I can't see how I could be called a troll.   I tried to avoid saying that you were; rather that it's a difficult heuristic problem. Reddit and the Internet in general are unfortunately full of anonymous or pseudonymous people declaring their personal views and experiences. That's how we normally interact as adults. But it doesn't work very well with strangers on the Internet. My heuristic is now satisfied that you are what you claim to be, but the first post didn't accomplish that at all.   Please take a look at the ""tone"" of Eric's article to which I was referring. Can you honestly say that my ""tone"" was more over the top than his?   To me, there are two key differences. First: Erik doesn't talk about himself at all; the words ""I"", ""me"", and ""my"" literally aren't there. This invites reactions and discussions to the ideas rather than the person or experience. (Of course, there's some straw-man arguing going on, which is a shame.) Second: he gives specific examples of the problem he's critiquing, and discusses them."
haskell,3aun81,saudade,15,Tue Jun 23 17:22:06 2015 UTC,"For those who, like me, had never heard of Alpine Linux before: https://www.alpinelinux.org/"
haskell,3aun81,gelisam,3,Tue Jun 23 17:33:33 2015 UTC,"Alpine Linux is a security-oriented, lightweight Linux distribution based on musl libc and busybox.  -- the homepage"
haskell,3aun81,cies010,-2,Tue Jun 23 18:24:49 2015 UTC,"Sounds interesting. It looks like this kind of distro will never consider systemd, so that's a plus."
haskell,3aun81,yitz,2,Wed Jun 24 08:50:31 2015 UTC,I knew I forgot to mention something thanks gelisam!
haskell,3aun81,dubiousjim,1 point,Tue Jun 23 17:46:25 2015 UTC,"Hi, I had made a page in the Alpine wiki about compiling GHC under uclibc. Hadn't gotten around to trying to redo the procedure under musl. I'm glad you did. I don't know if my notes were of any use to you, but it'd be nice to update them with a record of your process. At least until we get everything all automated and included in the official Alpine repository. (Even then, the notes could be useful to people trying to port GHC to other platforms.)"
haskell,3aymo1,chocsx,3,Wed Jun 24 15:34:54 2015 UTC,"I don't quite understand what you're asking.  Could you provide a sample input and output?  I'll assume this is a homework assignment asking you to add two numbers given their binary representation, and return the result in binary.  Haskell has some built-in functions for reading and writing numbers given a base in the module Numeric.  Example (ghci):  > import Numeric > import Data.Char > readInt 2 (\c -> c == '0' || c == '1') (\c -> ord c - ord '0') ""1101"" [(13,"""")] > showIntAtBase 2 (\n -> chr (ord '0' + n)) 13 """" ""1101"""
haskell,3aymo1,joeyadams,1 point,Wed Jun 24 16:26:32 2015 UTC,"the questions is, my homework is about make assembly interpreter using haskell, where i'll store the commands in a list. i need tips, no the answer! for improve my study"
haskell,3aymo1,ForTheFunctionGod,1 point,Wed Jun 24 23:37:53 2015 UTC,"After reading your posts a few times, I think you want the following: you have an .asm-file and you want a Haskell-program that runs it, like a virtual CPU.  I have a few questions, though:   I don't understand what you mean by ""binary numbers"". From where do these binary numbers come? Do you have to parse a string of 0 and 1 (e.g. ""10110011"" -> 179), or do you get a bitstream from somewhere? Do you want to emulate the CPU's registers in Haskell, or do you want to write to the actual registers? Do you emulate the stack and the RAM too?    Also, you only need two's complement for subtraction. You can add two numbers by straightforward bitwise addition (+carry)."
haskell,3asu1z,begriffs,12,Tue Jun 23 05:56:48 2015 UTC,"Can anyone tell me how well stack plays with emacs haskell-mode error checking? By which I mean, will the error checker use my stack project's references automatically? I know I can check myself I just thought I'd ask in case anyone knew already."
haskell,3asu1z,created_to_post_this,7,Tue Jun 23 14:07:36 2015 UTC,"So far stack has been playing really well with haskell-mode and flycheck, first I switched away from ghc-mod to /u/chrisdoners haskell-process flychecker. That way errors are pulled from the stack repl. My haskell-mode is also configured at follows, to also use ghci-ng   ((haskell-mode . (                   (haskell-process-type . ghci)                   (haskell-process-path-ghci . ""stack"")                   (haskell-process-args-ghci . (""ghci"" ""--with-ghc=ghci-ng"")))))"
haskell,3asu1z,drwebb,1 point,Tue Jun 23 19:17:31 2015 UTC,"When you C-c C-l to compile your file and open GHCi in emacs, doesn't it prompt you to tell it where your project's .cabal directory is? If you're using stack, you won't have one, so does haskell-mode still work?  I'm used to using emacs haskell-mode with cabal sandboxes and trying to figure out if switching to stack will break my workflow.  Edit: using this .dir-locals.el fixed my problem with emacs: https://github.com/commercialhaskell/stack/blob/master/.dir-locals.el"
haskell,3asu1z,kyllo,2,Wed Jun 24 22:19:30 2015 UTC,This probably depends on  how you do error checking. Do you use the haskell-mode REPL or do you rely on ghc-mod?
haskell,3asu1z,pycube,3,Tue Jun 23 17:12:00 2015 UTC,"I'm curious about the various flycheck plugins including those which use ghc, ghc-mod and hdevtools."
haskell,3asu1z,ranjitjhala,3,Tue Jun 23 18:07:31 2015 UTC,"I wish there were some example emacs configurations, linked from stack the documentation/wiki. That would help folks like me a lot. I don't care which backend my emacs is using (ghc-mod vs something else, presumably installed via stack as well), I just want to use type inference and import-aware syntax checking in emacs.  I hope haskell-mode will be able to support stack without much effort. For example, does haskell-mode have to be told where the binary for stack's downloaded GHC is located, per project? Maybe /u/chrisdoner will chime in (as a major contributor to both projects)?"
haskell,3asu1z,applicativethrowaway,4,Tue Jun 23 19:18:11 2015 UTC,"It should be a case of replacing calls to ghc with stack ghc and calls to ghci with stack ghci. In stack we have in the .dir-locals.el https://github.com/commercialhaskell/stack/blob/master/.dir-locals.el#L1 To run ghci with stack. I have some local elisp for running commands like ""build"" and ""test"" using interactive-haskell-mode, but it has to be merged in some sensible way into haskell-mode.  I'm currently working on stack ide-backend (to be used with ide-backend-mode), which will serve as something like ghc-mod + ghci. I'll probably announce that in a blog post when it's ready."
haskell,3asu1z,chrisdoner,1 point,Tue Jun 23 21:21:40 2015 UTC,Great news. Looking forward to trying it.
haskell,3asu1z,pi3r,9,Tue Jun 23 23:18:09 2015 UTC,Worth mentioning that the haskell-stack mailing list just started.
haskell,3asu1z,spindakin,8,Tue Jun 23 08:16:38 2015 UTC,"I consider stack to be a great way to innovate and experiment in that space without being slowed down by trying to reach consensus and modify cabal install for everybody. If it proves to be useful and widely adopted, the consensus would have been reached naturally :-) Yes, there's an issue of ""fragmentation of effort"" in the community but after fragmentation there will always be a period of consolidation of the proven solutions and that will benefit everybody in the long term."
haskell,3asu1z,mallai,5,Tue Jun 23 14:03:17 2015 UTC,"Stack seems really nice. As it uses a specific stackage snapshot, does this mean I don't specify versions in my cabal files?  Another question:  Why have a separate config file for  stack (stack.yaml).  Can't we have custom fields in our cabal file?"
haskell,3asu1z,arianvp,10,Tue Jun 23 07:32:31 2015 UTC,"As it uses a specific stackage snapshot, does this mean I don't specify versions in my cabal files?   That's your call. If you're building a local project, the version constraints in a .cabal file will only have the ability to tell stack that it's got the wrong versions. There are still advantages to having version constraints in a .cabal:   It prevents stack init from choosing incorrect build plans It can help you with testing on other snapshots (e.g. stack test --resolver nightly-2015-06-23) If you want to support people using cabal-install to build your code, which is especially true if you're going to upload to Hackage    Why have a separate config file for stack (stack.yaml). Can't we have custom fields in our cabal file?   There are lots of reasons in favor of a separate file, but probably the simplest is that stack supports multi-package projects, meaning that a single stack.yaml can support 0, 1, or many .cabal files."
haskell,3asu1z,snoyberg,3,Tue Jun 23 07:56:04 2015 UTC,"Even before switching to stack about two weeks ago, I've basically had very little worry about version constraints ever since I switched to using stackage lts (while I was still using cabal-install). I don't specify any constraints in my cabal file. I just let stackage lts pick them all.  However, I will say that stackage lts is beginning to show the fact that it is a long term support package set, and this is where I find stack to help the most. If you're staying on GHC 7.8.4 for a little while longer, you can't use transformers-0.4 with stackage because none of the builds support it (even the nightlies). Similarly, the diagrams package is stuck on 1.2 (because 1.3 makes some breaking API changes). Fortunately, in the case of diagrams, I can just do this in my stack.yaml file:  extra-deps:   - 'diagrams-core-1.3.0.1'   - 'diagrams-contrib-1.3.0.3'   - 'diagrams-lib-1.3.0.1'   - 'diagrams-svg-1.3.1.2'   - 'diagrams-solve-0.1'   - 'active-0.2.0.3'   - 'force-layout-0.4.0.1'   And now I everything works nicely (for diagrams at least. I don't know how to use the newer transformers). I find it to be a better way to use newer packages than the equivalent solution with a cabal-install sandbox."
haskell,3asu1z,andrewthad,9,Tue Jun 23 12:14:47 2015 UTC,"I think you'll be happy to hear that LTS 3.0 should be released soon, which will add GHC 7.10, transformer 0.4, and a lot more (check out the latest nightly to see all ~1100 packages)."
haskell,3asu1z,snoyberg,5,Tue Jun 23 13:24:34 2015 UTC,Very good news. 7.10 for mainstream adoption! :)
haskell,3asu1z,cies010,2,Tue Jun 23 13:48:14 2015 UTC,I am excite!
haskell,3asu1z,Crandom,6,Tue Jun 23 16:45:13 2015 UTC,"Today's nightly has:   transformers installed transformers-base ==0.4.4 diagrams ==1.3 diagrams-core ==1.3.0.1   As Dan Burton mentiones in the video that OP links to: ""LTS is not bleeding edge, and that's the whole point""."
haskell,3asu1z,cies010,6,Tue Jun 23 13:25:41 2015 UTC,"I totally agree, and I'm very happy that LTS is not bleeding edge. I guess I wasn't clear about this in my original comment, but I'm trying to stay with GHC 7.8.4 until 7.10.2 comes out. Consequently, the nightly releases don't really help me at this point."
haskell,3asu1z,andrewthad,2,Tue Jun 23 13:54:35 2015 UTC,Would it be possible to provide a Debian repo ? (I am using a derived distro that has just moved from Ubuntu to Debian jessie).  I would assume Debian packages would work for Ubuntu ?
haskell,3asu1z,pi3r,2,Tue Jun 23 23:27:42 2015 UTC,"Someone's working on it now. If you'd like to get involved, please email the haskell-stack mailing list, I'm sure testing and/or contributions will be very welcome."
haskell,3asu1z,snoyberg,1 point,Wed Jun 24 07:30:19 2015 UTC,I'm on my phone so sorry for the quick reply. stack takes care of figuring out where the cabal files are. The work flow is almost identical to using cabal repl as the Haskell mode process.
haskell,3atrrz,cies010,8,Tue Jun 23 13:15:10 2015 UTC,"Interesting find! The readme seems a bit confusing though; it talks about Seaside, ScalaFX, etc, while the UI is actually using Elm. Also, it doesn't link to roadmap.md."
haskell,3atrrz,eriksensei,4,Tue Jun 23 14:27:23 2015 UTC,"Stumbled on this, found it was never posted to this subreddit.  Yet."
haskell,3atrrz,slgard,4,Tue Jun 23 13:16:03 2015 UTC,"I can't (be bothered to) get it to compile. fails with ""Ambiguous occurrence ‘defaultTimeLocale’"" in Data.DateTime module which appears to be deprecated"
haskell,3atrrz,agocorona,2,Tue Jun 23 14:41:46 2015 UTC,Thanks a lot for this work. That is something that the haskell community need the most:  applications
haskell,3arv4y,pragm,13,Tue Jun 23 00:27:44 2015 UTC,"IMO the biggest thing Haskell has going for it in the safety department is purity.  There is simply no other pure language out there today that is viable for commercial development.  Therefore, these languages simply cannot provide the guarantees that you can get with Haskell.  So on one sense you cannot get safer code in other languages like you can in Haskell.  But in another sense you can take the ideas of purity and use them to help you design software in other languages.  They may not be able to give you compiler-checked guarantees, but you can still design APIs that are more pure and have less hidden side effects.  I'm not sure to what extent this will make your software better and more robust, but I'm pretty sure the effect will be non-zero."
haskell,3arv4y,mightybyte,13,Tue Jun 23 02:13:14 2015 UTC,"They may not be able to give you compiler-checked guarantees, but you can still design APIs that are more pure and have less hidden side effects. I'm not sure to what extent this will make your software better and more robust, but I'm pretty sure the effect will be non-zero.   Yeah, the effects are definitely an improvement.   A thing I don't see mentioned so often is that programming is on the one half caring about your own code (which is why I think Lisp attracts selfish programmers) and the other half caring about using other people's. People get stuck on me-me-me and don't look much at the ecosystem-wide effect. If the language enforces X, then you can trust it in other people's code. In a language without X enforced, you can only do it by convention for yourself and have no trust that anyone else adheres to your principles, nor expect that any libraries will make your life easier in applying this principle."
haskell,3arv4y,chrisdoner,3,Tue Jun 23 09:59:16 2015 UTC,I think about this w/r/t unsafePerformIO when discussions come up about it. I think the existence per se of unsafePerformIO in GHC almost doesn't matter in practice because of the cultural and structural things that enforce purity (though I still think it would have been a better choice for GHC to use a special syntax for unsafe functions).
haskell,3arv4y,jberryman,3,Tue Jun 23 15:34:20 2015 UTC,the cultural and structural things that enforce purity   This is a great point. The language enables and encourages purity to a certain degree; far more important is the community's commitment to purity and other forms of discipline.
haskell,3arv4y,conklech,3,Tue Jun 23 19:25:28 2015 UTC,"If the language enforces X, then you can trust it in other people's code. In a language without X enforced, you can only do it by convention for yourself and have no trust that anyone else adheres to your principles, nor expect that any libraries will make your life easier in applying this principle.    This is a very good point."
haskell,3arv4y,TimTravel,7,Wed Jun 24 07:45:38 2015 UTC,"There is simply no other pure language out there today that is viable for commercial development.   Note that in D if you mark functions pure and make them take immutable parameters then the compiler will ensure you write pure, side-effect free code."
haskell,3arv4y,logicchains,5,Tue Jun 23 11:12:07 2015 UTC,"Neat! For the info of others I did a quick google for details and found the ""pure functions"" section here: http://dlang.org/function.html  Seems like such a handy thing to have (and actually not too horrible to enforce) I'm surprised Rust didn't bother with it..."
haskell,3arv4y,sclv,1 point,Tue Jun 23 12:58:49 2015 UTC,"A new feature being (re)implemented for Rust is const fn functions. Basically C++'s constexpr (which in turn are mostly a really constrained focus-on-compile-time-usage version of D's pure (not sure how D ensures a function can/cannot be used for compile-time initialization, but it's something to do with enum, I think?)) but quite a bit less constrained, hopefully."
haskell,3arv4y,Enamex,3,Wed Jun 24 08:48:59 2015 UTC,"Interesting.  Thanks for the pointer.  I guess maybe my ""viable for commercial development"" clause might still save me there.  :P  That and chrisdoner's point about being able to trust other people's code.  Do you know how long D has had that?  I looked into D years ago before I started looking at Haskell and I don't remember seeing it."
haskell,3arv4y,mightybyte,3,Tue Jun 23 12:07:37 2015 UTC,"Since D 2.0, probably (a lot got added with 2.0)."
haskell,3arv4y,Enamex,3,Tue Jun 23 12:43:18 2015 UTC,"I guess maybe my ""viable for commercial development"" clause might still save me there. :P   Apparently an advertising company primarily using D called Sociomantic had over $100 million in revenue for 2013,  so I think it's shown some commercial viability. Although Sociomantic were only using D1, I'll give the language the benefit of the doubt in assuming it hasn't regressed significantly over time."
haskell,3arv4y,logicchains,3,Tue Jun 23 13:58:29 2015 UTC,Even Fortran has that.
haskell,3arv4y,chrisdoner,2,Tue Jun 23 13:34:15 2015 UTC,"So I guess maybe instead of saying that Haskell is the only popular language with purity, I should instead say that it's the only popular language with referential transparency."
haskell,3arv4y,mightybyte,5,Tue Jun 23 14:42:20 2015 UTC,"I think it has made me write safer code in other languages by encouraging me to write pure functions and have fewer side effects. It has also made me think harder about types in my code: even in weakly typed languages, I tend to write code that is strongly typed, because it's easier to reason about."
haskell,3arv4y,penguinland,2,Tue Jun 23 02:44:32 2015 UTC,"I'm not sure functional programming, per se, really helps you that much. You're going to have an easier time writing Java in a safe way than VBA or lisp. Really the gains are more related to strong typing. Haskell just happens to be better at shifting errors to compile time because it also has many nice features like non-nullable values and warning if pattern matches are non-exhaustive.  Pure functional programming, on the other hand, provides a way to avoid bugs to do with ending up in a bad state. I view it as an alternative to object oriented programming, which accomplishes roughly the same goal. However pure functional programming is possible more because of the type system than because of the functional paradigm. You can conceive of imperative languages that have this ""purely functional"" characteristic, and people have. To enforce a difference between pure and impure though, you need some thing to distinguish them and prevent impure code from being marked pure. In Haskell, the type system does this."
haskell,3arv4y,Kaidelong,4,Tue Jun 23 12:45:35 2015 UTC,"It takes a lot more effort to richly type destructive updates in a way that can catch errors at compile-time as easily as you can with functional data flow.  With arguments and results, having types verify you handle all the cases, and that everything checks out is a (at least partially) solved problem.  Imperative programming adds another form of data flow -- through the current state of mutable variables and use of destructive updates.  It is possible to give static types that help correctness, but it is far more difficult. The kind of static types in Java, when combined with destructive updates, is going to be inherently less safe than function application for data-flow."
haskell,3arv4y,Peaker,1 point,Tue Jun 23 16:20:08 2015 UTC,"How much more effort would it really be? You can make imperative languages that essentially exist as syntax sugar over a functional core, something like what C# does with how it interprets await (makes a continuation with the stuff after await and passes it into the asynchronous function as a callback). We already have ST in Haskell that does something like that (not like await, but it takes imperative code and gives it a functional interpretation for the sake of checking correctness with the type system).  I really hope it's not that difficult and I'm not missing something super important here because if we see pure functional programming take off it's likely going to take off in the context of imperative languages, not functional ones. The data flow problem seems tractable enough; you could take an approach very similar to how do notation is desugared.  PS: the purely functional imperative examples I had in mind were Disciple and Koka"
haskell,3arv4y,Kaidelong,1 point,Thu Jun 25 04:13:31 2015 UTC,Destructive updates aren't syntactic sugar over parameter passing. Mutability can't be so easily converted to pure functional code.  Consider aliasing effects for example.
haskell,3arv4y,Peaker,1 point,Thu Jun 25 08:09:46 2015 UTC,"Directly, not really. Indirectly, yes.  When you program in a language, it's generally best to follow the established idioms of that language. Functional programming in C tends to not work out so well. Mostly because the high-level programming you'd do in C would be better in a different language.   On the other hand, newer languages often take inspiration from existing languages. If something works well in a language, then new languages might borrow that. As an example, Rust draws inspiration from Haskell and ML to a significant degree."
haskell,3arv4y,dagit,1 point,Tue Jun 23 00:40:24 2015 UTC,"Strong Static Typing System- Types are documentation and guarantee about what a function is supposed to do, you can infer about what a function does reading and returns by reading its type. They also helps the programmer to reason and refactor the code. Thanks to it bugs can be caught before runtime. In a dynamic typed language like Python, you don't have any guarantee about what a function is supposed to return and you have to write much more documentation to overcome this, now I am using Haskell type notation when documenting python functions. With static typing an proper IDE can give you much more help than in a dynamic typed language.  Option type/ Maybe Monad / Maybe Functor - The option type avoids the ""null checking"", aka ""null reference"" or ""null object bug"". It also avoids successive boilerplate null checking. Tony Hore - Null References the Billion dollar Mistake Data Immutability and purity helps to avoid race condition bugs that are hard to detect and test. One example of how expensive and dangerous a bug like this can be is: Therac-25 case ""Lack of State"". Implicit or hidden states can lead to concurrency or race condition bugs."
haskell,3arv4y,eniacsparc2xyz,1 point,Fri Jun 26 06:29:33 2015 UTC,"Therac-25:       The Therac-25 was a radiation therapy machine produced by Atomic Energy of Canada Limited (AECL) after the Therac-6 and Therac-20 units (the earlier units had been produced in partnership with CGR of France).  It was involved in at least six accidents between 1985 and 1987, in which patients were given massive overdoses of radiation.  :425 Because of concurrent programming errors, it sometimes gave its patients radiation doses that were thousands of times greater than normal, resulting in death or serious injury.  These accidents highlighted the dangers of software control of safety-critical systems, and they have become a standard case study in health informatics and software engineering.     Relevant: Nancy Leveson | Software bug | Race condition | Theriac   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3arv4y,autowikibot,1 point,Fri Jun 26 06:30:42 2015 UTC,and these things can bee implemented in other languages?
haskell,3arv4y,eniacsparc2xyz,1 point,Fri Jun 26 07:12:41 2015 UTC,"Yes. But it will much more verbose and hard in a language without static typing, type inference and first class functions and data immutability.  You can simulate the option/ maybe type in Python with classes but it has an overhead and the language doesn't enforce this.  Some languages similar to Haskell are OCaml and F, an OCaml dialect to the .NET platform. There is also Scala that is a FP language for the JVM, however it doesn't have type inference like Haskell. The main difference between them is the purity and laziness, Haskell is the only one pure and lazy. Another feature hard to replicate is the Haskell compact notation.   Here some languages with option type"
haskell,3arv4y,autowikibot,1 point,Fri Jun 26 07:40:03 2015 UTC,"Option type:       In programming languages (especially functional programming languages) and type theory, an option type or maybe type is a polymorphic type that represents encapsulation of an optional value; e.g. it is used as the return type of functions which may or may not return a meaningful value when they are applied. It consists of either an empty constructor (called None or Nothing), or a constructor encapsulating the original data type A (written Just A or Some A). Outside of functional programming, these are known as nullable types.     Relevant: Nullable type | Null pointer   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3as4ry,evohunz,10,Tue Jun 23 01:53:22 2015 UTC,"Java's Class can be queried at runtime, but in Haskell, type information is erased at runtime. This means that you can write more functions in Java with the signature <T> T (T arg, Class<T> cls) than there are functions of type forall t. t -> t in Haskell (since the Java function can inspect the type argument). On the other hand, it's hard to prove anything about the Java version, whereas you know almost exactly what the Haskell function must do, given its type."
haskell,3as4ry,paf31,6,Tue Jun 23 03:57:14 2015 UTC,"How about Data.Typeable (and Data.Dynamic)? The Typeable constraint is needed, but if that is present, the type can be observed in runtime, can't it?"
haskell,3as4ry,literon,5,Tue Jun 23 05:54:23 2015 UTC,"Yes, so if you have a Typeable constraint, you don't get the guarantees that erasure would have given you."
haskell,3as4ry,rpglover64,4,Tue Jun 23 15:52:11 2015 UTC,"I would say no.  But let's be clear and distinguish three Java features:   Runtime type tests and casts: the expr instanceof SomeType test and (SomeType)expr casts. The java.lang.reflect API. Java Generics (1.5 and later).   (3) resembles the Haskell type system, but is much more complicated.  The closest Haskell analogue to (1) is Data.Typeable and Data.Dynamic.  When I hear the term ""Java Reflection,"" however, I understand it as (2), the java.lang.reflect API, which doesn't really have a Haskell counterpart.  This allows you take an arbitrary Class object, list out its constructors and methods, obtain runtime-created delegating wrappers around them and invoke them.  I'm not aware of anything like that in Haskell; Data.Typeable by itself doesn't provide any facilities for creating values of an arbitrary type that you have a TypeRef for, or for discovering functions at runtime that work with the type that a TypeRef denotes."
haskell,3as4ry,sacundim,3,Tue Jun 23 23:40:44 2015 UTC,"I'm surprised you didn't mention Haskell's ""-XDeriveGeneric"" extension. Which not unlike Java reflection, lets us convert a datatype to and from a generic representation and write generic code for any datatype.  More details here: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/generic-programming.html And a nice talk by Andres here: https://skillsmatter.com/skillscasts/3932-a-haskell-lecture-with-leading-expert-andres-loh Sure, Reflection in java allows more, such as dynamic binding and many other unsafe operations (even mutating internal symbol tables). But this additional power also makes things more complicated and less efficient (many runtime checks by class loaders, security managers etc)"
haskell,3as4ry,willtim,2,Wed Jun 24 19:10:53 2015 UTC,"I think so, yes. Java's reflection provides more information because Class objects contain more data, but it's basically the same things."
haskell,3aqj67,mallai,19,Mon Jun 22 18:16:47 2015 UTC,"However, how much of that can be used in Haskell today (with 7.10)?   At the risk be being too glib: None of it.   Notions of subtyping in the unifier itself basically wreak havoc on inference. The typeclass mechanism pushes these concerns out of the unifier.   There is a limited form of ""subtyping"" relationship between a class and a subclass, or an instance body and its head, but it isn't the same as a refinement type, the implications themselves are uniquely determined by coherent instance resolution.  Refinements in refinement types are usually about talking about properties of the values inhabiting the type. We don't really have that vocabulary in Haskell today, beyond some experiments like LiquidHaskell that are out on the fringes."
haskell,3aqj67,edwardkmett,6,Mon Jun 22 18:46:40 2015 UTC,"(My current view as co-author of the first paper mentioned.)  I basically agree with edwardkmett.  Refinement types aren't types in the same sense as the structural types in Haskell and ML - structural types are required prior to assigning semantics to programs, while refinements generally capture properties that are logical consequences of the semantics.  Sometimes the alternative term ""type refinements"" is used to emphasize that they aren't the same as structural types.  General intersection types appear to blur the distinction, sometimes this is handy when concepts may move between being enforced by the type structure or as properties.  A purist view is that if something inhabits the intersection of two types, the structural aspect of those two types must be the same.  Ultimately, you may only have one structural monotype with many refinements.  This applies to languages with subtyping too.  Type classes can be considered as refinement kinds (or kind refinements) that witness that particular types support particular sets of operations, with subclassing and intersection corresponding to existing features of Haskell type classes.  Frank Pfenning (my co-author) suggested this as far back as 1993, it seems natural and elegant aside from coherence."
haskell,3aqj67,rowandavies,2,Wed Jun 24 05:56:19 2015 UTC,"Hi Rowan,  I think you can use GHC extensions to encode full parametric intersection types by combining datatype promotion, closed type families, and higher-rank polymorphism. Basically, the idea is to mimic the way that large eliminations work in dependent types, but to use parametric quantification to get the right computational behavior -- I haven't tried compiling it, but I mean something like:   type family IfThenElse (b :: Bool) (s :: *) (t :: *) where    IfThenElse True  s t = s     IfThenElse False s t = t   type intersect s t = (forall b :: Bool. IfThenElse b s t)   Essentially an element of intersect s t has to be both an s and a t in order to be well-typed, because it has to be polymorphic in the boolean b. You can do something similar for universals, but it's a lot clunkier because GHC's treatment of existentials is pretty shabby.   I should note this is just an encoding of the types; I'm not sure if one can encode the right intro/elim rules without explicit type applications, which IMS ghc doesn't have yet?"
haskell,3aqj67,neelk,5,Wed Jun 24 16:00:52 2015 UTC,"Thanks. The interesting part of the ""unrestricted intersection types"" work I cited is that it allows using normal ML compiler which is unaware of the intersection and union types. They are transformed into products and sums after typechecking. Probably the same could be done for Haskell."
haskell,3aqj67,WarDaft,6,Mon Jun 22 19:44:04 2015 UTC,"It works a little bit, if you don't mind drowning yourself in extensions and using a special function to call your assembled hodgepodge.  {-# LANGUAGE     TypeFamilies,     FlexibleInstances,     TypeOperators,     MultiParamTypeClasses,     OverlappingInstances,     IncoherentInstances     #-}  import qualified Data.Text as T import Control.Concurrent (threadDelay)  data a :^ b = a :^ b  infixr 8 :^  class Inj a b where     inj :: b -> a  instance Inj a b => Inj a (c :^ b) where     inj (_ :^ b) = inj b  instance Inj a (a :^ b) where     inj (a :^ _) = a   Then we'll have:  fn = (T.length . T.pack :^ T.append (T.pack ""at "") . T.pack :^ ())  inj fn ""the"" T.append (T.pack "" end"") == ""at the end""  threadDelay $ inj fn ""sleep"" :: IO () -- Sleeps for at least 5 microseconds  But the types must match exactly. For example, length simply will not work without a great mess, because it works on objects of type [a] and unless you jump through numerous hoops you don't have that particular a, and String is definitely not [a]. You also simply cannot make a f = inj fn function that works. Even if you give it a top level type signature, you will only get f :: Inj a () => a.  You give up a lot and need to use verbose syntax risking bizarre error messages to get a little bit of someone else's box of toys, but if you really want to, you can."
haskell,3aqj67,kamatsu,3,Mon Jun 22 20:54:01 2015 UTC,That's not an intersection type. What about intersection elimination?
haskell,3aqj67,WarDaft,2,Tue Jun 23 08:26:23 2015 UTC,Hence qualifiers like 'hodgepodge' and 'drowning'.
haskell,3aqj67,kamatsu,3,Tue Jun 23 19:30:05 2015 UTC,It doesn't support them.
haskell,3aqj67,sclv,3,Tue Jun 23 00:27:49 2015 UTC,"If you look at the section on ""Coherence"" in the linked Dunfield paper on unrestricted intersection types, you'll see that what he presents, while a step forward, is far from something suitable to implementation in any language at all, since the basic problems of inferring a usable, meaningful, and predictable behavior for those types still remain :-(  The refinement typing story, as you discuss, is more tractable, and there's work on making LiquidHaskell much more usable and integrable into actual development. (And we have a GSoC project even that's about taking some small steps in that direction!)"
haskell,3aqj67,sclv,2,Tue Jun 23 13:06:35 2015 UTC,"Yes, any type of contract expressed in a type signature can be thought of as a refinement type. I am looking forward to LiquidHaskell :-)   Also, I found Dana Xu's work on Static contract checking for Haskell amazing. Is there anybody continuing that work?"
haskell,3aqj67,radix,2,Tue Jun 23 13:16:16 2015 UTC,"The LiquidHaskell research cites that line of work, but I don't know anyone specifically following the Xu approach."
haskell,3aqj67,radix,4,Tue Jun 23 13:38:31 2015 UTC,"Yes, I searched a bit and it does not seem to be followed. It's too bad as I found it quite natural and easy to learn and apply. Sure, many contracts are impossible to prove statically and they have to be deferred to run-time. However, they could be deferred to run-time only during testing and removed from the production builds, if performance is an issue.  I found LiquidHaskell to be much harder for me to wrap my head around.  EDIT: I take the last statement back. This paper does a great job of explaining how to use LiquidHaskell in practice."
haskell,3aqj67,radix,2,Tue Jun 23 13:58:56 2015 UTC,"Are ""union types"" not the same thing as coproducts, e.g., Either?  (I'm not saying they are, this is an honest question)"
haskell,3apftl,goliatskipson,28,Mon Jun 22 12:55:00 2015 UTC,"One of the authors here. The latest changes to Hayoo! haven't been changes to the core functionality. Instead, the problem with the wicked results is the indexer. Currently we crawl (!) the haddock html from http://hackage.haskell.org/. And since that changes quite frequently lately our indexer mixes things up while traversing the DOM.   Only recently I discovered that /u/ndmitchell had implemented a Haddock output format which is more stable. But I haven't had time to implement a proper parser yet. But if someone wants to step up and do some Haskell programming in their spare time that would be a nice project with great community reward. One could almost completely reuse the existing indexer structure, but instead of crawling html one would crawl those haddock files. One could start with https://github.com/hunt-framework/hayoo/blob/signature/hayoo-hoogle-indexer/src/Hayoo/Index/Hoogle/Parser1.hs which is a first try on a parser for said format.   As a partial solution: I will have a look on the indexers output and try to correct it. So hopefully we will have a recovered nice behaviour tonight."
haskell,3apftl,alexbiehl,10,Mon Jun 22 16:44:30 2015 UTC,Could you give a rough estimate on how much work this is? Depending on that I might be willing to give it a shot.
haskell,3apftl,alexbiehl,9,Mon Jun 22 19:12:42 2015 UTC,"1) Basically, your indexer has to download all cabal files (http://hackage.haskell.org/packages/index.tar.gz) and all hoogle-haddock files (http://hackage.haskell.org/packages/hoogle.tar.gz) from hackage.   2) You would fit the cabal files into PackageInfo format (https://github.com/hunt-framework/hayoo/blob/master/hayooIndexer/src/Hayoo/PackageInfo.hs) and the hoogle files into FunctionInfo format (https://github.com/hunt-framework/hayoo/blob/master/hayooIndexer/src/Hayoo/FunctionInfo.hs).   3) You would then calculate the package rank (https://github.com/hunt-framework/hayoo/blob/master/hayooIndexer/src/Hayoo/PackageRank.hs) from the PackageInfo, specifically package names and their dependencies.   4) Additionally you would create 'ApiDocument's from your PackageInfos and FunctionInfos (https://github.com/hunt-framework/hunt/blob/master/hunt-searchengine/src/Hunt/ClientInterface.hs) wrap them up in insert commands and print that out in json. Which can be used as input to the searchengine.   Parsing the cabal files can be done with the Cabal library, for the haddock format you would have to write a robust parser which gets you all the information for the 'FunctionInfo's you need.   And of course we would guide you and provide answers to your questions."
haskell,3apftl,quchen,10,Tue Jun 23 08:20:33 2015 UTC,"Apart from that, thanks for the great search engine. When it wasn't broken it was far superior to Hoogle for my search purposes. Keep up the good work!"
haskell,3apftl,kqr,6,Mon Jun 22 22:28:08 2015 UTC,Have you tried the Hoogle over at FP Complete? It seems to do the right thing for all three examples you mentioned.
haskell,3apftl,cies010,3,Mon Jun 22 14:27:26 2015 UTC,Yep... I currently use that as an alternative.
haskell,3apftl,cies010,2,Mon Jun 22 15:08:25 2015 UTC,So what's laking in FPC's Hoogle compared to the old Hayoo in your opinion?
haskell,3apftl,mightybyte,3,Mon Jun 22 16:08:24 2015 UTC,"At this point it's probably just convenience ... but a quick search for Data.Vector takes some time too:   first try: vector second try: Vector third try: Data.Vector   Most common result is on third place only after I write out the whole module name. To be honest I didn't expect that I'd find a bad example on the first try.  I might be mistaken, but I remember that ""old hayoo"" almost always gave the result you were expecting."
haskell,3apftl,codygman,1 point,Tue Jun 23 10:22:16 2015 UTC,Ok. Thanks!
haskell,3apftl,ndmitchell,7,Tue Jun 23 11:24:08 2015 UTC,"Yep, I completely agree.  The old Hayoo was my go to Haskell search engine as well, but the new one seems pretty much useless.  I can't recall a single search on the new Hayoo where I've actually found what I was looking for."
haskell,3apftl,ndmitchell,1 point,Mon Jun 22 14:47:37 2015 UTC,"Yeah, I was wondering if it was just me."
haskell,3apftl,alexbiehl,3,Tue Jun 23 18:57:39 2015 UTC,The results from Hoogle 5 are now at http://hoogle.haskell.org and might give you better results than the old Hoogle.
haskell,3apftl,alexbiehl,2,Mon Jun 22 20:13:33 2015 UTC,Same test as above:   first try: vector second try: Vector   Package I am searching for is on second place on the first try. Module I am searching for is on first place on second try. That's much better.  Is Hoogle 5 a different version than the one run by FP complete? Or is the better result just a consequence of a narrower search scope?
haskell,3apftl,magnusg7,6,Tue Jun 23 10:27:02 2015 UTC,"FP Complete are on Hoogle 4, this one is Hoogle 5. In this case, both versions are searching all of Stackage, so the better result is just because Hoogle 5 is better :)"
haskell,3apftl,pycube,4,Tue Jun 23 12:02:50 2015 UTC,It took longer than expected but check it out now. It should be much better now.
haskell,3apftl,edwardkmett,1 point,Wed Jun 24 13:52:16 2015 UTC,Much better now. What changed?
haskell,3apftl,pchiusano,1 point,Thu Jun 25 08:54:00 2015 UTC,I didn't change anything. I must have missed inserting the ranking into the index the last time... Sorry about that.
haskell,3apftl,chreekat,1 point,Thu Jun 25 10:33:44 2015 UTC,Thanks anyways for working on this awesome tool!
haskell,3apftl,CharlesStain,3,Thu Jun 25 14:17:20 2015 UTC,I fully agree. Here's another example: http://hayoo.fh-wedel.de/?query=ReaderT.
haskell,3ap4k7,gallais,6,Mon Jun 22 10:36:53 2015 UTC,"Author here. Feedback always welcome. This is more of a ""things that in hindsight are obvious"" but I thought I would share."
haskell,3aoyfi,agocorona,3,Mon Jun 22 09:01:25 2015 UTC,"How does this approach compare with Erlang, the gold standard in functional mobility?"
haskell,3aoyfi,yitz,4,Tue Jun 23 08:41:23 2015 UTC,"I don't know erlang neither cloud haskell very well. This development is at the beginning and the erlang model is mature.    The erlang model is intentionally low level, it tries to make the network and the communication costs visible. It focuses on reliability  Mine tries to make the network transparent and emphasizes composability and high level programming. An example of composability is in the mapReduce snippet.  Almost all cloud computing platforms work in inverted (reactive) mode. This is the only model that I know that operates in full de-inversion and yet is non blocking. This is the reason why it is composable. In contrast,  cloud-haskell and Erlang uses blocking calls.   Concerning inversion of control, this approach is more close to this: http://lampwww.epfl.ch/~odersky/papers/jmlc06.pdf  Concerning mobility of software, It is more closer to Objectspace Voyager: http://www.inf.fu-berlin.de/lehre/WS99/VS/Misc/Voyager/API/doc/orb.pdf  I will dedicate this software to Graham Glass, the genius behind Objectspace Voyager that developed a cloud platform 15 years ago that still is years ahead of anything else.  But this is at an early state. Let´s see what happens. Anyway, I never dreamed to do this with so little code and so fast. That may mean that I´m in the right direction."
haskell,3aoyfi,Jookia,2,Tue Jun 23 10:51:01 2015 UTC,"Hot swapping of code is also a goal. Once a program is substituted by a new version, replaying from the log would recover the node state.   If the program's behaviour is different wouldn't it diverge through replaying?"
haskell,3aosxv,meditans,11,Mon Jun 22 07:34:06 2015 UTC,"This means, ""return the tuple thunk""   Terminology nit: the tuple is not a ""thunk"", it's a ""constructor"".  A thunk is an unevaluated expression, whereas a tuple is a value.  More on the different kinds of heap object here: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects"
haskell,3aosxv,simonmar,5,Mon Jun 22 12:58:29 2015 UTC,"That is definitely correct. I'm also glad you linked to more info. I need to read up a bit on that!  Unless I'm committing a heinous crime by doing so, I think I'll keep the word ""thunk"" in the article there anyway for the sake of brevity."
haskell,3aosxv,kqr,8,Mon Jun 22 13:14:04 2015 UTC,"A friend of mine once had to write a three-page essay as punishment, entitled ""This is laziness"". On each page, he wrote a single word: THIS     IS     LAZINESS.  Or, in Haskell-form:  this_is_laziness :: a this_is_laziness = this_is_laziness   He was wise beyond his years."
haskell,3aosxv,ForTheFunctionGod,3,Mon Jun 22 11:49:27 2015 UTC,This reminded me of this strip: http://www.gocomics.com/calvinandhobbes/1995/01/09/
haskell,3aosxv,BethAr,3,Mon Jun 22 19:28:01 2015 UTC,"Simon Peyton Jones and David Lester have written an entire book on the subject of lazy evaluation. Implementing Functional Languages: A Tutorial is available on SPJ's website. It's from the early 90s, though, and covers Miranda instead of Haskell. I'm sure that some of the information is out of date. But it's been a good read so far (I'm still only about halfway through it), and it has a good collection of exercises if you're up for working through them.  While I'm talking about it, he has another book on his site as well. The Implementation of Functional Programming Languages is older, and is more like a collection of papers than a tutorial. Still, it covers more of the compiler (the first book is almost exclusively about the evaluator and the parts of the compiler that care about evaluation). For example, this book covers topics like efficient pattern matching and type inference.   The PDF for the first book is pretty clean, but unfortunately the second book's PDF is a bunch of scanned pages. If you're interested in this sort of stuff, I'd definitely try to grab a used copy."
haskell,3aosxv,balefrost,1 point,Tue Jun 23 02:25:45 2015 UTC,"Great write-up, thanks!"
haskell,3apngi,maxigit,1 point,Mon Jun 22 14:09:29 2015 UTC,"What about modeling it like the following ?  import Data.Map (Map) import qualified Data.Map as Map  type Duration = Double type Cost = Double data ShiftReport = SRTotal Map (Employee, Day) (Duration, Cost) | SRIndividual Shift  instance Monoid ShiftReport where   mempty = SRTotal $ Map.fromList []   mappend (SRTotal c) (SRIndividual s@Shift) = -- pseudocode       lookup (employee s, day s) c -> update/insert (duration/cost tuple)    I think it would be the most similar to the aggregation query you mentioned, unless I did something wrong :)  edit and for this question   knowing that once I've done that I'll need also to shrink it again and discard day to get the number of hours/cost per week   You have multiple answers with my suggested model. The simplest option is to add a phantom type to ShiftReport and have two monoid implementations in that case.  data DailyReport data WeeklyReport  -- declaration changes to  data ShiftReport a k v = SRTotal Map k v | SRIndividual Shift  instance Monoid (ShiftReport DailyReport (Employee, Day) (Duration, Cost)) where   ...  instance Monoid (ShiftReport WeeklyReport Duration Cost) where   ...   edit you might not even need the phantom type, just parameterize the result ""container""  data ShiftReport m = SRTotal m | SRIndividual Shift  instance Monoid (ShiftReport (Map (Employee, Day) (Duration, Cost))) where   ...  instance Monoid (ShiftReport (Duration, Cost)) where   ..."
haskell,3apngi,alt_account10,2,Mon Jun 22 14:36:36 2015 UTC,"The first solution Map (Employe, Day) (Duration, Cost) is somehow equivalent to the Shift'' solution (except I wrapped the pair in a DataType). However, I didn't think of a sum type which is indeed interesting."
haskell,3ar8la,Cosaquee,6,Mon Jun 22 21:25:14 2015 UTC,"The main point of the Haskell IO system is that it encourages you not to put things that do input and output into a ""pure"" function. A pure function is one that transforms data, like yours that describes how a set is transformed into its powerset. An IO function is one that describes an ""action"" that a computer performs, where it interacts with the outside world. The Haskell approach is that it is best not to mix those two aspects of your programs.  The IO part of your program starts with the magical IO function called main. The action described by that function is run when your program is run. The pure parts of your program are functions whose types do not include IO. IO functions, like main, can call other IO functions and also pure functions. Pure functions only call other pure functions - to keep things pure. The type system helps you maintain that invariant by causing the compiler to report an error if you violate it by mistake.  So rather than ""making input possible"" in your pure function, the natural way of accepting that input style would be to write a separate function - an IO function - to read the input list in the style that you want. Then, in main, you call that function, feed the result to your pure function to do the actual calculation (the pure part), and then print the final result.  See the post of /u/Tekmo for a few good examples of how to write that input function.  EDIT: In Haskell, ""code golf"" usually focuses on the pure part of the program. You then run the function at the GHCi prompt, or write a separate wrapper function that does the IO and doesn't count towards the golf score. But if you need to count also the IO as part of the golf score, there are techniques like using interact, >>=, etc. to make your IO code more terse, and you can inline your pure code inside the IO code."
haskell,3ar8la,yitz,4,Tue Jun 23 10:31:12 2015 UTC,"You can write the loop by hand, like this:  import System.IO (isEOF)  readInts :: IO [Int] readInts = do     eof <- isEOF     if eof         then return []         else do             n  <- readLn             ns <- readInts             return (n:ns)   If you prefer a more high-level solution you can use pipes to fold the input stream into a list:  import Control.Foldl (purely, list) import qualified Pipes.Prelude as Pipes  readInts :: IO [Int] readInts = purely Pipes.fold list Pipes.readLn"
haskell,3ar8la,Tekmo,3,Mon Jun 22 22:15:54 2015 UTC,"You might like to look at the interact function:  p :: [Int] -> [[Int]] p = filterM (const[True, False])  main = interact (show . p . read)   interact takes a function from Strings to Strings and turns it into a program which reads stdin, passes it to your function, and returns the output to stdout:  $ echo ""[1,2,3]"" | runhaskell Main.hs [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]   It can be very useful for wrapping pure functions for use on the console like this.  To get the behavior you initially asked for, consider using the lines function to break stdin on line boundaries."
haskell,3ar8la,paf31,3,Mon Jun 22 22:11:07 2015 UTC,I generally do something like  main = fmap (map read . lines) getContents >>= print . solve
haskell,3ar8la,sccrstud92,1 point,Tue Jun 23 01:09:02 2015 UTC,"unrelated to your question, better to remove the where clause in your first definition and replace each xss with its definition. recalculating is better than retaining huge lists in memory, on bigger inputs; and on smaller inputs it doesn't matter."
haskell,3aocgy,hamishmack,1 point,Mon Jun 22 04:12:12 2015 UTC,sounds cool but what's it mean?  EDIT the readme: https://github.com/leksah/leksah/blob/master/xobl/Readme.md
haskell,3aocgy,sambocyn,2,Tue Jun 23 21:50:25 2015 UTC,sounds cool but what's it mean?   The title was of this post was a bit strange for a reason but no one has pointed out why.  Perhaps no one noticed.  I have updated the readme.  I'll be making a how to screen cast once VirtualBox 5 is out.
haskell,3anz7x,fuzzyslippers42,15,Mon Jun 22 02:02:31 2015 UTC,"I am one of the Leksah devs and we would love to have Lighttable like features in Leksah.  This is as close as we get right now.  It would be great if someone could extend this.  This is probably a good place to start.  We would also love to have a an editor written in Haskell.  Leksah currently relies heavily on GtkSourceView (which is written in C).  We have some proof of concept integration for CodeMirror (JavaScript) and Yi (Haskell).  Whatever you decide we should be able to integrate it into Leksah with WebKitGTK+, but if it was me I would work on a UI for Yi using GHCJS.  The existing Yi UI modules are here."
haskell,3anz7x,hamishmack,3,Mon Jun 22 03:47:14 2015 UTC,"Have you considered using wxHaskell? It provides the wxAUI component (I added it to wxHaskell myself).  I've built a small editor using it and reactive-banana-wx.  So far it opens/closes/saves and highlights Haskell files and displays files to open in a tree layout.  The editor (wxStyledTextCtrl) is Scintilla based and so it provides highlight/autocompletion features, etc. (I just dont make use of them yet).    I can open up access to the code if anyone is interested, I don't have the time to put any real work into it myself.  It is setup to use Nix or Cabal for the build so it isn't difficult to setup the environment to play with the code. It is working on windows or linux too and has the native wx look.  wxAUI Demo Vid."
haskell,3anz7x,cessationoftime,3,Mon Jun 22 16:54:10 2015 UTC,"The wxAUI stuff looks nice.  If someone wants to port Leksah to wxHaskell they are welcome to (as long as it does not loose any significant functionality).  As a first step, it would be nice to have native looking file open and save dialogs and that should be easy to add without changing the rest of the code base over.  Next step might be to make sure we have a way to manipulate the DOM of a wxWebView from Haskell.   Basically we need the wx version of this https://github.com/gtk2hs/webkit/tree/master/Graphics/UI/Gtk/WebKit/DOM.  It might seem daunting, but all this code is generated from the IDL files.  So as long as someone can work out what is needed, we can update the generator and output all the Haskell wrappers from the IDL files using the same generator."
haskell,3anz7x,hamishmack,3,Tue Jun 23 04:01:15 2015 UTC,I may go ahead and set up the open/save dialogs. Do you prefer I use plain wxHaskell or wxHaskell + reactive-banana-wx?
haskell,3anz7x,cessationoftime,3,Tue Jun 23 12:11:50 2015 UTC,Beggars can't be choosers :-)  Plus I don't feel like I know enough about wxHaskell or reactive-banana-wx to have a valid opinion.  So feel free to use or not use reactive-banana-wx.
haskell,3anz7x,hamishmack,10,Tue Jun 23 12:53:39 2015 UTC,You could also try Reflex.
haskell,3anz7x,tejon,2,Mon Jun 22 03:04:35 2015 UTC,That could be interesting. Do you have experience with it?
haskell,3anz7x,ryantrinkle,13,Mon Jun 22 03:31:55 2015 UTC,"I think Reflex (disclosure: I'm the author) would work really well for your situation because of one key feature: you can build desktop apps with it, not just in-browser apps.  This means that you can access the file system and do everything else you'd normally do with a text editor, but you can use DOM, including whatever javascript libraries you need, to render the GUI.  Also, I think you'll find that Reflex provides an idiomatic Haskell experience through-and-through.  The layout works basically like Blaze or Lucid, except that you can get stuff back when you build an element - a click event, for example, from a button.  Then, you can use these results to do whatever you need to in your app.  Use of Reflex is growing.  Since the release about 3 months ago, I've been very happy to see a variety of projects built by others, including markup.rocks, which uses pandoc to translate between document formats as you type.  Our chatroom, #reflex-frp on irc.freenode.net, has grown to about 30 people, many of whom will be happy to help you out if you get stuck."
haskell,3anz7x,Saulzar,2,Mon Jun 22 04:43:53 2015 UTC,"I was looking into it. What would you say are advantages offered over something like, say, ghcjs-dom?"
haskell,3anz7x,ryantrinkle,4,Mon Jun 22 05:37:14 2015 UTC,"ghcjs-dom is a very low level bindings to the JavaScript DOM, reflex-dom is a much higher level abstraction. You don't deal with adding/removing Elements, you deal with higher level primitives from FRP, (e.g. Events, Behaviors), connect it all up and reflex-dom handles all the dirty low level (error prone) manipulation for you."
haskell,3anz7x,BethAr,3,Mon Jun 22 09:35:22 2015 UTC,"As /u/Saulzar correctly pointed out, reflex-dom is high-level, whereas ghcjs-dom is low level.  ghcjs-dom is essentially a direct binding to the W3C DOM.  reflex-dom, on the other hand, translates all of that into an FRP-based GUI framework.  With reflex-dom, you can always invoke direct ghcjs-dom or even JavaScriptFFI commands if you need to, but it shouldn't be necessary 99% of the time."
haskell,3anz7x,ryantrinkle,2,Mon Jun 22 09:39:07 2015 UTC,"Looking at markup.rocks, I think I might end up choosing reflex + reflex-dom. In your opinion, are there any areas where reflex(-dom) falls short or any reasons not to use them?"
haskell,3anz7x,tejon,3,Mon Jun 22 15:22:01 2015 UTC,"Another recommendation for Reflex.  It works really well if you use the GHCJS backend. I can't comment on the GTK backend, because our project is targeting Windows, but even on Windows I found trivial to build a desktop web view to serve the generated JS application.  You can use Qt to build a simple browser and serve your application on Windows, and use the GHC/GTK backend to serve it on the other platforms."
haskell,3anz7x,takhallas,2,Mon Jun 22 18:57:11 2015 UTC,"Not that I know of - and if there are any, I'll fix them!  Before Reflex was released publicly, it was already in use commercially, e.g. at Soostone, which rebuilt its Telescope analytics platform with Reflex and Reflex-DOM.  My company, Obsidian Systems does most of its work in Reflex, as well.  So, I don't think there are any major snags at this point.  However, there's still lots of room for improvement and growth, so I hope you'll let me know how things go for you, and how I can improve Reflex going forward!"
haskell,3anz7x,cies010,3,Mon Jun 22 23:25:05 2015 UTC,"Not yet, but it's high on my to-do list."
haskell,3anz7x,cies010,1 point,Mon Jun 22 03:34:24 2015 UTC,"There's an IRC chatroom for reflex, and people there seem pretty helpful. #reflex-frp"
haskell,3anz7x,jkozlowski,7,Mon Jun 22 04:35:41 2015 UTC,"I think GHCJS is currently a more future proof choice than Fay. And as mentioned here by others: there is an editor called Yi of which the implementation relies very little on things outside Haskell, maybe it could be made to compile to JS with GHCJS?"
haskell,3anz7x,pycube,3,Mon Jun 22 06:15:05 2015 UTC,"Another way to approach this might be to extends FPComplete's source viewer utility (which already uses GHCJS) with editing capabilities.  (on mobile, excuse me for no link)"
haskell,3anz7x,theonlycosmonaut,2,Mon Jun 22 06:17:36 2015 UTC,"This is more of an experiment for myself than anything else, and I'd really like to be doing more of ""my own thing"", rather than screwing with an existing codebase or forking an existing project."
haskell,3anz7x,apfelmus,5,Mon Jun 22 06:29:12 2015 UTC,I am dabbling with porting ace (http://ace.c9.io/) to GHCJS (using https://github.com/ocharles/Francium) in my spare time (https://github.com/jkozlowski/hace). I can really recommend this approach at the start: it means I only have to produce the correct markup (the interesting bit for me) and just apply their css and templates (the black magic to me) and things just look good.
haskell,3anz7x,conklech,4,Mon Jun 22 09:24:37 2015 UTC,"If you only care about an UI extensible in a UI-description language and that can be scripted with Javascript, one option that you could also look into is QML, for which there exists a haskell binding called hsqml. QML lets you describe your UI in a json-like language, and you can use javascript in QML to perform more complex tasks. The hsqml library allows you to expose any haskell function to QML, where you can then call it from javascript. The advantage of this would be that you have access to all native desktop widgets (using QtQuick.Controls) and if you need better performance, you can even write your own widgets in C++ (which might be useful for the main text view, which would be pretty performance critical I assume)."
haskell,3anz7x,apfelmus,3,Mon Jun 22 15:48:46 2015 UTC,"I have very brief experience with Fay and Threepenny, but based on those I'd say go with Threepenny. For me, Fay was a nice idea but hampered by needing its own packages and only being a subset of Haskell. With Threepenny, you're actually writing Haskell and don't have to modify your build process, etc."
haskell,3ankox,begriffs,4,Sun Jun 21 23:45:20 2015 UTC,Really upset that I missed this. Were any of the other talks recorded?
haskell,3ankox,MaxGabriel,10,Sun Jun 21 23:59:18 2015 UTC,"All but two, and I'll be posting them as I edit them.  The two missing ones are Ryan Orendorff and Greg Weber. (The rechargeable batteries for my wireless mic failed.)"
haskell,3ankox,cdep_illabout,5,Mon Jun 22 00:20:37 2015 UTC,"I'm not living in the bay area, so I really appreciate that you are taking the time to edit and post the videos.  I'll be looking forward to them!"
haskell,3ankox,spindakin,2,Mon Jun 22 02:49:22 2015 UTC,"Oh, wow, this was close by. Wish I'd know about it! Will there be another next year?"
haskell,3ankox,liberalogica,4,Mon Jun 22 08:57:05 2015 UTC,"Yeah, should be back next year in May or June. There is also a Haskell meetup gaining momentum in SF. Keep a look out here to see when the next meeting will be. http://www.meetup.com/Bay-Area-Haskell-Users-Group/"
haskell,3ankox,b00thead,2,Mon Jun 22 17:55:58 2015 UTC,"The possibility of distributing Haskell to the client side using Electron is exciting, but i did not really get how it works. As far as i can see in the docs, Electron will help just for building apps based on Javascript"
haskell,3ankox,jhedev,2,Mon Jun 22 09:57:55 2015 UTC,Do you have a link for electron?
haskell,3ankox,liberalogica,2,Mon Jun 22 11:16:31 2015 UTC,I think it's this one.
haskell,3am0qa,rpglover64,8,Sun Jun 21 15:22:45 2015 UTC,"By the way, the Show (a -> b) instance defined in this post can be found in the Text.Show.Functions module from base (if you really want it)."
haskell,3am0qa,RyanGlScott,9,Sun Jun 21 15:58:07 2015 UTC,"There is also a more capable instance in Data.Universe.Instances.Show, which is re-exported from the top-level package by Data.Universe.Instances.Reverse (the latter also includes Eq, Ord, Read, and Traversable instances for functions)."
haskell,3am0qa,dmwit,1 point,Sun Jun 21 18:14:47 2015 UTC,which you shouldn't. (maybe except when debugging)
haskell,3am0qa,ibotty,2,Sun Jun 21 17:26:05 2015 UTC,How come?
haskell,3am0qa,radix,10,Sun Jun 21 20:14:16 2015 UTC,"a well behaved Show instance has a coresponding Read instance where read . show aught to be id  of course this is frequently not followed. polymorphic ""stringify"" functionality is frequently abused across language communities"
haskell,3am0qa,Xenophyophore,10,Sun Jun 21 20:38:36 2015 UTC,"I think that Python actually did this right, with a string and a repr function, the former of which produces a human-readable representation, and the later of which uniquely identifies the object."
haskell,3am0qa,Peaker,3,Sun Jun 21 22:02:25 2015 UTC,repr also usually results in the original object when passed to eval.
haskell,3am0qa,Xenophyophore,2,Mon Jun 22 00:57:53 2015 UTC,"Not by default. By default, __repr__ generates a string like: <object at address>.  Note that most Python objects are mutable and have identity so they can't easily have this read.show identity which is easy in Haskell."
haskell,3am0qa,hastor,1 point,Mon Jun 22 08:49:00 2015 UTC,"For built-in types like string, int, float, list, dict, etc., it does work."
haskell,3am0qa,Buttons840,2,Mon Jun 22 20:00:11 2015 UTC,"I don't see how you can write this well behaved Show for any circular structure without including loop detection.  Any magic reference, like what is used in common lisp is invalid according to the Show documentation, so your well behaved Show instance would actually not be well behaved."
haskell,3am0qa,fridofrido,2,Mon Jun 22 05:36:27 2015 UTC,Why not put show and read in the same typeclass then?
haskell,3am0qa,ninereeds314,1 point,Mon Jun 22 20:26:45 2015 UTC,"of course this is frequently not followed   I believe that's because there isn't a separate pretty-printing class (say Pretty) in the base library, which there should be, and ghci should default to that instead of Show when it exists (and should fall back to Show when it does not).  (I see below that python does something similar)"
haskell,3am0qa,Drupyog,7,Wed Jun 24 13:03:36 2015 UTC,"I cannot with all intellectual honesty remember wanting a heterogenous list   Arguing only against this specific point (because existentials are AFAICT a perfectly good solution provided you genuinely need them, though I don't really have the practical experience) I'm betting the dynamically typed example is just that - a simplified example just to make the point that it can be done.  For actual need, I've certainly needed in C++ an OOP ""heterogenous"" container - all elements (or more likely the values they point to) share the same base class and therefore the same interface though they may have been constructed as derived classes. A simple example would be some kind of document - an item placed as a character may be an actual character, a bitmap image, a vector image etc. This is of course very similar to the existential type version - and statically typed.  Then moving to a dynamically typed language, if it quacks like a duck it's a duck. You don't necessarily need a shared base type, you only need that the elements share the parts of the interface that you actually use. It's still basically the same thing, just without the explicit relationship between types and compile-type checks.  So there is a need. If there wasn't, there'd have been no need to invent existential types in Haskell. Though on the other hand the need is unusual enough that Haskell 98 made do without existentials."
haskell,3am0qa,ninereeds314,3,Sun Jun 21 21:14:17 2015 UTC,"The thing is, you can do that with subtyping and/or structural subtyping. You don't need an heterogeneous list for this example."
haskell,3am0qa,technicolorNoise,7,Sun Jun 21 22:09:08 2015 UTC,"That's what I was trying to say - hence the example where I mentioned using it was a C++ subclassing example - except that typeclass inheritance in Haskell doesn't actually support these heterogenous containers by default. It has other advantages that OOP doesn't have instead. Which is why existential types (and higher rank types and a few other things) were invented.  The existential types section of the GHC manual explicitly says that ""What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way."" (my emphasis). An explicit goal of Haskell is to make the type system more powerful (without over-complicating it - though that's subjective, of course) to minimize the cases where the type system is an obstruction to getting the job done.  AFAIK no-one is claiming that Haskell is doing something no other language can do. OOP had a neat trick that Haskell didn't, so Haskell adapted it and adopted it (though the adapting was originally done in other languages as the GHC manual says).  BTW, subtyping doesn't avoid creating a heterogenous container - it's a way of creating a heterogenous container very similar to existential types. The individual elements have varying constructed-as types (the subtypes) even though they share the same interface/base type. That's why pointers/references to the elements are needed - because the individual elements don't have the same types, therefore don't have the same in-memory representations, so can't fit in fixed-size slots in a flat lump of memory as with a homogenous C array or C++ std::vector.  Existentials defer an aspect of type resolution to runtime using a virtual table (or some other implementation that achieves the same thing) that ""travels with the object"" - just like OOP. About the only difference is that in Haskell you can only inherit interface, not implementation inheritance, so - unlike C++ or Java - the style rule that you should prefer composition to inheritence (referring to inheritance of implementation) must always be followed.  Actually, existential types are often considered an anti-pattern in Haskell. My guess about why is that they're often over-used by people from an OOP background. Higher-rank types are claimed to be a better option for things that seem to need OOP (though they can't do heterogenous containers) and even the need for those, outside a few already-written libraries, is rare enough that I don't have much experience with those either.    I'm going to stop constantly changing this now."
haskell,3am0qa,conklech,3,Sun Jun 21 22:48:00 2015 UTC,"I'm a Haskeller for a hobby and work in Java professionally. So I use heterogenous containers where every element implements some API often, ex. HashMap<IndexEntry, SerializableRecord>, where SerializableRecord is a Java interface or superclass. What exactly is a higher rank type, and what does it do to solve this problem in a different way than existential types?"
haskell,3am0qa,ninereeds314,2,Mon Jun 22 02:56:31 2015 UTC,"Idiomatic Haskell doesn't use superclasses the way Java does. Normally, if we want to capture a finite universe of types within SerializableRecord, we'd do it the other way around, with a sum type:  data SerializableRecord      = UserRecord User     | EntryRecord Entry     | ...   Which allows us to distinguish the ""subtypes"" User, Entry, etc. using normal pattern matching.  Existentials (which are different than higher-rank types) provide another approach to this. We can make an existential type using two different syntaxes:  data Ex = forall a. Ex a data Ex where Ex :: a -> Ex   In both cases, a value of type Ex can contain anything: Ex ""string"" and Ex 3 and whatever else are fine. But the flip side is that a value of type Ex is basically useless to a consumer: you can't write a function of type Ex -> a because that would explode the type system.  Instead, you can add constraints to the existential; unwrapping the existential allows you to use the constraint. So with data Showy= forall a. Show a => Showy a, you can write f (Showy a) = show a, which has type Showy -> String. Similarly with fancier things. Adding Typeable or Dynamic to the mix allows you to do more things. See the GHC documentation on existential quantification for more general info.  The usual question with existentials is: why am I storing an existential rather than the data exposed by the constraint? For instance, [Showy] adds nothing to [String]; the only thing you can do with a Showy is convert it to a String, so why not just store a list of strings? Remember, because of laziness you can populate a list with a bunch of potentially-expensive operations that yield strings without paying the cost until and unless the result is demanded.  Higher-rank types allow inversion of control in polymorphism. This is potentially relevant to the present discussion, but I've run out of typing time."
haskell,3am0qa,ninereeds314,1 point,Mon Jun 22 19:51:33 2015 UTC,"I only just found this - the default way of keeping the set of operations open for extension but closing the set of types/classes/kinds/???s of values. I can't believe I was advocating a visitor-like pattern based on higher-rank types - the dangers of looking for a problem for a given solution rather than visa-versa, I guess."
haskell,3am0qa,conklech,1 point,Tue Jun 23 01:07:42 2015 UTC,"Previous reply deleted because I didn't read your comment properly.    OK, the SerializableRecord (if polymorphic) would be an existential type in Haskell - that HashMap is presumably a heterogenous container so you can't avoid that. But in OOP, because only each SerializableRecord instance knows which exact subtype it has, it also needs to implement all the functionality - potentially not on it's own, but it must be involved to resolve which actual subtype is involved. This means the set of operations that can be applied to SerializableRecord is mostly closed - determined by the interface to SerializableRecord itself.  This relates somewhat to the ""expression problem"" - the set of SerializableRecord subtypes is open so the set of SerializableRecord operations is closed. You can use a pattern to make the set of SerializableRecord operations open (such as visitor) but you tend to end up with a closed set of subtypes and/or a lot of clunkiness. Ultimately you run into the multiple dispatch issue.  Higher rank types allow you to pass a polymorphic function into your code that works for any SerializableRecord, providing a way to open the set of operations a bit, or at least to defer the responsibility for resolving them to the operation. It's really just a variant of the visitor pattern - you have a polymorphic operation instead of having to wrap operations in larger objects to get the polymorphism. It's not a magic solution to the expression problem, but it's an option for solving some problems in that space.  You could, of course, also fairly directly translate the visitor pattern using an existential type for your operation object, so the actual operation(s) are accessed via a typeclass interface. Maybe that could be the right thing in some cases, but in general it's probably a writing-Java-in-Haskell smell.    WARNING - The visitor stuff here at best needs caution, with maybe a very narrow case where it's justified but I'm not sure. The visitor pattern is generally a bad idea in Haskell because you don't need a design pattern to have an open set of operations but a closed set of not-exactly-subtypes - that's what algebraic data types give you anyway. Oops."
haskell,3am0qa,ninereeds314,1 point,Mon Jun 22 13:04:17 2015 UTC,"You don't necessarily need a shared base type, you only need that the elements share the parts of the interface that you actually use.   I'm not sure whether you're talking about some other language or about Haskell here, but in Haskell there are a bunch of idiomatic ways to capture exactly that without existentials. See Luke Palmer's Haskell Antipattern: Existential Typeclass article, for instance, although there are probably better and more recent explications."
haskell,3am0qa,ninereeds314,1 point,Mon Jun 22 19:21:11 2015 UTC,"That part is moving from C++ (the previous paragraph) to a dynamically typed language, so it's not about Haskell.  There's no such thing as base types in Haskell - a typeclass is not a type.  I've already referred to existentials being considered an antipattern with e.g. higher rank types being a common suggested alternative, but thanks for that link - I don't think I've seen that before."
haskell,3am0qa,conklech,1 point,Mon Jun 22 20:40:20 2015 UTC,"Actually, that article isn't very convincing to me.  Yes, you always have the option to pass around the relevant functions (effectively to build and pass around DIY vtables) manually. That applies to higher rank types too, and even plain old Haskell 98 typeclasses, not just existentials. It's a tool in the toolbox of course, ML programmers and even C programmers do it quite a bit, I'm sure it's sometimes the right thing to do even in Haskell.  There's even a view in some quarters that typeclasses are only necessary for the IO-like special cases, and should never have been used for anything else. Why have a Show class if you can just pass the show function you mean everywhere along with the data you might want to show?  But it's also doing work manually that the compiler can do for you. Of course for the compiler to do that work for you, you have to do other work instead - e.g. passing an explicit vtable argument is probably neither easier nor harder than specifying a typeclass constraint at least for the basics. I personally still bias that trade-off in favor of using language-provided abstractions rather than the DIY vtables approach."
haskell,3am0qa,ninereeds314,1 point,Mon Jun 22 21:57:15 2015 UTC,"typeclasses are only necessary for the IO-like special cases   I've never heard that. The common argument is that typeclasses are only appropriate for operations with laws, like Monad, Applicative, Functor, and the like.  Show is a convenience class. I always use it in examples because it's extremely straightforward. Its use outside of teaching and debugging is deeply questionable. It's only relevant to the existential-container discussion because data Showy = forall a. Show a => Showy a is easy to understand.   But it's also doing work manually that the compiler can do for you. . . . passing an explicit vtable argument is probably neither easier nor harder than specifying a typeclass constraint at least for the basics.   Both typeclass instances and passing around existentials pose nontrivial barriers to understanding. Instance resolution errors are the bugbear of new Haskellers, and understanding what's in scope on the RHS of an existential pattern-match is not always easy. Luke Palmer's examples are all monomorphic, which makes things very easy: the compiler can give you excellent errors.  Your comment about ""passing around vtables"" is perhaps on another subject.  Note that the example record type in the article is not a vtable: it's a collection of actual (lazy) values. Perhaps you are thinking of the periodic discussions about passing around Ord and similar dictionaries manually, to get around the global uniqueness of instances?"
haskell,3am0qa,conklech,1 point,Mon Jun 22 22:28:23 2015 UTC,"Both typeclass instances and passing around existentials pose nontrivial barriers to understanding.    All nontrivial abstractions pose nontrivial barriers to understanding - every abstraction has to be learned. Nevertheless, working with abstractions is a fact of life.   and understanding what's in scope on the RHS of an existential pattern-match is not always easy.   I'm not arguing that existentials should be used everywhere - heterogenous containers are one very specific use-case. For other problems, preferring alternative approaches using higher rank types or ordinary rank 1 types is also an option, and that doesn't mean I'm advocating ad-hoc polymorphism everywhere either.   Note that the example record type in the article is not a vtable: it's a collection of actual (lazy) values.   EDIT Oops - I actually managed to reply to that still without noticing a key fact.  You're correct - that's not really a vtable approach. It's still carrying around function pointers that are managed manually, though, which you have to do for every bit of functionality that varies based on the widget ""class"", so it's not that different from a vtable - it's as if you merged the object with the vtable.  That means you can vary functionality based on which instance of the Widget you're dealing with, even when it's meant to be the same kind of Widget. I'll assume the data constructor and field names aren't exported from the module in practice but, even so, that's usually more power than you'd want, meaning that in the common case where every instance is meant to render the same way that intent isn't so directly obvious and it's possible you could have the wrong render function for some instances by accident.   Luke Palmer's examples are all monomorphic, which makes things very easy: the compiler can give you excellent errors.   Yes, of course, but potentially at a price. A similar argument could be made for providing explicit type signatures for everything - you get better error messages because the inconsistency gets detected immediately, instead of some time later when the inferred types filling the gaps are eventually found not to work. The cost/benefit ratio still isn't in favor of going to that extreme.  If nothing else, using the language-provided notation for typeclasses makes it clear that your intent is to model classes of types. An arbitrary ADT can do anything that an arbitrary ADT can do, so doesn't in itself express any particular intent beyond packaging up some values.  Of course push that argument too far and the language has to specific constructs for every possible abstraction you could need, a bit like those daft game-programming BASICs that have specific built-in commands for everything instead of supporting libraries.  Basically, I accept that the manual-vtables approach has merit but I don't believe in the single all-purpose absolute and my bias is still towards using typeclasses, which also has merit. Though that certainly doesn't mean I'm advocating existentials everywhere."
haskell,3am0qa,beerdude26,8,Mon Jun 22 23:21:49 2015 UTC,It's perhaps worth noting that with Data.Typeable you can perform genuinely heterogeneous operations on list elements by stuffing everything into an existential constrained by Typeable and using cast or eqT to inspect the type of each element.
haskell,3am0qa,AndrasKovacs,4,Sun Jun 21 21:14:55 2015 UTC,Haskell: a better PHP.
haskell,3am0qa,Kaidelong,11,Mon Jun 22 06:20:45 2015 UTC,"Where this comes to bite me (that is, where Haskell's restriction bothers me) is purely syntactic:  Sometimes, I want to write something like map show [1, 'a', ""b""] instead of [show 1, show 'a', show ""b""]. I almost wish there were an -XEphemeralHeterogeneousLists extension (almost because it's definitely not worth the development effort) for this case."
haskell,3am0qa,josuf107,9,Sun Jun 21 15:27:24 2015 UTC,"Here's my try. It's not very pretty, but at least it has O(1) syntactic overhead in the length of the list:  {-# LANGUAGE   RankNTypes, TypeFamilies, ConstraintKinds,   GADTs, TypeOperators, DataKinds,   PartialTypeSignatures, ScopedTypeVariables #-}  import GHC.Exts import Data.Proxy  data HList ts where   Nil  :: HList '[]   (:>) :: t -> HList ts -> HList (t ': ts) infixr 5 :>  type family All c ts :: Constraint where   All c '[] = ()   All c (t ': ts) = (c t, All c ts)  hmap :: forall c ts r. All c ts => Proxy c -> (forall t. c t => t -> r) -> HList ts -> [r] hmap _ f Nil = [] hmap _ f (x :> xs) = f x : hmap (Proxy :: Proxy c) f xs  main = print $ hmap (Proxy :: _ Show) show (2 :> ""foo"" :> () :> Nil) -- [""2"",""\""foo\"""",""()""]"
haskell,3am0qa,kqr,6,Sun Jun 21 20:26:15 2015 UTC,"What about -XRebindableSyntax? I can imagine perhaps allowing something like [1, 'a', ""b""] (each show) at the expense of also having to write things like [1,2,3] list by changing cons into something that builds up a higher order function."
haskell,3am0qa,josuf107,6,Sun Jun 21 17:18:54 2015 UTC,"Another option is a local binding to help you out:  myWeirdList = 1 *: Just 3 *: Blue *: ""banana"" *: []     where         a *: b = show a : b         infixr 5 *:   I think *: is only slightly worse than typing a comma, and defining functions as operators seems more the intended use of Haskell. To me this is clear to read, easy to type, and requires no extensions or Jedi type tricks."
haskell,3am0qa,Roboguy2,2,Mon Jun 22 04:27:47 2015 UTC,"What I like about typing [1, Just 3, Blue, ""banana""] over your example is that my editor is very good at manipulating text inside various kinds of parentheses, including brackets. My editor does not understand that everything held together by *: is one unit."
haskell,3am0qa,chrisdoner,5,Mon Jun 22 06:55:45 2015 UTC,"I assume you would put it in parentheses in most cases. The list sugar doesn't really seem to buy you all that much:  [1, 2, 3, 4]        -- is the same as... (1: 2: 3: 4: []) -- except that you can judiciously replace the (:) mapM_ putStrLn (1*: Just 3*: Blue*: ""banana"": []) -- note you can also cheat and you use different combiners for different elements   The main complaint I would expect would be having to type out the [] manually. But if you have a long list and you want to change the way you're combining elements, it seems like the extra explicitness might be worth it.  I was thinking about this more, and the other downside seems to be operator binding. This requires knowledge of associativity and precedence (including of the common operators in base etc.), and I've heard complaints that operators are hard to read. But in this case where the binding is local I feel like the latter concern is mitigated by the fact that the definition is right alongside the usage. The former concern is more pressing, but thinking about it more, infix functions are a part of the design of Haskell, so it might be worthwhile to understand, define, and use them when appropriate. If they showed up more often, maybe fewer people would have to lookup how to choose and specify precedence and associativity (for instance, I had to lookup the precedence of (:)).  Edit:  One example of a precedence gotcha is that:  [1, 2, subtract 1 . (*2) $ 3]   is not the same as:  (1: 2: subtract 1 . (*2) $ 3: [])   As the comma in the list sugar has magically subzero precedence, but (:) has precedence 5, while ($) has precedence 0. So first 3:[] is evaluated to [3], then (subtract 1 . (*2)) is applied to it, which is a type error. So you'd want to write:  (1: 2: (subtract 1 . (*2) $ 3): [])   but for instance:  (1: 2: 3 - 2: [])   is fine because (-) has precedence 6. So order of operations really can be a pain. It helps to know that you can inspect the precedence and associativity of an operator using :info in ghci, and that parentheses are always fine."
haskell,3am0qa,Darwin226,5,Mon Jun 22 13:30:25 2015 UTC,"This actually isn't too bad with ConstraintKinds:  {-# LANGUAGE ExistentialQuantification, ConstraintKinds, RankNTypes #-}  data ConstrList c   = forall a. c a => a :> ConstrList c   | CNil infixr :>  constrMap :: (forall a. c a => a -> b) -> ConstrList c -> [b] constrMap f (x :> xs) = f x : constrMap f xs constrMap f CNil      = []  test :: ConstrList Show test = 1 :> 'a' :> () :> CNil   Then, constrMap show test gives you [""1"",""'a'"",""()""]  I was working on a package for dealing with containers with existential types a little while back. I should add this constraint stuff. You might be able to coax a polykinded Functor type class to handle all these cases in a uniform way (like in the hask package), but I haven't put too much work into that yet."
haskell,3am0qa,sccrstud92,10,Mon Jun 22 05:24:10 2015 UTC,"If you're considering it a syntactical convenience problem, the Lispy solution is e.g.  {-# LANGUAGE TemplateHaskell #-} import Language.Haskell.TH hmap name xsE = do   xs <- fmap flatten xsE   mapM (appE (varE name) . return) xs >>= return . ListE   where flatten (AppE xs x) = flatten xs ++ [x]         flatten x = [x]   And then:  λ> $(hmap 'show [| 1 'a' ""b"" |]) [""1"",""'a'"",""\""b\""""]"
haskell,3am0qa,dmwit,6,Sun Jun 21 17:23:18 2015 UTC,"But then I need to use Template Haskell in the module in question, which is a huge hammer and (annoyingly) prevents cyclic top-level definitions."
haskell,3am0qa,merijnv,12,Sun Jun 21 22:06:29 2015 UTC,"I think map show [1, 'a', ""b""] is also an example of valid programs that the type checker refuses. You could always say ""Yeah, but see, the list here isn't typically valid"", but does it matter? The type checker is preventing you to do something that you really should be able to."
haskell,3am0qa,tomejaguar,7,Sun Jun 21 15:56:22 2015 UTC,"Isn't there some way with a couple extensions to do something like  map show ([1, 'a', ""b""] :: [forall a. Show a => a])   ? I know that exact syntax doesn't work, but I thought I remembered seeing something like this."
haskell,3am0qa,_deepfire,6,Sun Jun 21 16:42:55 2015 UTC,"Not exactly. With sufficient extensions, you can write  data Box c = forall a. c a => Box a  onBox :: (forall a. c a => a -> b) -> Box c -> b onBox f (Box v) = f v  map (onBox show) ([Box 1, Box 'a', Box ""b""] :: [Box Show])   but by that time you're just repeating Box instead of repeating show and may as well just write  [show 1, show 'a', show ""b""]   which is shorter anyway and doesn't need any fancy types or extensions."
haskell,3am0qa,dnkndnts,2,Sun Jun 21 18:05:25 2015 UTC,"I've tried (I thought -XImpredicativeTypes might be the key), but I haven't succeeded."
haskell,3am0qa,PM_ME_UR_OBSIDIAN,5,Sun Jun 21 17:10:04 2015 UTC,"Word of warning: ImpredicativeTypes is broken as the underlying theory is an open question and no one is working on it. I've repeatedly suggested marking the extension deprecated, but no progress so far. At any rate, avoid writing new code using it if possible."
haskell,3am0qa,kamatsu,10,Mon Jun 22 08:19:09 2015 UTC,"In some sense you are correct.  On the other hand, for the kind of programs I write at least, it's probably a net loss to program correctness.  The number of cases where I do something theoretically sensible which was actually an error is probably greater than the number of times the compiler forbids something theoretically sensible, but practically impossible, that I actually wanted to do."
haskell,3am0qa,bss03,3,Sun Jun 21 16:04:05 2015 UTC,"Agreed. That doesn't make it less annoying when it comes up, though.  I think the right way to solve this would be metaprogramming (I expect that in a lisp with a type system like Haskell's, I'd just write a macro staticMap and the type checker wouldn't have to deal with it), but Template Haskell is an awfully big hammer for such a small problem."
haskell,3am0qa,kamatsu,2,Sun Jun 21 17:14:00 2015 UTC,"Not big, unwieldy I'd rather say."
haskell,3am0qa,PM_ME_UR_OBSIDIAN,3,Sun Jun 21 19:47:32 2015 UTC,"See, that's not a valid program, though. map is not merely a syntax extension: it has semantic meaning and semantic requirements.  If this annoys you, I have good news: it becomes exponentially worse with dependent types!"
haskell,3am0qa,kamatsu,3,Sun Jun 21 18:05:02 2015 UTC,"The problem here is lack of proper subtyping rather than having a rich type system. And guess what, subtyping belongs in dependently-typed languages too... Once we figure out how to make it work."
haskell,3am0qa,PM_ME_UR_OBSIDIAN,7,Sun Jun 21 18:37:46 2015 UTC,"The general consensus among the FPL community is that subtyping is a gigantic pain in the arse and, when combined with type inference (which can't be total due to subtyping) can cause type errors to appear substantially later than they would otherwise."
haskell,3am0qa,kamatsu,2,Mon Jun 22 02:16:19 2015 UTC,"You don't lose type inference when you add subtyping, it just statically types too many programs.  You can witness this in practice in Scala when the type inference infers either the initial or final type causing either a confusing static type error later in the program (best case) or a really confusing dynamic type error at runtime.  Allowing (sub-)structural subtyping of anonymous record types (and nominal subtyping of named record types where the underlying anonymous types are structural subtypes already) should still give you good results, mainly because of the lack of a top(final) or bottom(initial) type.  I think there's a powerful middle ground here, but it's still a research project.  Particularly if you start throwing dependent record types into the mix."
haskell,3am0qa,PM_ME_UR_OBSIDIAN,3,Mon Jun 22 16:38:15 2015 UTC,"You don't lose type inference when you add subtyping, it just statically types too many programs.   You lose complete, total type inference in the style of ML, certainly. Type inference for System Fsub is undecidable."
haskell,3am0qa,acow,1 point,Tue Jun 23 00:11:54 2015 UTC,"I like using an IDE with type-inferred languages so that I can easily check the types of my various terms. Type inference is to save you typing and make the code read more straightforwardly, but without an interactive environment it actively obfuscates your code.  In the context of a rich, interactive development experience, I think we could pull off subtyping. Even if type inference isn't total, you just need to nudge it in the right direction."
haskell,3am0qa,maxigit,3,Mon Jun 22 05:04:00 2015 UTC,"I think we could pull off subtyping.   Certainly. The question is, do you want to? Languages that have subtyping are a giant pain to work with formally."
haskell,3am0qa,sjoerd_visscher,1 point,Mon Jun 22 05:06:15 2015 UTC,"Languages that have subtyping are a giant pain to work with formally.   I haven't been exposed to that (because I don't know much about subtyping), do you have a good starting point for reading on the subject?"
haskell,3am0qa,smog_alado,1 point,Mon Jun 22 05:13:21 2015 UTC,How much PL theory have you studied?
haskell,3am0qa,sacundim,1 point,Mon Jun 22 05:13:48 2015 UTC,"I'm acquainted with data/codata, FOL, modal type systems, MLTT, basic model theory."
haskell,3am0qa,dllthomas,5,Mon Jun 22 05:17:11 2015 UTC,"There is tooling in Frames to do this via Vinyl records. It is used in the tutorial to apply methods from Num, but can of course be used for other purposes.  The one drawback to how this works today is the syntax of building the record, where Vinyl uses :& and RNil for the usual cons and nil values. If OverloadedLists ever gets fixed, we'll have the desired syntax, but will still need some fortuitous defaulting to deal with literals as in your example."
haskell,3am0qa,kqr,2,Sun Jun 21 18:34:12 2015 UTC,"Even though I agree it's inconvenient to not be able to do so, it looks like ""local"" syntaxic sugar to save some typing, instead of a real language limitation. Most of those ""hardcode"" heterogenous list would be better be a tuple. What you'll need then is something like  map3:: (forall s. s -> t)  -> (a, b, c) -> (t, t, t). map3 f (a, b, c) = (f a, f b , f c).   Unfortunatly, I don't think you can write this in Haskell at the moment."
haskell,3am0qa,chrisdoner,5,Sun Jun 21 21:47:22 2015 UTC,"Well, if, as /u/acow suggested OverloadedLists gets extended to handle heterogeneous lists, this stops being a problem."
haskell,3am0qa,conklech,1 point,Sun Jun 21 22:09:37 2015 UTC,"Just do show (1, 'a', ""b"")"
haskell,3am0qa,chrisdoner,3,Mon Jun 22 16:27:23 2015 UTC,"It’s contrived. I’ve written about as much Emacs Lisp and JavaScript as I have written Haskell and C#, and I cannot with all intellectual honesty remember wanting a heterogenous list.   The first example that comes to my mind is apply, which takes a variadic list as an argument. Its fairly common in Lisp and JS from my experience.   It’s ill-defined. What is this data structure? What can I assume about the elements so that I can write operations generically?   The Haskell equivalent of heterogeneous lists in a dynamic language would be a liist of an ADT with a tag for every possible type.   data Dynamic = DynInt Int | DynString String | ..."
haskell,3am0qa,conklech,3,Sun Jun 21 22:13:15 2015 UTC,"data Py = forall a. Show a => Py a instance Show Py where show (Py s) = show s  λ> map (\(Py p) -> show p) [Py 1,Py 'a',Py ""hello"",Py (\x -> x ** 2)] [""1"",""'a'"",""\""hello\"""",""<function>""]   ALERT: Existential Typeclass Antipattern sighted!  This is really no different from:  data Showable = Showable { show_ :: String, showsPrec_ :: Int -> ShowS }  showable :: Show a => a -> Showable showable a = Showable (show a) (flip showsPrec a)  λ> map show_ [showable 1, showable 'a', showable ""hello"", showable (\x -> x ** 2)] [""1"",""'a'"",""\""hello\"""",""<function>""]   ...which is in turn only a little little different from:  λ> [show 1, show 'a', show ""hello"", show (\x -> x ** 2)] [""1"",""'a'"",""\""hello\"""",""<function>""]   A list of things that you can only show doesn't afford anything that the lazy list of their show results doesn't!  As far as I can tell, existential typeclasses like these only add something if you throw Typeable into the mix (and perhaps a few things more)."
haskell,3am0qa,deech,3,Mon Jun 22 02:54:37 2015 UTC,"While I basically agree, syntactically I often find myself wishing I could factor out the repetition in [ show 1, show 'a', show ""hello"", show (\x -> x ** 2)]."
haskell,3am0qa,conklech,1 point,Mon Jun 22 06:05:07 2015 UTC,"Sure, but is the way to do that by replacing every instance of show with an instance of showable or for that matter with Py?"
haskell,3am0qa,tailbalance,3,Mon Jun 22 06:57:26 2015 UTC,"I'm aware of this post and didn't agree with it at the time it was posted. I don't see them equivalently. An existential carries with it capabilities, the record construct carries with it the results. They are different. The existential is open in the operations you are able to do, the record is closed. Consider:  {-# LANGUAGE ExistentialQuantification, StandaloneDeriving #-} data Py = forall a. (Show a,Num a,Ord a) => Py a deriving instance Show Py  λ> let xs = [Py 1,Py 2.0]   Construction is done.  Now I can, or more importantly, a user of my API, can write:  λ> map (\(Py p) -> show (if p>0 then p*2 else p+1)) xs -- I use a number of methods [""2"",""4.0""] λ> map (\(Py p) -> Py (p-1)) xs -- the type has not changed, it is still undetermined [Py 0,Py 1.0]   I.e. I freely choose the operations I'm going to apply. In the record encoding, you cannot express this because both the operations and the types need to be fully determined at the time of writing, you can only express the final step.  Additionally, combined with Rank-N types, you can have in your API a function like (forall a. (Show a, Ord a, Num a) => a -> a) to let people do transformations without ever knowing the actual type."
haskell,3am0qa,chrisdoner,1 point,Mon Jun 22 10:03:13 2015 UTC,"First: Isn't the distinction between ""capabilities"" and ""results"" illusory in the presence of laziness?  Second: The existential, in this case, is not ""open in its operations."" The existential in Py allows you precisely to use the class operations from Show, Num, and Ord, and nothing further. Nothing else would be typesafe, because we know nothing else about a. Why not implement a non-existential type, with unexposed constructor(s), that implements those classes?  module M (PyI) newtype PyI = PyI Int deriving (Show, Num, Ord)   Now a user can write the same functions, which only rely on class instances, simply without unwrapping the existential constructor:  (\p -> show (if p>0 then p*2 else p+1)) (\p -> p-1)   Furthermore they will get better errors.  Isn't the only difference that now you can rely on the knowledge that PyI contains an Int within the module, whereas in your example you were everywhere restricted to only the class methods? Edit 2: There's another difference, which may or may not be relevant. You can add two different PyI values together, but each existentially-wrapped Py is independent and can't be used together. If that behavior is desired, it can be restored with a phantom type variable.  (I agree that there are some situations where the existential is not an antipattern.)  Edit: I forgot that you wrote the article under discussion; maybe this comment would make more sense as a top-level reply."
haskell,3am0qa,Roboguy2,3,Mon Jun 22 20:05:44 2015 UTC,"First: Isn't the distinction between ""capabilities"" and ""results"" illusory in the presence of laziness?   No.   Second: The existential, in this case, is not ""open in its operations."" The existential in Py allows you precisely to use the class operations from Show, Num, and Ord, and nothing further.   Yes, you can only use the methods, and all the functions defined in terms of those methods, which adds up to a few dozen. Those are the capabilities I can choose between. I can pick which ones I'm going to use, in what order, if at all, and keep the value of the same type, or change it. I'm free to do that. That is what open means. My examples above demonstrate that, although evidently not well.   Why not implement a non-existential type, with unexposed constructor(s), that implements those classes?   Because now I have to decide ahead of time what the type will be. This misses the purpose of using an existential type in the first place, which is that I don't know what type it is."
haskell,3am0qa,conklech,1 point,Tue Jun 23 07:46:27 2015 UTC,"My concern in this discussion is simply that the benefits of these heterogeneous containers are very precise and limited, and generally don't align with how programmers coming from Java or other languages expect subtyping to work. See other threads on this post. I know you're not confused; I'm disputing your claim that it's not an anti-pattern. (""Anti-patterns"" are appropriate in the right circumstances, as I understand the term.)   I can pick which ones I'm going to use, in what order, if at all, and keep the value of the same type, or change it.   Oh, I see what you mean: we can unwrap Py (1 :: Int) and put back Py (2 :: Float).  But we can't do much useful with the constraints in your example, (Num a, Ord a, Show a), because the operations in those typeclasses can't produce anything but a or String. (Or Ordering/Bool, if we have a second value of type a, which we can only get via fromInteger.) So there's not really any sensible operation Py -> Py that takes advantage of that capability: one way or another you're either generating an entirely new value to put in the existential, or you have to keep the internal type the same.   That is what open means. My examples above demonstrate that, although evidently not well.   I'm sorry to be obtuse. My point isn't that your examples do or don't have open capabilities, but rather that operations on Py or [Py] values are strictly less open than on my PyI or on ordinary Double/[Double].  Consider [Py (1 :: Int), Py (2.3 :: Double)]. The only way to distinguish that from [Py (1.0 :: Double), Py (2.3 :: Double)] is by the difference in the string produced by show, and potentially by floating-point precision artifacts. That seems like a pretty narrow benefit, compared with using [Double] or (Int, Double) or a extensible record type.  As you note, the only additional openness is at the initial creation of the value. The results of that choice are then almost completely hidden within the type system; only the instances of the constraint classes can distinguish the type.  (The situation is totally different once Typeable comes into play.)   This misses the purpose of using an existential type in the first place, which is that I don't know what type it is.   I don't think I'm missing the point so much as arguing that you can often (not always!) address it without existential quantification, and that doing so is easier to reason about. There's always some point A, at which you know whether you want to put a Double or an Int in. At point B, there's some different behavior resulting from that decision; whether or not trailing decimals are displayed, let's say. If you want to preserve that distinction, I'd say to produce [(Double, Bool)] at point A, and use the Bool to decide whether to include trailing decimals.  Then between point A and B you have a lot more flexibility; you can change your mind, you can unzip the list and use fast vector operations, and you don't run any risk of having to think about skolems. It's more open."
haskell,3am0qa,conklech,3,Tue Jun 23 18:39:14 2015 UTC,They're useful for binding to heavily OO APIs. I use type-level heterogenous lists to give the user something that feels like polymorphic dispatch. Not sure how I could have achieved that otherwise.
haskell,3am0qa,Die-Nacht,3,Sun Jun 21 17:40:59 2015 UTC,"Isn't that a homogeneous type-level list, i.e. the elements (types) all have the same kind?  It looks like you've implemented something closely related to vinyl/HList, which I think of as a wildly different beast than the heterogeneous list this post discusses. Values of these lists have fully determined static types, like tuples; nothing's hiding behind an existential."
haskell,3am0qa,TheCriticalSkeptic,3,Sun Jun 21 21:21:09 2015 UTC,… or you can use proper heterogeneous lists instead of the anti-pattern code in the article.
haskell,3am0qa,theonlycosmonaut,1 point,Mon Jun 22 09:02:34 2015 UTC,I don't think it's an anti-pattern.
haskell,3am0qa,ggchappell,1 point,Mon Jun 22 16:57:35 2015 UTC,"It seems like uses of existential quantification in Haskell are often called an antipattern and this assumption is usually not discussed further. I don't think it is the case that it is always an antipattern and I don't think that is what the antipattern article intended to say (I could be wrong on this particular point, but note that the title is ""Haskell Antipattern: Existential Typeclass"").  I think the antipattern happens when you attempt to force a OO-like API using a type class. There is a key difference between what is happening in the antipattern article and what is happening here: You need AnyWidget to pipe Widget types around but here, we add no difficulty to passing Show types around. In the antipattern, you also lose potentially useful information. Here, you keep exactly the information that you need (the fact that it is showable), no more, no less.  It seems to me that the problem has more to do with the type class than the existential quantification itself. Existential quantification is used there to work around the issues caused by using a type class instead of just using a product type.  On the topic of HLists, the size of an HList is fixed at compile time which adds additional restrictions. In this particular case, you also have to provide extra information beyond what you actually need: All you need to know here is that everything is showable. With an HList, you must give it all the specific types you will be using.  I'm not saying HLists aren't useful, but I don't believe they are the right tool to use here."
haskell,3am0qa,cghio,1 point,Mon Jun 22 17:20:54 2015 UTC,"I agree with /u/Roboguy2 that HList is a completely different beast. They're analogous to tuples, not lists, in that the length and element types of a any concrete value must be statically known."
haskell,3am0qa,Oremorj,1 point,Mon Jun 22 20:10:06 2015 UTC,"But unlike tuples, they can have a map defined on them generically.."
haskell,3am0qa,Tekmo,1 point,Tue Jun 23 02:44:54 2015 UTC,"Sort of. You can do a higher-kinded map, as in HList's HMap or vinyl's rmap. You can't fmap. There are numerous other helpful operations, but they're not the same as the operations on [] and other containers of kind * -> *."
haskell,3am0qa,imz,2,Tue Jun 23 02:58:33 2015 UTC,"A while back I wrote a way to do this in a more generic way (but it only works on typeclasses that have function that always take one param).   https://gist.github.com/pjrt/3b2231e323f5a557ebea  We did have a use for it, but not the way ppl usually see it (a heterogeneous list). The concept I was thinking was ""a typeclass list""."
haskell,3am0qa,tallagur44,2,Mon Jun 22 01:41:24 2015 UTC,"When I first started out in Haskell I really thought this was something that was missing. But the lack of sub-type polymorphism (is that the term?) isn't necessarily useful as far as I can tell.  For example in Java I might have List<SomethingFactoryAbstractorInterface> and I might want to perform some map over that list. The reason it works is because all of the concrete types in the list are mutable - so if I modify them via an interface, the object's representation in memory has mutated.  But in Haskell if I could perform map f someInterface over a heterogenous list that implements the same type class I can't get anything useful out of it. I won't be able to properly recover any of the concrete types.  The example in the blog post with show, what would be wrong with this?  data Foo = Foo Int Char String deriving Show  show Foo"
haskell,3am0qa,chrisdoner,2,Mon Jun 22 04:19:48 2015 UTC,But in Haskell if I could perform map f someInterface over a heterogenous list that implements the same type class I can't get anything useful out of it.   You get a list of whatever result type f has!
haskell,3am0qa,rstd,1 point,Mon Jun 22 06:07:09 2015 UTC,"Comments on the following would be appreciated.     An oft-stated argument against static typing is that heterogenous lists are unreasonably difficult to model.   That's not an argument against static typing; it's an argument for dynamic typing. The point is not that static typing makes heterogenous lists difficult to model; rather, lack of dynamic typing makes them difficult to model.  Static & dynamic typing are not two sides of the same coin. They are not alternatives from which we must make exactly one choice. They are very different things, which happen to be used to solve common problems.  Since they are so different, whether each is included in a PL is somewhat independent from whether the other is included. Some PLs (like ANS Forth) offer neither. Plenty of PLs offer one of the two. And there is no reason why a PL could not offer both.  Now look at this:   data Py = forall a. Show a => Py a  instance Show Py where show (Py s) = show s   And this:   λ> [Py 1,Py 'a',Py ""hello"",Py (\x -> x ** 2)]  [1,'a',""hello"",<function>]   Apparently Haskell is a PL that offers both static & dynamic typing -- at least with the ExistentialQuantification extension enabled.  That said, to make the type theorists happy, let's put it this way: Haskell offers both static typing and tags.    EDIT. A couple of notes.   If the above thoughts are sound, then it would seem that the article fails to achieve its purpose: showing that we can construct heterogenous lists using static typing. On the contrary, the given construction uses tags (dynamic typing); the heterogenous list is constructed essentially the same way as in the Python example. Other commenters have focused on the question of whether difficulty in constructing homogenous lists matters. I am not addressing this issue at all."
haskell,3am0qa,chrisdoner,1 point,Mon Jun 22 06:54:12 2015 UTC,"If you really need this, I would use Dyn and Typeable rather than existentials. Otherwise you're throwing out so much information...."
haskell,3am0qa,rstd,1 point,Mon Jun 22 14:34:08 2015 UTC,"That's exactly what you shouldn't do, IMO -- unless you have absolutely no other choice to get the API that you want. If you use existential types you can still rely on parametricty and that's worth quite a lot -- again IMO."
haskell,3am0qa,dllthomas,1 point,Wed Jun 24 10:31:28 2015 UTC,"You don't even need the Py data type.  Just wrap the values in ""show"""
haskell,3anckv,HighCode,22,Sun Jun 21 22:29:54 2015 UTC,"I've run a lot of people through learning Haskell.  For the time being, I don't recommend books precisely, rather, I recommend a couple of courses that you can do for free online.  My guide for learning Haskell lists what I'd suggest.  If you'd like some rationale, I have a post about this.  I am working on a book with my coauthor Julie who'd never programmed before learning Haskell but it doesn't cover as much as cis194 and NICTA Course yet. It'll be at parity in October. I wouldn't recommend our book yet unless you're up for a bit of adventure and would like to contribute feedback. That said, I do think the book is more thorough WRT the basics already and a fair bit easier than face-planting into the recursion exercises in week 1 of cis194.  Also, regarding cis194, I've gotten permission from Brent Yorgey to make a community edited cis194 course. I've started that at this git repo. Currently I am trying to get it flipped into an updated and relatively vanilla Hakyll project. I'm also using semantic-ui for the styling and grid. If anybody would be willing to help me with this, I'd very much appreciate it."
haskell,3anckv,Mob_Of_One,2,Sun Jun 21 22:40:39 2015 UTC,"Also, regarding cis194, I've gotten permission from Brent Yorgey to make a community edited cis194 course. I've started that at this git repo.   Some good news here!"
haskell,3anckv,cies010,8,Mon Jun 22 08:09:31 2015 UTC,"(Shameless auto-advertising below)  My book Beginning Haskell includes several chapters geared towards learning how to develop a DSL. It includes quite some information about parsing, about how to create a data type which reflects the invariants on your DSL or how to give an interpretation of an AST (in order to do something or generate some code from your DSL). Look at the last few chapters."
haskell,3anckv,serras,1 point,Mon Jun 22 06:47:22 2015 UTC,"Yeah, even before your replies, the book that I had in mind to buy was yours. It seemed really nice, and now that I looked more closely into it, seems like it is a nice choice!"
haskell,3anckv,chibro2,2,Mon Jun 22 21:58:39 2015 UTC,Not a book but here's two classes that are great:  http://www.seas.upenn.edu/~cis194/ http://www.seas.upenn.edu/~cis552/schedule.html
haskell,3anckv,mishach,4,Sun Jun 21 23:58:38 2015 UTC,"I would also suggest looking at uchicago courses, which are delightfully written.   http://cmsc-16100.cs.uchicago.edu/2014/  http://cmsc-22311.cs.uchicago.edu/2015/"
haskell,3anckv,cian_oconnor,1 point,Mon Jun 22 02:09:07 2015 UTC,I'm currently working my way through the 16100 course which is excellent. I much prefer it to the cis194 course.
haskell,3anckv,mishach,1 point,Mon Jun 22 17:38:10 2015 UTC,"can concur, these uchicago students are a lucky bunch."
haskell,3anckv,Mob_Of_One,4,Mon Jun 22 17:46:56 2015 UTC,"One note, the newer versions of cis194 are more like intermediate courses than a beginner's introduction to Haskell, which is why I specifically recommend the Spring '13 version of cis194.  This is the version of cis194 I am trying to adapt to something the community can edit."
haskell,3anckv,jaybee,1 point,Mon Jun 22 00:04:39 2015 UTC,"The Haskell School of Expression is good. Though it is dated w.r.t. libraries etc, as the blurb says ""An underlying theme is the design and implementation of domain specific languages"" so it might meet your needs. It is also a decent tutorial for beginners."
haskell,3anckv,sclv,1 point,Mon Jun 22 10:47:36 2015 UTC,"There is a list of Haskell resources on the Haskell.org homepage: https://www.haskell.org/documentation  However, you'll need to judge, based on what you do and don't already know, which one hits the sweet spots for you, especially given that you have some prior FP experience.  The techniques for developing compilers aren't necessarily at the center of any of the linked resources. As it turns out, if you're just doing an external DSL transpiling to a straightforward target language, then you really just need to know three things A) how to design a decent AST, B) how to write a decent parser, and C) how to write a decent emitter.  While there's newer tech, the classic libraries for the latter two are parsec, and pretty. Even if you want to learn the newer fancier libraries to get more features, it is hard to go wrong starting with those two. While some people feel Real World Haskell isn't a good intro for total beginners, it nonetheless has one of the ""book form"" treatments of parsing and simple codegen in haskell, so you may find it useful for that purpose if not for just starting out.  Note that this is the sort of task that ""classic"" Haskell was already very suited to, and so you can do this sort of thing in a straightforward way without any newer type-system tricks, etc."
haskell,3amm51,jhoxray,9,Sun Jun 21 18:38:34 2015 UTC,Take a look at Reflex as well: https://www.youtube.com/watch?v=mYvkcskJbc4
haskell,3amm51,BethAr,1 point,Sun Jun 21 23:28:04 2015 UTC,"Ryan talks about his ambition that Reflex's ability to define different timelines will allow him to extend it to define networks of remote processes in the same code with semantics that correctly reflect which parts are and are not well ordered.  Since seeing this post I have been wondering whether it might be possible to describe such heterogeneous systems as GHCJS client and GHC Haskell server. Exactly (or indeed vaguely) how such code would be structured, extracted into server and client parts and compiled I don't know but the idea of combining the directness and integration of hoplon with the semantics of FRP is very appealing."
haskell,3amm51,maninalift,1 point,Mon Jun 22 09:27:27 2015 UTC,"One of the biggest benefits I see to having a GHC and GHCJS pairing is the sharing of types and your pure functions. You could certainly find yourself in a meteor like world, but types and pure functions alone would be a HUGE benefit."
haskell,3amm51,dukerutledge,6,Tue Jun 23 00:43:54 2015 UTC,"These three all feel as though they are aiming at being well ""integrated"" in some particularly opinionated way. Sorry, you won't find a meteor clone in this list; only the first one is really practical right now and only the last one seems to focus on client-server integration (I just kinda got carried away anyway):   PostgREST Very DB-oriented. I'd be pretty tempted to use this for smaller query-heavy projects, I suspect it's pretty fast to get stuff shipped - assuming that you start from scratch. Hasura This was on HN a while ago and seems to have some similar-looking goals to PostgREST. However, despite being built in Haskell it doesn't seem to be released and doesn't seem to focus on the Haskell crowd either so I don't quite know what to make of it. It's pretty odd since most Haskell frameworks are very modular and library-like while this looks more like a database front-end. MFlow Focuses on server-client integration, unfortunately this one still has a very researchy appearance. It also doesn't (intuitively) feel very modern to me... or perhaps the presentation is just not great. The ""flow"" aspect sounds super cool; I'm just not sure how much use you'll get out of it if your goal is to build a snappy single-page app. I could possibly imagine a wizard-like UI working out pretty well in this?   EDIT: Oh I think I forgot an interesting one:   Gabriel's mvc isn't really a web framework, but the pipes-style ""reactivity"" of it seems like perhaps it could push updates to the front-end in a sort of CQRS-like fashion? (Or even yesterday's FRPNow! with its interesting IO-like Now monad for that matter... or machines...). Anyway, maybe at some point we'll converge on something and then build out some ecosystem around it."
haskell,3amm51,rehno-lindeque,1 point,Sun Jun 21 23:26:13 2015 UTC,"Thank you for the pointers, FRPNow and some further reading based on it (Yampa etc) was very enlightening. I updated the original posting with some further ideas."
haskell,3amm51,salamynder,3,Tue Jun 23 11:33:14 2015 UTC,FP-webdev in general: Ur/web? (only relational (sql) DB up till now)
haskell,3amm51,anon_c,6,Sun Jun 21 20:49:46 2015 UTC,"Ur/web is extremely impressive but also very immature. BazQux uses Ur/Web in production, but the author had to use shared libraries to mix Haskell and Ur/web, which is pretty janky."
haskell,3amm51,Bzzt,3,Sun Jun 21 20:56:00 2015 UTC,Purescript-halogen might be worth looking into for you.  I've been using purescript with yesod and so far so good.  I've been eyeing spock as a more lightweight server solution though.
haskell,3amm51,anon_c,2,Mon Jun 22 05:23:23 2015 UTC,"This seems like an appropriate place to ask this question: What front-end systems are people using in a for-money context? There are a lot of promising approaches here, but most of them feel very experimental/immature.  Who's using GHCJS in production? What are the pain-points after the initial setup?  Who's using purescript for UI programming in production? What are the pain points?"
haskell,3amm51,paf31,3,Sun Jun 21 20:42:50 2015 UTC,"SlamData use PureScript for their frontend. They can probably comment on pain points, but I suspect one of the bigger ones right now is integrating with third-party components. PureScript FFI is pretty good at low-level integration, but JS components don't tend to fit too well into functional models of user interfaces."
haskell,3amm51,buffyoda,4,Mon Jun 22 01:34:05 2015 UTC,"PureScript is awesome, but don't take my word for it, just check out our online demo (http://slamdata.com). We use purescript-halogen for the front-end and are working on improving the story for native component integration."
haskell,3amm51,beerdude26,2,Mon Jun 22 15:32:25 2015 UTC,[RamdaJS](www.ramdajs.com) would probably integrate well ;)
haskell,3amm51,paf31,1 point,Mon Jun 22 06:38:03 2015 UTC,"Quite possibly, and I'd be interested to see it, but I suspect quite a lot of the functionality would be duplicated in our core libraries."
haskell,3amm51,anon_c,2,Mon Jun 22 17:16:16 2015 UTC,"In the past, I've used PureScript for data modeling and coffeescript/react for the UI code. This works quite well, but I'd rather be using one language instead of three.  Also, are there any GHCJS systems that let you build ""isomorphic apps""? This seems doable with purescript/react/node, but I'd rather not use node."
haskell,3amm51,cies010,3,Sun Jun 21 20:46:43 2015 UTC,Did you look into Purescript-React bindings?
haskell,3amm51,anon_c,1 point,Sun Jun 21 21:13:46 2015 UTC,"The purescript-react wasn't around when I was doing this, so I can't comment. It does look a bit too opinionated and immature, though."
haskell,3amm51,beerdude26,3,Mon Jun 22 20:23:45 2015 UTC,Running the servant library on the client to generate API request functions and running it on the server to generate API provider functions would be a nice idea
haskell,3amm51,AlpMestan,5,Mon Jun 22 06:34:00 2015 UTC,"I haven't used it yet, but there's servant-purescript."
haskell,3amm51,arianvp,1 point,Mon Jun 22 09:00:57 2015 UTC,I created this but I haven't updated it in a while because I lack time.  But would love to bring it up with the latest servant version this summer: https://github.com/arianvp/ghcjs-servant-client
haskell,3amm51,anon_c,1 point,Mon Jun 22 20:22:24 2015 UTC,"Yeah, if I need a web client for my current project, I will DEFINITELY use servant to generate the request functions. I'm very happy with servant so far."
haskell,3amm51,Drupyog,2,Mon Jun 22 20:24:35 2015 UTC,"Not in haskell, but in the OCaml world, ocsigen is exactly what you are describing."
haskell,3amm51,Arcsech,1 point,Sun Jun 21 20:54:07 2015 UTC,And WebSharper in the F# world.
haskell,3amm51,erdeszt,2,Mon Jun 22 01:33:03 2015 UTC,Haste does something similar to what you've described.
haskell,3amm51,maninalift,2,Sun Jun 21 22:00:36 2015 UTC,"There are many ways to approach the relationship between server and client in such a framework. Some systems are designed to feel like building an SPA but with magical access to running code on the server (basically just eliding the plumbing of your ajax APIs), others are designed to feel like writing your application on the server with the ability to magically execute code in the client (the callCC base or inspired approaches), yet others handle the separation and communication more explicitly. It's probably also worth learning from the experiments and endeavours in clojure(script) such as hoplon, coils and luminous.   Also jmacro-rpc is rather interesting, see eg this video https://www.youtube.com/watch?v=rtfbQJGQj0Q (edited, thanks /u/gbaz1)"
haskell,3amm51,gbaz1,1 point,Sun Jun 21 22:35:59 2015 UTC,"If that video link doesn't work, you can see it here: https://www.youtube.com/watch?v=rtfbQJGQj0Q  And here's the package on hackage: https://hackage.haskell.org/package/jmacro-rpc"
haskell,3amm51,tel,2,Sun Jun 21 23:00:08 2015 UTC,"Meteor is interesting in that it gives you a client-server shared data abstraction between mongo-DDP-minimongo. That architecture could be replicated anywhere, of course.  I think there's a lot to be gained from ""isomorphic"" strongly typed applications in that types can be shared between client and server. This one-ups the ""stringly-typed"" matching system in place today.  Haskell could also really shine with the client-based latency-compensation system Meteor has. That works by sharing server code on the client and having the client run it in ""emulation mode"" in order to predict the RCP's behavior on the minimongo cache. The client can then enact these changes to pre-empt the server which confirms it after some round-trip latency. If this doesn't scream ""free monad"", well..."
haskell,3amm51,maninalift,1 point,Mon Jun 22 02:36:56 2015 UTC,"I think there's a lot to be gained from ""isomorphic"" strongly typed applications in that types can be shared between client and server. This one-ups the ""stringly-typed"" matching system in place today.   That's very interesting, when I heard claims about Meteor's latency-compensation, I had assumed that it was basically doing something rather trivial (if cumbersome to do by hand). That is much more (repeating myself) interesting.  I would be very interested to see an FRP take on the client views bound to database live-queries idea."
haskell,3amm51,tel,2,Mon Jun 22 20:11:26 2015 UTC,"There's a neat idea here with all the ""time-traveling"" state you can pull off with functional state isolation. If an optimistic update fails you could roll back in time and attempt to replay some actions to predict what would have happened in the ""other timeline"". That'd probably be disconcerting from a UX perspective, though."
haskell,3amm51,drwebb,2,Mon Jun 22 21:33:24 2015 UTC,Sounds like an excellent idea. I'm not really a front end dev but GHSJS is definitely something you want to look into. If you have any ideas please also try sharing them on the commercial Haskell mailing list: https://groups.google.com/forum/#!forum/commercialhaskell
haskell,3amm51,BobbyTabless,1 point,Sun Jun 21 20:38:11 2015 UTC,I think the best current trade off if you are going for something like this is to use Haskell for a restful api.  The middle/front-end would be an isomorphic javascript app using react which is heavily inspired by functional programming. You can add other functional js libraries into this mix such as immutable.js and lodash.js (or the many others.. https://github.com/jussi-kalliokoski/trine is a new one that looks pretty interesting).  For me using React and friends in an isomorphic app is more important than using haskell like languages in the front end. If you really want to I think http://livescript.net/ is the best trade off between haskell and javascript as it's similar enough to javascript to be compiled to js in a 1 to 1 straightforward manner (and has source maps). I'll be looking at purescript and others once they have source maps.
haskell,3amm51,beerdude26,1 point,Sun Jun 21 23:49:46 2015 UTC,RamdaJS is also a very nice JS library
haskell,3am3qu,bashcat,19,Sun Jun 21 15:52:24 2015 UTC,Yes :)
haskell,3am3qu,tomejaguar,8,Sun Jun 21 17:13:01 2015 UTC,"Awesome! I've been a regular user of this site for years now. I was really glad that netflix let you keep using their API.  Anyways, of course you should! : )"
haskell,3am3qu,matchi,2,Sun Jun 21 17:57:47 2015 UTC,Thank you.
haskell,3am3qu,Alyte,7,Sun Jun 21 18:01:39 2015 UTC,"Yes, you should! :D"
haskell,3am3qu,billrobertson42,3,Sun Jun 21 17:27:39 2015 UTC,"If you think your users will care, then go for it.   However, there's nothing wrong with putting an about page up though that might serve your desire for the tech-brag, that way anybody is interested can find out."
haskell,3am3qu,billrobertson42,7,Sun Jun 21 17:49:15 2015 UTC,"I doubt 99.5% my users will care. But if it helps the Haskell community, I'll do it."
haskell,3am3qu,_AndrewC_,7,Sun Jun 21 17:51:35 2015 UTC,"Well, I think an about page would serve you in two ways. First, if anybody with the intent to hire finds the page (or you send them there) then they can see what you did. Also, by not putting a powered by logo at the bottom, which, like you said, most of your users don't care about. Instead, just having an about link, you're sending the subtle message that you understand what your users care about and put their needs/desires above your own.   BTW, nice site!"
haskell,3am3qu,cies010,2,Sun Jun 21 17:58:40 2015 UTC,Thank you. I think your advice is sound. I think I'll put up the info in a more discreet way.
haskell,3am3qu,Vektorweg,3,Sun Jun 21 18:01:02 2015 UTC,"I think it does help the community, and I can't think of any reason not to. It doesn't matter if not many people read it, even fewer will read the about. I do think it's good to explain some of the details in an about page, but ""powered by Haskell"" is still a nice plan."
haskell,3am3qu,mishach,3,Sun Jun 21 18:38:02 2015 UTC,"Try (also) to make sure your project is added to some of the ""Haskell in the wild"" lists that are floating around the www. It might be more worthwhile to make noise there :)"
haskell,3am3qu,arianvp,10,Sun Jun 21 21:24:28 2015 UTC,"The site is built with Scotty, postgresql-simple, blaze-html, and lots of other Haskell libraries."
haskell,3am3qu,spicenozzle,1 point,Sun Jun 21 15:53:27 2015 UTC,lots of other Haskell libraries   Some packages have too many dependencies.
haskell,3am3qu,stubborn_d0nkey,8,Sun Jun 21 18:18:56 2015 UTC,I agree. Stackage helped me here. I also avoided libraries that depend on lens.
haskell,3am3qu,CynicalHarry,3,Sun Jun 21 18:21:11 2015 UTC,This site looks really nice. Do you have guide on how to deploy it on the web?
haskell,3am3qu,magnusg7,2,Sun Jun 21 17:40:30 2015 UTC,"Thank you. I deploy it in a very simple way. I git pull on the server, run cabal build, and then restart the upstart job for the web server process."
haskell,3am3qu,magnusg7,3,Sun Jun 21 17:46:02 2015 UTC,Any reason why you build on the server? Why Not just copy over the binary?
haskell,3am3qu,theonlycosmonaut,4,Sun Jun 21 18:06:16 2015 UTC,Thanks for idea. Setting up a build server is a good idea for the future. For the moment I'm content with doing the simplest thing possible. I have a lot of other programming tasks to do before this Haskell rewrite of a 6 year old Ruby on Rails app is complete.
haskell,3am3qu,Hrothen,2,Sun Jun 21 18:09:26 2015 UTC,"I'd love to see an in-depth blog post about this rewrite process. Things you liked about Haskell for web work and things that still need work. I'm on the fence about writing some of my own stuff in haskell, but I'm still very new."
haskell,3am3qu,pogden,6,Mon Jun 22 01:05:09 2015 UTC,"In case I don't get around to writing a blog post, here's the short version:  WRITE YOUR WEBAPPS IN HASKELL. YOU WON'T REGRET IT!  But there is one more specific, probably controversial, point I would add:  Use a templating system that gives you full type safety, like blaze-html. The idea of having type-safe templates was weird to me at first. No web framework outside of Haskell that I've heard of gives you type-checking for web templating code. But type-safe templating code turns out to be critical if you want to take full advantage of Haskell's ability to keep your code aggressively refactorable as it grows.   This also means that I think JavaScript MVC is a poor architectural choice, at least until a library like ghcjs matures. You'll lose a lot of Haskell's type-checking coverage if you use a non-type-safe web templating layer -- whether it be AngularJS, Ember, React or whatnot -- especially since these JavaScript MVC layers tend -- and are meant -- to grow into massive codebases in themselves."
haskell,3am3qu,Majiet_The_Liar,1 point,Mon Jun 22 03:23:34 2015 UTC,Why won't I regret it?
haskell,3am3qu,beerdude26,2,Mon Jun 22 09:51:14 2015 UTC,Definitely. Subtile but visible would be my suggestion.
haskell,3an5xp,maxigit,8,Sun Jun 21 21:31:44 2015 UTC,"Here's another way to do it. Maybe there's an even shorter way, but it doesn't immediately come to mind.  Map.fromListWith (++) . map (key &&& pure)"
haskell,3an5xp,twistier,2,Sun Jun 21 23:58:46 2015 UTC,You want Data.Map.insertWith
haskell,3an5xp,singpolyma,2,Sun Jun 21 21:53:07 2015 UTC,"Funny, I was looking for something very similar the other day, but with the signature [(a, b)] -> Map a [b] -- basically a fromList that allowed duplicate keys. It surprised me that nothing existed. Your groupBy would do almost what I want, except that it wouldn't give the values in the shape I needed."
haskell,3an5xp,radix,1 point,Tue Jun 23 16:58:30 2015 UTC,"Ours problems are indeed equivalent and I was expected also to find a version of your group by. I had your problem initially but I found that is often better to not modify the of the input (a, b) for performance reason."
haskell,3an5xp,kfound,2,Tue Jun 23 19:20:08 2015 UTC,"groupBy burned me once already this week. I was expecting it to group all elements belonging to a key into a single list, but it only does this for contiguous elements. Running the list through sortBy first helped, but it wasn't obvious from the name or type signature."
haskell,3an5xp,cameleon,1 point,Tue Jun 23 19:49:43 2015 UTC,That function doesn't typecheck at all... insertWith expects two more arguments. I'm guessing you want fromListWith?
haskell,3an5xp,singpolyma,1 point,Mon Jun 22 09:53:44 2015 UTC,Yes that was my original code. I changed it to insertWith following /u/singpolyma comment . I shoudn't have ;-)
haskell,3an5xp,singpolyma,2,Mon Jun 22 11:30:41 2015 UTC,"If you want to use insertWith you don't need the intermediate list, just fold over the inbound list with insertWith"
haskell,3an5xp,singpolyma,1 point,Mon Jun 22 11:47:50 2015 UTC,How ? you still need to provide the key and wrap the value in a list (or any monoid).
haskell,3al6fc,jystic,11,Sun Jun 21 07:35:11 2015 UTC,And here is the paper (that you could actually understand)
haskell,3al6fc,tailbalance,2,Sun Jun 21 09:49:32 2015 UTC,It seems that in the definition 4.2 on page 11 (item (a)) there is a typo: it should be map snd instead of map (map snd); otherwise I can't make sense of the definition.
haskell,3al6fc,imz,10,Sun Jun 21 19:02:43 2015 UTC,"I vaguely knew that Ed was working on this, but it wasn't until his Lambda Jam talk that I got some idea of how much speed he was aiming for (and has achieved).  Apparently this isn't just O(n) - it has better constant factors than quicksort.  The first half of the talk was on the well-principled basis that guided the API design.  Most of the second half was on how he got the speed. Both halves were interesting, but the second half cannot be unseen :)  Hopefully someone posts the video when it goes online."
haskell,3al6fc,dalaing,3,Sun Jun 21 07:59:57 2015 UTC,"I thoroughly enjoyed his Lambda Jam talk, very excited to see this released on Hackage.  Quite awesome to have someone talk about category theory and custom primops all in one talk!"
haskell,3al6fc,chrisdoner,3,Sun Jun 21 08:22:21 2015 UTC,Was there a mention of the choice of doing everything with lists over e.g. a vector? When I want speed a list is not the first thing I tend to reach for.
haskell,3al6fc,edwardkmett,6,Sun Jun 21 09:11:47 2015 UTC,"They don't really affect things here. The list is just to get the data in. Behind the scenes it uses some fast array-like pads to do the bucket sorting. Putting them in vectors often means allocating something extra and from my tests almost always costs me in terms of performance, because I have to recurse at other list types, which means all new vectors all over again."
haskell,3al6fc,edwardkmett,2,Sun Jun 21 16:09:39 2015 UTC,"I did a (much longer winded!) version of the talk at Zurihac. They also captured video, so one of the two will turn out I hope. =)"
haskell,3al6fc,gleberp,2,Sun Jun 21 18:59:49 2015 UTC,"ZuriHac video will be out soon! But not earlier than you, Ed, send me a signed video release form :P  I am returning from long vacation now and I'll take care of it ASAP."
haskell,3al6fc,edwardkmett,2,Sun Jun 21 19:11:28 2015 UTC,Had no scanner handy. =) Will deal with it momentarily.
haskell,3al6fc,telephone34,7,Sun Jun 21 20:21:28 2015 UTC,How does this relate to the Omega(nlogn) barrier? Are the values assumed to be bounded?
haskell,3al6fc,augustss,13,Sun Jun 21 13:31:08 2015 UTC,"The way complexity for sorting is usually measured (with O(n log n)) is weird compared to most complexity measures. For sorting it is related to the number of input elements, whereas for a lot of complexity measures you instead measure the input size in bits.  If you do input size in bits for sorting you'll get O(n)."
haskell,3al6fc,tailbalance,11,Sun Jun 21 14:37:41 2015 UTC,TL;DR: That “barrier” assumes that GT|EQ|LT is all the information we can get from comparisons. And the essence of discrimination sorting/grouping is that we could get a little more.
haskell,3al6fc,edwardkmett,8,Sun Jun 21 15:38:48 2015 UTC,"The Omega(n log n) bound comes from limiting yourself to pairwise comparisons. If you have an O(1) comparator that works pairwise to determine relative ordering then you can't do better than n log n. Similarly, if you only have an O(1) comparator that compares for equality the you can gather equivalence classes in Omega( n2 ). Pretty much the only way to beat that is to avoid doing things pairwise or to cheat and know more about the order your data was in to start with.  Here we discriminate in O(n) in the 'amount of the structure we need to inspect', by exploiting the fact that radix and American Flag style techniques can get much more information out of a set of things than just working with them pairwise.  Unlike a radix sort this works ""top down"" (hence the American Flag sort reference) most of the time.  Assume you can radix sort your leaves somehow, then it comes down to handling sums and products.  Products use stability of the sort to chain two sorts together.  Sums split things into lefts and rights, radix sort each independently, then merge the results by appending.  None of these steps changes the asymptotics involved.  Since it is done top down you only pay for as much of the structure as you need to inspect to discriminate between things."
haskell,3al6fc,sclv,6,Sun Jun 21 16:12:53 2015 UTC,"The linked article on this thread does a good job -- you can think of this as a ""generic radix-style sort"" where you trade off space (for the radix table) for time."
haskell,3al6fc,rpglover64,5,Sun Jun 21 14:30:18 2015 UTC,"IIUC, yes. It takes advantage of the fact that 32 bit ints are a bounded range (and that they have a fast equality) and breaks other abstract data types by their constructors."
haskell,3al6fc,edwardkmett,4,Sun Jun 21 13:51:50 2015 UTC,There are still a number of optimizations I want to apply to this code.  It could be much smarter about 'stopping' when it sees it is sorting an equivalence class with one element. (It needs to do so for the right asymptotics.)  I've also begun working on a promises package that provides the 'lazy i-var' semantics i need to properly implement online stable unordered discrimination.   Once I can get that worked out we'll have something that the origin discrimination papers do not: a way to work with data in a streaming fashion.
haskell,3al6fc,Darwin226,7,Sun Jun 21 17:45:24 2015 UTC,"Could someone explain this? I just tried sorting 10 million reversely ordered Ints and Data.List.sort performed an order of magnitude faster (compiled with O2).  What did I do wrong?  Edit: Also, this took up 4gb of RAM while Data.List.sort didn't seem to take anything."
haskell,3al6fc,Taneb,15,Sun Jun 21 10:07:21 2015 UTC,"GHC's Data.List.sort is heavily optimized for the cases when large portions of the list are in order or reverse order. It's really quite a nice algorithm, well worth reading."
haskell,3al6fc,edwardkmett,5,Sun Jun 21 10:25:32 2015 UTC,"The sort didn't take anything because it didn't do any work, it was able to recognize the special case of a reverse sorted list and optimize it into a reverse. =)"
haskell,3al6fc,Darwin226,3,Sun Jun 21 17:46:28 2015 UTC,My foolproof methodology for testing sorting algorithms is flawed!
haskell,3al6fc,sclv,3,Sun Jun 21 18:58:09 2015 UTC,Guess it wasn't only fools you needed to worry about!
haskell,3al6fc,tomejaguar,2,Mon Jun 22 16:25:26 2015 UTC,"Unfortunately I'm pessimistic about discrimination for joins.  You pay a price O(in1 + in2 + out) where in1 and in2 are the sizes of the input sets, and out is the size of the output set.  This means if I want to look up a customer in my enormous customer database then discrimination won't do the job properly.  Is there a way around this?"
haskell,3al6fc,sclv,4,Sun Jun 21 08:37:17 2015 UTC,"To go any faster than linear on input you need an index, right? Discrimination works on unindexed, unsorted data.  So I don't think this will magically fix that -- it just captures well the case where you want a join-like thing on entirely unindexed data."
haskell,3al6fc,tomejaguar,3,Sun Jun 21 14:33:17 2015 UTC,You can create an index in O(n log n) time so it seems that discrimination is only worthwhile in the cases where you need uncompromising simplicity.
haskell,3al6fc,edwardkmett,6,Sun Jun 21 15:35:49 2015 UTC,"O(n log n) is still bigger than the O(n) above!  I generally advocate for creating indices, but we occasionally get data into a process from several different datasources that you need to merge with no common index, and there discrimination can ensure that you have at least a linear time bound.  Once I can get productive stable unordered discrimination working then it can even start spitting out results online."
haskell,3al6fc,hastor,6,Sun Jun 21 16:14:32 2015 UTC,Could you combine your discrimination package with (the work you have done on) self indexing to create for example generic wavelet trees/matrices for data sets?
haskell,3akrbh,SrPeixinho,17,Sun Jun 21 04:04:54 2015 UTC,"I think that's the way most people program, except they use where or let block to store the local declarations (unless they get used somewhere else). You will rarely find single expressions spanning several lines."
haskell,3akrbh,gasche,8,Sun Jun 21 09:25:08 2015 UTC,"I think that's the way most people program, except they use where or let block to store the local declarations (unless they get used somewhere else).   The problem I have with defining functions locally is that I run the risk of abusing free variables, creating code that is harder to read, refactor and reason about."
haskell,3akrbh,kqr,13,Sun Jun 21 11:14:15 2015 UTC,"Why is   insertAfter el ins  = concatMap (\x -> if x == el then [x,ins] else [x]) insertBefore el ins = concatMap (\x -> if x == el then [ins,x] else [x])  -- No comments, no formatting, no special syntax:  separateParens = insertAfter '(' ' ' . insertBefore ')' ' '   better than the previous attempt? They are both multiple lines/one line depending on how you look at it."
haskell,3akrbh,sccrstud92,11,Sun Jun 21 04:07:43 2015 UTC,I think the idea is that insertBefore and insertAfter are general purpose abstractions that could belong in a util library.
haskell,3akrbh,mbuhot,11,Sun Jun 21 04:18:02 2015 UTC,That is often not true
haskell,3akrbh,hastor,9,Sun Jun 21 09:07:55 2015 UTC,"It isn't ""better"" (define better) and actually worse in some aspects (certainly less efficient). It is just a different style, with potential advantages/disadvantages. The idea is to find, inside your function, some pattern that is generic enough to be given a global name. I've found this leads to more readable code (the last separateParens the easiest one to read) and reveals interesting abstractions that could be useful later (i.e., insertAfter and insertBefore). This practice changed a lot my workflow, but I think it improved my overall productivity and made Haskelling a lot easier. I'd swear naming things become one of the hardest parts of it now.  (My internet is bad today, I hope it didn't go twice.)"
haskell,3akrbh,billrobertson42,7,Sun Jun 21 04:19:53 2015 UTC,"It's not a bad idea. Shorter functions with fewer branches are easier to read. Also, when you give a name to a bit of code that was embedded in a larger function (i.e. put it in its own function), you can make that larger function easier to understand.  OTOH, if you go overboard with it, you're probably not going to produce more understandable code."
haskell,3akrbh,Jookia,6,Sun Jun 21 04:35:55 2015 UTC,Until the last example I didn't know exactly what the function was doing. That and branching puts a mental weight on my head when desk checking.
haskell,3akrbh,kraml,3,Sun Jun 21 05:12:42 2015 UTC,I would still make those global functions local in a where clause unless they are needed in multiple places.
haskell,3akrbh,Crandom,1 point,Sun Jun 21 17:23:00 2015 UTC,The last separateParens function is much easier to read.
haskell,3akrbh,bananu7,1 point,Sun Jun 21 05:21:45 2015 UTC,That version is (better|more explicitely) structured.
haskell,3akrbh,quchen,6,Mon Jun 22 14:23:43 2015 UTC,I challenge you to implement Data.List.sort and Data.Map.Lazy.insert in one line.
haskell,3akrbh,yitz,30,Sun Jun 21 08:03:32 2015 UTC,"isSorted = and . (zipWith (<=) <*> tail) sort = head . filter isSorted . permutations   EDIT: Just to clarify, this was meant to be funny. That is just about the worst way to implement sort; it's almost as slow as ""random sort"". It is meant to illustrate the point of /u/quchen, which is that some things are inherently complex in a way that makes it best not to implement them in a single line even though it's possible."
haskell,3akrbh,quchen,5,Sun Jun 21 08:39:38 2015 UTC,"This is precisely why I said ""Implement Data.List.sort"" and not ""a list sorting algorithm"" :-P"
haskell,3akrbh,danbst,3,Sun Jun 21 19:07:15 2015 UTC,will be glad if you explain (zipWith (<=) <*> tail) trick. That kind of pointfree I currently don't understand
haskell,3akrbh,yitz,15,Sun Jun 21 08:50:32 2015 UTC,"Applicative comes with an instance for (->) a. It works like this: if f is a function of 2 variables and g is a function of 1 variable, then (f <*> g) x = f x (g x). That's actually clear if you look at the type signature of <*> and think about what that would be if the applicative type is (->) a, i.e. functions whose input type is a.  If you've ever looked at Haskell Curry's combinator calculus, <*> for this instance is the S combinator.  EDIT: Changed ""the untyped lambda calculus"" to ""Haskell Curry's combinator calculus""."
haskell,3akrbh,kqr,8,Sun Jun 21 09:24:57 2015 UTC,"It's the same thing as \xs -> zipWith (<=) xs (tail xs), i.e. it checks that every element is less than or equal to its next element."
haskell,3akrbh,ndmitchell,3,Sun Jun 21 11:16:41 2015 UTC,"That's almost as efficient as the original sort:  import qualified Data.PQueue.Min as PQ  sort :: (Ord a) => [a] -> [a] sort = PQ.toList . foldr PQ.insert PQ.empty  main = print $ sort [1,3,2,8,7,9]"
haskell,3akrbh,lukewarm,6,Sun Jun 21 14:39:41 2015 UTC,"Using the extra package (http://hackage.haskell.org/package/extra) you can write:    replace ""("" ""( "" . replace "")""  "" )""   Which is only one line,  with no new auxiliaries, and I find clearer."
haskell,3akrbh,ndmitchell,5,Sun Jun 21 07:31:21 2015 UTC,"which is clever, but, as any regex-based conversion, hard to reason about in edge cases. e.g. what would be the result of:  replace ""z"" ""zz"" ""zzz""   ?"
haskell,3akrbh,WarDaft,6,Sun Jun 21 08:49:43 2015 UTC,"""zzzzzz"" - it's fairly simple if only applied once. It's harder if your replacement matches a later match bit."
haskell,3akrbh,Kaligule,2,Sun Jun 21 09:05:42 2015 UTC,"Why would that be unclear? It replaces occurrences in the original string, not in the resulting string. Otherwise even replace ""a"" ""a"" wouldn't terminate."
haskell,3akrbh,WarDaft,4,Mon Jun 22 04:49:04 2015 UTC,"Wow, I like that solution even better.  It is a good observation that insertBefore and insertAfter are actually special cases of an even more abstract function."
haskell,3akrbh,mightybyte,2,Sun Jun 21 21:04:25 2015 UTC,"One liners are so much easier to test and reason about. The more you can write like this while satisfying your performance requirements, the easier your life gets."
haskell,3akrbh,Ramin_HAL9001,2,Mon Jun 22 04:49:18 2015 UTC,"The Snap Framework Style Guide has always specified an absolute maximum line length of 78 characters.  I really like this style, and while I'm not super-nazi about it, I try to follow this in the vast majority of my code.  I believe code is more readable when it has a more organized visual flow.  Keeping within the 78 character line limit also allows me to have more code on my screen at once because I can open several windows side-by-side without having long lines truncated or wrapped."
haskell,3akrbh,quchen,2,Mon Jun 22 16:37:22 2015 UTC,"Well of course you can implement most Haskell language functions as a single line, but the lines can become very long."
haskell,3akrbh,yitz,2,Sun Jun 21 13:06:29 2015 UTC,"Unfortunately things like imports have to be on their own line, otherwise we could go quite wild like that."
haskell,3akrbh,BethAr,2,Sun Jun 21 19:08:13 2015 UTC,"Actually, they don't need to be:  module Oneline where {import Data.Char; oneline = map toUpper ""This module is all on one line.""}"
haskell,3akrbh,hargettp,1 point,Sat Jun 27 22:22:16 2015 UTC,"I write all my functions as a single line, but, later on, if I notice they have very local significance, I move them to where clauses accordingly."
haskell,3al95v,sccrstud92,33,Sun Jun 21 08:25:14 2015 UTC,"(+), (-) etc. for standard types like Int are not lazy.  You probably misunderstand how lazy evaluation works. A thunk for x + y is not a consequence of (+) being lazy, because by that time (+) hasn't even been called yet. It's the outer function that hasn't forced the result."
haskell,3al95v,roche,4,Sun Jun 21 09:07:52 2015 UTC,What are the downsides of automatically forcing arithmetic that cannot throw exceptions?
haskell,3al95v,roche,6,Sun Jun 21 16:33:43 2015 UTC,"How do you define 'arithmetic' and how do you know whether there is any 'arithmetic' somewhere inside a thunk without evaluating it? This'd destroy laziness everywhere.  How would you go about evaluating   fibs = 1:1:zipWith (+) fibs (tail fibs)   ?  I'm not even touching the problem of figuring out whether something may throw exceptions, go into a loop, or be very expensive to evaluate optimistically."
haskell,3al95v,roche,5,Sun Jun 21 16:48:10 2015 UTC,"Basically anything that can be turned into primitive operations by the compiler, +, -, *, etc. What would that break? How would that destroy your example? Lists are still lazy, so the fib example would still work. Only difference would be that forcing the spine of the list also forces the elements, because the elements are computed with simple addition.  Or maybe functions themselves can specify that thunks they form should always be forced instead of making the caller specify. I bet there could be really bad consequences from that, but I don't know what they would be. Has anyone tried something like this?"
haskell,3al95v,chrisdoner,5,Sun Jun 21 16:57:23 2015 UTC,"Ok, I misunderstood what you were suggesting.  There is still a problem of forcing an expensive/non-terminating/exception-throwing operand that wasn't meant to be evaluated. But for the case when operands are evaluated, it works that way, as u/augustss explains."
haskell,3al95v,multivector,14,Sun Jun 21 17:05:26 2015 UTC,"(+), (-), etc. for all the standard Prelude number types are strict."
haskell,3al95v,tomejaguar,4,Sun Jun 21 09:13:59 2015 UTC,Is there any way to observe this? I opened ghci and tried a few things but couldn't really come up with anything. I suppose that there are no numbers you feed to the LHS or RHS of (+) that result it it ignoring its other argument.
haskell,3al95v,kqr,14,Sun Jun 21 09:27:26 2015 UTC,Prelude> (undefined + undefined) `seq` () *** Exception: Prelude.undefined Prelude> (undefined : undefined) `seq` () ()
haskell,3al95v,SkoomaMudcrab,3,Sun Jun 21 09:30:05 2015 UTC,"This might be sleep deprivation speaking, but isn't basically all constructors lazy in their arguments (besides those that are bangpatterned/unpacked) and all functions strict in every argument they don't outright ignore (like const and it's second argument)?"
haskell,3al95v,Taladar,6,Sun Jun 21 10:19:48 2015 UTC,"There are three most widespread evaluation schemes: call-by-value, call-by-name and call-by-need.  Call-by-value: all arguments to a function are evaluated once before the body of the function is evaluated, and the resulting values are substituted into the body. This is also called ""strict evaluation"" and is used in e.g. C and Java.  Call-by-name: no argument is evaluated before the body of the function, but each time an argument is encountered in the body, it is evaluated. Thus some arguments may never get evaluated, while some may get evaluated more than once. I'm not sure where this scheme is used, but it is classified as ""non-strict evaluation"".  Call-by-need: no argument is evaluated before the body of the function, but if an argument is encountered in the body at least once, it is evaluated once and once only. This is the default scheme used in Haskell. It is also called ""non-strict"", but it is distinct from call-by-name."
haskell,3al95v,pycube,4,Sun Jun 21 12:34:30 2015 UTC,"I'm not sure where this scheme is used, but it is classified as ""non-strict evaluation"".   Presumably some of the text based languages work that way, things using strings as arguments like shell or TCL."
haskell,3al95v,danbst,4,Sun Jun 21 16:10:55 2015 UTC,"I'm not sure where this scheme is used, but it is classified as ""non-strict evaluation"".   I guess you could say that GHC haskell is partially call-by-name: when inlining, I think it sometimes happens that ghc duplicates the computation of one expression if it's cheaper to compute than to store."
haskell,3al95v,tomejaguar,2,Sun Jun 21 17:18:41 2015 UTC,"the first two approaches have analogues in tree searching - depth-first traversal or breadth-first traversal. I can think of it as ""searching the result of an expression inside it's AST""  the third scheme looks like breadth-first search in expression's abstract syntax DAG"
haskell,3al95v,kqr,3,Sun Jun 21 19:24:14 2015 UTC,"isn't basically all constructors lazy in their arguments   Yes, assuming the argument isn't given a ! in the constructor definition.   all functions strict in every argument they don't outright ignore   No, not at all.  maybe is lazy in its first two arguments but it doesn't ""outright ignore"" them.  It does ignore them in certain cases, which may be closer to what you are getting at!  Prelude> maybe undefined print (Just ()) () Prelude> maybe undefined print Nothing *** Exception: Prelude.undefined"
haskell,3al95v,AdituV,1 point,Sun Jun 21 11:15:27 2015 UTC,"I guess what I meant by ""outright ignore"" included ""outright ignore when the stars align"", or, as you said it better, ""ignore them in certain cases""."
haskell,3al95v,tomejaguar,2,Sun Jun 21 11:18:20 2015 UTC,"How about in:  foo :: (a -> a -> b) -> Bool -> a -> a -> b foo f p x y = if p then f x y else f y x   This should be lazy in f, x, and y, and in no case are any of them ignored."
haskell,3al95v,kqr,3,Sun Jun 21 11:27:18 2015 UTC,"This should be lazy in f, x, and y, and in no case are any of them ignored.   That depends on f.  If f = \_ _ -> () then x and y are indeed ignored.  Granted, this is a pathological case."
haskell,3al95v,int_index,-1,Sun Jun 21 11:37:56 2015 UTC,"Yup, totally correct. Those are the irrefutable patterns another commenter wrote about."
haskell,3al95v,kamatsu,2,Sun Jun 21 11:31:54 2015 UTC,"Irrefutable patterns are a GHC feature, not this."
haskell,3al95v,tomejaguar,1 point,Sun Jun 21 11:49:33 2015 UTC,"No, irrefutable patterns are just patterns that can't be refuted, like x or _ or (a,b)."
haskell,3al95v,augustss,2,Mon Jun 22 03:33:08 2015 UTC,"Sure, this is roughly the definition of strictness: strict = never ignored, lazy = sometimes ignored."
haskell,3al95v,tomejaguar,2,Sun Jun 21 11:50:42 2015 UTC,"It's more complicated than that, e.g., the function f x = f x is strict, even though x is never used."
haskell,3al95v,augustss,1 point,Sun Jun 21 22:44:10 2015 UTC,Interesting.  Here f is strict because f _|_ = _|_.
haskell,3al95v,letrecc,3,Mon Jun 22 05:57:13 2015 UTC,"One might be tempted to think that a function that loops is considered strict is a technical oddity.  But it's in fact important for strictness analysis to work well.  For example  afac n a = if n == 0 then a else afac (n-1) (n * a)   It's easy to see that this function is strict in n since it uses n in the comparison.  But is it strict in a?  In fact it is, because even if we never hit the base case it is strict in a due to the definition of strictness."
haskell,3al95v,kqr,2,Mon Jun 22 08:01:30 2015 UTC,functions  with irrefutable patterns are non-strict in the corresponding argument...
haskell,3al95v,letrecc,1 point,Sun Jun 21 11:21:55 2015 UTC,That's true! I can't believe I forgot about such a simple concept. I blame sleep deprivation!
haskell,3al95v,drb226,1 point,Sun Jun 21 11:31:16 2015 UTC,"as you well should. :) better yet, go get yourself some much needed sleep!"
haskell,3al95v,conklech,2,Mon Jun 22 23:57:08 2015 UTC,cons x xs = x : xs  Functions can be just as lazy as the other functions or constructors that they use.  Constructor fields can be annotated with ! to make them strict.
haskell,3al95v,kqr,2,Sun Jun 21 18:27:27 2015 UTC,"/u/tomejaguar's comment precisely and accurately describes how to determine whether a function is or is not lazy; we often ask whether (f undefined) `seq` () is equivalent to undefined or (). To learn more, check out the Laziness section of What I Wish I Knew When Learning Haskell and the materials it links, in particular this article by /u/augustss."
haskell,3al95v,augustss,10,Sun Jun 21 21:33:45 2015 UTC,"In essence, all let bindings are allocated as thunks on the heap. This means that when you write  let     x = a + b in     print x   you are creating a thunk by virtue of using a let binding, not because + is lazy. As it turns out, even if you would write  print (a + b)   GHC will turn that into  let     x = a + b in     print x   because in one of the intermediary stages function arguments have to be ""simple"" – i.e. a variable, not an expression. So regardless of how you write your code, your expression is going to end up in a let binding which will create a thunk on the heap.  However! Once that thunk gets evaluated, perhaps because it is needed in the print function, it will evaluate both its arguments immediately, because + is strict in both its arguments. There is no way you can get a result out of + without forcing both its arguments."
haskell,3al95v,augustss,12,Sun Jun 21 09:40:19 2015 UTC,"Assuming the type is Int, if a and b are evaluated then a + bwill not get a thunk.  This is a simple optimization called ""cheap strictness""; computing a + b cannot go wrong and it's cheaper than creating a thunk.  (I'm talking about ghc now.  The cheap laziness was first introduced in the LML compiler.)"
haskell,3al95v,kqr,3,Sun Jun 21 15:49:19 2015 UTC,This is the first I had heard of this. This is what I was hoping for. Does this work with (-) and (*) as well? (I assume it doesn't happen for (/) because b could be 0)
haskell,3al95v,ForTheFunctionGod,4,Sun Jun 21 16:31:41 2015 UTC,"Yes, it works for (+), (-), and (*) for Int (maybe Integer too).  And it could work for all floating point arithmetic."
haskell,3aluum,maxigit,6,Sun Jun 21 14:22:16 2015 UTC,"If you're doing this for a library to be released to Hackage, all of the standard discussions about PVP, upper bounds, etc, come into play. If on the other hand you're writing an application that isn't going to be shared, I think dependency pinning (via Stackage, cabal freeze, or equivalent), makes a lot more sense."
haskell,3aluum,snoyberg,6,Sun Jun 21 16:12:46 2015 UTC,https://wiki.haskell.org/Package_versioning_policy
haskell,3aluum,sclv,4,Sun Jun 21 14:46:17 2015 UTC,"IMO the version bounds in your cabal file should indicate a range of versions that you know [1] to work.  When there's a dependency without bounds and I'm trying to add bounds, here's what I do.  Presumably the code already builds.  If not, then the first step is to get it building.  When I'm trying to add a version bound for dependency foo, the first thing I do is find what version of foo the code is currently built with.  If I'm using a sandbox, I do cabal sandbox hc-pkg list | grep foo.  If I'm not using a sandbox, then I do ghc-pkg list | grep foo.  One of these two commands will return something like this:  foo-1.2.3.4   The PVP implies that if your package builds with foo-1.2.3.4, it should build with any foo-1.2.x.y where x >= 3.  There's certainly always a potential for mistakes that invalidate this rule, but you should assume it will apply until proven otherwise.  This suggests the following version bound:  foo >= 1.2.3 && < 1.3   The PVP says that when a package adds new functions to its API it has to bump at least the c version component in a.b.c.d.  This means that if your package does not use any of the things in foo's API that were new in 1.2.3, 1.2.2, or 1.2.1, then you can just use the lower bound >= 1.2.  In the ideal world, if you want to use that bound, you should test your package against foo-1.2.0.x first, but in most situations it's probably safe to use that bound.  Some people in this situation like to use this syntax:  foo == 1.2.*   But as soon as foo-1.3 comes out, that .* notation will no longer work and you will probably want to bump the bound to this:  foo >= 1.2 && < 1.4   So I prefer to avoid the .* notation for consistency and use the dual bound syntax everywhere.  [1] Yes, I know that ultimately the only way you can know is to actually build against that version.  Here I mean ""know with reasonably high likelihood"", where we assume that most of the time package authors conform to the PVP and mistakes are the exception rather than the rule.  This assumption works because cabal-install prefers more recent versions.  So if there was a mistake that causes 1.2.3.5 to fail even though 1.2.3.4 succeeded, it's very likely that the author will release a fix as 1.2.3.6 that will supersede 1.2.3.5 in the vast majority of practical circumstances."
haskell,3aluum,mightybyte,1 point,Mon Jun 22 16:22:53 2015 UTC,"You can use ghc-pkg list foo and cabal sandbox hc-pkg list foo, no need for grep."
haskell,3aluum,sopvop,1 point,Tue Jun 23 08:11:36 2015 UTC,"Ahh yes.  I default to using grep because the direct arg only works for an exact package name, while greg gives me partial matching"
haskell,3aluum,mightybyte,6,Wed Jun 24 04:57:08 2015 UTC,"Whatever you do, it's important to specify correct version bounds, in the sense that if your cabal file specifies that it is compatible with a particular version of one of its dependencies, your code better compile with that version. Otherwise, some user will have compilation issues and blame the vague notion of ""cabal hell"" for being unable to install your package when in fact the problem is that cabal was relying on incorrect information.  One easy way to do that is to specify exactly one version, the one with which you have tested. Unfortunately that's not very convenient for your users, because that might prevent them from using your package with some other package which picked a slightly different version of a shared dependency. <rant>And then users are still going to blame ""cabal hell"" because they can't be bothered to read error messages and will complain whenever things don't install magically the first time, regardless of whether what they're trying to accomplish is even possible.</rant>  So anyway, it's better to test it with lots of older versions and to specify a wide range. A while ago I built a tool called cabal-rangefinder which is supposed to do that automatically, and I plan to polish it up and put it on hackage some day.  Finally, there is the question of upper bounds. While in theory we cannot possibly have tested with future versions of our dependencies, future versions are often backwards-compatible, so we have two choices: either specify a pessimistic upper bound and adjust them upwards when new versions of our dependencies come out, or specify an optimistic upper bound and adjust them downwards when an incompatible version comes out. I do the latter because it's a bit less work, but there's the obvious downside that your version bounds will be wrong between the time a release comes out and the time you fix your version range.  By the way, it used to be that you had to release a new version of your package in order to fix up those version numbers, but in the ""Cabal file metadata"" section of your maintainer's page on hackage, it is now possible create new revisions of your cabal file without having to release a new version of your entire package. It's pretty neat, but <rant>it turns out that nix doesn't check for new revisions, so nix users may complain about compilation errors due to your open upper bounds long after you've fixed those bounds.</rant> For that reason you might prefer the pessimistic approach to upper bounds, <rant>except that Stackage prefers the optimistic approach, so there is no way to please everyone.</rant>"
haskell,3aluum,gelisam,2,Sun Jun 21 15:41:37 2015 UTC,"A while ago I built a tool called cabal-rangefinder[1] which is supposed to do that automatically, and I plan to polish it up and put it on hackage some day.   That's really interesting. What's the current status ? Does try every version configuration or just lower-bounds vs lower-bounds and higher-bounds vs higher-bounds ?"
haskell,3aluum,gelisam,2,Sun Jun 21 18:11:27 2015 UTC,"What's the current status ?   Slightly bit-rotted. Doesn't work with GHC 7.10 yet, I'll do that now. edit: done.   Does try every version configuration [...]   No, it uses binary search to find the point at which things start to break.   [...] or just lower-bounds vs lower-bounds and higher-bounds vs higher-bounds ?   I don't understand what you meant by that, but I certainly don't handle upper bounds. Like the documentation says, I assume that your code works with the latest version of everything.  The way it works is it repeatedly clears your sandbox and tries to rebuild with a slightly-modified cabal file which forces one dependency to one specific version and leaves everything else unbounded. This way cabal will use the latest version of everything except that one package and that package's dependencies."
haskell,3aluum,hvr_,1 point,Sun Jun 21 18:49:21 2015 UTC,"I don't understand what you meant by that   I meant, let's say you find a lower bound for the first package. When starting searching for the 2nd package, does it unbound the first package or does it uses the lower-bound already found ?  I think you answered it ."
haskell,3aluum,gelisam,2,Sun Jun 21 18:59:27 2015 UTC,"A while ago I built a tool called cabal-rangefinder which is supposed to do that automatically, and I plan to polish it up and put it on hackage some day.   Please do! I'm quite interested in seeing tooling like that, as I'd like to integrate more extensive (but obviously not the total cartesian product, as that wouldn't scale) range-testing into http://matrix.hackage.haskell.org :-)"
haskell,3aluum,snoyberg,3,Mon Jun 22 08:29:02 2015 UTC,"What's this? At first it looks like a collection of links about Hackage trustees, but that didn't seem to fit with the name ""matrix"", so I explored a bit more and figured out that you need to search for a package name in order to get a table of results for each GHC version and package version.  The information in these tables is very interesting to me! One of the major limitations of cabal-rangefinder at the moment is that it rebuilds everything with whatever version of GHC is installed on the user's machine, so if that's GHC 7.10, versions of mtl prior to 2.2 will fail and cabal-rangefinder will claim that the range is mtl >= 2.2, even though users with other versions of GHC would probably be able to compile with earlier versions of mtl as well. Did you have to do anything special to switch between the different versions of GHC which must be installed on your build machine? If there was an easy way to switch between several versions of GHC on the user's machine, cabal-rangefinder could repeat its exploration with all available versions and return the union of the ranges it found.  Another interesting piece of information in these tables is the fact that mtl-2.0.1.1 compiles fine with GHC 7.6, but mtl-2.1 doesn't. This is pretty bad news for cabal-rangefinder, which assumes that there is a unique version number before which all versions fail and after which all versions succeed. Otherwise, using binary search instead of testing every single version is not a justified optimization.  Your tables demonstrate that another of my assumptions is false, but it's good news this time. I assumed that the packages which come with GHC (the ""boot packages"") had a fixed version, and that we could not install or link to any other version of those. For this reason, cabal-rangefinder marks those packages as ""pinned"", meaning it will not attempt to find a good range for them. But in your table for containers for example, you clearly managed to install other versions, and I just tried compiling a test package with a non-boot version of containers and cabal does compile and link it. I need to look deeper into this, as I can see in cabal-rangefinder's history that I used to only pin base, and only later did I add all the boot packages. So there must have been a reason which made me think that doing so was a good idea. But what?  Finally, I think I could make cabal-rangefinder smarter if it had access to those matrices. Is there an API through which I could access this information, or should I try to scrape the HTML instead?"
haskell,3aluum,drb226,2,Mon Jun 22 13:03:33 2015 UTC,"In case it's unclear from the wording, I have no problem with people putting in upper bounds. It is a fact that if you add a package to Stackage with strict upper bounds on every dependency, you're more likely to get bugged by me to relax the upper bound, but I don't think that should surprise anyone. If you want to have upper bounds on your package, feel free to do so, and there's no Stackage penalty for this. I do request that you try to be prompt though about relaxing restrictive upper bounds so that it doesn't end up penalizing the rest of the Stackage collection.  I do on occasion have to remove a package because an author takes too long to relax an upper bound, but fortunately that's a rare occurrence."
haskell,3aluum,hvr_,0,Sun Jun 21 16:10:19 2015 UTC,"Cabal is not blameless in this. Knowing the ""correct version bounds"" for every single dependency is hard. Authors can write conservative bounds that only allow the versions they have verified, but that locks users out from using dependencies that fall outside that range. Don't forget that this, too, is ""cabal hell"": when cabal can't find any build plan at all because authors were too strict with their version bounds.  I for one think that starting with relaxed versions and adding restrictions as incompatibilities arise is much more likely to produce good bounds. Because users can discover and report build failures. It's easy to see who is at fault for the build failure: just look at which package failed to build. It's much harder to report the situation where cabal can't find a build plan, because cabal won't necessarily tell you who the culprit is.  Another scenario is that cabal can find a build plan, but it has you using old versions of libraries for no reason other than that someone forgot to bump up their dependency bounds. You could be missing out on important security patches that aren't being added to older versions. This, I think, is one area where Stackage shines. Authors get to declare that ""I am supporting this particular major version of my package for at least the next three months."" So you know you are getting the latest security patches for those packages."
haskell,3aluum,drb226,3,Mon Jun 22 01:51:16 2015 UTC,"IMO, both schemes (opt-in bounds vs. opt-out bounds) have their own trade-offs.  As you mention, opt-in scheme bounds can lead to cause Cabal to err on the conservative side and deny you an existing but blocked valid install-plan, and due to the rather complex inter-package build-dep language and semantics, the cabal solver error may not be trivial to understand (but afaik, there's still work going on trying to make the solver errors easier to understand).  For the usual class of solver errors which involve some package not supporting the latest major version, it's actually quite easiy to compute/identify the culprit (the following could be implemented in cabal-install): Generate a constraint-file constraining all Hackage packages to >= a.b where a.b is the latest major version. Run cabal install <goal> on an empty package db, and see which packages the cabal solver complains about being in conflict w/ the lower bound constraint. This is just a sketch of an idea on how we could compute things (I'm considering stuff like this for use on http://matrix.hackage.haskell.org/).  In any case, once identified, fixing such a solver failure usually just involves uploading a single new package release with the affected bound bumped. If, however, we consider the opt-out scheme, where everyone just sets bounds after there is evidence that it breaks, we get a totally different cost-model: For starters, once the bad bound has been identified, you have to retroactively edit all past package releases meta-data to retrofit the stricter bound. (NB: now you need to be able to edit .cabal files, whereas for the opt-in case, most of the time you get away by uploading a new package version).  Also, in this scheme, any new major version package release may cause real breakage in all packages that were unprepared (i.e. follow the opt-out scheme, and happen to hit an incompatibility) for this new package version introduced into the package pool. Whereas in the opt-in scheme, we get the benefit that previously working install-plans keep working. It's just new install-plans involving completely new major versions that won't get enabled automatically (but the user may selectively use --allow-newer=...).  I hope that we can agree that neither scheme is perfect.  Now to the argument that the opt-out scheme allows for better bounds discovery...   Because users can discover and report build failures.   While I can see how crowdsourcing would help with scalability here, I really don't think users should ever be confronted with compiler errors when they cabal install something from Hackage. Especially when there is actually a valid install-plan, I'd rather the user gets something installed than getting thrown a compile error in the face, having to find out where and how to report the issue, and finally having to wait till the package author fixes the missing upper bound, until she can reattempt to cabal install whatever originally failed (and hopefully now works)...   As to critical bugfixes being blocked by blocked major versions, that's an orthogonal problem more to do with lack of backporting in combination with inadvertent major version bumps. The more important a package is (in terms of its rev-deps), there more the author should consider backporting of critical bugfixes IMO.  Collecting compile errors should rather be left to buildbots with aggregation of build-reports, rather than users having understand what's going on. And I strongly agree that Cabal's current solver-errors are often rather non-obvious, and therefore need to improve to become easier to understand."
haskell,3aluum,mightybyte,0,Mon Jun 22 09:31:23 2015 UTC,you have to retroactively edit all past package releases meta-data to retrofit the stricter bound.   This is only true because of the way the cabal-install solved currently works. The solver could be adjusted to be more intelligent about recognizing that selecting older versions of things just because they have looser bounds is probably the wrong choice.
haskell,3ajy44,implicit_cast,4,Sat Jun 20 22:53:27 2015 UTC,I'm really glad to see focus on testing IO code.  I've been playing around with a derivative of /u/implicit_cast's idea that allows specifying the expected effects and their return values up front in the unit tests: https://gist.github.com/radix/8fe3a182488dc3b570c9  Any feedback would be welcome. Would a Free monad make this any easier to write? And I also need to figure out a better way to define the methods for the testing instance so they're less verbose.
haskell,3ajy44,radix,2,Sun Jun 21 00:19:05 2015 UTC,Would it be possible to auto-generate line 11 to 38?  Isn't that really boilerplate given that MyEffects is known?
haskell,3ajy44,hastor,1 point,Sun Jun 21 19:44:07 2015 UTC,I'm not sure how you'd get rid of the instance of MyEffects for IO. e.g. It's not clear how getStuff would map to getLine.  But I think the thing I need to figure out is a better way to specify the effects such I don't need to write the testing instance. That would mean enriching the core specification with knowledge of which parameters are expected inputs and which are return values.
haskell,3ajy44,radix,2,Mon Jun 22 19:44:58 2015 UTC,"Testing Monadic Code with QuickCheck uses something that is more-or-less a free monad to good effect.  For very vague and fuzzy reasons I can't put my finger on, that paper was a very hard read for me (relative to the points that it made and where I was up to with Haskell and related things at the time).    Eventually I gave a (rushed, underprepared) talk on it to force me to go through it properly :)  I've got related code somewhere, which modifies some of the examples from the paper to use Free for the actions and Writer to log the data used to test for observational equality.    That gets as far as being able to check which lines were written in the IMVU scenario.  Most of the inputs are generated using the Gen monad from QuickCheck, which allowed them to check some nice properties.    IIRC the paper doesn't capture the nice interaction of effects as well as the code from IMVU / /u/implicit_cast.    My gut feeling is that you could probably use Free to do something similar, but that might complicate things unnecessarily unless you also want to do property based testing like in the paper.  I've been meaning to write up some of this for a while.  I've got some related ideas to play with around cofree and testing - if I manage to get more than a post or two from those ideas, I'll write something about QuickCheck, monadic code, and the ideas in that paper as a prequel.  We'll see how we go I guess :)"
haskell,3ajy44,dalaing,6,Mon Jun 22 01:10:12 2015 UTC,"What about using IOSpec, which (IIRC) is a free monad specification of IO?"
haskell,3ajy44,lw9k,4,Sun Jun 21 03:23:47 2015 UTC,"I haven't looked closely at IOSpec, but it sounds like it would work as long as you are ok with specifying things at a low level.  For instance, I wouldn't expect IOSpec to be very helpful for testing a Yesod webserver."
haskell,3ajy44,sccrstud92,2,Sun Jun 21 04:02:18 2015 UTC,"Haven't heard of IOSpec, but this was one of the original use cases for the first thing I ever read about free monads. They would probably be great here."
haskell,3ajy44,jfischoff,5,Sun Jun 21 04:04:04 2015 UTC,"This approach is so obvious and simple that it is hard to grasp how powerfully useful it is for day to day development.   It is one of the things I miss from my time at IMVU. Writing tests for DB and Redis actions was easy and fast. It's hard to articulate what a time saver this was, but now that I don't have this ... it is sorely missed."
haskell,3ajy44,Iceland_jack,3,Sun Jun 21 17:12:03 2015 UTC,"If you need monadic testing Test.QuickCheck.Monadic has good support for it.   Simple use case is testing the result of compileRunRead :: Exp -> IO Value against a pure test oracle eval :: Exp -> Value:  prop_eval :: Exp -> Property prop_eval exp = monadicIO $ do   result <- run (compileRunRead exp)   assert (result == eval exp)   I recently added some examples to the documentation (focusing on .Monadic) to lower the barrier of entry, users shouldn't have to dig through papers to use libraries :)"
haskell,3ajy44,hastor,5,Sun Jun 21 04:44:54 2015 UTC,"This is a great example of the sorry state of testing IO in Haskell.  In dynamic languages like python or JavaScript, and even in java using reflection, FakeState and its World instance is roughly one line of code.  A stub, using reflection should be able to mimic any interface to the point that it is possible to query the stub regarding what arguments it was called with and similar.   This does not require any boilerplate code in other languages. I think some stubbing library is needed for Haskell, possibly using TH or Generic."
haskell,3ajy44,Taladar,2,Sun Jun 21 11:43:21 2015 UTC,"This is a great example of the sorry state of testing IO in Haskell.  In dynamic languages like python or JavaScript, and even in java using reflection, FakeState and its World instance is roughly one line of code.   Having had to debug some production code written in the style using the facilities you describe I am very glad Haskell does not have the mess that is dynamically generated code based on some method getting the name of the method called. It is about the only code I have ever seen where a simple grep to a function called will yield nothing on the entire code base."
haskell,3ajy44,hastor,1 point,Sun Jun 21 13:19:09 2015 UTC,Maybe you misunderstood me? No dynamic parts exist in production.
haskell,3ajy44,Taladar,2,Sun Jun 21 18:01:16 2015 UTC,If the language offers the feature it is going to be used in production by someone so I am glad Haskell doesn't offer this kind of feature.
haskell,3ajy44,hastor,1 point,Sun Jun 21 21:36:23 2015 UTC,"I don't understand.  You think Haskell doesn't offer great ways of writing unreadable or undebuggable code, but writing testable IO code would change the language to something undebuggable?"
haskell,3ajy44,Taladar,1 point,Mon Jun 22 05:12:21 2015 UTC,"No, writing code via something akin to the dynamic language facilities method_missing or similar things would make it undebuggable."
haskell,3ajy44,nolrai,2,Mon Jun 22 07:05:19 2015 UTC,What would it look like?
haskell,3ajy44,hastor,2,Sun Jun 21 15:35:07 2015 UTC,"Imagine something like:  $(mkSpy World) $(mkStub World) $(mkMock World)   mkSpy would be the simplest case, it would create a mkSpyWorld function that returns an WorldSpy which is an instance of World.  Also, for each function foo in the World typeclass, there would be a spyOnFoo function created:  data SpyInfo = SpyInfo NumberOfCalls [CallInfo]  spyOnFoo :: WorldSpy -> SpyInfo   by using mkSpy in tests, it would be easy to check that some IO function was called, how many times it was called, and with which arguments.  The next level of support would be mkStub.  This would create a WorldStub which is also an instance of World.  In addition to the spying, this world would be stubbable.  That is, it would be possible to specify what the functions in World would return.  This could be done like in the article, but a stubbing API could implement sweeping generalization such as ""all functions throw an error"".  All Either return types will return Left mzero.  Stubbing APIs also typicaly contain matching APIs for matching arguments.  Haskell is pretty good at this, so I'm not sure what that API would improve upon normal matching rules.  The next level of support would be mkMock.  This would create a WorldMock which is also an instance of World.  This has all the benefits of the spy and the stub, but in addition, it integrates with the test framework.  A Mock is a stub which also contains expectations, thus assert and possibly lifecycle management.  A mock that is called with the wrong arguments will fail the test.  An API for programming mocks would at least abstract over some assert functionality (regardless of test framework).  This is easy to do in languages with duck typing, but should be doable in Haskell as well.  All of this is pretty well known terminology and widely used in other programming languages such as java, python, and javascript."
haskell,3ajy44,hastor,3,Sun Jun 21 18:57:19 2015 UTC,"It's worth mentioning that, at Imvu, we do not use stubs or spies in our Haskell.  Instead, we offer fully functional fakes for every ""World"" capability.  For instance, instead of using a replay mock to cause a mock database to respond to a particular SQL query to produce a particular result set, we offer a pure database that can actually run the query.  Sensing results is done with an ordinary SELECT.  It works incredibly well."
haskell,3ajy44,hastor,2,Sun Jun 21 19:36:34 2015 UTC,"It was a bit laborious to write, but the power-to-weight ratio of this infrastructure has been astounding.  We haven't made any major changes to it in over a year.  We have just one FakeState across the whole application that implements everything.  We can, for instance, run SQL statements in pure tests and still thread tests across cores as though crosstalk were impossible. (because it is)  The end result is that engineers working on new features don't directly interact with the definition of FakeState.  They don't specify what to mock or how.  They just write ""runFakeWorld def myAction"" and their tests are perfectly reliable and fast."
haskell,3ajy44,WarDaft,2,Sun Jun 21 16:28:49 2015 UTC,"That's good to hear, but that also means that you only have functional tests, not unit tests.  What does this mean?  Let's say we have base IO as the basic IO functions at layer 1.  Then on top of that we have various abstractions, lets call those layer 2.  Then on top of that there is some other abstraction, let's call that layer 3.  When testing layer 3, if all you look at is the inputs (except the World instance) and outputs for the function, then it is a functional test.  If you look at how the function interacts with World, then you have a unit test.    The problem is that your fake World is at layer 1, and your layer 3 function interacts only indirectly with World though layer 2, so when you look at how your function interacts with World, you depend on the implementation of all of those layer 2 functions.  This makes the tests brittle, not in the way that they fail, but they fail when layer 2 is refactored.  There are ""external"" dependencies in the tests.  Better then is to define WorldLayer2 which allows fake versions of higher level abstractions than what World alone can do.  Then check how your layer 3 functions interact with the higher level IO functions in WorldLayer2.  If you go down this path with unit tests, you will find that you can't really define one true World fake, you need fakes that are tailored to the domain the function you are testing operates in."
haskell,3ajy44,hastor,3,Sun Jun 21 19:38:57 2015 UTC,"In practice, this isn't a problem for us.  I think part of the reason why is that our application (an HTTP server) has a very broad but shallow abstraction stack.  I think the other reason is that it just isn't frequently the case that we make a change to some ""layer 2"" that doesn't also change its public interface, in which case the ""layer 3"" code has to change anyway."
haskell,3akn2p,zvxr,2,Sun Jun 21 03:17:29 2015 UTC,"Be there, or be square...ly elsewhere."
haskell,3akn2p,Axman6,1 point,Sun Jun 21 03:18:03 2015 UTC,"Thanks for the post, I'd forgotten to post it on reddit!"
haskell,3ai7hl,atzeus,7,Sat Jun 20 12:36:18 2015 UTC,"Can't wait for a hackage release, this looks promising!"
haskell,3ai7hl,clrnd,7,Sat Jun 20 14:20:44 2015 UTC,They let people submit ICFP papers before the Hackage release :(
haskell,3ai7hl,ndmitchell,7,Sat Jun 20 14:50:31 2015 UTC,"It feels like this is actually gradually changing with the artifact evaluation process PLDI and POPL have been experimenting with.  Well, I doubt they're actually force it any time soon, but they'll definitely encourage people to submit working libraries. And if it starts working well, I'm sure ICFP will join in."
haskell,3ai7hl,tikhonjelvis,6,Sat Jun 20 16:22:46 2015 UTC,"I should note they do have a GitHub account, so it's not ""no code"", just ""no release""."
haskell,3ai7hl,ndmitchell,3,Sat Jun 20 20:49:41 2015 UTC,"Looking through the repo, there are 3 different versions of the code in 3 different directories. What gives?"
haskell,3ai7hl,Soul-Burn,2,Sun Jun 21 06:56:40 2015 UTC,"The artifact evaluation process only happens after a paper is accepted, it has no impact on acceptance and if the artifact fails its evaluation the paper is still accepted."
haskell,3ai7hl,pdexter,2,Sun Jun 21 06:28:11 2015 UTC,I think it already works well and I'm not sure why ICFP didn't join this year. I would definitely be in favor of having an artifact evaluation (AE) process in the following years.
haskell,3ai7hl,gasche,4,Sat Jun 20 17:19:32 2015 UTC,"I think you might want a preliminary release available to reviewers, but not a hackage release. I attached my code to my (rejected) ICFP submission this year, for example, but the upcoming hackage release is a much larger production involving several packages and patches to upstream packages."
haskell,3ai7hl,acow,3,Sat Jun 20 21:10:06 2015 UTC,I'm a fan of release early and often. Just so you don't get a name conflict when trying to upload if anything else...
haskell,3ai7hl,ndmitchell,3,Sun Jun 21 07:04:10 2015 UTC,"Yeah, I'm certainly not saying that having a hackage release would be bad, but that the effort of getting patches accepted and whatnot is largely orthogonal to describing your code.  I of course agree that reviewers should be able to run things to see that it all hangs together."
haskell,3ai7hl,acow,4,Sun Jun 21 15:21:51 2015 UTC,"I guess the title could be a bit of a play on ""Observational Equality, Now!""? I love the double entendre."
haskell,3ai7hl,rehno-lindeque,5,Sat Jun 20 18:53:43 2015 UTC,"Is it just me, or does the programming languages community have a slightly higher than average propunsity for word play? ;)"
haskell,3ai7hl,serendependy,2,Sun Jun 21 06:10:49 2015 UTC,propunsity   I see what you did there.
haskell,3ai7hl,_ion,6,Mon Jun 22 11:29:45 2015 UTC,"If I’m reading this right, this is basically the reformulation of the generator monad idea by presenting generators as plain behaviours. This is similar to an idea I was toying with for a while, but in the end I decided to keep generators a separate type, because in practice it felt confusing to conflate them with behaviours. Also, keeping them a separate type makes it easy to avoid unsafePerformIO."
haskell,3ai7hl,cobbpg,2,Sun Jun 21 06:46:16 2015 UTC,"Yes it is related to that, as we also describe in the related work. The interface is very different though, as well as the explanation. Why do you think it is confusing to making generators and behaviors the same type? As I see it, a generator is best explained as a Behavior (Behavior a), i.e. given a start time, give something that changes over time. The use of unsafePerformIO in the implementation has nothing to do with making generators and behaviors the same type, but with sharing (and switch). I don't see any way around this, as b switch e must mutate to forget b after e has happened to prevent the space leak. The relation with the denotational semantics shows that this trick is OK, it will not change the results of programs."
haskell,3ai7hl,cobbpg,3,Mon Jun 22 12:10:29 2015 UTC,"Not really for reasons of semantics, but rather due to API usability. At least for me it felt much easier to have a type-level distinction between creating stateful entities and combining them statelessly. Besides, it comes with the added bonus of being able to add other features to the generation layer (e.g. the clock system) without having to change your thinking about how you use it.  Even if implementations are getting better and better, the application design side of the FRP story remains an open and very exciting research area. I’m looking forward to seeing how it plays out."
haskell,3ai7hl,maninalift,3,Mon Jun 22 19:57:27 2015 UTC,Could fig. 4 maybe be plotted as a line? On a log scale scale? Maybe making a clearer visual distinction between the data sets than black and dark-grey?  I wouldn't be quibbling but I'm really too tired to read this now and I want to and this is how I express my frustration.
haskell,3ai7hl,davemenendez,1 point,Sat Jun 20 21:26:35 2015 UTC,"Sorry :) Looked ok on my screen, but I agree the color difference is a bit small. As a work around, increase the contrast :)"
haskell,3ai7hl,jonsterling,3,Mon Jun 22 14:38:11 2015 UTC,"I like the semantics described here, although the need for unsafePerformIO is worrying. I'm always concerned that the compiler might move things around in an unexpected way.  Events seem very much like IVars, so perhaps there is a way to implement them more directly. (Although these are apparently prone to space leaks as well.)  In any case, it seems like you should be able to avoid updating an event's IORef once the final value is known. Perhaps something like this:  memoEIO :: IO (M (Either (E a) a)) memoEIO einit = do     r <- newIORef (Left einit)     return (usePrevE r)  usePrevE :: IORef (Either (E a) a) -> M (Either (E a) a) usePrevE r = E $ do     res <- liftIO (readIORef r)     case res of         Right _ -> return res         Left e -> do             res' <- runE e             liftIO (writeIORef r res')             return res'"
haskell,3ai7hl,neelk,3,Mon Jun 22 19:47:51 2015 UTC,"I'm also concerned about the compiler moving stuff around :) It requires some thought, but the optimization shown in the paper is safe even when the compiler shuffles around code. This can destroy sharing: two instances of an event or behavior use two IORefs instead of one, but it cannot cause breakage, or reintroduce the space leak (since we still use an IORef).  Indeed the events are very similar to IVars, they are essentially IVars with a more extensive interface (Monad instance, planNow, switch).  The optimization you describe indeed works :)"
haskell,3ai7hl,rehno-lindeque,5,Tue Jun 23 07:44:31 2015 UTC,"This way of doing I/O is reminiscent of the stream based I/O that was used in early versions and precursors to Haskell, before monadic I/O was introduced.   i find this section interesting, because it is my understanding that frp is in no small part motivated by a dissatisfaction with the IO Monad as a solution to the previous streaming / continuation based solutions  in reactive banana, there is a bit of busyness with writing your core event loop and setting up primitive inputs, but i have been using the vinyl library in a convenient way to add new primitive Event without touching any of my event-graph-construction code  something like  import Data.Proxy import Data.Vinyl import Data.Vinyl.Functor (Const (..), Lift (..)) import Control.Concurrent.Chan (Chan, newChan, readChan) import Lens.Family2 (Lens') import Reactive.Banana.Frameworks (AddHandler, fromAddHandler, newAddHandler)  type Inputs = '[Click, Fps]  -- forgive me, i have no unicodes. in should be read as that set membership operator click :: (Click in rs) => Lens' (Rec f rs) (f Click) click = rlens Proxy fps :: (Fps in rs) => Lens' (Rec f rs) (f Fps) fps = rlens Proxy  --------------------------------- -- We need to build a record of `Handler` and a record of `AddHandler` newtype Handler a = Handler { handle :: a -> IO () }  newRow :: ( Rec AddHandler rs, Rec Handler rs )              -> IO ( Rec AddHandler (r ': rs), Rec Handler (r ': rs) ) newRow ( ahs, hs ) = do     ( ah, h ) <- newAddHandler     return ( ah :& ahs, HAndler h :& hs )  genRecords :: Rec (Const ()) rs -> IO ( Rec AddHandler rs, Rec Handler rs ) genRecords (_ :& rest) = newRow =<< genRecords rest genRecords RNil = return ( RNil, RNil )  -- it fills any shape putty :: RecApplicative rs => Rec (Const ()) rs putty = rpure (Const ())  initHandlers :: RecApplicative rs => IO ( Rec AddHandler rs, Rec Handler rs ) initHandlers = genRecords putty  setupInputs :: Frameworks t => Rec AddHandler Inputs -> Moment t (Rec (Event t) Inputs) setupInputs = rtraverse fromAddHandler  --------------------------------------- -- set up event registering code type Registrar = Chan (IO ()) -> IO () registerClick :: Handler Click -> Registrar registerFps :: Handler Fps -> Registrar  register :: Rec Handler Inputs -> IO () register handlers = do     c <- newChan     -- actually we need to do some `Async` work here, but i     -- hope the picture is clear to folks     mapM_ ($ c) (recordToList (registrars <<*>> handlers))     forever $ do         act <- readChan c         act     where     registrars = Lift (Const . registerClick) :& Lift (Const . registerFps) :& RNil"
haskell,3ai7hl,sinelaw,1 point,Sat Jun 20 15:35:37 2015 UTC,I'm confused. What is this demonstrating?
haskell,3ai7hl,TimTravel,2,Mon Jun 22 17:17:31 2015 UTC,"the article makes such claims as   It is hard to extend: new input and output facilities can only be added by changing the Input and Output types, and then changing the wrapper program.   the code above provides a way to add new primitive event streams by adding them to the registrars record. code which uses these inputs must only be updated if it asks for the new field, in which case it just uses one of the provided lenses and propagates the constraint for the field's membership in the record of inputs"
haskell,3ai7hl,glaebhoerl,3,Mon Jun 22 17:28:57 2015 UTC,"The claim you quote is about Arrowized FRP, not about all FRP libraries, and in particular not about reactive-banana. Reactive banana has other difficulties concerning IO: it requires you to hook up all event streams statically (before starting the FRP stuff), which is problematic for example for dynamically opening files or dynamically creating widgets."
haskell,3ai7hl,Sonarpulse,1 point,Tue Jun 23 07:34:11 2015 UTC,"thank you for the clarification. i am on my second day of digesting this paper, and i think what is the meat of it to me (as an api user) is this Now monad which is a lot like reactive banana's Moment t monad except that it does not require a Frameworks t constraint to perform io. i do admit it looks like a lot less ceremony to do dynamic event switching with io here, and that is an ergonomic win i am looking forward to, but i'm not sure the claim is true that you can not write these same events without this novel construction"
haskell,3ai7hl,dominiquedevriese,2,Tue Jun 23 13:50:45 2015 UTC,Nice! Looking forward to giving this a read.  Kripke stuff sounds interesting....
haskell,3ai7hl,dominiquedevriese,5,Sat Jun 20 15:19:40 2015 UTC,"Just an FYI: the Kripke structure they use is not the same as the Kripke structure of time that I and the others who have worked on temporal-logic-based FRP have used -- this is something new.   My main disappointment is that they don't connect their criterion to an implementation, but that just means I'll need to read their next paper. :)"
haskell,3aj47b,mgoszcz2,6,Sat Jun 20 18:15:36 2015 UTC,One feature I particularly like about this library is that the documentation comments are tests. [...] I run these tests by passing them through a preprocessor   Have you considered using doctest?
haskell,3aj47b,rampion,6,Sat Jun 20 19:47:02 2015 UTC,"Yes, but I decided against it, as I have about 5 times in the past, eg for the filepath library. I find writing a one off doc generator is pretty easy and gives me flexibility to do custom things which are inappropriate in a generic tool, but make the tests better as docs for my users. As some examples:   In filepath I infer all single letter variables to be forall quantifiers.  In extra I use Eq on IO that captures stdout. In filepath I run all tests against two different modules.  In extra == undefined means it throws an exception.    If I had to use either filepath or extras doc gen tests on the other it wouldn't work as nicely. I do love the idea of a doc test package, and do encourage its use, but writing a quick one for a project gives a lot of freedom and not that much work."
haskell,3aj47b,ndmitchell,3,Sat Jun 20 20:59:56 2015 UTC,reminds me MissingH
haskell,3aj47b,vagif,1 point,Sat Jun 20 20:31:54 2015 UTC,"Not a coincidence :). This library is aiming for a subset of the kind of things that MissingH did, without the bigger pieces like a CSV parser etc."
haskell,3aj47b,ndmitchell,3,Sat Jun 20 20:51:20 2015 UTC,I noticed that you reimplemented a large portion of split library. Is there a reason?
haskell,3aj47b,vagif,1 point,Sat Jun 20 20:52:44 2015 UTC,"The split library is more general with more options - I think I even recommend it in the docs for those who want more. All I did was generalise the lines/words from base, plus port over the functions in text to work on list. That gives you the most common splits, but not the general pattern and options of split."
haskell,3aj47b,ndmitchell,1 point,Sat Jun 20 21:09:04 2015 UTC,"Oh, and last time I looked at split I didn't see linesBy/wordsBy, so I didn't think I was reimplementing as much as I did!"
haskell,3aj47b,ndmitchell,1 point,Mon Jun 22 05:47:42 2015 UTC,I've seen of this library. Is it something largely used or better to stay away from ?
haskell,3aj47b,maxigit,1 point,Sun Jun 21 10:43:22 2015 UTC,"It's from a different era. Best avoided now, but 10 years ago, it was useful."
haskell,3aj47b,ndmitchell,2,Sun Jun 21 15:56:29 2015 UTC,What are the reasons for avoiding it?
haskell,3aj47b,ndmitchell,4,Sun Jun 21 16:28:25 2015 UTC,"Maybe ""avoid"" is a strong term. It's a bunch of things, some unrelated, some unportable, some superseded by functionality in libraries like filepath, many still useful. It's fine to use, but most things in it could be found in a better form elsewhere. The only things not anywhere else are the kind of things I put in the extra library."
haskell,3aj47b,_deepfire,8,Sun Jun 21 17:19:01 2015 UTC,Wish we had some kind of support infrastructure for organizing garbage-collection on the library namespace..
haskell,3aj47b,SkoomaMudcrab,5,Sun Jun 21 19:59:58 2015 UTC,I am happy to provide partial functions (e.g. fromRight)   I don't get it. How is that something to be proud of?
haskell,3aj47b,ndmitchell,20,Sat Jun 20 20:14:17 2015 UTC,"It's a statement, not a boast. I find those functions useful, so I include them. When writing a one off data analysis pass, I use partial functions plenty, so it's nice not to have to reinvent the wheel. When writing an automated trading algorithm I exercise more caution. However, even there, what I care about is that the program doesn't crash, which requires knowing what is partial and where. And even there, I'd rather blow up if my expectations are violated than do the wrong thing.  I wish there was a checker that allowed partial functions but checked they didn't make the program partial. In fact, I would like that so much that I spent my PhD writing one :) See http://community.haskell.org/~ndm/downloads/paper-not_all_patterns_but_enough-25_sep_2008.pdf"
haskell,3aj47b,chrisdoner,6,Sat Jun 20 21:06:28 2015 UTC,Still on my wishlist to get Catch ported to GHC.
haskell,3aj47b,maxigit,1 point,Sun Jun 21 13:07:37 2015 UTC,"Sometime , you KNOW the partial function  won't crash because you just build the data for it. Example  fromJust  $ something            <|> defaultValueFromLocalConfiguration           <|> defaultFromGlobalConfiguration           <|> Just hardcodedDefaultValue    The last Just ... garantie that fromJust won't fail. You obviously can write in lots of different way , but I found it clear as it is."
haskell,3aj47b,chrisdoner,4,Sun Jun 21 10:42:36 2015 UTC,"Sometime , you KNOW the partial function won't crash   This line of reasoning does not take you to a happy place. I argued why here."
haskell,3aj47b,ndmitchell,1 point,Sun Jun 21 12:57:21 2015 UTC,"I think you are more arguing hat GHCs lack of stack traces sucks, which it does.  Mu has them which suddenly means fromJust does throw a meaningful error."
haskell,3aj47b,chrisdoner,2,Sun Jun 21 15:59:04 2015 UTC,"I think you are more arguing hat GHCs lack of stack traces sucks, which it does.   No, the fact that these preventable exceptions even happen in programs that I am using is what motivates this distaste. The fact GHC's error messages are unhelpful is an orthogonal point."
haskell,3aj47b,gergoerdi,6,Sun Jun 21 17:32:11 2015 UTC,"Why not use something like  fromMaybe hardcodedDefaultValue . msum $         [ defaultValueFromLocalConfig     , defaultFromGlobalConfig     ]   in that case?   Look ma, no partial functions!"
haskell,3aj47b,maxigit,8,Sun Jun 21 13:43:55 2015 UTC,"Because you forgot the most important bit which is the something and I'm not joking. It's a problem of expressing your idea. The idea here is to get something or the value from the local config or the value from the global one or finally the hardcode value. The fromMaybe mess up the order which is even not reverse but becomes 4 1 2 3 (if number where the priority). It's just unnecessary confusing, which leads to different sort of bugs (ie forgetting the something ;-))."
haskell,3aj47b,_ion,3,Sun Jun 21 14:15:19 2015 UTC,"asum [ something      , defaultValueFromLocalConfiguration      , defaultFromGlobalConfiguration      ] & fromMaybe hardcodedDefaultValue"
haskell,3aj8y3,keithb,6,Sat Jun 20 18:58:31 2015 UTC,"it doesn't say that you have to sudo the command   That's because you don't. In fact, you probably shouldn't.   nor that you have to have $HOME/.cabal/bin on the path   You don't, but it's very useful. This is standard cabal stuff though, so that might be the reason why the leksah documentation doesn't mention it. --global isn't required either; pretty much all haskell packages work just fine if you install them per-user.   This on OS X 10.10.3 with XCode 6.3.2 and its command line tools installed and ghc 7.8.3 and cabal-install 0.8.0 “using version 1.8.0.2 of the Cabal library”.   Debian user myself, so I can't tell what the right way of installing GHC on OS X would be, but I'd assume that if you were to follow these instructions, you'd get a working GHC 7.8 with a new-ish Cabal (1.18), and it should work. OS X requires more yak-shaving than any of the GNU/Linux flavors (where it's basically just a matter of apt-get install haskell-platform), but the idea is that installing Haskell-platform takes care of that for you.  As for the dependency problems and compiler errors, I don't know anything about these, but a failed package build is often a matter of missing system libraries.  Either way, I recommend heading over to #haskell on freenode, there's an incredible bunch of tremendously helpful people there, including many OS X users, I'm sure they can help you better than I could."
haskell,3aj8y3,tdammers,2,Sat Jun 20 19:23:49 2015 UTC,"As for the dependency problems and compiler errors, I don't know anything about these, but a failed package build is often a matter of missing system libraries.   Well, the build will say, for example  ld: library not found for -lHStext-1.2.1.1-ghc7.8.3   but there is a   /usr/local/lib/text-1.2.1.1/ghc-7.8.3/HStext-1.2.1.1.o    and a   /Users/keithb/.cabal/lib/text-1.2.1.1/ghc-7.8.3/HStext-1.2.1.1.o   so odd that a cabal build can't find (either of) them, I'd have thought."
haskell,3aj8y3,creichert,2,Sat Jun 20 19:39:53 2015 UTC,"When something like this happens, the first thing I do is try to reinstall again with. cabal install -v -j1 <package>. The probelm in the initial run is that it's less verbose when installing the packages in parallel so you might not be able to identify the real source of the error.  Can you run the command again with those flags and post the full build log? I don't use OSX but I would try to avoid using sudo cabal install anything unless it's absolutely necessary (which I don't think it is)."
haskell,3aj8y3,BethAr,3,Sat Jun 20 20:40:53 2015 UTC,"So, with a clean environment now the leksah build needs a newer gtk2hsC2hs than I have, and updating that needs a newer alex and a newer happy than I have…and after that I need pkg-config in order to install a newer glib…"
haskell,3aj8y3,hamishmack,2,Sat Jun 20 21:53:03 2015 UTC,"I've manually deleted every haskell-y looking thing on this machine, re-installed The Haskell Platform and now am trying to build leksah again, more as a smoke test for the HP install now that I have a binary for leksah anyway."
haskell,3aj8y3,yitz,2,Sat Jun 20 20:50:07 2015 UTC,"Debian user myself, so I can't tell what the right way of installing GHC on OS X would be, but I'd assume that if you were to follow these instructions[1] , you'd get a working GHC 7.8 with a new-ish Cabal (1.18), and it should work.   I assumed that too ;) Turns out not. Thanks for your other comments, though."
haskell,3aj8y3,snoyberg,3,Sat Jun 20 19:42:04 2015 UTC,"I have no experience with OS X, but sometimes you can get things to install by deleting the tmp folder and trying again. If that doesn't work, I would often have to delete .cabal as well, but don't do this until you get better advice from Mac people.  There is a .dmg for Leksah, hopefully you have seen it: https://github.com/leksah/leksah/wiki/Leksah-0.15.0.3"
haskell,3aj8y3,sambocyn,3,Sat Jun 20 19:19:13 2015 UTC,The .dmg is probably the way forward. Even after downloading a binary of the latest cabal the  leksah install has a really long list of unmet dependencies that stop it from building. Isn't that what cabalis exactly mean to manage?
haskell,3aj8y3,sambocyn,3,Sat Jun 20 19:25:51 2015 UTC,Here are the most up to date instructions on how to build leksah on OS X.  But as someone else noted you might just want to grab the DMG file.
haskell,3aj8y3,Taladar,3,Sun Jun 21 08:47:55 2015 UTC,"How did you end up with such an old version of cabal? Haskell Platform gives you one that does understand sandbox. There's an alternative installer called ""GHC for OS X""; I don't use that, but I'm quite sure it also gives you a version of cabal that understands sandbox.  Whatever non-standard thing you did to install your broken Haskell tool set, you should undo, install one of the standard installers, and start again. It should work fine then.  No, do not use --global and do not use sudo. Do it exactly the way the leksah site says."
haskell,3aj8y3,Taladar,1 point,Sun Jun 21 11:19:40 2015 UTC,"It should work fine then.   I've done that and it does not. And frankly, I've lost interest. No other current programming toolset is ths brittle."
haskell,3aj8y3,ephrion,4,Sun Jun 21 11:37:26 2015 UTC,"I'm sorry to hear that, and unfortunately this is something I hear all too frequently. A number of us are trying to fix the status quo of the tooling in Haskell to avoid these kinds of problems. As someone else linked to in this thread, you may want to give stack a shot, with the caveat that it's still in beta and not all software (like Leksah) is tested with it yet."
haskell,3aj8y3,yitz,1 point,Sun Jun 21 16:17:32 2015 UTC,"Many years ago I challenged SPJ at a conference regarding the sad state of Haskell tools. He smiled his matinée idol smile and told me to use EMACS. That wasn't good enough then and it's really not good enough now. If the haskell community really wants to make it on any meaningful scale with industrial practitioners then you need to provide slick tools which pretty much work out-of-the-box on every mainstream platform. It doesn't have to be as good as IntelliJ is today, but if it were, say, as good as the Lisp tools were twenty years ago that would be adequate.   A couple of years ago I paid for my team to do a haskell training course (mainly for the intellectual exercise) and the best that the trainer, a professional  haskell programmer, could do was SublimeText with some rats' nest of plugins. Practitioners don't think of programs as complex text needing a clever text editor. We shouldn't be forced to think of haskell programs that way because the only tools that work reliably everywhere are clever text editors."
haskell,3aj8y3,snoyberg,1 point,Sun Jun 21 18:52:49 2015 UTC,"I feel the pain, but for me, writing Haskell in emacs (without even haskell-mode installed) and compiling in a terminal, was much more easier than jumping to definition in IntelliJ.  once a Haskell IDE with Java IDEs' like 1000 features exists, it will go from the programming language providing the best programming experience to the programming language providing the best programming experience that's also a good experience. at least, for me."
haskell,3aj8y3,yitz,1 point,Sun Jun 21 22:00:45 2015 UTC,"I'm not sure that I can parse you penultimate sentence.   I'm a tired old man and I just want an easy life. Mainly I want to write a program to solve my problem, not fiddle about with tools. I did EMACS (and vi) based tool-chains twenty years ago and more and I don't want to go back to that. And, I'm a Smalltalk and Lisp guy at heart—a program should not be some sort of Frankenstein's monster sort of assemblage of dead things (ie text files) that we do surgery on and then they get jazzed into unnatural life now and again (ie compiled, linked, loaded and run). Programs should be living, growing symbiotic organisms. IntelliJ (and relatives) and Eclipse do a really good impression of that for Java and a bunch of other compiled languages. I want that for haskell, too. (Well, actually I want it for the smaller, cleaner, more stable language that's inside haskell trying to get out)."
haskell,3aj8y3,hamishmack,1 point,Sun Jun 21 23:15:24 2015 UTC,"I think my sentence parses, but if it was unclear: I just meant that coding in Haskell could be really fun all the time given the detailed feedback and massive refactorings that are possible, given the information statically provided its type system."
haskell,3aj8y3,snoyberg,3,Thu Jun 25 07:10:23 2015 UTC,They all are if you install a version so ancient it is from pre 1.0 days for a program that has been past 1.0 for years.
haskell,3aj8y3,hamishmack,0,Sun Jun 21 16:29:45 2015 UTC,"A better toolchain would have told me that this was the problem, and good documentation would have let me work it out. And a friendly, helpful community member would refrain from inviting the inference that I'm just an idiot."
haskell,3aj8y3,Crandom,2,Sun Jun 21 18:54:47 2015 UTC,"There is plenty of documentation that shows you the current cabal and cabal-install version, particularly the minimum version required to use sandboxes as they are a recent feature.  We all make mistakes and I do not think you are an idiot at all for making this one...however judging Haskell as a whole based on this experience with an old version seems quite harsh."
haskell,3aj8y3,hamishmack,1 point,Sun Jun 21 21:35:49 2015 UTC,"I've not made any statements about haskell as a whole here, only and specifically about the tools."
haskell,3aj8y3,yitz,4,Sun Jun 21 23:06:54 2015 UTC,"Honestly, the new stack tool is pretty great about solving these sorts of problems."
haskell,3aj8y3,hamishmack,6,Sun Jun 21 03:56:32 2015 UTC,How does the new stack tool prevent people from using some non-standard installation process and ending up with an ancient and broken version of cabal?
haskell,3aj8y3,yitz,2,Sun Jun 21 11:22:07 2015 UTC,"One reason would be that stack install cabal-install will default to using the latest LTS release. But to be honest, installing cabal-install isn't a common use case for stack."
haskell,3aik5c,agumonkey,3,Sat Jun 20 15:06:36 2015 UTC,What's the difference between a catamorphism and a generalised fold? I've always had catamorphism described to me as a 'generalised fold'.
haskell,3aik5c,Crandom,3,Sun Jun 21 05:18:50 2015 UTC,"catamorphisms are often described as being a generalization of fold :: (a -> b) -> b -> [a] -> b to functors other than []  the generalizations discussed in the paper is more about ""how do i find the structure where i can slot in different things to get these different kinds of morphisms for my functor, catamorphisms being among them"""
haskell,3aik5c,Crandom,4,Sun Jun 21 13:38:04 2015 UTC,"Sure, but I'm curious about generalised folds vs catamorphisms specifically - throughout the video Wu talks about them as if they are different (X works for nearly everything except generalised fold) and the zoo of morphisms slide at 11:04 has them as different things."
haskell,3aik5c,edwardkmett,3,Sun Jun 21 14:01:54 2015 UTC,"cata :: Functor f => (f x -> x) -> Mu f -> x cata f = c where c = f . fmap c . out   is a 'slightly generalized' fold in that it takes an arbitrary f-algebra and lets you tear down the least fixed point with it, whereas normally we just deal with foldr :: (a -> b -> b) -> b -> [a] -> b  but if we take the base functor of [] to be data L a b = Nil | Cons a b then we can see that foldr is just taking that (L a)-algebra apart into two functions. Going backwards:   foldr :: (a -> b -> b) -> b -> [a] -> b  ~ (a -> b -> b, b) -> [a] -> b  ~ ((a, b) -> b, b) -> [a] -> b  ~ ((a, b) -> b, () -> b) -> [a] -> b  ~ (Either (a, b) () -> b) -> [a] -> b  ~ (L a b -> b) -> [a] -> b   On the other hand, in the 'recursion schemes from comonads' (rsfc's in the talk) world, it was discovered that you can build a fold that is a bit more stylized.  gcata   :: (Functor f, Comonad w)   => (forall b. f (w b) -> w (f b)) -- ^ a distributive law   -> (f (w a) -> a)                 -- ^ a f-w-algebra   -> Mu f                           -- ^ fixed point   -> a gcata k g = g . extract . c where   c = k . fmap (duplicate . fmap g . c) . out   Here we use the distributive law to keep pushing the source of our comonad out of sight so that we never need to 'start' it.  By carefully picking the comonad and the distributive law you can get interesting recursion schemes, including most of the ""zoo of morphisms"" described at the beginning of the talk. (You need to deal with a similar distributive trick to work with monads and anamorphisms to get all of them.)  At some point I showed you can combine these distributive laws into distributive laws for known comonad transformers. These recursion schemes let you build bigger and bigger schemes. From this primordial stew  the mythic  ""zygohistomorphic prepromorphism"" was born -- just by smashing together distributive laws and asking ""what does this mean!?""  The talk spoke about how all of these generalized recursion schemes from comonads are instances of adjoint folds."
haskell,3aik5c,zenzike,2,Mon Jun 22 19:39:42 2015 UTC,"Yup, edwardkmett has hit this on the head: that's exactly what I meant when I was distinguishing catas from generalised folds."
haskell,3aj17l,_skp,3,Sat Jun 20 17:47:59 2015 UTC,"This post also announces the hid package, a binding to the hidapi C library. The author says that the existing hidapi Haskell binding ""doesn’t work and has bugs""; hid also includes the hidapi documentation in the Haddocks."
haskell,3aj17l,conklech,2,Sun Jun 21 21:45:25 2015 UTC,"I include the hidapi C documentation, yes.  The Haskell hidapi (here) returns a list of HID devices that is not correct. That’s why I decided to write my own."
haskell,3aj17l,TotesMessenger,2,Sun Jun 21 22:40:15 2015 UTC,"I'm a bot, bleep, bloop. Someone has linked to this thread from another place on reddit:   [/r/gamingpc] HID and MSI keyboards • /r/haskell (x-post)   If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads. (Info / Contact)"
haskell,3aj17l,conklech,2,Sat Jun 20 17:51:17 2015 UTC,"To save others the wasted click: that post has been deleted and has one comment: ""Uhh. Okay."""
haskell,3aj17l,conklech,1 point,Sun Jun 21 21:38:49 2015 UTC,"I got the post downvoted, so I decided to delete it."
haskell,3agmpy,gelisam,3,Sat Jun 20 00:13:14 2015 UTC,"A great article, but I do not agree with the last statement:    I hope that this last example makes it clear that sharing is something you can control.   In my experience, it is quite possible to get GHC to share some data. What is difficult or near impossible though is getting GHC to not share some data. So it's only true in one direction: if you want sharing, you can control it. But if you want to avoid sharing, that is difficult.   Just see http://stackoverflow.com/q/21891096/2494803 for an example. Preventing sharing in this case depends on disabling certain compiler optimizations and choice of correct pragmas."
haskell,3agmpy,pycube,3,Sat Jun 20 11:33:27 2015 UTC,It looked like Oleg's example for preventing sharing didn't rely on any extensions (just pragmas). Has the compiler gotten even smarter since then?
haskell,3agmpy,rpglover64,7,Sat Jun 20 14:12:31 2015 UTC,Yeah but Oleg's trick is completely nutty and not robust at all.  Just use -fno-full-laziness and -fno-cse and be done with it.
haskell,3agmpy,tomejaguar,5,Sat Jun 20 14:44:04 2015 UTC,"Those can be applied on a module level, right? So in principle, we could pull out the code that needs to avoid sharing into its own module without affecting optimizations in the rest of the program?"
haskell,3agmpy,rpglover64,3,Sat Jun 20 15:40:22 2015 UTC,You can put them in an OPTIONS_GHC at the top of a module but I don't know how it affects the compilation of other modules.
haskell,3agmpy,tomejaguar,2,Sat Jun 20 15:43:37 2015 UTC,"I'm not sure, I haven't tried that yet. My experience comes from debugging the reflex FRP library, which uses weak pointers and therefore has to control sharing."
haskell,3agmpy,pycube,2,Sat Jun 20 14:47:26 2015 UTC,"Disclaimer: I haven't tried this out.  If I understand the blog post correctly, you just need the scope of the functions to have different things in them. How about changing the xs to have type Int -> Int and then just not use its argument?"
haskell,3agmpy,penguinland,2,Sat Jun 20 12:08:27 2015 UTC,"GHC will float out things that do not depend on the argument to the toplevel, so this will not work (it'll sometimes transform \() -> ... to let x = ... in \() -> x )"
haskell,3agmpy,pycube,1 point,Sat Jun 20 12:37:29 2015 UTC,This did not happen in the blog post. Do you have a sense of why it didn't happen there?
haskell,3agmpy,penguinland,8,Sat Jun 20 12:39:45 2015 UTC,"Because I ran my code with ghci! I didn't realize optimizations were allowed to increase sharing. I just tried all my examples again with -O2 level optimizations, and this time, every single example memoized! Even the four fib functions at the end shared their results with each other."
haskell,3agmpy,want_to_want,1 point,Sat Jun 20 13:02:53 2015 UTC,"Wow. Does that mean Haskell has no concept of big-O space complexity at the language level, because optimizations can affect it? That's pretty wild."
haskell,3agmpy,rpglover64,6,Sat Jun 20 13:28:08 2015 UTC,"I think this is true for most languages, not just Haskell."
haskell,3agmpy,augustss,5,Sat Jun 20 14:08:11 2015 UTC,Assuming that the optimization improve things then big-O complexity is unaffected.
haskell,3agmpy,tomejaguar,2,Sat Jun 20 15:35:25 2015 UTC,What do you mean?  Optimizing  length (f ()) + length (f ())   into  let f' = f () in length f' + length f'   increases space complexity from O(1) to O(n).
haskell,3agmpy,augustss,5,Sat Jun 20 15:46:00 2015 UTC,"I said, assuming it improves things. :)   This kind of transformation is why ghc is very reluctant to do much CSE."
haskell,3agmpy,tomejaguar,2,Sat Jun 20 15:56:23 2015 UTC,"Yes, assuming it improves things it won't make things worse :) (for the same value of things)"
haskell,3agmpy,VikingofRock,2,Sat Jun 20 16:06:05 2015 UTC,Thanks for pointing this out. I have updated the post to reflect this important caveat.
haskell,3afi3t,chrisdoner,16,Fri Jun 19 18:35:09 2015 UTC,"An equivalent way to understand the difference is to observe that the following instance definition  instance IsString (Writer String ())   will only block IsString (Writer String ()) from being redefined again, thus the compiler cannot prevent some other module from defining something else such as  instance IsString (Writer String Int)   which would cause a definite ambiguity in the expression do ""hello""; ""world"" :: Writer String () as both instances are valid here.  In contrast, this instance  instance (a ~ ()) => IsString (Writer String a)   will block any instance of the form IsString (Writer String _) from being defined again, regardless of constraints, and thus the compiler is safe to assume that this is the only possible instance."
haskell,3afi3t,Fylwind,4,Fri Jun 19 21:03:59 2015 UTC,"this is the only possible instance   And therefore the only possible 'value' of a is (), right?"
haskell,3afi3t,theonlycosmonaut,5,Sat Jun 20 03:16:26 2015 UTC,Essentially (when the constraint solver gets around to it).
haskell,3afi3t,Fylwind,3,Sat Jun 20 04:36:04 2015 UTC,Sounds singleton-ey.
haskell,3afi3t,beerdude26,14,Sat Jun 20 17:19:12 2015 UTC,"Really good to see this being written up - it's knowledge that seems to get informally passed down, but it makes a huge difference when it comes to inference and building pragmatic libraries. Thanks Chris!  P.S. you still need to merge my suggestion that uses even more of this trick to lucid ;)"
haskell,3afi3t,ocharles,13,Fri Jun 19 18:50:35 2015 UTC,"This goes back to oleg I think. He did it before we had ~, so he had to write his own ~ which he called TypeCast (and is actually a bit more powerful than ~ still, though closed type families bring us closer).  http://okmij.org/ftp/Haskell/typecast.html  The use of TypeCast was the key enabling trick in all the magic in the HList library.  I think very quickly after the introduction of ~ lots of us realized that it could do about 2/3 of what TypeCast did, with a bit less hassle."
haskell,3afi3t,sclv,8,Fri Jun 19 19:04:00 2015 UTC,"Yeah I learned it from http://okmij.org/ftp/Haskell/typeEQ.html . When you combine it with OverlappingInstances you can do some pretty interesting things. I used the trick to implement a really complicated type-checked fuzzy coerce function (see the docs for a description), using chains of type-level predicates  http://hackage.haskell.org/package/shapely-data-0.1/docs/src/Data-Shapely-Normal-Massageable.html#Massageable  Unfortunately a lot of the code only worked apparently because of a typechecker bug in GHC 7.6 . So that was a cool way to spend a bunch of hours..."
haskell,3afi3t,jberryman,9,Fri Jun 19 20:57:06 2015 UTC,"I've used this trick for years, but I first stole the trick from Daniel Wagner (/u/dmwit). I don't know what prompted him to come up with it or where he learned it, however."
haskell,3afi3t,edwardkmett,11,Fri Jun 19 18:49:45 2015 UTC,I think the exceptions library is one of the first instances (hur hur) of this that I encountered. :-)
haskell,3afi3t,paf31,7,Fri Jun 19 18:58:16 2015 UTC,"Constraints only apply after GHC has already decided it’s going with this instance.   This is the ""Aha!"" moment for me. Can anyone summarize why GHC makes this choice? Why not backtrack and try another instance if the subgoals aren't satisfiable?"
haskell,3afi3t,edwardkmett,20,Fri Jun 19 21:35:11 2015 UTC,"Why not backtrack and try another instance if the subgoals aren't satisfiable?   That alternative design at first seems more powerful, but it is fundamentally anti-modular.  Now adding an instance in one module could and should change the behavior of existing code, code that has already been written and compiled!"
haskell,3afi3t,tikhonjelvis,9,Fri Jun 19 21:50:36 2015 UTC,"In some sense, though, it just exposes the fundamentally anti-modular ""open world"" nature of typeclass instances. That is, the fact that instances are always completely global and outside of your control is what really exacerbates the problem; otherwise, it could at least be controlled with fine-grained importing.  Unfortunately, I don't know how to get around it without sacrificing some of the things that make typeclasses so useful and powerful :/. It's a hard design problem."
haskell,3afi3t,edwardkmett,6,Fri Jun 19 23:45:46 2015 UTC,Any mechanism that allows you to restrict the space of instances you see destroys the coherence of instance resolution. =(
haskell,3afi3t,danharaj,2,Sat Jun 20 01:23:49 2015 UTC,At this point do you have a complete flow chart for answering criticisms to the type class mechanism?
haskell,3afi3t,edwardkmett,3,Mon Jun 22 03:55:22 2015 UTC,I can't tell if its complete. I maintain an open universe assumption. =)
haskell,3afi3t,hiptobecubic,3,Mon Jun 22 04:29:53 2015 UTC,How was it compiled if it didn't already have a valid instance to use?
haskell,3afi3t,edwardkmett,6,Sat Jun 20 01:47:14 2015 UTC,"If you can backtrack and try another instance if the subgoals aren't satisfiable then another instance can succeed. That is sort of the purpose of backtracking in the first place.  Now consider a scenario where you have  instance Comonad m => Whatever m  orelse instance Monad m => Whatever m  instance Monad Foo   Now say the user doesn't supply a Comonad instance for your particular so you pick Monad Foo to derive your Whatever Foo instance. Then suppose later on in another module they specify   instance Comonad Foo   Now defining a new instance later really changes which instance should have been selected in all that code that selected the Monad before -- if you want to have coherent instance resolution throughout your program.  In the absence of backtracking this is not a concern. Adding new instances just lets more code compile, it doesn't change the semantics of existing code."
haskell,3afi3t,hiptobecubic,3,Sat Jun 20 02:27:06 2015 UTC,"Ah ok. I hadn't thought about the case of several ways to succeed, only that introducing more modules allow you to succeed where you previously could not. Thanks."
haskell,3afi3t,twanvl,3,Sat Jun 20 02:33:55 2015 UTC,"A way to avoid that problem with the backtracking instance search is to require that there is a single unique instance in the end. Now the only issue is that adding an instance can make code that compiled before stop compiling; but if it still compiles, the semantics doesn't change."
haskell,3afi3t,edwardkmett,5,Sat Jun 20 11:28:02 2015 UTC,"True, but that means that backtracking didn't really win you anything.  You lose the ""open world"" promise that you can define new instances freely, and now you need to add a global consistency check everywhere, and the search is no longer goal directed, so how to execute it becomes a much messier open question. A language could exist that worked like that, but there is a big jump between top down and bottom up undirected searching in complexity.  The job of the compiler then isn't basically just a glorified pattern match using the exact same reasoning as is needed at the value level but now its checking global consistency of a huge set of axioms to ensure that every single combination of these things has exactly one unique answer as you continue to add axioms, and then reverse engineering a pattern match process."
haskell,3afi3t,rpglover64,2,Sat Jun 20 15:11:42 2015 UTC,"IIRC, /u/kamatsu has commented that this is fragile and unpleasant in practice, based on experience with Isabelle/HOL.  EDIT: See reply below."
haskell,3afi3t,kamatsu,3,Sat Jun 20 14:20:13 2015 UTC,"I was referring to a different problem with Isabelle, where mixfix syntax is allowed to be ambiguous, and it will simply try typechecking both parse trees and picking the one that type checks."
haskell,3afi3t,sclv,6,Sat Jun 20 14:26:14 2015 UTC,"For one thing, how can you be sure that your constraint resolution is unique -- i.e. you need to prevent the choice of instances (or ability to find an instance) from being determined the search strategy."
haskell,3afi3t,winterkoninkje,2,Fri Jun 19 21:42:59 2015 UTC,"Well, there's that pesky business about Turing-completeness (1,2). In principle that needn't be a show-stopper —just because something terminates doesn't mean it'll do so before the universe ends, and we can always ctrl-C—, but imagine trying to explain to someone why their instance resolution went into an infinite loop. Is that better or worse than explaining that resolution commits to any matching instance before it verifies the prerequisites?"
haskell,3afi3t,drb226,6,Sun Jun 21 03:49:09 2015 UTC,"I tend to see FlexibleInstances as something to be avoided when possible. Not that it's a particularly dangerous extension, but simply because there's usually a better way to design your code without it."
haskell,3afi3t,SrPeixinho,8,Sat Jun 20 00:31:49 2015 UTC,I think this is brilliant but I can't help but feel once again the complexity of the system is overwhelming.
haskell,3afi3t,tikhonjelvis,11,Fri Jun 19 20:38:30 2015 UTC,"The problem is that understanding this trick, and why it matters, requires going below the typeclass abstraction and understanding how instance resolution works.  In my view, this should ideally be an implementation detail you don't have to worry about. It's a shortcoming of the whole abstraction. But I don't know how to fix or improve it, or even how to design another system that's as expressive as typeclasses without these issues."
haskell,3afi3t,drb226,9,Fri Jun 19 23:44:09 2015 UTC,You have to understand how instance resolution works   It's noteworthy that both the trick and the thing it replaces use non-standardized Haskell language extensions.
haskell,3afi3t,mightybyte,6,Sat Jun 20 00:28:51 2015 UTC,"Yes, I think this is a very good point.  I've thought for awhile now that there are two (at least) very distinct levels of power in Haskell.  There are the things you can do with a knowledge of the language features themselves.  And then there is a whole new set of things you can do if you know how the compiler implements those features.  I never noticed this split in other languages.  Maybe it existed, but I think it's much bigger in Haskell."
haskell,3afi3t,sambocyn,7,Sat Jun 20 00:14:16 2015 UTC,"by the latter, you mean stuff like instance resolution, dictionaries, sharing, etc?  It's be cool to have a longer list of ""stuff to learn about GHC once you've learned Haskell""."
haskell,3afi3t,otterdam,3,Sat Jun 20 00:46:00 2015 UTC,"C++ is a language with lots of complexity; one source of that complexity is that 'how the compiler implements those features' has become language features. SFINAE would be the closest thing to this 'constraint trick', except this behaviour is codified in the standard rather than the Perlish 'it does whatever the main compiler does'."
haskell,3afi3t,pycube,3,Sat Jun 20 08:41:31 2015 UTC,This is not exactly SFINAE. SFINAE in haskell would be if GHC continued instance resolution after it detected that the constraint a ~ () cannot be satisfied.
haskell,3afi3t,SrPeixinho,4,Sat Jun 20 11:39:49 2015 UTC,"Well, you know I'm the occam razor guy who whole heartedly believes we don't need anything more than the good old lambda calculus..."
haskell,3afi3t,tomejaguar,7,Sat Jun 20 01:19:51 2015 UTC,Right with you on that one.  It definitely feels like more of a trick than a principle.
haskell,3afi3t,andrewthad,5,Fri Jun 19 21:00:41 2015 UTC,Thanks so much for writing this up. I had never fully understood why this worked.
haskell,3afi3t,conklech,4,Fri Jun 19 18:55:52 2015 UTC,"Learning and applying this trick was, for me at least, the gateway to understanding how to write advanced instances. It's simple enough to fully digest from concrete examples, and it really drives home the ""backwards"" order of instance resolution.  Is there somewhere on the Wiki or some other central-ish documentation that could contain a link to this post or a summary? This is a great explication, and I thing the underlying technique is a bit more than a trick."
haskell,3afi3t,sambocyn,2,Fri Jun 19 21:48:26 2015 UTC,"what do you mean by ""backwards""?"
haskell,3afi3t,edwardkmett,6,Sat Jun 20 00:47:53 2015 UTC,"Probably mostly that instances read from the ""head"" of the instance (the right hand side of the arrow) back to the ""body"" of the instance (the left hand side of the arrow) by pattern matching without backtracking.  This lets instance search be entirely goal directed."
haskell,3afi3t,conklech,5,Sat Jun 20 01:25:37 2015 UTC,"Normal (value-level) pattern matches/equations ""go"" left to right, in that once the LHS matches, the RHS is evaluated and cannot backtrack to try a different pattern/equation. Instance resolution goes right to left: once the instance head (on the right hand side of the =>) matches, the LHS is added to the constraint and it's too late to backtrack.  Edit: As /u/edwardkmett says more concisely."
haskell,3afi3t,sambocyn,3,Sat Jun 20 02:30:02 2015 UTC,"makes sense, thanks."
haskell,3afi3t,atnnn,3,Sat Jun 20 04:53:20 2015 UTC,I wonder if it's a coincidence that the ~ operator is used for the same reason at the value level:  foo (~True) = ... instance a ~ Bool => Foo a where ...
haskell,3afi3t,edwardkmett,5,Sat Jun 20 00:41:59 2015 UTC,Very much a coincidence. =)
haskell,3afi3t,codygman,4,Sat Jun 20 01:24:19 2015 UTC,Any idea why you keep getting downvoted in this thread? Maybe some unpopular opinion or disputed fact I don't know about.
haskell,3afi3t,edwardkmett,4,Sat Jun 20 03:18:08 2015 UTC,I tend to take these things in stride. It isn't like I'm here for the karma.
haskell,3afi3t,codygman,2,Sat Jun 20 03:34:42 2015 UTC,"Me either, I just like to know when/if i'm missing something :)"
haskell,3afi3t,MrWoohoo,3,Sat Jun 20 04:20:18 2015 UTC,Is this part of haskell98 or does it use a language extension I need to read? Looking up the ~ operator on hoogle leaves me mystified as to what this all means.  EDIT: I decided this was a good place to start reading
haskell,3afi3t,winterkoninkje,3,Sat Jun 20 01:01:41 2015 UTC,"The (~) isn't part of Haskell98, nor Haskell2010. It was added to handle GADTs and type families, though it can be extended to be used elsewhere (e.g., as in the OP)."
haskell,3afi3t,martingalemeasure,2,Sun Jun 21 03:52:58 2015 UTC,"Ah, I was curious about why you did this in lucid but forgot about it before I had a chance to ask. Thanks for clearing it up."
haskell,3afi3t,imz,2,Fri Jun 19 20:12:47 2015 UTC,"Another ""trick"" with instance declaration that attracted my attention and which I don't understand completely is the use of a forall in http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Monoid.html#Alt:  instance forall f a . Alternative f => Monoid (Alt f a) where         mempty = Alt empty         mappend = coerce ((<|>) :: f a -> f a -> f a)   Could anyone perhaps explain the need for it, and why it can't go without it?"
haskell,3afi3t,oerjan,2,Mon Jun 22 06:56:45 2015 UTC,"That forall is because of ScopedTypeVariables, needed to give the type annotation for the (<|>).  Edit: Although experimenting seems to confirm this, I don't understand why this doesn't contradict this manual section."
haskell,3agvoa,lleksah15,6,Sat Jun 20 01:44:36 2015 UTC,"Persistent defines two functions, fromSqlKey and toSqlKey which work on Int64:  instance FromText UserId where       fromText = fmap toSqlKey . fromText   The first fromText attempts to decode an Int64 and might fail. That is why you use fmap toSqlKey over the resulting Maybe Int64.   EDIT: docs https://hackage.haskell.org/package/persistent-2.2/docs/Database-Persist-Sql.html#v:toSqlKey"
haskell,3agvoa,creichert,3,Sat Jun 20 02:16:52 2015 UTC,Thanks /u/creichert.  It works. I had not turned on FlexibleInstances and it was giving me issues even with your code but turning it on fixed it.
haskell,3agvoa,eegreg,1 point,Sat Jun 20 03:45:04 2015 UTC,"Not sure why servant doesn't just use path-pieces, but you can still define your instance with to/FromPathPiece"
haskell,3agvoa,AlpMestan,3,Sat Jun 20 02:37:42 2015 UTC,"We use FromText for more than just captures (say, reading a header value or a query string param)."
haskell,3agvoa,eegreg,-1,Sat Jun 20 06:16:35 2015 UTC,but if you are re-using the same FromText instance than the instance written for a header value or a query string param must be valid for a capture also. It seems like you could either use PathPiece for everything or you want separate typeclasses and it would be used just for captures.
haskell,3agvoa,AlpMestan,2,Sat Jun 20 15:16:50 2015 UTC,"Absolutely, we could, but the name would then be a bit misleading (a header value isn't a piece of the path)."
haskell,3agvoa,AlpMestan,1 point,Sat Jun 20 15:54:42 2015 UTC,"/u/AlpMestan, hope you don't mind asking you a somewhat related question to my post. I am sending Auth tokens in the header and many of the end points require it. Is there a way to define an operator that will do this automatically for each request?    ""users"" :> Header ""Auth-Token"" Text :> Get '[JSON] [User]  -- Naively I tried  |:> = :> Header ""Auth-Token"" Text :>  -- So I can do something like  ""users"" |:>  Get '[JSON] [User]   Of course, I am treating my made-up operator like a macro and it will somehow magically substitute it in place but that does not work. I tried studying your source code and you seem to be defining the operator as         data (path :: k) :> a           deriving (Typeable)  The above syntax is all new to me as I have only seen data SomeType = Constructor { .. }. Any suggestions on how I can avoid duplicating the header capture in my route definitions?  Thanks!"
haskell,3agvoa,eegreg,2,Sat Jun 20 19:17:10 2015 UTC,"To keep the spirit of what you're suggesting, you can do:  type a :|- b = a :> Header ""Auth-Token"" Text :> b -- (i'm not sure your suggested ""|:>"" is a valid type-operator identifier)   However, note that servant will also let you write e.g  type API = Header ""Auth-Token"" Text :> API' type API' = ""users"" :> Get '[JSON] [User]        :<|> ""messages"" :> Get '[JSON] [Message]  -- or all in one type: type API =   Header ""Auth-Token"" Text :> (          ""users"" :> Get '[JSON] [User]     :<|> ""messages"" :> Get '[JSON] [Message]   )   i.e ""factor out"" the header.  Alternatively, you could write a type family to not even have to manually write the Header.  type family AddAuthHeader api where   AddAuthHeader (a :<|> b) = AddAuthHeader a :<|> AddAuthHeader b   AddAuthHeader (a :> b) = AddAuthHeader b   AddAuthHeader a = Header ""Auth-Token"" Text :> a   Something like this would take an API type and turn it into another one, where each endpoint is augmented with an additional argument (the value of the ""Auth-Token"" header, if it's there). This solution is however a bit involved for what you're trying to achieve though, where just factoring out the Header as shown above is definitely the thing I would recommend.  By the way, feel free to use the IRC channel & mailing list if you have further questions."
haskell,3agvoa,AlpMestan,0,Sun Jun 21 00:21:55 2015 UTC,"But FromText is entirely too ambiguous of a name as this shows. Virtually any parser could use a typeclass named FromText. But in different cases (as here) the source text may have slightly different characteristics.  If you want a single generic name something that isn't asking for a global clash such as ServantText would be good. In that case you could have still have a default definition that uses path-pieces.  But using separate classes such as PathPiece, HeaderText, etc seems like a much more sound approach."
haskell,3agvoa,eegreg,1 point,Sat Jun 20 19:12:40 2015 UTC,"I don't see why one would really need separate classes for these. Header values, query string parameters and ""path pieces"" (in the terminology of the package mentionned above) are just ""dummy"" textual representations of some type, hence FromText/ToText. If you use some FromText instance to read a UserId from the URL as a capture, you probably want to use the same when reading a UserId from, say, a header. Wouldn't you? Your suggestion would also require 2 classes for path pieces, 2 classes for headers, etc.  Then, in addition to that, each content type XXX gets its FromXXX/ToXXX classes. It's been working pretty well so far and isn't something people have reported to be confusing or causing name clashes in their projects.  Do not misinterpret this message, your suggestion absolutely makes sense theoretically. In practice, everyone just wants the same fromText for path pieces, header texts and what not, and this saves us a lot of repetition/boilerplate."
haskell,3agvoa,AlpMestan,1 point,Sun Jun 21 00:10:15 2015 UTC,"I can see how for an API Server this won't matter much. But if a url is presented to a user, then the path-piece is part of the UI, not just a ""dummy"". Whereas the Header is not part of the UI. So if I had an Id stored as binary data in the database (this is common among newer databases), if I send it as a header I might just base64 encode it, but if it is a path piece I would display it as hex.  Using a To/FromText representation for everything pushes it all towards the most constrained representation: the path piece. So I still think it would be better just to call it what it is then pretend it is something more general.  At a minimum, why not provide default implementations that use To/FromPathPiece? That would help avoid the confusion leading to this question and promote code re-use.  I remember now that I authored a module with a ToText typeclass. In hindsight it would have been better to come up with a different typeclass name. http://hackage.haskell.org/package/shakespeare-2.0.5/docs/Text-Shakespeare-Text.html#v:toText"
haskell,3ag6i1,desijays,23,Fri Jun 19 21:48:42 2015 UTC,-XScopedTypeVariables
haskell,3ag6i1,andygillku,14,Fri Jun 19 22:31:10 2015 UTC,"DependantHaskell  ...well, I can hope :p"
haskell,3ag6i1,Crandom,12,Fri Jun 19 22:09:33 2015 UTC,-XRankNTypes
haskell,3ag6i1,heisenbug,1 point,Fri Jun 19 21:52:21 2015 UTC,"I think it shouldn't be on by default, though (that's what /u/desijays meant by becoming a part of the core compiler?)."
haskell,3ag6i1,mjmrotek,6,Sat Jun 20 08:12:36 2015 UTC,"This does not answer your question about extensions likely to be included into the ghc compiler, but there was a nice overview of commonly used extensions written by /u/jlimperg 3 months ago, which might be of interest to you."
haskell,3ag6i1,m0rphism,3,Fri Jun 19 23:40:26 2015 UTC,Thanks for the link to the overview.
haskell,3ag6i1,chrisdoner,6,Sat Jun 20 01:38:17 2015 UTC,I enable FlexibleInstances and FlexibleContexts before I even get out of bed.
haskell,3ag6i1,Intolerable,8,Fri Jun 19 23:23:56 2015 UTC,-XOverloadedStrings  -XGeneralizedNewtypeDeriving
haskell,3ag6i1,edwardkmett,5,Sat Jun 20 00:22:34 2015 UTC,FWIW- I rarely use either of these extensions.
haskell,3ag6i1,Tekmo,16,Sat Jun 20 01:32:20 2015 UTC,"For what it's worth, I use those extensions all the time"
haskell,3ag6i1,chrisdoner,5,Sat Jun 20 03:30:50 2015 UTC,"Yeah, I use both all the time. OverloadedStrings appears in >25% of modules in my projects.  chris@retina:~$ find Emacs/packages/ Packages/ Apps/ -name '*.hs' | xargs grep OverloadedStrings | wc -l 121 chris@retina:~$ find Emacs/packages/ Packages/ Apps/ -name '*.hs' | wc -l 457   GeneralizedNewtypeDeriving appears less because I tend to put all my types in one module and use it once."
haskell,3ag6i1,mjmrotek,5,Sat Jun 20 13:52:13 2015 UTC,-XDeriveDataTypeable (or the automagic variant?)  -XDeriveGeneric   -XDeriveFunctor  -XDerive*  -XStandaloneDeriving  -XNoMonomorphismRestriction ;)  I wish:  -XScrewExportListsIWantToImportThatPackagesInnardsJustToDeriveSomeInstancesGoddammit
haskell,3ag6i1,mallai,3,Sat Jun 20 08:18:07 2015 UTC,Afaik   XNoMonomorphismRestriction   Is now on by default since 7.8.1. But maybe it's only in GHCi...
haskell,3ag6i1,Tekmo,2,Sat Jun 20 13:03:03 2015 UTC,"Yeah, it's on by default for just ghci"
haskell,3ag6i1,quchen,4,Sat Jun 20 13:47:10 2015 UTC,"Some that are just very convenient, and have a good change of making it into the next standard:   MultiWayIf LambdaCase BangPatterns BinaryLiterals NumDecimals"
haskell,3ag6i1,mallai,3,Sat Jun 20 14:20:18 2015 UTC,On related note. You can enable such extensions in cabal file. But I remember some discussion that people preferred to see the list in each file to help with reading the code.
haskell,3ag6i1,chrisdoner,3,Sat Jun 20 13:05:57 2015 UTC,"Also, having per-module extensions lists means you can load two projects into the same GHCi session without them stepping on eachother's toes."
haskell,3ag6i1,beerdude26,2,Sat Jun 20 13:53:38 2015 UTC,This is a great and succinct blog series.
haskell,3ag6i1,nolrai,1 point,Sat Jun 20 17:26:57 2015 UTC,"I don't think your two questions are that related, are they?"
haskell,3agupg,peterood,2,Sat Jun 20 01:34:31 2015 UTC,"I live in berkeley. I've done some programming in haskell but am still fairly beginner, though not a beginner programmer. I would like to meet up with other people that are into haskell or even just programming in general."
haskell,3afur0,Darwin226,3,Fri Jun 19 20:14:19 2015 UTC,"(so that head . sort is fast)   Maybe you can take inspiration from the leftist heap implementation with the MinHeap policy (or just use that) (heap package, not the heaps one)?"
haskell,3afur0,alt_account10,3,Fri Jun 19 21:49:24 2015 UTC,I was hoping someone would actually find it an interesting challenge to try and optimize my code so that I could learn from it. I'm not looking for an actual fast implementation.
haskell,3afur0,nowne,2,Fri Jun 19 22:03:01 2015 UTC,Check out http://www.reddit.com/r/haskell/comments/2tb8k2/modular_code_and_lazy_evaluation_in_haskell/cnya7gw
haskell,3afur0,precalc,4,Sat Jun 20 02:37:33 2015 UTC,"Use unboxed vectors and vector-algorithms instead. If you want fast heaps, look at the heaps package."
haskell,3afur0,edwardkmett,2,Fri Jun 19 20:59:53 2015 UTC,"Note: While heaps is optimal, it is not fast. ;)"
haskell,3afur0,cartazio,1 point,Sat Jun 20 01:43:08 2015 UTC,"as an alternative, https://en.wikipedia.org/wiki/Pairing_heap pairing heaps are super simple to write in haskell. I have an implementation of that lying around somewhere"
haskell,3afur0,autowikibot,1 point,Sun Jun 21 02:10:37 2015 UTC,"Pairing heap:       A pairing heap is a type of heap data structure with relatively simple implementation and excellent practical amortized performance. Pairing heaps are heap-ordered multiway tree structures, and can be considered simplified Fibonacci heaps. They are considered a ""robust choice"" for implementing such algorithms as Prim's MST algorithm,  :231 and support the following operations (assuming a min-heap):   find-min: simply return the top element of the heap. merge: compare the two root elements, the smaller remains the root of the result, the larger element and its subtree is appended as a child of this root. insert: create a new heap for the inserted element and merge into the original heap. decrease-key (optional): remove the subtree rooted at the key to be decreased, replace the key with a smaller key, then merge the result back into the heap. delete-min: remove the root and merge its subtrees. Various strategies are employed.   The analysis of pairing heaps' time complexity was initially inspired by that of splay trees.  The amortized time per delete-min is O(log n).  The operations find-min, merge, and insert run in constant time, O(1).   Determining the precise asymptotic running time of pairing heaps when a decrease-key operation is needed has turned out to be difficult. Initially, the time complexity of this operation was conjectured on empirical grounds to be O(1),  but Fredman proved that the amortized time per decrease-key is at least  for some sequences of operations.  Pettie then derived an upper bound of  amortized time for decrease-key, which is .  No tight  bound is known.   Although this is worse than other priority queue algorithms such as Fibonacci heaps, which perform decrease-key in  amortized time, the performance in practice is excellent. Stasko and Vitter  and Moret and Shapiro  conducted experiments on pairing heaps and other heap data structures. They concluded that the pairing heap is as fast as, and often faster than, other efficient data structures like the binary heaps.     Relevant: List of data structures | Left-child right-sibling binary tree | Double-ended priority queue | Heap (data structure)   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,3afur0,edwardkmett,1 point,Sun Jun 21 02:11:17 2015 UTC,"The ""Work Smarter"" section of https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/part-5 gives a pretty concise pairing heap implementation that works well in practice."
haskell,3ae777,HoneyedOasis,2,Fri Jun 19 11:56:34 2015 UTC,Would be nice if there was an online course.
haskell,3ae777,mishach,4,Fri Jun 19 22:12:54 2015 UTC,All the course materials are on line here : https://github.com/NICTA/course  What you don't get is the instruction that would when attending the course in-person.
haskell,3acvr8,tejon,11,Fri Jun 19 02:09:07 2015 UTC,"Note that this is about Visual Studio Code, which is a different thing from Visual Studio. VSCode is an IDE based on the Atom Editor, and Atom already has a package for interop with ghc-mod.  I'm not saying that VSCode shouldn't have Haskell support. Just making sure people know this isn't about the main Visual Studio IDE."
haskell,3acvr8,radix,6,Fri Jun 19 15:38:08 2015 UTC,"Assuming this gets many votes, who's gonna implement it?"
haskell,3acvr8,hagda,2,Fri Jun 19 11:18:01 2015 UTC,"By someone who has a high tolerance for pain and finds it more painful to not be able to code in MSVS MSVSC. Although, anecdotal, Windows users seem to have said high tolerance.  edit: I stand corrected."
haskell,3acvr8,abaquis,3,Fri Jun 19 13:42:16 2015 UTC,In the past that was Simon Marlow (and Krasimir Angelov) they wrote the original Visual Haskell bindings way back in the day.
haskell,3acvr8,edwardkmett,2,Fri Jun 19 15:22:32 2015 UTC,The pain is in the pudding.
haskell,3acvr8,abaquis,2,Fri Jun 19 15:37:01 2015 UTC,"Although, anecdotal, Windows users seem to have said high tolerance.   what do you mean by that?"
haskell,3acvr8,nikofeyn,2,Fri Jun 19 23:00:16 2015 UTC,Windows users have a high tolerance for pain--in my anecdotal experience.
haskell,3acvr8,abaquis,1 point,Tue Jun 23 18:26:47 2015 UTC,"Do you mean users or developers? In my experience Windows users have a very low tolerance - if your software doesn't have a one click installer that sets you up completely, then you're dead before you even start."
haskell,3acvr8,asampson,1 point,Wed Jun 24 18:41:27 2015 UTC,Visual Studio Code != Visual Studio. It's a lightweight editor more similar to atom.
haskell,3acvr8,Crandom,7,Fri Jun 19 20:12:17 2015 UTC,"I think the open source community would be wise to forego closed-source corporate crapware. Also, other than cabal problems (though stack seems promising), I find haskell development on Linux using vim or emacs to be quite nice. It's not perfect, but if we want another editor then open source is the only way to go."
haskell,3acvr8,elasticfish,3,Fri Jun 19 15:01:11 2015 UTC,"From what I see (I haven't tried it) it looks like Microsoft have taken their key feature of Visual Studio - debugging, then put it in an new IDE compromised of mostly free software, stripped user freedom from it and put it online.  Usually people spend their time begging outside nonfree cathedrals for things like GNU/Linux support since they've already bought in to lock-in, but this cathedral was only built two months ago.  I don't get how spending time adding Haskell to this would be a good idea for the community or the poor IDE users."
haskell,3acvr8,Jookia,2,Sat Jun 20 00:13:47 2015 UTC,We couldn't submit your vote at this time.   meh ..
haskell,3acvr8,Drezil,1 point,Fri Jun 19 07:16:06 2015 UTC,me too.
haskell,3acvr8,mosha48,1 point,Fri Jun 19 08:08:10 2015 UTC,That would be great!
haskell,3acvr8,kuznero,1 point,Fri Jun 19 11:31:31 2015 UTC,LOL. This is like begging for a bread in front of the mansion.  No one is coming out :))  The only people who would spend their time and effort to create a haskell IDE are the ones who code in haskell.
haskell,3ad685,gilded_honour,15,Fri Jun 19 03:46:01 2015 UTC,"Disclaimer: I'm a committer to the Frege project. I use it quite extensively since I mostly work on the JVM anyway and this is only option to do pure functional programming on the JVM. Frege is fundamentally different from earlier approaches to bring a) Haskell or b) ""functional style"" in other languages to the Java platform. Therefore, the experience of ""it didn't work with x"" should not lead to premature conclusions about Frege. The best approach is to give it a try and if you should hit any limits, post questions here, at stackoverflow (preferred), or start a conversation on the mailing list.  Frege is not a competitor to GHC and native compilation but it is the best option to have the benefits of Haskell when programming on the JVM."
haskell,3ad685,DierkKoenig,8,Fri Jun 19 11:17:19 2015 UTC,this is only option to do pure functional programming on the JVM   I'm hopeful it will get some excellent company soon.
haskell,3ad685,eriksensei,4,Fri Jun 19 13:15:38 2015 UTC,Now that's really intriguing. Especially as a replacement for scala/jvm + scala/js...
haskell,3ad685,Oremorj,3,Fri Jun 19 17:35:39 2015 UTC,My thoughts exactly! Not there yet though; SlamData have been adding some issues today to shed some light on what needs to be done.
haskell,3ad685,eriksensei,2,Fri Jun 19 18:14:01 2015 UTC,fundamentally different from earlier approaches to bring a) Haskell    fundamentally? It's almost the same as Haskell on JVM.
haskell,3ad685,cunningjames,10,Fri Jun 19 12:00:44 2015 UTC,"I took that to mean fundamentally different from earlier approaches, not fundamentally different from Haskell."
haskell,3ad685,voxfrege,12,Fri Jun 19 12:11:25 2015 UTC,"Yes, this is how it was meant.  Specifically, simplifiying a bit, earlier approaches targeted 100% GHC compatibility, essentially writing a GHC backend plus a runtime system (this is where things get hairy).    Whereas Frege was created to be first and foremost a practical JVM language. This means, similarity with Haskell is valued highly, but sometimes it is more reasonable to deviate.  For example, in Frege, Bool is an abstract data type, and there are two literals true and false (just like in Java). Why? Because we want to interface with other JVM languages, and that means that we ought to use the JVM primitive types. But JVM types are all abstract, viewed from Frege, whereas Algebraic Data Types are not. So, would we give up consistency and make an exception for Bool? Not at all."
haskell,3ad685,voxfrege,5,Fri Jun 19 12:29:07 2015 UTC,"It must be pointed out that what you can expect is on the level of Haskell 2010 (not GHC), plus a different FFI specialised and exclusivly for JVM needs, plus a simple record system that gets the namespacing issues solved."
haskell,3ad685,Mob_Of_One,14,Fri Jun 19 12:17:25 2015 UTC,GHC and the GHC runtime is one of the perks of using Haskell (green threads! unlifted types that work properly! binaries!) so I haven't bothered yet but it looks interesting.
haskell,3ad685,eviltofu,4,Fri Jun 19 04:14:07 2015 UTC,Can GHC emit java byte codes?
haskell,3ad685,terrorjack,4,Fri Jun 19 08:54:58 2015 UTC,"Nope, and not yet on schedule."
haskell,3ad685,voxfrege,8,Fri Jun 19 10:22:29 2015 UTC,"Small nitpick: It's 4 years around, not 7.  It is definitively possible to use frege in android, people have tried this. But it is of course far from practically usable. (I wish people interested in this stuff would contribute more.)"
haskell,3ad685,codygman,3,Fri Jun 19 07:23:58 2015 UTC,I'm interested in using Frege from android but I don't know a lot about java or android. How could I help? Where would I start?
haskell,3ad685,voxfrege,2,Fri Jun 19 11:06:03 2015 UTC,"Honestly, I know nothing about Android either, except that it somehow runs on my phone. Hence, I can't give any serious advice in this respect.  I assume technically it is about exposing  the existing Android Java classes and methods as Frege types and functions - this is similar to the Haskell FFI, but tailored for JVM needs."
haskell,3ad685,vagif,5,Fri Jun 19 12:01:29 2015 UTC,There's java-bridge with quite extensive documentation.  It sorta FFI from haskell to java.
haskell,3ad685,againstmethod,3,Fri Jun 19 14:16:54 2015 UTC,"I've tried Frege, and I was fairly impressed with it given the niche it currently occupies. Quite usable.  EDIT: Never tried using it on Android."
haskell,3ad685,Die-Nacht,6,Fri Jun 19 16:17:48 2015 UTC,"I fear that it will have the same issues as Scala/clojure (no tail recursion, weird thread system, bad performance due to java bytecode being meant for...well... Java)."
haskell,3ad685,voxfrege,9,Fri Jun 19 05:54:52 2015 UTC,"The JVM language creators sure hope for the tailcall bytecode, maybe in Java 12 :)  However, the following does work in Frege:  even :: Int -> Bool even 0 = true even 1 = false even n = odd (pred n)  odd :: Int -> Bool odd  n = even (pred n)  main  = println (even 123456789)   It can work in 2 ways: first by inlining odd, which results in a loop that counts down twice each round. But more interestingly, it does work even when we forbid inlining.  Regarding performance, it is true that approximating functions by function objects is a bit expensive. But the Java8 lambda implementation, which is going to replace the traditional way of implementing this is said to be faster - 5 to 60 times faster according to Brian Goetz."
haskell,3ad685,ReshenKusaga,3,Fri Jun 19 07:34:28 2015 UTC,"As for the tail recursion bit, doesn't Scala have compile-time tail-recursion optimization?"
haskell,3ad685,kamatsu,7,Fri Jun 19 06:50:08 2015 UTC,"No. Only for self-recursion, not tail-call optimisation in general."
haskell,3ad685,ReshenKusaga,1 point,Fri Jun 19 06:54:09 2015 UTC,"Ahh, okay. That makes sense, thanks!"
haskell,3ad685,semanticistZombie,-1,Fri Jun 19 07:20:46 2015 UTC,"Not that I have any experience with that, but I feel like any JVM language would have to make talking with Java very easy, and since it's an imperative language maybe using a less purely-functional and more imperative language would be a better option. Have you seen this http://www.ocamljava.org/ ?"
haskell,3ad685,voxfrege,9,Fri Jun 19 13:01:06 2015 UTC,"Why, in Haskell there is no problem with ""imperative"". As SPJ said, Haskell is one of the  finest imperative languages. And this was only half-joking.  Apart from that, we have plenty imperative, non-pure languages on the JVM already. Of course, the well known and highly valued ML implementations are among them."
haskell,3ad41d,ignorantone,5,Fri Jun 19 03:23:42 2015 UTC,"Same name, different author!"
haskell,3ad41d,augustss,3,Fri Jun 19 08:28:28 2015 UTC,Note that I am not the author. I thought it was interesting and never saw it linked here.
haskell,3ad41d,gasche,6,Fri Jun 19 03:24:07 2015 UTC,"Indeed, this is very interesting, thanks for posting! There is a very nice 2015 paper on example-driven code synthesis that would be a relevant point of comparison (and I have been working on related ideas myself), I'll contact the author about this."
haskell,3absc6,DrDeluX,51,Thu Jun 18 20:39:04 2015 UTC,Side effects: I became more aware of them and have since tried writing code without them where possible while abstracting out the 'effectful' parts.
haskell,3absc6,vikasmenon,7,Thu Jun 18 21:15:24 2015 UTC,"Yup. More generally, I've become more appreciative of being explicit in my code. Does a function need a value? Pass it in as an argument. I don't care if that value gets inherited by some complicated mechanism in a field in the object containing the method. Pass it in as an argument if the method needs it.  Being explicit makes refactoring and debugging so much easier. When I'm refactoring I don't want to have a mental map in my head of which objects are inherited how and in how many generations just to be able to move a method. Simple refactors like those should be (mostly) a matter of symbolic manipulation. Copy the relevant bits of code and paste them somewhere else, and boom, you're done. You could even do it following simple rules in the vein of ""\x -> f (g x) = \x -> (f . g) x = f . g"". I don't need to think when doing those transformations, which is a good thing, because as soon as I think I'm likely to make a mistake.  Avoiding side effects is only a part of that."
haskell,3absc6,kqr,82,Fri Jun 19 08:59:59 2015 UTC,It made me a worse programmer because I'm less motivated when working on anything else.
haskell,3absc6,Denommus,23,Thu Jun 18 22:50:34 2015 UTC,"Yes, this has happened to me, too. Haskell ruined my appreciation for Java. Now it's hard to get excited about writing Java."
haskell,3absc6,stolarj,5,Thu Jun 18 23:07:57 2015 UTC,"I'm learning Java now because I have a new job that requires it. I'm finding Steams and Functions somewhat familiar and more fun than ""for"" loops. I wish I had those when coding C++ in my previous job."
haskell,3absc6,tdox,6,Fri Jun 19 01:25:34 2015 UTC,When I realized >>= is called flatMap my interest rose a bit
haskell,3absc6,gatlin,2,Fri Jun 19 04:40:03 2015 UTC,"Or less generally, concatMap. I used flatMap for the first time today with Function.identity() to make concat. (Java Stream concat is closer to ++ or :.)"
haskell,3absc6,tdox,1 point,Fri Jun 19 05:48:02 2015 UTC,"I agree with your comments about STL. Concerning Java-like streams in C++, your comment prompted me to look for them, and I just found this: http://jscheiny.github.io/Streams/. Perhaps there are others as well."
haskell,3absc6,tdox,7,Fri Jun 19 03:00:56 2015 UTC,"Ah, ""The Functional Curse""."
haskell,3absc6,Crandom,1 point,Fri Jun 19 05:29:09 2015 UTC,I'm not alone!
haskell,3absc6,gfixler,5,Fri Jun 19 10:55:53 2015 UTC,I frequently find myself reimplementing even simple Haskell constructs in other languages. Why console.log when you can slot in a traceShowId.
haskell,3absc6,mgoszcz2,2,Sun Jun 21 20:47:22 2015 UTC,"I gave myself a little library of flip, comp, ident (id is taken), fst and snd, and probably 100 others for the Python I have to do for work."
haskell,3absc6,gfixler,30,Thu Jun 18 23:36:45 2015 UTC,"Haskell made me a better C programmer  When writing C, I sometimes encode my sum types as virtual table structs, which give me type-safety. (Haskell trick!)  When I need a ""let"" constructor (for a local variable) in the C preprocessor, I encode it via a redex (#define a new macro and call it to assign the variable). Also a trick I learned when I learned how ""let"" can be implemented (if you don't have let generalization, at lesat).  Haskell made me appreciate types more  I learned that declaring lots of precise types for extra clarity and safety is a great technique.  Most of the programming world re-uses Bools, Ints, and other types for everything, despite not quite matching, as if an extra line or two for a type-decl is expensive. Haskell taught me that with precise-enough types, I can actually reasonably cover the entire dynamic space of all possible inputs I could have.  Haskell was a gateway drug  Haskell was also a gateway drug to Agda and Idris. Having learned Agda and Idris, and some of the type theory behind them -- I can now pick up new languages much faster. Even ones that have a lot of interesting type theory behind them. I can read advanced academic papers, despite having no academic background.  Laziness  Haskell taught me about the virtues of laziness, and their cons. Not sure if that makes me a better programmer :)  Build stuff  Haskell lets me build stuff relatively quickly, while also having some minimal trust in what I just built."
haskell,3absc6,Peaker,6,Sun Jun 21 20:48:24 2015 UTC,"Haskell made me a better C programmer  When writing C, I sometimes encode my sum types as virtual table structs, which give me type-safety. (Haskell trick!)   As a C programmer by day and Haskeller by night, I'm very interested in seeing this."
haskell,3absc6,serendependy,9,Thu Jun 18 21:56:27 2015 UTC,"Imagine a parse function:  typedef struct {      enum Tag;      union ... // yikes! } Cmd; Cmd parse_cmd(const Buf *);   And then you need an enum, and you need to be careful when you switch on the tag, etc.  Vs:  typedef struct {    void (*strangle)(void *arg, Enemy *);    void (*hug)(void *arg, Friend *); } cmd_handlers; void parse_cmd(const Buf *, const cmd_handlers *, void *arg);   Less tedious, more type-safe, yay!  As for the preprocessor trick, imagine you want to use __COUNTER__, the new preprocessor token that generates a unique (in this compilation unit) number by incrementing at every use.  You do something like:  #define MAC(x)    \   do { \     int _var_##__COUNTER__; \     use(&_var_##__COUNTER__); \   }   Oops! Each use of __COUNTER__ will generate a new number. Use a redex to emulate ""let"":  #define MAC(x)    \   MAC_(x, __COUNTER__) #define MAC_(x, counter) \   do { \     int _var_##counter; \     use(&_var_##counter); \   }   And now it works!"
haskell,3absc6,Peaker,1 point,Thu Jun 18 23:53:58 2015 UTC,"How does the struct trick make everything more typesafe? Because now you have to know whether you are passing a Friend or an Enemy?  #include <stdio.h>  typedef const char Enemy; typedef int Friend;  void strangle(Enemy *e) {     printf(""Strangle! %c\n"", *e); }  void hug(Friend *f) {     printf(""Hug! %i\n"", *f); }  typedef struct {     void (*strangle)(Enemy *);     void (*hug)(Friend *); } cmd_handlers;  void parse_cmd(const char *b, const cmd_handlers *c) {     switch (*b) {         case 's':             c->strangle(b);             break;         case 'h':             c->hug((int*)b);             break;         default:             printf(""???\n"");             break;     } }  int main(int argc, char* argv[]) {     cmd_handlers c = {strangle, hug};     if (argc > 1) {         parse_cmd(argv[1], &c);     } else {         parse_cmd(""h"", &c);     } }"
haskell,3absc6,hiptobecubic,5,Fri Jun 19 00:00:14 2015 UTC,Because the typical alternative of a union with an enum tag lets you easily access the wrong union field by accident.
haskell,3absc6,Peaker,2,Fri Jun 19 06:02:05 2015 UTC,"I definitely understand how tagged unions can go wrong, what I don't see is how this version can't. I think I just didn't explain myself very well.  Is it more typesafe because you can't call hug unless you have a value of type Friend now? Rather than having an opaque Cmd that could take either type but is expecting to only get the correct type? If so, haven't we just changed the entire structure of the program? You can't pass around the Cmd anymore, you call it right from within the parser.  I haven't written any non-trivial C in several years now. I'm pretty rusty. :)"
haskell,3absc6,hiptobecubic,1 point,Fri Jun 19 10:32:37 2015 UTC,"It forces inversion of control, yes. That's a downside.  You can regain control by building up an ugly union if you want, inside your callbacks.  But at the implementor's side, indeed it is safer because they can only call if they have a Friend now.  At the user's side, it is safer because they can only use a Friend in the correct case, but not the other case.  So it is safer in both sides of the API.  Note that if the parsing is light-weight, you can just re-call the parser with different handlers at any given point you'd otherwise switch on a tag."
haskell,3absc6,Peaker,1 point,Fri Jun 19 22:36:02 2015 UTC,I don't understand example about MAC. For example where x goes and why do you need to create local variable _var_xxx when you throw it away later.?
haskell,3absc6,raluralu,1 point,Fri Jun 19 22:53:57 2015 UTC,"Oh, MAC isn't a real/useful macro, but it could be a part of one.  Imagine it does something useful with x and _var_##counter after the call to use :-)"
haskell,3absc6,Peaker,10,Fri Jun 19 11:16:05 2015 UTC,Laziness   To me it seems that a language can't be truly declarative without laziness. It seems declarative means separating execution from semantics. Strictness means that the order of execution is encoded in the expressions - so not separate and therefore not declarative.  edit: It seems like this is a point that is made too seldom. Laziness is often criticised and I don't think I've heard this being mentioned as a counter point.
haskell,3absc6,worldsayshi,15,Fri Jun 19 12:16:08 2015 UTC,"Or, you can opt for totality instead. Then eager/lazy is just a performance choice that can be done later.  Also, I am not sure that for most programming, more declarative is always better.  It's a trade-off.  Making my denotational semantics easier to understand is great, but losing the ability to predict evaluation order easily sucks.  I think if Haskell had (much) better runtime introspection capabilities, it wouldn't be so bad. But the combination of unpredictability of laziness with the opacity of Haskell at runtime is a disaster in many scenarios."
haskell,3absc6,Peaker,4,Thu Jun 18 22:56:47 2015 UTC,"This depends on your idea of ""most programming."" What I've seen in the industry is a lot of internal web apps where making the program ""do the correct thing"" is of primary importance, and the right thing changes. ""Do the thing quickly and without eating all the memory"" is a secondary concern, because hardware is cheaper than developers. I agree about runtime introspection, but don't have any ideas."
haskell,3absc6,pogden,2,Thu Jun 18 23:13:00 2015 UTC,"This is exactly my line of work. Resource consumption is not a big deal at all. As long as it takes under 200ms to serve the page, no one cares how it's being done. I have only once been bit by a laziness issue, but it was pretty easy to resolve."
haskell,3absc6,andrewthad,2,Fri Jun 19 01:29:16 2015 UTC,"But the combination of unpredictability of laziness with the opacity of Haskell at runtime is a disaster in many scenarios.   It is a minor inconvenience in most situations. Most situations I would describe as disasters are rather the kind of things where data is silently corrupted, servers are overwhelmed by requests or data is not saved/deleted. Any performance considerations like the ones in Haskell which tend to be easy to test for do not warrant such extreme terms."
haskell,3absc6,Taladar,2,Fri Jun 19 12:48:49 2015 UTC,Experts sometimes have to spend weeks chasing a space leak caused by accidental thunks.  That is a disaster IMO.
haskell,3absc6,Peaker,1 point,Fri Jun 19 07:37:28 2015 UTC,Maybe those experts should familiarise themselves with the GHC RTS profiling parameters which allow pinpointing the locations of space leaks in a much shorter time.
haskell,3absc6,Taladar,1 point,Fri Jun 19 10:31:28 2015 UTC,Take a look at: http://neilmitchell.blogspot.co.il/2013/02/chasing-space-leak-in-shake.html
haskell,3absc6,Peaker,1 point,Fri Jun 19 11:16:33 2015 UTC,"As I said, familiarity with the tools to pinpoint space leaks to a particular type of data helps immensely in solving these problems quickly. Another thing that helps is to use strictness annotations in every long-lived piece of data like that list of ThreadIds from the start.  The post also doesn't support your conclusion that it takes weeks of work to find the leaks just because it says it was found ""over the course of a few weeks""."
haskell,3absc6,Taladar,1 point,Fri Jun 19 12:14:49 2015 UTC,"I recall he said he chased it for weeks.  Anyway, I've been having my own hell chasing time leaks between my threads due to evaluation happening in the wrong threads, hidden laziness, etc.  Consider for example, using Data.Map.Strict, and then accidentally using fmap on it. It's now lazy on the values, oops!  Consider having a strictness annotation on a type like a list (or perhaps worse, a polymorphic type instantiated to be a list). Of course it's obviously a mistake when you notice it, but these kinds of bugs can hide everywhere, and the tooling doesn't really pinpoint it. It can say ""Lists are leaking somewhere"". That's not good."
haskell,3absc6,Peaker,2,Fri Jun 19 13:36:56 2015 UTC,"I think rather a language is preferably pure by default to be [ideally] declarative. Haskell is pure by default and lazy, Idris and PureScript are pure by default and strict. All three have declarative constructs like monads.  See also how do we all feel about laziness."
haskell,3absc6,chrisdoner,1 point,Fri Jun 19 17:35:57 2015 UTC,"Actually, the key ingredient is separating side effects from evaluation order (which is what Haskell does).  Once you do that then the only difference between lazy and strict is efficiency and the occasional bottom value."
haskell,3absc6,Tekmo,1 point,Fri Jun 19 08:20:38 2015 UTC,separating side effects from evaluation order   How do you do that without laziness?
haskell,3absc6,worldsayshi,5,Fri Jun 19 14:43:14 2015 UTC,"First off, the way Haskell already does it (encoding IO as a stateful function wrapped in a newtype) works even in a strict language.  Laziness has nothing to do with how Haskell separates side effects from evaluation order.  Laziness was the reason that people wanted to side effects from evaluation order, but the actual implementation of the separation does not rely on laziness.  In fact, Standard Chartered has a strict dialect of Haskell which achieves the exact same separation just fine.  However, the way Haskell achieves the separation is not the only approach.  Another approach is to encode IO as a syntax tree representing the effects that you want to run.  Evaluating the syntax tree does not trigger the effects.  See these two posts, which explain the syntax tree trick:   http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html (The last section, on IO)"
haskell,3absc6,Tekmo,32,Fri Jun 19 17:27:40 2015 UTC,"It is without irony when I say that coding in Haskell allows me to be a whole lot dumber, letting the compiler guide me. I'm trying to recreate that experience to the best of my abilities in other languages. In particular,   Make undesirable state unrepresentable in the system, or at least so hard to create that tests are bound to catch it even when that's not what they're actually testing Limit the range of implicit state as much as you can (given OOP languages that's pretty futile to be honest though)   And on the theoretical side, I care much more about semantics and understanding the program now, whereas before the superficial impression of ""works alright"" was enough."
haskell,3absc6,quchen,15,Fri Jun 19 19:46:36 2015 UTC,"Haskell allows me to be a whole lot dumber, letting the compiler guide me   Agreed. But this means I'm only better at making maintainable systems in a language of equal or more powerful type capabilities and purity to Haskell. Idris is a step up or a step across, OCaml or SML is a step down, C# and Java is a further step down, Lisp/JavaScript/Python/Ruby/etc. is jumping off a cliff. Haskell gave me the habit of ignoring a class of unrepresentable errors which is not an advantage when using languages lower on the type-em pole. It makes me a bad programmer in other languages, and I don't care that it does."
haskell,3absc6,chrisdoner,17,Thu Jun 18 21:36:04 2015 UTC,"Funnily enough I feel the exact opposite. I've been writing a lot of Javascript lately and Haskell has my poor-code Spidey senses turned way up. I can't tolerate ""incomplete matches"" and find ways to avoid boolean blindness as a rule. I am constantly papering over Javascript's wildly duplicitous APIs with simple, consistent ones inspired by ADTs. I also write APIs which respect abstraction in a way that's nearly impossible to conceive of in normal JS usage.  It's a huge step up. I still write Javascript, but I write things that a multitudes simpler, dumber, easier to understand."
haskell,3absc6,tel,4,Thu Jun 18 23:02:44 2015 UTC,"I'm a combination of you two. I'm so used to Haskell dealing with the difficult stuff, and my poor-code Spidey sense are in other languages turned up as a result. I frequently go, ""holy shit that's a bug ——— crud I have to think about this ——— oh man there's a huge bug hiding there ——— seriously? I need to worry about this!?"" and I'm like a neurotic ant walking all over the code worrying about potential bugs.. but I'm not sure I actually write better code because of it."
haskell,3absc6,kqr,4,Fri Jun 19 00:44:55 2015 UTC,Yeah... I had to learn to go with the flow for code that's out of my control. Which is a bit tragic and makes me jump on documtation of poor interfaces.
haskell,3absc6,tel,3,Fri Jun 19 09:13:41 2015 UTC,"It makes me a bad programmer in other languages, and I don't care that it does.   Would you still feel this way if you didn't get to write Haskell at work? I have to write Erlang and I don't even know what the hell is going on, ever, even in the applications that I get to build from scratch. I wish I could forget that static typing exists at all, so I could focus on actually programming instead of fighting off nagging thoughts that my efforts are just going to be thrown away in three months by some unfortunate successor after an unsuccessful refactor attempt. Knowing Haskell is a curse."
haskell,3absc6,MitchellSalad,15,Fri Jun 19 14:22:57 2015 UTC,GHC is like a teacher holding a cane.
haskell,3absc6,BethAr,3,Fri Jun 19 00:23:47 2015 UTC,I love this description
haskell,3absc6,worldbefree83,22,Fri Jun 19 02:59:50 2015 UTC,"Haskell taught me that programming wasn't worth the effort. Even with a language which does the Right Thing more than half the time, I came to realize that software is limited not by specification or correctness, but by inherent complexity, time costs, and enormous social pressures.  I don't program very much now, but I do tutor from time to time. Whenever I work with someone in Java or C++, I cry for them. They are taught bullshit methods and the world is in denial about it. You can produce someone who can write code, but their understanding of computer science is typically vocational.  (I wonder how much this kind of phenomenon appears in fields like law or medicine).   On the rare occasions I do do some programming now, I still reach for Python first. There are a handful of things about Haskell that I never got over how tedious they are. Records and modules are verbose. Typeclasses seemed to make my life more difficult instead of easier, trying to figure out which types satisfy the constraints. Documentation was always awful. (Does Hackage still not properly SEO its content?)   I would not unlearn Haskell if I had the choice. There was so much interesting stuff to see. But after the dust settled and I finally understood the Cont monad, I realized that what I liked was not Haskell itself, but the introduction of mathematical principles to programming."
haskell,3absc6,tactics,7,Fri Jun 19 12:26:25 2015 UTC,"(I wonder how much this kind of phenomenon appears in fields like law or medicine).   At least in law, licensing exams seem to do an okay job of ensuring some familiarity with fundamental concepts. And law schools (should) inculcate a disciplined approach to rule application.  Some problems I've seen in law are very similar to the problems in programming that Haskell addresses. Lawyers sometimes misunderstand, or don't think about, how the parts of a rule/argument/case/fact pattern fit together; they're sometimes insufficiently disciplined in ""refactoring"" and ""type-checking"" an argument or analysis. We don't have a compiler to tell use we've put things together upside-down; we have to rely on ourselves and each other (and the judge--but of course by then it's too late!).  Haskell has been surprisingly helpful to my development as a lawyer, for many of the same fundamental reasons people have identified for making them better programmers."
haskell,3absc6,conklech,5,Fri Jun 19 01:46:35 2015 UTC,"(I wonder how much this kind of phenomenon appears in fields like law or medicine).    Probably quite a lot, sadly."
haskell,3absc6,tomejaguar,2,Fri Jun 19 17:50:11 2015 UTC,"Law and medicine are both vocational degrees (despite the social luster that attaches to them), so I'd assume it happens a good deal.  Guess what: engineering is also a vocational degree."
haskell,3absc6,gclichtenberg,2,Fri Jun 19 08:28:32 2015 UTC,I guess I did attach a bit of a negative connotation to the word. Shame on me.
haskell,3absc6,tactics,9,Fri Jun 19 17:35:36 2015 UTC,"Haskell taught me ""the stricter the better""; better to deal with annoying errors getting used to a new style then rarely have trouble debugging or at runtime than to have everything destroyed after a seemingly small change every couple of weeks.   But to be honest, I think the best thing is just that now I'm able to think more ""out of the box"", find my own solutions, etc, better than before. You never know when little details will end up saving your life in something completely different. Probably goes for exposure to anything different in general though."
haskell,3absc6,Alyte,21,Fri Jun 19 18:20:42 2015 UTC,"If I had to express it in one sentence: ""Because Haskell forces me to think harder and get a clearer picture about what I'm implementing before writing down any SLOC"""
haskell,3absc6,hagda,27,Thu Jun 18 22:57:05 2015 UTC,"Haskell is a Think Hard, Write Once, Debug Nowhere language."
haskell,3absc6,mhd-hbd,7,Thu Jun 18 20:57:30 2015 UTC,"I wonder if Feynman would have liked Haskell (""Write down the problem, think very hard, write down the answer"") =)"
haskell,3absc6,hagda,3,Thu Jun 18 22:11:33 2015 UTC,I think he would have. It is very elegant.
haskell,3absc6,mhd-hbd,2,Fri Jun 19 11:15:48 2015 UTC,"The ""Debug nowhere"" part is sometimes a problem though. We really lack debugging capabilities, and printf-style debugging inside GHC is really not much fun."
haskell,3absc6,quchen,5,Fri Jun 19 15:34:24 2015 UTC,"Yeah. That is why you need even stronger types :D  (what, no I couldn't possibly be talking about Agda, or Idris, or Coq, or...)"
haskell,3absc6,mhd-hbd,1 point,Fri Jun 19 16:09:24 2015 UTC,"Why use printf instead of ghci, :break, :set -fbreak-on-error, and :trace?"
haskell,3absc6,codygman,1 point,Fri Jun 19 22:06:43 2015 UTC,"I've had some difficulties with that, for example inside GHC it's sometimes hard to load a module in GHCi. For smaller projects it works fine of course."
haskell,3absc6,quchen,1 point,Sat Jun 20 03:55:19 2015 UTC,How large? I can say its worked well on up to 5000 loc for me.
haskell,3absc6,codygman,1 point,Sat Jun 20 14:05:48 2015 UTC,"I meant ""smaller"" in the sense of complexity. GHC has quite a complicated build system, and when you change something, you can't simply hit :r in GHCi, because complex steps might have to be taken to get all dependencies compiled again."
haskell,3absc6,quchen,10,Sat Jun 20 18:12:06 2015 UTC,"I have the opposite experience. Haskell allows me to start writing while I only have a partially formed idea, and then it incrementally exposes where I need to think harder, until I'm done."
haskell,3absc6,twistier,7,Sun Jun 21 07:59:29 2015 UTC,"I first approached Haskell because it has a multi-platform compiler. What I actually loved about it was that nulls were not baked in the language itself.  After that point, working on Haskell in real projects has taught me the importance of thinking about the problem beforehand. Its type system has pointed many, many mistakes I would've noticed too late (on production environment, probably) in other languages.  In time, I made me think ""how will I make this and that fit together?"" and implement the glue using higher-order functions derived from mathematical structures (functor, applicatives, monoids, monads). Then, I started to miss all that stuff in other languages I work with. All that effort made me think differently about coding in general."
haskell,3absc6,ardamose123,1 point,Thu Jun 18 23:44:01 2015 UTC,"What I actually loved about it was that nulls were not baked in the language itself.   Well, bottom is baked into all types."
haskell,3absc6,776865656e,9,Thu Jun 18 22:20:11 2015 UTC,"I don't know that Haskell made me a ""better programmer,"" but it definitely made me go ""Oh wow... I guess computers can help me design programs!"" which had been unknown to me, during my years of working only with python/perl/php/javascript-kind of languages.  If writing code that is testable and simple to reason about is being a good programmer, then Haskell might definitely make you a better programmer. Because after practicing Haskell, it will become easier for you to frame computations in terms of pure functions. And so you will be writing pure functions in other languages too. And since pure functions are provably simpler to refactor, test, reason about, etc. you will be writing better code in those other languages."
haskell,3absc6,zandernoriega,2,Thu Jun 25 16:33:13 2015 UTC,"I was trying to think how to express my answer to the OP but I think you've nailed it. The C# and Python I write for work now looks as close to Haskell as I can make it. I break everything into small, composable units without even thinking now."
haskell,3absc6,created_to_post_this,6,Thu Jun 18 23:04:23 2015 UTC,"I started with Java and hated the class boiler plate, the lack of higher order functions and the looping by incrementing counters, but I loved the refactoring support and up-front compiler warnings and errors.   Then I tried Ruby and Python and JavaScript and Clojure and l loved the higher order functions but hated debugging runtime errors.  Now I use Haskell for all my personal projects and I get the best of both worlds."
haskell,3absc6,kyllo,1 point,Fri Jun 19 09:02:03 2015 UTC,"You say you get the best of both worlds, but refactoring support's a pretty weak element of current Haskell tooling. It could be great, but it isn't - yet."
haskell,3absc6,776865656e,6,Fri Jun 19 00:22:15 2015 UTC,"I drank the design pattern kool aid so long ago. I still really love the visitor pattern. Haskell showed me a whole boatload of new abstractions that are created for better reasons than ""they're effective""   Haskell made me see interface boundaries in a deeper way. My boring old java stuff is better, cleaner, smaller. It's kind of like seeing problems from a new dimension - there are more axis you can split the solution space.  Also, the haskell compiler is relentless in showing you dumb mistakes. I started to think more deeply about how everything fits together to avoid those compiler errors. That sharpened thinking helps in any language. Sure, the script works, but what would ghc say?"
haskell,3absc6,jfoutz,1 point,Thu Jun 25 16:35:05 2015 UTC,"Sure, the script works, but what would ghc say?   I love that!"
haskell,3absc6,776865656e,5,Fri Jun 19 00:48:48 2015 UTC,"It's helped me manage side effects better. I make many more pure functions now that get tied together in something that has side effects. This has the extra advantage that it makes my code easier to test. It has helped me recognize and name certain patterns better. Even when I'm not working in Haskell, I often now say ""Oh, this should be wrapped in a Maybe,"" or ""this should be generalized to work over all monoids."" I used to have said ""this value might be null; I'd better make it a pointer"" or ""I need to get this to work for both ASCII and Unicode strings, so I'll make a wrapper class with two subclasses."" I tended to write very verbose, over-engineered code. Now that I can put names to the patterns, it's easier to streamline things properly. When I worked in C++, I would get annoyed that functions could only have a single return type when I wanted to return several different things depending on the context. I learned Python, and was thrilled that duck typing let me return any type I wanted, but then became wary/cautious because a function's return type might be anything at all. Now that I know Haskell, I see that what I really wanted all along was an ADT, and I now tend to structure my Python like an ADT when necessary.   Haskell gives me the vocabulary to talk about how the code ought to be structured, regardless of the language."
haskell,3absc6,penguinland,8,Thu Jun 25 16:36:07 2015 UTC,"It opened my mind to the possibilities that existed in computer programming. Before Haskell, these three things were ingrained in my thinking:   strict evaluation/evaluation as a hidden side-effect, global, implicit state, loops being the only control structure.   It all comes down to the point made in Why Functional Programming Matters: Haskell offers ways of composing together parts of programs strict or imperative languages will never match. Implicit state prevents you from decomposing the program into parts. Strict evaluation prevents you from composing parts into programs, because certain kinds of parts cannot be written. None of the following can be defined to the desired effect in a strict language:  or = foldr (||) False min = head . sort cond :: Bool -> a -> a -> a mzero :: Monad m => m a   With no way of defining your own control structures, you're left with the if and while primitives; common patterns cannot be abstracted away and must be written out, over and over again. Ideas like Applicative or Monad, or anything from monad-loops, never even arise.   After ~5 years of procedural PHP & JSF, when it started to dawn on me what kinds of programming were really possible, I honestly felt as if I had been let in on some wonderful secret. I imagine this is how Hilbert must've felt when he saw Cantor's work and said that ""from the paradise Cantor has made us, none shall chase us forth""."
haskell,3absc6,ForTheFunctionGod,1 point,Fri Jun 19 00:09:32 2015 UTC,"Implicit state prevents you from decomposing the program into parts. Strict evaluation prevents you from composing parts into programs, because certain kinds of parts cannot be written [...]   I disagree, although Haskell makes it alot easier."
haskell,3absc6,olzd,4,Fri Jun 19 01:20:31 2015 UTC,"Haskell exposed me to a string of different concepts which all made me better at building programs in subtly different ways. For example, that monads can be composed using distributivity laws made me realize that the engineering concern of composability is equivalent to the mathematical concept of distributivity."
haskell,3absc6,PM_ME_UR_OBSIDIAN,5,Fri Jun 19 11:27:39 2015 UTC,"Haskell taught me a few things:   how to master recursion the value of types how to build bigger code from small parts the value of immutability and controlled side effects the value of higher order functions the value of laziness a bunch of features which will someday arrive to mainstream languages how to build abstractions properly how interesting programming languages and compilers are the connection of math to programming - bunch of math stuff just clicked right away when I studied them in college it was a door to many other languages that it is easier to write functional flavored javascript than imperative javascript more   and also:   how programming is broken how hard and verbose it is to program without immutability and higher order functions (or even kinds!)   Haskell also made me have to ""start programming all over again"", where if I'd continued using C++ I would be probably learning on more interesting and advanced domains, though I will get there."
haskell,3absc6,gilmi,5,Fri Jun 19 00:51:09 2015 UTC,"It made me a better programmer by teaching me the value of tracking side effects explicitly in types. I don't think I've ever had a bigger or more important revelation in all of my 30ish years of programming. (Well, alright... aside from the more ""trivial"" ones like ""I can make the machine do things for me!"" when starting out on this incredible journey that programming is.)"
haskell,3absc6,Oremorj,3,Fri Jun 19 07:06:29 2015 UTC,"Haskell has made me a better programmer because now I know Haskell. Now I have a good understanding of what FP, declarative programming, strong + static typing, etc. are all about, and what they feel like. But I will say that I'm paid to write Java and I've had a hard time taking what I've learned from Haskell and applying it when I write Java. But that was never my goal. I just wanted to have fun learning a new language and see how far I could take it. Turns put I really love Haskell. YMMV."
haskell,3absc6,stolarj,3,Fri Jun 19 18:49:57 2015 UTC,"Not directly related to haskell, but more towards general FP (languages, like clojure, elixir, and even elisp) i have definately used functional techniques in the language i use most at my dayjob, javascript borrowed from other languages. I rarely use loops anymore, and try to avoid mutable state at all costs. Javascript does not force this, but as a result my code has far less bugs and is very predictable. The one thing i miss most is probably pattern matching.  Having no/less sideeffects also makes it trivial to refactor code. Javascript having its roots in lisp, clearly surfaces when you think diffrently about your code, plus es6 brings alot of new stuff. Soon theres even tco, so recursion is a valid option too."
haskell,3absc6,gkunno,1 point,Thu Jun 18 23:16:48 2015 UTC,"Though the JS code results in less bugs, is it efficient?"
haskell,3absc6,hexbienium,2,Fri Jun 19 10:35:42 2015 UTC,"Well, it's the first programming language I'm learning in depth, so it's probably made me better in most respects. If I had to single out one example, I'd say that Haskell's typeclasses have given me a much deeper understanding of the fundamental distinctions between different kinds of data and constructs."
haskell,3absc6,mhd-hbd,4,Fri Jun 19 16:14:14 2015 UTC,Haskell was a gateway drug to a way deeper understanding of what programming is.  Haskell taught me elegance and conciseness. Haskell taught me discipline.
haskell,3absc6,google_you,-12,Fri Jun 19 00:47:10 2015 UTC,"It didn't. It did give me false sense of superiority, though. Now I'm alone at the corner mocking at stupid imperative code with side effects, full of resentment and bitterness. Haskell ftw."
haskell,3absc6,rezb1t,10,Thu Jun 18 22:16:54 2015 UTC,"Well, at least you managed to find a way to feel superior to both groups. [/s]"
haskell,3absc6,google_you,-1,Fri Jun 19 01:54:57 2015 UTC,"Yes, Haskell is such an enabling technology."
haskell,3a9ctd,lukewarm,17,Thu Jun 18 06:59:18 2015 UTC,"Frege does TCO, as far as I know. I am preparing a side project for a Haskell -> asm.js compiler. The spec has been around for a while, but there are already a few rough edges though: one is no resizable heap. That means you should allocate an 1GB buffer (just for a single webpage), or re-allocate and move the heap (like C++ vector, but will cause occasional long stalls). A nice thing about js backend is WebWorkers. I think I can make a threaded rts with that, implement stuff like efficient threadlets, MVars, stuff like that. No existing Haskell -> js compiler has threaded rts, to my best knowledge."
haskell,3a9ctd,terrorjack,9,Thu Jun 18 07:33:46 2015 UTC,"1) Frege turns recursive functions into loops.  To do this fully it would make the linker very tricky (because you will need to build all the functions that might recurse together into the same loop).  2) Luite spent a lot of time looking into it, but eventually decided it was not worth the effort yet.  3) As far as I know WebWorkers cannot share memory, so they are more like processes than threads.  GHCJS does threads and MVars using the same trampoline it uses to void stack overflows (due to the lack of real TCO in JavaScript).  We are hoping Cloud Haskell will be used to communicate with WebWorkers.   Writing a GC is notoriously difficult to get right, but don't let this put you off.  Talk to Luite as he may have some good pointers.  Perhaps you could resurrect the manually managed heap idea in GHCJS."
haskell,3a9ctd,hamishmack,5,Thu Jun 18 08:53:56 2015 UTC,"They can not share memory, but there is a webkit extension with which you can pass buffers between the workers (zero-copy, just handing over a pointer to a memory region)."
haskell,3a9ctd,rstd,6,Thu Jun 18 09:08:53 2015 UTC,"Writing a GC is notoriously difficult to get right. Talk to Luite as he may have some good pointers  ... pointers, to garbage"
haskell,3a9ctd,clrnd,6,Thu Jun 18 14:04:18 2015 UTC,but it's not garbage if there are (reachable) pointers to it...
haskell,3a9ctd,luite2,8,Thu Jun 18 14:39:46 2015 UTC,GC is notoriously difficult to get right...
haskell,3a9ctd,SixBitProxyWax,6,Thu Jun 18 15:32:34 2015 UTC,"It can be garbage even if there reachable pointers to it.  It's garbage if it will never be used again.  Implementing this exactly is, of course, undecidable. The pointer chasing most GCs do is one approximation, but there are others."
haskell,3a9ctd,augustss,5,Thu Jun 18 15:45:05 2015 UTC,"There is a new shared typed array support coming in major browsers. It isn't here today in a meaningful capacity, but it will give us access to browser-based atomics, mostly for supporting things like emscripten and multithreading."
haskell,3a9ctd,edwardkmett,3,Thu Jun 18 15:54:48 2015 UTC,1) Frege turns recursive functions into loops. To do this fully it would make the linker very tricky (because you will need to build all the functions that might recurse together into the same loop).   That's called a trampoline and it's what many Scheme compilers that compile to C do.
haskell,3a9ctd,chrisdoner,5,Thu Jun 18 12:46:21 2015 UTC,"That doesn't sound right to me.  A trampoline can be used to optimize all tail calls.  A loop is a much simpler construct that only works on recursive ones (or mutually recursive ones, if you're clever)."
haskell,3a9ctd,tomejaguar,6,Thu Jun 18 13:47:05 2015 UTC,"To clarify:     1) Frege does TCO, as far as I know.   1) Frege turns recursive functions into loops. To do this fully it would make the linker very tricky (because you will need to build all the functions that might recurse together into the same loop).    Doing it ""fully"" would be doing a trampoline, which is perfectly implementable in C or Java. (Unless by ""fully"" was meant ""make all the other Java code I call from foreign functions also not allocate any stack when recursing, but I don't think that's what was meant by ""Frege does TCO."")   A loop is a much simpler construct that only works on recursive ones (or mutually recursive ones, if you're clever).   Yes, changing some functions that are self-tail-recursive into loops is a limited specialization that I implemented in the Fay compiler.  That said, Haskell's laziness shares behaviour with a trampoline: force the thunk, get back a thunk, force the thunk, get back a thunk. This is why forever m = do m; forever m runs in constant space."
haskell,3a9ctd,chrisdoner,4,Thu Jun 18 14:55:40 2015 UTC,"Ah yes, you're right.  I misunderstood.  Now that you've clarified, everything in the thread makes a lot more sense :)"
haskell,3a9ctd,tomejaguar,2,Thu Jun 18 14:57:36 2015 UTC,"Doing it ""fully"" would be doing a trampoline, which is perfectly implementable in C or Java. (Unless by ""fully"" was meant ""make all the other Java code I call from foreign functions also not allocate any stack when recursing, but I don't think that's what was meant by ""Frege does TCO."")   What I meant is that Frege does not use function pointers or anything in its trampoline (I could be confusing it with some other language though).  So if A can tail call B and B can tail call A (where A and B are functions in different compilation units) then the linker will need to build a trampoline function that can call both A and B.  A() = Trampoline_AB(0) B() = Trampoline_AB(1) Trampoline_AB(f) =     while true         switch f             case 0:                  f = A_impl();             case 1:                  f = B_impl();   instead of just having  A() = Trampoline(A_impl) B() = Trampoline(B_impl) Trampoline(f) =     while true         f = f()   Does that sound right or is Frege smarter than that (perhaps it uses a mix of both sorts of trampoline)?"
haskell,3a9ctd,hamishmack,4,Thu Jun 18 17:17:28 2015 UTC,"TCO on the jvm   AFAIK that only works with trampolines, which are pretty expensive."
haskell,3a9ctd,ibotty,5,Thu Jun 18 08:30:23 2015 UTC,"There is a clear intention on the behalf of the Ecmascript folks to eventually support TCO automatically, it just isn't here yet. (There has been desire to support it since the failed ES4 days, so I'm not holding my breath but I am hoping to be pleasantly surprised some day.)"
haskell,3a9ctd,edwardkmett,6,Thu Jun 18 15:55:57 2015 UTC,"See section 14.6, page 262 of the latest version of the standard (ES6, June 2015)  http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf"
haskell,3a9ctd,luite2,1 point,Thu Jun 18 18:03:11 2015 UTC,I meant the java virtual machine. On others not all hope is lost.
haskell,3a9ctd,ibotty,3,Fri Jun 19 08:01:47 2015 UTC,I think support for resizing asm.js heaps has been added https://bugzilla.mozilla.org/show_bug.cgi?id=965880
haskell,3a9ctd,farre,2,Thu Jun 18 10:25:26 2015 UTC,"Oh well, I'm not sure if another (besides Fay, Haste and GHCJS) compiler is what we need :S"
haskell,3a9ctd,bananu7,16,Thu Jun 18 10:28:47 2015 UTC,"TCO is apparently already on the agenda: it seems that it's proposed for asm.js (see also the Firefox bugzilla), and is listed as a ""future feature"" for WebAssembly."
haskell,3a9ctd,neelk,7,Thu Jun 18 08:43:29 2015 UTC,This pleases me.
haskell,3a9ctd,chrisdoner,7,Thu Jun 18 15:01:49 2015 UTC,"The main bottleneck is that it currently has all the asm.js limitations of lack of access to the garbage collected store, so it is rather hard to interact with. Once those limitations are relaxed, I'm looking forward to a new version of ghcjs with a greatly reduced footprint. ;) The ES7 improvements 64 bit arithmetic should help out a great deal as well."
haskell,3a9ctd,edwardkmett,4,Thu Jun 18 15:53:27 2015 UTC,"Hallelujah, this should have been done 15 years ago.    Brendan / Mozilla fought pretty hard to keep any concept of binary format, byte code, common IL, pretty much anything that hinted at the possibility of a language agnostic runtime ever happening on the (ironically)  O/S agnostic browser.   But I guess only Nixon could have gone to China ..."
haskell,3a9ctd,precium,4,Thu Jun 18 18:33:06 2015 UTC,"This should have been the plan for browser-side code since the beginning, I wonder how any standards body could consider Javascript a proper standard."
haskell,3a9ctd,BethAr,0,Thu Jun 18 19:42:41 2015 UTC,Why do you think JS is not a standard? Can you elaborate?
haskell,3a9ctd,rstd,7,Thu Jun 18 22:55:54 2015 UTC,"Oh, it is a standard. I was arguing that it shouldn't be."
haskell,3a9ctd,BethAr,0,Thu Jun 18 23:49:28 2015 UTC,Why shuldn't it be a standard?
haskell,3a9ctd,rstd,4,Fri Jun 19 08:05:24 2015 UTC,"The whole point of WebAssembly is that Javascript is horrible, there are many websites which will describe why that is the case.  The number of compile-to-javascript languages is enormous just because people have to fight constantly against Javascript's shortcomings.  If you need a simple overview from a Haskell point of view, take a look at ""The Javascript Problem"" at Haskell.org."
haskell,3a9ctd,BethAr,2,Fri Jun 19 14:38:00 2015 UTC,"There's still no bytecode, etc. It's just a binary version of the asm.js AST."
haskell,3a9ctd,psygnisfive,6,Thu Jun 18 20:25:09 2015 UTC,One could argue asm.js is a Javascript source code representation of byte code.
haskell,3a9ctd,zoomzoom83,2,Fri Jun 19 01:46:53 2015 UTC,I wouldn't hold my breath just yet.  WebAssembly is a waporware and will stay so for at least a few years.
haskell,3a9ctd,vagif,6,Thu Jun 18 14:54:57 2015 UTC,"""Vaporware"" seems like a somewhat strong term for something with a prototype implementation. It's not a working product yet, but ""a few years"" is pretty pessimistic."
haskell,3a9ctd,ldpreload,4,Thu Jun 18 15:56:01 2015 UTC,"As far as I could tell from their documentation, that prototype isn't a prototype of WebAssembly. It's a prototype of binary encoded Javascript, more to prove that WebAssembly would provide enough of an advantage to actually pursue. It's a proof of concept; nothing more."
haskell,3a9ctd,balefrost,4,Fri Jun 19 01:50:28 2015 UTC,"In this case prototype won't cut it. This is not yet another javascript microframework developed by one guy in his free time with 3 followers on github :))  This is a huge project that hinges on implementation and support by all major players (MS, Google, Mozilla, Apple)."
haskell,3a9ctd,vagif,3,Thu Jun 18 16:18:41 2015 UTC,I thought there were people from all of those companies helping with this project?
haskell,3a9ctd,sccrstud92,2,Thu Jun 18 22:54:09 2015 UTC,And it will take all of them collectively at least 5 years to deliver a first iteration of a usable product supported across all major browsers.
haskell,3a9ctd,vagif,1 point,Fri Jun 19 00:26:19 2015 UTC,Wouldn't it make more sense to work on compiling C-- to WebAssembly? That way more languages would be supported.
haskell,3absht,andrewthad,5,Thu Jun 18 20:40:16 2015 UTC,"Let's figure it out!  Looking at the source, I notice a private module called Graphics.Rendering.SVG which creates an svg AST from different kinds of diagrams. For example:  > import Diagrams.Prelude > import Graphics.Rendering.SVG > let svg = renderPath unitSquare > :t svg svg :: SvgM > svg <path d=""M 0.5000000000000001,-0.5 l -1.1102230246251565e-16,1.0 h -1.0 l -1.1102230246251565e-16,-1.0 Z""/>   This SvgM type is from lucid-svg, so maybe there is an operation in there to add attributes to existing Svg values? Looking at the documentation, I find this:  > import Lucid.Svg > :set -XOverloadedStrings > svg `Lucid.Svg.with` [class_ ""myclass""] <path d=""M 0.5000000000000001,-0.5 l -1.1102230246251565e-16,1.0 h -1.0 l -1.1102230246251565e-16,-1.0 Z"" class=""myclass""/>   It worked! But we have to add those extra attributes after the diagram has already been rendered to svg. Can we somehow use a diagrams attribute which will later be rendered to class_ along with everything else?  Looking at the code for Graphics.Rendering.SVG again, I notice functions called renderAttr and renderTextAttr which look like they accept arbitrary attributes. Unfortunately they are not exported by the module, and within the module they are always called with a concrete attribute other than class_, so I think it is clear that diagrams-svg does not support what you want. Oh well!"
haskell,3absht,gelisam,2,Fri Jun 19 12:46:59 2015 UTC,"Thanks. This is the closest thing in the right direction that I've seen so far. I think that to support this feature, diagrams itself would need to be able to track a map of arbitrary data (maybe of type Map Text Dynamic or Map Text Text) that backends could handle in a specific way. Or maybe since people usually work with a monomorphic diagram, there might be a way to extend only the SVG version of a diagram with extra fields that can be set. But I haven't explored the internals enough to know yet."
haskell,3absht,martingalemeasure,4,Fri Jun 19 15:33:15 2015 UTC,"I'm one of the developers of diagrams. So you are on the right track, you should be able to add an attribute in diagrams-svg that can be added to the style of a diagram. Then diagrams-svg would handle the attribute. If you would like to work on it I can help you navigate to the right parts of the code base - join us on #diagrams, irc. If not perhaps file and issue on github in the diagrams-svg repo and hopefully one of us will be able to get to it in the not too distant future."
haskell,3absht,gelisam,2,Fri Jun 19 15:41:46 2015 UTC,https://github.com/diagrams/diagrams-svg/pull/82
haskell,3absht,sccrstud92,1 point,Fri Jun 19 18:15:12 2015 UTC,I think I'm on the right track now. Expect a PR from me soon.
haskell,3absht,martingalemeasure,2,Fri Jun 19 17:35:46 2015 UTC,Looks like diagrams already have the ability to track a map of arbitrary data: https://hackage.haskell.org/package/diagrams-core-1.3.0.1/docs/Diagrams-Core-Style.html
haskell,3aagnk,martingalemeasure,15,Thu Jun 18 14:47:55 2015 UTC,"Close enough?  {-# LANGUAGE ScopedTypeVariables #-} main :: IO () main = do   msg :: String       <- getLine   putStrLn msg   The type signature is on the variable pattern, I just played with the whitespace to make it look like the type signature and the binding are on two separate lines like in your example."
haskell,3aagnk,gelisam,1 point,Thu Jun 18 15:28:41 2015 UTC,This is what I currently do but I'd still prefer it to be more like my original post. Not to mention my syntax highlighter doesn't work properly on this style.
haskell,3aagnk,int_index,12,Thu Jun 18 16:44:42 2015 UTC,"Your syntax highlighter is bad, that's all."
haskell,3aagnk,mstksg,10,Thu Jun 18 17:50:10 2015 UTC,are you suggesting we hack the language to support a syntax highlighter? :p
haskell,3aagnk,PM_ME_UR_OBSIDIAN,2,Thu Jun 18 20:31:21 2015 UTC,IMHO anything that has to do with traversing source code should be the responsibility of the compiler :)
haskell,3aagnk,MaxGabriel,1 point,Fri Jun 19 04:33:22 2015 UTC,no of course not. just putting it out there for folks who hack on editor pluggins.
haskell,3aagnk,nifr,4,Fri Jun 19 12:26:01 2015 UTC,"It fails for my syntax highlighter as well, but this works for me:  (msg :: String) <- getLine"
haskell,3aagnk,Iceland_jack,10,Thu Jun 18 22:35:53 2015 UTC,"main :: IO main = do   msg <- getLine   let _ = msg :: String   ...   I know it's a little upside down, but that trick has often worked for me.  I'm opposed to the OP's syntax because it would require some sort of heuristic to distinguish it from  do   io :: T   where T is some type headed by the monad."
haskell,3aagnk,andrewthad,2,Thu Jun 18 15:42:03 2015 UTC,It doesn't have to be upside down (note the mdo):  {-# LANGUAGE RecursiveDo #-}  main :: IO () main = mdo   let _ = msg :: String   msg <- getLine   ...   May leave you with a weird taste in your mouth though.
haskell,3aagnk,int_index,1 point,Fri Jun 19 02:23:07 2015 UTC,High five! I've done this too.
haskell,3aagnk,Iceland_jack,5,Thu Jun 18 15:43:11 2015 UTC,+1 for noticing the ambiguity.
haskell,3aagnk,sfvisser,7,Thu Jun 18 17:49:51 2015 UTC,You can write  main :: IO () main = do   msg :: String <- getLine   putStrLn msg
haskell,3aagnk,int_index,2,Thu Jun 18 15:23:20 2015 UTC,"Yes, but you do need -XScopedTypeVariables in order to explicitly type patterns."
haskell,3aagnk,tdox,14,Thu Jun 18 15:29:21 2015 UTC,I could argue that -XScopedTypeVariables is how Haskell should work in the first place.
haskell,3aagnk,tomejaguar,1 point,Thu Jun 18 17:49:15 2015 UTC,+1  Haskell2015?
haskell,3aagnk,dougmcclean,4,Fri Jun 19 06:14:17 2015 UTC,I have often wanted this.
haskell,3aagnk,Iceland_jack,3,Thu Jun 18 15:18:02 2015 UTC,Why not just  msg <- getLine :: IO String
haskell,3aagnk,EvilTerran,2,Fri Jun 19 06:56:25 2015 UTC,I think because in general the monad might have a complicated type that doesn't have a simple name like IO in scope.
haskell,3abqoc,remwang,9,Thu Jun 18 20:27:12 2015 UTC,"Apart from time, space consumption is another thing to care about. Laziness can sometimes cause space leak, for example, check modifySTRef' in Data. STRef"
haskell,3abqoc,terrorjack,5,Thu Jun 18 21:09:35 2015 UTC,Another common one is trying to store the result of some work done on one thread in a location shared with another thread.
haskell,3abqoc,acow,6,Thu Jun 18 21:00:27 2015 UTC,"Strictness matters the most in data type declarations. Strict (and unboxed) fields work much better on today's CPUs, due to better cache usage (both in terms of size and locality). In particular, non-strict scalar fields are almost always wrong."
haskell,3abqoc,tibbe,2,Fri Jun 19 05:59:21 2015 UTC,"Sorry for my ignorance, but what does Scalar field mean ?"
haskell,3abqoc,sibip,6,Fri Jun 19 07:30:36 2015 UTC,"A scalar is any datatype that is simple and not composite, ie. not a function, a record, a struct, a list, an array etc. Usually by scalar types people mean integers, chars and floating-point numbers. So what Johan Tibell meant was that in types like  data Rec = Rec {a :: Int, b :: Double, nonScalar :: CompositeType,                  c :: Char, fun :: Int -> CompositeType -> CompositeType}   it is almost always better to make the following fields strict:  data Rec = Rec {a :: !Int, b :: !Double, nonScalar :: CompositeType,                  c :: !Char, fun :: Int -> CompositeType -> CompositeType}   Note that making fields strict does not necessarily mean that they will be unboxed.  Addendum: you might find this and the wiki page helpful."
haskell,3abqoc,SkoomaMudcrab,1 point,Fri Jun 19 11:01:44 2015 UTC,"Int, int64, double, and so forth."
haskell,3abqoc,tibbe,6,Fri Jun 19 11:56:06 2015 UTC,"I wrote a library that performs Monte Carlo simulations, and literally adding one $! (i.e. strict function application) instead of a $ cut the run-time in half.  My understanding is that the vast majority of heavily numerical code would benefit from strictness, but correct me if I'm wrong."
haskell,3abqoc,tdees40,4,Fri Jun 19 17:13:51 2015 UTC,You are correct. There's work going on to make a strict by default language extension for such code.
haskell,3abqoc,garethrowlands,8,Fri Jun 19 20:46:41 2015 UTC,"Strictness is an optimization - you're telling the compiler about the evaluation order, instead of leaving it up to the compiler to work out.  As such, its appropriate when you know more information about the optimal evaluation strategy than the compiler.  This is common in very low level code, or when writing algorithms."
haskell,3abqoc,dons,3,Fri Jun 19 10:49:12 2015 UTC,"Not a direct answer to your question, but I found it very useful to understand more about how Haskell's evaluation model actually works. If you understand it, then you will be able to answer this on a case by case basis.  Here are my go-to references:   http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf https://hackhands.com/lazy-evaluation-works-haskell/"
haskell,3a9qou,Kiuhnm,9,Thu Jun 18 10:17:16 2015 UTC,"Are you talking about the PureScript compiler when you say it has a bus-factor of 1? That's not really the case, I basically co-develop it with /u/paf31 and there are others that have a pretty good understanding of some or all of the internals too, like @andyarvanitis, /u/hdgarrood, @puffnfresh."
haskell,3a9qou,gb__,1 point,Thu Jun 18 13:00:40 2015 UTC,I fixed the OP.
haskell,3a9qou,vagif,6,Thu Jun 18 18:37:25 2015 UTC,"Are you a single dev, or do you work in a team?  Do you intend at some point to pass your codebase to someone else for maintenance?  If the answer is yes, you will find that developing front end with a language most known is better for your project longterm than your desire to enjoy the ride while you are in it :)  Let me tell you a anecdote from my experience.  I developed a web app with yesod where the front end (html and javascript) was generated by the backend using hamlet templates. The javascript was still just a normal js.  Yet when i tried to bring into project other members of our team, i quickly found out that anything besides very trivial stuff like fetch the data from db and pass it to the browser is very hard for them to grasp.  Luckily there was not that much front end code (html and js) so i sat over the weekend and moved all html and js from yesod templates into static files and converted our app into SPA (on angular).   This allowed my other team members to quickly get into development and mostly write js/html/css with a touch of very simple haskell (REST urls returning or consuming json)  Nowadays i would recommend you to try out reactjs + immutable and optionally some FRP lib like RxJs or baconjs.  Otherwise when time comes for you to move on, you'll find yourself chained to that project because no one else will be able to take it off your hands.  You will become that bus factor 1 you are dreading so much :)"
haskell,3a9qou,valderman,4,Thu Jun 18 15:16:21 2015 UTC,"You may want to have a look at Haste in addition to GHCJS. Last time I checked, Haste produced quite a bit smaller code than GHCJS. Unfortunately, the current stable 0.4 branch isn't all rainbows and unicorns; both performance and compatibility is getting a major overhaul with 0.5, but that release is still some time off.  Full disclosure: I'm the main developer of Haste."
haskell,3a9qou,valderman,2,Thu Jun 18 17:34:22 2015 UTC,My only problem with Haste is that it's a dialect of Haskell so I can't get full code reuse between client and server.
haskell,3a9qou,valderman,5,Thu Jun 18 17:46:56 2015 UTC,"It's a dialect in the sense that it's GHC Haskell minus (currently) Template Haskell and weak references, plus a few libraries and extras. You should report any compatibility problems as bugs, because code reuse is definitely a design goal of Haste."
haskell,3a9qou,andrewthad,10,Thu Jun 18 18:06:50 2015 UTC,"I don't mean to be inappropriate, but why don't you and GHCJS's developers join forces?"
haskell,3a9qou,cdsmith,6,Thu Jun 18 18:11:24 2015 UTC,"Depends on the definition of ""join forces"". We have some different ideas of code generation, among other things, which means it's pretty unlikely that Luite et al would just dump GHCJS and start working on Haste, and vice versa. This is not a bad thing. There's more than one way to skin a cat, and often nice things come out of multiple people skinning multiple cats in different ways.  However, I definitely agree that there could - and should - be more of a joint effort regarding infrastructure, common problems and other things. It just... Hasn't happened so far, I guess. ghc-simple is one  fledgling effort to make some of the work on Haste more widely useful, but probably not really useful to GHCJS though."
haskell,3a9qou,cdsmith,2,Thu Jun 18 20:07:44 2015 UTC,"Just to add a little historical perspective, there was a period a time (at least a year, maybe several) when haste was a way more usable solution than GHCJS. I know this because about a year and a half ago, I played around with Fay, Haste, and GHCJS. Haste was like a much better Fay, and GHCJS was that thing that seemed like the most correct solution but that didn't really work yet and could only be built by the devs working on it. I remember reading posts about whether or not it was abandoned or if it was ever going to work out. So, at that point in time, the choice of Haste seemed like a no-brainer for anyone who wanted to use haskell client-side.  At the present time, the situation is different. GHCJS did actually work out, and now common folks can get it installed and working."
haskell,3a9qou,sclv,5,Fri Jun 19 20:10:48 2015 UTC,"Luite has mentioned here that there is work on a""next-generation"" code generation for GHCJS, and I seem to recall that it sounded very interesting in that it was set up to enable different code generators.  A big reason for GHCJS's code complexity now is that it simulates a GHC style multithreaded environment.  An option to generate single threaded code when you know that's not necessary would make the code a lot simpler.  That said, let me echo the sentiment that while the code might look bad, consider running Closure, and then actually checking the code size and performance.  It doesn't do so bad.  It's been plenty sufficient for my project (CodeWorld)."
haskell,3a9qou,hamishmack,0,Fri Jun 19 00:19:10 2015 UTC,"But ""it doesn't do so bad"" and ""plenty sufficient"" don't sound so comforting.  Scala.js is ""almost as fast as hand-coded JS"".  So the question is: ""Is Haskell so much better than Scala to justify the risk(?) of producing slower applications?"""
haskell,3a9qou,mightybyte,2,Fri Jun 19 00:57:39 2015 UTC,"That's your decision to make.  In my case, the answer is that the whole project would be useless if I switched from Haskell to Scala.  CodeWorld accepts code written by kids and produces JavaScript with GHCJS for them to see the result, and Scala is a non-starter for teaching to kids in this setting.  That's different from your situation... but that comes down to you needing to define what your requirements are, and make a decision about what meets your specific requirements."
haskell,3a9qou,mightybyte,1 point,Fri Jun 19 16:03:11 2015 UTC,"I've already decided that I'm going to implement a small app both in Scala and Haskell to see the difference.  Besides, I think that learning Haskell will open my mind even If I should end up choosing Scala."
haskell,3a9qou,BethAr,2,Fri Jun 19 18:34:25 2015 UTC,"The difference isn't in performance as measured by real benchmarks. The difference is that the Scala.js developers make bolder claims than the ghcjs developers -- that doesn't mean those claims are necessarily correct. To be quite honest I don't have any reason to believe they are, absent benchmarks..."
haskell,3a9qou,Tekmo,1 point,Fri Jun 19 16:26:00 2015 UTC,"GHCJS has Threads, MVars and Async Exceptions.  Why would you want those?  If you have a calculation to do that may take too long can send it to the server before you start and if the result comes back from the server before the client finishes you can abort the local thread doing the calculation with an Async Exception."
haskell,3a9qou,Tekmo,7,Fri Jun 19 03:44:45 2015 UTC,"I found out that GHCJS produces javascript code which is big and slow.   I have an app with almost 9000 lines of code that I'm compiling to JS with GHCJS.  Is the raw output big?  Yes.  But I disagree that it is necessarily slow.  When we switched to GHCJS we were actually surprised at how snappy that UI was.  Can it get better?  I'm sure it can.  But I haven't found that it is unusably slow right now.  I haven't spent much time yet trying to reduce the code size, but one afternoon I ran the GHCJS output through the clojure compiler in aggressive mode and the code size went from ~19MB to a little less than 1MB!  In my mind that is small enough for most SPAs.  So I would argue strongly for your possibility #1 and have put my money where my mouth is and am using that approach for a significant project.  Oh, and I will say that I have found it very important to have the front and back ends in the same language.  Even just switching from Haste (almost the same language) to GHCJS made a big difference in our code size and reuse."
haskell,3a9qou,mightybyte,6,Thu Jun 18 11:54:50 2015 UTC,"GHCJS is probably fast enough for your UI, but it's at least 3 times slower than hand-coded JS. That's a deal breaker for me. Scala.js and Dart are much much faster.  Also 1 MB is considered quite big if you want to support mobile devices as well."
haskell,3a9qou,mightybyte,6,Thu Jun 18 13:57:07 2015 UTC,Could you give more concrete details about your use case and the test scenario that led you to those numbers?
haskell,3a9qou,mightybyte,5,Thu Jun 18 14:03:18 2015 UTC,"I would like to know more as well. We are doing experiments porting a substantial application to Elm, Purescript and now GHCJS (Reflex), and found little difference in performance, if any. The application is quite large even in the original Angular.js implementation, so the increase in size was negligible, the increase in performance, however, is noticeable."
haskell,3a9qou,hamishmack,1 point,Thu Jun 18 14:19:48 2015 UTC,Those are numbers that I read here and there on the web. I don't know how reliable they are.  Are there some official figures?
haskell,3a9qou,vagif,7,Thu Jun 18 14:20:47 2015 UTC,"Why don't you write a tiny project in each language and compare generated code size and performance?  I don't think it's wise to rely on hearsay.  The amount of times that ""conventional wisdom"" is wrong is astonishing.  You'll also be more confident in your decision if you test things out yourself."
haskell,3a9qou,hamishmack,1 point,Thu Jun 18 17:06:18 2015 UTC,The only problem is that I already know Scala (I use it prevalently as a functional language) but I know nothing about Haskell. I was looking for some reassurance that learning Haskell was a good investment for someone who already is proficient in Scala.
haskell,3a9qou,hamishmack,8,Thu Jun 18 17:14:42 2015 UTC,My experience is that it takes less time to learn something than to assess whether or not its worth learning.  This is especially true for the case of learning Haskell from Scala.  The two languages are similar enough that it shouldn't take you very long to pick up Haskell.
haskell,3a9qou,sclv,5,Thu Jun 18 17:16:33 2015 UTC,"A flat across the board statement such as ""3x slower"" rarely captures the realities adequately.  I'm generally skeptical of performance claims when they come without well-defined empirical tests to back them up.  I'd like to get a better idea of precisely what you want to do so I can give more informed advice about whether GHCJS will be sufficient, and if not, how likely it might be to get there in the future."
haskell,3a9qou,radix,3,Thu Jun 18 14:36:23 2015 UTC,"What I do depends on what my clients need. For instance, my next project is going to be a mobile-friendly forum.  Faster and shorter JS means a better experience on mobile platforms. Faster JS also means lower battery consumption, so the faster the better."
haskell,3a9qou,mightybyte,4,Thu Jun 18 14:51:57 2015 UTC,"As is usually the case in software, you have to make a tradeoff.  If you anticipate a significant mobile user base, then maaaaaybe GHCJS-generated code will be too bloated for you.  But I absolutely don't think speed will be problematic.  Are a few milliseconds here and there and few extra minutes of battery life worth the substantially reduced code compleity, fewer bugs, and better maintainability you can get from using GHCJS?  In the vast majority of common applications I think GHCJS is a clear win.  Also, I believe there is a big overhaul to the GHCJS code generator in the works.  I'm sure this will improve code size and probably performance.  Even if you decide that you don't have enough experience with GHCJS to warrant using it for your next project, I would definitely recommend using it for small projects in your spare time so you can get up to speed and better assess whether it will work for you."
haskell,3a9qou,turbomann,4,Thu Jun 18 15:37:52 2015 UTC,"OK, I'll develop a small app in GHCJS and see how it goes. I hope the documentation is enough to get started. Thanks for convincing me :)"
haskell,3a9qou,mightybyte,5,Thu Jun 18 16:17:14 2015 UTC,"I'd recommend trying it with the reflex FRP library.  Ryan Trinkle has really streamline the process of getting up and running with his try-reflex repo.  Even if you don't need substantial reactive functionality that still might be the easiest way to get started.  But if you're building GUIs, then I'm guessing you'll probably want FRP sooner rather than later.  Check out Ryan's talk at the NY Haskell Meetup for a nice introduction to reflex."
haskell,3a9qou,turbomann,2,Thu Jun 18 16:33:30 2015 UTC,That library is one of the reasons why I wanted to try GHCJS in the first place.
haskell,3a9qou,mightybyte,2,Thu Jun 18 16:59:34 2015 UTC,If your app is just going to handle infrequent user events with a small amount of logic then you should be fine.  If it has to animate things or perform complex computations then it will depend on the requirements.  There is a lot of cool stuff you can do with GHCJS that will probably tax some mobile devices.  For instance you could live preview markup text entered by users (like the GHCJS based markup.rocks does).  However I think it should be possible to scale back most apps when running on low power devices.  For instance markup.rocks could scale back on mobile devices so it:   Only downloads the conversion code for the most popular document types. Only convert the document when the user stops typing for 10sec. Only convert when the user presses a preview button. Sends the document to the server for conversion instead of doing it on the client.   And when that kind of scaling is not possible you can always resort to the JavaScript FFI to optimise the performance critical parts of your application.  The best bet might be to create an example app of what you fear will be a pathological use case.  If it is slow or power hungry share it and someone else might have a good solution.
haskell,3a9qou,Bzzt,2,Thu Jun 18 16:25:40 2015 UTC,If your app is just going to handle infrequent user events with a small amount of logic then you should be fine.   In which case one would question shooting birds (simple client side apps) with cannons (ghcjs)  He'd probably be done with that app using any current js frameworks in a fraction of time it takes to install and properly configure ghcjs :))
haskell,3a9qou,ItsNotMineISwear,1 point,Thu Jun 18 20:17:08 2015 UTC,I was thinking of something like a web app designed to replace a shared spreadsheet with 1000 formula cells.
haskell,3a9qou,CKoenig,1 point,Fri Jun 19 03:16:20 2015 UTC,The best bet might be to create an example app of what you fear will be a pathological use case. If it is slow or power hungry share it and someone else might have a good solution.   I'd prefer to choose a technology which guarantees a certain level of efficiency. For instance Dart is as fast as hand-coded JS. Scala.JS is also very fast and Scala (in the right hands) is very concise and expressive. So why not use Scala instead of Haskell? Is Haskell so much better as a language?
haskell,3a9qou,erdeszt,1 point,Thu Jun 18 17:08:06 2015 UTC,"I'd prefer to choose a technology which guarantees a certain level of efficiency.   The guarantee that GHCJS tries to provide is that if something is O(x) when compiled with GHC then it will be O(x) when compiled with GHCJS.  This is what allows code to be shared between client and server without fear that it will go from say O( N ) to O( N2 ).  There will be constant factor differences and GHCJS aims to keep them small, but not all of them will be GHCJS related (for instance a mobile device will not match a high end server).    So why not use Scala instead of Haskell?   Too much baggage for my liking.   Is Haskell so much better as a language?   Yes, I think so."
haskell,3a9qou,Oremorj,2,Thu Jun 18 17:55:08 2015 UTC,The guarantee that GHCJS tries to provide is that if something is O(x) when compiled with GHC then it will be O(x) when compiled with GHCJS.   That's the bare minimum!!! I guess this isn't obvious in Haskell because of lazy evaluation.
haskell,3a9qou,Oremorj,2,Thu Jun 18 18:06:41 2015 UTC,"In my experience, the cost of calculations in JS is dwarfed by the cost of DOM interaction (not to mention ajax calls) -- it is nearly always the case that improving performance of JS apps isn't about the cleverness of the generated code, but the care with which the ""expensive"" work is minimized by higher level architectural decisions."
haskell,3a9qou,expatcoder,6,Fri Jun 19 16:23:06 2015 UTC,"btw, I think you mean Closure compiler, not Clojure :)"
haskell,3a9qou,sclv,2,Thu Jun 18 14:20:27 2015 UTC,"Oops, yes."
haskell,3a9qou,expatcoder,2,Thu Jun 18 14:36:40 2015 UTC,"Based on your requirements, I would probably recommend Clojure + ClojureScript. Works nicely on client and server, there are nice libraries and functional programming using immutable data structures. Additionally, ClojureScript compiles down to really efficient JS which might actually end up being faster than native  JS (escpecially if you want to use something along the lines of react.js via om/reagent/reacl).  ATM I don't see GHCJS generating usable JS if you want to support mobile or your SPA to be fast and responsive. I sure hope this is going to change but as of now, I'll stick to CLJS with the occasional look at Elm."
haskell,3a9qou,sclv,3,Thu Jun 18 14:25:34 2015 UTC,ATM I don't see GHCJS generating usable JS if you want to support mobile or your SPA to be fast and responsive.   Supporting mobile...you might be right.  Fast and responsive...I have a complex GUI that says otherwise.  And GHCJS allowed this to be done with code that is MUCH more maintainable and less prone to bugs.
haskell,3a9qou,expatcoder,2,Thu Jun 18 14:59:52 2015 UTC,"Well, I guess it depends. At t he shop I work we use ClojureScript for almost all of our guis and so far, we did not run into major problems that were caused by cljs maintainability. On the other hand, we're pretty focused on writing small and simple functions with usable comments.   That being said, I'm really looking forward to using Haskell via GHCJS, but I think that this sadly is still going to take a lot of work."
haskell,3a9qou,sclv,6,Thu Jun 18 15:32:37 2015 UTC,"That being said, I'm really looking forward to using Haskell via GHCJS, but I think that this sadly is still going to take a lot of work.   It's absolutely going to take a lot of work, which is why I'm trying to get more people using it.  But I think the potential is huge."
haskell,3a9qou,expatcoder,2,Thu Jun 18 15:45:30 2015 UTC,"There are two things I don't like about Clojure:   it's not statically typed it's a lisp   There is nothing wrong with Clojure and I read great things about it, but I don't like it. I prefer Haskell-like syntax and if I can't use Haskell, then Scala will do.  Elm is cool but its type system is sorely lacking and the author is not going to do anything about it because he's afraid of scaring away non-Haskell developers."
haskell,3a9qou,gilmi,2,Thu Jun 18 14:43:50 2015 UTC,"Why not GHC + purescript?  You can have some similar data structures on each end if you'r'e concerned about serialization.  You can't directly share code on each end but stylistically they are similar.  If you're interested in doing your full stack in haskell-like languages this seems like a good way to go to me.    Maybe in the future there will be GHCWebAssembly with better performance, but I wouldn't plan on that for any real world projects yet."
haskell,3ab7ok,evanrelf,3,Thu Jun 18 18:09:55 2015 UTC,"A version of ghc-mod that's compatible with GHC 7.10 hasn't been released yet. According to https://github.com/kazu-yamamoto/ghc-mod/issues/437, cloning the repository, and cabal installing it should work."
haskell,3ab7ok,willIEverGraduate,1 point,Thu Jun 18 19:07:14 2015 UTC,"This is correct. I've been using it with 7.10.1 for a while now. It's not perfectly happy, but it works."
haskell,3ab7ok,acow,5,Thu Jun 18 20:56:09 2015 UTC,"Just had a few small suggestions:   however stack doesn't like my version of GHC   stack will work with either GHC 7.8 or 7.10, you just need to select the right snapshot. If you have a different GHC version to what the snapshot requires, running stack setup will get the right one. I'd probably recommend that in this case, as ghc-mod isn't compatible with your system-installed GHC   the Stackage Nightly global config file gives me some obscure fromFlag NoFlag. Use fromFlagOrDefault error   Wipe our your ~/.cabal/config file, run cabal update, and then append the contents on stackage.org to your ~/.cabal/config file instead of replacing it (yes, the instructions on stackage.org are confusing on this part, I'll update it).  That said, most people seem to prefer using sandbox-local settings instead of global settings."
haskell,3ab7ok,snoyberg,2,Fri Jun 19 05:43:27 2015 UTC,Have you tried a Cabal sandbox yet?
haskell,3ab7ok,hexbienium,3,Thu Jun 18 19:01:42 2015 UTC,"This is my first time ever using Cabal, so while I have heard of sandboxes, I have no idea how to use them."
haskell,3ab7ok,BethAr,2,Thu Jun 18 20:00:07 2015 UTC,"Assuming you don't know this yet: if you do the cabal sandbox init command at the root folder of your project, a sandbox will be created for that project. Every package you install from that same folder will end inside the sandbox and not at the global package repository, which will avoid conflicts with the packages of other projects.  If you don't need the sandbox anymore, you can simply delete the .cabal-sandbox folder and the cabal.sandbox.config file."
haskell,3ab7ok,BethAr,1 point,Thu Jun 18 20:21:13 2015 UTC,Is there any benefit to creating a sandbox in your user directory?
haskell,3ab7ok,BethAr,1 point,Thu Jun 18 23:40:43 2015 UTC,"I might be wrong, but I think that is where cabal-install will place your packages by default. People on Mac can elucidate.  I believe you should only create sandboxes for the projects, and avoid installing anything outside them unless you are sure it will not cause any conflicts, or that it will be used across all of your projects.  The only things I install outside a sandbox are GHCJS and the tooling that SublimeHaskell requires. Obviously, they bring with them a million other dependencies."
haskell,3ab7ok,Hrothen,3,Thu Jun 18 23:59:41 2015 UTC,The fact that cabal does not default to using sandboxes is terrible. Every new user falls into the trap. I'm considering advising new people to skip cabal altogether and use the new LTS tools.
haskell,3ab7ok,mightybyte,1 point,Thu Jun 18 19:46:19 2015 UTC,"In this specific case it would actually be worse if the packages were automatically installed in a sandbox, as a new user doesn't know they need to manually add it to their PATH. It would just look like some mysterious error."
haskell,3ab7ok,BethAr,1 point,Thu Jun 18 20:35:01 2015 UTC,"The fact that cabal does not default to using sandboxes is terrible. Every new user falls into the trap.   That has not been my experience at all.  Most of the new users I have talked to were already using sandboxes.  Now maybe that was the case at an earlier stage and I'm just not seeing them until later.  But I still do not think sandboxes are the biggest issue.  The biggest issue is packages with missing dependency bounds.  If the very first cabal install command you run works inside a sandbox, then it would have worked outside a sandbox."
haskell,3ab7ok,mightybyte,2,Thu Jun 18 19:58:12 2015 UTC,"Yes, but the second command may not. Since every new project will add it's own dependencies, the chances of cabal hell increase dramatically.  My experience has been the opposite of yours, most users I know have been bitten by this, some to the point of even being dissuaded from learning Haskell. The only time they escape the trap is when they have someone more experienced guiding them."
haskell,3ab7ok,int_index,1 point,Thu Jun 18 20:15:04 2015 UTC,"Yes, I don't dispute that we are better off with sandboxes than we were without them.  But I think they are a little overblown because it's too terribly difficult to learn when they matter and how you might manage without them."
haskell,3ab7ok,andrewthad,3,Thu Jun 18 21:02:48 2015 UTC,"This should be a 72pt red warning on top of the Cabal manual:  DO NOT cabal install WITHOUT A SANDBOX  You're going to burn in the Cabal hell.  However, your problem is for another reason: ghc-mod is not yet compatible with GHC 7.10."
haskell,3ab7ok,int_index,1 point,Thu Jun 18 19:13:50 2015 UTC,So would I solve this by using GHC 7.8? Would I want to have both versions of GHC installed simultaneously (how would that work?) or do I need to downgrade?
haskell,3ab7ok,int_index,1 point,Thu Jun 18 20:05:36 2015 UTC,"Don't try to install two versions of GHC simultaneously. There are ways to do this (for example stack), but if you're new to haskell, you don't want to get drowned in all the alternative package manager mess. My recommendation is to remove 7.10.1 and use 7.8.4 instead for the time being. Whenever a new haskell release comes out, the 7.X.1 version is supposed to be stable, but I prefer to wait til 7.X.2 comes out to make sure everything has really been worked through."
haskell,3ab7ok,int_index,0,Thu Jun 18 20:16:16 2015 UTC,"My advice would be to not use ghc-mod. It's slow and buggy anyway. Haskell tooling isn't very good as of today.  EDIT: This is just my experience with ghc-mod. I don't want to offend the authors and contributors of the project. In fact, I'd be happy if the tool became better, so please keep working on it. I know some work is being done wrt speed."
haskell,3ab7ok,Hrothen,1 point,Thu Jun 18 20:12:28 2015 UTC,How do I use Cabal sandboxes? Is it different for projects and global packages?
haskell,3ab7ok,andrewthad,1 point,Thu Jun 18 20:06:28 2015 UTC,"When you invoke cabal sandbox init, you're creating a separate local package database in your current directory. This is similar to how NPM works - it creates a local package database."
haskell,3ab7ok,mightybyte,1 point,Thu Jun 18 20:14:17 2015 UTC,"Okay that makes sense. If a dependency conflict arises in a sandbox, what's the best way to deal with it? Will starting over from scratch and reinstalling things fix it? Or do I have to do some sort of version limiting?"
haskell,3ab7ok,int_index,1 point,Thu Jun 18 23:39:56 2015 UTC,"Sometimes you can fix it with cabal sandbox delete && cabal sandbox init and reinstalling everything, sometimes not. In practice, you almost always can."
haskell,3ab7ok,mightybyte,1 point,Fri Jun 19 07:01:41 2015 UTC,"Sandboxes are used to create local installs of packages so different versions don't conflict with each other in different projects. Since you're trying to install binaries that you want to be available everywhere, you want to build in a sandbox but put the executable somewhere on your PATH. There are a couple ways to do that, but we actually have a handy shell script to automate it, which suffices for most tasks."
haskell,3ab7ok,int_index,1 point,Thu Jun 18 20:39:26 2015 UTC,"As an addendum to this good advice, add this line to ~/.cabal/config (An just in case you're a total noob, the tilde means your home folder):  require-sandbox: true   Now you will have to use sandboxes and cabal-install stops you if you try not to."
haskell,3ab7ok,mightybyte,1 point,Thu Jun 18 20:21:53 2015 UTC,"I'm just a noob to Haskell :)  Does that change apply everywhere, so anywhere I try and install a package it will only let me inside a sandbox?"
haskell,3ab7ok,int_index,0,Thu Jun 18 23:52:10 2015 UTC,DO NOT cabal install WITHOUT A SANDBOX You're going to burn in the Cabal hell.   Not at all.  You just have to be aware of what you're doing and be willing to unregister packages and/or rm -fr ~/.ghc in the future.
haskell,3ab7ok,mightybyte,2,Thu Jun 18 19:19:40 2015 UTC,"Can you install multiple versions of the same package with this approach? Will it work properly every time?  Also, going lower a level (from cabal to ghc-pkg) sounds like a symptom of Cabal hell to me."
haskell,3ab7ok,tdox,0,Thu Jun 18 19:29:54 2015 UTC,"Can you install multiple versions of the same package with this approach? Will it work properly every time?   A clean non-sandbox system is EXACTLY the same as a single clean sandbox.  Yes, you can install multiple versions of the same package as long as they don't have conflicting dependency constraints.  If you're installing to an empty package repository, yes, it will work properly every time.  If you try to install another package that depends on the package for which you have installed two versions, then you might have issues.  But the same is true of sandboxes.   Also, going lower a level (from cabal to ghc-pkg) sounds like a symptom of Cabal hell to me.   The fundamental ""cabal hell"" problem has been around for decades and was previously known by terms such as DLL hell and dependency hell.  It is about finding a solution to complex sets of dependency constraints.  You can have cabal hell in a sandbox in all the same ways you can have cabal hell without a sandbox.  Going from cabal to ghc-pkg is just a user interface issue.  ghc-pkg unregister is analogous to cabal sandbox hc-pkg unregister.  rm -fr ~/.ghc is analogous to cabal sandbox delete.  Cabal hell isn't about whether you're using a single sandbox or no sandboxes at all.  It's about what you do with a single sandbox.  The biggest thing sandboxes give you is the ability to have multiple completely isolated sets of packages exist at the same time and not feeling icky about doing cabal sandbox delete.  If you don't need to switch back and forth between different incompatible sets of installed packages, then you could just not use sandboxes and you'd be fine."
haskell,3ab7ok,mightybyte,3,Thu Jun 18 19:49:22 2015 UTC,"But the same is true of sandboxes.   This isn't true of sandboxes for the very reason that you can have several of them. Yes, you can't have packages with conflicting dependencies in one sandbox, but you can have several sandboxes.   You can have cabal hell in a sandbox in all the same ways you can have cabal hell without a sandbox.    Yes, but you're bazillion times less likely to, as every project you're working with has a separate sandbox."
haskell,3ab7ok,_AndrewC_,2,Thu Jun 18 20:10:22 2015 UTC,"Yes, but you're bazillion times less likely to, as every project you're working with has a separate sandbox.   If you don't know about rm -fr ~/.ghc, then I agree.  But for years I've viewed that as essential knowledge.  Sandboxes are a nicer way of doing the same thing.  I think rather than just trumpeting ""sandboxes!"" we should educate people about what's really going on that causes these issues and how they can be avoided."
haskell,3ab7ok,mightybyte,3,Thu Jun 18 21:06:53 2015 UTC,"If I have two projects with confilcting dependencies, should I rm -rf ~/.ghc every time I compile one after the other?"
haskell,3ab7ok,_AndrewC_,2,Thu Jun 18 21:38:11 2015 UTC,"Right, that's the case where sandboxes provide the biggest benefit.  But I think that a decent portion the time people won't have two projects with conflicting dependencies."
haskell,3a8re2,xelxebar,34,Thu Jun 18 03:08:15 2015 UTC,I think this would be cool. I prefer this idea to trying to tell people to go to a different subreddit.
haskell,3a8re2,radix,1 point,Thu Jun 18 03:19:05 2015 UTC,Porque no los dos? Have a link to /r/haskellquestions in at the top of the weekly post.
haskell,3a8re2,tejon,4,Fri Jun 19 02:22:24 2015 UTC,Because that splits the user base. Most people will settle on one and miss questions and answers in the other.
haskell,3a8re2,rpglover64,3,Fri Jun 19 02:30:18 2015 UTC,"Yep, I gave up on my city subreddit to a large degree when they decided to split out social things from news needlessly."
haskell,3a8re2,saudade,16,Fri Jun 19 16:21:23 2015 UTC,I think that'd be a rad idea. Even now I still have questions like 'what's the point in arrows'
haskell,3a8re2,Octopuscabbage,9,Thu Jun 18 04:27:30 2015 UTC,"Arrows were first introduced to solve space leaks that occurred in monadic parsers.  They can provide guarantees about garbage collectibility that monads can't.  This is explained in John Hughes paper ""Generalising Monads to Arrows.""  Arrows came before Applicative and Applicative has a similar kind of advantage, but Applicative seems to be much more generally useful.  NB. I am not an expert on these things."
haskell,3a8re2,reaganveg,5,Thu Jun 18 05:08:17 2015 UTC,"Applicative + Category gives all the power/guarantees of Arrow, iirc."
haskell,3a8re2,Crandom,3,Thu Jun 18 08:10:22 2015 UTC,"You also sometimes want Bifunctor (e.g. for  Either or (,)) or Profunctor (e.g. for (->))"
haskell,3a8re2,rpglover64,3,Thu Jun 18 17:02:12 2015 UTC,"Apart from what others have said, one good use for arrows is for modeling pipes and streams, kind of like the Bourne Shell (UNIX shell) concept of pipes, and Haskell has a language extension enabling the syntactic sugar for this kind of pipes programming. Arrows provide the Lego-block-like functions to which the pipe programming syntactic sugar translates, in much the same way that monads provide the Lego-block-like functions to which the imparative programming syntactic sugar translates."
haskell,3a8re2,Ramin_HAL9001,2,Thu Jun 18 07:38:25 2015 UTC,"Two good references about that (practical-ish, not historical): 1 2.  They also provide proc notation (analogous to monads' do notation) that's useful for certain complex data-flow wiring (take a look at auto for some examples)."
haskell,3a8re2,rpglover64,5,Thu Jun 18 17:10:07 2015 UTC,The point of arrows is that some things are arrows but not monads.
haskell,3a8re2,tomejaguar,9,Thu Jun 18 06:30:52 2015 UTC,"I'm thoroughly for this idea. /r/haskellquestions gets very little traffic, so I think this would help, both by encouraging people to ask questions and by encouraging people to read questions.  A lot of subs have themed days, and a lot of spin-off haskell subs have little traffic, so I'd probably suggest something like ""TIL - Wednesdays"", ""Best Of - Fridays"", etc. in addition to e.g. ""Ask Anything - Mondays""."
haskell,3a8re2,rpglover64,1 point,Thu Jun 18 17:22:07 2015 UTC,This is a really great idea! I hope the mods take notice.
haskell,3a8re2,reaganveg,9,Thu Jun 18 18:32:26 2015 UTC,"I think this is a great idea. I don't think it's good to branch off into other subreddits for newbies, because it's useful to get those questions exposed to the entire community, for extra eyeballs to check to ensure the answers written are correct, and to give a varied perspective.   I wish there was one of these for category theory, do you think it's possible to include a space of 'safe, interrelated / connected / adjacent topics' (like category theory) to ensure that there is a regular stream of questions, and that comprehension is complete, and knowledge retention is firm? As long as it can relate back to haskell in some way, of course. I just would like to gain understanding from a less pragmatic application side of things, as I improve with the language."
haskell,3a8re2,beerdude26,6,Thu Jun 18 11:37:53 2015 UTC,"This is a really good idea.  Most people would hesitate to ask a ""stupid"" question in a top-level thread, but there is no obvious alternative (other than just not asking here)."
haskell,3a8re2,twistier,1 point,Thu Jun 18 05:49:00 2015 UTC,Especially when they see cutting edge stuff passing by all the time.
haskell,3a8re2,Ramin_HAL9001,5,Sat Jun 20 17:34:02 2015 UTC,I think this is a fantastic idea.
haskell,3a8re2,ForTheFunctionGod,3,Thu Jun 18 12:03:52 2015 UTC,"I would love to see this, and I am fairly regularly on Reddit, so I would like to contribute to answering beginner questions."
haskell,3a8re2,sccrstud92,2,Thu Jun 18 07:39:47 2015 UTC,"Sounds like a great idea. /r/haskellquestions is nice, but it's much, much less active than /r/haskell, as others have already said. A regular questions thread here would ensure a wider exposure of people's questions, while not flooding the subreddit - and it would constitutive good outreach."
haskell,3a8re2,dalaing,4,Fri Jun 19 01:29:41 2015 UTC,"For now, we have /r/haskellquestions"
haskell,3a8re2,sccrstud92,19,Thu Jun 18 03:15:36 2015 UTC,"I might have missed something, but I don't think there's anything like consensus that questions are off-topic in /r/haskell.  Sometimes questions get posted and get voted up a lot, or generate interesting discussions.  Granted, sometimes they fall flat.  They don't all get downvoted as off-topic, and /r/haskell has more than 20x the subscribers of /r/haskellquestions, so it seems like /r/haskell is just as valid a place for questions.  It always irks me when someone has a question and gets a ""Take it to /r/haskellquestions"" as a response.  Partly because that doesn't seem to be the consensus, but mostly because I can imagine how frustrating it is.    I don't know how I'd take it if I had a questions I really wanted answered, I found /r/haskell and saw that people were asking questions (and they were being well received) and then got told to scram when I asked mine.  Maybe people go away assuming there's some kind of secret handshake - or maybe they just go away :/"
haskell,3a8re2,dalaing,4,Thu Jun 18 03:51:27 2015 UTC,"I hope I didn't imply that questions don't belong here. I certainly don't feel that way. However, in light of OP's proposal for a questions only thread, I think not acknowledging a questions only subreddit first would be a mistake.  On the flipside, imagine seeing a subreddit with a lot of haskell discussion, but is often about very advanced topics, and then finding out about /r/haskellquestions from one of the comments (because no one reads the sidebar as much as they should) and feeling like they finally found a good repository of questions from newcomers like themselves."
haskell,3a8re2,Alyte,4,Thu Jun 18 04:09:26 2015 UTC,"I agree that it's good to point out /r/haskellquestions.  I have no problem whatsoever with your initial comment.   I just have a bee in my bonnet about people dropping by and trying to shoo people away, and your comment reminded me that I've been meaning to say my piece for while now.  I've been holding off because it didn't seem fair to rant in response to any particular individual saying ""Take it to /r/haskellquestions"".  Partly because it's not any one person doing it, and partly because it would derail the thread.  Finally, a meta-thread on questions has appeared, and I have one less thing to vent about :)"
haskell,3a8re2,dalaing,2,Thu Jun 18 04:38:22 2015 UTC,"I disagree. There are plenty of places to ask questions, but I don't think here should be one of them. On this subreddit, most content is about Haskell's design, cool plans and showing off libraries, all things Haskell excluding questions really. Now, I think it should be kept as such not because ""eww, newbies"" (I'm one anyways) but because of the sheer number of questions people tend to have. I don't want all the other cool content to be dwarfed by questions :( We have /r/haskellquestions, which is active enough, why take that content which I'm sure not all of us subbed for, and put it here?  Now, as for interesting discussions. Yeah, those are great. Should be fine to repost thought provoking or unanswered questions here?  Edit: there is also stackoverflow, the IRC, Google, etc... And our community is among the most welcoming IMHO anyways, in case anybody thinks people may have trouble looking for help. Not to mention this subreddit links to /r/haskellquestions."
haskell,3a8re2,rpglover64,2,Thu Jun 18 23:09:13 2015 UTC,"We have different opinions on this, which is fine.   I still don't think there is a consensus on questions being off-topic. The votes and discussions on questions on /r/haskell seem to indicate that they're on-topic."
haskell,3a8re2,sccrstud92,1 point,Thu Jun 18 23:18:00 2015 UTC,/r/haskellquestions gets very little traffic compared to the /r/haskell; I think this proposal would be a large improvement.
haskell,3a8re2,rpglover64,1 point,Thu Jun 18 17:12:36 2015 UTC,"That may be true, but I know of at least one person who has them both open all the time."
haskell,3a8re2,sccrstud92,1 point,Thu Jun 18 17:22:44 2015 UTC,"And I always read my own multi, but we're still just a drop in the bucket."
haskell,3a8e35,valderman,20,Thu Jun 18 01:10:18 2015 UTC,"The GHC API is many things; easy to get started with is not one of them. (At least, it wasn't for me. Your mileage may vary.) To make it a bit more accessible, I broke out the compiler driver parts of Haste and generalized them slightly. The result is a small library that lets you use GHC to extract various information from Haskell code in a fairly straightforward manner, without having to first figure out how GHC works under the hood.  The plan is to add some additional scaffolding on top, to automate bootstrapping any custom compilers built using the library: automating storage and bookkeeping for application-specific intermediate code, loading dependencies on demand, that sort of thing.  I'm curious if this may be of use to anyone outside of our department, and if anyone has any features or API enhancements to suggest to make it useful to a wider audience."
haskell,3a8e35,Tekmo,5,Thu Jun 18 01:10:23 2015 UTC,It might help to have one long-form example in the haddocks to show how the pieces fit together
haskell,3aa5kl,andrewthad,5,Thu Jun 18 13:10:14 2015 UTC,"You also have this option:   replicate :: (Applicative f, Alternative f) => Int -> a -> f a  replicate 0 _ = empty  replicate (1 + n) x = pure x <|> replicate n x   If you're willing to throw out plain ol' Haskell98, then you can also have   replicate :: (Applicative f, Monoid (f a)) => Int -> a -> f a  replicate 0 _ = empty  replicate (1 + n) x = pure x <> replicate n x   I tend to prefer these as it's clearer what it means to replicate a specific element.  I guess your replicateMonoid is a bit closer to raising an element to a power, that is replicateMonoid 5 (Sum 20) ~ 5 * 20 for an additive monoid or replicateMonoid 5 (Product 20) ~ 20^5 for a multiplicative monoid."
haskell,3aa5kl,ocharles,3,Thu Jun 18 13:32:00 2015 UTC,"Note: it is better to repeatedly double. This gives you O(log n) replicate for some Alternatives/Monoids. Using the machinery in semigroups, sometimes it can be O(1)."
haskell,3aa5kl,edwardkmett,1 point,Thu Jun 18 20:01:33 2015 UTC,"Ah yea, thanks for reminding me of that trick!"
haskell,3aa5kl,ocharles,2,Thu Jun 18 23:13:05 2015 UTC,"I like yours replicates. I had not considered those as options before, and they do seem to make more sense when you can distinguish the element from the container. But, in cases like Endo and Text, I think that replicateMonoid is the only option."
haskell,3aa5kl,ocharles,3,Thu Jun 18 13:54:46 2015 UTC,"Indeed, yours will cover more cases than mine can. I tend to reach for things based on Alternative when I have a sensible way of talking about any Haskell types (hence the functor f)."
haskell,3aa5kl,imz,2,Thu Jun 18 13:58:43 2015 UTC,Why are using <|> from Alternative in the second definition?
haskell,3aa5kl,ocharles,1 point,Thu Jun 18 14:06:25 2015 UTC,Because I didn't type check my code :) Thanks for noticing!
haskell,3aa5kl,sccrstud92,5,Thu Jun 18 14:22:47 2015 UTC,Check out Data.Semigroups.times1p  times1p :: Natural -> a -> a   This also performs more efficiently that most list-based replicating method because it uses repeated squaring. Only issue is you can't use it to obtain mempty.
haskell,3aa5kl,edwardkmett,4,Thu Jun 18 17:56:24 2015 UTC,Using it we can make a Monoid + Semigroup based 'replicate' that can nicely act in O(1) time on things like Any and All that are idempotent. I use this fairly often. I should probably add it to Data.Semigroup.
haskell,3aa5kl,cghio,3,Thu Jun 18 20:00:20 2015 UTC,"Just about every conceivable helper function of monoid a helper function of lists, as lists are the free monoid.   monoidReplicate x = mconcat . replicate x"
haskell,3aa5kl,singpolyma,2,Fri Jun 19 02:01:46 2015 UTC,Similar to:  mconcat (replicate n x)
haskell,3a97xs,begriffs,3,Thu Jun 18 05:58:06 2015 UTC,"/u/begriffs, I wish you used a different video player or provided a way to cast the video to my TV. Not being able to do so makes viewing the video uncomfortable."
haskell,3a97xs,chinpokomon,2,Fri Jun 19 08:39:20 2015 UTC,Thanks for reporting the issue. Can you explain what it does wrong? Screenshot?
haskell,3a97xs,chinpokomon,2,Sat Jun 20 03:41:21 2015 UTC,"It just doesn't have a way to send to ChromeCast. I can make the video full screen, but if it were an MP4 or WebM video, I think Chrome automatically adds a cast button. I've only viewed the site on my phone, but the player is not the native player for browser, and maybe it isn't an HTML5 video format? I'm not sure since I haven't dug into the site source code."
haskell,3a97xs,rampion,4,Sat Jun 20 03:54:50 2015 UTC,"Ok, I love laziness but I hate promoting take 5 $ sort xs as a viable way of working.  I'm going to pick on this more fleshed out example, rather than Tikhon's fly-by  import Debug.Trace (traceShow) import Data.List (partition)  sort :: Ord a => [a] -> [a] sort [] = [] sort (x:xs) = sort ls ++ [x] ++ sort rs   where (ls, rs) = partition (<x) xs  newtype TraceOrd a = TraceOrd a deriving (Show, Eq) instance (Show a, Ord a) => Ord (TraceOrd a) where   compare (TraceOrd a) (TraceOrd a') = traceShow (a,c,a') c     where c = compare a a'  input :: [ TraceOrd Int ] input = map TraceOrd $ reverse [1..100]   Given that, we can see that print $ minimum input does 99 comparisons while print $ (head . sort) input does 4950.  Dude, that's making a linear algorithm quadratic.  Laziness is great, but using this example just makes us look bad and reduces credibility.    UPDATE: Yeah, this wasn't a good argument."
haskell,3a97xs,tikhonjelvis,3,Thu Jun 18 19:03:31 2015 UTC,"I think that's more a problem of that sort than anything.   Some cursory testing with the standard sort from Data.List has them performing similar amounts of comparisons. (Which is, presumably, a variant of merge sort.) It looks like a constant difference.  EDIT: After slightly less cursory testing (but still being too lazy for an actual analysis), head . sort has a very consistent 1.4x overhead over minimum on random numbers. This is just a constant factor, and one that's not too bad. The quadratic explosion above is purely a result of the poor implementation of sort.  More generally, it does depend on the algorithm used by sort, but this just means that the right algorithm to choose for sorting a lazy list is different than what you'd use for an array or something. (I'd have to think about it more than I want to right now, but heap sort might be a really good fit.)  It still seems like a reasonable way to think about combining programs and taking advantage of laziness."
haskell,3a97xs,tikhonjelvis,2,Thu Jun 18 21:40:50 2015 UTC,Should I replace the sort example in the notes below the video with another one which has better gains from laziness?
haskell,3a97xs,rampion,3,Thu Jun 18 23:38:09 2015 UTC,"I think it's fine. As far as I can tell, the take n . sort example works correctly with just a constant overhead—a small price to pay for expressiveness and modularity. (Ie it does, indeed, preserve asymptotics.) You just have to use an appropriate sort algorithm... like the one from Data.List."
haskell,3a97xs,tikhonjelvis,2,Thu Jun 18 23:41:40 2015 UTC,"Ok, thanks for coming back with some testing. I concede the point.  I apologize for pulling an example from an arbitrary blogpost and associating it with your talk. I should have gone straight to testing against Data.List.sort.  Now I really want to spend some time reading sort's implementation.  Thanks for taking the time to set me straight."
haskell,3a97xs,sambocyn,1 point,Fri Jun 19 01:54:19 2015 UTC,"It's worth a look, if only for the comments which paint an interesting history of GHC's sort going from quick sort to merge sort."
haskell,3a97xs,rampion,1 point,Fri Jun 19 05:37:47 2015 UTC,is that Prelude's sort?
haskell,3a9kif,_skp,9,Thu Jun 18 08:46:26 2015 UTC,"I statically link my executables on Windows, and that's the default behaviour IIRC. When I wanted my friend to run my application, he just copied the 7MB executable. No hassle, worked like a charm.  For libraries (when the end-user is a developer), using cabal seems fine."
haskell,3a9kif,bananu7,-3,Thu Jun 18 10:12:42 2015 UTC,"That’s being lazy and dodging the issue. For friends, why not. For a serious and/or commercial purposes, that doesn’t fit. GHC has been supporting shared libraries for a while now on. We have to use it.  If the end-user is a developer, I think that cabal is there exactly for that, I totally agree."
haskell,3a9kif,Drezil,9,Thu Jun 18 10:16:11 2015 UTC,"statically linking is the default-way to do it. To everyone i talked who is into deployment (mostly games) i got the same answer: Link EVERYTHING statically and provide installers for your dependencies (.NET, DirectX...). On Linux there is a small exception due to the packet-manager. You can depend on slow-moving, stable libraries (like OpenGL, SDL, ...) - but if you use anything not in the default repos of your supported platform (yes, even debian-stable if you want to support it) should be linked statically.  And for Unix: just support Source-Downloads with a buildscript, which basically reads like  <getting stackage or using a defined one> cabal sandbox init cabal install --only-dependencies cabal build ln -s dist/..../ executable   At least thats how i would do that and it seems reasonable."
haskell,3a9kif,Hrothen,2,Thu Jun 18 10:21:24 2015 UTC,"Dude, we've been passing around executable binaries between computers for as long as it's been possible."
haskell,3a9kif,acow,5,Thu Jun 18 17:34:31 2015 UTC,"It's a platform-dependent problem, and even then you'd want to consider your audience. cabal-install is a build tool, not a package manager, so you're right in that it's totally inappropriate.  For OS X, you could target brew if your audience is tech savvy, but not necessarily Haskell savvy. You could also package things up into an app bundle for end users.  For Windows, statically link the executable and put together an installer.  For most Linux distributions, build packages for each major package manager.  For Nix, you don't need to do anything, you're already done."
haskell,3a9kif,emmanueltouzery,6,Thu Jun 18 14:55:32 2015 UTC,"halcyon looks like an interesting solution for that purpose, but I didn't manage to look at it yet. I agree cabal+ghc are not a good solution."
haskell,3a9kif,Drezil,5,Thu Jun 18 10:07:17 2015 UTC,"Do you want to distribute sourcecode or binaries?  For sourcecode i think stackage and cabal are sufficient - as people wanting the source want to develop anyway.  What is needed is somthing to bundle up everthing you have in your working-directory .. like a  cabal bundle <target>   where target is something like ""windows"" ""osx"" ""arm"" ""unix"" etc.  sadly this would also bundle all the dependencies into a package. But i think this is a good thing when you want to deploy to end-users. They just want to install their *.msi, *.exe, *.deb, ... and have things working.  I think the usual unix-way of sharing resources is not (yet) feasible with Haskell as libraries are changing too fast and you cannot force a dependency on the client.  i.e. i want to deploy my yesod-app and i just noticed a change in authorization for from version 1.4.2 -> 1.4.3 wich will break beginning with 1.5 or 1.6. So either you clutter your code with pragmas like   #ifdef yesodver < 1.5 ... #else ...   and basically replicate every change of any library in your code so the suggested cabal build can figure stuff out or you have to restrict yourself to ""stable"" libraries provided by your target - thus shutting yourself out from recent changes or whole libraries.  tl;dr:   for sourcecode-distribution i think stackage is enough for end-user-distribution we need to pack everthing into one package (or even one binary) and suffer that the enduser wastes diskspace as libraries don't get shared"
haskell,3a9kif,Drezil,1 point,Thu Jun 18 10:16:15 2015 UTC,Statically linked executables sound to be a solution. But I’m not sure it’s a good solution…
haskell,3a8ixb,rampion,10,Thu Jun 18 01:53:41 2015 UTC,"The term for this is ""Beautiful folds"".  There's an implementation of this in my foldl library almost exactly equivalent to what you wrote, so you can just write:  >>> import Control.Foldl as L >>> let mean = L.sum / L.genericLength   There is another implementation in Edward's folds library and the documentation for that contains links to other resources on this topic."
haskell,3a8ixb,Tekmo,5,Thu Jun 18 02:35:25 2015 UTC,"As far as I know, the literature on this amazing topic resides in blog posts; the original idea appears to be due to Max Rabkin:  http://squing.blogspot.com/2008/11/beautiful-folding.html   which arose from the complications in   https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/  The applicative instance, which is part of what makes the idea so awesome, is due to Twan van Laarhoven, inventor of the 'van Laarhoven lens' concept, in a comment on Rabkin's post. Conal Elliot has written a number of related posts   http://conal.net/blog/posts/another-lovely-example-of-type-class-morphisms  The foldl library was distinctive for actually exporting a wide assortment of pre-defined folds. Many others could be written.    For example, many of the folds in the statistics library are written internally in pretty much this way, but are exported as functions, and thus a) cannot be employed simultaneously, and b) can only be used on vectors. But the Fold concept is independent of the input type and can be employed on bytestrings, lists, and various types from pipes, conduits and io-streams etc.  In the streaming case, a second pass is out of the question, and so the idea is really essential."
haskell,3a8ixb,michaelt_,2,Thu Jun 18 12:51:56 2015 UTC,"Thanks!  Having now reread all of these, I can no longer say where I first read it.  Another nice approach I found was Data analysis with Monoids."
haskell,3a8ixb,darkroom--,4,Thu Jun 18 17:05:53 2015 UTC,Don't know the paper but I can think of a library: https://hackage.haskell.org/package/foldl-1.0.0/docs/Control-Foldl.html
haskell,3a8ixb,vikasmenon,2,Thu Jun 18 03:04:33 2015 UTC,Maybe this: http://www.haskellforall.com/2013/08/composable-streaming-folds.html
haskell,3a6p9h,drb226,18,Wed Jun 17 17:34:26 2015 UTC,So you didn't have to type cabal sandbox init and you didn't have to type cabal install --dependencies-only and you didn't have to type cabal test?
haskell,3a6p9h,sclv,31,Wed Jun 17 18:49:47 2015 UTC,"He also didn't have to wait for several minutes (or, depending on the project and the hardware, tens of minutes) to wait until everything in the sandbox compiles from scratch.  He also didn't have to remember to delete the sandbox which otherwise would consume hundreds of megabytes of disk space."
haskell,3a6p9h,roche,12,Wed Jun 17 18:59:02 2015 UTC,Sure. I'm just trying to distinguish what the key features are and aren't -- i.e. to elicit responses like yours that expand on the post and clarify these things.
haskell,3a6p9h,sclv,15,Wed Jun 17 19:00:21 2015 UTC,"Ah, the time honored technique of Socratic trolling."
haskell,3a6p9h,otherwhere,5,Thu Jun 18 05:44:16 2015 UTC,"Otherwise known as ""asking questions""."
haskell,3a6p9h,sclv,12,Thu Jun 18 14:10:12 2015 UTC,"you didn't have to type cabal sandbox init   Correct. And believe it or not, I consider this a bigger win than meets the eye. If a contributor comes back later and does a fresh pull, said contributor doesn't have to think about whether or not to make a new sandbox or to use the same one that they used a couple months ago. Stack handles this automatically.   and you didn't have to type cabal install --dependencies-only   Correct. This is a small win. I don't consider it to be very big, but it's one less thing to remember. Again, if contributors come back months later, they don't have to think about it. It's just done automatically.  Oh, and did I remember to install test suite dependencies? I forget if cabal install --only-dependencies will do the right thing if I also pass it the --enable-tests flag, or if I need to cabal configure first. With stack, it's just handled for me. One more papercut avoided.   and you didn't have to type cabal test   Well I did have to type stack test. But this ran all four test suites, and automatically compiled these packages against each other. I think its intelligent handling of multi-package projects is one of stack's biggest improvements over cabal.  Not only didn't I have to type these things, I didn't have to think about them. Not having to think about them is a minor convenience for those of us who are veterans at using cabal, but it's a major convenience for newcomers, who won't even have to learn how to manually manage a sandbox and dependencies."
haskell,3a6p9h,theonlycosmonaut,5,Wed Jun 17 19:43:00 2015 UTC,"I think it also worth noting that I was also able to be sure that the build on my machine was using the same dependencies as the build that other contributors are using. But this can also be accomplished with cabal.freeze so, not much difference between cabal and stack on this point. (Also .halcyon/constraints accomplishes the same.)"
haskell,3a6p9h,conklech,3,Wed Jun 17 19:50:46 2015 UTC,"Does stack pay attention to a .cabal file if it extsis, or do I have to duplicate dependencies into the stack file if I want to provide both methods?"
haskell,3a6p9h,Crandom,2,Wed Jun 17 21:50:15 2015 UTC,"Does stack pay attention to a .cabal file if it extsis?   to a degree, yes.   do I have to duplicate dependencies into the stack file if I want to provide both methods?   You currently have to duplicate dependencies into the stack file, even if stack is your only method.  Each package has a cabal file which specifies dependencies for buildable targets of that package. This is necessary for uploading to hackage. Stack also makes sure it adheres to the constraints listed in the cabal file.  stack.yaml specifies a precise set of dependencies. As Crandom noted, most of these are implicitly specified via the Stackage snapshot you select (e.g. lts-2.13). Any hackage dependencies that aren't in the snapshot must be specified, along with the specific version of each dependency that you would like to use.  Stack prints helpful error messages that suggest versions for these extra dependencies for you. You can just copy/paste the snippet from the error message right into your stack.yaml. Stack 0.0.3-beta was just released, which has a really nice error message improvement.  So you see, the .cabal file and the stack.yaml file serve different purposes. The latter is more comparable to a cabal.freeze file."
haskell,3a6p9h,creichert,1 point,Wed Jun 17 22:34:55 2015 UTC,"You currently have to duplicate dependencies into the stack file, even if stack is your only method.   Isn't this statement overly pessimistc? You can leave the auto-generated stack.yaml file alone unless the dependencies stated in the .cabal file are inconsistent with the auto-selected Stackage snapshot, correct?  (I realize you explain in detail later, but perhaps it would be better not to start off with ""yes, you have to duplicate everything, except..."")"
haskell,3a6p9h,Crandom,3,Wed Jun 17 22:55:14 2015 UTC,"You can only leave the auto-generated stack.yaml alone if you have no extra-deps. I don't believe that stack is smart enough yet to correctly generate extra-deps without some human intervention. But the process of   stack build copy suggested extra-deps into stack.yaml repeat   Usually goes most of the way. I just wrote up a stack.yaml for the lambdabot repo using this process. After the automated help, I had to do two more things manually:   select an older version of IOSpec than was suggested, because the suggested version wanted base >=4.8 when I wanted to use ghc-7.8. select an older version of utf8-string (the one in the snapshot was too new)   Both are considerations that stack will probably get smart enough to do automatically, but it's not there yet.  See also: https://github.com/lambdabot/lambdabot/pull/124"
haskell,3a6p9h,theonlycosmonaut,2,Wed Jun 17 23:03:50 2015 UTC,You will have to add any dependencies in your cabal file that aren't on Stackage to the extra-deps field. In reality this will probably not be that many packages as all the popular ones are on Stackage.
haskell,3a6p9h,Crandom,6,Wed Jun 17 21:53:38 2015 UTC,You can also point to a git or http url directly:  packages: - some-directory - https://example.com/foo/bar/baz-0.0.2.tar.gz - git: git@github.com:commercialhaskell/stack   commit: 6a86ee32e5b869a877151f74064572225e1a0398
haskell,3a6p9h,cdep_illabout,2,Thu Jun 18 06:37:01 2015 UTC,This is awesome
haskell,3a6p9h,mightybyte,1 point,Thu Jun 18 07:06:03 2015 UTC,"As long as the right versions are there! EDIT: ah, looks like the ability to choose a snapshot will help that greatly."
haskell,3a6p9h,mightybyte,2,Wed Jun 17 22:06:54 2015 UTC,"You can also put a different package-version in extra-deps, which will shadow the one in the Stackage snapshot."
haskell,3a6p9h,sopvop,4,Thu Jun 18 10:10:31 2015 UTC,"Is there some way to open up the tests in ghci with stack?  With cabal I can do cabal repl test (assuming my test is named ""test"").  I wanted to do this the other day with stack and I couldn't figure out how."
haskell,3a6p9h,sopvop,2,Thu Jun 18 01:38:09 2015 UTC,"I don't believe this is currently possible, but should be doable. Pinging /u/chrisdoner."
haskell,3a6p9h,mightybyte,19,Thu Jun 18 01:42:53 2015 UTC,"I don't see how this buys me much.  In this whole workflow I can pretty much s/stack/cabal/, add a couple more simple commands, and it works fine.  But if I use stack I'm locked into stackage.  If these benefits are really that significant why not contribute them to cabal so that every haskeller can reap the benefits without needing to switch their workflow to a brand new tool?"
haskell,3a6p9h,mightybyte,19,Wed Jun 17 18:53:40 2015 UTC,"If I use stack I'm locked into stackage   You're actually not. You're locked into building off of stackage, but you can always select your own versions of everything. You can easily specify any dependency on hackage, or even (new feature) any commit on github and stack will fetch it for you automatically. Stackage just provides a stable and convenient default.   If these benefits are really that significant why not contribute them to cabal so that every haskeller can reap the benefits without needing to switch their workflow to a brand new tool?   I think this is a great question. I attempted to answer it when I gave my talk on stack at bayhac. The short answer is that by making stack a brand new tool, we were able to iterate and add new features much more quickly. We don't have to worry about backwards compatibility with existing cabal workflows. Another tangential reason is that stack doesn't care as much about bootstrapping, so we care less than cabal about having an ultra light set of dependencies. (Particularly talking about TLS here.) We plan to continue developing stack as its own thing, independent of cabal-install. I think that the stack workflow is easy to switch to. If it's not... I'd say file a bug report! Stack's whole raison d'etre is to be easier to use than cabal. If we can eventually find a way to merge these improvements back into cabal, fantastic. But our priority is to get these improved workflows out to the public ASAP, and so that's what we did."
haskell,3a6p9h,Crandom,20,Wed Jun 17 20:15:59 2015 UTC,"The short answer is that by making stack a brand new tool, we were able to iterate and add new features much more quickly.   I think that's a great reason.  That's exactly what happened with cabal-dev and cabal-meta, both of which I used in the past.  But I think the community would benefit more if you took your findings and contributed them back towards improving cabal-install (which is what happened with both of these packages) rather than spending time and energy trying to get people to switch to stack thereby fracturing the community.  In short, stack should be an on-ramp to cabal-install, not a completely separate road."
haskell,3a6p9h,jberryman,-7,Wed Jun 17 22:35:21 2015 UTC,"The short answer is that by making stack a brand new tool, we were able to iterate and add new features much more quickly.   Or you just want to have control over haskell ecosystem."
haskell,3a6p9h,_AndrewC_,6,Wed Jun 17 21:25:04 2015 UTC,"we like to have competing libraries, they explore the design space and make each other better  why don't we want to have competing build tools? halcyon, nix, stack, and cabal are each a different take, and who knows which is the best for any one situation?"
haskell,3a6p9h,mightybyte,9,Wed Jun 17 21:38:19 2015 UTC,That works while package authors don't assume that you use one certain tool and break all other tools. For example by not following PVP.
haskell,3a6p9h,mightybyte,2,Wed Jun 17 21:45:32 2015 UTC,"I feel like it should be noted that LTS Haskell relies on semantic versioning. LTS Haskell releases are semantically versioned with a major and minor component. A minor upgrade (e.g. from lts-2.13 to lts-2.14) can only include minor version bumps in the packages, and it is expected that LTS Haskell packages are semantically versioned.  As for PVP proper, packages can both follow PVP and be included in Stackage. However, Stackage does not require PVP adherence, only adherence to semantic versioning and successfully building with the rest of Stackage.   while package authors don't assume that you use one certain tool and break all other tools   Well, let me give another example: ghc-only language pragmas. Authors who use language pragmas unique to GHC are leaving Hugs users in the dust. Should GHC feel bad for having better features? Should people avoid GHC, or cater to Hugs? I don't think so.  It's no secret that stack is trying to be a better cabal-install. I don't think stack should feel bad for allowing authors to care less about strict PVP adherence. I do think authors should feel bad if they are neglecting the legitimate needs of their users.  If you are the user of a given package that doesn't adhere to the PVP, then send them a patch! Offer to keep their dependency constraints up to date. The reason people shirk their PVP responsibility (particularly: upper bounds) is because they find it tedious and burdensome. If someone else is willing to do that work, then the tedium and burden is lifted.  But if you are just throwing on pre-emptive upper bounds that don't provide any benefit to the package today, you might get some pushback, because pre-emptive upper bounds today usually creates an additional work item of bumping up those bounds tomorrow."
haskell,3a6p9h,conklech,6,Wed Jun 17 23:43:26 2015 UTC,"There seems to be an unspoken implication that stack encourages deviation from the PVP, when in fact I believe the opposite to be the case.   The PVP is about more than just semantic versioning.  Specifically, it also requires version bounds on dependencies.  From the document:   This means specifying not only lower bounds, but also upper bounds on every dependency.   The fact of the matter is that stackage advocates have demonstrated a strong pattern of violating this.  Not surprising that they would be experiencing more trouble with dependency hell than the people who are giving the solver adequate information to resolve dependencies properly."
haskell,3a6p9h,beerdude26,0,Thu Jun 18 00:16:34 2015 UTC,"The dependency hell I have experienced has very frequently been due to upper bounds that are unnecessarily strict. I disagree with the PVP on the point of putting upper bounds on every dependency.  Note that on my preceding comment, I made a large edit. (My mistake, I had forgotten that I was editing and not authoring the original comment.)"
haskell,3a6p9h,dalaing,4,Thu Jun 18 00:24:37 2015 UTC,"From your above edits...   But if you are just throwing on pre-emptive upper bounds that don't provide any benefit to the package today.   Yes they do.  They tell you what dependency versions your package has been verified to work with.  The fact that you have experienced dependency hell with too-strict version bounds is not a problem with version bounds, it is a deficiency in our tooling.  And we are constantly working to improve our tooling.  I don't want to debate the PVP here again.  It has been hashed and re-hashed multiple times in the past.  The community has a clear standard, the PVP.  It's rather concerning that FP Complete is promoting tools that are commonly used in lieu of conformance with the community standard.  This alternative approach is based on the assumption that you can synchronize the world.  I do not believe that assumption is scalable."
haskell,3a6p9h,dalaing,1 point,Thu Jun 18 00:45:35 2015 UTC,"They tell you what dependency versions your package has been verified to work with.   They aren't guaranteed to tell you that, but they can tell you that, yes. More often, they tell you what versions the package is expected to work with. And if someone ever hits a case that doesn't work, then the issue is hopefully reported, and then the version bounds are adjusted accordingly.   The community has a clear standard, the PVP.   The community is far from united on this standard.   This alternative approach is based on the assumption that you can synchronize the world.   I disagree. It's based on the reality that a portion of the world is synchronized under the Stackage project. The whole world doesn't have to be synchronized in order to reap the benefits of a part of it being synchronized."
haskell,3a6p9h,theonlycosmonaut,6,Thu Jun 18 01:39:53 2015 UTC,This sounds pretty crazy. The stack authors are not trying to wrest control of the haskell ecosystem - they're merely trying to make a better tool to deal with some of the shortcomings of cabal. You can always keep using cabal if you want to.
haskell,3a6p9h,Crandom,14,Wed Jun 17 21:47:59 2015 UTC,"It's not crazy to think that what FPComplete's doing ( building its parallel ecosystem) is guided in part by business considerations, or to get a little annoyed when they pretend otherwise.   But I agree it's nothing to get worked up about and indeed I think it's great that they've been able to explore these problems from a clean slate."
haskell,3a6p9h,tomejaguar,4,Wed Jun 17 22:16:53 2015 UTC,"Yeah, but the business considerations driving this are that businesses starting out with Haskell shouldn't have to master a clunky, slow and error-prone package installer before Haskell.   Removing big pain points is good for FP Complete's business and good for the rest of us."
haskell,3a6p9h,_AndrewC_,6,Wed Jun 17 22:57:11 2015 UTC,"Removing big pain points is good for FP Complete's business and good for the rest of us.   Not if it encourages behavior that causes problems for the rest of the ecosystem.  And in this case, there's evidence that it does."
haskell,3a6p9h,Oremorj,6,Thu Jun 18 00:00:08 2015 UTC,"there's evidence that [it encourages behavior that causes problems for the rest of the ecosystem]   I do see evidence that stackage has encouraged some people to be lax about upper bounds. I don't see evidence that this causes real problems, nor do I see evidence of other problems."
haskell,3a6p9h,mightybyte,8,Thu Jun 18 00:30:32 2015 UTC,I do see evidence that stackage has encouraged some people to be lax about upper bounds.   That is exactly what I'm talking about.  It has caused problems for me numerous times because it means that dependencies can cause my tested and perfectly functional packages to stop building at any time without warning.
haskell,3a6p9h,mgsloan,2,Thu Jun 18 01:02:34 2015 UTC,I don't follow. Can you give me an example of how lack of upper bounds on someone else's package has caused your package to stop building? Doesn't your package have bounds that prevent this from happening?
haskell,3a6p9h,mightybyte,5,Thu Jun 18 01:13:09 2015 UTC,"Stack is open source. Stackage, and the curation tools behind it, are open source.  We don't want ""control over"" the Haskell ecosystem. We do want to be empowered to make the Haskell ecosystem better, and we weren't getting enough of that when limited to just making PRs on cabal-install."
haskell,3a6p9h,radix,19,Wed Jun 17 22:26:07 2015 UTC,"I think it's a valid concern that FPCo appears to consistently prefer to develop green-field solutions rather than work with existing infrastructure.  I emphasize those words because I personally don't think it's a correct concern, and I suspect that it's an appearance rather than the truth. I find your justification persuasive. But it's proper for the community to question potential NIH syndrome,  especially as regards central infrastructure projects."
haskell,3a6p9h,_AndrewC_,4,Wed Jun 17 22:46:33 2015 UTC,"I think it's a valid concern that FPCo appears to consistently prefer to develop green-field solutions rather than work with existing infrastructure.   Acknowledged.  Skepticism is absolutely welcome. Criticism is absolutely welcome. You don't have to trust FP Complete; take a look at the source! Raise concerns in the issue tracker and on the Commercial Haskell mailing list! Make your own fork and do it better, or build the same features into cabal!  I personally think that the project stands well on its own merit. Anyone with concerns: take a closer look, ask questions, let's hash it out. We've got nothing to hide."
haskell,3a6p9h,radix,2,Thu Jun 18 00:41:26 2015 UTC,"I don't think the NIH argument can really fly here. The community has identified the numerous issues that plague cabal. Some looked at nix for solutions, others wrote backpack. When viewed that way, FPCo's stack is the most idiomatic approach of them all, just providing a wrapper around cabal and co."
haskell,3a6p9h,_AndrewC_,5,Thu Jun 18 21:16:34 2015 UTC,"We do want to be empowered to make the Haskell ecosystem better, and we weren't getting enough of that when limited to just making PRs on cabal-install.   Is that an assumption, or something that was tested?  And if it was tested, was it through some kind of private communications?  The only agitation for sizeable change I've seen in the PRs and cabal-dev list in the last year was for SSL support.  That seemed to work out alright, Michael played a valuable part in that, and there's a PR up for it now.  It's possible-to-probably that I missed something there.  I'm wondering about how much empowerment is seen as ""enough"", and if / when it was denied, or whether it was an assumption / perception / vibe.    Mostly because that might be useful info for the cabal folks - with 0 full-time devs, I'm struggling to think of scenarios where they'd reject offered help out of hand - there might be the will to alter the process (or the vibe) to make contributions easier to make, etc...  I can see the benefits of having two sets of tools iterating at different speeds / under different requirements.  It would be nice if there was a path towards reconciling some of those differences.    I don't know if having a discussion about that would reduce concerns about the fragmentation or stir things up further.  I'd just like to understand the background a bit more.  Edit: now that I think back a little, I can imagine the way things fell out with the SSL work might have been the catalyst - IIRC there were two pretty solid-but-conflicting sets of requirements in play with that."
haskell,3a6p9h,Oremorj,3,Thu Jun 18 00:46:54 2015 UTC,"We do want to be empowered to make the Haskell ecosystem better, and we weren't getting enough of that when limited to just making PRs on cabal-install.   Is that an assumption, or something that was tested?   I don't want to put words in /u/snoyberg's mouth, but this is the gist of what I understood from what he's told me about his interaction with the cabal project. I'll leave it to him to confirm/deny/elucidate.   I don't know if having a discussion about [reconciling stack and cabal-install] would reduce concerns about the fragmentation or stir things up further.   I think it is definitely a discussion that should be happening."
haskell,3a6p9h,_AndrewC_,2,Thu Jun 18 01:23:17 2015 UTC,"Even without getting into details, I tend to think people putting more energy into the system is usually a good thing.    If people use and like stack, that's a win. If steps are made to help more people work on cabal-install and other infrastructure (or if people take the time to re-check that the current process is for the best), that's a win.  I'm a little tickled that in that shooting for a super-set of cabal-install you've also managed to tick the boxes for   a-more-than-likely thankless maintenance burden for lots of users complaints"
haskell,3a6p9h,mgsloan,2,Thu Jun 18 04:55:10 2015 UTC,Does cabal-install not want the same? What's the problem here?
haskell,3a6p9h,created_to_post_this,11,Wed Jun 17 21:47:04 2015 UTC,"I don't see how this buys me much.  In this whole workflow I can pretty much s/stack/cabal/, add a couple more simple commands, and it works fine.   These other simple commands are undiscoverable to newbs :( Off the top of my head, they have to remember to:   (install ghc and put on path)  (install cabal and put on path) cabal update cabal sandbox init cabal install --only-dependencies  cabal configure --enable-tests cabal test   Compared to:   (install stack and put on path)  stack test    If they forget to sandbox, they'll probably mess up their user package db when they install something else. The --only-dependencies flag is magic that took me ages to discover. Why should I need to cabal configure and enable tests at all when cabal test should handle that? By this point the new haskeller has given up. I see it all the time as I introduce people to haskell - they almost always quit because of cabal.    But if I use stack I'm locked into stackage.   This is great for the newbie, they packages will always install and work together. You can build packages outside Stackage using extra-deps.    If these benefits are really that significant why not contribute them to cabal   Cabal's UI is hopelessly convoluted. We could change it to something simpler but it would break backwards compatibility. The cabal codebase is also big and scary, having stack as a new thing helps speed up development and gives the stack authors more control over what they want the end state of stack to look like.    so that every haskeller can reap the benefits without needing to switch their workflow to a brand new tool?   Everyone can reap the benefits by downloading it now. Work flow switching is quite easy, you just install stack and write a 5 line stack.yaml, reusing your current cabal projects."
haskell,3a6p9h,hagda,4,Wed Jun 17 21:43:58 2015 UTC,We could change it to something simpler but it would break backwards compatibility.   It doesn't have to change backwards compatibility.  Just make new binary called cabal-new or cartel or something.
haskell,3a6p9h,created_to_post_this,2,Thu Jun 18 06:25:22 2015 UTC,Or stack? ;)
haskell,3a6p9h,hagda,1 point,Thu Jun 18 15:37:43 2015 UTC,"It must be called ""illuminati""."
haskell,3a6p9h,mightybyte,1 point,Fri Jun 19 17:42:57 2015 UTC,"These other simple commands are undiscoverable to newbs   As I mentioned above this is not entirely true.  Most newcomers I talk to already have sandboxes set up.   This is great for the newbie, they packages will always install and work together.   This is not true.  My problem with curation post provided a concrete example of this.  Curation/stackage/stack/et al are not a panacea.   Cabal's UI is hopelessly convoluted. We could change it to something simpler but it would break backwards compatibility.   It seems quite plausible to me that ""cabal test"" could be changed to something that also does a cabal install if necessary.  If not, then we can certainly create another command, ""cabal go"" for instance.   Everyone can reap the benefits by downloading it now.   Not true.  Many of us are working on the next versions of the libraries that will go into the next stackage release.  You can't use stackage in this case."
haskell,3a6p9h,acow,9,Wed Jun 17 22:47:03 2015 UTC,"Most newcomers I talk to already have sandboxes set up.   And how many ""cabal hell"" experiences did they go through to get to that point?   Not true. Many of us are working on the next versions of the libraries that will go into the next stackage release. You can't use stackage in this case.   Not true ;).  You can use a newer version of a package by adding it to the extra-deps section of the stack config."
haskell,3a6p9h,mightybyte,2,Wed Jun 17 22:59:03 2015 UTC,"You can use a newer version of a package by adding it to the extra-deps section of the stack config.   It's not that simple.  Doing that can result in its own form of dependency hell because the new package can force you onto different versions of packages than the ones on stackage.  (This is exactly what happened in the case that prompted my problem with curation post.)  How are you going to find those?  Ok, you spent some time and found those.  Then you add one more package.  Same problem happens again, but this time it's less obvious due to the way these two new packages depend on each other.  This is dependency resolution and it's a hard problem.  To my knowledge stackage doesn't solve this problem.  cabal-install combined with disciplined use of dependency bounds does."
haskell,3a6p9h,Crandom,5,Wed Jun 17 23:54:16 2015 UTC,"the new package can force you onto different versions of packages than the ones on stackage... How are you going to find those?   stack should simply report them to you. It will spit out an error and suggest that you add those packages to your extra-deps. Usually you can just copy/paste the suggested extra-deps into your stack.yaml and be on your merry way.  Here's an example using the lambdabot repo.  I also tried to make another example for you here, but that led me to find a bug. But this is definitely something that stack is designed to handle with ease.  I agree that dependency resolution is a hard problem, but I believe stack solves it well (with plans for improvement to do even better). Obviously, when packages provide meaningful and accurate dependency bounds, any dependency resolution tool can benefit from this information."
haskell,3a6p9h,mightybyte,2,Thu Jun 18 01:58:44 2015 UTC,"Personally I have found that using Stackage (nightlies) has been really nice. But has there been any consideration of maybe adding a hackage resolver that just directly uses Hackage? I realize that it may not be considered best practice, but it could perhaps quell a lot of the anxiety people have about ""relying on FP Complete"". And I could see myself using it as a CI job (parallel to my normal jobs using stackage) to give me advance warning of any incompatibilities with the cutting edge in the ecosystem.  Another thing I can imagine would help is to officially move management of Stackage under the umbrella of a community organization such as the Commercial Haskell group. I know Stackage is open source[1], but the ""management"" is another thing.  [1] Actually, is it really all open source? Even boring deployment automation and stuff?"
haskell,3a6p9h,hagda,2,Thu Jun 18 03:31:52 2015 UTC,"just directly uses Hackage?    I think you'll find that the bleeding edge of hackage is not consistently co-compilable, whereas stackage is.   Paragraph edited for tone (apologies): I'm not at all convinced that taking stack out of the hands of FP Complete is a good idea, since they've made so much progress, when cabal didn't.   I'm no Thatcherite, but I don't like all the commercial = evil assumption that's going on around FP Complete. (Not you particularly.) It seems some folk would have been happier if they'd kept all this tooling available only to paid customers and closed-source."
haskell,3a6p9h,Crandom,2,Thu Jun 18 15:57:29 2015 UTC,"I think you'll find that the bleeding edge of hackage is not consistently co-compilable, whereas stackage is.   I already know this. But apparently a decent number of people still want to use it as their main source of dependencies, and it seems like maybe that's a use case that could be supported without too much trouble? I don't think it should be the default, but if people really think they have a good reason to use it, it seems reasonable to allow them to.   You want to take stack   Maybe this was a typo, and you meant ""Stackage"", but if you really meant ""Stack"" then I think your understanding of the situation is not up-to-date. Stack is the successor to stackage-cli, which was an FPCo-""owned"" project which was given to the care of the Commercial Haskell group. The Stack project has a number of maintainers (with commit rights and everything) from all over the Haskell community, even me! (against good sense, I think ;-)  For what it's worth, the second part of my post was about putting Stackage under the umbrella of the Commercial Haskell group, not Stack -- which already is!   out of the hands of a company   (going back to assuming we're talking about Stackage, not Stack) This sounds like an assumption that somehow moving Stackage under the official care of Commercial Haskell would prevent the current developers from continuing to contribute to it. Given that Stack has gone through exactly this transition, I think we have very good evidence that other projects (Stackage) could make the same transition.  I love FPCo. I don't think they've done anything wrong at all, and I think they have consistently kept the best interests of the larger Haskell community in their hearts. The thing that pains me is that there are people who do get scared of the mythical ""lock-in"" of Stackage. I am not very convinced by most of their concerns, but I also do think that long-term, community resources like Stackage (especially if it becomes the de facto source of Haskell code) should have community oversight. I very much doubt that such a transition would prevent FPCo from putting their resources into it just as efficiently as now."
haskell,3a6p9h,beerdude26,1 point,Fri Jun 19 03:24:14 2015 UTC,"You make some good points, and thanks for explaining stuff I was clearly unaware of.  (I've edited one of my paragraphs for tone -  I had been getting exasperated with all the anti-stackage talk, but that's no excuse for sarcasm, so I've made that more polite. Sorry for the original tone.)   I worry a lot that the key benefit of stackage, mutual compatibility, is absent from the wildest west of hackage,  and that adding a back door to the cliff-top path is perhaps a mistake in a tool designed to avoid cliffs.   Surely if you want hackage direct and you know what you're doing, there's no reason you can't use cabal to get at it directly. (As folk have pointed out, stack also allows you to use packages from outside the curated set.)"
haskell,3a6p9h,gsscoder,2,Fri Jun 19 06:45:09 2015 UTC,"I'm no Thatcherite, but I don't like all the commercial = evil assumption that's going on around FP Complete   For me, personally, it's not about that at all. It's that they seem to be splitting off into their own ecosystem and ways of doing things... and aggressively encouraging everyone into their ecosystem -- and that will be a huge problem down the road, I think. Given that they've generously(!) open-sourced all of this stuff I just wish that they could work better together with the Cabal/Hackage folks on actually moving some of this stuff into the ""standard"" tools. I'm sure they have their reasons and that it's not necessarily FP Complete's fault that there's this lack of coordination/agreement, but it makes me worry about the almost inevitable ecosystem split.  EDIT: Compare this with e.g. ""npm"" which is the de-facto package manager for node.js and what a huge boon having a single package manager for everything has been for the (node) js community. Granted, the package manager has to work well enough, but if I were kind I'd want everyone working on improving the pre-existing tools where they can fulfill this role.  EDIT#2: Incidentally, we see the results of a similar fragmentation with all the different IDE-support packages, ide-backend/ghc-mod/build-wrapper/etc. and the result is that there's currently no really realiable/good way to have IDE-like functionality for every editor out there -- which we probably should have at this point."
haskell,3a6p9h,hagda,1 point,Fri Jun 19 17:47:00 2015 UTC,"Some FP Complete folks made suggestions for changes to cabal, e.g. storage on S3 to reduce downtime, some security improvements and others, but were told no, no and no. Under those circumstances they've just rolled their own. I might be wrong, but my impression from reading the conversations on those issues is that it's not FP Complete's fault at all, and that they got spurned by the cabal folks on a number of occasions.  I think ""aggressively encouraging everyone into their ecosystem"" is a different thing from blogging about their new, nicer, easier, ready-made solution to which package versions to use and how to install them. You might find that their ardent supporters are just folk fed up with cabal and delighted with the new tooling that removes the pain; folk tend to get evangelistic when they discover things that are dramatically better than what they had before."
haskell,3a6p9h,hagda,1 point,Sat Jun 20 09:23:07 2015 UTC,"Adding to Dan's response:  I quite like having an explicit list of extra dependencies.  Sometimes cabal's constraint based dependency resolution doesn't work out so well, and it picks an archaic version of a package.  By having a list of extra dependencies, you get to explicitly ask for this if you really want it.  Instead of being at the whim of cabal's relatively opaque solver, you get to be in the driver's seat."
haskell,3a6p9h,PM_ME_UR_OBSIDIAN,3,Thu Jun 18 08:45:37 2015 UTC,"When I was new I almost gave up because of cabal problems. This was within the last year. In the end it became a positive because I learned a lot about Docker in order to create isolated, repeatable Haskell environments just to get going. All of these use stackage, by the way.  I really appreciate the work that goes in to creating cabal and the like. That work makes all of our work and play possible. But I have to disagree with the idea that things like stackage and stack are counter-productive or unnecessary (which I take to be your position here, please correct if I'm overstating). For me as a now intermediate Haskeller they were utterly essential. Without them I'd have given up on what is now my favourite language (sorry Python, I still love you lots)."
haskell,3a6p9h,reaganveg,5,Thu Jun 18 14:51:46 2015 UTC,"In the end it became a positive because I learned a lot about Docker in order to create isolated, repeatable Haskell environments just to get going. All of these use stackage, by the way.   IMO, docker, cabal sandboxes, stackage and all that are mostly kludges to workaround some more fundamental issues with Cabal (which are being worked on from what I've seen at Zurihac, but I can understand that the Stackage-camp may be threatened if those ambitious projects would ever come to fruition). These kludges are useful to some degree, but we shouldn't settle for them, but rather improve Cabal to get to the point where they aren't essential to avoid ""cabal hell"", but are used for what they are really meant to be used (e.g. CI systems, deployment containers, etc). So I guess enjoy Stackage while the really cool tooling to come is still vaporware, but be prepared to abandon Stackage at some point..."
haskell,3a6p9h,drwebb,2,Thu Jun 18 16:21:27 2015 UTC,"I agree. My essential point was that I agree with the OP that, when one doesn't need to really think about tooling, onboarding new developers becomes much less frustrating and thus more likely to happen."
haskell,3a6p9h,rvion,2,Fri Jun 19 08:47:47 2015 UTC,"Yeah... and I really hope that at some point the out-of-the-box experience of GHC+cabal (maybe even when the Haskell Platform is installed) will provide that kind of experience, w/o having to resort to 3rd party tooling such as stack pursuing a different path while experimenting in the design space (which in its own right  may provide  valuable input for how to improve  Haskell's proper standard tooling)."
haskell,3a6p9h,cameleon,2,Fri Jun 19 08:55:33 2015 UTC,"I really appreciate the work that goes in to creating these tools, which makes all of our work and play possible, but I have to disagree with the idea that things like stackage and stack are counter-productive or unnecessary (which I take to be your position here, please correct if I'm overstating).   I think these things have value and can be productive in the short term.  I think they are counter-productive in the big picture as they are currently being marketed and if they fragment the community by not merging back into the main community tools in the future."
haskell,3a6p9h,vincentrevelations,10,Thu Jun 18 15:43:18 2015 UTC,"For what it's worth, speaking as someone who is willing to make their own everything and has problems getting patches accepted into GHC, haskell-mode, other tooling things, etc., I'm really happy with what FPCo is doing with stack.  I think you're totally right about stackage having a negative impact regarding version bounds, and that the curation model is ultimately limited. However, I've found FPCo to be much more open than any other group associated with Haskell, and, seeing the resistance to change elsewhere in the community (eg. hackage on git, S3 for package hosting, addressing on-boarding documentation when the Platform fell behind, adopting sandboxes to address cabal hell), this kind of green field approach is exactly what is needed.  My hope is that I can actually have an impact on these new infrastructure developments to address my concerns about how stackage fits into things. I don't think this is a long-term fracturing of the ecosystem, but a necessary parallel evolution to get out of the quagmire."
haskell,3a6p9h,cdep_illabout,10,Thu Jun 18 01:50:44 2015 UTC,"add a couple more simple commands   This is a small barrier to entry. If a potential contributor hits a speed bump on this part, they are that much less likely to continue towards attempting to contribute. Dealing with sandboxes is not always simple, especially the ""test all four packages based on changes to this one"" part."
haskell,3a6p9h,cdep_illabout,3,Wed Jun 17 19:25:45 2015 UTC,"Dealing with sandboxes is not always simple, especially the ""test all four packages based on changes to this one"" part.   Most of the newcomers that I have recently helped with build issues were already using sandboxes.  So anecdotally speaking your point 1 ""create a sandbox"" doesn't seem to be an issue--at least for the people that I've worked with.  Install dependencies is just a simple ""cabal install"", so I don't think that's a big deal either.  The --only-dependencies flag is just a small optimization.  So that leaves us with this multi-repo pattern being the main thing that stack brings to the table.  I don't know what percentage of hackage packages are multi-repo, but from what I've seen it's probably a minority."
haskell,3a6p9h,Crandom,2,Wed Jun 17 22:00:48 2015 UTC,"This is the opposite of my experience - new people have no idea they should use sandboxes and accidentally install in the global package db, which doesn't end well (""cabal hell""!)."
haskell,3a6p9h,cdep_illabout,6,Wed Jun 17 22:06:41 2015 UTC,"Not using sandboxes does not automatically end in cabal hell.  Most of the time things build fine for me.  It only ends in cabal hell if you install one thing then install something else that needs different dependencies than those already installed, or if you are installing things that don't have proper PVP-compliant upper bounds."
haskell,3a78zh,ahar0n,11,Wed Jun 17 19:51:02 2015 UTC,"Haskell is not strongly normalizing, as it allows general recursion, which lets you define non-terminating functions, i.e. f x = f x.  But the Y-Combinator, as you've presented it here, has still no type in Haskell. Inside your outer lambda, you have an application g a, where both g and a are (\x -> f(x x)). The typing rule for function application concludes g a :: t0 from the premises g :: t1 -> t0 and a :: t1, so it has to give (\x -> f(x x)) two different types, which induces the error message you have mentioned.  Here's a Haskell implementation I found in a stackoverflow answer a while ago:  newtype Mu a = Mu (Mu a -> a)  \f -> (\h -> h $ Mu h) (\x -> f . (\(Mu g) -> g) x $ x)   where f :: a -> a and the sub expressions of the function application have types  (\h -> h $ Mu h)                 :: (Mu a -> a) -> a (\x -> f . (\(Mu g) -> g) x $ x) :: (Mu a -> a)   Apart from the newtype wrapping, both expressions still embody the concept of the original (\x -> f(x x)).  The Mu type constructor here takes the least fixed point of the type constructor (-> a). It is the type-level version of the fix operator specialized to the function type constructor. I found this tutorial introducing the general concept. Often the name Mu or Fix is used for the general version of the Mu shown here.  edit: I think the implementation mentioned by /u/jozefg is nicer than the one I found on stackoverflow. It uses the general typelevel fixpoint construction and more closely resembles the original Y-Combinator modulo newtype wrapping."
haskell,3a78zh,m0rphism,10,Wed Jun 17 20:08:39 2015 UTC,I have a blog post about this chock full of pretentious words over here.  If you just want the code  newtype Mu f = Mu {unMu :: f (Mu f)} unfold = unMu fold   = Mu  newtype X' b a = {unX :: a -> b} type X a = Mu (X' a)  unfold' = unX  . unfold fold'   = fold . X' y f = (\x -> f (unfold' x x)) $ fold' (\x -> f (unfold' x x))   The basic idea is that you use type recursion to infect our term language with recursion. This is how it works in the lambda calculus which is built around the single recursive type D = D -> D. With recursive types like this we can apply a term to itself and with self application we can actually get recursion.
haskell,3a78zh,jozefg,1 point,Wed Jun 17 20:53:52 2015 UTC,"Nice, thank you!"
haskell,3a78zh,tomejaguar,1 point,Wed Jun 17 21:18:36 2015 UTC,You have  X a Mu (X' a) Mu X' -> a (Mu X' -> a) -> a ...   I think the last two Mu X' should be Mu (X' a).
haskell,3a78zh,lpeterse,5,Thu Jun 18 09:37:06 2015 UTC,What about this one (it's in Data.Function)?  fix :: (a -> a) -> a fix f = let x = f x in x
haskell,3a78zh,jozefg,3,Wed Jun 17 19:56:26 2015 UTC,Because it uses the term recursion baked into Haskell instead of falling out type recursion like the lambda calculus.
haskell,3a5k0x,lpeterse,8,Wed Jun 17 11:59:40 2015 UTC,"I'd appreciate some feedback on whether this approach goes totally into the wrong direction or is actually a useful improvement.  I'm referring to this thread for some background information:  https://www.reddit.com/r/haskell/comments/2o5558/is_network_library_poorly_implemented_or_am_i/  I while ago I wanted to play around with SCTP in Haskell and found it was not so easy to do with the existing network library in Haskell. The deeper I dug into the topic the more I felt the library suffers from some design issues that cannot easily be overcome without breaking the API and putting all existing applications depending on it at jeopardy. You might want to the check the library's issue tracker and the linked discussion for details.  I came to the conclusion that I could do a fresh and well-designed rewrite and have it coexist with the network library even within one application. If the rewrite turns out to be an improvement people could smoothly port their libraries to use the new library without the need to port everything at once.  Here is (a non-exhaustive) list of things I believe to have improved:   No autotools required (this is especially problematic on Windows). The Haskell Platform that brings MinGW is just enough. Everything that ships with this (core) library should be supported on every platform (i.e. the Unix sockets will live in a still-to-develop socket-unix package). No conditional exports or platform specific behaviour. The socket library is interruptible even on the non-threaded Windows runtime (this is a little hacky at the moment, but it's at least correct and does not require tons of #ifdefs in the Haskell code). No duck-typing addresses anymore: network's SockAddr type is a finite enumeration. It has been expanded with SockAddrCan recently, but these kind of changes break old code or at least trigger non-exhaustive pattern match warnings. The socket library uses type families to solve this. The network library keeps track of the socket's state. This is problematic as there are sockets that can be connected more than once and also introduces a source of possible inconsistency with the real socket state. The socket library just tries and throws exceptions when if something went wrong. Clean and simple. Socket Options: Not all socket options are integers and the set of socket options is not finite as the network library suggests by using an enum for this. The socket library uses two type classes for this and new options (in external packages) may be added easily. Exception handling: The socket library throws SocketExceptions. They can be distinguished from other IOErrors and their meaning should be reliable independant of the platform."
haskell,3a5k0x,semanticistZombie,4,Wed Jun 17 11:59:58 2015 UTC,"I haven't looked at it in details, but as the author of the linked post, big kudos for this :)"
haskell,3a5k0x,hastor,3,Wed Jun 17 14:48:54 2015 UTC,Everything that ships with this (core) library should be supported on every platform   Could I ask for SO_REUSEPORT so we can get cheap/performant load-balancing on Linux?
haskell,3a5k0x,imz,2,Wed Jun 17 22:31:03 2015 UTC,SO_REUSEPORT is one of these non standard extension with limited portability. It was introduced with Linux 3.9 and I'm unaware about other platforms. At least Windows does not support it. Are there more things like this that justify a socket-linux package? I'm also open for other suggestions.
haskell,3a5k0x,imz,2,Thu Jun 18 06:33:14 2015 UTC,"Are non-exhaustive pattern match warnings really a bad thing? Since I don't see the examples of the code in the old style and in your new style, I can't of course understand the issue well.  But I'd consider it as an indicator that there are new things in the library, and the application code might need a re-work.  (I've just been adding a new thing (a new data type option) into a program of mine(not network-related), and had a thought that it's bad that I have used default rules in function definitions (like a last f _ = a default value) to save typing. Because: when the new thing was added, I might need to re-work the logic of some of theses functions; the logict might become broken because the case with the new thing must be treated, but unfortunately I don't get the noin-exhaustive pattern-matches warnings. I wish I had them. Now I have decided to avoid default rules, and to try to write out all the values of an enum explicitly, to make the logic of my code more safe w.r.t. future changes.)"
haskell,3a5k0x,imz,5,Wed Jun 17 12:23:55 2015 UTC,"I agree that this problem vanishes when you use a default rule. Still, a default rule yields another warning if you matched all patterns:  main :: IO () main =   case True of     True  -> return ()     False -> return ()     _     -> return ()    [1 of 1] Compiling Main             ( Test.hs, Test.o ) Test.hs:5:3: Warning:    Pattern match(es) are overlapped    In a case alternative: _ -> ...   I consider it good style to have all functions total (if possible) and to try to eliminate all warnings when writing code. Otherwise warnings loose their potential to warn you about programming errors."
haskell,3a5k0x,jimenezrick,3,Wed Jun 17 12:41:12 2015 UTC,"I'm afraid I wasn't clear enough in my comment.   Warnings are good. If a new thing appears in the library, then there should be non-exhaustive patterns warnings in the programs that use the library. The author of the program then can revisit this place and check that the logic is not broken with the new case (add a new case). Default rules are bad. They hide the places where the logic might be broken after a library update.   So, the essence of my comment was:  I'd consider avoiding warnings on library updates an ""anti-goal"". (And I'd recommend to program authors NOT to use default rules -- in order to get MORE warnings on library updates. Here you seem to have misunderstood me. I'm not suggesting default rules as a solution.)"
haskell,3a5k0x,bos,2,Wed Jun 17 12:58:47 2015 UTC,"Ok, now I got the subtile difference: on library updates. You're right. Nothing more to add."
haskell,3a5k0x,sccrstud92,2,Wed Jun 17 13:04:17 2015 UTC,"And now I seem to get what you meant. You probably meant that the users of the old library got warnings even without library updates, right?  That was not clear to me. Perhaps, it could be more clear if there was an example of this ""duck typing"" approach of the old library, which made it hard to use the library without getting warnings."
haskell,3a5k0x,bos,4,Wed Jun 17 13:12:05 2015 UTC,"I meant that it might be possible that someone A matched on SockAddrInet, SockAddrInet6 and SockAddrUnix. Now SockAddrCan was added. The CAN-bus is something only rarely used. It seems odd that A now needs to adapt his library to get rid of this warning again.  By duck-typing I meant that usually you decide for an address family (i.e. INET) and than stick with it. Even when splitting of new sockets with accept the address family doesn't change. In the network library you always check at runtime what kind of socket/address you just got and dispatch on the different constructors of SockAddr."
haskell,3a5k0x,ignorantone,4,Wed Jun 17 13:21:49 2015 UTC,To put it in relation: The issue with the warnings is really not that dramatic after all and just an additional observation. The main issue is IMHO that you cannot extend the network library with external packages.
haskell,3a5k0x,ibotty,8,Wed Jun 17 13:32:03 2015 UTC,"I think I will give it a try, I'm always in favour of sane and clean libraries aiming for better code quality and maintainability in the long term :)  And yeah, let's rip off the #ifdef madness, we can't accept to have a nice language such as Haskell and to have many libraries written like in the 80s... with preprocessor crap..."
haskell,3a5k0x,sambocyn,5,Wed Jun 17 14:14:30 2015 UTC,Credits to Yuras Shumovich for this excellent blog post: http://blog.haskell-exists.com/yuras/posts/stop-abusing-cpp-in-haskell.html
haskell,3a5k0x,joeyadams,6,Wed Jun 17 14:30:47 2015 UTC,"Why is the API SOMETIMES SHOUTING and Other Times Using Caps, while at stILL othER tiMES using a bizARRE MIX?"
haskell,3a5k0x,emarshall85,3,Wed Jun 17 17:29:54 2015 UTC,"Good point. Honestly, there is no good reason for this. I was torn between ""make people recognize the c constants"" and ""darn, constants in Haskell can't start with an upper case letter"". The final outcome looks bizarre, right.  I think it's a good idea to get this straight before people actually start depending on the library. Proposal:  inaddrUNSPEC_GROUP -> inAddrUnspecGroup (others according) msgNOSIGNAL            -> msgNoSignal (etc) aiADDRCONFIG           -> aiAddrConfig (etc) niNAMEREQD              -> niNameReqd (etc)   Im unsure whether it should be SEQPACKET and INET or SeqPacket and Inet. What to do with something like IPV6_V6ONLY?"
haskell,3a5k0x,emarshall85,5,Wed Jun 17 18:09:57 2015 UTC,"I think if you make everything look haskell-y in the same way, then even people with knowledge of the C constants can just that knowledge if the mapping you choose is consistent. Plus I think what you proposed just makes everything look nicer."
haskell,3a5k0x,rdfox,5,Wed Jun 17 18:16:26 2015 UTC,"I understand the desire to make things look C-like, but honestly there's no advantage to it – and let's face it, we're not writing C :-)  I would even go further and suggest that the naming could be further cleaned up in some cases. For instance, the purpose of the NI_ prefix in NI_NAMEREQD in C is due to its total lack of a module system and the longstanding tradition of vrshrtnms (very short names).  In Haskell, you could reasonably maybe-drop the prefix and expand the name to NameRequired. You might still need the prefix because our name scoping is sadly not really all that much better than C's."
haskell,3a5k0x,acow,2,Wed Jun 17 20:13:56 2015 UTC,Here is a gist elaborating my previous proposal. Everyone is invited to edit it. Several points are still unclear. When concensus is reached I'll change the library accordingly and make it version 0.5.0.0.
haskell,3a5k0x,eacameron,3,Thu Jun 18 08:09:22 2015 UTC,"+1 for more Haskelly names. Predictability is important. A bizarre mix of capitalization is no good.   SeqPacket  Inet   Yes to these.   What to do with something like IPV6_V6ONLY?   I think /u/bos has a good point here. We're not writing C. Consider dropping the IPV6 prefix on all of these socket options constants, as well as any other prefix-y constants. The prefix is there so that C programmers know these constants are all related. In Haskell we have sum types; we don't need the prefix.  IPV6_V6ONLY -> V6Only    Maybe even consider eliminating boolean blindness from this particular boolean flag.  I suggest adding a link to the source for the meaning of the C flags, i.e. a webpage. Then the user has a guide if they're not sure what a constant means."
haskell,3a6118,Kiuhnm,12,Wed Jun 17 14:37:24 2015 UTC,"The first piece of advice I give to anyone I meet who's interested learning about/implementing compilers (of any kind) is to write the parser last.  Parsing is a rich, and for some extremely satisfying) subject, but it's probably the least important part of a compiler.  It's also where almost every treatment of compilers starts.  But it's a trap!  You'll want to change your concrete syntax as you gain a better understanding what you're doing.  You'll find that you'll need to experiment with a bunch of different ways of representing your abstract syntax.  You'll realize that such-and-such clever trick would make everything so much cleaner, and then say ""oh, but my parser is so beautiful!  and it took days to handle that nasty shift-reduce conflict..."" and then you'll be sad because you have to mangle your hard-won parser or keep it and have a dirtier rest-of-your-compiler.  Also, concrete syntax design is actually pretty hard.  It's a rat hole that keeps lots of people from ever getting to ""the good parts"" of the compiler.  When you can't possibly get any farther without concrete syntax (perhaps because you need to start writing tests of larger programs, and coding in the AST becomes too painful), use S-Expressions.  Aside from being perfectly sufficient concrete syntax in their own right, they're well supported in lots of places.  Emacs already has great support (on its own, but especially with paredit); and since all those ruby folks got into clojure, I'm pretty sure there's plenty of great Sexp to be had if you swing that way.  (I haven't done much lisp in Vim---emergency edits to my .emacs notwithstanding---so I can't say much from personal experience there).  Speaking of S-Expressions, some great background reading on functional language implementation (though eager, impure, and untyped) is http://haskell.cs.yale.edu/wp-content/uploads/2011/03/CompByTrans-POPL89.pdf, and possibly http://www.cs.purdue.edu/homes/suresh/590s-Fall2002/papers/Orbit.pdf (I don't think this latter was available last time I was looking at this work, so I haven't read it yet).  Good Luck!"
haskell,3a6118,deviant-logic,3,Wed Jun 17 16:30:01 2015 UTC,"This advice can also be terrible depending on who's doing it. It's a lot easier to stay on track with goals if you're implementing some parsing and have things to show for it, and paralysis analysis can be a major problem if you don't lock down some syntax."
haskell,3a6118,Umbrall,2,Wed Jun 17 22:20:58 2015 UTC,"I hear what you're saying, and I probably could have been more moderate in expressing this.  That being said, if you have a type checker or some static analysis written on your AST, I wouldn't call that nothing to show."
haskell,3a6118,deviant-logic,1 point,Thu Jun 18 04:08:37 2015 UTC,"is there a compromise? like using a chart parser, slower than happy but easy to write (can handle left recursion). then one might rewrite the parade at the end."
haskell,3a6118,sambocyn,2,Thu Jun 18 21:48:35 2015 UTC,"Honestly this is just about what works for you. I think you're fine using it, and if you have to rewrite at the end that's fine, but I'd prefer having things not be so tenuous without a parser."
haskell,3a6118,Umbrall,1 point,Thu Jun 18 21:53:54 2015 UTC,Thanks for the advice!
haskell,3a6118,kjandersen,11,Wed Jun 17 21:58:29 2015 UTC,"I found the first few chapters of SPJs 'The Implementation of Functional Languages' a very easily followable read. If the rest delivers on the promise in the title, I think it should fit what you are looking for :)  http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/"
haskell,3a6118,aseipp,3,Wed Jun 17 15:31:05 2015 UTC,"IMO, this is the best book to start if you have a bit of familiarity. It's slightly dated, but excellent introductory material and very comprehensive from start to finish.  I still have the pristine physical copy I got from school around here. One of these days I'll get Simon to autograph it. Or maybe he could just write a more up to date book instead :)"
haskell,3a6118,neilthecoder,2,Wed Jun 17 16:28:03 2015 UTC,"I was looking for something more recent, but it's a starting point. Thank you!"
haskell,3a6118,fuklief,1 point,Wed Jun 17 16:32:02 2015 UTC,"There's a slightly newer version called ""Implementing Functional Languages""."
haskell,3a6118,fuklief,8,Fri Jun 19 03:52:15 2015 UTC,"Write you a Haskell: http://dev.stephendiehl.com/fun/  Not sure if he is still working on it though, doesn't seem to have been updated in a while."
haskell,3a6118,guaraqe,5,Wed Jun 17 15:16:11 2015 UTC,"https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html  Designing Dependently-Typed Programming Languages — Stephanie Weirich might also be of interest, it may be somewhat too advanced though"
haskell,3a6118,merijnv,1 point,Wed Jun 17 15:19:27 2015 UTC,"All the lectures on that page seem very interesting but, as you said, quite advanced."
haskell,3a6118,gilmi,1 point,Wed Jun 17 16:10:03 2015 UTC,This looks very interesting!
haskell,3a6118,gilmi,2,Wed Jun 17 15:32:51 2015 UTC,Take a look at Andrej Bauer's Programming Language Zoo: http://andrej.com/plzoo/
haskell,3a6118,b00thead,2,Wed Jun 17 14:53:17 2015 UTC,This may be useful later. First I need to learn the theory.
haskell,3a5c0e,Distort3d,7,Wed Jun 17 10:15:48 2015 UTC,"This isn't your worst problem.  When I worked on packaging Haskell for Gentoo we had special support for GHC on machines with less than 512mb. You need a special build of GHC that does not use ""split objects"" for its .a files (think libHSbase-4.8.a), otherwise just linking your program will cause ld to take too much memory and invoke the OOM killer.  As others have said, if you're building for a cheap VPS or similar, the better approach is to build on a more powerful machine and just deploy the final binary to the target machine.  cabal configure --prefix=${where-you-want-it} cabal build cabal copy --destdir=./image   Now tar/zip up the image dir and deploy that to the prefix location on the target machine. (If you're using any libs that use data files you would need to do the above for those too, using the same image dir.)"
haskell,3a5c0e,dcoutts,1 point,Wed Jun 17 14:29:10 2015 UTC,"Ok, thank you, i guess i have no other choice."
haskell,3a5c0e,myetech,7,Wed Jun 17 15:52:50 2015 UTC,"You can automate this with Halcyon.  You’ll still need a build machine with at least 1GB RAM, and the same architecture/OS as your target machine.  Note I’ve had build failures on Fedora machines with 4GB, so I recommend 8GB.  My preferred approach is — spawn a temporary EC2 instance (or a DigitalOcean droplet, or a Linode… linode), and build the project there using Halcyon.  As long as you’ve set up private storage, Halcyon will automatically upload the build products to it.  Once that’s done, you can kill the build machine, paying only for a couple of minutes of high-RAM usage, and use Halcyon to deploy on your target machine.  Follow the Halcyon tutorial to get started, or check out thoughbot’s “Building Haskell projects with Halcyon” for a well-written introduction."
haskell,3a5c0e,kyllo,5,Wed Jun 17 21:24:36 2015 UTC,"Turn on swapping and try again, if that's possible on your device"
haskell,3a5c0e,Taladar,1 point,Wed Jun 17 13:18:26 2015 UTC,"It has swapping, cabal update uses more than 500 MB of memory, it's rediculous."
haskell,3a5c0e,bgamari,2,Wed Jun 17 15:53:52 2015 UTC,Actually compiling any modern language (as opposed to running it) on a 512MB machine is the ridiculous bit here. You would run into similar problems with most decent sized C++ or even C projects as well. Usually the linker takes the most memory of all build steps.
haskell,3a5c0e,emarshall85,4,Thu Jun 18 11:23:27 2015 UTC,"As dcoutts points out, you are in for a world of pain trying to compile on such a small machine. In my testing on ARM I generally use machines with at least 1GB of RAM.  Nevertheless, it is a little ridiculous that cabal update has a maximum RSS of 700 MB when run on my laptop. This appears to be a bug. I've opened this ticket so it can be tracked."
haskell,3a5c0e,lrich,1 point,Wed Jun 17 14:48:24 2015 UTC,I guess i have to compile a cross-compiling ghc then.
haskell,3a5c0e,tomejaguar,3,Wed Jun 17 15:54:57 2015 UTC,"Just a hunch, but I wonder if you could adjust the nice levels of the cabal and ghc processes such that they don't starve your system's memory? A few weeks ago when I was diagnosing hard freezes that happened when cabal installing large packages (ghcjs in particular), I adjusted nice levels, swappiness, and even tried a different CPU scheduler.  Met with mixed results, but worth a shot, maybe? Though, if you're on Windows, I wouldn't even begin to know how to do any of those things."
haskell,3a4qrl,cdep_illabout,14,Wed Jun 17 05:31:02 2015 UTC,"I really like servant for making RESTful APIs. I wrote a post on combining Persistent and Yesod Servant, and I really have a hard time imagining a higher level/more productive approach to doing this.  EDIT: lol i need to go to bed earlier. stupid homework..."
haskell,3a4qrl,ephrion,6,Wed Jun 17 05:44:09 2015 UTC,persistent and servant I suppose.
haskell,3a4qrl,ibotty,1 point,Wed Jun 17 06:34:20 2015 UTC,"I think GP meant ""Persistent and Servant"" since the blog post's title is ""servant-persistent""."
haskell,3a4qrl,codygman,3,Wed Jun 17 07:18:44 2015 UTC,"I really have a hard time imagining a higher level/more productive approach to doing this   I am authenticating through the web server headers (SSL auth), and wrote a DSL (with operational) that handles authentication for me, limits what I can do with the DB (that part is not that useful) and properly handles rollbacks and web response when I throw something. I am not sure if that's more productive, but I needed the rollback part ..."
haskell,3a4qrl,bartavelle,3,Wed Jun 17 16:57:23 2015 UTC,Oh and I also have a GATDs DSL for access right management. That is useful.
haskell,3a4qrl,bartavelle,3,Wed Jun 17 17:00:53 2015 UTC,Is any of this open source?
haskell,3a4qrl,codygman,1 point,Wed Jun 17 18:22:15 2015 UTC,"Ooh that's neat. I've been considering what I want my authentication/authorization schemes to look like with my own project, but haven't settled on anything in particular. Would you mind sharing anything?"
haskell,3a4qrl,ephrion,6,Wed Jun 17 20:52:15 2015 UTC,"It's just a few lines of code ... unfortunately none of it is open source.  It's something like :  data AuthRight a where     Pure :: a -> AuthRight a     :> :: Ord a => AuthRight a -> AuthRight a -> AuthRight Bool     :== :: Eq a => AuthRight a -> AuthRight a -> AuthRight Bool     CurType :: AuthRight UserType     ItemAccess :: Key Item -> AuthRight AccessLevel     TaskAccess :: Key Task -> AuthRight AccessLevel     ...   Now it might be nicer to just use a free monad and ditch Pure and all the operators, keeping only the FooAccess, but I just needed simple expressions.  Then I have a function like this that powers most endpoints :  service :: (Key a -> AuthRight Bool) -> Key a -> Webapp b -> EitherT ServantErr IO b   That authenticates the user, checks its access rights, and finally runs the provided action."
haskell,3a4qrl,bartavelle,1 point,Wed Jun 17 21:10:00 2015 UTC,"Could you make a blog post about this? I would find it useful, and I bet others would too."
haskell,3a4qrl,ignorantone,2,Wed Jun 17 23:11:33 2015 UTC,Done
haskell,3a4qrl,bartavelle,1 point,Mon Jun 29 18:54:08 2015 UTC,"I'll try, but this will have to wait for next week !"
haskell,3a4qrl,bartavelle,2,Thu Jun 18 05:40:12 2015 UTC,"I've been meaning to get into servant, so thanks for sharing that article!"
haskell,3a4qrl,kqr,1 point,Wed Jun 17 19:05:16 2015 UTC,"I think you meant to say ""I wrote a post on combining Persistent and servant"", not ""Persistent and Yesod""."
haskell,3a4qrl,andrewthad,6,Wed Jun 17 13:14:20 2015 UTC,There is also silk's rest.
haskell,3a4qrl,jhedev,3,Wed Jun 17 06:36:38 2015 UTC,"It's pretty solid, I've used it at a hackathon."
haskell,3a4qrl,Octopuscabbage,6,Wed Jun 17 13:07:53 2015 UTC,Have you used servant before?  I'd be really interested in a comparison between rest and servant.
haskell,3a4qrl,Octopuscabbage,3,Wed Jun 17 13:33:46 2015 UTC,"No, I just now heard of servant. From what I gather they support two kinds of thoughts about designing rest apis. Silks is more about defining it around one 'object' so if you have a 'user' object you can pretty easily define all the user routes (list, create, destroy) in a record type way. Servant seems to be defining a custom route for each action which I see more usable when you have more actions than interactions with 'objects'"
haskell,3a4qrl,AlpMestan,5,Wed Jun 17 13:36:37 2015 UTC,"Well, technically you could automate a lot of the repetitive bits (e.g typical CRUD endpoints) and regroup endpoints by ""sections"", as illustrated below.  -- CRUD endpoints for entities of type 'a' -- indexed by values of type 'i' type CRUD i a = ReqBody '[JSON] a :> POST '[JSON] () -- create            :<|> Capture ""id"" i :> Get '[JSON] a -- read            :<|> Capture ""id"" i :> ReqBody '[JSON] a :> Put '[JSON] () -- update            :<|> Capture ""id"" i :> Delete '[JSON] () -- delete            -- the last three could be written:            -- Capture ""id"" i :> (Get ... :<|> ReqBody ... :> Put ... :<|> Delete ...)  type MyAPI = ""users"" :> CRUD UserId User         :<|> ""products"" :> CRUD ProductId Product   So you can group things logically and try and define your very own notion of resource that supports your needs. Since those are just types, you can easily define them in different modules, transform them and abstract any kind of boilerplate into a reusable solution."
haskell,3a4qrl,NihilistDandy,2,Wed Jun 17 15:06:27 2015 UTC,"Wow, that's a good trick. I've been using Servant for some internal projects at work, and it didn't occur to me to do that."
haskell,3a4qrl,Octopuscabbage,1 point,Wed Jun 17 17:14:07 2015 UTC,Part of the reason I liked silk's rest is it did that creative part trick for me.
haskell,3a4qrl,jhedev,3,Wed Jun 17 19:48:52 2015 UTC,"I tried both for a simple app and for me servant works better for smaller applications. For example, I wrote a todobackend implementation using servant, which was pretty straightforward and I really liked it. Using rest for something this small feels a bit overkill as it takes some time to get used to it (at least for me :) )."
haskell,3a4qrl,jkarni,6,Wed Jun 17 14:44:32 2015 UTC,"I'm not sure it's fair to place servant in the first category rather than second. servant is (or has been, since the 0.2 rewrite) a web framework itself rather than a library one uses in addition to one's web framework of choice."
haskell,3a4qrl,jkarni,3,Wed Jun 17 07:38:43 2015 UTC,"Thanks, I added a little note about this.  I'd also be interested in hearing if the authors of servant agree with your classification."
haskell,3a4qrl,jkarni,4,Wed Jun 17 13:34:43 2015 UTC,"I'm one of them ;)   But you are right that should be somewhat more prominently stated. We wanted to make it clear the uses of the API DSL are not tied to writing web services (servant-client, for example, can be a passable http-client or wreq replacement well outside the context of any web application). But we probably should just admit that by far the most common and most important use-case is as a web framework."
haskell,3a4qrl,ibotty,2,Wed Jun 17 13:57:20 2015 UTC,"There's also a little ambiguity about what is meant by ""servant"" - we use it as both the name of one of the packages, with the expressions of the DSL, and the whole ecosystem. The servant ecosystem (including, in particular, the servant-server package) can certainly be called a framework."
haskell,3a4qrl,ibotty,4,Wed Jun 17 14:01:03 2015 UTC,"You can also use something even more minimal like wai and one of the routing libraries. I routinely use wai-routing.  That said, for non-generic code I use servant. It's really good."
haskell,3a4qrl,beerdude26,2,Wed Jun 17 06:35:57 2015 UTC,Do you have a blog post / example app somewhere that shows an example of doing this?
haskell,3a4qrl,AlpMestan,2,Wed Jun 17 06:50:00 2015 UTC,"No, but the example usage on its hackage site is easy to follow. To implement your own Predicates you need to do a little more. I should write something about it and submit it to its haddocks."
haskell,3a4qrl,beerdude26,3,Wed Jun 17 07:37:27 2015 UTC,"I'm mainly interested in authorization capabilities. I know servant has a patch for basic auth, but they're not yet sure whether their implementation choices are even the right ones. I'd really like OAuth, though."
haskell,3a4qrl,AlpMestan,4,Wed Jun 17 07:17:54 2015 UTC,"You can already do auth quite easily, but servant doesn't provide it yet out of the box. Among the ways to do it:   Write/use a similar wai middleware to this one Define your own combinator that you can sprinkle over any API type you want to make it auth-protected Use an auth proxy in front of your webapp, like sproxy   There may be other ways to do it but I have used these 3. What's happening in the PR you saw is that we're really just trying to provide the simplest auth combinators that cover most of the typical needs. If you really care about auth capabilities and have precise needs, we would love hearing about it (even if you don't use servant)! Feel free to drop by the relevant ticket, that would be very appreciated."
haskell,3a4qrl,get-your-shinebox,2,Wed Jun 17 08:03:12 2015 UTC,"sproxy seems very interesting, especially since it should be possible to generate a bunch of the privilege rules for particular paths from servant's types."
haskell,3a4qrl,LukeHoersten,3,Wed Jun 17 08:27:03 2015 UTC,That's a pretty cool idea.
haskell,3a4qrl,Mob_Of_One,1 point,Wed Jun 17 13:15:25 2015 UTC,"I feel you.  I like Spock the most out of everything I tried, but I'd be willing to use whatever meant I didn't have to write another authorization system.  The guy who wrote Spock also semi-recently created a user management librrary https://hackage.haskell.org/package/users.    I'm skeptical of things like Servant that want to do a lot for me, but I haven't looked too far into it."
haskell,3a4qrl,codygman,3,Wed Jun 17 21:33:44 2015 UTC,I collected a list of Haskell REST API tools/services a bit ago here on reddit: http://www.reddit.com/r/haskell/comments/2r1l42/haskell_rest_libraryserver_breakdown/  Authors of the libraries provided some good motivating-case comments etc.
haskell,3a4qrl,AlpMestan,1 point,Wed Jun 17 12:20:41 2015 UTC,"Thanks, I added a link to post."
haskell,3a4qrl,Mob_Of_One,2,Wed Jun 17 13:31:16 2015 UTC,"Depending on what you want, I'd recommend Scotty, Spock, Servant, or Yesod. Roughly in order of most to least minimal."
haskell,3a4qrl,dbushenko,3,Wed Jun 17 05:34:40 2015 UTC,"Hm, how are Scotty/Spock more minimal than Servant? Do you consider them more minimal because Servant is an eDSL?"
haskell,3a639i,darkroom--,3,Wed Jun 17 14:55:31 2015 UTC,"I believe this is a mistake but i cant find any literature on it.   do [x] <- ""hello""    return x   If STM had mzero as fail, then this would be  an implicit infinite loop."
haskell,3a639i,quchen,2,Wed Jun 17 15:03:27 2015 UTC,But shouldn't you use orElse with anything that could be an infinite loop?
haskell,3a639i,NihilistDandy,4,Wed Jun 17 15:08:37 2015 UTC,"In my opinion I think this is a better proposal for fixing fail,    fail _ = mzero    Pros:    Less work - MonadPlus is already adopted in the mainstream.  Follows the same laws as suggested in the MFP because of this MonadPlus law: mzero >>= f = mzero Almost all monads with sensible fail implementations are instances of MonadPlus and set fail _ = mzero    Cons:    Some monads use the string argument for error reporting. STM is a monad with a MonadPlus instance but errors out on fail. (I believe this is a mistake but i cant find any literature on it.)"
haskell,3a639i,hagda,2,Wed Jun 17 17:08:30 2015 UTC,You've lost me... what exactly are you proposing? Just using MonadPlus instead of creating a new MonadFail class?
haskell,3a1o06,quchen,9,Tue Jun 16 15:12:26 2015 UTC,"In my experience every monad that doesn't throw an asyc exception is an instance of monadplus so why can't we change fail to fail _ = mzero? Are there monads that have ""sensible"" fail implementations that lack monadplus instances"
haskell,3a1o06,darkroom--,10,Tue Jun 16 15:23:00 2015 UTC,What is the point of MonadPlus now that every Monad is an Applicative? Isn't Alternative enough?
haskell,3a1o06,willIEverGraduate,5,Tue Jun 16 16:15:15 2015 UTC,"Applicative and Monad MAY behave differently. Take as example a construct for automatic paralellizing. Here you have Applicative as parallel computation (validating some laws, though) and Monad as the sequencial dependency-counterpart. So there may be use-cases for a different implementation of both.  I see MonadPlus as introducing a 0 in a ring (with mappend as +, >== as *, return as 1), thus defining fail _ = mzero would be the way to go i assume. This differs from Applicative i think."
haskell,3a1o06,Drezil,14,Tue Jun 16 16:40:26 2015 UTC,"I believe that while technically Applicative and Monad may behave differently, those instances are considered unacceptable and non-law-abiding. See this thread for an extensive discussion – the tl;dr is that Applicative and Monad must agree, and that newtype wrappers should be used in cases where there are different Applicative and Monad implementations."
haskell,3a1o06,NiftyIon,6,Tue Jun 16 19:22:34 2015 UTC,"I think in Haxl, if you use a *> b you get parallel computation, whereas if you use a >> b you get serial execution.  They might agree about the result value, though, but not necessarily the effects. I think in this case it is even visible that the execution is parallel or serial."
haskell,3a1o06,Peaker,8,Tue Jun 16 19:38:21 2015 UTC,"In the async library by the same author, Simon Marlow, a similar phenomenon existed for a short time. A Monad instance was added for Concurrently which differed from the Applicative instance in that it didn't actually provide concurrency. When that started causing serious, difficult-to-debug problems for people, the Monad instance was removed. (It's still there in the version on Hackage, but removed in HEAD.)  So I wonder if that apparently broken Monad instance in Haxl will also soon be fixed."
haskell,3a1o06,yitz,2,Tue Jun 16 20:44:44 2015 UTC,I don't think so. Haxl is using some tricks to get as much concurrency as possible out of a specification but not more. It is meant to perform binds.
haskell,3a1o06,ibotty,3,Wed Jun 17 09:47:59 2015 UTC,I bet the Haxl monad is broken as well because if (<>) is parallel and (>>=) is serial then that means (<>) != ap. Which breaks a very important law in Control.Applicative.
haskell,3a1o06,darkroom--,6,Wed Jun 17 14:42:07 2015 UTC,I bet the Haxl monad is broken as well because if (<*>) is parallel and (>>=) is serial then that means (<*>) != ap. Which breaks a very important law in Control.Applicative.   fixed formatting
haskell,3a1o06,Intolerable,7,Wed Jun 17 16:09:13 2015 UTC,"That law is only broken if you consider concurrency as observable.  Exceptions aside, which I didn't investigate in haxl yet, a computation in the Haxl monad yields exactly the same result as in the Haxl applicative (if expressible). That means, <*> == ap. It will just be quicker to compute the answer."
haskell,3a1o06,ibotty,9,Thu Jun 18 06:55:44 2015 UTC,"That's correct.  The equivalence relies on a bit more in Haxl, in particular the result of doing a concurrent/batched fetch should be the same as doing sequential fetches, but if we assume that, then we can assume <*> = ap."
haskell,3a1o06,simonmar,4,Thu Jun 18 10:14:02 2015 UTC,"It depends on what you mean by ""!="". Under some big-step evaluation semantics they are still equal."
haskell,3a1o06,kamatsu,2,Thu Jun 18 06:30:32 2015 UTC,"I think in this case it is even visible that the execution is parallel or serial.   It’s not, except for debugging functions and a possible performance difference."
haskell,3a1o06,evincarofautumn,3,Thu Jun 18 15:04:45 2015 UTC,"Notably, if the monad is commutative—as Haxl is—then a concurrent Applicative does agree with the Monad instance. That’s one of the major points of our ICFP paper."
haskell,3a1o06,evincarofautumn,9,Thu Jun 18 15:06:30 2015 UTC,"Are there monads that have ""sensible"" fail implementations that lack monadplus instances   Yes, for instance the following type:  data M s a = Fail | Succeed a | Step s (M s a)   It represents a computation, which takes some steps with intermediary results and then either fails or succeeds with a final result. It has a sensible Monad instance with fail _ = Fail, but there is no sensible mplus and thus no MonadPlus (at least without constraints)."
haskell,3a1o06,edvo,4,Tue Jun 16 21:56:32 2015 UTC,Isn't this a sensible mplus?  mplus Fail b = b mplus a@(Succeed _) _ = a mplus (Step s m) b = Step s (mplus m b)
haskell,3a1o06,twistier,4,Wed Jun 17 01:07:59 2015 UTC,"If you're after an end result that is either Fail or some number of Steps that were on the path towards a Succeed followed by the Succeed itself, this runs into problems with  mplus (Step s Fail) b = Step s (mplus Fail b) = Step s b   in that it can bring an intermediate step from a ""failure path"" across into a ""success path"".  Edit: That would also requiremplus Fail _ = Fail.  I'm not sure if I'm interpreting the semantics of M correctly though."
haskell,3a1o06,dalaing,4,Wed Jun 17 03:43:54 2015 UTC,"In response to your edit, mplus mzero b = mzero directly violates this law: mplus mzero b = b"
haskell,3a1o06,twistier,3,Wed Jun 17 04:12:33 2015 UTC,"That's what makes me thinks I might be working with the semantics /u/edvo intended - since that would mean that M is Monad with a sensible fail implementation and no valid MonadPlus instance, which is what M was supposed to be an example of.  Edit: to be clear - I can see where you're coming from, and that your mplus is valid under one set of semantics.  I can also see a set of semantics where, as per the MonadFail proposal, ""a call to fail should abort the computation"", and M can't have a valid MonadPlus."
haskell,3a1o06,dalaing,1 point,Wed Jun 17 04:32:47 2015 UTC,You are prescribing a semantics that just doesn't match the function I wrote. That doesn't mean it's wrong.
haskell,3a1o06,twistier,3,Wed Jun 17 03:57:18 2015 UTC,That's the semantics I got from reading /u/edvo's example.  It's possible I misunderstood those semantics.    That's why I front-loaded my comment with all of those qualifying statements going into what I'd assumed about the semantics :)
haskell,3a1o06,dalaing,2,Wed Jun 17 04:08:07 2015 UTC,Which example are you talking about? The only comment I see from /u/edvo only has the ADT and a little description of it: a series of steps terminated by success or failure.
haskell,3a1o06,twistier,4,Wed Jun 17 04:09:43 2015 UTC,"In my use case mplus p1 p2 should give me the first path that succeeds. It should not return a path, that has mixed steps from p1 and p2. Your implementation might be useful for some other use case, but would not work for me.  By the way, I simplified the type. The actual type is data M i s a = Fail | Succeed a | Step s (i -> M i s a), so you cannot decide whether a path will eventually succeed."
haskell,3a1o06,edvo,2,Wed Jun 17 08:04:18 2015 UTC,because many MonadPlus dont follow the associativity law(to allow for infinite data structures) I will ignore that law. So the only laws we are burdened to prove is mzero >>= f  =  mzero. If you notice that is the same law that fail follows. I assume he gave us a correct MonadFail instance. QED?
haskell,3a1o06,darkroom--,3,Wed Jun 17 03:06:42 2015 UTC,"When it comes to ignoring associativity, I found this interesting.  I guess it comes down to whether you consider MonadPlus to be for ""monoids with monads"" or for ""search monads"".  I hadn't really thought about it, and had just assumed it was the first one (and that if you wanted to ignore associativity, then you really wanted a different abstraction).  Does anyone know if the definition has been nailed down further since then?"
haskell,3a1o06,dalaing,2,Wed Jun 17 03:40:46 2015 UTC,"No, I don't think there is any real consensus. This is actually the first I've heard of people actually advocating that associativity is not an important law for MonadPlus, though. I've always considered it deeply important and taken that for granted. I'm aware of cases where you don't want associativity, but I guess it just doesn't occur to me that for some reason people would want to push such things into MonadPlus..."
haskell,3a1o06,twistier,1 point,Wed Jun 17 04:08:13 2015 UTC,"I wasn’t really advocating for non-associativity, more for the fact that MonadPlus is the perfect fit for the fail problem with only STM not following the tradation of fail _ = mzero. The only other downside is that you could lose helpful string information, but that isnt a breaking change and I feel the string is very ugly."
haskell,3a1o06,darkroom--,7,Wed Jun 17 14:45:18 2015 UTC,"Are there monads that have ""sensible"" fail implementations that lack monadplus instances   STM is MonadPlus, but has fail = error (implicitly, via the default implementation)."
haskell,3a1o06,darkroom--,6,Tue Jun 16 20:09:51 2015 UTC,Is there a reason fail doesn't equal mzero for STM?
haskell,3a1o06,drb226,9,Tue Jun 16 23:58:26 2015 UTC,"No hard reason, no. But when you have code that always produces a retry because your pattern fails to match, you've got an implicit infinite STM loop in your code."
haskell,3a1o06,spindakin,7,Wed Jun 17 14:52:24 2015 UTC,This throws away the informative String. Some monads have useful ways of preserving information about failure.
haskell,3a1o06,edwardkmett,3,Tue Jun 16 19:34:32 2015 UTC,"ParsecT, for example."
haskell,3a1o06,dalaing,2,Sat Jun 20 01:48:14 2015 UTC,"There are instances that ""fail"" with error, such as STM, where their mzero retries."
haskell,3a1o06,edwardkmett,6,Thu Jun 18 20:21:02 2015 UTC,"As food for thought, what would happen if we had  MonadFail m ~ MonadError String m   where MonadError comes from / is equivalent to Control.Monad.Except and  fail = throwError   I've always been keen for the option of something more informative than a String with various parsing libraries (some of which tend to use fail / mempty / etc...), and I can kind of see how that could be done with MonadError and classy prisms.  It'd be nice if we could get fail our of Monad as well as laying some groundwork towards having the option of more structured error information (assuming that is something people want).  Edit: Gah, I thought that was on the mailing list...  Something similar was mentioned here although there might be just a few problems with it..."
haskell,3a1o06,dalaing,2,Tue Jun 16 22:51:25 2015 UTC,That requires standardizing lots of extensions.
haskell,3a1o06,ForTheFunctionGod,2,Thu Jun 18 20:18:54 2015 UTC,"That was meant to be a sarcastic ""just a few"" when I linked to your response on the mailing list :)"
haskell,3a1o06,edwardkmett,3,Fri Jun 19 00:49:50 2015 UTC,"ApplicativeDo is somewhere out there on the horizon, and we're not sure yet how much fail makes sense in the context of Applicative   You could just forbid failable pattern matches in the presence of an explicit applicative constraint, e.g.  f :: Applicative f => f (Maybe a) -> f (Maybe a) -> f [a] f xs ys = do (Just x) <- xs            (Just y) <- ys            pure [x,y]  >>> Line 1: Can not use failable patterns in Applicative blocks! >>> Line 2: Can not use failable patterns in Applicative blocks!   A comprehensible error message would probably a challenge."
haskell,3a1o06,edvo,7,Tue Jun 16 16:22:18 2015 UTC,Not a concern. Any use of a failable pattern is going to require a Monad constraint to deal with the success case anyways.  This will already fail.
haskell,3a1o06,hagda,3,Thu Jun 18 20:20:02 2015 UTC,"Just to throw it in for discussion, would it make sense to change the constraint of guard from MonadPlus m to MonadFail m?"
haskell,3a1o06,darkroom--,8,Wed Jun 17 08:07:09 2015 UTC,fail is there primarily for desugaring. It is in no way meant to be a strange version of MonadZero.
haskell,3a1o06,Kaidelong,2,Wed Jun 17 14:53:14 2015 UTC,why did guard need MonadPlus in the first place instead of just using fail?
haskell,3a1o06,hvr_,5,Wed Jun 17 13:52:32 2015 UTC,Actually guard only requires alternative and with AMP the type was changed to reflect that.
haskell,3a1o06,singpolyma,2,Wed Jun 17 14:31:39 2015 UTC,I imagine that this will break a lot of code because of all the manifest types everywhere. Does anyone have any metrics on how often people use partial pattern matches in do expressions?
haskell,3a1o06,hvr_,7,Thu Jun 18 20:43:13 2015 UTC,"There's surprisingly little breakage. You'll find it mostly in monadic parser code if at all.  To give you a concrete example, I tried to cabal install heist lens in a new sandbox w/ a GHC 7.10 which was patched w/ fail moved from Monad to a new MonadFail class (i.e. transitionless). The resulting install plan needed 52 packages:  MonadCatchIO-transformers-0.3.1.3 MonadRandom-0.4 StateVar-1.1.0.0 adjunctions-4.2.1 aeson-0.8.1.1 attoparsec-0.13.0.0 base-orphans-0.3.2 bifunctors-5 blaze-builder-0.4.0.1 blaze-html-0.8.0.2 blaze-markup-0.7.0.2 comonad-4.2.6 contravariant-1.3.1.1 directory-tree-0.12.0 distributive-0.4.4 dlist-0.7.1.1 either-4.4.1 errors-1.4.7 exceptions-0.8.0.2 extensible-exceptions-0.1.1.4 free-4.12.1 hashable-1.2.3.2 heist-0.14.1 kan-extensions-4.2.2 lens-4.11 map-syntax-0.2 mmorph-1.0.4 monad-control-1.0.0.4 (monads-tf-0.1.0.2) mtl-2.2.1 nats-1 parallel-3.2.0.6 parsec-3.1.9 prelude-extras-0.4 primitive-0.6 profunctors-5.1.1 random-1.1 reflection-1.5.2.1 safe-0.3.9 scientific-0.3.3.8 semigroupoids-5.0.0.2 semigroups-0.16.2.2 stm-2.4.4 syb-0.5.1 tagged-0.8.0.1 text-1.2.1.1 transformers-base-0.4.4 transformers-compat-0.4.0.4 unordered-containers-0.2.5.1 vector-0.10.12.3 void-0.7 xmlhtml-0.2.3.4  and required merely trivially patching up 9 out of 52 packages, specifically  aeson-0.8.1.1 attoparsec-0.13.0.0 dlist-0.7.1.1 either-4.4.1 exceptions-0.8.0.2 free-4.12.1 mmorph-1.0.4 parsec-3.1.9 text-1.2.1.1   Most fixes are actually rather needed for the class instance definitions (and there aren't that many Monad instance definitions which override fail). Requiring to convert a Monad to a MonadFail constraint seems seldom needed, and may actually point out potential oversights."
haskell,3a1o06,darkroom--,6,Fri Jun 19 09:16:05 2015 UTC,The original proposal has a section talking about this. I compiled Stackage and looked for how many do-blocks get fail desugarings.
haskell,3a1o06,willIEverGraduate,2,Thu Jun 18 20:44:40 2015 UTC,What is the motivation for MonadFail over just Fail (ie: why require a monad for this? Non-monads can express failure sometimes...)
haskell,3a1o06,ibotty,6,Wed Jun 17 11:48:35 2015 UTC,/u/edwardkmett recently posted some motivation for why to Monad m => MonadFail m
haskell,3a1o06,Kaidelong,3,Fri Jun 19 09:03:48 2015 UTC,Read his github posts. Basically without the monad superclass you get a very odd pointed type which has no laws.
haskell,3a1o06,singpolyma,2,Wed Jun 17 14:46:08 2015 UTC,"But, even with the constraint, you still get a very odd type class :)  Hopefully the desugaring warning is introduced with the proposal, and step 2 is ""deprecate MonadFail""."
haskell,3a1o06,Kaidelong,6,Wed Jun 17 15:59:56 2015 UTC,you still get a very odd type class   but with laws.
haskell,3a367t,goliatskipson,15,Tue Jun 16 21:30:07 2015 UTC,"Short version: Yes and no, but mostly no.  Longer version: On the one hand, at Galois we used the HaLVM to create a high-bandwidth, low-latency streaming crypto streaming, and it is definitely true that not having an OS adding all sorts of delays to the process can be very useful. And measurable.  On the other hand, the network stack we've built was not designed with high performance in mind. (Actually, it kind of was, except it turned out GHC didn't make as much abstraction go away as Trevor had hoped.) So while the concepts you link to are of theoretical benefit to the HaLVM, we'd need to do some performance tuning in the network stack to see some of that benefit. Which is on a long-term TODO list, but we'll have to see when we get time or funding to make that happen.  I will note that other unikernel systems -- and I'm thinking, in particular, of Mirage and OSv -- have spent more time tuning their network stacks, and I believe have published about the advantages they see in ditching the OS.  Finally, and I should probably post this to /r/haskell, but if you're interested in the HaLVM, we'll be doing a workshop on building cool things with the HaLVM at StrangeLoop."
haskell,3a367t,awick,3,Wed Jun 17 04:08:53 2015 UTC,"Nice! Thanks for the throughout answer. There is no change I'll be at StrangeLoop, but probably there will be videos?   Regarding performance tuning: this sounds like a good project for a MSc or PhD thesis. Maybe even GSoC?"
haskell,3a367t,moltarx,3,Wed Jun 17 05:04:06 2015 UTC,"(Trevor here) There are some major architectural problems with HaNS as it stands that need to be sorted out first, but yes!"
haskell,3a367t,hastor,1 point,Wed Jun 17 10:19:39 2015 UTC,Such as?
haskell,3a367t,hastor,1 point,Wed Jun 17 22:35:27 2015 UTC,OSv also looks like a great target for a ghc port.
haskell,3a367t,awick,1 point,Wed Jun 17 22:55:16 2015 UTC,"In a way, that's sort of what the HaLVM is. In a much more tightly integrated way, with a different design philosophy."
haskell,3a2sse,GeorgeTalksCode,2,Tue Jun 16 19:56:24 2015 UTC,Are the slides available somewhere?  I want to get the general ideas of this without sitting through 44 minutes of a youtube video.
haskell,3a2sse,carette,1 point,Sat Jun 20 13:27:59 2015 UTC,Literal haskell source and slides at : https://github.com/gwils/next-level-mtl-with-classy-optics
haskell,3a4j1r,tomotamo,3,Wed Jun 17 04:14:41 2015 UTC,"a really basic api wrapper: https://github.com/intolerable/googl-haskell/blob/master/src/Googl.hs  a more complex api wrapper: https://github.com/intolerable/reddit  im using my own api-builder package for these, if you have any questions about anything specific i'd be happy to help"
haskell,3a4j1r,Intolerable,2,Wed Jun 17 16:15:29 2015 UTC,I found this one to be extremely helpful about how to design a usable package: http://fvisser.nl/post/2013/may/28/towards-a-better-haskell-package.html
haskell,3a4j1r,lpeterse,1 point,Wed Jun 17 13:58:15 2015 UTC,I don't agree with all the advice. This is a very sweeping statement:   Type classes are wonderful technology but are by far the easiest way to obscure a library. Avoid them whenever possible.
haskell,3a4j1r,jaybee,1 point,Wed Jun 17 14:20:40 2015 UTC,"Those are a bunch of advice, very vague. I'd like a real example."
haskell,3a4j1r,lpeterse,2,Wed Jun 17 14:36:29 2015 UTC,"Then I suggest to take a look at the huge-impact libraries on Hackage: bytestring, containers, wai etc. Those are excellent examples of how to structure a project.  When you decide to use config files (why not?), the configurator package is a pleasure to work with."
haskell,3a4j1r,taylorfausak,2,Wed Jun 17 14:45:42 2015 UTC,"It's not a tutorial per se, but take a look at my Strava API client, Strive. To answer your first question, I split the modules into actions, options, and types. And to answer your second question, the only secret is an API key, which the user provides to the client constructor."
haskell,3a1wlk,int_index,12,Tue Jun 16 16:15:43 2015 UTC,"I think the answer is ""historical reasons"" in the following sense. The monad transformer approach was introduced by Jones, Hudak, Liyang in 1995 or so. See for example: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/POPL96-Modular-interpreters.pdf  Their theory was sort of ad-hoc. One of the nice works trying to give a more general story was Jaskelioff's 2009 modular monad transformers: http://www.fceia.unr.edu.ar/~mauro/pubs/mmt/mmt.pdf  That was the paper that introduced the uniform lifting laws. In it, it was observed that the transformations for lifting callCC through State, uniquely among all liftings, did not preserve uniformity.  However, rather than change the behaviour of an existing library to come in line with new laws, the infelicity was just documented (although clearly the story could be spelled out better).  I don't think that the non-uniform version is necessarily better or more useful in any sense -- just there seems to be more breakage caused by changing it than pain caused by leaving it?"
haskell,3a1wlk,sclv,5,Wed Jun 17 04:54:22 2015 UTC,"^- This.  To the best of my knowledge, this is the historical justification for the current instance.  The theory came along much later, and changing it would induce wild silent changes to the semantics of all the code that uses Cont with State, breaking virtually all of it."
haskell,3a1wlk,edwardkmett,3,Wed Jun 17 12:24:40 2015 UTC,Is it possible to recover the expressive power of current callCC via the law-abiding variation?
haskell,3a1wlk,doliorules,5,Wed Jun 17 13:26:05 2015 UTC,"The current instance for StateT s (Cont r) works the same as the instance for ContT r (State s). This, I think, is the most unfortunate part: instead of having two nesting orders that do different things, we have that they do the same thing.  The reason that they chose to do things that way in the original paper is that it is how callCC interacts with genuine mutable state in a language like Scheme. Calling continuations doesn't roll back memory mutations, because arranging for that to happen is much more work. They call the version that does roll back, ""debug semantics.""  The difference is rather like ExceptT (State s) vs. StateT s. Except. The former preserves state changes, while the latter rolls back state changes when you throw and catch, because it has no other option. But with callCC there is an option in this one case."
haskell,3a1wlk,edwardkmett,2,Wed Jun 17 14:43:39 2015 UTC,"Each does a different thing with regards to the state they keep.   You can't really translate code written for one into using the other.  One way you can do it with manual state capture in the environment, but in the other direction IIRC you are hosed -- and this manual trick isn't monad-agnostic, it requires knowledge of the instance you're in."
haskell,3a1wlk,michaelt_,1 point,Wed Jun 17 13:41:13 2015 UTC,Thanks! Now it all makes sense.
haskell,3a1wlk,Drezil,3,Wed Jun 17 08:22:10 2015 UTC,"The documentation for MonadCont doesn't state any law governing implementations of callCC.  The function liftCallCC' as a Haskell function and no signature doesn't violate any law of course; a law is associated in the text with the special synonym CallCC. That it doesn't 'deserve' that name doesn't mean that its use in the instance for StateT is bad; it is only applied to callCC from the underlying monad.  To find a mistake in this, we would have to know what the laws of MonadCont/ callCC are.    Put differently: this objection would not arise if the definition of liftCallCC' were simply inlined in callCC definition in the instance for MonadCont m => MonadCont (StateT s m)"
haskell,3a1wlk,vapourismo,2,Tue Jun 16 22:59:33 2015 UTC,"I think that the complete lack of laws for callCC in documentation would make the callCC = undefined definition perfectly valid as well. Those laws must be somehow implied, if not clearly stated in documentation.  So what are the implied laws? If I was to define my own MonadCont instance, how would I know it's correct? To answer this question, we have to consider two types of instances in mtl:   Immediate instances associate an effect with the transformer that implements it. An example of such an instance would be MonadState s (StateT s m a). StateT handles the MonadState effect. Lifting instances delegate the effect to the inner monad of a monad transformer.   So, lifting instances should preserve some behavior of the operations they're lifting. And as I understand, the laws in Control.Monad.Signatures specify exactly what properties should be preserved. Lifting callCC through StateT uses an operation that doesn't satisfy the uniformity law, so it doesn't preserve any known properties, so why not define all lifting instances to ignore all possible laws and behave in unexpected ways?"
haskell,3a1wlk,Drezil,4,Tue Jun 16 23:12:47 2015 UTC,"If you compare both versions: https://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-State-Lazy.html#liftCallCC you see that they do different things. The one uses the latter state, the other the earlier state in its return type.  That should make a logical difference - so you cant just switch both.  (I just took a brief look at it. Dunno if thats correct, though)."
haskell,3a45q2,Mattiemus,2,Wed Jun 17 02:16:18 2015 UTC,I noticed in the question you say that you are storing state in an MVar. Is there a reason you prefer this over an IORef or a TVar?
haskell,3a45q2,sccrstud92,2,Wed Jun 17 04:46:13 2015 UTC,"The state is potentially changed on multiple threads at the same time: when a new client connects it will spawn its own thread, add itself to the server state, and begin listening."
haskell,3a45q2,sccrstud92,1 point,Wed Jun 17 14:56:26 2015 UTC,Exactly. That seems like the use case for IORef or TVar.
haskell,3a45q2,sccrstud92,2,Wed Jun 17 17:59:04 2015 UTC,I Thaught IORefs weren't meant for modification across threads? I have tried using TVars but the exact same error occurs (i assume they use MVars internally)
haskell,3a1zjf,listrophy,13,Tue Jun 16 16:36:17 2015 UTC,"Title should be ""Using Stack to build and execute an existing Slack Bot""."
haskell,3a1zjf,ilmmad,3,Tue Jun 16 18:16:05 2015 UTC,"Yeah, the focus here is really just using stack to build an existing project. The bot that I use here is basically ""Hello, World."""
haskell,3a1zjf,twopoint718,2,Tue Jun 16 18:52:38 2015 UTC,gah. sorry about that.
haskell,3a1zjf,Tekmo,12,Tue Jun 16 21:17:11 2015 UTC,"I don't see how this is an improvement over cabal.  Can't you do the same thing with cabal install and cabal run?  That's not to say that stack isn't an improvement, but I thought it was for other reasons."
haskell,3a1zjf,Taladar,2,Tue Jun 16 20:36:39 2015 UTC,"cabal-install requires an existing compiler installation, stack does install the compiler for you if it is not yet installed. It also doesn't require the add-source steps in packages that need local dependencies."
haskell,3a1zjf,roche,5,Wed Jun 17 09:02:23 2015 UTC,"If you only want to install an executable, with recent stack you can say stack install. That'll install it into $HOME/.local/bin/ (whcih should be in your PATH), so you don't need stack exec."
haskell,3a1zjf,ajay,6,Tue Jun 16 17:49:26 2015 UTC,It wasn't clear to me from the article why I should use Stack instead of cabal sandboxes. Would anyone be able to provide or maybe point me at a comparison between these two approaches?
haskell,3a1zjf,Crandom,5,Tue Jun 16 19:33:02 2015 UTC,"Stack has a more beginner friendly UI than cabal (whose defaults do bad things). Stack uses lts-haskell/Stackage out of the box, if you want to use that. It can also deal with multiple cabal packages at once."
haskell,3a1zjf,rstd,4,Tue Jun 16 19:41:09 2015 UTC,Why not fix the tools we have instead of creating an ever growing number of new ones? If the cabal defaults are bad then fix that first. It'll only be more confusing for new users the more tools we have.
haskell,3a1zjf,MitchellSalad,5,Tue Jun 16 22:45:23 2015 UTC,"Dan Burton answered this question at BayHac this year. He basically said (paraphrasing) ""we wanted these improvements over cabal, and we wanted them now"". Presumably, rewriting everything from scratch was simpler than understanding and then extending what was already there. I see no problem with that. If you want cabal to do this, that, and the other thing, try hacking on it yourself; no one is stopping you."
haskell,3a1zjf,Crandom,4,Wed Jun 17 02:18:01 2015 UTC,I have tried. I gave up after trying to navigate the source.
haskell,3a1zjf,creichert,5,Wed Jun 17 07:06:38 2015 UTC,"I would imagine having total control and a clean slate to work with would be a big reason. stack still uses the Cabal library under the hood which could mean some of these improvements do see their way back to cabal install if anyone is willing to do the work.  Having multiple tools might confuse newcomers but we certainly won't be the only language with that ""problem"". Python, ruby, and ocaml all have choices which can be confusing."
haskell,3a1zjf,tomejaguar,2,Tue Jun 16 23:20:30 2015 UTC,Cabal is a lost cause.  I once browsed the source and came out a disillusioned man.
haskell,3a1zjf,bgamari,9,Wed Jun 17 05:39:09 2015 UTC,"Cabal does have its issues but to call it ""a lost cause"" is more than a bit hyperbolic. Some parts of the codebase show their age but this is true of most sufficiently old open-source projects.  Really the project just needs more hands. It's absurd that such a widely used piece of code has exactly zero full-time developers. Spring-cleaning Cabal wouldn't be a glamorous task (and may even be unpleasant at times) but I don't think it would be nearly the Herculean effort that is often suggested."
haskell,3a1zjf,sclv,3,Wed Jun 17 09:11:43 2015 UTC,"Welp, never read some of the dark corners of ghc source code then or we may never see you round these parts again."
haskell,3a1zjf,tomejaguar,2,Thu Jun 18 05:22:29 2015 UTC,If it rhymes it must be good.
haskell,3a1zjf,sclv,2,Tue Jun 16 20:01:02 2015 UTC,cabal install ?
haskell,3a0q4y,errge,4,Tue Jun 16 09:08:10 2015 UTC,"errge, awesome work!  So as a note to any other haskellers trying to get ghc on alpine linux, i've managed to get to at least a bootstrap apk for ghc 7.10.1 and was going to submit that upstream along with a cabal apk soonish.   I've been doing my work here: https://github.com/mitchty/alpine-linux-ghc-bootstrap  I'll just dump my notes on what i found about porting ghc to musl here cause why not.  First note, unlit and building a cross compiler doesn't work or might have a bug, it gets built with the host libc from what I found. So I have to do this: https://github.com/mitchty/alpine-linux-ghc-bootstrap/blob/master/bootstrap/Dockerfile#L89-L97  If you build a normal ghc without specifying -nopie, and tell the linker to not use PIC with -fno-PIC, you get this: https://gist.github.com/mitchty/29125de21ade1a04364f  But as it turns out thats likely alpine linux's use of PaX. Long story short, .text relocations aren't allowed by normal executables. So if you turn it off, you can coerce ghc to work without any modifications but to ghc itself. https://github.com/mitchty/alpine-linux-ghc-bootstrap/blob/master/alpine/Dockerfile#L53  But that still causes issues with building base within alpine with your bootstrap ghc itself from what i've found. Been working on figuring out how to get ghc built the ""right"" way and get an apk submitted. But i'm not dealing with 7.8.4. But thought i'd throw this out there, I'm just at the point where I can bootstrap install an apk to generate a real apk with ghc/cabal as dependencies.  In either case I might snag a few of the things you did in build.mk and for configure to see if that helps at all for bootstrapping ghc in alpine within itself.  I just was farting around with using llvm as the backend, but it generates HUGE binaries, aka about 10 megs for a hello world. They're fast static binaries though. :)"
haskell,3a0q4y,saudade,3,Tue Jun 16 13:56:18 2015 UTC,"Feel free to look around of course!  Happy if you can steal something.  We solved the PIE issue by simply doing --no-pie at linker time, but if you have opinions about this and you have a better, technically more superior solution, we are happy to try something else.  Also, please make sure that you apply the patch on libffi from our Dockerfile, that is very-very nasty.  It will cause a bug only if you have an FFI call that calls back to Haskell (e.g. hfuse).  So it can easily remain hidden if you don't have a testcase for that.  If you convince the Alpine guys to ship a GHC based on this work, then we can just start apk installing that instead of compiling our own in the Dockerfile, so your work and contribution would help my project a lot too!  Feel free to send us an email if we should talk more about a shared project, we can also have a audio/video chat of course!"
haskell,3a0q4y,saudade,2,Tue Jun 16 16:08:31 2015 UTC,"Sure thing, just didn't know anyone else was working on porting/using ghc on alpine linux is all. Thats my main reason for throwing out my work in progress to an apk.  I can/have apk's that work that are non position independent that install and ""work"" but I just found out sunday about what PaX itself is doing and have been trying to see if I can bootstrap natively without any linker or compiler cheats. But if nobody cares about a first revision being a work in progress no big deal.  And I was going only for 7.10.1 mostly due to the cross compiling fun I had, but I also took a bit of a different tack for the bootstrap compiler by using the sabotage linux gcc cross compiler. I also cheated by installing ncurses into my cross compiler setup to work around the terminfo stuff.  Tonight is a bit busy as well will be tomorrow but if you want we could both probably work towards apk's. Its to the point I can build a real ghc apk that depends on itself but since I thought I was the only person working on this have been working more on understanding the grsecurity patches and PaX and PIC code and how all this nonsense meshes together.  I'm giving my box at home a bit of a workout with a couple changes and if I can generate initial bootstrap apk's from it I'll add in the ffi stuff and try again. I did some spot checks on compiling things vi cabal but nothing as extensive as you did."
haskell,3a0q4y,saudade,2,Tue Jun 16 17:15:01 2015 UTC,"Ok so the ffi stuff has been fixed in 7.10.1 I verified that.  But I have a quick question for everyone, depending on how I build this ghc, the binaries it produces are vastly different in size when statically linked. With llvm and -O2, the helloworld program from the bindisttests folder is ~10 megs unstripped.  With -O2 alone with native code gen, its ~7.5 megs unstripped. With -O0 for some things like base libraries I can get it to 1 meg which I think is how the gentoo port was compiled. But this all affects the resultant binaries runtime performance. So not sure what everyone would want. I'm leaning towards -O0 honestly just in case this port has hidden issues that take more exposure to expose.  Anyone have thoughts/care?  I personally don't care, and might prefer the -O2 -fllvm build but I'm weird that way. I'm going to build apks tonight with -O2 and non llvm backend mostly because it helps build these apk's faster. For the moment these apks for ghc 7.10.1 and cabal won't be in the alpine package archives until I sort out how to get them into alpine linux upstream if thats ok. ghc needing to be bootstrapped makes this more annoying than it need be.  I haven't started on 7.8.4 either but I'll do all this in a bit. I'm still not 100% happy with the nopie bits but I don't quite understand all the moving parts to know if its truly needed for the alpine hardening setup."
haskell,3a0q4y,aleator,4,Wed Jun 17 21:20:04 2015 UTC,I'm not an expert about ghc internals or musl. Can using musl interfere with any features on the Haskell side? (such as bound threads or some such?)
haskell,3a0q4y,saudade,5,Tue Jun 16 12:34:14 2015 UTC,Actually we have had a crazy debugging session that led to a LibFFI vs Alpine/Musl bug discovery.  I'll try to find the time to write up a blog entry about it after my vacations (and also send a bug report of course).  Hopefully no more bugs left though :)
haskell,3a0q4y,DarkLinkXXXX,3,Tue Jun 16 16:10:06 2015 UTC,"Unlikely, its just a libc, you can use uclibc too to similar effect. musl libc is designed to be statically linked into executables."
haskell,3a0q4y,eegreg,4,Tue Jun 16 13:45:49 2015 UTC,You had me at musl.
haskell,3a0q4y,aseipp,3,Tue Jun 16 13:22:05 2015 UTC,Would it make sense to have GHC default to using musl instead of libc?
haskell,3a0q4y,boylube,11,Tue Jun 16 15:24:50 2015 UTC,"Not really, because GHC has absolutely zero control here. You could do it for specific binary distributions for specific platforms, but not through GHC. The docker image uses Alpine Linux as a base, which bases the entire system on musl, so all libraries use it as their libc. So there are no conflicts and it's all consistent. ""There can only be one.""  On just about any other system - which uses glibc - it's infeasible because you can't link the two together in any one program, and, surprise, all the libraries and resources on your machine will use glibc. So we can't ""default to musl"", we can only use what's available. So you need everything to link against it (even in the dynamic case, it has its own dynamic loader e.g. musl-ld.so, IIRC), by using a system that uses musl for everything. You could accomplish this on 'any Linux distro' if you used Nix and Nix used musl as part of its toolchain, but it doesn't.  To be clear, musl and glibc can exist on the same system. Applications on your system can be linked to either. But one application, through its dependencies, cannot link to both. You can't link or otherwise communicate between them (imagine if you malloc'd a pointer from glibc, and passed it to musl, even providing the linker didn't some freak out on you when you tried to use both in one program). GHC has to link applications against one of them, so it has to 'default' to whatever the system defaults to.  In general the only 'real' way to solve this is to do what the Go people did, and instead do not use a libc at all, for any of the primary GHC distribution, and instead wrap the specific underlying platform's syscalls and process ABI to cover all your cases. That has other costs, mostly that you have to actually implement it all, which won't be a walk in the park. And even then, you may still have libraries you link to which, in turn, depend on your libc - for example, GHC itself uses ncursesw, which is in fact linked against whatever libc you have, and obviously reimplementing terminfo/ncurses to fix that is bonkers.  So it's basically impossible to avoid completely libc practically speaking for a lot of programs, and the question of dynamic vs static libc are mostly up to your distro, and out of our hands."
haskell,3a0q4y,aseipp,2,Tue Jun 16 15:51:02 2015 UTC,"I assume you meant glibc, yes I think so. musl Is a fraction of the size of glibc. It is easier to only use the parts you like and need. However I even think we should not need any libc, but that might be a pipedream."
haskell,3a0q4y,aseipp,6,Tue Jun 16 15:37:06 2015 UTC,"The problem with the no-libc approach is that it simply doesn't scale to any actual program that talks to a library, as far as I can see. In practice I feel it's only going to ever work for very limited amounts of applications, especially Haskell where we use a lot of powerful FFI libraries for all kinds of things.  If you ever use iconv, zlib, ncurses, gtk, or literally any library of non-trivial size - or even a trivial size that just used memset, or your own C code that does whatever - it's almost certainly going to use your libc in one way or another and bring it in as a link dependency, either at dynamic load time or literal link-time.  Because of the nature of symbol names, and their link-time scoping rules, this is important. Unless you are literally going to go rewrite every one of your dependent libraries to use special_ghc_<foo> instead of <foo> (forall <foo>), just to avoid libc, you cannot get away from the fact that symbol name, say, memset has to be provided by something. And if you provide memset yourself, that's going to make the linker angry when you bring in other that want the libc memset, too.  I don't really think it's going to buy us much, because the dependency graph for Haskell applications is often deep and rich between libraries, so it's pretty likely most applications will pull in some C code somewhere along the line. Given the amount of C code out there, it just feels impractical to ever hope to exonerate ourselves from a C standard library.  As for whether or not GHC can 'default' to musl, as I said elsewhere, I don't think we will ever be able to influence that or have any control over it (see my other reply) - it's something that will fundamentally be at the hands of your distribution maintainers, for similar reasons."
haskell,3a0q4y,boylube,2,Tue Jun 16 16:02:41 2015 UTC,"Yes, I know that this decision is distribution dependent and the GHC HQ can't help or influence it.  I think this is why a good compromise is to just develop normally on a desktop GNU/Linux, but then move to our Docker image to compile a portable binary that you can distribute.  Docker is just one command away once you installed it, it's not that painful..."
haskell,3a0q4y,aseipp,2,Tue Jun 16 16:12:26 2015 UTC,"No, it's completely reasonable what you're doing and I think it's a good idea.  I'm just explaining why the nolibc route isn't very beneficial overall (IMO) and why GHC has very little control over being able to 'fix' this deficiency."
haskell,3a0q4y,afcowie,2,Tue Jun 16 16:20:52 2015 UTC,"All valid points, however absolutely not in line with my vision.   I consider the C calling convention horrible and hazardous. I'm personally fine with not having FFI to C at all. I'm mainly a C developer myself and I just don't fully trust any software that links to C modules.   I guess my real problem is having read too much FOSS C code that has obvious issues, more so in larger projects, such as libpq.   It is useless to build well defined software and then link it with mud."
haskell,3a0q4y,saudade,2,Tue Jun 16 16:29:39 2015 UTC,"I don't really like C and I write it plenty, trust me. I'd totally dig a system where I didn't have to worry if unzip'ing a file could compromise my computer. :) I'm just telling you how it is, and 'it' is unlikely to change any time ever in the near future I'm afraid (which makes the 'no-libc' approach essentially a huge amount of work for little to no gain, unfortunately)."
haskell,3a0q4y,Jurily,3,Tue Jun 16 16:44:14 2015 UTC,How did you deal with libgmp? Did someone rebuild that against musl?
haskell,3a0q4y,saudade,3,Wed Jun 17 01:41:49 2015 UTC,"It already exists for alpine linux, the build scripts pick it up if you don't force integer-simple to be used.  bash-4.3# ldd /usr/local/lib/ghc-7.10.1/bin/ghc | grep gmp         libgmp.so.10 => /usr/lib/libgmp.so.10 (0x7fb987127000)"
haskell,3a0q4y,theonlycosmonaut,2,Wed Jun 17 21:07:02 2015 UTC,"I'm confused. What does it mean to have a ""portable"" Linux executable? Is glibc not portable enough? Does it work on ancient kernels? Does it work on 32/64 bit? Does it adapt to my kernel config?  If it's about binary sizes, why bother when Haskell is notorious for bloat? cabal is 15M stripped, that has nothing to do with libc."
haskell,3a0q4y,rdfox,8,Tue Jun 16 16:46:15 2015 UTC,"Portable in this case is a misnomer. A fully static binary doesn't have any dlopen() calls, to libc or otherwise.  Effectively they are portable within the same architecture, aka x86_64 stuff will/should run on any distribution of the same type.  The consistency is the linux syscall interface, for musl libc this means your linux kernel will have to be about 2.6.16 or newer, .19 is preferred if you want to use threads as provided by musl. But other than that it will run anywhere.  And no glibc is not portable, glibc has version numbers and what normally ends up happening is you build against glibc 2.1 say, but you want to run that binary on a glibc of 2.2, no worries works fine. But want to run that on glibc 2.0, and now you've problems.  Static linking glibc is not an exercise for the faint of heart, and is fraught with pain. glibc is not designed to be statically linked into executables. musl however is designed for this purpose, what normally happens, in c at least, is a statically linked musl libc binary is smaller than a dynamically linked glibc binary.  Hopefully that explains the why a bit more and the reason some few of us want this. Feel free to ask more questions!"
haskell,3a0q4y,captain_hoo_lee_fuk,1 point,Tue Jun 16 17:19:46 2015 UTC,Sounds great!
haskell,3a21tx,asswaxer,3,Tue Jun 16 16:52:40 2015 UTC,Maybe haskell-plot ?
haskell,3a21tx,sibip,3,Tue Jun 16 17:30:20 2015 UTC,"Sadly this one depends on gtk, which is a nightmare to get working in Windows."
haskell,3a21tx,maxigit,2,Tue Jun 16 18:06:19 2015 UTC,"Are you looking for a ready-to-use tree map feature or a framework to write your own ? In the later case, diagrams is a good choice."
haskell,3a21tx,bgamari,2,Tue Jun 16 19:13:57 2015 UTC,"I have wanted to implement support for this in Chart for quite some time but have never found a good enough excuse to devote the time to doing so. It would be a lovely project for someone wanting to get started with the codebase, however."
haskell,3a21tx,bgamari,2,Wed Jun 17 09:15:04 2015 UTC,"Actually, I take it back. I was clearing out my todo list just now and it turns out I started working on heatmap support in 2012. I have no idea whether I finished and it certainly doesn't build with modern Chart releases but the branch is here. Judging from the email thread where I announced this, it seems my chart-image package may also be relevant here."
haskell,3a21tx,timbod,1 point,Wed Jun 17 14:59:31 2015 UTC,It's relatively easy to implement new plot types for the chart library. You just need to create a record with this type  These don't need to be in the chart library itself - it's fine for applications to define their own plot types.
haskell,39ztwz,rowanblush,2,Tue Jun 16 03:03:28 2015 UTC,"I was working on this to present at BayHac on Sunday in a lightning talk, but I didn't finish up quite in time. Hope someone finds this helpful!"
haskell,39ztwz,mreeman,2,Tue Jun 16 03:04:36 2015 UTC,How is nixops vs something like docker/kubernetes?
haskell,3a06ar,uncountableB,12,Tue Jun 16 04:56:41 2015 UTC,"There's a couple image processing libraries. I'm on mobile so I can't provide links,  but I think you can use one called JuicyPixels,  I use a lot one called ""friday""."
haskell,3a06ar,Vetii,7,Tue Jun 16 05:14:35 2015 UTC,"I worked for about two years on a proprietary project that did just the kinds of things that you are describing. I don't know of any generally available library (in any language) that does it well.  If the matrix is very regular and reliable, it's not that hard. If it has complex variations - such as arbitrary row and column widths, arbitrary row and column spans, and arbitrary cell contents that you need to detect - I convinced myself that in general this is an NP-hard problem, although I didn't write down a formal proof.  Good luck, and have fun!"
haskell,3a06ar,yitz,6,Tue Jun 16 06:08:00 2015 UTC,"https://hackage.haskell.org/package/JuicyPixels  JuicyPixels is a raster image generating library, not for analysis, although they provide primitives for loading JPEG and PNG images into a Vector data type:  https://hackage.haskell.org/package/vector  You can then use the Vector produced by JuicyPixels in the ""hmatrix"" package  https://hackage.haskell.org/package/hmatrix  With ""hmatrix"" you are provided with the linear algebra algorithms. Although hmatrix doesn't really provide any ready-made recipes for typical image processesing algorithms like edge detection, vector quantization, etc. So it isn't quite image processing, but it is almost there. If you understand the math behind it you can roll your own."
haskell,3a06ar,Ramin_HAL9001,5,Tue Jun 16 07:08:58 2015 UTC,The blog post image processing with comonads is nice.
haskell,3a06ar,quiteamess,3,Tue Jun 16 09:23:58 2015 UTC,"Interesting to see Friday and Juicy in this thread. They are very nice libraries, and combined they can give a Haskell web app basic image manipulation functionality without using any system (C) dependecies or braking out in ImageMagik.  I've raised an issue for that. :)"
haskell,3a06ar,cies010,3,Tue Jun 16 08:44:58 2015 UTC,I'm sure you'll be interested in this:  https://github.com/RaphaelJ/friday-report
haskell,3a06ar,codygman,3,Tue Jun 16 08:39:58 2015 UTC,"as far as i know image processing is closely related to matrix processing, so this could be relevant Matrix processing libraries for Haskell"
haskell,3a06ar,liberalogica,2,Tue Jun 16 10:31:30 2015 UTC,"I've used the CV library for toy problems as well as repa and Friday.  None are as easy, stable or featureful as truly necessary but for learning or toying it can work.  Edit: toying with CV: http://tommd.github.io/posts/LprWithCV.html"
haskell,3a06ar,tom-md,2,Tue Jun 16 14:31:01 2015 UTC,There's yarr: https://github.com/leventov/yarr/blob/master/tests/bench-results.md
haskell,3a06ar,idontgetoutmuch,1 point,Tue Jun 16 16:08:07 2015 UTC,"Wow, that's a lot to go off on. Thank you so much! Hopefully I get somewhere with this, haha."
haskell,3a02kl,Buttons840,10,Tue Jun 16 04:19:31 2015 UTC,This project is a dominion (deck building game) simulator.
haskell,3a02kl,sbergot,5,Tue Jun 16 08:42:11 2015 UTC,"Having a play method on a card is indeed a very OO way of thinking about it, especially since in real life cards are pretty much static data.   I'd be looking to write a Card type and a Table type to represent the cards currently in place and write   play :: Card -> Table -> Table    possibly using lens to manipulate the Table.   From what I've seen of my students' Magic: The Gathering cards, the card can contain instructions for what to do when played, and if you feel you want to represent that as code rather than data, you can go a little bit more OO-flavored and incorporate an effect field :: Maybe (Table - > Table) in your Card data type."
haskell,3a02kl,_AndrewC_,3,Tue Jun 16 05:56:57 2015 UTC,"Just wondering, will it be appropriate if we just use (Table -> Table) instead of using maybe to wrap it, and if the card doesn't have any effect, we'll use id as a placeholder?"
haskell,3a02kl,PoJieNie,6,Tue Jun 16 14:32:35 2015 UTC,"For searching purposes, I think Maybe (Table -> Table) would be better. Functions aren't in Eq."
haskell,3a02kl,Magnap,3,Tue Jun 16 19:41:37 2015 UTC,"And then the set of cards is just [Card], in case that wasn't clear"
haskell,3a02kl,fruitbooploops,3,Tue Jun 16 11:14:17 2015 UTC,"A Table -> Table function may be too limiting, especially if Table doesn't contain enough game state. In principle (though in practice, only in joke sets like Unglued), an MTG card could require you to do something extreme, like play a different game and vary its effect based on the winner. I'm thinking something more general using continuations, like this might be useful."
haskell,3a02kl,rpglover64,2,Tue Jun 16 18:17:56 2015 UTC,"That is a terrible approach. Adding a new card becomes hard and you need to edit every function with Card on the type. IMO having methods is the way to do. A card is data, yes. So is a function. The effect of a card is part of the card data, and that translates to a Haskell function. It is the most natural thing to do to have a function as a field of the card."
haskell,3a02kl,SrPeixinho,2,Wed Jun 17 05:39:13 2015 UTC,"... which I suggested at the end, yes."
haskell,3a02kl,_AndrewC_,3,Wed Jun 17 05:58:39 2015 UTC,"Ohh... woops. Okay, I shamefully admit I stopped reading after the type. Hey, but be fair to me, that paragraph was a total plot twist. I just assumed it added more info.   Sorry Andrew...! :(  (... this all makes me wonder if we would be so biased against OOP style if OOP wasn't a thing and Haskell was C ...)"
haskell,3a02kl,SrPeixinho,1 point,Wed Jun 17 08:23:38 2015 UTC,"It was indeed a bit of a plot twist, and I can totally understand if folk don't quite make it to the end of what I write. As my wife  occasionally says, ""you can't expect me to listen to everything you say!"" :)"
haskell,3a02kl,_AndrewC_,2,Wed Jun 17 18:55:08 2015 UTC,"She says that? Hahahahhaha! Well, it is a reading optimization, necessary but sometimes it mistakes.  edit/disclaimer: that applies to reddit/posts/papers/etc, I obviously read every single word of anything addressed specifically to me"
haskell,3a02kl,SrPeixinho,2,Wed Jun 17 19:09:03 2015 UTC,"Usually it happens after I've pointed out that I really did tell her something she thinks I didn't, and it always makes me laugh."
haskell,3a02kl,_AndrewC_,7,Wed Jun 17 22:45:44 2015 UTC,"I'm working on a card game right now.  I'm using three monad layers. At the top is a state monad that contains all the physical game state. Below that is a free monad that describes client/server requests and responses and random numbers. The last layer is of course the IO monad.  This system works OK, but the state monad is a bit of a bummer since its effects are so unconstrained. I might try to rework it into another free monad."
haskell,3a02kl,pubby8,3,Tue Jun 16 08:21:23 2015 UTC,+1 for free monad
haskell,3a02kl,Crandom,3,Tue Jun 16 12:31:53 2015 UTC,There's a Dominion simulator that someone has written.
haskell,3a02kl,tel,7,Tue Jun 16 13:06:25 2015 UTC,"For this you will need to create your own Embedded Domain-Specific Language (EDSL).  All programming languages, including EDSLs require a notion of ""memory,"" ""objects,"" and ""computation."" So if your EDSL is for that of a board game:   ""memory"" is the game board, including the shared game board and the part of the board specific to each player. ""objects"" are anything that can exist on the board, including avatars for players, cards, tokens, dice, etc. ""computation"" are the rules for eacch possible card in the game. When a player ""plays"" a card, the card will contain a set of instructions that is ""executed"" which alters the state of the game board.   Your EDSL should also contain logic primitives like IF statements, and FOR-EACH statements, and should probably also be able to throw exceptions.  So lets say you have a card with the following rules:  One thing about these card games is that the logic of the cards can be encoded in an Embedded Domain-Specific Language (EDSL). For example, if you have a card with a rule like:  ""Fire-Breathing Griffin"" costs 4 food resources and 2 magic resources to use requires creature ""Master of Enchanted Creatures"" activated blocks user from casting water-related spells while in play deals 1 damage to any non-enchanted creature   That way you can encode rules for your cards using a data structure which might look something like this:  data ResourceType = Gold | Water | Land | Magic | ... deriving (Eq, Ord, Read, Show, Enum, Bounded)  data Resouce = Resource ResourceType Int deriving (Eq, Ord, Show, Read)  data Computation =           Assert Bool [Conditional]         | UseResource [Resource]         | ForEach [Selector] [Computation]         | ...     deriving (Eq, Ord, Show, Read)  data Card = Card { cardName :: String, cardRules :: [Computation] }     deriving (Eq, Ord, Show, Read)  ...  exampleCard :: Card exampleCard = newCard{         cardName = ""Fire-Breathing Griffin"",         cardRules = [             UseResource [Resource Food 4, Resource Magic 2],             Assert True [CheckActivated (Find (Creature ""Master of Enchanted Creatures""))],             BlockUseOf [Find Spell [Select (Variety ""water"")]],             ForEach [Find Opponent [Select AnyCreature]] [                 IgnoreWhen [Select (Upgrades ""enchanted"")]             ]         ]     }   So the above data structure is a bunch of lists and data type constructors. Also, as you can see in the above example, Haskell's deriving (Read, Show) feature is used so that your data can be read to and written from files on a disk in human readable form.  Then you need to implement a transormation function, which will probably be a type class, that can traverse your EDSL data types and update your game board state accordingly:  class Computable t where     compute :: t -> EitherT CannotPlayError (State GameBoard) Result   instance Computable Comptation where     compute (Assert yesOrNo cond) = compute cond >>= \result -> case result of         BoolResult bool | bool/=yesOrNo -> throwError (UnsatisfiedCondition cond)         _                               -> return result     compute (UseResource rsrcs) = do         forM_ rsrcs $ \ rsrc@(Resource rsrcType amount) -> do             x <- lookupResources rsrcType             if x < rsrcType then throwError (NotEnoughResrouces rsrc) else                 modifyResources rsrcType (subtract amount)         return (BoolResult True)  instance Computable Conditional where     compute (...) = ...   You may want to look into the lens library, it makes it much easier to deal with a complex state object like a game board than vanilla Haskell."
haskell,3a02kl,Ramin_HAL9001,3,Tue Jun 16 11:23:12 2015 UTC,"I wrote a tutorial showing how you can mix lenses, State and IO to write a game in a traditional imperative and OOP fashion."
haskell,3a02kl,Tekmo,3,Tue Jun 16 12:59:29 2015 UTC,This might give you some ideas:  https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon
haskell,3a02kl,codygman,2,Tue Jun 16 16:58:16 2015 UTC,this might help you get started.
haskell,3a02kl,gilmi,2,Tue Jun 16 05:21:28 2015 UTC,"Some comments here (and the link itself) should be relevant to what you are trying to do: http://www.reddit.com/r/haskell/comments/2yqwgi/type_directed_spell_system_development/  Basically, if you want your cards to potentially have really crazy effects that screw around with the rules of the game itself, then continuations are something you could be interested in."
haskell,39yrxy,dmalikov,15,Mon Jun 15 21:55:27 2015 UTC,"Cabal hell doesn't even exist anymore for stack users. In fact, I haven't had any dependency-related issues since cabal sandboxes, and now finally stack solves the ""recompile seemingly all of hackage for every project"" problem that sandboxes introduced."
haskell,39yrxy,MitchellSalad,7,Tue Jun 16 02:13:11 2015 UTC,"Fundamentally stackage is just relying on someone else to go through cabal hell for you, though.  Of course that might be solution enough for most users but it isn't actually a solution."
haskell,39yrxy,reaganveg,6,Tue Jun 16 04:32:30 2015 UTC,Nix requires a similar amount of work.
haskell,39yrxy,npouillard,4,Tue Jun 16 05:01:31 2015 UTC,Nix is useful beyond Haskell though.
haskell,39yrxy,cies010,6,Tue Jun 16 08:34:05 2015 UTC,"I don't know, learning Nix has been quite challenging. There is not much documentation out there, and most of it is outdated."
haskell,39yrxy,sccrstud92,3,Tue Jun 16 05:18:26 2015 UTC,You're right in particular the haskell-ng changes have outdated some important docs.
haskell,39yrxy,npouillard,2,Tue Jun 16 06:17:13 2015 UTC,"haskell-ng has made it way easier though,  especially with the cabal2nix tool."
haskell,39yrxy,Crandom,3,Tue Jun 16 09:23:05 2015 UTC,"Yes, but nix is in general not very self-documenting for newcomers. When I last experimented with it, it was hard enough even finding source locations for errors, much less figuring out how to do anything independently without pretty focused instructions."
haskell,39yrxy,conklech,3,Tue Jun 16 18:02:49 2015 UTC,"I agree, I think nix has terrible UI/noob-friendlyness. But you can go a long way by just following http://wiki.ocharles.org.uk/Nix and not really understanding the bulk of the nix-specific stuff."
haskell,39yrxy,Crandom,9,Tue Jun 16 18:09:34 2015 UTC,"Cabal hell doesn't exist any more for cabal users either, if you use cabal correctly with its modern features.  It's also not necessary to ""recompile seemingly all of hackage for every project"", since cabal supports shared sandboxes.  Even without shared sandboxes, unless you are constantly starting brand new projects with huge dependency sets, a fresh compile of the dependency set at the beginning of a project only takes a few minutes using parallel builds and seems like a good idea.  Our projects tend to have on the order of 150-200 indirect dependencies. It takes me 5 to 10 minutes to rebuild a sandbox from scratch, and although I work on multiple such projects, I don't find myself doing that more than once or twice per week. So to me, it's worth that tiny cost to know that I have fresh builds direct from the source code, in my own environment, with my own settings.  EDIT: To be clear, as I also said about Nix, stack is great work and looks like a really cool tool. We may end up trying it. But you are doing stack a disservice by implying that its reason for existence is to avoid ""cabal hell"" or ""interminable cabal sandbox rebuilds"", because those problems don't really exist anymore even with cabal itself."
haskell,39yrxy,yitz,14,Tue Jun 16 06:53:13 2015 UTC,"Cabal hell doesn't exist any more [...], if you use cabal correctly   That's a big IF right there. The problem is you can use cabal incorrectly. And many users do, because of lack of documentation or experience.  The best systems are those which do not allow you to do things incorrectly. I would expect the Haskell community to know that.. you know, like having strong types doesn't allow you to call functions with the wrong arguments?"
haskell,39yrxy,rstd,0,Tue Jun 16 09:40:37 2015 UTC,So then why not just wrap cabal in a better API?
haskell,39yrxy,Tekmo,4,Wed Jun 17 00:58:51 2015 UTC,"That's basically what I was trying to do with stackage-sandbox: wrap cabal in an api that encourages shared sandboxes.  However, fully sharing sandboxes between projects turns out to be rather fragile. Projects often need to deviate from each other in small ways. I might want to work on the bleeding edge of package A, while also working on package B which depends on the stable version of package A. These cannot share a sandbox. But with stack, they can share just the dependencies that they draw from stackage."
haskell,39yrxy,drb226,11,Wed Jun 17 01:05:14 2015 UTC,"The problem is cabal is too hard for beginners to use and they just give up. Then people tell them they're ""using cabal incorrectly"" which does not help. Cabal's defaults should do the correct things, not the potentially dangerous things. It should at the very least make a sandbox for you when you 'cabal init' and prevent you from installing in the global package database."
haskell,39yrxy,Crandom,2,Tue Jun 16 09:21:07 2015 UTC,"shared sandboxes   Does it share the entire sandbox, or does it share the individual compiled packages?  I know the former exists, but the latter would be really useful too."
haskell,39yrxy,Fylwind,4,Tue Jun 16 07:33:26 2015 UTC,"stack solves the ""recompile seemingly all of hackage for every project   How does it solve that?  The local sandbox still can't be shared between projects."
haskell,39yrxy,tomejaguar,3,Tue Jun 16 05:32:54 2015 UTC,The local sandbox still can't be shared between projects.   It can be shared with cabal. Does stack somehow prevent that?
haskell,39yrxy,yitz,3,Tue Jun 16 07:04:32 2015 UTC,"Non-reusability was my naive understanding of the following passage:   Packages are installed into isolated package databases by default. There is a layering of three package databases: The global database, the snapshot database, and your personal project's database. Many projects can share the same global database (base, bytestring, etc.) and the snapshot database (e.g. text, haskell-src-exts, etc.)—which means no unnecessary rebuilding of packages—and yet each project has its own package database, so they are isolated from each other and cannot break each other.   https://www.fpcomplete.com/blog/2015/06/announcing-first-public-beta-stack"
haskell,39yrxy,tomejaguar,2,Tue Jun 16 20:00:26 2015 UTC,"I don't get to share the local sandbox, but 90% of my dependencies are from stackage lts-2.13, so I get to avoid 90% of the compilation every time I start a new project, which I still consider useful."
haskell,39yrxy,andrewthad,2,Tue Jun 16 11:53:54 2015 UTC,"True, but you can just put multiple packages into the same ""project."" Or as others have mentioned, get more of your dependencies into stackage and then they'll be shared even if in different projects.  In theory, stack can be extended to use your own ""snapshots"" rather than using the default of LTS Haskell."
haskell,39yrxy,drb226,1 point,Wed Jun 17 01:12:26 2015 UTC,"True, but there aren't a whole lot of super useful packages that aren't yet on stackage. And if you find one, just notify the maintainer, or make the PR yourself."
haskell,39yrxy,MitchellSalad,2,Tue Jun 16 07:00:28 2015 UTC,It doesn't have all of Hackage though :(
haskell,39yrxy,Crandom,3,Tue Jun 16 09:17:54 2015 UTC,"It's pretty trivial to add a non-stackage package to your stack projects by adding it to the extra-deps list in your stack.yaml, or create a multi-package project and use the source for an extra package if you so desire."
haskell,39yrxy,drwebb,3,Tue Jun 16 17:20:26 2015 UTC,"I think it is a bit misleading to claim that nix, as amazing as it is, solves ""cabal hell"". Sandboxes solve cabal hell, nix does not (for the moment) solve cabal hell, what it provides for haskell developement is instead a replicable environment, an easy way to change compiler, automatic installation of non-haskell dependencies and a set of packages spanning almost the entirety of hackage which are know to work well with each other. This is no small feat, and is a very nice set of features, but it is still definitely possible to get into cabal hell, and quite easily."
haskell,39yrxy,miguelnegrao,1 point,Tue Jun 16 10:56:04 2015 UTC,"One of Nix's many features is a more intelligent way of implementing sandboxes. So if, as you say, ""Sandboxes solve cabal hell"", it necessarily follows that Nix does as well."
haskell,39yrxy,Doji,1 point,Tue Jun 16 20:34:49 2015 UTC,One of Nix's many features is a more intelligent way of implementing sandboxes.   Could you explain how Nix does this?
haskell,39yrxy,tomejaguar,1 point,Tue Jun 16 21:46:16 2015 UTC,"Sure. Suppose you have two sandboxed projects. Project one depends on A B and C. Project two depends on A B and D. With sandboxes, you will end up with two copies of A and B.  In Nix, all the libraries are located in the nix store, and each project is given access to only the libraries it requires. So you end up with a single copy of each A B C and D. Nix just tells the compiler where to find the necessary libraries behind the scenes. So when compiling project one, it'll tell the compiler where to find A B and C. When compiling two, it'll tell the compiler where to find A B and D. The compiler won't find libraries it isn't supposed to because they're stored in a directory named with a massive hash - a very undiscoverable location. Chroot can also be used to enforce this constraint of not finding libraries the compiler isn't supposed to a little more strongly."
haskell,39yrxy,Doji,1 point,Thu Jun 18 01:45:14 2015 UTC,each project is given access to only the libraries it requires   Thanks.  This is the key point.  How is this arranged?  Is every package in its own package database?
haskell,39yrxy,tomejaguar,1 point,Thu Jun 18 05:50:11 2015 UTC,"Before building, we traverse the dependencies, copying the *.conf files into a temporary package db directory (""$packageConfDir""), and then run ghc-pkg --package-db=""$packageConfDir"" recache. When we build Setup.hs, we pass the same --package-db=""$packageConfDir"" flag.  You can see this in action here (as well as support for propagating includes and such): https://github.com/NixOS/nixpkgs/blob/7e04b7319c54bf0a4c0b6b55caca80a3b7434a87/pkgs/development/haskell-modules/generic-builder.nix#L151-183"
haskell,39yrxy,cstrahan,1 point,Sat Jun 20 01:56:23 2015 UTC,"Cool, thanks for the explanation!"
haskell,39yrxy,tomejaguar,1 point,Sat Jun 20 06:54:15 2015 UTC,"ok, I should have said ""cabal sandboxes + the cabal dependency solver solves cabal hell"". Nix doesn't have a built-in dependency solver (there were attempts [¹]), therefore if the set of packages with specific versions you want to install together are not compatible with the current (or older) set of packages in nixpkgs, then you need to basically do the dependency solving manually, which is hard work. [1] https://github.com/MarcWeber/hack-nix"
haskell,39yrxy,miguelnegrao,1 point,Wed Jun 17 10:51:46 2015 UTC,"forgot to add, nix also provides binary caches which save a lot of time (and power consumption :-) ). One has to be aware though, that in some instances one can't mix binaries from different caches, or with locally compiled ones due to ghc non-determinism (https://github.com/NixOS/nixpkgs/issues/7792)."
haskell,39yrxy,miguelnegrao,10,Wed Jun 17 10:57:39 2015 UTC,"Nix is a great direction. I'm looking forward for it to mature for all platforms.  But calling it ""escaping cabal hell"" is just rhetoric. Cabal hell hasn't existed for quite a while now. It was caused by limitations of older versions of cabal in the face of a genuinely difficult problem. Now cabal is far more powerful and flexible. When people say they are experiencing ""cabal hell"", what it means is that they are using the tools wrong. So what we need to solve ""cabal hell"" is better documentation, and perhaps UI improvements, for existing tools, not new tools.  Again, that is not to say that Nix isn't needed or isn't cool. It is! But ""cabal hell"" is not the issue."
haskell,39yrxy,yitz,13,Tue Jun 16 07:00:00 2015 UTC,"If cabal hell hasn't existed for a while, then I'd like to know why I had to help at least three beginners at ZuriHac with what looked like cabal hell to me."
haskell,39yrxy,ocharles,2,Tue Jun 16 11:02:52 2015 UTC,"As yitz said   When people say they are experiencing ""cabal hell"", what it means is that they are using the tools wrong.   It's no surprise that beginners would be ""using the tools wrong"", but I think the attitude we should take is that the tools should be friendlier, easier to use, and harder to ""use wrong"", rather than accusing people of causing their own misery."
haskell,39yrxy,drb226,4,Wed Jun 17 01:17:36 2015 UTC,"Spot on. I don't care what the definition of ""cabal hell"" happens to be, but as long as I see people using cabal and experiencing the agonies of hell, then as far as I'm concerned that is cabal hell."
haskell,39yrxy,ocharles,2,Wed Jun 17 08:28:32 2015 UTC,"cabal feels like the sort of tool that you shoot yourself in the foot with if you just start using straight ahead after reading over the high-level view of what it does. Because then you find out that one of the default behaviours is wrong and that ""you should of course change that/don't do that"". Like some Unix tool with the defaults set for 80s computers.  Perhaps like the culture around some Unix tools, with time the people who are knowledgeable about the tool can use it competently and seamlessly, since it places more of a penalty on initial users rather than experienced users which have established their habits, suffered rookie mistakes, and configured it in a sensible way. To them it looks like a solved problem."
haskell,39yrxy,jeandem,4,Wed Jun 17 16:42:00 2015 UTC,A good move would probably be to disable using Cabal out of a sandbox by default.
haskell,39yrxy,Jookia,2,Tue Jun 16 08:05:11 2015 UTC,This is a great idea.
haskell,39yrxy,andrewthad,1 point,Tue Jun 16 11:54:46 2015 UTC,"Cabal already has a --require-sandbox option. It's a choice of Haskell toolset installation packages such as Haskell Platform, etc., whether or not to set it by default."
haskell,39yrxy,yitz,2,Tue Jun 16 20:56:17 2015 UTC,"Do the majority of use cases need it off? If not, why is it off by default?"
haskell,39yrxy,Jookia,1 point,Tue Jun 16 22:48:52 2015 UTC,"There was a point when it was on by default. It causes me some confusion, but I soon learned to just always use sandboxes."
haskell,39yrxy,drb226,4,Wed Jun 17 01:14:10 2015 UTC,tl;dr cabal isn't a package manager
haskell,39yrxy,Peaker,4,Tue Jun 16 07:05:43 2015 UTC,"GHC needs to allow same package version to be installed multiple times.  Until then we're in ""sandbox hell""..."
haskell,39yrxy,tomejaguar,2,Tue Jun 16 10:36:35 2015 UTC,"Unbeknownst to almost everyone, it has supported this for a long time!  What you need to do is install every package in its own package database.  Then there's no possibility of conflict.  Some cleverness would be required to enable the correct set of databases when building or installing, but there's no more to it than that.  I'm very surprised nothing has been made of this yet as it holds to key to solving a lot of cabal hell. I'm working on an installer/package manager using this idea as a side project, but I don't have that many resources to dedicate to it."
haskell,39yrxy,Peaker,3,Tue Jun 16 20:06:22 2015 UTC,"Then you need some sort of database of package databases, don't you? :)  This sounds like a convoluted solution, doesn't it? Unless GHC's package database is simply deprecated and replaced by this solution."
haskell,39yrxy,tomejaguar,2,Tue Jun 16 20:14:14 2015 UTC,"Then you need some sort of database of package databases, don't you? :)   Yes, essentially a list of packages.   This sounds like a convoluted solution, doesn't it?   No, it's an incredibly simple solution to a longstanding problem!  The problem can be solved unilaterally, now, without waiting for anyone in the GHC or cabal team to do anything.  I find that amazing.   Unless GHC's package database is simply deprecated and replaced by this solution.   It is GHC's package database!  Maybe I just didn't explain well enough."
haskell,39yrxy,hailmattyhall,2,Tue Jun 16 20:22:42 2015 UTC,"Cabal hell hasn't existed for quite a while now   I don't think this is correct and I hope that many feel the same way. I've used sandboxes in what seems to be the correct way as far as I can suss out and I still often end up with problems getting the dependencies to all build together. Sometimes I can't even get them to build after doing a complete clean, ie:   $ rm -rf .cabal-sandbox ~/.ghc ~/.cabal ~/cabal.sandbox.config   In the end I gave up and used Nix, which is a bit of a faff so far from idea.  It may well be a documentation problem, as you say (although I'm inclined to say it isn't wholly a doc problem), but it's still a problem. And then you have the problem that, with every new project, you have to sit and wait for ten minutes for all the libraries you need to really start working to install. It's far from ideal."
haskell,39yrxy,yitz,0,Tue Jun 16 15:33:30 2015 UTC,"I've used sandboxes in what seems to be the correct way as far as I can suss out and I still often end up with problems getting the dependencies to all build together.   I sympathize with build problems you have had. But it is exactly this kind of unfair blaming of cabal, without providing any details of exactly what went wrong for you, that I object to.  I can report that our team has many projects with very large dependency sets, and cabal works fine for us. We do this all day long. The old nightmare of constantly struggling to find a way to pin dependency versions just so that cabal could find a build plan - and then falling way behind on updates of the packages - have ended. When builds do occasionally go wrong, the underlying reason is unrelated to cabal itself, and cabal helps us to find a good solution."
haskell,39yrxy,hailmattyhall,5,Tue Jun 16 21:16:20 2015 UTC,"I'm not sure it is unfair to blame cabal. It's not just me having these problems, it's widespread. I can't provide details because I haven't got the project around and, in the end, I just gave up writing in Haskell. I could write them in Python or even Rust much quicker and with far less hassle.   The problems may have ended for you, they may not have done for others."
haskell,39zuwk,asswaxer,10,Tue Jun 16 03:11:05 2015 UTC,mapM or foldM
haskell,39zuwk,singpolyma,1 point,Tue Jun 16 03:42:42 2015 UTC,Is there a foldM? What module?
haskell,39zuwk,Crandom,6,Tue Jun 16 03:51:43 2015 UTC,Woops. Found it. I'm sorry.
haskell,39zuwk,ignorantone,1 point,Tue Jun 16 03:58:46 2015 UTC,"IIRC, mapM is really just traverse."
haskell,39zuwk,Soul-Burn,10,Tue Jun 16 15:08:31 2015 UTC,In the interest of giving you the tools to become self serving:  https://www.haskell.org/hoogle/?hoogle=%28a+-%3E+m+b%29+-%3E+%5Ba%5D+-%3E+m+%5Bb%5D  Try crafting the type signature and use hoogle :)
haskell,39zuwk,yitz,6,Tue Jun 16 04:34:49 2015 UTC,"The others have answered how to actually solve the problem you encountered, but I have to question need of performing the IO ""inside the loop"". This hints to me on bad composability. I would try to separate the pure calculation from the IO operations.  As you know, Haskell is a lazy language so even if your function returns a list, it won't calculate the rest of the list until it is needed.  Instead of fold, think of using scan which is like fold but returns the intermediate values, and then map the result to IO operations using mapM, foldM, sequence, etc like the other answers recommend.  So instead of b -> [a] -> IO b, change it to a pure b -> [a] -> [b] and map the resulting [b] to IO ()."
haskell,39zuwk,Stratege1,3,Tue Jun 16 12:45:09 2015 UTC,Thank you so much. Responses like this really help me learn so much and discover things a novice like me would need to stumble upon much later otherwise.
haskell,39zuwk,kqr,4,Tue Jun 16 12:51:46 2015 UTC,"Another hint is to keep in mind that every monad is also an applicative, so the function you are looking for is often found in Data.Traversable or Data.Foldable."
haskell,39zuwk,gelisam,3,Tue Jun 16 06:36:00 2015 UTC,"I can't seem to get around the fact that things like putStrLn produce IO(), so the contents of the IO are lost."
haskell,39zuwk,zoomzoom83,2,Tue Jun 16 03:15:11 2015 UTC,"if for some reason you'd want it to be different, you can always just wrap it into something like this:  retainValue :: (a -> IO b) -> (a -> IO a) retainValue a x = a x >> return x   this code segment should also make it obvious why putStrLn and many others having IO () as return type is completely sensible."
haskell,39zuwk,gelisam,1 point,Tue Jun 16 08:07:08 2015 UTC,"From a step-by-step viewpoint, if you are able to create  map putStrLn [""hello"", ""world""]   which will give you [IO ()], which is a list of IO (), you're already halfway there. There exists a function  sequence :: [IO a] -> IO [a]   which will run all the IO actions inside a list and give you back the results as an IO list. If you don't care for the results, there's also  sequence_ :: [IO a] -> IO ()   which just throws away the results, but still performs the IO actions."
haskell,39zuwk,gelisam,1 point,Tue Jun 16 10:38:59 2015 UTC,What do you mean by that? Which piece of information would you like to keep?
haskell,39zuwk,beerdude26,1 point,Tue Jun 16 12:10:59 2015 UTC,"For example if I was keeping a sum of the numbers from an array and I wanted to print the sum as each element was added I though I could putStrLn previousSum >>= \x - > return $ x + nextElement  as the function inside the fold, but the putStrLn gives back a IO ()  so x wouldn't be containing the previous sum, but (). I saw foldM was the solution though"
haskell,39zuwk,_skp,4,Tue Jun 16 12:19:01 2015 UTC,You can call putStrLn and still return another value  In a completely contrived example:  double :: Int -> IO (Int) double n = do     let dbl = n * 2     putStr (show dbl)     return dbl
haskell,39zuwk,tel,2,Tue Jun 16 12:34:42 2015 UTC,"In your example, previousSum is a number, but putStrLn expects a string. Let's try to fix your example:  putStrLn (show previousSum) >>= \x -> return $ x + nextElement   But wait, that doesn't work either! If putStrLn is returning its argument, and its argument is a String, then x is a String, not a number, so you can't add nextElement to it.  In general, the thing we are printing might not be the same thing as the thing we want to keep. To disambiguate, we can simply give a name to the thing we want to keep.  let x = previousSum in putStrLn (show previousSum) >> return $ x + nextElement   In this case, giving a name to previousSum is redundant because it already has a name, so you can simply write this:  putStrLn previousSum >> return $ previousSum + nextElement   Does that make sense?"
haskell,39x1wo,tailbalance,8,Mon Jun 15 14:29:45 2015 UTC,"A neatly packed way to call with convenient optional literal arguments. Nice Hackage haddock documentation. I anticipate the need for some  deconstructor like maybe in case you feel like being point-free instead of pattern-matching, e.g. greet = option ""Hello"" (""Hello, "" ++). Also, does an IsList instance also make sense, for further convenience?"
haskell,39x1wo,chrisdoner,5,Mon Jun 15 14:58:16 2015 UTC,"Alright, I'll add something like option  I really want an IsList instance, but the problem is that the IsList type class requires a toList method which round-trips with fromList, which the Optional type cannot provide.  I would prefer that IsList had a FromList super-class for types that support list literal syntax but that do not support list pattern matching syntax."
haskell,39x1wo,Tekmo,1 point,Mon Jun 15 15:40:09 2015 UTC,"This only states fromList . toList = id as a law, not the reverse. toList just changing to an empty/singleton list should be law abiding. Though having fromList would have to throw out elements, which seems kind of unsafe for a literal."
haskell,39x1wo,htebalaka,1 point,Wed Jun 17 19:17:57 2015 UTC,"The issue is that toList would have to map both Default and Specific [] to the empty list, and then fromList can only map back to one of them."
haskell,39x1wo,Tekmo,8,Wed Jun 17 21:44:55 2015 UTC,"I always found it funny that the strength of the Haskell type system extends boolean blindness to eleven: we have blind Maybes, Eithers, Lambdas, and so on. Your optional argument breaks that blindness for the Maybe type."
haskell,39x1wo,quchen,8,Mon Jun 15 16:08:12 2015 UTC,I think it's worthwhile having default blind types so that they can be used as a substrate for building non-blind versions wrapped in suitable newtypes.
haskell,39x1wo,Tekmo,0,Mon Jun 15 16:15:59 2015 UTC,"I wrap everything in newtypes, Primitive Obsession exists haskell just as badly as in imperative languages."
haskell,39x1wo,Crandom,6,Tue Jun 16 09:27:17 2015 UTC,possibly useful?  ofMaybe :: Maybe a -> Optional a toMaybe :: Optional a -> Maybe a default :: a -> Optional a -> a
haskell,39x1wo,rampion,7,Mon Jun 15 15:01:08 2015 UTC,"My plan is to propose adding a generalized version of toMaybe to Data.Foldable:  -- You could implement this more efficiently toMaybe :: Foldable f => f a -> Maybe a toMaybe = listToMaybe . toList   Then you could use the Foldable instance for Optional to use this function.  Similarly, you can generalize ofMaybe to work for any Alternative:  ofMaybe :: Alternative f => Maybe a -> f a ofMaybe  Nothing  = empty ofMaybe (Just a ) = pure a   I'll probably add something like default, too, although under a different name since default is a keyword."
haskell,39y2lp,Kiuhnm,15,Mon Jun 15 18:58:05 2015 UTC,"Haskell in many ways remind me of Baldurs Gate. You'll spend the first 8 hours talking to inn keepers and getting slaughtered by lvl 1 goblin. But once the story takes off, all you can remember is how freaking awesome Baldurs Gate is."
haskell,39y2lp,enzain,3,Mon Jun 15 19:49:18 2015 UTC,"Deus Ex is another masterpiece which bored me to death at the beginning. Also, its dated (even back then) graphics engine didn't help. But I'm glad I stuck with it because it's the greatest game I've ever played.  If Haskell were a game, it'd be Deus Ex."
haskell,39y2lp,clrnd,1 point,Tue Jun 16 11:21:55 2015 UTC,"Haskell is Godhand, don't mess with me bro.  It's fast, hard, hipster, intelligently designed but only if you care to look past it's ugly graphics."
haskell,39y2lp,vagif,1 point,Tue Jun 16 13:41:34 2015 UTC,"Shoot, i never got past 1lvl goblins."
haskell,39y2lp,hamishmack,9,Tue Jun 16 04:10:17 2015 UTC,I am really keen to improve Leksah for new users.  Am I right in thinking the outstanding issues you had with Leksah are:   It does not validate package names and module names when the user adds new packages or modules (it just fails with an error in the Log pane that might not even be visible). leksah-server crashes on Windows when exiting (kind of embarrassing for a Haskell app).   What other bugs should we be fixing?  What features should we be adding?  What things were hard for a new user to find in Leksah?
haskell,39y2lp,hamishmack,6,Tue Jun 16 01:15:07 2015 UTC,"Here's a list:   I find the external shell annoying. I'd get rid of that. Also, I'd like to see errors/warnings by hovering over the code. Or at least when you click on some line of code the ""Errors pane"" should highlight and show the corresponding error. HLint suggestions should be indicated on the code (errors in red and suggestions/warnings in yellow, for instance). There should be some space or vertical line between line numbers and code. You should be able to close a tab by clicking on it with the middle button (as in many browsers). You should be able to add/delete file from the Files pane. I'd change the layout to make it more similar to VS, Eclipse and Intellij IDEA. Many people are used to have the project tree on their left and other windows at the bottom. Also the windows/panes should be hidden and appear when there's something new to show. I wasn't able to set breakpoints and make the debugger work."
haskell,39y2lp,hamishmack,5,Tue Jun 16 10:56:36 2015 UTC,Thanks heaps!  Some of these would never have made it onto my list (I don't even have a middle mouse button :-) ).  I'll make sure they all get added to the issues list.   I wasn't able to set breakpoints and make the debugger work.   Breakpoints in Haskell can be tricky to reason about at first.  Here is a good example of the kind of confusion that can arise.
haskell,39y2lp,hamishmack,1 point,Tue Jun 16 12:47:37 2015 UTC,"No mouse wheel??? :O  Regarding breakpoints: right click -> ""set breakpoint"" does nothing."
haskell,39y2lp,hamishmack,3,Tue Jun 16 14:02:28 2015 UTC,"No mouse wheel??? :O   Apple mouse (I am lucky it has a ""secondary click"")   Regarding breakpoints: right click -> ""set breakpoint"" does nothing.   Does it say anything in the Log pane?"
haskell,39y2lp,gfixler,2,Tue Jun 16 14:35:45 2015 UTC,"It says  :break Main 4 9 module 'Main' is not interpreted; try ':add *Main' first   Why isn't there a ""Debug"" or ""Start Debug"" option? It's all very confusing to me."
haskell,39y2lp,776865656e,3,Tue Jun 16 14:49:08 2015 UTC,"module 'Main' is not interpreted; try ':add *Main' first   GHCi has found your compiled Main module and is using that.  Unfortunately it cannot set breakpoints in compiled code.  If you touch the file (make a white space change or something) it will reload it as an interpreted module.   Why isn't there a ""Debug"" or ""Start Debug"" option? It's all very confusing to me.   The Debug -> GHCi menu item is a toggle (also on the tool bar) that switches you into ghci mode.  Leksah starts the ghci process with ""cabal repl"" and starts using that instead of cabal for things (where it would have done ""cabal build"" it sends "":rebuild"" to ghci).  Some things do not work without GHCi running so Leksah asks you if you want to start GHCi when you try to do them.  Other Debug Tips  It is handy to know that Ctrl + Enter will send the currently selected text to GHCi or the current line of text if there is no selection.  This could be any Haskell expression to evaluate or a GHCi command.  If you do Panes -> Debugger it will bring up a scratch pad you can use to put commands and expressions in ready to send to GHCi with Ctrl + Enter.  If you make changes to the code it will replay your last Ctrl + Enter command after reloading the change into GHCi.  Panes -> Output uses the pretty-show package to try to display your output nicely using WebKit.  If your expression always outputs HTML you can tell Leksah this in the right click menu of the output pane."
haskell,39y2lp,Darwin226,1 point,Tue Jun 16 15:51:51 2015 UTC,"OK, thank you!"
haskell,39y2lp,razvanpanda,2,Tue Jun 16 16:51:30 2015 UTC,I have added issues 106 to 113 to try to cover these.  Thanks again for the feedback.
haskell,39y2lp,Hrothen,1 point,Sat Jun 20 03:25:44 2015 UTC,I'm back to using Leksah so if you could solve those issues it'd be great!  Why am I back? Because Leksah is fast.
haskell,39y2lp,razvanpanda,4,Sat Jun 20 10:55:38 2015 UTC,Thank you for your service. This might make work a bit more fun.
haskell,39y2lp,Taladar,5,Mon Jun 15 19:49:26 2015 UTC,"Alternative, really nice way of installing ghc+cabal: https://github.com/fpco/minghc  Has ghc-7.10.1 and ghc-7.8.4, both in 32 and 64 bit. The Haskell Platform is nice, but has problems."
haskell,39y2lp,razvanpanda,2,Mon Jun 15 22:38:55 2015 UTC,"The so called ""Haskell Platform killer"" predictably didn't work for me. After it installed, cabal update simply crashes."
haskell,39y2lp,emarshall85,2,Tue Jun 16 09:29:17 2015 UTC,I don't recommend it because it comes with cabal 1.22.0.0 which has compatibility issues with ghc-mod.
haskell,39y2lp,dbushenko,2,Mon Jun 15 22:50:57 2015 UTC,You can build the master branch of ghc-mod in a sandbox and it will work with cabal 1.22.0.0
haskell,39y2lp,tejon,1 point,Mon Jun 15 22:56:24 2015 UTC,"Not on windows, there's a cabal bug where temp lib names go over the character limit and certain libraries ghc-mod requires won't compile because of it."
haskell,39y2lp,0culus_,1 point,Tue Jun 16 01:01:06 2015 UTC,I got it to compile on Windows a few hours ago. Maybe you need to place the sandbox closer to the root so it won't go over the limit?
haskell,39y2lp,0culus_,1 point,Tue Jun 16 01:19:44 2015 UTC,Use the unpack/install trick for the packages which fail to install automatically.
haskell,39wzsx,tailbalance,25,Mon Jun 15 14:13:18 2015 UTC,"A shameless self-plug. Here's how you can implement this library on top of Ether:  ethereal ""Br"" ""br"" type Break = ExceptT Br  break :: Monad m => r -> Break r m a break = throw br  loop :: Monad m => Break r m () -> m r loop m = handleT br id (forever m)"
haskell,39wzsx,int_index,24,Mon Jun 15 15:11:52 2015 UTC,"What reading Haskell papers has done to my brain:   By default, you wrap commands other than break with lift.   Stream of consciousness:  ""you wrap a co-mmand"" wait, co-mmand, what's that? I suppose it must be the categorical dual (whatever the hell that is) of... mmand? Wait, what's an mmand? Oh damn it! Time for coffee."
haskell,39wzsx,hans2504,22,Mon Jun 15 17:00:53 2015 UTC,co-ffee
haskell,39wzsx,5outh,2,Mon Jun 15 17:26:16 2015 UTC,co-py that!
haskell,39wzsx,hagda,1 point,Mon Jun 15 20:20:44 2015 UTC,The complement of Python?
haskell,39wzsx,Soul-Burn,3,Tue Jun 16 12:47:00 2015 UTC,Cofree?
haskell,39wzsx,IceDane,1 point,Mon Jun 15 21:24:56 2015 UTC,For a second I thought you guys were playing the name game. I was trying to sing it in my head but it just wasn't working.
haskell,39wzsx,MrWoohoo,2,Mon Jun 15 23:52:40 2015 UTC,"Oh! By the way, the categorical dual of something is just that thing with all of the arrows flipped backwards."
haskell,39wzsx,5outh,2,Tue Jun 16 14:43:01 2015 UTC,This is why you shouldn't practice co-archery; you might shoot yourself in the foot.
haskell,39wzsx,rpglover64,11,Tue Jun 16 18:22:03 2015 UTC,Wouldn't implementing it in CPS yield better performance? Otherwise there's going to be a pattern match for each bind (something the compiler might optimise away though).
haskell,39wzsx,dnaq,7,Mon Jun 15 16:31:47 2015 UTC,I'm not sure.  I'll just have to benchmark this to find out.
haskell,39wzsx,Tekmo,2,Mon Jun 15 20:07:55 2015 UTC,"I would be curious to see the performance of this in both forms, and against a hand written (tail recursive, I guess?) equivalent."
haskell,39wzsx,kvanberendonck,2,Tue Jun 16 09:51:10 2015 UTC,"I tried something like this yesterday with control-monad-loop (I wanted to see how continue was implemented). In fact control-monad-loop uses a sort of church encoded version of   newtype Loop c e m a = Loop {runLoop ::  m (Either c (Either e a))}   i.e.   newtype LoopT c e m a = LoopT {runLoopT :: forall r. (c -> m r) -> (e -> m r)  -> (a -> m r) -> m r   }   The simpler type just adds another option to Break.  (Here is a job for ether!).  I reimplemented the stuff with the more straightforward type and the differences were no where significant. It was kind of amazing, really how far they tracked each other.  Here's the extended module with both variants, and two of the examples. https://gist.github.com/michaelt/eb738a5b6a7524471e61    The trouble, I think, is that Control.Monad.Loop doesn't take advantage of the Church encoding to write a non-recursive version of loop. (The examples are using foreach which is somewhat different but I couldn't find a difference in other ways.)  Taking advantage of a church encoding or the like would involve rethinking the relation between loop & co, and break and continue -- if I understand what's going on."
haskell,39wzsx,michaelt_,9,Tue Jun 16 13:42:51 2015 UTC,Pros: it's possible. Cons: it's possible.
haskell,39wzsx,literon,6,Mon Jun 15 16:44:53 2015 UTC,what about continue ? :-)
haskell,39wzsx,agrafix,6,Mon Jun 15 16:31:35 2015 UTC,That's in this one.
haskell,39wzsx,tejon,5,Mon Jun 15 18:08:08 2015 UTC,"What's a ""ntinue""?"
haskell,39wzsx,Soul-Burn,3,Tue Jun 16 12:47:22 2015 UTC,"Is this the same as using EitherT?  I.e. loop being runEitherT, and break being left?"
haskell,39wzsx,kraml,4,Mon Jun 15 19:57:03 2015 UTC,"Yes.  This uses ExceptT under the hood, which is equivalent to EitherT."
haskell,39wzsx,Tekmo,7,Mon Jun 15 20:08:17 2015 UTC,Thanks! It is always good to reduce boilerplate by putting such things into packages. I repeated the aliases I mentioned above quite a few times.  $1 /u/changetip
haskell,39wzsx,kraml,6,Mon Jun 15 20:17:30 2015 UTC,"/u/Tekmo, kraml wants to send you a Bitcoin tip for 4,142 bits ($1.00). Follow me to collect it.    what is ChangeTip?"
haskell,39wzsx,changetip,3,Mon Jun 15 20:19:19 2015 UTC,How well does GHC compile ExceptT-loops compared e.g. to an explicit self-recursion loop?
haskell,39wzsx,hagda,4,Tue Jun 16 07:09:39 2015 UTC,https://github.com/joeyadams/haskell-control-monad-loop
haskell,39wzsx,roche,3,Tue Jun 16 05:56:57 2015 UTC,I notice a marked absence of loop $ do ... in favor of loop (do ...). Is this idiom required?
haskell,39wzsx,conklech,8,Mon Jun 15 16:36:33 2015 UTC,No. That's /u/Tekmo trying to dissipate the opinion that Haskell is an unreadable language due to excessive use of symbolic operators.
haskell,39wzsx,int_index,6,Mon Jun 15 16:42:49 2015 UTC,"Oh good; that's fine. I was worried it was related to the magic of ($) and didn't see why it would be.  To me wide parentheses groups are more unreadable than $; maybe because I didn't grow up in Lisp, and always used column-aligned braces in C. But your point is well taken."
haskell,39wzsx,conklech,2,Mon Jun 15 17:07:56 2015 UTC,the magic of ($)   That makes me sad for some reason :(.
haskell,39wzsx,theonlycosmonaut,7,Tue Jun 16 02:11:13 2015 UTC,They are equivalent.  I just try to avoid the ($) operator to make the code more approachable to newcomers.  I'm less picky about this operator's usage in application code (as opposed to library code) because presumably application code would only read by at least intermediate Haskell programmers.
haskell,39wzsx,Tekmo,3,Mon Jun 15 18:13:48 2015 UTC,"I've started doing that as well, where practical, and especially in examples. I find myself preferring it, as well! There's something pleasing about wrapping up a chunk of code in parentheses. I feel the beginning of a long descent towards Lisp..."
haskell,39wzsx,theonlycosmonaut,6,Tue Jun 16 02:09:23 2015 UTC,"The two are syntactically equal, you can use whichever you prefer. I personally prefer the later."
haskell,39wzsx,ocharles,3,Mon Jun 15 16:43:25 2015 UTC,I suppose the parentheses makes it look less like loop is somehow a special construct.
haskell,39wpi8,gallais,9,Mon Jun 15 12:36:19 2015 UTC,"It's a bit unfortunate that all the examples seem to focus on handling effects from left to right in the big coproduct of effects. This could mislead the reader into believing that it is nothing but another stack of monad transformers when, in fact, it is absolutely possible to handle whichever effect you may want to. I guess the code would be a bit uglier though."
haskell,39wpi8,tschrijvers,8,Mon Jun 15 12:40:01 2015 UTC,"You are right. It is entirely possible and valid to handle the effects in a different order. The general results in the paper allow for this (as well as adding new effects during the handling). We did not show any example of that in the paper because it requires a more involved setup, which was not the main focus."
haskell,39wpi8,pchiusano,5,Mon Jun 15 14:09:49 2015 UTC,"I'd very much like to see a writeup of that somewhere, along with code examples that use it. Having an unordered bag of effects that you can handle in any order is very much the point (for me anyway) of algebraic effects. We need to see whether the pain / awkwardness of using your approach in this scenario is better than the equivalent monad transformer code, or something super simple like this recent post.  But regardless, it seems like great work! :)"
haskell,39wpi8,tschrijvers,3,Mon Jun 15 19:55:34 2015 UTC,"Thanks for the compliment :-)  This work is about how to make handlers efficient under the hood and does not focus on a user-friendly front-end.   The idea of tagging different instances of the same effect, already used in MTLX, is orthogonal and can also be used with algebraic effect handlers."
haskell,39wpi8,pchiusano,2,Mon Jun 15 20:40:34 2015 UTC,"This work is about how to make handlers efficient under the hood and does not focus on a user-friendly front-end.   Okay, makes sense, thanks for your reply. I do hope someone picks up the torch and figures out how to make this approach more usable. I think it's very important, even if it might not be of theoretical interest to you. :)"
haskell,39wpi8,michaelt_,2,Tue Jun 16 14:50:40 2015 UTC,"Even in a completely explicit stack of monad transformers, ""it is possible to handle whichever effect you may want to"". There is no need to handle things from left to right, though the things themselves may be thought of as running 'from left to right'. You just need to remember where you left it, which is an unusually minute intellectual demand.    import Control.Monad.State import Control.Monad.Writer import Control.Monad.Reader import Control.Monad.Morph import Lens.Simple  import Pipes import qualified Pipes.Prelude as P  p :: Producer Int (WriterT String (StateT String (ReaderT String IO))) () p = each [1..3] >-> arbitrary_stack  r :: Producer Int (WriterT String (StateT String IO)) () r = hoist (hoist (hoist readerHandler)) p  e :: Producer Int (WriterT String IO) () e =  hoist (hoist stateHandler) r   f :: WriterT String IO () f = runEffect $ e >-> P.print  g :: IO () g = execWriterT f >>= putStrLn  -- > g -- -- -- 1 -- a -- -- 1 -- -- -- 2 -- b -- -- 2 -- -- -- 3 -- c -- -- 3 -- --1a--2b--3c  readerHandler = runReaderT ?? """" stateHandler = evalStateT ?? ""--"" writerHandler = fmap fst . runWriterT   arbitrary_stack = forever $ do    n <- await   a <- get   tell a   liftIO $ putStrLn a >> print n   str <- liftIO getLine   tell $ show n ++ str   b <- ask   liftIO $ putStrLn b   tell b   put (a ++ b)   yield n"
haskell,39wpi8,tschrijvers,6,Mon Jun 15 14:43:25 2015 UTC,"michaelt_: What you are showing for monad transformers does not correspond to running algebraic effect handlers in a different order. The idea of changing the order is to change the interaction between the two effects (if they don't commute). This is achieved by running algebraic effect handlers in a different order and by stacking your monad transformers in a different order. My Haskell'14 talk on ""Effect Handlers in Scope"" illustrates this (the decr example):  http://people.cs.kuleuven.be/~tom.schrijvers/Research/talks/haskell2014.pdf"
haskell,39wpi8,michaelt_,3,Mon Jun 15 14:53:27 2015 UTC,"@tschrijvers how do you justify the point of departure, which appears on page 3 of the slides:   Monad Transformers        Algebraic Effect Handlers         No       - composition -       Yes"
haskell,39wpi8,tschrijvers,4,Mon Jun 15 18:34:03 2015 UTC,"The point there is that the structure imposed by effect handlers allows you to combine different effects in a systematic way. (The caveat is that it comes at the cost of more restricted expressivity.)  Here is the video of the talk, if you want to hear what I said with the slides. https://www.youtube.com/watch?v=q2TRONftCcg&list=PL4UWOFngo5DXuUiMCNumrFhaDfMx54QgV&index=40"
haskell,39wpi8,michaelt_,1 point,Mon Jun 15 20:17:41 2015 UTC,"Yes, at slide 3, you say that 'previous research' has shown that there are all kinds of problems with composition of monad transformers."
haskell,39wpi8,michaelt_,2,Mon Jun 15 20:49:19 2015 UTC,"Yes, I was only objecting to this remark of gallais:   This could mislead the reader into believing that it is nothing but another stack of monad transformers when, in fact, it is absolutely possible to handle whichever effect you may want to.    which definitely will mislead many readers into thinking that 'it is not possible to handle whichever effect you may want to' even in a grotesque explicit transformers-style stack."
haskell,39wpi8,edwardkmett,5,Mon Jun 15 15:10:11 2015 UTC,"What I meant is that State s (Maybe a) and Maybe (State s a) are fundamentally different whereas using Free (State s + Maybe) a lets you pick one of these two (or any other for that matter, cf the logging example in the paper) at handling time."
haskell,39wpi8,rpglover64,13,Mon Jun 15 14:50:02 2015 UTC,".. with all the usual Codensity effect handling problems in terms of cost of reflecting upon the ""effects"" multiple times, and being too big to properly handle Reader. It slightly wins over the mtl when used linearly at the expense of all the lazy state and lazy writer examples. =("
haskell,39wpi8,tschrijvers,3,Mon Jun 15 21:46:32 2015 UTC,"I was wondering, as I was reading the intro, if it fell victim to the same issues. I wonder no more.  I almost wish you'd write something that isn't a reddit comment explaining what's wrong with alternatives to mtl for handling effects (kinda like your talk about alternatives to type classes), but I know you have other things to do with your time."
haskell,39wpi8,rpglover64,5,Tue Jun 16 13:30:10 2015 UTC,"The phrases ""fell victim to"" and ""what's wrong with alternatives to mtl"" are overstatements. The situation is not black and white; there are respective merits. For instance, because effect handlers restrict themselves to the effects that compose nicely, you don't have to write a quadratic number of lifting instance."
haskell,39wpi8,edwardkmett,5,Tue Jun 16 15:02:21 2015 UTC,"The phrases ""fell victim to"" and ""what's wrong with alternatives to mtl"" are overstatements.   Granted. I was keeping the ""Type Classes vs. the World"" talk in mind; implicits vs. coherent type classes isn't black and white either, but Ed's presentation is pretty opinionated in its defense of type classes, and I expect a similar strength of opinion in an argument for the mtl.  In both cases, the community (and especially the neophytes) are much more familiar with the disadvantages of the standard Haskell approach than with the disadvantages of the alternatives, so I appreciate the frequent reminders of the advantages of the current approach."
haskell,39wpi8,rpglover64,4,Tue Jun 16 18:03:03 2015 UTC,"I'll probably do an 'mtl vs. the world' talk at some point, laying out the benefits and trade-offs of known effect system approaches, but I'm just now getting back to boston after a month away from home. I have to give a talk tomorrow, but it'll be a much lighter affair. =)"
haskell,39wpi8,edwardkmett,1 point,Wed Jun 17 01:39:12 2015 UTC,"Just to check, neither ether nor monad-classes have the issues that Codensity approaches have?"
haskell,39wpi8,jkarni,2,Fri Jun 19 14:06:32 2015 UTC,The former trades this in for vastly noisier explicit tag use and the latter for having no next to no inference whatsoever and having to use explicit signatures for anything that may ever be polymorphic. Pick your poison.
haskell,39wvsa,jpvillaisaza,3,Mon Jun 15 13:38:46 2015 UTC,Wouldn't it be better to run both functions on the exact same input list? Is there a way to duplicate an unevaluated thunk in such a way that it gets evaluated twice (once for each duplicate) for this kind of purpose?
haskell,39wvsa,Taladar,2,Mon Jun 15 22:25:31 2015 UTC,"Perhaps, the construction of the source data takes a considerable amount of time inside the measured evaluation. And it appears in both compared expressions.  If we are interested in comparing the implementations of reverse, we'd want to substract that common part. (Actually, I'd expect much more than being 2-times faster.)"
haskell,39wvsa,imz,4,Mon Jun 15 14:36:02 2015 UTC,Isn't that the purpose of the env?
haskell,39wvsa,sccrstud92,3,Mon Jun 15 20:46:07 2015 UTC,"Aha. My comment pertained to the first simple part (with clockSomething (obverse [1..1000000]). Now, thanks to your answer, I'm learning a bit of criterion."
haskell,39wvsa,imz,2,Mon Jun 15 21:11:28 2015 UTC,Oh sorry! Didn't realize. That is a good point.
haskell,39w49u,afroisalreadyinu,14,Mon Jun 15 07:32:48 2015 UTC,"God, all those (>>?), (==>), which are actually all the same (>>=) function. I guess that could be weird and non-intuitive to a beginner, but I also think adding more and more operators might lead to misconfusion as well.  It’s always simpler to learn one abstraction and reuse it wherever it’s possible than duplicating every now and then, even though it’s for educational purposes here. Just meta-thinking about that habit people have to follow when teaching new concepts. I tend to stick to known abstractions – eh, chapter ten and no actual use of applicative functors and monads while LYAH introduced them quite quickly? Am I the one only one who thinks something is wrong?"
haskell,39w49u,_skp,10,Mon Jun 15 10:06:58 2015 UTC,"I don't think RWH is a good tutorial on Haskell or FP. It's got some great content but you should learn first from something like LYAH, then come to it next."
haskell,39w49u,jaybee,7,Mon Jun 15 11:07:16 2015 UTC,"Am I the one only one who thinks something is wrong?   RWH follows the ""monads are strange, hmkay?"" approach that was quite common in 2008. Although Control.Applicative gets used the Applicative class is never mentioned at all. :/  I guess I should add Applicative to the list of missing stuff.  EDIT: I've noticed that almost no one else has edited that answer. If you find stuff like this, feel free to update it, it's a community wiki answer for a reason :)."
haskell,39w49u,qZeta,4,Mon Jun 15 14:05:30 2015 UTC,"Ah! Well, fair enough then. But we’re in 2015, and I don’t think monads are strange at all. Such thinkings make them strange. If you introduce monads to the beginners in the first place, they’re quickly demystified and people can say “oh! that’s just that!” whereas if you keep telling your audience that “monads are strange and utterly hard to get your feet wet with”, well, yeah, you just get people think that monads are hard. But they’re not."
haskell,39w49u,_skp,8,Mon Jun 15 14:22:23 2015 UTC,I like the typeclassopedia approach a lot more than the RWH one:   Hey new guy. Look:   that's a typeclass here's how Functor's defined; there are several laws here's how Applicative's defined; there are several laws here's how Monad's defined; there are several laws do is syntactic sugar.   *done*
haskell,39w49u,qZeta,4,Mon Jun 15 14:28:02 2015 UTC,"I thought all those were a setup and expected a ""instead of using all these custom operators you can use bind (>>=)""."
haskell,39w49u,codygman,3,Mon Jun 15 18:31:30 2015 UTC,"I thought so, but the final statement never came up. A pity. :)"
haskell,39w49u,_skp,2,Mon Jun 15 23:48:22 2015 UTC,Isn't Real World Haskell outdated or abandoned?
haskell,39w49u,minipump,3,Mon Jun 15 13:00:11 2015 UTC,"I think I remember /u/Tekmo and /u/bos talking about going through and updating it, but I don't know if anything ever came of that."
haskell,39w49u,Hrothen,6,Mon Jun 15 17:43:46 2015 UTC,We have.  Bryan O'Sullivan is working on setting it up so that people can contribute fixes and improvements but I think it will take him some time.
haskell,39w49u,Tekmo,3,Mon Jun 15 18:14:55 2015 UTC,"That's good to hear, I vastly preferred RWH over LYAH when I was starting out."
haskell,39w49u,Hrothen,1 point,Tue Jun 16 01:02:17 2015 UTC,Possibly both
haskell,39uwys,aseipp,16,Mon Jun 15 00:16:46 2015 UTC,"Version number 1.22.4.0 (was 1.22.2.0).    So with this fixed, what's left to compile ghcjs with stock ghc?"
haskell,39uwys,vagif,3,Mon Jun 15 02:51:05 2015 UTC,"I believe the second issue (user package database location) refers to #10232, which was also fixed in 7.10.2.  So, hopefully nothing? :)"
haskell,39uwys,dkubb,12,Mon Jun 15 11:48:31 2015 UTC,"I'm pretty happy with the amount of reported issues this release has fixed (the issue tracker says 100 of them, but that's a bit inflated), so if you get a chance, do test it so I can just kick it out the door next week and be done with it. That'd be swell.  As usual, thanks to all the users for their reports.  Tentative release notes are here."
haskell,39uwys,CharlesStain,5,Mon Jun 15 00:22:27 2015 UTC,FYI there are two duplicate lines in the known bugs section of the release notes.
haskell,39uwys,cies010,6,Mon Jun 15 01:06:44 2015 UTC,Fixed.
haskell,39uwys,adamgundry,7,Mon Jun 15 01:23:00 2015 UTC,"Several performance-related issues inside GHC have been fixed. As a result, you should see improved compilation times and memory usage (issues #10397, #10370, #10422).   Yay!"
haskell,39uwys,cies010,5,Mon Jun 15 05:49:46 2015 UTC,"you should see improved compilation times and memory usage   Compared to 7.10.1 or to 7.8.4? Just out of curiosity: do we actually measure these things in a benchmark to get a grip on perf regressions? (I remember seeing some automated benchmark suite for GHC, but it might have been a memory from my dreams)"
haskell,39uwys,mallai,8,Mon Jun 15 08:41:06 2015 UTC,Joachim Breitner has been doing some great work in this area. I believe the latest tool he's put together is https://perf.haskell.org/ghc/
haskell,39vba9,jradloomy,2,Mon Jun 15 02:32:43 2015 UTC,"Did you see http://phaazon.blogspot.co.uk/2014/11/foreword-abstracting-what-shaders-are.html ? Seems similar, not sure what the status of that one is.  Code can be found here: https://github.com/phaazon/ash"
haskell,39vba9,sdroege_,2,Mon Jun 15 11:41:43 2015 UTC,"I’ve saved that project for later, but I have some new code on my laptop not pushed upstream yet. Interesting /u/jradloomy is working on that as well. Does it work?"
haskell,39vaqj,dalaing,1 point,Mon Jun 15 02:27:39 2015 UTC,Cofun sounds scary!
haskell,39vaqj,Crandom,7,Mon Jun 15 09:36:03 2015 UTC,That's just cultural conditioning.  Producing fun takes work.  Cofun is all about consuming the fruits of those labours.
haskell,39vaqj,sacundim,1 point,Mon Jun 15 10:03:36 2015 UTC,Not if you've already had cofun with free monads.
haskell,39vaqj,BlackBrane,1 point,Mon Jun 15 22:49:29 2015 UTC,"Cool, thanks. I'm looking forward to working through some of this.  Hopefully the video of that talk turns up before long."
haskell,39vaqj,mreeman,1 point,Mon Jun 15 10:37:08 2015 UTC,Awesome. Your first part was quite enlightening
haskell,39tumu,AaronRoth,26,Sun Jun 14 18:44:51 2015 UTC,We're actually in the process of working on implementing this proposal based on an earlier proposal this year.
haskell,39tumu,edwardkmett,15,Sun Jun 14 21:19:59 2015 UTC,"Relatedly: if this is the kind of discussion you'd like to be aware of or be involved in, please subscribe to the libraries mailing list.  I periodically bring it up because I really like the idea of there being   more people involved in the libraries discussions, and  less friction/alarm/surprise when the changes roll out."
haskell,39tumu,dalaing,4,Sun Jun 14 22:42:01 2015 UTC,"Okay seriously, does this kind of decision still happen on a mailing list because of genuine issues with all other options? Is there a reason beyond simple inertia to pick such an awkward venue?"
haskell,39tumu,tejon,5,Mon Jun 15 00:58:26 2015 UTC,"It's not my call, but I can see some reasons for it.  I can imagine having something that is focused specifically on the topic of library proposals, is archived, searchable, and can host a thoughtful discussion over a span of months is helpful to the goals of the libraries committee.  The haskell-cafe mailing list seems to be going strong, so I can imagine that's also a soft point for mailing lists being something that reaches and is accepted by the community.  I'm struggling to think of other avenues that tick those boxes."
haskell,39tumu,dalaing,8,Mon Jun 15 01:26:37 2015 UTC,"I can imagine having something that is focused specifically on the topic of library proposals, is archived, searchable, and can host a thoughtful discussion over a span of months is helpful to the goals of the libraries committee.   Agreed. But a hosted forum, or even a newsgroup, would satisfy all those constraints with the added benefit that for new users the interface for the archive and search is the same as for actual participation. If I join the mailing list now, I don't get twenty years of emails that I can browse for context; I have to go to the web archives, and holy shit are they ugly and hard to navigate, because email formatting conventions are a different world and threading is not an inherent concept.  Make it a newsgroup and Google takes care of most of that for you now, plus you still have the option of downloading it all to a local client for offline access if that's still a concern for anyone (it might be). Forum software loses the latter benefit, but gains twenty years worth of improvements to organization and interface.  I get how it would be an inconvenient transition for existing users, because their own local archives would no longer be in the same place as new conversations. But that's exactly the price being levied on newcomers, and I don't see a reason beyond ""been there, got mine, your turn.""  Granted it could be a deliberate barrier to entry, to cut down on chatter. Putting aside the likelihood that chatter would be less of an issue in a more modern format, at least this would be a reason; I could accept it. Not agree with it, and not want to interact with a bunch of exclusionary hipsters, but the wall would have a stated purpose and I could just walk away from it.  But I'm pretty sure that's not the case, and it's mostly just inertia as I surmised. And I think it's causing problems. Despite really wanting to participate, I still haven't been able to hold my nose long enough to subscribe to yet another load on my inbox, and I don't think I'm such an outlier that nobody else is similarly dissuaded. So this is me agitating to bring attention to the issue. (In a place where the chance of decision-makers paying attention is very low. Never said I was a good agitator...)"
haskell,39tumu,tejon,10,Mon Jun 15 02:05:15 2015 UTC,"Agreed. But a hosted forum, or even a newsgroup, would satisfy all those constraints with the added benefit that for new users the interface for the archive and search is the same as for actual participation. If I join the mailing list now, I don't get twenty years of emails that I can browse for context; I have to go to the web archives   ...and that's what http://gmane.org/ is great for... it exposes most relevant mailing lists via NNTP, and allows you to instantly access a malinglist's past discussions in your MUA (assuming your MUA also supports NNTP-folders), with proper mail headers allowing to reply w/o breaking the threading (which is one of my pet peeves...)"
haskell,39tumu,hvr_,4,Mon Jun 15 06:14:22 2015 UTC,"I highly doubt newsgroups would increase participation. For all the bad things that can be said of email, it does have a low barrier of entry.  I also don't see the inbox problem you mention, any good mail provider supports automatic sorting of emails into folders."
haskell,39tumu,Taladar,3,Mon Jun 15 09:07:31 2015 UTC,Cool - that makes sense.  I guess I'd just kind of forgotten about newsgroups :)  There would be some unknown-sized risk that you might lose more people who are already participating and are happy enough with a mailing list than you'd gain from migrating to something else.  Would be interesting to see what the people involved with the list thought.  I'm basically for anything that gets more people involved - although with all other things being equal I'd rather not lose anyone who has already been participating.  Good luck with the agitation :)
haskell,39tumu,dalaing,1 point,Mon Jun 15 02:13:39 2015 UTC,As opposed to?
haskell,39tumu,pmpt,4,Mon Jun 15 01:23:59 2015 UTC,"For the record, https://ghc.haskell.org/trac/ghc/ticket/10365"
haskell,39tumu,hvr_,8,Mon Jun 15 09:14:41 2015 UTC,"As one of the loudest proponents of that, you can count on my +1 whenever it comes up. I protested especially loudly when (<>) was stolen away from Semigroup to make it type-specialized for Monoid, which I still feel was a big mistake.  But I think the feeling was that there's only so much global breaking change you can do at once. AMP was big enough, so we'll probably wait for that to settle in a bit first.  EDIT: I'm wrong about waiting. /u/edwardkmett reports elsewhere in this thread that GHC HQ is already working on implementing this."
haskell,39tumu,yitz,6,Sun Jun 14 19:26:09 2015 UTC,"I protested especially loudly when (<>) was stolen away from Semigroup to make it type-specialized for Monoid, which I still feel was a big mistake.   Wait, <> is still a class-method of Semigroup, so is it really stolen? Wouldn't we simply generalize <> to Semigroup again? Would that even break any code?"
haskell,39tumu,RedLambda,5,Sun Jun 14 20:29:36 2015 UTC,"Once we make Semigroup a superclass of Monoid, less will be broken. But it's still two different types, so there will be cases where type inference will get it wrong.  One quick example: GHC doesn't always generalize types in where clauses. So an expression in a where clause without an explicit type signature could be typed as Semigroup where until now it was typed as Monoid. That would lead to a new type error if you later try to use mempty in a context whose type unifies with the type of that expression."
haskell,39tumu,yitz,9,Sun Jun 14 20:52:46 2015 UTC,The generalization problem you are talking about isn't actually a concern here.  It'll pick a monomorphic type for the instance parts due to the NoMonoLocalBinds or NoMonomorohismRestriction.   Adding a layer to the typeclass hierarchy has zero effects on that phenomenon and introduces no new chances for ambiguity.
haskell,39tumu,edwardkmett,1 point,Sun Jun 14 22:36:23 2015 UTC,"Excellent, thanks!  So the only significant breakage will be similar to AMP breakage - people defining Monoid instances will now be required to provide Semigroup as well. Is this correct?"
haskell,39tumu,yitz,2,Mon Jun 15 16:10:14 2015 UTC,"Correct. The tentative plan is to add the class to base in 7.12, expose it in Prelude in 7.14, and make the superclass constraint go live in 7.16, with suitable warnings as it goes, so 7.12 will be a lot like 7.8 for the AMP, but with a slightly longer build up to the cut over."
haskell,39tumu,edwardkmett,10,Mon Jun 15 19:22:05 2015 UTC,Please fix the Monoid instance for Maybe a first.
haskell,39tumu,pigworker,8,Sun Jun 14 20:37:30 2015 UTC,Which new instance do you have in mind?  There are at least two:  instance Monoid a => Monoid (Maybe a) where     mempty = pure mempty     mappend = liftA2 mappend  instance Monoid (Maybe a) where     mempty = empty     mappend = (<|>)
haskell,39tumu,Tekmo,10,Sun Jun 14 20:46:53 2015 UTC,"The one which corresponds to the use of Maybe for modelling failure with prioritised choice. The name goes with the semantic idea, even if there are other semantic ideas which involve representationally isomorphic structures.  No instance of Alternative or MonadPlus should ever do other than duplicate a Monoid instance. And when we have higher-order constraints, we should dispose of the surfeit of operators.  I'm in a cleft stick here. I don't like the fact that Haskell effectively prioritises control operators over boring effectful operations. But that's the situation and it's not going to change. Accordingly, the monoidal structure that comes from the Maybeness of a Maybe type should be prioritised over the lifting of monoidal structure on the underlying value type. That is, Maybe v is the type of computations for v which have failure and prioritized choice, not the type of v values in the presence of failure."
haskell,39tumu,pigworker,9,Sun Jun 14 20:59:30 2015 UTC,The only real upgrade path we have for the Monoid for Maybe is to switch it to the addition of a point to a Semigroup.   Anything else would randomly change the semantics of large swathes of existing Haskell code silently.
haskell,39tumu,edwardkmett,11,Sun Jun 14 21:24:05 2015 UTC,"I thought you might say that.  Sounds like ""success at all costs"" to me.  I have been saying this since the bad choice had only just happened. And now I'm getting the ""well we can't change it now"" treatment?"
haskell,39tumu,pigworker,5,Sun Jun 14 21:40:36 2015 UTC,"Personally, I happen to think that the Maybe-as-upgrading-a-semigroup-to-a-Monoid instance selection is perfectly reasonable.  I'm not in a hurry to push for all monoids being consistent with an unrelated class on a completely different kind in another hierarchy.  Many folks like Monoids to use mappend = liftA2 mappend, and mempty = pure mempty, as it is a reasonable choice with even more instances than the one you favor here, which is also inconsistent with your vision, so I don't think you'd get uniform acceptance. There are far more of those out in the wild than cases where it lines up with MonadPlus/Alternative. The one real ""go to"" example of your proposed law is [a] -- which gets its status as such by being the free monoid, so any other instance would be quite surprising!  The current Maybe-as-upgrading-a-Monoid-to-a-Monoid is just terrible, however."
haskell,39tumu,edwardkmett,9,Sun Jun 14 21:53:15 2015 UTC,"You seem to be willing to allow Maybe to stand just as a 1+ type operator with no particular semantic concept behind it, rather than as the consistent deliverer of computations with failure and prioritised choice. I think that's bad design. Moreover, I routinely enjoy using systematic monoid operations like foldMap as control operators, assuming I've avoided importing the parts of the library that would induce the wrong semantics.  I have no objection to upgrading semigroups to monoids. My objection is merely to that being erroneously conflated with prioritised choice."
haskell,39tumu,pigworker,11,Sun Jun 14 22:01:35 2015 UTC,"Of course, silent change is a legitimate concern. It's time programming language design acknowledged change over time. Instead we have 1984ism, where everyone has to update with whom they have always been at war."
haskell,39tumu,pigworker,2,Sun Jun 14 21:48:05 2015 UTC,anywhere I could read up on how that'd look like?
haskell,39tumu,sambocyn,7,Sun Jun 14 23:20:19 2015 UTC,No. But that's only because people haven't thought about it. We should.
haskell,39tumu,pigworker,2,Sun Jun 14 23:23:50 2015 UTC,Is gofmt a step in the direction you're thinking about?
haskell,39tumu,rpglover64,3,Mon Jun 15 15:26:05 2015 UTC,"Do you have some concrete examples? I doubt that I have ever used that Monoid instance in my own code, and I can't remember ever having come across it being used that way in a library in any obvious way."
haskell,39tumu,yitz,3,Sun Jun 14 21:41:56 2015 UTC,"I've used it ""in the wild"" on monoids that have expensive units."
haskell,39tumu,edwardkmett,6,Sun Jun 14 21:50:26 2015 UTC,No instance of Alternative or MonadPlus should ever do other than duplicate a Monoid instance   Why would you want two type class instances to do the exact same thing?  That seems like a waste of an instance.
haskell,39tumu,Tekmo,3,Sun Jun 14 21:31:58 2015 UTC,"A regular happening in my world is that I write down a newtype constructor with the semantics I want, for which the Monoid rules would derive me a monoid, but because of this particular instance, it's not the monoid I want to use for the Alternative and MonadPlus instances. I am forced to write the bloody thing myself. The automatic derivation works compositionally at the * level, but the instances I really need are for * -> *. Instead, I get random instances which are nothing to do with the conceptual meaning of Maybe.  Much like I want Applicative and Monad to be consistent, I want monoidal structure to be consistent."
haskell,39tumu,pigworker,2,Sun Jun 14 21:55:40 2015 UTC,"Wouldn't you be able to use the derived Alternative/MonadPlus instance?  Many type constructors of kind ((* -> *) -> (* -> *)), like StateT, lift Alternative/MonadPlus instances correctly, analogous to how Applicative type constructors of kind (* -> *) will lift Monoid instances:  instance Alternative m => Alternative (StateT s m) where ...   Is there a specific type constructor you have in mind that does not lift Alternative/MonadPlus in the way that you desire?"
haskell,39tumu,Tekmo,5,Sun Jun 14 22:02:18 2015 UTC,Not if I write Stuff -> Maybe x or the like. I'd rather that type just meant what it said.
haskell,39tumu,pigworker,3,Sun Jun 14 22:11:04 2015 UTC,"Note that ReaderT Stuff Maybe x would do the correct thing.  Then you could wrap that in a newtype and derive Alternative to get the behavior you want:  newtype Example x = Example { getExample :: ReaderT Stuff Maybe x } deriving (Functor, Applicative, Monad, Alternative, MonadPlus)"
haskell,39tumu,Tekmo,4,Sun Jun 14 22:44:13 2015 UTC,I really think it's very sad if the meaning of things when seen as components of the *-> * hierarchy are so separate from their meaning in the * world.
haskell,39tumu,pigworker,1 point,Sun Jun 14 23:22:14 2015 UTC,Why?
haskell,39tumu,Tekmo,1 point,Sun Jun 14 23:31:18 2015 UTC,"Meanwhile, please explain why it is actively good design to make Maybe mean both lifted semigroup and failure-with-prioritised choice. Speak up positively for the status quo. Go on."
haskell,39tumu,pigworker,3,Sun Jun 14 23:27:33 2015 UTC,"Like you, I've been against Maybe's Monoid instance being a lifted Semigroup.  I don't know where you got the impression that I supported the status quo.  The instance I prefer is this one:  instance Monoid a => Monoid (Maybe a) where     mempty = pure mempty     mappend = liftA2 mappend   ... not to be confused with the Monoid instance for Maybe in the Prelude, which has a different implementation."
haskell,39tumu,Tekmo,4,Sun Jun 14 23:36:27 2015 UTC,Previous thread on the subject:  http://www.reddit.com/r/haskell/comments/30s1t2/proposal_make_semigroup_as_a_superclass_of_monoid/cpveavt?context=3
haskell,39tumu,gelisam,1 point,Sun Jun 14 21:19:08 2015 UTC,"Ugh! I should have done a little research before I stirred this one up all over again. Thanks for the link, though."
haskell,39tumu,hastor,3,Sun Jun 14 21:23:19 2015 UTC,I think this would be a great thing.  How could anyone write a Spark clone in Haskell without Semigroup being a superclass of Monoid.  It makes no sense!
haskell,39tumu,pythonista_barista,3,Sun Jun 14 19:59:33 2015 UTC,"Could you expand on that a bit? I can see how Applicative and Monad are essential, but how would one be unable to survive without SemiGroup?"
haskell,39tumu,tonyday567,4,Sun Jun 14 20:13:36 2015 UTC,"And while we're breaking stuff, can we go with (+) and zero instead of mappend and mempty?  It's mmadness."
haskell,39tumu,Kaidelong,5,Sun Jun 14 20:52:54 2015 UTC,"While I would like to see this, I doubt that this is ever going to happen in Haskell.  There is indeed a disciplined approach toward this, you can base the numerical hierarchy on Semigroup and work your way up. (+) could also replace (||) for a boolean algebra notation (boolean algebra is really just a group with a dual boolean algebra that switches around the operators, think of the De Morgans laws).  Again, although you could implement this in Haskell, I doubt that this will ever be standard in any way."
haskell,39tumu,tonyday567,3,Sun Jun 14 23:59:38 2015 UTC,"I've been playing around with subhask which opts for (+) and zero, and the numerical heirarchy are instances of Semigroup as you suggest."
haskell,39tumu,twanvl,3,Mon Jun 15 00:38:17 2015 UTC,"Semigroups and groups are usually written with (*) and one instead of (+) and zero. ""One"" is then the identity element, while ""zero"" is an absorbing element. The notation (+) is often reserved for Abelian groups (commutative groups)  In Haskell the issue is that there are at least two ways in which numbers form a monoid: with (+) and with (*). Which one should we pick as the standard one? And what to do with the other? IMO there is no right answer other than to be explicit about it, which is the current situation with the Sum and Product newtypes."
haskell,39tumu,RedLambda,4,Mon Jun 15 08:35:05 2015 UTC,...mno =)
haskell,39tumu,dave4420,3,Sun Jun 14 21:07:43 2015 UTC,"Please, no. (+) implies there should be a (*) in the same typeclass.  I agree that mappend and mempty aren't great names, but they're not that bad, and we already have (<>) as an alternative to mappend anyway."
haskell,39tumu,ocharles,9,Sun Jun 14 21:15:21 2015 UTC,"How does (+) imply a link to (*)? If anything I'd expect negate and to have a full additive group, but just having (+)certainly doesn't suggest a full ring structure, to me."
haskell,39tumu,sambocyn,3,Sun Jun 14 22:49:30 2015 UTC,"yeah, it's more like (*) implies (+), otherwise it would be (+)."
haskell,39tumu,Taladar,5,Sun Jun 14 23:38:47 2015 UTC,Isn't (+) mostly used for abelian groups in maths though while (*) is used for non-commutative ones?
haskell,39tumu,sambocyn,1 point,Mon Jun 15 09:18:21 2015 UTC,"oh, didn't know that was a thing. the (*) you learn as a kid is commutative though so that might take a bit to relearn.   also, often multiplication is juxtaposition (""abc"" is ""a * b * c"") which is even worse for Haskell ;)"
haskell,39tumu,RedLambda,1 point,Sat Jun 20 00:52:30 2015 UTC,"Yes, please do it already!"
haskell,39tumu,prophile,-2,Sun Jun 14 20:19:28 2015 UTC,Why not make it a subclass instead? Then you can get a really simple default definition for (<>) by defining it to (<>).
haskell,39tumu,hexbienium,12,Sun Jun 14 23:55:06 2015 UTC,"Because not all semigroups are monoids. A monoid is required to have a unit mempty, whereas a semigroup needs only the associative binary operation <>."
haskell,39tumu,conklech,6,Mon Jun 15 00:53:48 2015 UTC,"Obligatory meta-comment for voters: Please don't downvote comments below zero on grounds of ""wrongness."" That's not a helpful use of the voting system; it reduces the signal-to-noise ratio, because readers can't tell whether a -5 comment, which is hidden by default, is offensive garbage or a constructive question like this one."
haskell,39tumu,prophile,2,Mon Jun 15 17:13:41 2015 UTC,"I wouldn't call it a constructive question so much as a poor joke which fell a bit flat. Not a bad use for downvotes, all in all IMO."
haskell,39tumu,conklech,1 point,Mon Jun 15 19:41:39 2015 UTC,"... Okay, fair; I obviously didn't read carefully enough to realize it was intentionally stupid rather than just mistaken. :) (Although in my defense I think a reasonable newcomer could ask that question in honest confusion.)"
haskell,39tszu,Kiuhnm,84,Sun Jun 14 18:31:43 2015 UTC,http://fpcomplete.com/ is the best bet for magna cum laude guys.
haskell,39tszu,camaiocco,23,Sun Jun 14 18:49:09 2015 UTC,"This doesn't mean that I've never used simple editors.   ...wait, I hope you're not mistaking Emacs or Vim for ""simple editors"". Don't be fooled by their modest appearance... Emacs is actually a fully fledged operating system in disguise... ;-)"
haskell,39tszu,RedLambda,12,Sun Jun 14 20:36:04 2015 UTC,Emacs is the best IDE I have used for any language by and far.
haskell,39tszu,creichert,1 point,Sun Jun 14 21:00:34 2015 UTC,"For any language? Even, say, Java?"
haskell,39tszu,776865656e,10,Mon Jun 15 00:33:51 2015 UTC,"Even if I miss out on a few features in a polished IDE, I get a significant return on time invested by working with Emacs for most tasks. Most of my Emacs functionality is consistent and reusable between the various programming languages I use as well as daily tasks. I am in control of exactly the features I want and how they behave. If I need to modify some piece of functionality or add a feature, I am able to customize that using lisp and an extremely large and rich history of documentation and functions to learn from. It's also supported on a very large amount of platforms.  I have used IDE's in the past. They still have a learning curve and they still don't work from time-to-time. If there was a feature in an IDE that I absolutely needed then I would probably use it for that specific task and still stick with Emacs for the majority of my work. Some Java tasks might just be that exception.  I understand this is not everyone's cup of tea but it's frustrating to see posts like this when so many of the benefits of a modern IDE for Haskell are available right now (jump to source, integrated REPL, on the fly recompilation and source annotations, code formatting, jumping to and from errors, auto-completion, inline documentation, integrated hoogle, even refactoring). Most of that functionality is built on tools which aren't even specific to Emacs!"
haskell,39tszu,creichert,1 point,Mon Jun 15 03:02:35 2015 UTC,"An $editor fight? Honestly? Do you really think that's useful to him? Does that actually address his concerns?  ""Oh well if you just X and Y and Z then Q Haskell is very nice in $editor"".  Then provide a download that does that. The fact that it's possible to setup some editor to work well with Haskell doesn't mean the editor works well for Haskell.  It shouldn't be that hard."
haskell,39tszu,mbcook,2,Mon Jun 15 19:49:28 2015 UTC,"An ""$editor fight"" is typically about Emacs vs. Vim, whereas I was mostly pointing out that if he referred to e.g. Emacs or Vim as a ""simple editor"" he probably gave up too early.  And fwiw, so far I haven't seen any IDE that handled multiple programming languages that didn't need hours of tweaking before it was usable to me. And I wouldn't recommend any IDE that wasn't able to handle multiple programming language, unless you want to waste time learning a different IDE for every programming language you need to handle in your professional career."
haskell,39tszu,RedLambda,17,Fri Jun 19 15:37:38 2015 UTC,"This is a legitimate gripe. Really, I sympathize. But to clarify, by ""perfectly working"" I assume you don't mean bug-free but mature code assist and refactoring tools. Right?  If IDEs like IntelliJ are an integral part of your workflow and Leksah hasn't worked for you, you're right to stick with Scala for a while longer."
haskell,39tszu,deech,13,Sun Jun 14 20:50:45 2015 UTC,What's considered sophisticated refactoring these days?
haskell,39tszu,alt_account10,4,Sun Jun 14 18:45:53 2015 UTC,"What's considered sophisticated refactoring these days?   This is a great question. I'll answer for the benefit of those not familiar with refactoring browsers.  If you're looking for an example, then IntelliJ IDEA is a great example of a mature, intelligent and comprehensive refactoring tool (for Java).  Refactorings can be performed automatically, without you needing to spend time manually tying up loose ends. (It works very reliably, even for refactorings that touch hundreds or thousands of files.) Because IntelliJ has a deep understanding of your code base and its interdependencies -- it can perform these refactorings reliably and quickly. Common operations like reordering a function's parameters can be performed effortlessly and quickly.  In my opinion, working with a powerful refactoring editor allows you to spend more time in the zone and concentrating on the task at hand. As a software engineer, being in a state of flow and maximising the length of time one can be in flow is extremely important (to me). If you are working with large projects, where refactorings are riskier -- you want the refactoring tool to perform the transformation efficiently and without breakage. (Of course, breakage can usually be spotted by the compiler -- but that's not the point -- having to go around and fix everything up takes time away from your flow.)"
haskell,39tszu,lostalien,11,Tue Jun 16 01:29:18 2015 UTC,"I'm interested in helping you get a working Haskell environment. Have you tried Leksah? If everything installs without issue, I think it might be your best option.  Is using Emacs or Vim out of the question for you? Even if it just means just following these steps for Emacs? If so, that's fine... if Emacs is an option for you though (even only using basic features) I'd highly recommend it since it's what I use and can vouch for.  If you just want a working environment now, I agree with /u/camaiocco about FP Haskell Center. Perhaps try it and let me know if it's missing any of the features you are wanting?  I've also tried Intellij and couldn't get Haskforce installed. Though I didn't put much effort into it because Intellij was always kind of slow for me as well. I haven't tried EclipseFP because last time I tried Eclipse it was pretty slow for me as well.  I used to be a big vim user, but haven't tried making a Haskell environment in it yet. However I think haskell-vim-now as /u/scientia_est_ars recommended would be best."
haskell,39tszu,codygman,3,Sun Jun 14 20:06:16 2015 UTC,"Leksah looked promising but I had some trouble with managing workspaces, packages and modules. I soon learned that you need to follow certain rules for the names (Leksah should validate the names and warn you rather then fail silently!). Then I needed to add a dependency (base). Using the GUI I added the dependency but it didn't stick. My experience is that many things don't work in Leksah and fail silently."
haskell,39tszu,codygman,3,Sun Jun 14 21:16:30 2015 UTC,Can you tell me what version of Leksah you were using? Can you give me some steps to reproduce these things?
haskell,39tszu,codygman,1 point,Sun Jun 14 23:08:50 2015 UTC,"I was using the newest version of three days ago (a new version was released today). As for the steps, sorry but I uninstalled everything."
haskell,39tszu,codygman,2,Mon Jun 15 00:02:14 2015 UTC,"As for the steps, sorry but I uninstalled everything.   If you can even recall what you might have done I'll try and reproduce them myself."
haskell,39tszu,codygman,1 point,Mon Jun 15 02:20:49 2015 UTC,"Leksah   Another thing: when I close Leksah leksah-server.exe crashes:  (1294.1a2c): Access violation - code c0000005 (first chance) First chance exceptions are reported before any exception handling. This exception may be expected and handled. *** ERROR: Module load completed but symbols could not be loaded for C:\Leksah\bin\leksah-server.exe msvcrt!memcpy+0xc5: 000007fe`ff9511d3 488b440af0      mov     rax,qword ptr [rdx+rcx-10h] ds:00000000`0e200000=???????????????? 0:003> k Child-SP          RetAddr           Call Site 00000000`0fa7ddf8 00000000`031ab5be msvcrt!memcpy+0xc5 00000000`0fa7de00 00000000`07f42f40 leksah_server+0x2dab5be 00000000`0fa7de08 00000000`0e0d5d58 0x7f42f40 00000000`0fa7de10 00000000`000002c4 0xe0d5d58 00000000`0fa7de18 00000000`00000000 0x2c4"
haskell,39tszu,scientia_est_ars,1 point,Mon Jun 15 14:10:32 2015 UTC,I've finally managed to get HaskForce to work!!! I don't know what I did differently... but now it's fast and responsive.  edit: Everything worked just fine but as soon as I created the cabal file for my project I got a ghc-modi error :(  It might be a compatibility issue with cabal 1.22.00. I'll try downgrading to the 1.21.00 version.
haskell,39tszu,ephrion,1 point,Mon Jun 15 15:22:01 2015 UTC,"Yeah, I've heard about issues with cabal 1.22 and ghc-mod."
haskell,39tszu,gilmi,1 point,Mon Jun 15 18:36:58 2015 UTC,Now it works! I found out that the plugin by JetBrains is better than HaskForce. I don't know why everyone keeps recommending HaskForce.
haskell,39tszu,meditans,1 point,Mon Jun 15 19:05:35 2015 UTC,"That's interesting, because I've also gotten the impression that HaskForce was best for intellij."
haskell,39tszu,gilmi,9,Mon Jun 15 19:47:09 2015 UTC,https://github.com/begriffs/haskell-vim-now
haskell,39tszu,creichert,15,Sun Jun 14 19:33:23 2015 UTC,"So, there's stack which is just coming out, and seeks to make the whole ""getting started with Haskell"" thing nicer.  The best editors for Haskell are emacs and vim. Both have quite good tooling support in the form of plugins, with emacs probaby coming out a bit ahead. Spacemacs is a pretty good batteries-included option if you're willing to give it a go. Enable ""haskell-mode"" in the .spacemacs file and you'll be set.  I've heard that Sublime Text and Atom also have decent Haskell plugins, though I have no experience with those."
haskell,39tszu,gilmi,5,Sun Jun 14 19:07:35 2015 UTC,"how do I enable ""haskell-mode"" in spacemacs?  I'm trying to checkout spacemacs, coming from vim. I have the dependencies install and on $PATH and I add haskell to the list of (setq-default dotspacemacs-configuration-layers '(...)). this got me syntax-highlighting and I can use SPC m h t to get a known function's type, but I would like to get type errors, lints, auto-completion and more types of value under cursor. can you help? pretty please? :)"
haskell,39tszu,yitz,6,Sun Jun 14 19:38:12 2015 UTC,"I can probably help with spacemacs :). Read this: https://github.com/syl20bnr/spacemacs/tree/master/contrib/!lang/haskell then, if you have problems, either pm me here on reddit or go to the gitter chat of spacemacs and ask there."
haskell,39tszu,yitz,1 point,Sun Jun 14 21:20:03 2015 UTC,thanks! I have followed this guide with only some success. I will contact you soon :)
haskell,39tszu,enzain,1 point,Mon Jun 15 04:42:45 2015 UTC,"I don't use spacemacs specifically but I do use emacs.  Some of the extensions for haskell require executables from hackage.  Do you have ghc-mod, hoogle, hlint, stylish-haskell installed? Spacemacs also seems to support ghci-ng, hindent and structured-haskell-mode. I also use codex to generate ETAGS for a cabal project and all dependencies (requires hasktags).  So, as a start try cabal install ghc-mod hoogle hlint."
haskell,39tszu,rezb1t,1 point,Sun Jun 14 20:24:19 2015 UTC,"yes, I have ghc-mod, hoogle, hlint and stylish-haskell installed :)"
haskell,39tszu,enzain,2,Mon Jun 15 04:40:55 2015 UTC,"Some of our developers just use Notepad++, which has syntax highlighting for Haskell, and are happy with it. Personally, I am an emacs user."
haskell,39tszu,Tekmo,27,Sun Jun 14 19:47:18 2015 UTC,"Actually, those IDE's don't understand your code - they can't, because the information just isn't there. What is amazing about them is that they are able to save you so much time despite the fact that the language is low level.  I spent years working in those kinds of IDE. I suppose if someday I have to go back to a job where I need to spend my day using one, I'll survive. But wouldn't it be nice if the reason you spend less time debugging is because of there being many less bugs to begin with? When you express at a higher level what you are actually trying to accomplish, the compiler is better able to assist you get your program right the first time.  There are people working on increasingly better interactive development environments for Haskell. I believe that because of the higher semantic level of Haskell, it will be possible to create an IDE that is far better than anything you see today; I also believe that such an IDE will look quite different than the IDEs you are familiar with today in other languages. We'll see. But it will take time and experience before we get there.  One of the reasons progress was slow in the past on Haskell IDEs was that there was less motivation: once you get the hang of it, development in Haskell is faster, not slower, than development in a traditional language, even with its polished IDE. But you are right, it's important, and I think there is a lot more awareness of that now.   a complete installer/package with language + tools perfectly working!   That was one of the original motivations of Haskell Platform - a first step in that direction. But Haskell Platform fell behind, for various reasons. That had the positive effect that it caused people to investigate and discover new approaches. But it also caused things to become quite confusing and poorly documented for the newcomer, you are right. Things are still in flux right now; hopefully they will settle down again soon."
haskell,39tszu,yitz,-9,Sun Jun 14 19:15:44 2015 UTC,"This is probably my favorite answer, attack minor remarks, ignore the problem at hand, talk about how awesome haskell will become and best of all says:   Things are still in flux right now   for a 20 year old language.  I love haskell and I wish it was the nr. 1 language in world but when people act like this toward someone who genuinely tried his best at joining the community it just annoys me to no end. I get it, it's fun to act all smug, and seeing the votes I can see I am in the minority but still.. could we?? not."
haskell,39tszu,enzain,15,Sun Jun 14 20:09:59 2015 UTC,"yitz was relating an experience he/she has had with Haskell that he/she feels parallels the experience OP was looking for, made a good point that static analysis in most conventional languages is hard and therefore IDEs don't really understand your code, and yitz was also relaying a possible reason as to why the Haskell ecosystem doesn't have these tools.  I don't see anything irrelevant or smug here. IDEs have not historically been a thing we care about, therefore they languish. If you're so concerned, write an IDE."
haskell,39tszu,maxigit,-7,Sun Jun 14 20:27:15 2015 UTC,"yitz was relating an experience he/she has had with Haskell that he/she feels parallels the experience OP was looking for,   That's great except the experience was about how IDEs are inferior, talking about how degrading he feels to use them is.   made a good point that static analysis in most conventional languages is hard and therefore IDEs don't really understand your code   Had absolutely nothing to do with what OP was talking about. But it does make you sound cleaver.   If you're so concerned, write an IDE   I don't need to, haskell already have decent tools, but to set them up can be somewhat convoluted, and especially  if instead of helping people start talking about static analysis of other languages."
haskell,39tszu,maxigit,7,Sun Jun 14 20:47:01 2015 UTC,I'm sure that Haskell IDE plugins would welcome pull requests to fix these bugs
haskell,39tszu,gfixler,20,Sun Jun 14 20:40:52 2015 UTC,"I'm sorry you interpreted what I wrote as an attack - I really didn't intend it to be one.  Haskell is 20 years old as a research language, but very new as a mainstream-track language in industry. I agree with you that the toolset has plenty of room for improvement. My points were:   There were reasons why until now not as much has been done as could have been. Now that Haskell is quickly gaining popularity as a commercial development language, a lot more is being done. But the result of that will be quite different than what you are used to in an IDE that is fine-tuned for languages that are very different in nature than Haskell. Since a very different kind of IDE is needed and we can't just write a regular plugin for an existing one, it will take time until we get there.   In short - it's going to be a fascinating journey. If you're interested - why not jump in and join the fun?"
haskell,39tszu,Taladar,4,Sun Jun 14 21:15:21 2015 UTC,"First off, I am not op merely someone who experienced the same when I first began.  Secondly I may have been a bit harsh, because I know you don't do it on purpose. It is just, I remember how annoying comments like that was when I getting into haskell. And while they fine points on their own to bring up. They don't belong on thread about someone completely new to the language, who is already feeling overwhelmed."
haskell,39tszu,gfixler,7,Sun Jun 14 21:33:03 2015 UTC,What are the killing features an IDE gives you (apart from having to relearn everything each time you try a new language?) that you can't live without ?
haskell,39tszu,Taladar,7,Sun Jun 14 21:31:24 2015 UTC,"I'd like to have:   good auto-completion + inline documentation good debugger + REPL smart indentation and formatting during typing errors / warnings / types annotations in the code refactoring (maybe less useful in Haskell???)   ... and the IDE must be fast. It's OK if the annotations are delayed, but the typing, the formatting, etc... must be instantaneous. Also, I'd like to have the column selection mode."
haskell,39tszu,gfixler,7,Sun Jun 14 21:46:36 2015 UTC,"You get pretty much that in Emacs/Vim. The main difference I've seen between IDE vs Emacs/Vim is IDE are usually ""mouse centric"". Being able to touch type usually reduces lots the need of a mouse."
haskell,39tszu,OmnipotentEntity,-1,Sun Jun 14 22:07:01 2015 UTC,"What I like about Windows (as opposed to Linux) is that you can do simple things without any prior knowledge because the interface is intuitive. Visual Studio is an example of such an approach. Moreover, you learn by doing because every menu and option tells you the corresponding keyboard shortcut and so you become more and more efficient."
haskell,39tszu,benediktkr,12,Sun Jun 14 22:14:08 2015 UTC,"There's a hard limit to how efficient I could become in Windows, and I hit it, hard, years before I switched to Linux. I had thought I knew all there was to know until that point, but Linux opened my eyes. 9 years later, I still have to work on Windows at work, and I hate it. Everything grinds to a halt for me, and literally eveything is more difficult. Some things are next to impossible, and many are just a little bit worse, but pretty much nothing is better. I call Windows the ""Death by a Thousand Cuts."" This has been my experience this past decade. To me, the cost of discoverabilty is speed and composability. UIs let me do only what they've decided well ahead of time what I'm allowed to do."
haskell,39tszu,benediktkr,3,Sun Jun 14 23:44:11 2015 UTC,"To me, the cost of discoverabilty is speed and composability.   True about the Windows style of discoverability but vim's and emacs' help system do show that you can still make a tool discoverable even without limited menus (limited in size I mean, you could never use that approach for vim or emacs with its thousands of functions)."
haskell,39tszu,maxigit,6,Mon Jun 15 09:33:11 2015 UTC,"I've taught Vim at my company, and the thing I taught was its composable language, showing how it's very like English, and thus not really hard to learn, and not thousands of hotkeys, but rather, dozens, which compose like a natural language into many thousands of statements. You 'speak' to Vim. Learn a new verb or noun, and you can fold it into the rest of sentences you know how to say. There were a lot of people nodding during the talks. They even asked things like ""So, could I delete this paragraph and the next two with... d... 2... ap?"" Yep! People seemed to get it. Emacs, on the other hand, seems to be thousands of things to remember."
haskell,39tszu,enzain,4,Mon Jun 15 09:40:09 2015 UTC,"Vim certainly has the advantage there. However Emacs Lisp is quite a bit ahead of vimscript in terms of writing extensions, as are some of the built-in tools to facilitate new language modes (parsers instead of regular expressions for syntax highlighting,...). The help system is also superior IMO. So is the multi-TTY attachment stuff when using an emacs server.  Ideally I would like an editor that combines the best aspects of both."
haskell,39tszu,776865656e,1 point,Mon Jun 15 12:54:06 2015 UTC,"I'll never argue in favor of VimL over anything. These days, though, I've been really curious about an Emacs with Vim's language, but built atop Haskell. Yi is supposed to be along these lines, but I don't know how far it gets in that quest."
haskell,39tszu,codygman,-1,Mon Jun 15 17:13:13 2015 UTC,You can always use the powershell.
haskell,39tszu,enzain,8,Sun Jun 14 23:57:53 2015 UTC,"Not Grandparent.  Yes, you can use the powershell now, it might even work well.  I don't know, I've barely tried it.  I jumped ship way back in 2002.  From what I've seen, powershell operates differently from unix shells.  Things that you want to be there... just aren't.  But it's just close enough to be frustrating.  It screws with my intuition.  When I say intuition let me explain.  You like what you like, and that's fine.  But I don't personally find Windows GUIs to be intuitive.  Frankly, I find them to be a big PITA since Ribbon.  I don't know how old you are, but considering you developed on a C64, you must be around my age or a little older.  Perhaps you've simply forgotten the learned skills it takes to find the Ribbon GUI or the Boxes GUI intuitive.  Skills I've never really learned because I've been outside of the ecosystem.  What I find intuitive and what you find intuitive largely depend on what we've each been exposed to.  And that's why I'm posting I guess.  I take objection to the blanket statement that ""Windows GUIs are easy and intuitive, and Vim/Emacs/Unix is just so cha-raaaaazy."""
haskell,39tszu,verandaguy,1 point,Mon Jun 15 01:21:52 2015 UTC,"That has been rapidly changing for the last 10 years or so. I would argue that for the last 4-5 years it has been the other way around, there are linux distributions featuring GUIs that are far more intuative to new users than the Windows GUI (but of course most people are already used to Windows by now)."
haskell,39tszu,augustss,1 point,Mon Jun 15 15:30:42 2015 UTC,"Yesterday I installed Ubuntu to try the Linux version of Eclipse with EclipseFP.  I needed to create a desktop icon for an app. In Windows I can create a shortcut on the Desktop with a click whereas in Ubuntu it appears that one have to create a .desktop file by hand (or so a guide I read said), which implies that one must know its format. Is this supposed to be user-friendly and intuitive?"
haskell,39tszu,verandaguy,3,Mon Jun 15 15:46:07 2015 UTC,"You can drag-and-drop from the Unity Launcher menu or from the context menu if you right click the application in the file manager.   But shortcuts on the desktop aren't used in the same way as in windows. Most people use the launching method their desktop environment provides (in Ubuntu with Unity, this is the Launcher menu)."
haskell,39tszu,verandaguy,1 point,Mon Jun 15 16:07:43 2015 UTC,"user-friendly and intuitive doesn't necessarily mean fast. It's fine for casual users but and editors are different. It's a tool you'll use probably daily for years, and the entry cost is somehow irrelevant (especially if you learn vim/emacs , because you could use them for absolutely any language). As you said IDEs are user-friendly and intuitive which mean that EVERYBODY can use them, even people which know how to use and ""editors"". This gives editor people a superpower, they can use and IDE and a editor, whereas you don't have the choice and have to use an IDE. Your lack of this superpower is strong enough to make you give up haskell, which is a shame when you think about it : If you had gave up on everything not user-friendly or intuitive your probably won't be able now to walk, read/write , swim etc ...   Funnily, pretty much everybody which has this superpower and have the choice between IDE and editors choses editors, so maybe those editors are more powerfull than you think they are.  Also, you are obviously a ""mouse-person"" and probably can't touch type. In the same way, ""touch typing"" is also a superpower , you can still use a mouse, but also have the choice to not use it for everything ;-)"
haskell,39tszu,jaybee,2,Tue Jun 16 19:53:14 2015 UTC,"good auto-completion + inline documentation   decent auto-completion + out of editor documentation with haddock.   good debugger + REPL   yee.. we still can't get a proper stacktrace, seemes like its impossible to make, all debugging is based around unit tests.   smart indentation and formatting during typing   Hmm.. you'll learn quickly how to type/format pretty.   errors / warnings / types annotations in the code   got it!   refactoring    You mean find/edit right?"
haskell,39tszu,dreugeworst,1 point,Sun Jun 14 21:57:45 2015 UTC,"I just read that one should indent if then else like this:  f x = if <long boolean expression>       then 1       else -1   Therefore, an IDE should put the cursor under the if automatically.  Regarding refactoring, many of the most sophisticated features are related to OOP so I don't know what it'd be possible with Haskell."
haskell,39tszu,penguinland,9,Sun Jun 14 22:04:12 2015 UTC,"Perhaps ""extract function/module/etc"", ""make pointfree/pointful"", ""convert top-level if-then-else to guards/vice versa"", etc? Man, all of this is really making me want to write a Haskell IDE."
haskell,39tszu,tejon,1 point,Mon Jun 15 00:46:30 2015 UTC,HaRe
haskell,39tszu,kamatsu,2,Mon Jun 15 19:07:41 2015 UTC,ah yeah that's possible 100%
haskell,39tszu,tejon,6,Sun Jun 14 22:08:54 2015 UTC,"I'm more than a little surprised you haven't tried using just an editor to work with Haskell. I do my development in Vim (okay, neovim, which is extremely similar), and I've got a few plugins that do syntax highlighting (obviously), import and function name completion for any installed libraries, linting and syntax checking, ghc-mod for CTE detection, the list goes on.  IDEs don't always have all the answers, and if that's all you're used to using, I'd strongly suggest you try picking up sublime or NPP, if not vim or emacs. They're all extendable much easier than Eclipse or IntelliJ, so worst case you can always write your own extension to fit your taste - something I think a LOT of programmers forget you can do."
haskell,39tszu,kamatsu,-7,Sun Jun 14 23:56:40 2015 UTC,I don't believe that you can add auto-completion and refactoring as easily as you make it sound. I'd probably be better off writing my own IDE from scratch if I wanted the perfect solution (for me).
haskell,39tszu,tejon,4,Mon Jun 15 00:17:30 2015 UTC,Personally I'm totally addicted to M-/ in Emacs.  It's a completion that works in any language.
haskell,39tszu,ForTheFunctionGod,3,Mon Jun 15 10:31:59 2015 UTC,"To each their own, but it's not necessarily as difficult as some might make you believe. There already exist numerous frameworks for this kind of stuff. Look up YouCompleteMe - it's basically an API between Vim and almost whatever you're using to compile or interpret your code. On top of that, it does just come with bindings for C/C++ over Clang, but there are dozens of other language bindings out there, ripe for the download!  /shameless plug for YCM"
haskell,39tszu,agocorona,1 point,Mon Jun 15 01:04:51 2015 UTC,"Also worth mentioning that refactoring, granted, is certainly nontrivial in Haskell, but the language makes it difficult to write coherent code without adhering to patterns and good practices in the first place. I wouldn't count on a ""quick refactoring"" plugin for any editor or IDE out there for Haskell that does as much work for you as, say IntelliJ's refactoring feature does for Java, but I wouldn't place refactoring utilities too high on the priorities list in a Haskell toolchain."
haskell,39tszu,possibly-necessary,1 point,Mon Jun 15 03:48:07 2015 UTC,You think you'd be better off writing your own IDE than learning how to use emacs or vim? Maybe you should just stick to whatever you're using now.
haskell,39tszu,newuser_alkjasdf,-3,Mon Jun 15 11:02:44 2015 UTC,"I didn't say that. I said that I'd be better off writing my own IDE than implementing all the features I need (auto-completion, refactoring, etc...) in vim/emacs."
haskell,39tszu,deech,1 point,Mon Jun 15 11:07:48 2015 UTC,"import and function name completion for any installed libraries   so, auto-completion is already done. No need to implement anything. Refactoring is a different matter, but is so much simpler in Haskell than most other languages anyway that it would probably work very differently than in IDE's if implemented."
haskell,39tszu,Kludgy,12,Mon Jun 15 12:01:43 2015 UTC,"I'm reminded of this blog post. The short version is that people who get really good at using IDEs tend not to adopt new languages because they're not as productive without a good IDE, and the people who get really good at new languages tend not to adopt IDEs because they're not as productive without the new language features that the IDEs don't support yet. Both types of developers can do excellent work, and I suspect both types of developers are important for improving both language design and IDE design.  It sounds like you've gone down the IDE route, and we've gone down the language route. and that's fine. I wish you all the best, and maybe our paths will cross again in a few years."
haskell,39tszu,gaymenonaboat,4,Mon Jun 15 00:24:06 2015 UTC,"Dart is a new language and has had great tools from day 1.  Scala is another great language with powerful features and has good tools.  As you can see, you can have both things."
haskell,39tszu,andrewthad,5,Mon Jun 15 00:44:20 2015 UTC,"Dart is by Google, who can just throw money at it until it shines. Even so, its only compile target is JavaScript.  Scala is built around the JVM. Its purpose is literally to be a better Java. So it too has only a single compile target, and tools designed for Java can be adapted without much hassle.  Haskell targets native binaries across multiple architectures and OSes. (In fact, so far as I know, typeclasses are impossible to represent efficiently on .Net or JVM; taking advantage of one of those ecosystems isn't even an option.) GHC is tuned for time optimization of lazy behavior, and space optimization of immutable structures, two concerns few other languages have; and it does a good enough job to frequently rival languages that were designed for performance. And thus far it's been maintained primarily by a loose association of department heads, postgraduate students, and a few interested non-academics, all of whom do other things full time.  I think you're comparing apples and oranges to Haskell."
haskell,39tszu,gaymenonaboat,2,Mon Jun 15 03:46:28 2015 UTC,"In fact, so far as I know, typeclasses are impossible to represent efficiently on .Net or JVM; taking advantage of one of those ecosystems isn't even an option.)    Typeclasses have nothing to do with it. Typeclasses are actually eliminated entirely from the code by GHC while typechecking."
haskell,39tszu,enzain,1 point,Mon Jun 15 04:38:13 2015 UTC,"Hmm, that does make sense. I recall Eric Lippert commenting in his blog that some types available in Haskell aren't feasible in .Net languages, and since neither F# nor Frege (on JVM) supports typeclasses my mind locked on them."
haskell,39tszu,rezb1t,6,Mon Jun 15 05:48:37 2015 UTC,"Probably Lippert was referring to higher kinded polymorphism, which is incompatible with .NET's reified generics (but not with the JVM's weaker reflection capabilities). It seems like it ought to be possible to fix that, though."
haskell,39tszu,enzain,2,Mon Jun 15 05:51:01 2015 UTC,"Yeah, context was the ability to have a fully generic >>= so that sounds right."
haskell,39tszu,gfixler,6,Mon Jun 15 05:58:51 2015 UTC,"I will come out right away and say that a Haskell-IDE does not exist. There. That said, I sympathise with your woes. An ""all inclusive"" tool chain for Haskell would be a great boon. Let me summarize the options and options that might have been:   EclipseFP has been abandoned. IntelliJ works well enough. At one point, some people tried to implement Visual Studio integration (VisualHaskell). This was abandoned too. leksah is a Haskell-IDE, written in Haskell. While a monumental effort, the fact that it is maintained by only one guy in his free time shows. I tried it once and found it to be complicated and confusing. SublimeHaskell is a plugin for SublimeText that offers type inference, autocompletion, linting, and build error reporting, but due to its dependence on ghc-mod and an older version of haskell-src-exts, I haven't been able to get it to work with GHC 7.10. One can do something with Emacs, I suppose. I don't understand Emacs.   So what's the best set-up? If you ask me, it's the editor of your choice, with a GHCi window on the side. While this may not offer the benefits of a full IDE, you don't have to learn much to get it running and, in my eyes, SublimeText makes VS and IntelliJ look crude and antiquated. I can't quite put my finger on it; perhaps it's their old-ass, black-on-white color schemes, their ""enterprise"" configuration windows that SL replaces with simple JSON-files, or SL's support for multiple cursors. Hell, maybe it's just that the cursor fades in and out smoothly in SL while it blinks harshly elsewhere. Whatever it is - as much as I used to love VS, I couldn't go back to it anymore.    If you really want to promote Haskell, you need to provide a complete installer/package with language + tools perfectly working! You can't ask a beginner (in Haskell) to spend hours on google trying to install the damn thing!   The Haskell platform provides that. It's a standard installer and once it's done, you can open (Win)GHCi and load up a source file, simple as that. The only tool you need in addition is an editor. Occasionally, you have to open up a console window and type cabal install packageSuchAndSuch. No IDE, as said, but simple enough to get running."
haskell,39tszu,tejon,2,Mon Jun 15 09:13:27 2015 UTC,Leksah confusing? I used leksah for years. it is the most complete IDE for haskell. It run both in windows Linux and Mac
haskell,39tszu,gfixler,1 point,Mon Jun 15 22:36:23 2015 UTC,"The new version of the Haskell platform introduced some bugs on Windows.  OK, I'll try SublimeText."
haskell,39tszu,tejon,5,Mon Jun 15 09:33:13 2015 UTC,"I'll agree that it can be a bumpy ride if you expect the same level of support that you get from Visual Studio.  In case you're willing to try something lighter, you could use vim/emacs + ghc-mod, which will give you good autocompletion and error highlighting (although the learning curve for vim may not be worth it, of course).   I think there are plugins for integrating ghc-mod with other editors like Sublime Text, so that might be worth a try."
haskell,39tszu,gfixler,5,Sun Jun 14 18:59:19 2015 UTC,"Did you try installing the Haskell Platform? It kind of encompasses the complete installer/package with language requirement. True, there isn't an IDE, and I don't really notice it cause I'm used to a vim/cmdline workflow, so I can't really comment on how significant that is.  Also, yes, installing and configuring makes using Haskell difficult, but isn't it that way with a lot of software? I remember the first time I tried installing Arch Linux I had no idea what I was doing and configured the boot loader incorrectly and had to start over. But, the next time I tried, I had figured out most of the installation process and installed it successfully. Of course, then I messed up installing the window manager and the graphics card drivers, but eventually I got it all to work. It just took a lot of persistence."
haskell,39tszu,enzain,3,Sun Jun 14 20:10:09 2015 UTC,"The Haskell Platform is the first thing I tried but on Windows cabal init doesn't work because the Haskell Platform uses an old version of cabal. Therefore I downloaded the version 1.20.0 which fixed that bug but then I had other problems (which I don't remember, honestly)."
haskell,39tszu,enzain,5,Sun Jun 14 21:11:55 2015 UTC,"Just found https://visualstudio.uservoice.com/forums/293070-visual-studio-code/suggestions/7756542-haskell. Might be exactly what you're looking for, OP."
haskell,39tszu,enzain,3,Mon Jun 15 02:37:31 2015 UTC,"I would love to see this happen.  Or to be able to purchase a native build of the FP Complete system.  I use Spacemacs right now, but even with this leg up the fragmentation and requirement to fix your own integration issues for features that we can agree should just work, is a lot of lost productivity."
haskell,39tszu,enzain,4,Mon Jun 15 15:41:13 2015 UTC,"In general I suggest you get more familiar with a text editor like atom, sublime, vim, or emacs, before looking into more niche languages like Haskell. IDE support for languages not in the top 5 tends to be pretty bad, whereas text editors tend to have a more active community with tooling support. I found this out myself once I started looking into random lesser mainstream languages that had heavy reliance on *nix tooling in the early years of in my undergrad [1].  For me my workflow is generally a tmux session with vim and a repl. The repl comes in handy for avoiding lengthy compile times, and an interactive development workflow.  In short, your reliance on IDE support will only hold you back when it comes to any non mainstream technologies [2].    [1] even ruby and scala IDE support was bad back then  [2] this isn't to say I don't think IDE's aren't great    edit: rephase the last bit"
haskell,39tszu,gilmi,2,Mon Jun 15 03:32:05 2015 UTC,Your workflow is the exact same as mine.
haskell,39tszu,NSCFType,2,Mon Jun 15 11:57:44 2015 UTC,*hi five*
haskell,39tszu,hdgarrood,9,Mon Jun 15 12:12:57 2015 UTC,"I hear you!, I use windows and I had the exact same experience as you, I even reached the state you are in now. After 20 hours of install errors, missing files and version mismatches; I was on about to give up, when out of what I can only describe as shear luck my program randomly started working.   With all that said, I have loved haskell ever since, and I truly think it's one of the best/most pleasant languages to work with. But that barrier to entry is 100% why haskell is not growning.  From what I've come understand is: if you have used vim on linux all your life then installing is really easy and works great, but for everyone else it's a living hell.  But i guess it follows our motto: Avoid success at all cost"
haskell,39tszu,enzain,7,Sun Jun 14 18:52:20 2015 UTC,"But that barrier to entry is 100% why haskell is not growning.   Haskell is growing. Maybe not as fast as some would like, but I've seen nothing but acceleration forward for as long as I've been a part of the community."
haskell,39tszu,sasquatch007,3,Sun Jun 14 20:22:24 2015 UTC,"Because haskell is awesome, so once you join you won't leave, but reason why it's not growing fast is because of that barrier to entry."
haskell,39tszu,baconated,1 point,Sun Jun 14 20:25:37 2015 UTC,"Why I gave up on Haskell   Because haskell is awesome, so once you join you won't leave."
haskell,39tszu,jeandem,5,Mon Jun 15 00:13:04 2015 UTC,"Not really fair. OP didn't even manage to get his toes in the pool, just stared longingly at the water while fiddling with the rusty latch on the gate..."
haskell,39tszu,Tekmo,8,Mon Jun 15 03:13:36 2015 UTC,You seem pretty good with metaphor. You should write a monad tutorial.
haskell,39tszu,Tekmo,6,Mon Jun 15 09:21:37 2015 UTC,"""A monad is like your mom. Everyone keeps telling you it's easy, and you really hope they're lying."""
haskell,39tszu,Tekmo,1 point,Mon Jun 15 11:07:07 2015 UTC,Oh snap!
haskell,39tszu,gergoerdi,3,Mon Jun 15 17:02:15 2015 UTC,If I'm not wrong we talked in the other thread where I asked about IDEs for Haskell.  I thought I did it but then I found out that some things weren't working because of some errors. So many hours wasted... :(
haskell,39tszu,eaturbrainz,1 point,Sun Jun 14 19:01:21 2015 UTC,"I never got eclipse to work either, but atom as I wrote is working amazing. What error are you getting exactly?  EDIT: Also cygwin terminal with fish is great to use as terminal as well."
haskell,39tszu,ExceedinglyEdible,2,Sun Jun 14 19:06:21 2015 UTC,"ghci_mod didn't work, but now that I think about it, I didn't try Atom on Ubuntu.  On Ubuntu I installed the haskell platform which comes with cabal 1.16 and ghc 7.6.3!!! Maybe I should try something newer but how? I'm not a Linux user."
haskell,39tszu,BethAr,2,Sun Jun 14 19:15:33 2015 UTC,"hmm it should just work on windows, did you add your source files to the .cabal file?  Edit: Remember you can run ghci in the console to see if it has any problems. Try going into your project and type  ghc-mod check  src/Main.hs   assuming you have such a file, ""cabal init"" should provide it automatically for you if i remember correctly"
haskell,39tszu,ccaapton,1 point,Sun Jun 14 19:20:59 2015 UTC,"On Windows 7 64bit SP1   installed MinGHC 7.8.4 (64) https://github.com/fpco/minghc installed Atom   installed ide-haskell installed language-haskell installed autocomplete-haskell installed haskell-ghc-mod ==> ERROR!   Haskell-ghc-mod: ghc-mod failed with error code 1 'ghc-mod' is not recognized as an internal or external command, operable program or batch file.   I'll try to install ghc-mod with cabal install ghc-mod. It says:  C:\Users\Kiuhnm>cabal install ghc-mod Resolving dependencies... All the requested packages are already installed: ghc-mod-5.2.1.2 Use --reinstall if you want to reinstall anyway."
haskell,39tszu,ccaapton,3,Sun Jun 14 21:04:25 2015 UTC,"ctrl + , opens up the settings go to haskell-ghc-mod, and manually add the path of ghc-mod installation: %AppData%\Roaming\cabal\bin\ghc-mod.exe  NB: if you have a sandbox(cabal sandbox init inside your project folder), and you are running cabal install ghc-mod inside that folder then ghc-mod will not be installed globally but only locally for that project. Which you want  to avoid as you want ghc-mod to be installed globally, while other library files you only want locally."
haskell,39tszu,ccaapton,1 point,Sun Jun 14 21:08:54 2015 UTC,Unfortunately there's no ghc-mod.exe on my hard-disk! Should I try to remove minGHC and install the Haskell Platform? How did you install ghc and cabal?
haskell,39u17p,eviltofu,18,Sun Jun 14 19:40:47 2015 UTC,"Because Integral and RealFrac are not types but rather type classes. Think of these as interfaces, it is written this way to say that a is constrained, meaning it must have an implementation for the functions: quotRem, toInteger,... etc and b must have the functions: properFraction,..etc."
haskell,39u17p,enzain,10,Sun Jun 14 19:49:56 2015 UTC,"This is a great explanation.   To go into a bit more detail, whenever you use a type variable in a function signature, you're saying ""I don't care what this is, my function will work with whatever type you end up using for this."" In order for that to be true, you're only allowed to use operations on that argument that it has some knowledge of.  Take for example the following function signature:  foo :: a -> a   foo takes an argument of type a and returns a value of type a. a can be anything -- we have no idea what type the function will end up using, and as a result, we have no idea what operations we can perform on the a. Think about what the implementation of foo might look like.  Really, think on it before looking further!  foo is only allowed to have a single implementation: foo x = x. It's also known as id.  What about bar :: a -> a -> a? It's like foo, but it takes two arguments. Since we know from foo that if you don't know anything about the arguments, you can't do anything with them. So what do we know about bar? It takes two arguments of the same unknown type, and returns one of them. Since we have two arguments, there are two possible implementations: bar x y = x and bar x y = y.  What about baz :: a -> b -> a? baz takes two arguments, like bar, but since we're not using the same type variable, the two types might be different. Also, since we know the return type of baz is a value of type a, and our function only has access to a single a, that the function only has a single implementation!  baz x y = x     So, we are limited in what we're capable of doing to values in functions, based on what we know about the type of them. Let's make a pretend data type:  data Lolcat = Lol | Cat   And a simple function to operate on it:  lol :: Lolcat -> Lolcat   Consider the possible implementations of lol. It looks kind of like id or foo from above, but specializing the unknown type a with the type Lolcat. Whereas we don't know anything about an unqualified a, we know something about values of type Lolcat -- they can either be Lol or Cat! id is only allowed to return the value passed to it, but lol is able to know that it's first argument might be either a Lol or Cat and is able to return either a Lol or Cat. It has four possible implementations. Consider what they might be!    A type class constraint tells us what functions we're allowed to use on values of that type. The typeclass Num gives us +, -, and other functions for working with numbers. When we have a typeclass constraint, we know that we can use functions defined for that typeclass on those variables. As an example, consider:  foo :: Num a => a -> a   This is similar to id and lol above, but now instead of substituting a concrete type for a as we did with lol, we have a typeclass constraint. This constraint tells us what we can do with our a: We can use +, -, abs, *, signum, fromInteger, and negate, as well as any other functions which take an instance of the Num typeclass, as long as we eventually return the same type. There are a whole bunch of possible implementations:  foo x = x + 5 foo x = x * 2 foo x = 10 - x -- etc..."
haskell,39u17p,ephrion,3,Sun Jun 14 21:09:56 2015 UTC,"To be pedantic, bottom is a member of every type, so foo x = foo x and foo x = undefined are also valid functions of type a → a."
haskell,39u17p,joelwilliamson,6,Mon Jun 15 01:57:06 2015 UTC,"Also worth pointing out that this lets you constrain a type with multiple interfaces:  falsy :: (Monoid a, Eq a) => a -> Bool falsy x = x == mempty"
haskell,39u17p,Tekmo,6,Sun Jun 14 23:05:54 2015 UTC,"In addition to what other people have said, imagine what would happen if you had a function like this:  showSorted :: (Ord a, Show a) => [a] -> String showSorted = intercalate "", "" . map show . sort   How would you write that using your notation?"
haskell,39u17p,VikingofRock,4,Sun Jun 14 20:00:14 2015 UTC,"Not the original poster, but I would write it as  showSorted :: [Ord+Show] -> String   (The exact color of the + bikeshed is up to a debate, of course.)  Also, I'd like all Ords in the type signature to refer to the same type variable, but different type variables can be recovered like this:  cmpEnum :: a@Enum -> b@Enum -> Bool   It's been on my Haskell wishlist for quite some time. (I've no idea how feasible it would be in practice, tho). Currently I have to reinvent it using type aliases:  type IO' a = forall m. MonadIO m => m a  foo :: Config -> IO' Int foo = ...   It isn't that useful, but with MonadIO I do use it pretty often."
haskell,39u17p,peargreen,3,Sun Jun 14 20:09:30 2015 UTC,"What would you do if you had a function with the signature  (Show a, Show b) => (a -> b -> a) -> a -> [b] -> a   ?"
haskell,39u17p,VikingofRock,3,Sun Jun 14 20:35:08 2015 UTC,"I would probably write it as you have written it. I don't really want a completely revamped syntax for type signatures, just some syntactic sugar for common cases.  (Obviously, this would backfire in many ways – confused beginners, etc. I know. It's a wishlist thing, not a rationally evaluated Haskell improvement proposal.)"
haskell,39u17p,peargreen,1 point,Sun Jun 14 20:46:02 2015 UTC,"Fair enough. I could see something like that being nice in addition to what we currently have. Also, I like what you did with IO' there. I think that really helps improve readability!"
haskell,39u17p,VikingofRock,6,Sun Jun 14 21:00:32 2015 UTC,Thanks for all the answers. It's day 3 of learning Haskell and there really is a lot for me to learn (and unlearn).
haskell,39u17p,tailcalled,3,Mon Jun 15 04:12:20 2015 UTC,How would you write this:  succ :: Enum a => a -> a
haskell,39u17p,irishsultan,2,Sun Jun 14 20:42:35 2015 UTC,"That one would be easy: Enum -> Enum, because both parameter and result are of the same type.  Of course if you have (Show a, Show b) as someone else pointed out you do have a problem"
haskell,39u17p,Fylwind,5,Sun Jun 14 20:47:20 2015 UTC,"But there are several ways to interpret Enum -> Enum!  Enum a => a -> a (Enum a, Enum b) -> a -> b Enum b => (forall a . Enum a => a) -> b"
haskell,39u17p,irishsultan,2,Sun Jun 14 21:55:26 2015 UTC,"Sure, but when giving just the first it's not clear why it's a problem. While the second one illustrates that there is a problem even without any of the other two.   I'm fairly certain that the /u/eviltofu wouldn't have considered the succ example problematic anyway, because he seemed to think of type classes as actual types."
haskell,39u17p,StudentRadical,1 point,Sun Jun 14 22:00:56 2015 UTC,a and b are arbitrary types such that type a belong to RealFrac type class and type b belongs to Integral type class.
haskell,39uhny,maxigit,5,Sun Jun 14 21:58:02 2015 UTC,"First, it's worth noting that multiple filters can be combined into one - it corresponds to the logical conjunction of all the filters. Next, I'd note that both of your case analysis statements send Nothing to the list being filtered - that is, they are the same as filter (const True). So, let's see how these ideas play out.  First, I'm going to move the case statements inside each filter:  filterByDate :: HasDate a => Maybe Date -> Maybe Date -> [a] -> [a] filterByDate startM endM as =   let as' =         filter (\a ->                   maybe True (fmap (a >=) startM))                as       as'' =         filter (\a ->                   maybe True (fmap (a <=) endM))                as'   in as''   Next, I want to combine those filters into one. We have a few options. One is to directly combine the Bools with &&:  filterByDate :: HasDate a => Maybe Date -> Maybe Date -> [a] -> [a] filterByDate startM endM as =   filter (\a ->             maybe True (fmap (a >=) startM) &&             maybe True (fmap (a <=) endM))          as   Finally, we can tidy this up a bit:  filterByDate :: HasDate a => Maybe Date -> Maybe Date -> [a] -> [a] filterByDate startM endM =   filter (\a ->             maybe True (fmap (a >=) startM) &&             maybe True (fmap (a <=) endM))   Hope that helps!"
haskell,39uhny,ocharles,1 point,Sun Jun 14 22:42:32 2015 UTC,You haven't used startM and endM.
haskell,39uhny,tomejaguar,1 point,Mon Jun 15 05:52:29 2015 UTC,"Thanks, there was a typo - startDate should have been startM (end the same for end)"
haskell,39uhny,ocharles,6,Mon Jun 15 07:30:16 2015 UTC,"A different approach would be to use the Endomorphism monoid, and basically write it as  filterByDate startM endM = appEndo $      mconcat [ maybe mempty (\start -> Endo $ filter ((>= start) . date)) startM             , maybe mempty (\end   -> Endo $ filter ((<= end) . date))   endM)             ]   This approach has the advantage of not being tied to the fact that all your transformations are filters."
haskell,39uhny,gergoerdi,2,Mon Jun 15 03:28:28 2015 UTC,"I think you might have forgotten to wrap the partially applied filters in Endo, but I love this answer."
haskell,39uhny,andrewthad,1 point,Mon Jun 15 13:00:07 2015 UTC,"Yes, thanks, good point. I'll edit the post now."
haskell,39uhny,gergoerdi,1 point,Mon Jun 15 13:51:03 2015 UTC,"That's exactly what I was looking for, my best choice was using fold like this   filterByDate startM endM as = foldl' (&) filters as        where filters = catMaybes [ Just id                 , startM <&>\start ->  filter ((>= start) . date)                 , endM   <&> \end -> filter (>= end) . date)                 ]   But what annoys me is the Just id at the beginning.  Using Endo I can do instead   filterByDate startM endM as = appEnd endos as         where endos = mconcat . map Endo $ catMaybes [                 , startM <&>\start ->  filter ((>= start) . date)                 , endM  <&> \end -> filter (>= end) . date)                 ]"
haskell,39uhny,sacundim,1 point,Mon Jun 15 17:07:02 2015 UTC,"Using the reducers package it becomes   filterByDate startM endM as = reduceWith appEndo endos as          where endos = catMaybes [                   , startM <&>\start ->  filter ((>= start) . date)                   , endM  <&> \end -> filter (>= end) . date)                   ]"
haskell,39uhny,sacundim,2,Tue Jun 16 16:45:20 2015 UTC,"As somebody who worked with time ranges for a long time, I'd recomment this: abstract the ranges into a type and put the logic into that type's operations.  Example:  -- | A data type for possibly-infinite time intervals. data Range t    = Before t -- ^ Beginning of time to specified point (exclusive)   | Between t t -- ^ Between two points of time (inclusive start, exclusive end)   | Since t -- ^ From a point of time (inclusive) to the end of time   | Forever   | Never   deriving (Eq, Show)  inRange :: Ord t => t -> Range t -> Bool inRange t (Before t0) = t < t0 inRange t (Between t0 t1) = t0 <= t && t < t1 inRange t (Since t0) = t0 <= t inRange _ Forever = True inRange _ Never = False  filterByDate :: HasDate a => Range Date -> [a] -> [a] filterByDate range = filter (\a -> date a `inRange` range)   This also supports writing a small utility library around Range, with operations like:  -- | True if and only if the two ranges coincide in one end but don't overlap anywhere. meet :: Eq t => Range t -> Range t -> Bool  intersection :: Ord t => Range t -> Range t -> Range t startsBefore :: Ord t => Range t -> Range t -> Bool endsAfter :: Ord t => Range t -> Range t -> Bool contains :: Ord t => Range t -> Range t -> Bool"
haskell,39uhny,beerdude26,1 point,Tue Jun 16 02:40:18 2015 UTC,"I agree that your solution in this particular case is pretty neat,  however date in my question is just an example of a more general problem, which is why my question was titled 'how to apply conditional transformations'. The same problem generally occurs when generating SQL query , where this range ""trick"" can't apply."
haskell,39ss5l,logicchains,35,Sun Jun 14 12:22:10 2015 UTC,Approximately never.
haskell,39ss5l,tomejaguar,2,Sun Jun 14 15:05:19 2015 UTC,"I was wondering, before I opened the thread, if the top rated answer would be ""Never""."
haskell,39ss5l,crodjer,2,Mon Jun 15 08:44:52 2015 UTC,Always expect them (e.g. in bracket-style functions) but never throw them.
haskell,39ss5l,Taladar,10,Mon Jun 15 08:55:26 2015 UTC,"with asynchronous exceptions in particular seeming like they could make code a lot more difficult to reason about.   They do, though I don't know how else you would handle events such as a keyboard interrupt.  At least with exceptions you can recognize that the event occurred and possibly perform cleanup or recovery; the Rust mechanism you describe sounds inferior.  Also, the only point at which you have to worry about asynchronous exceptions is in impure code, particularly where you acquire resources.  Careful use of functions like bracket will cover you here.  Asynchronous exceptions aren't a concern in pure code.  Practically, it makes sense to use exceptions for code that's in the IO monad."
haskell,39ss5l,massysett,8,Sun Jun 14 13:38:30 2015 UTC,I don't know how else you would handle events such as a keyboard interrupt   You can have event handlers for handling external events without giving programmers the power to raise their own exceptions.
haskell,39ss5l,tomejaguar,5,Sun Jun 14 14:56:36 2015 UTC,"At least with exceptions you can recognize that the event occurred and possibly perform cleanup or recovery; the Rust mechanism you describe sounds inferior.   The idea behind the Rust mechanism is something like Erlang's fail-fast approach, with a supervisor thread restarting the thread on failure if necessary. I've never used it in serious code myself so can't account for its effectiveness."
haskell,39ss5l,hastor,6,Sun Jun 14 14:14:09 2015 UTC,"Erlang's fail-fast approach is only safe in a local setting where the supervisor can really supervise.  For any other setting (primarily in a distributed setting), it is inferior to other techniques.  If there is a supervisor, how is that different from a function that catches all exceptions?  What is superior is an exception handling technique where stack unwinding is not conflated with the search for an exception handler.  In common lisps' condition system, the exception handler (condition handler) runs before the stack is unwound, which makes it a real supervisor who can decide what to do (fix the problem, or unwind the stack)."
haskell,39ss5l,sambocyn,3,Sun Jun 14 19:55:58 2015 UTC,"split off tack unwinding from exception handler search   woah, never thought about it like that before.  so instead of try/catch, you'll say ""handling this error within this subexpression"" or something?"
haskell,39ss5l,hastor,3,Sun Jun 14 21:48:38 2015 UTC,"In common lisp, when you want to throw an exception you can instead say:  ""you know what, I can't handle this situation, dear condition system, please give me a result that makes sense."" If the ""give me a result"" doesn't happen, the stack was unwound, but there is also the case where the condition system magically comes up with a sensible value.  The textbook example is parse errors.  You have a library that parses a CSV file.  At some point in the file, there is a parse error.  The parse library can't know how to deal with this (bail out or provide a default value).  However, the caller of the library knows, so it has set up a condition where ""parse error"" will return a default value (or unwind the stack).  This can all be handled by creating a callback mechanism, but in common lisp it is built into the exception handling system, which is a pretty elegant way of dealing with these issues, because the ""callbacks"" can go through multiple layers of library code and connect information known at a high level in the program with error conditions far down in low-level libraries.  http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html"
haskell,39ss5l,Taladar,2,Mon Jun 15 21:09:07 2015 UTC,The code looks similar to a try-catch but it allows you to e.g. decide to return a value from within the catch that can then be used at the position of the throw to continue execution (e.g. if the exceptional situation is a 'can not parse this unicode character' you could decide what to use as a replacement character for each occurrence).
haskell,39ss5l,Tekmo,9,Mon Jun 15 08:59:38 2015 UTC,"You should avoid asynchronous exceptions as much as humanly possible, mainly because they don't show up in the types.  Usually the only legitimate use case for them is when you know the exception is unreachable but you cannot prove it in the types and even then you should consult more experienced Haskell programmers to see if there might be a way to more safely encode what you are trying to do.  For synchronous exceptions, they are totally reasonable and most people use them when programming using IO because the IO in the type documents the potential for synchronous exceptions."
haskell,39ss5l,ForTheFunctionGod,6,Sun Jun 14 16:23:06 2015 UTC,"is there anything that can be done now but couldn't be done in an exception-less Haskell (or at least one with only a coarse-grained panic mechanism like Rust's)?   Yes/no. Without exceptions, you couldn't write partial functions like fromJust or head (they throw IOError on invalid inputs, I think). The sort of exception that can be surreptitiously thrown anywhere is dangerous, but it was included for a reason: if all you had were ""safe"" functions, you'd either have to provide proof that their input would be valid (e.g. you'd have to encode the non-emptiness of a list you supply to head), or you'd have to mark the calling function as ""unsafe"" too (calling a head' :: [a] -> Maybe a in f would have to result in f :: ... -> Maybe b, unless you could provide for the Nothing-case).  I'm torn on this issue. On the one hand, you are playing with fire when you're using partial functions, but on the other, small ones like head, fromJust, or fromRight might just be within the bounds of acceptable risk.   asynchronous exceptions in particular seeming like they could make code a lot more difficult to reason about.   Asnychronous exceptions are unavoidable (e.g. StackOverflow) and only really come into play if you have threaded code. That is, if a child thread gets an asynchronous exception, it has to detect that event and signal its waiting parent thread that it's about to terminate. This, however, can and probably has already been abstracted by some library. That  aside, they don't mar one's ability that much, since pure code can't do anything with them anyway, and IO-code can't do much besides terminating in a graceful way."
haskell,39ss5l,implicit_cast,12,Sun Jun 14 14:08:05 2015 UTC,"I'd be totally on-board with tweaking the Prelude such that  head :: [a] -> Maybe a unsafeHead :: [a] -> a   These kinds of power tools are fantastic to have around, but safety should be the default."
haskell,39ss5l,ForTheFunctionGod,7,Sun Jun 14 16:06:24 2015 UTC,"Might I recommend the listsafe library, written by yours truly? :)  BTW, if you have MonadThrow, you can write all unsafe functions by piling a MonadUnsafe on top of it:  class MonadThrow m => MonadUnsafe m where    unsafeExtract :: m a -> a  instance MonadUnsafe Maybe where unsafeExtract = fromJust instance MonadUnsafe (Either a) where unsafeExtract = fromRight instance MonadUnsafe IO where unsafeExtract = unsafePerformIO   Then  head = (unsafeExtract :: Maybe a -> a) . Data.List.Safe.head"
haskell,39ss5l,Fylwind,5,Sun Jun 14 18:24:36 2015 UTC,"(they throw IOError on invalid inputs, I think)   Actually, they throw ErrorCall."
haskell,39ss5l,implicit_cast,8,Sun Jun 14 22:00:41 2015 UTC,"I set for myself two rules:   Pure code shouldn't raise exceptions.  It's awful. If, in some particular API, the ""best"" thing to do is to crash, just raise an exception.  If you're not actually doing something useful with the failure, you don't benefit by encoding it at the value level."
haskell,39ss5l,gilmi,15,Sun Jun 14 16:03:17 2015 UTC,"In a purely functional language, I would like every effect to be encoded in the return value. IMO, a function that throws exceptions without in being encoded in it's type is doing things it shouldn't do."
haskell,39ss5l,shift_reset,9,Sun Jun 14 13:26:12 2015 UTC,"F* does this; it's ""parameterized by a join semi-lattice of effects"" (which are also referred to in the paper as Dijkstra monads):   PURE -> DIV -> STATE / EXN -> ALL  At the bottom, we have PURE, which classifies computations that are pure, total functions. The effect DIV is for computations that may diverge (i.e., they may not terminate), but are otherwise pure. STATE is for computations that may read, write, allocate, or free references in the heap; EXN is for code that may raise exceptions; ALL- computations may have all the effects mentioned so far, as well as IO.   So an otherwise pure function that might throw will have a return type of Exn a."
haskell,39ss5l,gilmi,2,Sun Jun 14 14:49:03 2015 UTC,I'm curious if you consider nontermination an effect?
haskell,39ss5l,tailcalled,2,Sun Jun 14 18:17:02 2015 UTC,"I don't like non-termination, but I don't yet know how to encode/restrict it using types. exceptions on the other hand..."
haskell,39ss5l,hexbienium,4,Sun Jun 14 18:39:11 2015 UTC,"codata Partial a = Done a | Later (Partial a)   (might need some quotienting, though...)"
haskell,39ss5l,tailcalled,2,Sun Jun 14 21:51:25 2015 UTC,"I'm just now learning about codata, so correct me if I'm wrong, but in this case you're using it so that you can encode a non-terminating computation as Later (Later (Later (...))) (infinitely nested), right?"
haskell,39ss5l,shift_reset,2,Mon Jun 15 13:49:20 2015 UTC,Yes.
haskell,39ss5l,tailcalled,2,Mon Jun 15 14:44:59 2015 UTC,How about linearity?
haskell,39ss5l,shift_reset,2,Sun Jun 14 18:46:00 2015 UTC,"Wouldn't it be nonlinearity that's the effect (or rather, coeffect)?"
haskell,39ss5l,gilmi,2,Sun Jun 14 22:02:34 2015 UTC,"Yes, nonlinearity would be the effect. I was just curious if this person goes as far as that in thinking about effects."
haskell,39ss5l,dskippy,1 point,Mon Jun 15 00:46:24 2015 UTC,I don't know what you mean.
haskell,39ss5l,hexbienium,4,Sun Jun 14 18:56:56 2015 UTC,"I write large Haskell applications professionally and I almost never create my own exceptions. However, there is one type of case where I do. Cases that never actually happen.  I tend to be extremely conservative of a programmer, so I turn on all warnings in my code and commute them to errors and as such I require myself to have things like complete pattern matching coverage and such. Occasionally I have situations where I need to explicitly handle an error case that I know will never happen. Imagine something like a lookup immediate after an insert. Instead of polluting my types and promoting everything up the call stack with Maybe I just raise exception with a clear message that some basic assumption has been violated. I haven't seen any of those errors ever come up though. But it satisfies the type checker, it satisfies warnings, it's very readable and explicit, and it only costs a few lines in my module to explain the situation."
haskell,39ss5l,tejon,3,Mon Jun 15 04:19:04 2015 UTC,"I'm still very much in the process of becoming a good Haskell programmer, so I'd like to ask the advice of some of the more experienced people in this thread. I get the impression from responses thus far that it's not a good idea to use error, etc., to deal with, say, bad input by throwing an exception. If I'm writing a very short program (say, < 100 lines) that I will nonetheless need to tweak, would the best error-handling mechanism be to just do everything in the Maybe monad (since that's the simplest error-handling monad)?  Edit: to expand a little – the main reason I might use error is because it offers an easy way of throwing helpful error messages, which are helpful for debugging purposes. I could achieve a more sophisticated and pure version of the same thing by making my own error type and making it an instance of Error, but that seems like way overkill for a short program. Maybe can't provide error messages, and there's nothing computationally-intensive or potentially dangerous in this program, so might error be acceptable after all?"
haskell,39ss5l,hexbienium,3,Mon Jun 15 01:05:26 2015 UTC,"It's probably worth stepping up to Either just for future-proofing. You can still basically treat it as Maybe by just not binding any Left results, but you'll have the plumbing later if you decide to add logging etc."
haskell,39ss5l,SkoomaMudcrab,1 point,Mon Jun 15 04:15:01 2015 UTC,That's a good thought! Thanks for the advice.
haskell,39ss5l,maxigit,5,Mon Jun 15 04:19:05 2015 UTC,One example would be safe resource disposal: https://wiki.haskell.org/Bracket_pattern  Although I think that exceptions are a vestige of the sequential era and just don't work well in the concurrent & parallel world.
haskell,39ss5l,hiptobecubic,4,Sun Jun 14 13:45:51 2015 UTC,"I always though using exceptions was the last resort, and in 20 years of programming (in different languages), I've never really needed or used them."
haskell,39ss5l,hiptobecubic,2,Sun Jun 14 13:40:14 2015 UTC,"I also feel like exceptions are some kind if weird blight and should be avoided, so I'm interested in the answer to this, but surely the fact that some other language doesn't have them is not particularly meaningful.  Several of the most popular languages in the world don't even have static types, but I think we can all agree that we're better off for having them."
haskell,39ss5l,ForTheFunctionGod,5,Sun Jun 14 12:45:40 2015 UTC,"surely the fact that some other language doesn't have them is not particularly meaningful.   It shows that lacking exceptions isn't a bar to attracting developer mindshare. I've seen programmers argue that they couldn't imagine using a language without exceptions, so having multiple successful languages without exceptions acts of a sort of social proof that it's okay for a language not to have exceptions, for people who are concerned about such things.   It also acts as empirical evidence supporting the notion that exceptions aren't necessary for modern software development (although C already showed this, many would consider its lack of exceptions a result of its age rather than a design choice)."
haskell,39ss5l,AndrasKovacs,2,Sun Jun 14 12:51:30 2015 UTC,"Sure but I'm not seeing how we disagree. There are languages that do and don't have all kinds of things. It doesn't seem to matter as far as mind share. So while I feel like exceptions are annoying and screw everything up, many popular languages have them and ""do well."" I don't think you can cite a popular language's features as all good, just not bad enough to ruin the language."
haskell,39tboc,gelisam,2,Sun Jun 14 15:59:08 2015 UTC,Very nice post.  I'm tempted to use this for some lens spelunking.  I'm not sure if I have adequate caffeine supplies though...
haskell,39sj9c,MrWoohoo,20,Sun Jun 14 09:52:15 2015 UTC,"Since you are new, I think it's worth pointing out some context relating to your question, the frustration you had, and how much you should extrapolate that to the rest of the Haskell ecosystem.  First of all, the FP Complete School of Haskell is a crowd-sourced tutorial site.  Anyone can create an account and throw up a tutorial.  Any time you have a system like that the quality is going to be highly variable.  This isn't a criticism of the School of Haskell.  It's a fact about anything crowd-sourced.  Second, if you look at the comments, one of the first things you'll see is ""Awful tutorial"".  I'm not here to speculate on the quality of this tutorial, but it's worth noticing that someone else seemed to have problems with it.  Third, the tutorial mentions two packages: html-conduit and xml-conduit.  So those are the first two places I would go to look for your modules.  The best way to do that is to go to hackage.  Like others have suggested, one way to do that is to google ""html-conduit haskell"".  Googling for ""html-conduit hackage"" also seems to work well too.  But my preferred approach is to go to the URL (""hackage.haskell.org/package/"" ++ packageName).  That will take you directly to the hackage page for the most recent version of packageName and it lists all the modules exported by that package.  That's a great way to get more documentation on the functions used by the example and help you understand it better.  I use this link so much that I prime my browser's autocomplete by entering the string ""hackage.haskell.org/package/"" 10 or 20 times so that I can just open a new tab, type ""h"", hit right arrow, and type a package name to get me straight to that package's documentation.  From this I would argue that first of all you should not extrapolate too much of this experience to the rest of the Haskell ecosystem.  It's just one tutorial on a crowd-sourced site.  Second, notice how tutorials are hard to maintain.  This is not unique to this tutorial, it is a general principle.  If it isn't auto-generated from the source it will go out of date.  (In fact, I've started making my tutorials part of my automated test suite.)  I think this is part of why you don't see as many tutorials in the Haskell ecosystem.  We tend to rely more on haddock documentation which is auto-generated from source and will always be correct for the version it was generated for.  Third, learn to explore the hackage documentation pages.  They are an invaluable resource.  And finally, keep at it.  The Haskell community is still trying to figure out how to make the on-ramp easier.  It can be frustrating at times, but I believe it's absolutely worth it in the end."
haskell,39sj9c,mightybyte,16,Sun Jun 14 16:38:12 2015 UTC,"Seems that those School of Haskell examples rely a bit too much on the Web-based IDE. It'd be desirable for such tutorials to mention which packages (& versions) they need, especially if the required packages are not even part of the Haskell Platform."
haskell,39sj9c,RedLambda,5,Sun Jun 14 10:05:36 2015 UTC,"Yeah, tutorials without fully qualified imports are worthless."
haskell,39sj9c,mcandre,7,Sun Jun 14 16:36:53 2015 UTC,I'm happy when tutorial writers manage to at least include their imports!
haskell,39sj9c,zz_h,5,Sun Jun 14 18:25:11 2015 UTC,You could also provide either a cabal file or a Github project that the beginner could clone and install.
haskell,39sj9c,Tekmo,3,Sun Jun 14 16:20:18 2015 UTC,"EDIT: Success! Thanks for the late night help on IRC too! Managed to get a cabal file set up and it compiles! I can't load foo.hs into ghci without errors because it doesn't know about the cabal file I guess.   ORIGINAL PROBLEM: Nevermind :) Thanks!  Copied from the pastebot site  I'm trying to compile a program that uses the following imports:  import Network.HTTP.Conduit (simpleHttp) import qualified Data.Text as T import Text.HTML.DOM (parseLBS) import Text.XML.Cursor (Cursor, attributeIs, content, element, fromDocument, child,                     ($//), (&|), (&//), (>=>))   It is from the second example on this page  https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup  I am on ISX Yosemite using this package https://ghcformacosx.github.io  ghc --version; cabal --version The Glorious Glasgow Haskell Compilation System, version 7.10.1 cabal-install version 1.22.0.0 using version 1.22.0.0 of the Cabal library   I've spent all night now trying to learn how to track down broken dependancies and it still isn't working. Is there a simpler way to do it? what is the right   cabal install ????  to get it compiling?  (I have figured out how to ""cabal sandbox init"" successfully, which turned out to be one of my early stumbling blocks)  It's 3am. I'm going to bed. I pray someone knows the right cabal incantation to let me get this example working. Thanks!"
haskell,39sj9c,tomejaguar,1 point,Sun Jun 14 09:53:55 2015 UTC,"How about googling for those modules, seeing what packages they come from, and installing them?  Does something go wrong with that approach?"
haskell,39sj9c,RedLambda,15,Sun Jun 14 09:57:29 2015 UTC,Isn't that a bit too much to expect from newcomers to have to play package detective first before they can try out an example?
haskell,39sj9c,tomejaguar,1 point,Sun Jun 14 10:08:13 2015 UTC,"Yes, it is too much, but it can be done at least."
haskell,39sj9c,Codas89,2,Sun Jun 14 11:22:02 2015 UTC,"Yes, I've spent three hours trying to figure that out. Google results get lots of old links that I don't think are relevant and nothing leaps out as a definitive answer if you don't know what you're looking for. Hoogle isn't particularly useful for a beginner either for what I was trying to do. Mapping from Dotted.Module.Name to CABAL-importPackageTag isn't easy. Hoogle can offer up LOTS of seemingly good possibilities, again if you're a beginner.  So yeah... I've been Googling."
haskell,39sj9c,tomejaguar,4,Sun Jun 14 10:20:55 2015 UTC,"Look like /u/tomejaguar beat me to it, but I still have something to add.  Might I interest you in stackage (nightly builds since you are using GHC 7.10.1)?  This will not help you with discovering the packages you need, but /u/tomejaguar did a great job explaining that. Instead, stackage provides a set of specific versions of packages that are all known to compile together.  This will probably save you a lot of trouble in the long run, even when using sandboxes.  To get started, just copy their cabal.config file in your project directory  wget https://www.stackage.org/nightly-2015-06-14/cabal.config   and update the cabal index  cabal update   Thats it, every time you try to install a new package, cabal will automatically apply the version constraints from the stackage snapshot and cabal hell should be a thing of the past."
haskell,39sj9c,RedLambda,2,Sun Jun 14 11:14:29 2015 UTC,"Firstly, yes this process should be made easier for beginners, and secondly, even if you do know what packages to install it may be hard to get compatible versions which work together.  However, once you know the procedure it is easy to find out what packages certain modules belong to.  Here is the procedure.  Google for the following:   Network.HTTP.Conduit haskell Data.Text haskell Text.HTML.DOM haskell Text.XML.Cursor haskell   The first hit in every case (at least for me) is a link to the Hackage page of the package in question.  At the top of the page you see   http-conduit-1.2.4:  HTTP client package with conduit interface and HTTPS support. text-0.11.2.0: An efficient packed Unicode text type. html-conduit-0.1.0: Parse HTML documents using xml-conduit datatypes. xml-conduit-0.7.0.1: Pure-Haskell utilities for dealing with XML with the conduit package.   This means you need to install the packages   http-conduit text html-conduit xml-conduit   As I said above, just knowing the package names doesn't mean you can install them successfully, but it is a start and it's what I meant in my original message."
haskell,39sj9c,ignorantone,3,Sun Jun 14 11:04:52 2015 UTC,"[...] even if you do know what packages to install it may be hard to get compatible versions which work together.   Only if the packages don't specify proper version constraints. If they do (as luckily do most carefully maintained packages), it's just a matter of cabal install <names-of-packages> and cabal will figure out a working combination.  As a last resort, if that fails, you can always try your luck with using the Stackage-constraints, which may or may not help."
haskell,39sj9c,yitz,1 point,Sun Jun 14 13:45:59 2015 UTC,"What about fpcomplete's Hoogle?  You'll see that the second search result matches your module name, corresponding to the http-conduit package."
haskell,39sj9c,alt_account10,1 point,Mon Jun 15 08:10:47 2015 UTC,You should be able to load foo.hs into ghci using the cabal-sandbox-aware version of ghci. Navigate to the root of the sandbox and run:  cabal repl   Give it a try and let us know how it goes.
haskell,39sj9c,dhjdhj,5,Sun Jun 14 11:24:18 2015 UTC,Not to be confused with Cabal Hell™
haskell,39sxlw,schrodingers_paradox,7,Sun Jun 14 13:34:14 2015 UTC,"If you come from imperative-land, perhaps phrasing it in a different syntax may be enlightening.  // add x y = x + y var add = function(x) { return function(y) { return x + y; } };  // increment n = add 1 n var increment = function(n) { return add(1)(n); }   Since that definition of increment just forwards its argument along to the function returned by add, we can simplify.  // increment = add 1 var increment = add(1);   That’s it."
haskell,39sxlw,evincarofautumn,3,Sun Jun 14 18:23:23 2015 UTC,"Thank you, this is what made it click!"
haskell,39sxlw,gfixler,2,Sun Jun 14 19:52:49 2015 UTC,"And I have to work in Haskell for my job, so I actually do this. E.g.:  id = lambda x: x const = lambda x: lambda _: x comp2 = lambda g: lambda f: lambda x: g(f(x))   etc...  And it's all so I can curry. E.g.:  map(comp2(const)(id), xs)   Not that I need to map a const of id, but you get the idea. I have hundreds of little one-liners like this in a library that make my daily tasks so much easier."
haskell,39sxlw,evincarofautumn,1 point,Mon Jun 15 10:00:26 2015 UTC,"Ah, I’m so glad! You’re welcome. :)"
haskell,39sxlw,cocreature,4,Mon Jun 15 05:13:16 2015 UTC,"Every function takes only one argument, so add is really a function that takes one argument and returns another function that takes another argument. So GHC knows that add 1 is a function so addPlusOne has to be a function aswell."
haskell,39sxlw,ForTheFunctionGod,3,Sun Jun 14 13:43:27 2015 UTC,Does this mean that Haskell does not have functions without arguments?
haskell,39sxlw,tailcalled,5,Sun Jun 14 13:52:03 2015 UTC,"A function with no arguments is a constant. It would make no sense to ""call"" it, as opposed to just using it as a value. When you do see something that looks like a function without arguments, like getTime :: IO Time, you have to keep in mind that  data IO a = IO (RealWorld -> (a, RealWorld))   RealWorld is a magic token that GHC supplies to the main function and which gets optimised away anyway. So, in reality, the above function's signature would be more faithfully represented as  getTime :: RealWorld -> (a, RealWorld)   Similarly, get :: State s () (getting the current state and no return value) expands to get :: s -> (s, ()).  In general: functions = values. It sounds simple, but I know from experience that it takes time to really wrap your head around that fact."
haskell,39sxlw,SkoomaMudcrab,3,Sun Jun 14 14:51:03 2015 UTC,"Does this mean that Haskell does not have functions without arguments?   Yes, in the same sense that Haskell doesn't have functions with more than one argument. A function in Haskell always takes exactly one argument.  For practical purposes, however, we frequently call values of types of the shape  a1 -> ... -> an -> b   n-argument functions. This leads to the obvious generalization of calling any value a 0-argument function."
haskell,39sxlw,kamatsu,-4,Sun Jun 14 15:59:20 2015 UTC,"It does. For example, get from the State monad is a function/method with no arguments. It cannot and does not get constant-folded by the compiler because it has side effects. Calling it can produce different results every time.  The more precise statement would probably be: Haskell functions don't have more than 1 parameter."
haskell,39sxlw,Hrothen,5,Sun Jun 14 14:00:04 2015 UTC,get isn't a function or method. It's a value ;) Haskell functions are only those values that have a function type.
haskell,39sxlw,ForTheFunctionGod,1 point,Sun Jun 14 15:55:30 2015 UTC,"That's what I read indeed, but that doesn't clarify why it's expecting an argument in the latter case of AddPlusOne."
haskell,39sxlw,Roboguy2,2,Sun Jun 14 14:01:45 2015 UTC,Your first function is a function that takes one argument and returns a value. Your second function takes zero arguments and returns a function that takes one argument.
haskell,39sxlw,MaybeJustNothing,2,Sun Jun 14 14:11:11 2015 UTC,"It doesn't really expect anything. addPlusOne is a perfectly fine value on its own. What you have to understand is that creating a function doesn't do anything special; it just gives a short name to a body. In particular, add is just a short name for a nested lambda:  add n m = n + m add = \n -> (\m -> n+m)   You can replace add with its body in addPlusOne and get:  addPlusOne n = add 1 n  -- replace add with its body addPlusOne n = (\p -> (\m -> p + m)) 1 n -- renamed add's n to p to avoid ambiguity addPlusOne = \n -> ((\p -> (\m -> p + m)) 1 n) -- put the n on the right, just as above with add   The last 3 lines are equal, but the first version is obviously more convenient than the third. The third one, however, is that the expression really ""means"", in a sense. It's only for convenience that you can write something like  f n m another_arg = ...   So functions are just shorthands; they have no special meaning. GHC expects an argument to addPlusOne = add 1 because it expects one to add 1-- and it expects an argument to add 1 because  add 1 = (\n -> (\m -> n + m)) 1       = \m -> 1 + m   The whole thing is really just an instance of ""reduce/apply as much as you can"", irrespective of where the named functions are*.   Small caveat: that's not ENTIRELY true because of some low-level mumbo-jumbo that goes on because of the monomorphism restriction and compilation, but it's the main point to take away."
haskell,39sxlw,maxigit,1 point,Sun Jun 14 14:27:59 2015 UTC,"I feel like that's a bit of a confusing example. In all the instances of MonadState that come with mtl, ultimately there is a function with an argument hidden inside it. Not only that, but (as has been said above) all Haskell functions take exactly one argument.  (Also, I think your link is wrong.)"
haskell,39qold,int_index,4,Sat Jun 13 20:39:14 2015 UTC,"I don't know much about Haskell, but it seems to me that your examples for logDiv use badly named arguments a and b instead of x and y."
haskell,39qold,captainpatate,4,Sat Jun 13 22:52:19 2015 UTC,"Yeah, that's what I get for not feeding my examples to the compiler. Fixed."
haskell,39qold,ignorantone,2,Sat Jun 13 22:57:46 2015 UTC,Does anyone know of a tool for type checking or compiling examples in Haddocks documentation? (a quick search did not avail me anything)
haskell,39qold,ignorantone,5,Sun Jun 14 01:59:58 2015 UTC,Perhaps you're thinking about doctest?
haskell,39qold,mbruder,1 point,Sun Jun 14 02:01:49 2015 UTC,"ah thanks, that looks great"
haskell,39qold,michaelt_,3,Sun Jun 14 03:45:00 2015 UTC,Update: now compatible with GHC 7.8 (thanks /u/peargreen).
haskell,39qold,roche,3,Sun Jun 14 01:24:47 2015 UTC,"Update: Hackage documentation is now available, thanks to the neil tool."
haskell,39qold,michaelt_,3,Sat Jun 13 21:48:39 2015 UTC,Your type signature for summator does not seem to be correct (missing m).
haskell,39qold,michaelt_,1 point,Sat Jun 13 22:34:43 2015 UTC,You're right. Fixed.
haskell,39qold,michaelt_,3,Sat Jun 13 22:40:25 2015 UTC,"What if you have two functions, both requiring a MonadState, but it's different MonadStates? There's no way you could use those functions in one monad transformer stack with mtl, thus mtl is antimodular!    Isn't this a bit of an exaggeration? The ether solution is 'modular' in one way, but not in others, e.g.  {-#LANGUAGE TemplateHaskell #-} import Lens.Simple -- import Control.Lens  import Control.Monad.State.Strict  data St = St {_int:: Int , _str::String} makeLenses ''St  defSt = St 0 """"  f :: (MonadIO m, MonadState Int m) => m () f = do a <- get        liftIO $ putStr ""the Int state is "" >> print a  g :: (MonadIO m, MonadState String m) => m () g = do s <- get        liftIO $ putStr ""the String state is "" >> putStrLn s  useboth = do     zoom int f     zoom str g     int += 1     str <>= ""!""  runboth :: IO () runboth = evalStateT ?? defSt $ do   useboth   useboth   useboth  -- >  runboth -- the Int state is 0 -- the String state is -- the Int state is 1 -- the String state is ! -- the Int state is 2 -- the String state is !!   This works with either Control.Lens or Lens.Simple, though with Lens.Simple, the signature of useboth will be specialized to    useboth :: MonadIO m => StateT St m ()   With Control.Lens we stay in mtl-land, which I take it you would prefer, but with a slightly alarming inferred type   useboth    :: (Functor (Control.Lens.Internal.Zoom.Zoomed m1 ()),       Functor (Control.Lens.Internal.Zoom.Zoomed m2 ()), MonadIO m1,       MonadIO m2, Zoom m1 m Int St, Zoom m2 m String St) =>       m ()   Control.Lens.magnify operates similarly on the MonadReader cases."
haskell,39qold,michaelt_,7,Sun Jun 14 03:39:39 2015 UTC,https://ro-che.info/articles/2014-06-11-problem-with-mtl#merging-transformer-layers
haskell,39qold,Tekmo,2,Sun Jun 14 06:32:07 2015 UTC,"The only example given here is    foo = do    x <- get    put $ fromEnum $ not x   which fails to type check. But the going Haskell way of writing something like this is  foo :: MonadState (Bool, Int) m => m () -- type inferred even with lens-family/ Lens.Simple foo = do   x <- use _1    _2 .= fromEnum (not x)   Where's the boilerplate or hackery in that? In order to exhibit a 'problem with mtl' you need to find a use case that is not met with this bread-and-butter solution, which by now typical haskellers can write in their sleep. So far though you make do with abstract remarks, such as that this forces the two MonadState 'layers' together.  This is correct of course, but one is looking for a use case in which that is wrong.  They exist of course, but a proper illustration should be one in which the matter is pressing; foo by itself isn't such an example."
haskell,39qold,michaelt_,3,Sun Jun 14 17:45:32 2015 UTC,"For me it's very important how I take apart monad transformer layers. With Ether I can runStateT to satisfy one MonadState constraint and continue working with another. With merged layers I can't.  f :: MonadState (Int, Bool) m => m Char g :: MonadState Int m => m Char   Try invoking f from g to get what I'm talking about."
haskell,39qold,michaelt_,2,Sun Jun 14 17:50:50 2015 UTC,"Right, I was going to continue there to say that this should be the main talking point for ether. The theoretical considerations in e.g. the 'problem with mtl' don't touch on this.  It is independent of the fact that the zoom material affects the order of the 'layers' by making them adjoining. By fusing them into one layer, it makes it harder to handle one and maintain the other. (It isn't very hard by the way.)"
haskell,39qold,Tekmo,2,Sun Jun 14 18:17:33 2015 UTC,"Perhaps you could contribute to Ether by writing a little Wiki page on the subject? I'd write one myself, but my writing skills are subpar (as you can see, my phrasing caused a lot of confusion here)."
haskell,39qold,Tekmo,2,Sun Jun 14 18:20:32 2015 UTC,"To feed one element of a tupled reader you would need something like    run_1 :: MonadReader a m => ReaderT (b,a) m r -> b -> m r  run_2 :: MonadReader a m => ReaderT (a,b) m r -> b -> m r  run_1 r b = ask >>= \a -> runReaderT r (b,a)  run_2 r b = ask >>= \a -> runReaderT r (a,b)   This is simpler done in line in a 'stack' that is by hypothesis going to depend only on a.  I ask for the a and apply runReaderT with the b I propose to feed it, and thus lower the predefined MonadReader (a,b) to a MonadReader a; it is a line longer than the ether method, but ask is a pretty short line ..."
haskell,39qold,Tekmo,3,Sun Jun 14 18:30:00 2015 UTC,"I never argued it was impossible, but then you'd have to write those run functions for every possible way of nesting one environment inside another.  If we don't restrict ourselves to 2-tuples, then we have to write functions for tuples of all possible lengths. For all effects (MonadReader, MonadWriter, MonadState). Don't forget that MonadState can be deconstructed in various ways (evalStateT, execStateT, runStateT). Oh, and there is also ExceptT, for which we would have to work with Eithers, not with tuples.  But let restrict ourselves to 2-tuples.  Consider those functions:  f :: MonadReader (a, (b, (c, (d, (e, ()))))) m => m r g :: MonadReader (a, (c, (d, ()))) m => m r   I don't think that boilerplate glue to call f from g is going to be even readable."
haskell,39qold,Tekmo,2,Sun Jun 14 18:38:40 2015 UTC,"f :: MonadReader (a, (b, (c, (d, (e, ()))))) m => m r; f = undefined g :: MonadReader (a, (c, (d, ()))) m => b -> e -> m r g b e =  do   (a,(c,(d,()))) <- ask   runReaderT f (a,(b,(c,(d,(e,())))))   You just ask and feed the recycled ReaderT what it needs. It's not as nice as ether, granted.  The state version is less pleasant  fs :: MonadState (Int, Bool) m => m Char; fs = undefined gs :: MonadState Int m => Bool -> m Char gs b = do    n <- get   (c,(n',b')) <- runStateT fs (n,b)   put n' >> return c   Maybe the way to say it all is: zoom and magnify make it easy to compose reader and state items with simple parameters into reader and state items with more complex parameters; ether makes it easier to introduce more complex reader and state items into the definition of simpler ones."
haskell,39qold,michaelt_,2,Sun Jun 14 18:49:26 2015 UTC,"Fine, with MonadReader you just ask for the required arguments and pass them. But with MonadState you also need to put their new versions back. And with MonadError you'd have to pattern match on Eithers.  And here we have only two functions. What if we have dozens? I mean, this is a solution, but there's a lot of boilerplate associated with it that I don't want to rewrite at each call site. And if I abstract it away, I get literally millions of combinators."
haskell,39qold,michaelt_,2,Sun Jun 14 18:57:13 2015 UTC,"zoom and magnify are fully compatible with Ether, by the way. They want MonadReader and MonadState from mtl, which you can provide for a tagged effect via the ethered function.  ethered foo $ zoom _1 $ do     -- something here"
haskell,39qold,alex-v,3,Sun Jun 14 18:56:25 2015 UTC,"For the few cases where you cannot merge StateT layers you can resolve the ambiguity using the ""transformers"" library instead of ""mtl""."
haskell,39qold,conklech,4,Sun Jun 14 19:01:04 2015 UTC,"That's a band-aid, not a principal solution."
haskell,39qold,gclichtenberg,2,Sun Jun 14 07:02:59 2015 UTC,"I don't oppose this library at all, it seems great. It was just the claim ""mtl is anti-modular"" that struck me as excessive.   If you are trying to do something like what ether does, then tupling with zoom _1 and zoom _2 will seem like a hack, a band-aid etc. This isn't what my example was an example of, though.   In my case, I wanted to operate with a (deliberately simple) state St. A St is composed of an Int and a String. Modularity suggests that I ought to be able to recycle my old MonadState Int ... and MonadState String ... gizmos in the construction of my new MonadState St ... items. It is this form of modularity is available with zoom and magnify but not with ether.    Even that case is in fact very simple. Lenses needn't look to actual fields of a record-type. If you look at this pipes-text example resolving a problem posed by Michael Snoyman, you will see that with zoom one is able to operate on a Producer ByteString state recycling predefined state-devices ('parsers', in this context) that look for:   a Text with utf8 encoding  a pair of Texts with utf8 encoding a different pair of Texts with utf8 encoding, and  a pair of raw ByteStrings.   all of this in sequence; moreover, what type I 'see' in the state at any stage can depend on what the previous parsers turned up.  The advantages of ether cannot be clearly expressed with the term 'modular'."
haskell,39qold,peargreen,4,Sun Jun 14 08:47:44 2015 UTC,"Ether-style tagging can be combined with Lens-style zooming, those are orthogonal concepts.  My argument is that mtl alone can't be used in a modular way, you need to extend it either with Lens-style zooming or Ether-style tagging to get modularity. Both are mtl-compatible.  Perhaps it's just bad phrasing on my part."
haskell,39qold,conklech,3,Sun Jun 14 15:40:17 2015 UTC,"I grasp this point. I was operating with the a priori that by now zoom is part of the universal haskell tool-kit.   Maybe I'm wrong, and it's a separate point, but it seems to me a surprising number even of academic discussions of the alleged difficulties of monad transformers exhibit unawareness of either or all of: the distinction between mtl and transformers; the existence and simplicity of zoom; and the existence of hoist.  I wasn't thinking you were guilty of these, but much of the 'extensible effects' discourse is, and tends to a solution in which all monadic material is assimilated to exceptions and handlers. This seems like an obvious regression to me, especially since all the textbook examples can easily be managed with really elementary combinators like zoom and hoist."
haskell,39qold,tejon,1 point,Sun Jun 14 15:53:25 2015 UTC,Why?
haskell,39qold,leperLlama,6,Sun Jun 14 16:25:20 2015 UTC,"First of all, let's acknowledge that merging states into one layer is a hack. It's boilerplate-heavy and doesn't work with some monad transformers. You also can't merge a lazy state and a strict state into one, for obvious reasons.  So manual lifting is something that allows you to side-step the problems with merging layers, but now you're relying upon a particular order in which monad transformers are stacked, which completely defeats the purpose of mtl - abstracting from this order. So when you abandon an idea (in this case abstracting from the order of monad transformers) to solve a particular problem (in this case unmergable states), I call that a band-aid, because it just fixes the problem where it bleeds the most, not on a fundamental level."
haskell,39qold,tejon,4,Sun Jun 14 15:37:06 2015 UTC,"There is boilerplate associated with the ether solution, too.  With the lens-based solution you specify the sub-state by providing a lens and with ether you specify the sub-state by providing a Proxy.  Also, don't forget the type signature boilerplate that the ether library introduces.  Compare this:  (MonadState s1 Foo m, MonadState s2 Bar m) => m r   versus:  StateT (s1, s2) m r   Yes, the purpose of the mtl is to abstract away the order, but in many cases monad effects do not commute, which is why I prefer an explicit order anyway.  For example, consider this mtl-based code fragment:  do put 0    (put 1 >> throwError ""foo"") `catchError` (\_ -> return ())    get   What do you think that get will return?  0 or 1?  The answer is: it depends on the order of the ErrorT and StateT layers.  So I don't think it's principled to allow effects to commute because that changes the semantic behavior of code."
haskell,39qx15,shakleton42,16,Sat Jun 13 21:55:29 2015 UTC,"Yeah. He mentioned that in his appearance on the HaskellCast. The idea is to keep doing the things that are principled and just ""the right thing to do"". That is something that gets harder as more and more people adopt the language and get angry at breaking changes.  Let's just be happy that we got the AMP and the FTP into 7.10, at least for the moment, we are still on the right track, I think."
haskell,39qx15,shakleton42,2,Sat Jun 13 22:33:31 2015 UTC,Thanks I will look into AMP and FTP to see what they are. I bet they are exciting and helpful changes.
haskell,39qx15,yitz,15,Sat Jun 13 22:34:42 2015 UTC,"Ouh. Sorry. Those are the Applicative/Monad Proposal, that is to say, making Applicative a proper superclass of Monad, and the Foldable/Traversable Proposal, which generalised many functions in the Prelude that used to work only on lists to work on any kind of Foldable or Traversable (like Trees etc.).  Both of these were really smart ideas and should have been implemented ages ago. The only thing really speaking against them was that it would break some old code. Both were accepted in 7.10 (the current version of GHC)."
haskell,39qx15,Taladar,1 point,Sat Jun 13 22:39:28 2015 UTC,"AMP was universally supported. FTP was not so clearly a smart idea and was controversial. Anyway, they were indeed both implemented in 7.10, so no point beating a dead horse."
haskell,39qx15,gfixler,1 point,Mon Jun 15 16:38:53 2015 UTC,"There was a poll and as far as I recall 75% were for implementing FTP so I would say it was pretty well supported too, even if support wasn't universal."
haskell,39qx15,Mob_Of_One,1 point,Tue Jun 16 13:03:08 2015 UTC,"That is something that gets harder as more and more people adopt the language and get angry at breaking changes.   This is why I'm not excited about Haskell gaining a lot of popularity. We have this one place where we're allowed to try really hard over long periods of time to get everything right, and I see people all the time championing its move into the mainstream."
haskell,39qx15,FPguy,6,Mon Jun 15 09:47:16 2015 UTC,Sounds right to me. I think SPJ noted how where to put the commas in that statement in one of his talks.
haskell,39qx15,Mob_Of_One,37,Sat Jun 13 22:17:51 2015 UTC,"I was at a talk where he explained it this way:  avoid $ success at all costs   This of course is quite different from:  (avoid success) at all costs   Shortly after that talk, he invested his own money in FP Complete (where I am founder/CEO) so you know he does want to see Haskell succeed."
haskell,39qx15,davidwsd,12,Sat Jun 13 23:24:25 2015 UTC,I'd never seen the Haskell-y parse of the sentence. That's quite clear :)
haskell,39qx15,theonlycosmonaut,10,Sat Jun 13 23:28:06 2015 UTC,"Unfortunately, to non-haskellers    avoid $ success at all costs    looks like    avoid monetary success at all costs   so its probably best not to publicize that phrasing too widely."
haskell,39qx15,donri,4,Sun Jun 14 05:49:05 2015 UTC,"avoid (success at all costs)   is just as clear and goes with the second, inexplicably-parenthesised parsing of the sentence. :)"
haskell,39qx15,LePotatoEspeciale,2,Sun Jun 14 07:15:31 2015 UTC,I usually present it with a colon:   avoid: success at all costs
haskell,39qx15,FPguy,1 point,Sun Jun 14 10:32:18 2015 UTC,"I'm new to Haskell, can someone explain what those statements mean?"
haskell,39qx15,LePotatoEspeciale,3,Sun Jun 14 17:54:28 2015 UTC,"a $ b c d e is just an alternative syntax for a (b c d e).  So in normal English: we want to avoid ""success at all costs"" which is quite different from ""avoid success, at all costs""."
haskell,39qx15,tonyday567,2,Sun Jun 14 18:54:47 2015 UTC,Thank you!
haskell,39qx15,nosewings,6,Sun Jun 14 19:29:42 2015 UTC,"It wasn't in the original statement, but memes evolve and the motto has also come to represent perjoratives about haskell practice - make stuff trickier than it has to be, obfuscate, invent technical complexity where practical solutions would suffice, be academic not commercial.  I still wear the hair shirt on haskell pride days, but the motto is too clever.  I want haskell to be successful."
haskell,39qx15,yitz,8,Sat Jun 13 23:15:14 2015 UTC,Anyone who takes the motto as evidence against Haskell is just looking for a reason to dislike it.
haskell,39qx15,beerdude26,6,Sun Jun 14 01:56:15 2015 UTC,"While SPJ's exegesis is a clever way out, I think the original intention really was what it sounds like. But it was tongue-in-cheek.  The ""slogan"" was a play on an inherent contradiction in SPJ's original goals for GHC: it was pure research whose goal was to prove that it is possible to develop a compiler for a pure functional language that is practical enough to be used in industry. But by achieving that goal, the compiler will become unsuitable for pure research."
haskell,39qx15,cgibbard,1 point,Sun Jun 14 11:32:45 2015 UTC,"Whatbis ""pure research""? Porting OCaml papers to Haskell using GHC seems pretty pure."
haskell,39qx15,cgibbard,3,Sun Jun 14 22:24:09 2015 UTC,"Success of a language comes with a lot of weight. The more users that you have, the more voices you have complaining at you whenever you realise that you'd like to change anything, even in cases where it's generally agreed upon that those changes would be a good thing overall.  Haskell has probably already failed to avoid success in the sense that was originally intended. There's still a surprising extent to which changes are getting pushed through in the basic libraries, but things have been pretty conservative overall for a pretty long time now.  In order to make fundamental progress on the language itself, we might need a new language at this point though.  Personally, for example, I'd like to see something pretty close to Haskell, with lazy evaluation by default and properly coherent type classes, but with a full dependent type system. Doing this right while trying to keep the name ""Haskell"" would likely break too much code to keep everyone happy."
haskell,39qx15,beerdude26,2,Sun Jun 14 14:26:41 2015 UTC,Sounds like a simple fork of GHC is in order by someone prominent in the community and competent to direct these changes?
haskell,39qx15,cgibbard,2,Sun Jun 14 15:04:07 2015 UTC,Quite possibly. It would be nice to hang on to all the work done on the backend and runtime system. Replacing the internal type system would be no small task though.
haskell,39qx15,beerdude26,1 point,Sun Jun 14 17:38:52 2015 UTC,That's pretty much Idris.
haskell,39qx15,cgibbard,2,Sun Jun 14 22:24:54 2015 UTC,"No it's not. Idris is strict by default, and has a different design philosophy behind its implementation of type classes. Both of these things have a pretty big impact on the style of programming which can be adopted in the language.  Don't get me wrong, Idris is great, but it's not exactly what I'm looking for as my next favourite language to get things done in."
haskell,39qx15,gfixler,1 point,Mon Jun 15 00:29:11 2015 UTC,"Apologies. What is type class coherence, then?"
haskell,39qx15,xkcd_transcriber,2,Mon Jun 15 05:53:08 2015 UTC,"The property that for any type class C and any type T, there is a guarantee that instances C T are globally unique, so if you obtain two of these from different places, you know they're actually the same instance, and don't have to worry about which one is being used.  It's not enough, for instance, to allow people to define whatever instances they like without checking for overlaps and then just pick whichever one you find first when trying to decide on an instance.   Apart from data structures with invariants like Set/Map and their relationship with Ord (using two different orderings screws everything up), things get even more subtle once you have existential types with instances packed away in them, perhaps being unpacked by functions that also explicitly get an instance of the same class. Since you're not explicitly supplying the instance parameters, you really don't want to have to worry about which instance is getting passed along by the compiler, and the only reasonable way to not have to worry is if that instance is globally unique."
haskell,39qsxq,possibly-necessary,3,Sat Jun 13 21:19:20 2015 UTC,"Any kind of criticism, suggestion or request is appreciated! I will do all I can to address any such feedback."
haskell,39qsxq,gelisam,5,Sat Jun 13 21:47:49 2015 UTC,"I'd add an example to that readme, preferably one which demonstrates how concolic testing differs from other approaches."
haskell,39qsxq,roche,3,Sun Jun 14 00:51:42 2015 UTC,"I second u/gelisam: this certainly needs explained examples, especially since many (including me) just heard about ""concolic testing"" for the first time. The amount of setup this requires (including a patched jhc and an ancient version of llvm) is prohibitive. To have people try this, you could expose this as a web service or offer a downloadable docker image with everything prebuilt and preinstalled."
haskell,39qsxq,roche,1 point,Sun Jun 14 06:45:11 2015 UTC,"Examples are on the way! I'd love to provide this as a web service, do you have any cheap or free hosting suggestions?"
haskell,39qsxq,bgamari,2,Sun Jun 14 18:27:08 2015 UTC,"I use Digital Ocean, it's $5/mo."
haskell,39qsxq,bgamari,1 point,Sun Jun 14 19:15:59 2015 UTC,"That looks pretty decent, I'll look into it!"
haskell,39re1v,zai_naom,5,Sun Jun 14 00:39:05 2015 UTC,"Visual Studio Visual Studio, or Visual Studio Code?  Because the latter is based on Atom and Atom has pretty good Haskell support already.  Either way, if you're going to do this, I recommend using:  https://github.com/fpco/ide-backend  https://github.com/chrisdone/ide-backend-client"
haskell,39re1v,Mob_Of_One,2,Sun Jun 14 01:18:28 2015 UTC,"I would also recommend ide-backend(-client) for new editor plugins, but there is currently an open issue regarding Windows compatibility. Ide-backend currently relies on the unix package and therefore does not compile on Windows systems.  Furthermore, ide-backend currently assumes a server-like environment where data and source files have to be explicitly added to the current session in order to be registered by the running GHC process. This is however going to change in the future."
haskell,39re1v,Codas89,2,Sun Jun 14 07:54:16 2015 UTC,"There used to be one, but it's been abandoned."
haskell,39re1v,Hrothen,2,Sun Jun 14 01:18:16 2015 UTC,"https://github.com/LukaHorvat/HaskellPackage  You can try to get this to work, but it's probably better served as an example of how to make one. I do have plans to update it to something that actually works, but the Atom extension kind of does everything I want it to, and doesn't feel like a massive hack like writing VS extensions is."
haskell,39q7an,elbiot,9,Sat Jun 13 18:07:30 2015 UTC,"There are indeed a few things to keep in mind. The differences between foldl, foldl' and foldr are the go-to example.   I also remember an example when sharing could result in a space leak, something like:  x = do  let list = [1..1000000]  mapM_ print list  print (sum list)   The reasoning went as follows: because list is used in line 4 as well, the elements cannot be garbage collected and remain on the heap, resulting in huge memory usage. However, if one inlined list in both locations, like so:   x = do  mapM_ print [1..1000000]  print (sum [1..1000000] )   ... the program is optimized to run in constant memory, because each time a number is printed on line 2, it is immediately marked for garbage collection. Could someone confirm this?  However, most of the heavy lifting optimization-wise has already been done by library authors. The wai package, for example, has gone through extremely thorough optimization. The extreme composability of functional programming languages means that you can easily stand on the shoulders of these giants."
haskell,39q7an,beerdude26,2,Sat Jun 13 18:33:11 2015 UTC,"Thanks.  I think I follow what you're saying, but this doesn't run for me so I can't actually see it. I think it's because putStrLn needs a char, not an int.  I tried to use intToChar but it isn't in scope.  I am a total noob."
haskell,39q7an,errorprawn,1 point,Sat Jun 13 18:54:05 2015 UTC,"You can convert integers to strings with the show function (for every instance of the Show typeclass such a function must exist).  In this instance, you should be able to use for example  mapM_ (putStrLn . show) [1..1000000]"
haskell,39q7an,bheklilr,5,Sat Jun 13 19:00:48 2015 UTC,"Or use print since its definition is print = putStrLn . show, so just mapM_ print [1..1000000]"
haskell,39q7an,beerdude26,1 point,Sat Jun 13 19:13:00 2015 UTC,"Woops, missed that, sorry! You can use print instead of putStrLn.  EDIT: Edited the OP."
haskell,39q7an,ReinH,20,Sat Jun 13 19:31:56 2015 UTC,"Interpretation vs. compilation is a red herring.  The languages you gave as examples aren't even very good ones: Haskell has an interpreter and CPython is a bytecode compiler. And anyway, languages are not compiled or interpreted: implementations are. Instead of thinking about languages (and their implementations) in terms of compiled vs. interpreted, it's more useful to consider their evaluation semantics, runtime systems, and so on. This is where you'll find the differences between Python and Haskell that most affect performance."
haskell,39q7an,kqr,12,Sat Jun 13 19:32:32 2015 UTC,"It is not possible to compile Perl, for example, which makes it a purely interpreted language."
haskell,39q7an,ReinH,5,Sat Jun 13 19:46:35 2015 UTC,The exception that proves the rule. ;)
haskell,39q7an,hiptobecubic,2,Sat Jun 13 19:47:53 2015 UTC,I have never understood this expression and this time is no exception. :(
haskell,39q7an,_AndrewC_,2,Sun Jun 14 15:21:43 2015 UTC,"*edit: Thanks to ReinH for the wikipedia link, introducing my new first paragraph:  The latin phrase was used for an argument that a law or rule exists from the evidence that there is a stated exception, so that if I say ""free parking after 5pm"", this exception proves that there is a general rule that you must pay for parking.  In these days of postmodernism, folk choose any interpretation they fancy, and I've known people assert that there are no absolutes, so all rules have exceptions, that this is an exception, and that therefore the rule is right. (This is so far from my understanding of logic that it can be very hard to find common ground with them. Typically it's frustrating to discuss truth with postmodernists since anything is up for reinterpretation, in my opinion to the point of vacuousness.)   My impression is that most people use it to mean that the case under discussion is very rare and not at all typical - that whilst this apparently contradicts something, that thing is nevertheless generally true even if it isn't absolutely true. This is consistent with using the word ""prove"" to mean ""test"", so making the statement that it's the exception that challenges the rule."
haskell,39q7an,ReinH,2,Sun Jun 14 19:15:55 2015 UTC,https://en.wikipedia.org/wiki/Exception_that_proves_the_rule
haskell,39q7an,autowikibot,1 point,Sun Jun 14 19:40:24 2015 UTC,"Exception that proves the rule:       ""The exception that proves the rule"" is an exception to a generally accepted truth. This is an old fashioned use of the word 'prove', which means 'to test'. It does not mean that it demonstrates a rule to be true, but that it tests the rule. It is usually used these days when an exception to a rule has been identified: for example, Mutillidae are wasps without wings, and therefore are an exception that proves (tests) the rule that wasps fly.  ""The exception [that] proves the rule"" also means that the presence of an exception applying to a specific case establishes (""proves"") that a general rule exists. For example, a sign that says ""parking prohibited on Sundays"" (the exception) ""proves"" that parking is allowed on the other six days of the week (the rule). A more explicit phrasing might be ""the exception that proves the existence of the rule.""     Relevant: Wizard's First Rule | La Excepción | Apples and oranges | Counterexample   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Call Me"
haskell,39q7an,hiptobecubic,2,Sun Jun 14 19:41:05 2015 UTC,Ahhhhh. That makes sense. Thanks!
haskell,39q7an,conklech,1 point,Sun Jun 14 21:46:26 2015 UTC,"I also take ""exception that proves the rule"" to indicate a situation where one notices or perceives an anomaly, which inspires awareness of a previously-unnoticed pattern."
haskell,39q7an,quchen,3,Mon Jun 15 16:46:29 2015 UTC,"How so? I imagine it being very hard, but why would it be impossible?"
haskell,39q7an,irishsultan,8,Sat Jun 13 22:48:34 2015 UTC,"Short explanation: because depending on what a variable contains parsing differs, so you need to know the type of a variable (in an untyped language) to know how to parse a statement.  http://www.perlmonks.org/?node_id=663393"
haskell,39q7an,BurialOfTheDead,6,Sat Jun 13 22:55:47 2015 UTC,Could you not compile all possible valid parses then select it at runtime?
haskell,39q7an,bb010g,4,Sat Jun 13 23:22:04 2015 UTC,It's Perl; that's going to be a lot of compiling.
haskell,39q7an,BurialOfTheDead,1 point,Sun Jun 14 02:33:35 2015 UTC,"Those compiled routines would exist already though it'd end up being a subroutine call, like a library call in other langs."
haskell,39q7an,vsdcacc,3,Sun Jun 14 13:45:27 2015 UTC,"You can say the type is (A,B,C)... for the A,B,C... possible types, or even generate an evaluation logic that is inserted as a kind of wrapper and executed before the 'statically unparsable' value is used - like a small inline interpreter."
haskell,39q7an,jmite,2,Sun Jun 14 05:48:14 2015 UTC,"I suspect it's a case where you can compile it, but your runtime library basically ends up being an interpreter that does the real work."
haskell,39q7an,HEGX64,1 point,Sun Jun 14 06:38:26 2015 UTC,Or Befunge (a language designed to be uncompilable)
haskell,39q7an,twiceaday,1 point,Sun Jun 14 04:51:13 2015 UTC,"perlcc begs to differ, though to be fair it can't compile all perl programs."
haskell,39q7an,MrWoohoo,2,Sun Jun 14 06:52:34 2015 UTC,"t's more useful to consider their evaluation semantics, runtime systems, and so on.   Excellent point, thank you."
haskell,39q7an,augustss,5,Sat Jun 13 23:12:50 2015 UTC,With thunks and laziness I've imagined Haskell as compiled snippets threaded together by a runtime interpreter. I would be interested in feedback from those who know if this is a useful mental model.
haskell,39qd62,enzain,11,Sat Jun 13 18:58:10 2015 UTC,In the original definition of Haskell there was automatic deriving.  If you left out the deriving clause you would get as much as possible.  This was removed for the sake of being more explicit; it was tricky to predict exactly what a left out deriving would give you.
haskell,39qd62,augustss,8,Sun Jun 14 10:31:11 2015 UTC,"Often, the point of making a newtype is to restrict the interface of the type. Automatically deriving everything would defeat this purpose. Also, sometimes you want custom instances that would not be the same as the auto-derived code, for example for Show and Read.  It seems like there are two separate problems in this. The first problem only applies if there are Show instances already implemented.  If you want a temporary fix for the first problem so that you don't have to type out the full constraint every time, you can use PartialTypeSignatures. Here's an example:  {-# LANGUAGE PartialTypeSignatures #-}  showIt :: _ => a -> String showIt x = show x   You can also enable -fno-warn-partial-type-signatures to stop the warnings from happening, but I wouldn't suggest it in this case. The warnings will help you remember to remove the constraints later on."
haskell,39qd62,Roboguy2,1 point,Sat Jun 13 19:08:55 2015 UTC,"I see your point but isn't that more the exception than the rule, wouldn't you always want as many derives as possible?(maybe add some sugar to prevent it) Also I don't see why custom instances couldn't just always override the defaults instances?  Secondly I am hopelessly dependent on ghc-mod so only 7.8 for me :/ and PartialTypeSignatures  is a brand new feature in 7.10."
haskell,39qd62,Roboguy2,4,Sat Jun 13 19:28:07 2015 UTC,"That would complicate things a lot. You can only have at most one instance of a type class for any type so this would need to be an exception to that rule, making the type system more complicated. You wouldn't be able to look at a source file and quickly determine what instances are being implemented and what those implementations are (whether they are default or not). To me, that is a pretty big downside. It's also not clear to me how this would interact with orphan instances.  Also, the most instances you can derive for a newtype is all of the instances for the underlying type, but that is something you would often not want to do. I would say that that would be the exception, actually. Usually, you either want a newtype in order to restrict the interface from the underlying type or in order to make a instance of a type class that is different from the instance of the underlying type (such as ZipList or a Int newtype that does modular arithmetic). In both cases, you wouldn't want this behavior.  Basically, to me it looks like something that solves a pretty minor problem (a bit of extra typing) by potentially introducing some problems, reducing clarity a bit and possibly changes to the type system itself (especially with regard to the first part about avoiding writing out constraints in function types).  It might make sense to have an extension that lets you write something that tells GHC to derive everything it can, but I wouldn't want that to be the default operation.  That's unfortunate about ghc-mod. It looks like a fix for 7.10 is in progress on github."
haskell,39qd62,edwardkmett,1 point,Sat Jun 13 20:35:02 2015 UTC,The problem is functions such as (!) because nothing automatically derives show can't print the data object in question when throwing an error. Which makes finding such a bug a near impossible task. I mean at the very least auto derive a ToString class.
haskell,39qd62,edwardkmett,5,Sat Jun 13 21:12:43 2015 UTC,"On the other hand, if you ""could"" print functions then you'd have to worry about the fact that now every function you write has to carry around enough information to print itself, and that you don't have to care just about how the function behaves on different values to consider it a ""different functions"" but rather how it prints. This pretty much shuts down almost every single optimization the compiler might attempt on your behalf."
haskell,39qd62,heisenbug,1 point,Sat Jun 13 21:24:20 2015 UTC,I don't see how that necessarily follows?  as it would only need to carry information it already was required to carry.
haskell,39qd62,Magnap,9,Sat Jun 13 21:37:34 2015 UTC,"Not necessarily. The optimizer spits out code that only bears the barest resemblance to the function you wrote.  Once you start playing javascript-like games where you can ""print"" functions, now someone is going to come along and check to see if the string you print for the function is the same as some particular constant value or something.  If your optimizer changes the definition of the function?   (\x y -> x) const (\y z -> y) (\w y z -> y) ""oogabooga""   are all equivalent functions extensionally. They do exactly the same thing. You can substitute one for the other in every single possible context today.  They won't produce the same string when your magic function printer prints them, and in the status quo we equationally rewrite down to simpler and simpler forms as we run rather than constantly build things up into messier and messier functions.  In your world you have to keep all that noise forever because someone sometime might try to ask you for it and you have to be able to supply it.  These functions are no longer equivalent!  Moreover, the compiler takes things from its surface representation and feeds it through multiple intermediate layers down into entirely different language to execute. The high level semantics of the code you started with just aren't there after it has gone through the compiler. The type information is erased, etc. We can throw all that stuff away at runtime because it did its job at compile time, and carrying it around at runtime would change the asymptotics of your code.  Your function isn't defined by its semantics on values its defined by a weird mishmash of its semantics on values, and how it prints when handed to your magic function.  The optimizer now dare not change the latter because it'll change how things compare for equality if you compare the ""toString""s of the functions!  Little versions of this abound in other languages that try to shoehorn random extra semantics onto lambdas.  e.g. scheme allows for you to check to see if two lambdas are the same lambda by allocating a ""location"" tag every time you create a lambda. This pretty much rules out whole swathes of optimizations because you have to live in fear that your users might try to check if your function is the same function object in memory closing over the same stuff as another function object in memory.  You're adding a ton of semantics.  Consider the equational reasoning steps allowed in   http://arxiv.org/pdf/1309.5135v1.pdf  sum (map sqr (down z)) = foldr (+) 0 (build (\c n -> foldr (c . sqr) n (down z))) = foldr ((+) . sqr) 0 (down z) = let loop x = if x==0 then 0 else sqr x + loop (x-1)    in loop z   takes a high level specification and equationally rewrites it into something that is damn near optimal from a machine standpoint.  They are extensionally equal, but behave differently internally. GHC will for you today change one into the other.  The details of every closure a function happens to touch, etc. aren't something I want it to have to regurgitate on demand. It is an evolutionary dead-end in language design."
haskell,39qd62,merijnv,1 point,Sat Jun 13 21:58:07 2015 UTC,"Great read, very interesting information; however I wasn't exactly looking for this to cover functions anyway, I just wanted to have toString on data and newtypes. I know function would have to be covered as well, but for instance in F# if you toString on a function it just becomes something like ""#21312Function"" and I don't see why it couldn't do the same in haskell without breaking optimization."
haskell,39qd62,orclev,3,Sun Jun 14 04:32:45 2015 UTC,Because the idea is that Read and Show are inverses in a context-free way.
haskell,39qd62,gelisam,1 point,Sun Jun 14 09:27:49 2015 UTC,"To put it in a less formal way: if you want show to be a pretty-printer, read has to be a parser."
haskell,39qd62,tejon,1 point,Sat Jul 4 14:48:35 2015 UTC,Which information is it already carrying? If you just wanted to print the type of a function as it's show then you need to suddenly start storing the types of the function somewhere.
haskell,39po7z,sammecs,17,Sat Jun 13 15:17:53 2015 UTC,This exists.  http://hackage.haskell.org/package/dimensional  It worked well for my uses.
haskell,39po7z,tom-md,9,Sat Jun 13 16:15:31 2015 UTC,The dimensional package now comes in a few different flavors - eg dimensional-tf uses type families.  I have some IHaskell notebooks exploring dimensional-tf and  the units package at https://github.com/DougBurke/astro-haskell/
haskell,39po7z,dougburke,1 point,Sat Jun 13 18:20:50 2015 UTC,"This should probably be formulated as ""this exists, you could draw inspiration from there"" because OP specifically asked how to write such a library."
haskell,39po7z,goliatskipson,6,Sun Jun 14 05:48:34 2015 UTC,This is called dimension typing. Here's a wiki page on it.
haskell,39po7z,beerdude26,6,Sat Jun 13 15:41:42 2015 UTC,"There are a few packages that do this using type-level numbers encoding the power of each dimension you use. Here is a simple example (it uses the type-level naturals that are built in in GHC, but integers would actually be more appropriate).  So meter has type Value 1 0 v, time has type Value 0 1 v. The operations try to match the dimensions:  > meter .+. second     Couldn't match type ‘0’ with ‘1’     ... > meter .*. meter .*. meter .+. cubicMeter 2.0   I wrote unittyped to create an open-world approach to this: the dimensions weren't hard-coded in the type, but extensible. This worked by creating type-level maps from types to numbers. Sadly, I haven't updated it in a while, so the code is quite bitrotten by now."
haskell,39po7z,xnyhps,1 point,Sat Jun 13 18:23:28 2015 UTC,"As others have mentioned, there's some excellent work in this area based on the idea that we can encode the units of a quantity using type-level integers. The dimensional-tf and units libraries are probably the current state of the art. The downside of this approach is that errors are reported in terms of numeric inequalities rather than the units they represent, exposing the underlying encoding to users of the library. This is a bit unsatisfying compared to units in F#.  In uom-plugin (see also the Haskell Symposium paper) I've been exploring an alternative approach, using a GHC typechecker plugin to solve constraints on units directly. This should give better type inference behaviour and simpler error messages."
haskell,39p4he,CynicalHarry,10,Sat Jun 13 11:39:57 2015 UTC,"You could use .:, .:., .:: etc. from the composition package."
haskell,39p4he,Regimardyl,3,Sat Jun 13 12:14:45 2015 UTC,Awesome. Thats precisely what I was looking for. Thank you.
haskell,39p4he,afmrak,1 point,Sat Jun 13 12:52:27 2015 UTC,I've wanted this for so long. Thanks for suggesting
haskell,39p4he,dmwit,6,Mon Jun 15 16:18:59 2015 UTC,"See also semantic edit combinators. With the right glasses on, (result . result) (foldl (+) 0) foo is more readable than (foldl (+) 0 .) . foo."
haskell,39p4he,winterkoninkje,5,Sat Jun 13 19:29:16 2015 UTC,"Instead of the composition-based approach of (.), (.:), etc, an alternative form of point-free programming is to use the ($::) and (~>) combinators from pointless-fun"
haskell,39p4he,twistier,2,Sun Jun 14 01:23:33 2015 UTC,"Here is another way to write it. I did not do this very carefully, so be wary of mistakes.  allTargeting :: Lesson s -> WeightMap -> Int allTargeting =   ( fmap (foldl (+) 0)   . sequenceA   . sequenceA    . (fmap . fmap) (Map.findWithDefault 0)   )   [ Slot . timeslot    , Day . day    , uncurry Cell . time    ]   Edit: Yup. It's wrong."
haskell,39p4he,yitz,3,Sat Jun 13 13:46:02 2015 UTC,"That doesn't actually work though. What does is   allTargeting =   ( foldl (+) 0   .: sequenceA   .: sequenceA    . (fmap . fmap) (Map.findWithDefault 0)   )   [ Slot . timeslot    , Day . day    , uncurry Cell . time    ]"
haskell,39p4he,Vektorweg,2,Sat Jun 13 14:35:38 2015 UTC,"For skipping two, you want ""owl eyes"" (avoiding the less community-inclusive name for it some people use):  ((.).(.))   But that doesn't generalize nicely beyond two."
haskell,39p4he,SkoomaMudcrab,-9,Sun Jun 14 19:56:06 2015 UTC,"You need boobs, as suggested with the composition package.   (.:) = (.).(.)"
haskell,39ojcx,TheCriticalSkeptic,21,Sat Jun 13 06:42:45 2015 UTC,"The product/coproduct duality is a duality of the categorical properties of the type constructors.  It is really not the case that ""plus"" and ""times"" are ""dual"" in a ring in any obvious way.   Observe that product/coproduct do have almost the ring structure though.  The kind of (,) is * -> * -> * and similarly, Either :: * -> * -> * which is just the curried form.  They are both bifunctors.  They each commute and are associative up to isomorphism, and they even have the distributive laws.  What makes the type (a,b) the product of the type a and the type b?  Well, categorically, it is that you have two morphisms  fst :: (a,b) -> a snd :: (a,b) -> b   that satisfy a universal property, namely if I have any type c and arrows f :: c -> a and g :: c -> b there is a unique arrow h:: c -> (a,b) such that  fst . h = f   and  snd . h = f   and this can be spelled out:  h = \x -> (f x,g x)   so to get coproducts we just dualize things.  That is, we just point the arrows in the other direction.  We need arrows a ->Either a b and b -> Either a b but that is easy enough  Left :: a -> Either a b Right :: b -> Either a b   and we need a universal arrow.  Given any c with f :: a -> c and g :: b -> c we need a unique arrow h :: Either a b -> c such that  f = h . Left and g = h . Right.  Indeed, such an arrow exists  h = \x -> case x of                Right y -> f y                Left y -> g y"
haskell,39ojcx,philipjf,8,Sat Jun 13 07:31:56 2015 UTC,"To see that conjunction is the product in a poset P, consider two elements a, b ∈ P (recall that a morphism a → b in P is the same thing as the inequality a ≤ b):   we have projections fst : a ∧ b ≤ a and snd: a ∧ b ≤ b given any morphisms f : c ≤ a and g : c ≤ b there is a unique morphism (f,g) : c ≤ a ∧ b.   That disjunction is the coproduct is just a dual argument.  Since you come from rings and groups, you should ponder on the difference between the coproduct of Abelian groups vs. the coproduct of groups. For instance, what is the difference between ℤ + ℤ formed in the category of abelian groups Ab and ℤ + ℤ formed in Grp? The ambient category matters – you can't tell what is what just by staring at the type signatures."
haskell,39ojcx,andrejbauer,6,Sat Jun 13 09:23:47 2015 UTC,"/u/philipjf correctly says that you should be comparing the type signatures of (&&) and (||), (*) and (+), to the kind signatures of the product and coproduct types in Hask. It's more convenient to curry everything:      (||) :: Bool -> Bool -> Bool (**) :: Bool -> Bool -> Bool (+) :: Int -> Int -> Int (*) :: Int -> Int -> Int Either :: * -> * -> * (,) :: * -> * -> *   This is because coproduct (Either) and product ((,)) are type constructors, so the correct notion to consider is not a type signature but a kind signature, if you want to compare it to type signatures of functions on types.      In terms of the categorical diagrams defining product and coproducts, it is in both situations the case that the resulting object is determined by two objects. You start with two objects A,B of your category, and form either the coproduct A+B, or the sum AxB. So in both cases you expect a kind signature * -> * -> *, or a (in appearance circular, but actually not) kind signature (*,*) -> *. You can see this as follows: given a category C, the ""coproduct formation"" and ""product formation"" are functors of type C x C -> C, where C x C means a product category, which is a different notion than the actual consideration of products inside the category. So coproduct and product, despite being dual notions internal to the category C, both look like functors C x C -> C, essentially for the reason that both coproducts and products are determined by two objects. In other words: despite one notion being a colimit and the other being a limit, they are both defined over the same diagram (the diagram being a diagram of two objects in the category, with no arrows)."
haskell,39ojcx,presheaf,1 point,Sat Jun 13 09:36:33 2015 UTC,"I feel that for Bool, True is like 1 and False is like 0, with && a product and || a sum.   In sets, monoids, groups, rings and fields, you can make the cross product of two objects and it's the product in that category, but you can only do the category theoretical sum in Set, since the need for a common identity element destroys the disjointness of the union.   (For example, you'll have problems using a monoid structure for Bool and another for Integer to make a monoid structure for Either Bool Integer.)"
haskell,39ojcx,_AndrewC_,2,Sat Jun 13 09:49:04 2015 UTC,"Specifically, they're sum and product modulo 2.  So 1 * 1 = 1 and T & T = T, while 10 = 01 = 0*0 = 0, so T & F = F & T = F & F = F.  Likewise, 1 + 0 = 0 + 1 = 1, so T ^ F = F ^ T = T, but 1 + 1 = 0 (modulo 2) = 0 + 0, so T ^ T = F ^ F = F.  Note that this is technically xor, but then again, Either is as well (it doesn't contain both an a and a b)."
haskell,39nzcj,timdees40,1 point,Sat Jun 13 03:08:51 2015 UTC,The article's link to SPJ's contracts paper is broken.
haskell,39orx6,muzzlecar,4,Sat Jun 13 08:38:29 2015 UTC,"You can't get such a warning in general.  Suppose you wrote  instance (Foo f, Convertable a) => Convertable (f a) where   convert d x = convert d <$> x   and then in an unrelated module someone defined instance Foo [a].  Then you have overlap with no chance of detecting it at the compile time of your module."
haskell,39qsie,xSnowCrash,3,Sat Jun 13 21:15:30 2015 UTC,http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/  Controversial but I'm open to all sides.
haskell,39qsie,rdfox,3,Sun Jun 14 01:34:53 2015 UTC,"at the end of the article, it said it did indeed made him a better programmer but it kinda messed up his code in a sense that he was never satisfied with it / unreadable, which demoralized him."
haskell,39qsie,Vikaton,1 point,Sun Jun 14 14:23:36 2015 UTC,I can relate.
haskell,39qsie,rdfox,4,Sun Jun 14 14:31:32 2015 UTC,I do not see any content worth reading or sharing there.
haskell,39qsie,quchen,3,Sat Jun 13 23:04:17 2015 UTC,"Perhaps the goal was not to share, but to request contributions? This subreddit has seen many discussions about the ways in which learning Haskell makes you learn new ways of approaching problems, which may or may not make you a better programmer by   allowing you to find elegant solutions to problems, but making you forget how you used to solve those same problems in mainstream programming languages, or dislike having to resort to such seemingly-inelegant solutions.   I'm not familiar with Quora, is it an appropriate place to record such discussions for future reference? I find it hard to find old discussions on Reddit."
haskell,39n67u,agocorona,1 point,Fri Jun 12 22:56:00 2015 UTC,"You're not really ""using non-determinism"" here, and the use of the term ""non-determinism"" to describe having a parallel ""choose"" operator is severely stretching the definition."
haskell,39n67u,kamatsu,3,Mon Jun 15 06:35:41 2015 UTC,Then what the list monad does? See my paragraph about backtracking and non-determinism.   The Transient monad is inherently for non-deterministic computations involving events and multithreading. For the examples of the article what I wanted to do is to make it as close in behaviour to the list monad as possible to allow the programmer to use the same intuitions.
haskell,39n67u,kamatsu,1 point,Mon Jun 15 12:43:12 2015 UTC,The list monad simulates nondeterminism by sequential deterministic evaluation.   The only nondeterminism here is the evaluation order of threads. And this is not leveraged here in any way.
haskell,39m17i,asswaxer,14,Fri Jun 12 18:02:35 2015 UTC,"""Constant applicative form"" is a noun. So you'd say something like ""f is a CAF"" rather than ""f is in CAF"". A CAF is an expression with no free variables that isn't a lambda. Example: z = [1..100]. Nonexample: z n = [1..n]. Nonexample: z = \n -> [1..n]. A partially applied function is also a CAF, although I don't understand why. So this is a CAF: z = (+) 4. And this is not: z = \x -> 4 + x.  CAFs are often used to save the results of computing functions by assembling a data structure that contains all of the input/output pairs of your function and partially filling it in as needed. The classic example is calculating the Fibonacci sequence.   fib :: Int -> Integer fib n = fibs !! n fibs :: [Integer] fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   Here fib is a function and fibs is a CAF.  So can we pull off this trick for any function? I doubt it. You would need some kind of sensible data structure for the domain of your function, which might be wonky. Consider map :: (a -> b) -> [a] -> [b]. To memoize this you'd need to be able to store arbitrary functions and find them again later.  The CAF trick is also arguably not the best way to memoize things in Haskell. There are a bunch of cool toys in Data.Memocombinators aimed at making memoization easy. Check out their example of fib:  import qualified Data.MemoCombinators as Memo fib = Memo.integral fib'   where   fib' 0 = 0   fib' 1 = 1   fib' x = fib (x-1) + fib (x-2)   It looks almost exactly like the naive implementation of fib, but this is memoized. It will also be faster than my earlier example since they are surely using something better than a list to store results. (e: I checked. It looks like an IntTrie, so I'd expect their lookup cost to scale with log n rather than n.)  *****e: Oh! I just learned something neat. The benefit of partially applied functions being CAFs. Check this out: in Data.Memocombinators we have  type Memo a = forall r. (a -> r) -> (a -> r) (snip) -- | Memoize an ordered type with a bits instance. bits :: (Num a, Ord a, Bits a) => Memo a bits f = IntTrie.apply (fmap f IntTrie.identity)   and in Data.IntTrie we have   apply :: (Ord b, Num b, Bits b) => IntTrie a -> b -> a identity :: (Num a, Bits a) => IntTrie a   So if I have a function like f :: Thing1 -> Thing2 and there are  Bits, Ord, and Num instances for Thing1, then the expression z = bits f is a CAF by virtue of being a partially applied function. Inside the first argument to that function, which was eaten by the partial application, we have a memo table!  z = bits f z = apply (fmap f identity)     ^^^^^  ^^^^^^^^^^^^^^^             |              |        |              |--The memo table.        |--The function that we partially applied.   So if I understand the behavior correctly, GHC saves the information we gain about that data structure because it's consumed by the CAF."
haskell,39m17i,redxaxder,6,Fri Jun 12 21:36:08 2015 UTC,Everytime I look at that hackage page I end up staring at the source code wondering how that memos
haskell,39m17i,darkroom--,3,Fri Jun 12 22:45:57 2015 UTC,This is a completely awesome answer.
haskell,39m17i,_AndrewC_,2,Sat Jun 13 06:54:16 2015 UTC,"Hmm, but z n = [1..n] doesn't have free variables.  It therefore is a CAF, by your definition."
haskell,39m17i,_deepfire,1 point,Sun Jun 14 19:15:39 2015 UTC,thanks for this great answer.   This makes me ask: why does a function need to be a CAF to be remembered ? The (+) 4 vs \x-> x + 4 makes me wonder why it can't remember for values of x just like it remembers for the unnamed variable to (+) 4 ?
haskell,39m17i,redxaxder,3,Sat Jun 13 11:02:18 2015 UTC,"The (+) 4 vs \x-> x + 4 makes me wonder why it can't remember for values of x just like it remembers for the unnamed variable to (+) 4 ?   It's the 4 that gets shared, not unnamed variable. This is a better example of the difference between those two:    p = \x -> length [1..100000000] + x p' = (+) (length [1..100000000])   With p the length is recomputed every time and with p' it is shared between calls. (This is why the code for Data.Memocominators works.)  CAFs are an implementation detail of GHC rather than part of the language standard. In general it's up to the compiler to figure out when sharing computations is a good idea and when it is a bad idea.   There are cases where everyone can agree it's a good idea and would expect their Haskell compiler to do it. Like let x = fac 10 in x + x. There are also cases where the plumbing necessary to make sharing possible causes trouble. Consider this function:  avg :: [Double] -> Double avg xs = sum xs / length xs   If you pass in a big enough lazy list as an argument to avg you will run out of memory. Because xs is shared, the parts you aren't currently using (and could easily re generate) won't be garbage collected between the sum call and the length call (aside: which of those two functions happens first is also up to GHC). The ""right thing to do"" is to rewrite this to do everything in a single list pass, but the penalty for doing this the ""wrong way"" is harsher in Haskell than in, say, Python. You run out of memory rather than paying a time cost.   The people who went through a million cases and decided whether or not to do sharing for each one probably have good reasons for why GHC acts the way it does, but I don't know them. I expect there were a lot of grey areas where the decision could have gone either way, and maybe for some of them the decision will change in the future."
haskell,39m17i,jystic,3,Sat Jun 13 13:42:52 2015 UTC,"Slightly off topic, but, if one was to rewrite avg to do everything in a single pass, they should check out the awesome foldl library:  import qualified Control.Foldl as L  avg :: [Double] -> Double avg = L.fold (L.sum / L.genericLength)   or more generally:  avg :: (Foldable f, Fractional a) => f a -> a avg = L.fold (L.sum / L.genericLength)"
haskell,39m17i,Archaeanimus,3,Sat Jun 13 14:51:37 2015 UTC,\x -> someFunction x arg1 may be rewritten as flip someFunction arg1.
haskell,39m17i,hexbienium,2,Fri Jun 12 21:31:20 2015 UTC,Or (my Haskell linter just pointed this out to me today for the first time) as  `someFunction` arg1
haskell,39lhm6,cipher2048,12,Fri Jun 12 15:53:25 2015 UTC,My guideline is to never reach for TH except to eliminate a maintenance burden I've already introduced through code duplication.
haskell,39lhm6,rpglover64,5,Fri Jun 12 16:23:03 2015 UTC,"I agree with this but I'd add, ""and don't use it to generate serialization code that should never break or change without human intervention unless you're willing to write some very comprehensive integration tests""."
haskell,39lhm6,Mob_Of_One,4,Fri Jun 12 20:35:46 2015 UTC,"+1. If you're serious about compatibility you will write all serialization by hand. (That doesn't mean you can't do shorthands for common patterns, but you must have ultimate control. This is why I don't trust safecopy. In its entire history it has had at least one compatibilty break. That's enough for me to want to write all serialization/deserialization by hand.)"
haskell,39lhm6,Oremorj,2,Fri Jun 12 21:22:49 2015 UTC,"Been burned by this, have you?"
haskell,39lhm6,rpglover64,1 point,Sat Jun 13 11:11:28 2015 UTC,"Not yet, but I know a lot of people who have.  Unusually for a programmer, I try to learn from other peoples' mistakes.  IIRC, I use generic ToJSON instances in Bloodhound exclusively for trivial newtypes. I don't have the same objections to the use of Generics in general that others have."
haskell,39lhm6,Mob_Of_One,5,Sat Jun 13 17:13:09 2015 UTC,Why else would you use TH other than to reduce duplication?
haskell,39lhm6,Darwin226,11,Fri Jun 12 17:47:53 2015 UTC,To create a DSL?
haskell,39lhm6,kyllo,4,Fri Jun 12 18:17:15 2015 UTC,I mean I avoid using it preemptively.
haskell,39lhm6,rpglover64,2,Fri Jun 12 17:50:58 2015 UTC,"TH can introduce new identifiers, i.e. it can be unhygienic if you want it to. Higher-order-functions cannot do that."
haskell,39lhm6,Oremorj,8,Fri Jun 12 21:25:06 2015 UTC,"Just my opinion, so take this as one more data point, but I would treat Template Haskell as the abstraction nuclear option. Don't reach for it unless you still have a something that is causing you a problem after other avenues have been investigated and found lacking. That said, here are some justifiable uses:   Automatically implement an instances of a type class that would otherwise be tedious and error prone. Embed fragments of a well known language in your code (e.g. Hamlet embeds HTML). Basically, people are far more likely to know HTML than whatever HTML building EDSL you might come up with so the result is actually an improvement in clarity."
haskell,39lhm6,multivector,2,Fri Jun 12 19:15:20 2015 UTC,... and: If you need to declare new identifiers and such unhygienic things. TH is basically the not-quite-as-general equivalent of LISP/Scheme macros. (I'm not sure whether that's a good thing or a bad thing.)  Most things where you would reach for a macro in LISP/Scheme can be accomplished quite simply in Haskell with a higher-order function or two.
haskell,39lhm6,Oremorj,3,Fri Jun 12 21:20:08 2015 UTC,"Both TH and GHC.Generics are in some sense poorly documented. I can't speak to the maintainability of TH code; GHC.Generics has been pretty stable over the past few years, and I don't particularly expect it to change much in the future.  GHC.Generics is great for eliminating boilerplate  in one specific use case: generating mechanically derivable class instances. It can do other things, but in that niche it's great. You'll need a compendious and precise understanding of the Haskell typeclass system to use it effectively; alternately, working with Generics is a great way to acquire a compendious and precise understanding of the typeclass system. Newer features in that area, particularly closed type families, are also helpful in many circumstances."
haskell,39lhm6,conklech,2,Fri Jun 12 20:18:05 2015 UTC,"Adding ""genetic"" code? That's something else entirely, mate!  (I apologize to everyone reading this. It just seemed like a pun that had to be made. Again, sorry.)"
haskell,39kpik,Kiuhnm,13,Fri Jun 12 12:07:02 2015 UTC,"also you can try the usual supsects: emacs, vim and as an alternative to Atom maybe sublime text"
haskell,39kpik,CKoenig,2,Fri Jun 12 12:34:34 2015 UTC,"I have tried to learn how to use emacs several times, but I did not succeed. Is there a good way to learn emacs usage?"
haskell,39kpik,vitalijzad,11,Fri Jun 12 12:52:12 2015 UTC,"I find Spacemacs to be a lot less rough around the edges. It has an great menu system that shows up after hitting <space>, really helpful for emacs noobs."
haskell,39kpik,cies010,3,Fri Jun 12 14:02:16 2015 UTC,"Coming to spacemacs from vim, I like it but I feel like it's too easy to wander out of the manicured garden and get lost in the jungle. For example, spacemacs hasn't got its ctags story straight and the workaround is go learn elisp and add some features, which coming from vim is a lot to take on."
haskell,39kpik,rdfox,2,Fri Jun 12 17:39:02 2015 UTC,I had the same problem with vim actually. A system that is so complex that the investment to configure it fully to my needs is too big.  With Spacemacs the default layers plus some tweaks gets me to 90% of my needs. I think that is wonderful.  I did not manage to get Spacemacs working with SHM and ide-backend though. So anyone who has that working: pls show me yr configs :)
haskell,39kpik,cies010,6,Sat Jun 13 10:46:15 2015 UTC,Get out of here.
haskell,39kpik,PM_ME_UR_OBSIDIAN,0,Fri Jun 12 15:12:21 2015 UTC,I don't take orders from heathens.
haskell,39kpik,barsoap,5,Fri Jun 12 17:00:08 2015 UTC,"I've never used Emacs, my loyalties are with Vim. You still need to keep the trollbait out of /r/haskell."
haskell,39kpik,PM_ME_UR_OBSIDIAN,-2,Fri Jun 12 17:23:21 2015 UTC,"Oh, but vimscript is truly atrocious. I was always kinda envious about the emacs folks, there... until I discovered spacemacs, which is the best of both worlds.  My intention was to say ""spacemacs is actually vi"", as, believe it or not, the fact that ""emacs"" is a substring of ""spacemacs"" might confuse people. It was you who took it to flaming levels.  ...though I think by now spacemacs also offers disabling evil mode. Probably because it's just a very, very good emacs distribution of which yet other people got envious."
haskell,39kpik,barsoap,2,Fri Jun 12 17:35:34 2015 UTC,"The tutorial it comes with is pretty good but, as with all things, it's just practice. You don't have to start off doing everything in the most efficient way, you can add new commands and shortcuts to your repertoire gradually."
haskell,39kpik,Barrucadu,2,Fri Jun 12 17:57:54 2015 UTC,"There are reference cards for the Emacs key bindings (https://www.gnu.org/software/emacs/refcards/pdf/refcard.pdf) that were a great help to me when I got started. Really though the only commands you need to know to get started are how to open a file, save a file, indent and quit. Once you have those mastered, you can take advantage of more features."
haskell,39kpik,colonelflounders,2,Fri Jun 12 12:55:50 2015 UTC,Use the GUI one and do the Emacs tutorial.
haskell,39kpik,TheDeza,10,Fri Jun 12 15:19:40 2015 UTC,There will be a new version of Leksah this weekend that will fix that.  There is a work around described here.
haskell,39kpik,hamishmack,1 point,Sat Jun 13 07:44:30 2015 UTC,Thanks. I'll wait for the fix. Does the workaround cripple Leksah in any way?
haskell,39kpik,hamishmack,1 point,Fri Jun 12 12:25:03 2015 UTC,You can download the new version here.
haskell,39kpik,hamishmack,2,Fri Jun 12 15:46:48 2015 UTC,"Thank you, but I had many more problems with Leksah so I gave up. In particular, managing packages and modules is a pain. For instance I wasn't able to add a dependency to a project no matter how many times I told Leksah to add it.  I think that the main problem with Leksah is that too many things fail silently (or almost silently)."
haskell,39kpik,hamishmack,1 point,Sun Jun 14 17:53:07 2015 UTC,"but I had many more problems with Leksah   I am genuinely interested in them all!   For instance I wasn't able to add a dependency to a project no matter how many times I told Leksah to add it.   Now fixed in Leksah 0.15.0.3.  Thanks heaps for letting me know! I had no idea this had been broken (I tend to edit my cabal files with Package -> Edit -> With Text Editor).  It looks like it might have been a recent change to Cabal that broke this.  BTW did you know you can add dependencies on installed packages (those in ghc-pkg list) with Workspace -> Resolve Errors (Ctrl + R)?  For instance if you add this to a package that does not depend on vector:  import Data.Vector ()   Then when you get a GHC error about the hidden package hit Ctrl + R and Leksah will add the dependency to your package.  Resolve Errors (Ctrl + R) will also try to fix undefined errors by adding imports for you.   I think that the main problem with Leksah is that too many things fail silently (or almost silently).   Any examples you could give would be very helpful.  I use Leksah a lot, so I have a blind spot for these sorts of things."
haskell,39kpik,PM_ME_UR_OBSIDIAN,2,Sun Jun 14 18:41:09 2015 UTC,"For instance try to create a module with the name ""chapter_2"". It should fail because that's not a valid name for a module. But a beginner doesn't know that. Leksah doesn't complain but the module isn't created."
haskell,39kpik,baconated,1 point,Mon Jun 15 06:24:33 2015 UTC,"Cool.  That is a good one.  I think we have a similar issue logged for the package name in Package -> Add, but I do not think there was one for Add Module.  I have added an issue for you.  Please let me know if you can remember any others."
haskell,39kpik,PM_ME_UR_OBSIDIAN,8,Mon Jun 15 09:36:05 2015 UTC,"I'm on your side. My background is C#/F#/Java/Python. Tooling-wise, I've never found my joy in Haskell. Turns out that a lot of influential community members just don't believe in IDEs for some reason.  When I start coding in Haskell again, I'm going to try setting something up in Sublime Text. It won't be full-featured by any measure, but it's going to be something.  If I get pissed off enough I'll write a Visual Studio plug-in, but that's a quite serious amount of work and I can't see myself getting paid to do it."
haskell,39kpik,vagif,8,Mon Jun 15 10:15:38 2015 UTC,"Turns out that a lot of influential community members just don't believe in IDEs for some reason.   As a vim user, I also get this. The tools for vim just don't seem to be at the same level of quality as other languages. golang is something I poked a bit before starting Haskell, and the tools for golang and Haskell are just worlds apart.  AFAIK, in theory you should be able to make the tools for Haskell just as good or better than the ones for golang, but golang's culture is ""get shit done"" so they built tools that let them ""get shit done"". Haskell's culture seems more... academic, where people seem to take pride in being able to write code without any editor support.  Honestly it is my biggest pain point with Haskell."
haskell,39kpik,PM_ME_UR_OBSIDIAN,2,Fri Jun 12 16:59:22 2015 UTC,Honestly it is my biggest pain point with Haskell.   ...and also Haskell's one excuse for not having taken over the world already :)
haskell,39kpik,PM_ME_UR_OBSIDIAN,2,Fri Jun 12 17:49:44 2015 UTC,"Switch to the dark side (emacs) :) You will find that ""get shit done"" for haskell in emacs is miles ahead of anything you will ever have in vim."
haskell,39kpik,PM_ME_UR_OBSIDIAN,4,Fri Jun 12 18:27:42 2015 UTC,"I was about to choose F# over Haskell, but then I found out that F# lacks Higher Kinded Types.  This looks interesting by the way: Fstar"
haskell,39kpik,rdfox,3,Sat Jun 13 15:40:41 2015 UTC,"F# and Haskell are both excellent tools. IMO, there really isn't a wrong choice between the two.  If Haskell had F#'s tooling, though... or if F# had Haskell's type-level machinery... We'd have an incredible setup. I'm not sure which of the two would be hardest to achieve."
haskell,39kpik,PM_ME_UR_OBSIDIAN,2,Fri Jun 12 22:10:13 2015 UTC,I read that F# relies on reified generics provided by the CLR. Unfortunately they're not powerful enough to support higher kinded types.  A solution would be to follow Scala's approach and use type manifests which are carried around at runtime (the JVM erases types at runtime).
haskell,39kpik,Oremorj,2,Fri Jun 12 22:25:22 2015 UTC,F# could either have erased HKTs (which would make reflection less usable) or have runtime tags like Scala. Either way would screw with the C# interop.
haskell,39kpik,PM_ME_UR_OBSIDIAN,2,Sat Jun 13 00:11:21 2015 UTC,"I hope that in a few years FStar will be ready for serious applications. It supports dependent types and compiles to F#, OCaml and JS. I'm following the tutorial right now: tutorial"
haskell,39kpik,zz_h,1 point,Sat Jun 13 00:34:32 2015 UTC,I'm not seeing F* going anywhere. It never made it past the research prototype stage.
haskell,39kpik,PM_ME_UR_OBSIDIAN,3,Sat Jun 13 10:28:25 2015 UTC,Maybe microsoft will pay you.
haskell,39kpik,_AndrewC_,6,Sat Jun 13 17:49:25 2015 UTC,"I already work at Microsoft, and to be honest I've been thinking about transferring to the Visual Studio team in order to work on my one true love - developper tools! Right now my work situation is quite satisfying, but I'll probably make the jump in the coming years.  In the meanwhile, if only MSFT started offering 20% personal project time like Google does, I'd probably put mine towards Visual Studio plug-ins for functional languages."
haskell,39kpik,_AndrewC_,1 point,Fri Jun 12 17:45:23 2015 UTC,"AFAIUI 20% time (these days) actually just means that you'll work an extra day (above the usual 5) on your own projects... which they'll own all rights to. So I wouldn't feel that bad even if you're working for the Evil Empire :p.  EDIT: Yeah, I know that doesn't work out to 20%, but how else are they going to keep up the illusion other than calling it ""20%""? One of the many reasons I never interviewed with Google. Not that I'd necessarily consider Microsoft."
haskell,39kpik,_AndrewC_,1 point,Fri Jun 12 17:46:56 2015 UTC,The evil empire is looking less evil every day!
haskell,39kpik,Darwin226,2,Fri Jun 12 21:39:14 2015 UTC,I'm more worried about the evil empires that don't appear to be evil.
haskell,39kpik,Crandom,2,Fri Jun 12 22:28:12 2015 UTC,What about this: VS plugin.  It seems incomplete but it's a start.
haskell,39kpik,cies010,2,Sat Jun 13 07:00:13 2015 UTC,"I don't know too much about Emacs, but the problem with Vim is that it's a text editor first and an IDE second. Coercing it to behave like an IDE takes a lot of screwing around in text files, looking up documentation, configuring obscure packages - hours, even dozens of hours. Running Vim as an IDE is a part-time job for at least the first year.  Even then, you won't get a polished experience. For example, running Vim inside tmux subtly breaks both, and I haven't found another documented way to get tiled buffers. If you want to write your own Vim plugins, have fun with vimscript! By contrast, IntelliJ accepts any JVM language, Visual Studio any CLR language."
haskell,39kpik,cies010,13,Fri Jun 12 18:38:34 2015 UTC,Please refrain from personal attacks.
haskell,39kpik,vitalijzad,1 point,Fri Jun 12 17:12:11 2015 UTC,"The user has been banned, thanks for reporting, sorry it took so long to turn around."
haskell,39kpik,absence3,1 point,Fri Jun 12 17:34:38 2015 UTC,Thanks for your help. No need for apologies.
haskell,39kpik,implicit_cast,5,Fri Jun 12 17:41:56 2015 UTC,"Well, my point is that you could be adding something to the conversation by bringing a different perspective, but instead your content is getting drowned in all the rudeness. If you edited out the negative snide stuff, it would add a lot to the conversation."
haskell,39kpik,absence3,13,Fri Jun 12 18:17:33 2015 UTC,Try Atom with ide-haskell package. It has been making some very rapid advancements lately and is really decent to use.
haskell,39kpik,PM_ME_UR_OBSIDIAN,7,Mon Jun 15 14:20:32 2015 UTC,"It uses ghci-mod though, which is a pain to set up/doesn't work with 7.10.1 :/"
haskell,39kpik,PM_ME_UR_OBSIDIAN,2,Mon Jun 15 14:45:55 2015 UTC,"Not using 7.10.x as someone new to Haskell is certainly not a shame!  I would advice against using 7.10, unless you are developing libraries. I've not yet heard many shops that have moved their production code over to 7.10 either.  7.8 with Atom... I should try it myself if it has proper ide-backend suppport :)"
haskell,39kpik,enzain,1 point,Fri Jun 12 19:34:01 2015 UTC,Oops just noticed I misread ide-haskell as ide-backend...  Still Atom looks rather nice for Haskell:  https://atom.io/packages/ide-haskell
haskell,39kpik,enzain,2,Sat Jun 13 06:48:32 2015 UTC,"To download Atom, ho here:  https://atom.io  To install a package in Atom, see here:  https://atom.io/docs/v0.186.0/customizing-atom  After installing Atom, the complete command list is:  apm install ide-haskell apm install haskell-ghc-mod apm install autocomplete-haskell"
haskell,39kpik,enzain,2,Fri Jun 12 12:16:25 2015 UTC,Doesn't Atom have similar performance issues as Eclipse though?
haskell,39kpik,thehoodatron,3,Fri Jun 12 12:44:44 2015 UTC,"It certainly used to, but it's improved quite a lot over the last few months.  I find it to be pleasantly snappy now."
haskell,39kpik,enzain,1 point,Fri Jun 12 14:00:34 2015 UTC,"Good to know, I might try it again then!"
haskell,39kpik,thehoodatron,2,Fri Jun 12 14:04:12 2015 UTC,"I installed Atom and the appropriate plugins. But now I found out that cabal doesn't work on Windows 7. At the prompt I entered  cabal init   and after a few questions it said ""cabal: git: does not exist"". It appears that this is a known bug, supposedly solved, but never really solved.  My impression is that Haskell is very averse to Windows."
haskell,39kpik,enzain,1 point,Fri Jun 12 12:38:59 2015 UTC,Does ide-haskell support GHCJS? My goal is to develop SPAs with Haskell (scotty + reflex-dom?).
haskell,39kpik,CraigTreptow,3,Fri Jun 12 15:29:58 2015 UTC,"My intuition is that, as a Haskell newbie, you're probably going to run into a lot of trouble if you start with ghcjs. I don't have any concrete arguments, just a gut feeling that you're going to be doing quite a lot of trailblazing."
haskell,39kpik,Tekmo,2,Fri Jun 12 15:32:19 2015 UTC,"I won't start with GHCJS, but that's definitely my goal (and then I'll add Liquid Types [LiquidHaskell]!)."
haskell,39kpik,sideEffffECt,1 point,Fri Jun 12 16:24:18 2015 UTC,Carry on :) I hope you'll find a lot to your liking around these parts.
haskell,39kpik,hargettp,6,Fri Jun 12 18:07:28 2015 UTC,"I use haskell on windows and on linux, and my impression has been positive on both(after I've learned about all the setup traps).  Here is my suggestion, get:   GHC 7.8 cabal 1.20 (1.22 does not work with ghc-mod and you will be screwed if you try) and Atom (amazing editor imo)   Download the following addons for atom:   autocomplete-haskell haskell-ghc-mod  ide-haskell  language-haskell  merge-conflicts (for git merging)   in cabal install:   ghc-mod version  stylish-haskell   Sit back and enjoy :)"
haskell,39kpik,InnerChutzpah,2,Fri Jun 12 15:43:51 2015 UTC,"I installed GHC this way: minghc.  Now let's see if it works with Atom... By the way now ""cabal init"" works correctly!"
haskell,39kpik,bitflip,1 point,Fri Jun 12 17:07:59 2015 UTC,great!
haskell,39kpik,pi3r,1 point,Fri Jun 12 18:02:11 2015 UTC,"I'm about to give up :(  Neither cabal 1.20 nor 1.22 work on Windows. With the former ""cabal init"" doesn't work and with the latter ghci-mod doesn't work! Now I'm about to try IntelliJ hoping that it doesn't rely on ""cabal init"" to create new projects.  As a last resort I'll have to install Ubuntu in a VM or go back to Scala and forget about Haskell.  edit: I was wrong. The Haskell Platform comes with cabal 1.18! How can I upgrade to version 1.20?  edit2: Nevermind, I found the right command here: http://blog.johantibell.com/2014/04/announcing-cabal-120.html"
haskell,39kpik,razvanpanda,1 point,Fri Jun 12 18:26:27 2015 UTC,"Yes, I had the exact same experience, joining the haskell comunity has a very high entry barrier. However once you get it to work, you'll start to realize why things are done this way.  I spent 20 hours before I got anything to work on windows, which is completely unacceptable, my mistake was I had cabal 1.22.  I honestly think the real challenge to haskell is to make it more beginner friendly."
haskell,39kpik,tdees40,1 point,Sat Jun 13 01:27:19 2015 UTC,I think I did it! Maybe I should write a post about it for total beginners.
haskell,39kpik,vitalijzad,1 point,Sat Jun 13 10:41:30 2015 UTC,"Using Atom, every time I click Ctrl+s to save a .hs file, I get the error:     Haskell-ghc-mod: ghc-mod failed with error code 1 come up in the GUI. I've installed all of the packages you mentioned (including the correct versions)."
haskell,39kpik,tdees40,1 point,Sat Jun 13 12:14:15 2015 UTC,did you configure your cabal?
haskell,39kpik,mallai,1 point,Sun Jun 14 09:47:15 2015 UTC,I have not. What do i need to configure exactly? I'm doing this on Ubuntu 14.04 btw
haskell,39kpik,Crandom,2,Sun Jun 14 10:15:40 2015 UTC,If you have setup a cabal project like so How to write haskell program. Then you can simply type:   cabal configure    in your console when inside your project folder.
haskell,39kpik,eegreg,6,Sun Jun 14 10:40:45 2015 UTC,"This may help you: https://wiki.haskell.org/IDEs  as well as this, the Sublime Text 2 Haskell plugin: https://github.com/SublimeHaskell/SublimeHaskell"
haskell,39kpik,andrewthad,5,Sat Jun 13 23:37:52 2015 UTC,You can try this IntelliJ IDEA Haskell plugin
haskell,39kpik,gracjan,2,Sun Jun 14 04:39:38 2015 UTC,"OK, I'll try that. It's a pity that there's no debugger though. Leksah seems to be more complete."
haskell,39kpik,dzack,2,Sun Jun 14 08:09:53 2015 UTC,There are also   https://github.com/Atsky/haskell-idea-plugin https://github.com/rikvdkleij/intellij-haskell
haskell,39kpik,__buckie__,12,Sun Jun 14 08:55:50 2015 UTC,"I find FP Complete's offering quite good, and free for projects whose source code can be public: https://www.fpcomplete.com/business/fp-haskell-center/. It saves the fresh Haskell programmer from having to setup a toolchain, and focus on writing new code.  At some point, learning the toolchain and setup is well worth doing, but nothing wrong with getting to focus on the language itself in the beginning."
haskell,39kpik,Ghostlike4331,5,Fri Jun 12 12:55:37 2015 UTC,I'm old school in this respect: I like to do as much as possible offline and have all my files on my hard disk.
haskell,39kpik,__buckie__,4,Sat Jun 13 04:49:26 2015 UTC,"Putting my vote here. You want to learn 1 new thing, not 10. FP complete eliminates 2-10, so you can focus on 1."
haskell,39kpik,ndmitchell,3,Sat Jun 13 10:44:28 2015 UTC,"Seconded. They saved me a lot of time wrangling around with non-core tasks.  Once I set up my own environment, I didn't really have any particular need for a fancy IDE. The code is pretty terse. To be fair, I didn't do any large projects."
haskell,39kpik,absence3,4,Sat Jun 13 12:44:32 2015 UTC,IntelliJ with haskforce looked promising. Unfortunately I am not sure it is as active as it used to be: https://github.com/carymrobbins/intellij-haskforce/graphs/contributors  Atoms.io looks quite nice. The last time I have checked (a couple of months ago) it was too slow but according to posters it has improved a lot in that area.  Emacs (spacemacs) is cute and nice but fragile due to ghc-mod and a perfectible haskell-process mode. The fact that a tool such as ghc-mod doesn't work with ghc-7.10 yet (the hackage version) is a bit worrisome.
haskell,39kpik,PM_ME_UR_OBSIDIAN,3,Fri Jun 12 14:07:21 2015 UTC,"Work on Haskforce is still going on in this branch: https://github.com/carymrobbins/intellij-haskforce/commits/scala-cabal-issue144 IDEA + Haskforce is currently my favorite desktop IDE as it just works after a very simple setup, including working autocomplete with ghc-mod and find usages."
haskell,39kpik,rdfox,3,Sat Jun 13 11:06:46 2015 UTC,Sublime is pretty terrific for Windows.
haskell,39kpik,PM_ME_UR_OBSIDIAN,1 point,Fri Jun 12 20:13:36 2015 UTC,Does it have an Haskell plugin? Is it easy to install?
haskell,39kpik,_AndrewC_,2,Fri Jun 12 14:41:46 2015 UTC,"Yes, it's called Sublime Haskell, and it's very easy to install.  If you don't want to go through the mental overheard of learning Vim or Emacs, Sublime is definitely the way to go on Windows (although I've heard good things about Atom!)."
haskell,39kpik,absence3,3,Fri Jun 12 16:10:55 2015 UTC,"I am a dedicated user of Sublime Haskell but unfortunately, it cannot be said that it's easy to setup. It does not work with most recent cabal and ghc-mod. I recently installed Sublime Haskell from this fork https://github.com/gbrsales/SublimeHaskell. To use it go to Preferences->Package Control->Add Repository and give that URL. Then Preferences->Package Control->Install Package and type Sublime Haskell. Also, as  a beginner, go with GHC 7.8.4 as ghc-mod does not yet work well with 7.10.  I tried Atom and it's very nice."
haskell,39kpik,PM_ME_UR_OBSIDIAN,2,Fri Jun 12 19:44:49 2015 UTC,I would argue SublimeHaskell is basically impossible to install.
haskell,39kpik,orclev,3,Fri Jun 12 12:48:58 2015 UTC,haskell-vim-now is a good vim setup that works easily out of the box. You would need to learn vi key bindings though to get the advantages of VIM.  I have been trying to make the switch to spacemacs (which also supports vi key bindings) but I keep running into basic install issues.
haskell,39kpik,muzzlecar,3,Fri Jun 12 12:50:44 2015 UTC,"I recommend vim. It's what I use and it works well for almost everything. The initial learning curve is kind of bad (a lot like haskell), but just like haskell, it's worth learning."
haskell,39kpik,hamishmack,3,Fri Jun 12 12:57:32 2015 UTC,"I'll give you a link to Emacs haskell-mode:  https://github.com/haskell/haskell-mode  Note though that Emacs is a very special beast, you will like it or hate it. Be warned."
haskell,39kpik,muzzlecar,2,Fri Jun 12 14:45:55 2015 UTC,"If you're thinking about going the vim route, I did a small writeup on some of the most useful plugins and settings: http://dzackgarza.com/tutorials/2015/05/30/setting-up-a-haskell-dev-environment/"
haskell,39kpik,hamishmack,1 point,Fri Jun 12 20:12:00 2015 UTC,"If I go that route, I think I'll use spacemacs (many recommend it)."
haskell,39izi6,begriffs,20,Fri Jun 12 01:28:13 2015 UTC,Sometimes just writing the same thing twice is the easiest solution:  bid <- liftIO randomIO now <- liftIO getCurrentTime
haskell,39izi6,dan00,5,Fri Jun 12 08:27:04 2015 UTC,"Depending on which liftIO is being used, there could be a non-negligible performance difference, no?"
haskell,39izi6,sccrstud92,6,Fri Jun 12 20:07:55 2015 UTC,+1 (with apologies for the side effect -:)
haskell,39izi6,dhjdhj,6,Fri Jun 12 11:12:24 2015 UTC,"So much this. It's shorter, neater, and the pattern (liftIO) is made apparent."
haskell,39izi6,theonlycosmonaut,6,Fri Jun 12 12:26:06 2015 UTC,"This is the style I like; I think of it imperatively (gasp!) like declaring my variables, and it's easier for me to refactor my bindings later when I can avoid getting applicative operators involved. But what's more interesting to me someone getting giddy about having these kinds of conversations at work."
haskell,39izi6,supersemicolon,1 point,Fri Jun 12 08:43:29 2015 UTC,"Like /u/roconnor, I disagree. The applicative idiom does need to be learned. But it is trivially easy: <$> .. <*> ... means ""apply this function to these arguments, but inside the Applicative"".  Once you get that, the idiom is so ubiquitous, and so conducive to writing better code, that you won't even blink. It will be hard to remember why it was that you ever thought it was ""less clear"" or ""not as easy""."
haskell,39izi6,yitz,2,Sun Jun 14 11:50:38 2015 UTC,"I don't argue against the use of applicative style, but against the concrete use case. I don't consider the creation of a tuple to just pattern match against it to be clear or even good style.  I've no problem reading both proposed solutions, but still both don't strive for simplicity and they somehow seem to use abstractions for the sake of them."
haskell,39izi6,dan00,1 point,Sun Jun 14 15:06:56 2015 UTC,"But the return type of the expression is a tuple. Not seeing that code snippet in context, I'm taking it at face value that a tuple is what is needed.  And in that case, using a tuple constructor in applicative style is no less simple than using a sugared tuple constructor in a separate return clause in monadic style. And the use of the applicative idiom - to my taste - makes the style of the overall expression clearly better than writing out a monadic do block.  If the tuple could have been avoided, then that is indeed a cost, so maybe the do block version without the tuple would be better. Not always though. I would have to see the context."
haskell,39izi6,yitz,2,Sun Jun 14 16:35:00 2015 UTC,"But the return type of the expression is a tuple. Not seeing that code snippet in context, I'm taking it at face value that a tuple is what is needed.   Well, then we're arguing about different things. I'm seeing two IO actions bound to bid and now."
haskell,39izi6,dan00,2,Sun Jun 14 17:48:22 2015 UTC,"I'm taking it at face value that a tuple is what is needed.   I think the fact that the tuple has no name, but its elements have names, suggests that the tuple is simply a convenience introduced so that liftIO only appears once."
haskell,39izi6,theonlycosmonaut,17,Mon Jun 15 04:26:30 2015 UTC,"I was going to say something similar. I'm not sure why the suggestion to use applicative is considered ""elegant"". It's certainly correct and it's certainly terse but it seems harder to read/understand because, for one thing, having the tuple separator operator used as a prefix operator. This also seems oddly ironic.  The original is readable and clear. That seems elegant almost by definition!"
haskell,39izi6,dhjdhj,6,Fri Jun 12 11:10:25 2015 UTC,There is a proposal to add Applicative Do-notation to GHC which would combine the best of both worlds.
haskell,39izi6,mn-haskell-guy,0,Fri Jun 12 15:03:16 2015 UTC,"I agree. I never really agreed with ""refactoring"" which doesn't really change anything. In that case, both version are right. It seems a waist of time, to rewrite one for the other."
haskell,39izi6,maxigit,3,Fri Jun 12 20:34:12 2015 UTC,"I definitely prefer the applicative form because it removes the bound variables.  If a value is unnamed, you cannot accidentally incorrectly refer to it.  The applicative pairing operation is so common that I wish it were in defined in Control Applicative.  I often define these myself  a <×> b = (,) <$> a <*> b a <+> b = Left <$> a <|> Right <$> b   Although the  <×> operator looks like two Tholian vessels that are about to start building a web."
haskell,39k8sw,KomankK,17,Fri Jun 12 08:49:27 2015 UTC,"The first thing to do is write a where clause  where plausibleJump' = plausibleJump s a b       nonEmptyPlausibleJump x y = (plausibleJump' x y) /= []   and remove all the duplication of those function calls.  To be more advanced, define the list  newPositions = [ (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1) ]   and express your function as a use of find.  If you're really clever you can find a way to generate newPositions rather than write it out by hand!"
haskell,39k8sw,tomejaguar,6,Fri Jun 12 09:07:01 2015 UTC,I like this transformation the most because it's clear where everything in the original code went. The other answers seem a little code-golfy (sorry).
haskell,39k8sw,beerdude26,4,Fri Jun 12 11:21:22 2015 UTC,"You have a ton of redundancy in your code. Try to eliminate repeating words by capturing the varying parts into a data structure (container, e.g. a list) and use operations on that data structure (e.g. map, filter, fold)."
haskell,39k8sw,heisenbug,3,Fri Jun 12 10:20:24 2015 UTC,"Using laziness you can just build a list of every possibilities and take the first ""interesting"" one.   import Data.Maybe  kightJump s a b = head (filter (/=[]))           [ plausibleJump s a b (-1) 2           , plausibleJump s a b 1     1           , plausibleJump s a b 2    1           ... etc ...           ]) ++ [[]]]   Of course, in your particular, the full list can dryied-up and be written in more conscise way."
haskell,39k8sw,maxigit,2,Fri Jun 12 12:19:47 2015 UTC,"Learn You a Haskell discusses a similar problem:  link1 link2  (You'll have to search for ""knight"" yourself.)"
haskell,39k8sw,toujw,3,Fri Jun 12 18:53:00 2015 UTC,"I'll attempt to implement what tomejaguar suggested:  Edit: I added some comments explaining what I'm doing  Edit 2: added 'not', thx @mstksg   knightJump s a b =     -- since the function find returns a Maybe we need to   -- look at whether we got the right result   maybe      [] -- this is the default. We return [] if there were no plausible jumps     pJumpUncurried -- this is the function we apply to the position tuple if we got one     result    where     -- first I make a partial from the plausibleJump function that takes      -- a tuple with the position as the last argument instead of two separate arguments     pJumpUncurried = uncurry (plausibleJump s a b)      -- all possble combinations with 1 or -1 in the first tuple position      -- and 2 or -2 in the second     rightPos = [(x,y) | x <- [1,-1], y <- [2,-2]]     -- and now the reverse of those with 2 or -2 in the first and 1 or -1 in the second     leftPos = map swap rightPos      -- both together     positions = rightPos ++ leftPos      -- find the first one for which applying the plausibleJump function      -- does not return an empty list     -- this returns a Maybe a      -- the function 'null' is better than /= [] and does the same thing     result = find (not . null . pJumpUncurried) positions"
haskell,39k8sw,CynicalHarry,6,Fri Jun 12 09:25:01 2015 UTC,"I would probably have result be  result = find (not . null . pJumpUncurried) positions   using null is probably nicer than (== []) because it doesn't have an Eq constraint... not that that's a huge deal here, but it's just a good habit :)  or just probably even better, to get rid of boolean blindness,   result = listToMaybe . dropWhile null . map pJumpUncurried $ positions   which saves the recalculation of pJumpUncurried later in the final answer. And avoiding boolean blindness when you can is nice anyways :)"
haskell,39k8sw,mstksg,1 point,Fri Jun 12 09:50:15 2015 UTC,"what do you think about this  knightJump s a b =   maybe [] fst result   where     positions = uncurry (++) $ (id *** map swap) [(x,y) | x <- [1,-1], y <- [2,-2]]     result = uncons . dropWhile null . map pJumpUncurried $ positions"
haskell,39k8sw,CynicalHarry,1 point,Fri Jun 12 11:27:54 2015 UTC,Cool.  I would probably map pJumpUncurried before the find which avoids needing to apply it again in the maybe.  Then you can just use fromMaybe (or a case might be clearer).  I would also use not . null instead of (/= []).  I'd also probably put type sigs on the definitions in the where clause.
haskell,39k8sw,tomejaguar,1 point,Fri Jun 12 09:51:00 2015 UTC,"I'm not familiar with the problem, but would this work?  knightJump s a b = take 1 $ uncurry (plausibleJump s a b) =<< positions where     positions = -- as above   It maps the plausible jump function to all the positions, concatenates the result and picks the first one (or empty if nothing was found)."
haskell,39k8sw,absence3,1 point,Fri Jun 12 10:07:14 2015 UTC,"I'm not quite sure what your s, a, and b are, but I hope this is useful:  knightMoves :: [(Int,Int)] knightMoves = [m | a <- [1,-1], b <- [2,-2], m <- [(a,b),(b,a)]]  onBoard :: Int -> (Int,Int) -> Bool onBoard s (a,b) = 0 <= a && a < s && 0 <= b && b < s  plausibleMoves :: Int -> (Int,Int) -> [(Int,Int)] plausibleMoves s (a,b) = [ (a+x,b+y) | (x,y) <- knightMoves, onBoard s (a+x,b+y) ]"
haskell,39hvcl,paf31,20,Thu Jun 11 20:41:03 2015 UTC,"Aside:   Profiling of course slows things down a bit. Compilation of the UI went up to over 3.5 minutes when a core module was touched.   This is a bad property of our current profiling infrastructure in Haskell. It relies on source rewriting, which means that the code that's profiled is not the same as the code being executed in production. That it turns means that you can't know for sure whether the profile is lying to you. For example, if you apply profiling to any core library (text, attoparsec) GHC fails to perform e.g. stream fusion and you end up measuring something completely different than you thought.  We need to move to profiling based on debug information like DWARF, so that compilation is not hampered by the profiling code, meaning that we can trust the results much more. As a bonus the code being profiled will not run noticeably slower. Also, this is what other languages do (for the above reasons.)"
haskell,39hvcl,tibbe,4,Fri Jun 12 07:09:19 2015 UTC,I thought we were moving some stuff to DWARF? Are you saying that we aren't moving enough to it?
haskell,39hvcl,ocharles,8,Fri Jun 12 07:34:40 2015 UTC,"GHC can now emit DWARF, which is a step in the right direction. This means in principle you could now productively use perf or a similar tool on Haskell code. That being said, it will still be a painful experience (""hmm, 20% of my cycles are spent in c24_info...""). A little bit of tooling could go a long ways in improving this situation."
haskell,39hvcl,bgamari,1 point,Fri Jun 12 13:39:16 2015 UTC,Exactly.
haskell,39hvcl,tibbe,5,Fri Jun 12 15:11:50 2015 UTC,"I couldn't agree more.  Profiling is useful for find really bad spots (as described in this blog post), but once you've done that the information you get is so unreliable that it makes it very hard to make progress."
haskell,39grgd,stunt_penis,37,Thu Jun 11 16:44:31 2015 UTC,"The traditional way is to use newtype to call out the fact that the three items aren't really strings, they just happen to be represented that way.  newtype FirstName = FirstName String newtype LastName = LastName String newtype AboutMe = AboutMe String  createUser :: FirstName -> LastName -> AboutMe   Now you can't screw up and swap order.  To make one you use the constructor defined FirstName ""stunt_penis"".    Now you only have to be careful when you create the data, instead of at each point where you use the data."
haskell,39grgd,TheJonManley,12,Thu Jun 11 16:55:59 2015 UTC,"In Haskell use of newtypes in encouraged and newtypes are guaranteed to have zero runtime impact and to involve no runtime instructions whatsoever (zero cost coercion). In other words, performance wise createUser :: FirstName -> LastName -> AboutMe is identical to  createUser :: String -> String -> String"
haskell,39grgd,nifr,11,Thu Jun 11 17:02:34 2015 UTC,"Beware that the zero cost coercion sometimes requires some refactoring/obfuscation. https://wiki.haskell.org/GHC/Coercible  For example, you might need to use 'coerce' where you would might normally use 'fmap'."
haskell,39grgd,_AndrewC_,12,Thu Jun 11 17:44:59 2015 UTC,Sometimes I wish they called that unwrap instead of coerce.  Coerce sounds so much less typesafe than it really is.
haskell,39grgd,conklech,3,Thu Jun 11 19:08:02 2015 UTC,"To explain /u/nifr's comment for anyone not familiar with the problem: for newtype NT = { unNT :: String }, it is guaranteed that NT :: String -> NT and unNT :: NT -> String have zero runtime cost, but fmap NT and fmap unNT do not enjoy that guarantee; in general the container must be traversed. The new-ish Coercible system address that problem."
haskell,39grgd,serras,2,Thu Jun 11 19:25:13 2015 UTC,"The problem with this is that you lose the ability to write  createUser ""John"" ""Doe"" ""Hello!""   which you can easily remedy adding  deriving (IsString)   to each of the declarations."
haskell,39grgd,jeremyjh,3,Fri Jun 12 18:51:26 2015 UTC,"Which would let you make the exact same mistake you can make with only String. If you just want to document the logical type, the ""type"" keyword is called for."
haskell,39grgd,stunt_penis,2,Fri Jun 12 14:24:15 2015 UTC,"You are right, but I don't ever find myself writing that code in any real application.  Constant strings just don't show up much. Typically I'm reading in some data from somewhere (network, database, stdin), parsing & verifying, then operating on it.  The newtype approach allows that parsing & verification step to propagate its result through the rest of the app. ""Yes, this really is a valid first name"".  Of course that also then plays nice with the smart constructor style, where you would have a mkFirstName :: String -> Maybe FirstName function, hiding the FirstName constructor to other modules.  All depends on the kinds of guarantees you want in the code.  This is certainly boilerplate, but it does get you something.  Tradeoffs!"
haskell,39grgd,liberalogica,1 point,Fri Jun 12 14:33:59 2015 UTC,"Would not it be enough to use type synonims? This way there would be no need to use constructors, right?  type FirstName = String"
haskell,39grgd,stunt_penis,2,Fri Jun 12 15:30:25 2015 UTC,"If you did that it wouldn't solve the original problem of swapping arguments accidentally.  Type synonyms don't introduce unique types into the type checker, it is just an alias.  so if you have  type FirstName = String type LastName = String  fullName :: FirstName -> LastName -> String   It wouldn't care at all if you called it either way:  fullName ""Stunt"" ""Penis"" -- or fullName ""Penis"" ""Stunt""   If you have newtypes, it does prevent that kind of error.  I find type aliases useful mostly to compact down a long type.  a totally made up example:   type UserTracker = Map (UserId, Day) (UserCounter Int)   So your type signature takes a UserTracker instead of a Map. Even though to the type system they're the exact same thing, it can make the functions read nicer to the next programmer.  (don't go overboard, it's another layer of indirection. A few well chosen ones help, a ton of them just obfuscate)."
haskell,39grgd,liberalogica,1 point,Sat Jun 13 14:11:18 2015 UTC,"Thanks for the explanation. If you convert your String to a FirstName type synonym when it gets into the system, though, the type checker will not allow it to be used in place of a LastName, right?"
haskell,39grgd,stunt_penis,2,Sat Jun 13 16:56:37 2015 UTC,"type FirstName = String   This doesn't do anything at the type level, other than giving you a nice name.    newtype FirstName = FirstName String   This is a whole different type as far as the type system is concerned. It can be pattern matched back into the inner String very easily, but is a totally distinct type.  Newtypes can only wrap a single inner type.    data Name = Name String String   Data allows for many fields.  It creates a new type to the typechecker, like newtype."
haskell,39grgd,stunt_penis,1 point,Sat Jun 13 19:39:43 2015 UTC,"And yes, you'd have a function at the border of your system to check the raw input (a String) and turn it into semantically valid data (a FirstName).  Then you would limit yourself to only using it in the correct ways, with the functions that expected it."
haskell,39grgd,PM_ME_UR_OBSIDIAN,-1,Sat Jun 13 22:55:13 2015 UTC,"""stunt_penis"""
haskell,39grgd,ocharles,18,Sat Jun 13 22:56:19 2015 UTC,"The problem is you have no distinction in your types. You have a few options. One would be to combine fields into a record and then pass that record as arguments. This is basically like working with named parameters:  {-# LANGUAGE RecordWildCards #-} data Args = Args { firstName, lastName, aboutMe :: String } createUser :: Args -> User createUser Args{..} = ...   I use -XRecordWildCards so you don't have to unpack all the arguments. Check the documentation (or my blog if that's new to you).  The other option is you newtype each argument type:  newtype FirstName = FirstName String newtype LastName = LastName String createUser :: FirstName -> LastName -> User createUser (FirstName firstName) (LastName lastName) = ...   This is pretty tedious with all the unpacking, but is very explicit about what is what (and that the set of first names is different to the set of last names)."
haskell,39grgd,chrisdoner,6,Fri Jun 12 18:40:22 2015 UTC,"The problem is you have no distinction in your types. You have a few options. One would be to combine fields into a record and then pass that record as arguments. This is basically like working with named parameters:   Provided one remembers to use Args {…} or  Args{firstName=…} for calling createUser, of course.   createUser :: FirstName -> LastName -> User createUser (FirstName firstName) (LastName lastName) = ...   This is pretty tedious with all the unpacking, but is very explicit about what is what (and that the set of first names is different to the set of last names).   Indeed, although preferably you won't unpack here, where you can yourself go and accidentally mix them up, and rather wherever your values end up going, to a database or to some printer, should anticipate that data type and know how to unpack it. E.g. in the case of persistent, you can do insert (Person (firstname :: FirstName) (lastname :: LastName)) and implement the PersistField class."
haskell,39grgd,chrisdoner,6,Thu Jun 11 16:58:03 2015 UTC,"Hi. :-) In persistent you can do  newtype FirstName = FirstName String deriving (PersistField) instance PersistFieldSql FirstName where     sqlType = sqlType . liftM unFirstName   If you have like 5 of these, it's not a big deal. If you have dozens, then some TH to automate it may be in order. It's quite sane but it requires familiarity with the TH APIs."
haskell,39grgd,chrisdoner,2,Thu Jun 11 17:02:51 2015 UTC,How does Clojure solve it cleanly?
haskell,39grgd,timmy_tofu,5,Thu Jun 11 17:08:04 2015 UTC,"Doesn't the first suggestion just push the problem down a level?  createUser $ Args ""Engage!"" ""Jean-Luc"" ""Picard"""
haskell,39grgd,ignorantone,9,Thu Jun 11 17:15:40 2015 UTC,"Only if you choose to use the short and risky way:  initCFG = Configuration ""nobody"" ""nowhere"" ""nowhere"" False False ""/"" ""/"" 0   The verbose but safe way:  initCFG' = Configuration     { username      = ""nobody""     , localHost     = ""nowhere""     , remoteHost    = ""nowhere""     , isguest       = False     , issuperuser   = False     , currentdir    = ""/""     , homedir       = ""/""     , timeConnected = 0     }   source: http://en.wikibooks.org/wiki/Haskell/More_on_datatypes"
haskell,39grgd,chrisdoner,4,Thu Jun 11 17:22:25 2015 UTC,Newtype wrappers:   newtype FirstName = FirstName String newtype LastName = LastName String createUser :: FirstName -> LastName -> …
haskell,39grgd,evohunz,3,Thu Jun 11 20:23:58 2015 UTC,"Why not?  -- hide data constructor data CreateUserRequest = CreateUserRequestCtor {   curFirstName :: String,   curLastName :: String,   curAboutMe :: String }  -- expose this mkCreateUserRequest :: CreateUserRequest mkCreateUserRequest = CreateUserRequestCtor """" """" """"  -- your function, client needs to use mkCreateUserRequest with field names createUser :: CreateUserRequest -> Something createUser request = fail   where firstName = curFirstName request          lastName = curLastName request          aboutMe = curAboutMe request"
haskell,39grgd,MaxGabriel,3,Thu Jun 11 17:25:26 2015 UTC,"Side note, but I think your function signature is missing a return value. Your function takes 3 arguments (firstName, lastName and aboutMe), so you should have an extra -> ReturnTypeHere added to the function."
haskell,39grgd,dchagniot,1 point,Thu Jun 11 17:52:56 2015 UTC,Why not using Phantom Types ? e.g. Using Phantom Types for Extra Safety.
haskell,39grgd,dskippy,1 point,Thu Jun 11 16:57:45 2015 UTC,"I highly recommend newtype wrappers for this, as many other people have mentioned. I am writing a large Haskell application at a development shop where Haskell is new to many people. The code is dealing with a lot of IDs of different types of concepts floating around the code that come from our database. Passing arguments in the opposite order is something that is trivial to prevent using Haskell's type system and that's one of the main reasons I used Haskell for this application. Safety. The extra constructor is well worth it, believe me. You hardly actually even write it because literals are uncommon in a real program."
haskell,39grgd,howardbgolden,-7,Thu Jun 11 19:22:35 2015 UTC,Only program when sober? Only write commutative functions?
haskell,39hgki,sivteck,3,Thu Jun 11 19:10:23 2015 UTC,"One thing I noticed when it was linked in IRC earlier today is that the instructor presents a function that is not a sieve as the sieve of eratosthenes.  Haskell.org got nitpicked to death for having the word ""sieve"" even in the code, which is why it was changed to filterPrime."
haskell,39hgki,Mob_Of_One,1 point,Fri Jun 12 00:34:39 2015 UTC,"Huh. How is it different from the sieve? I'm new to Haskell.  I do notice that in his description of the algorithm, he says that one starts with ""an infinite list"". :-)"
haskell,39hgki,dogweather,2,Wed Jul 15 17:17:46 2015 UTC,"Has anyone here had experience with this course, professor, or website before? I'm hesitant to sign up for a random MOOC I don't recognize."
haskell,39hgki,FlameFist,3,Thu Jun 11 20:46:34 2015 UTC,A close friend of mine attended the University. It's a very highly regarded university in India.
haskell,39hgki,vamega,2,Thu Jun 11 21:27:33 2015 UTC,"Alright, I think I'll look more into it. Seems interesting enough, and I've always wanted to get into Haskell."
haskell,39hgki,FlameFist,2,Thu Jun 11 21:58:43 2015 UTC,Why not take Erik Meijer course on functional programming in Haskell from edX?
haskell,39hgki,thecity2,1 point,Sun Jun 14 01:00:23 2015 UTC,Because I didn't know about it. ;-) Thanks for the pointer!
haskell,39hgki,dogweather,1 point,Wed Jul 15 17:01:22 2015 UTC,Thanks!
haskell,39hgki,nick_storm,1 point,Thu Jun 11 20:41:02 2015 UTC,"This is the content of the welcome mail if you choose to sign up:  ""Dear student  Welcome to NPTEL Online Courses and Certification!  Thank you for signing up for our online course ""Functional Programming in Haskell"". We wish you an enjoyable and informative learning experience.  The course will begin on July 15 2015. When content is released on the portal, you will get an email alerting you. Please watch the lectures, follow the course regularly and submit all assessments and assignments before the due date. Your regular participation is vital for learning.  We will open registration for the exam soon. A form has to be filled and the certification exam has a fee, which needs to be paid at the time of registration. Everyone who has signed-up for the course, including those who do not register for the exam, will continue to have access to the course contents.  There are two sections on the portal apart from the course content and assignment sections:   The announcement list which will only have messages from course instructors and teaching assistants - regarding the lessons, assignments, exam registration, hall tickets etc. The discussion forum which is for everyone to ask questions and interact - If you have any questions regarding the technical content in the lectures, any doubts in the assignments or any question related to the exam, registration, hall tickets, results, etc, kindly write about this in the forum and the course instructor/TA will respond to it. Please use this well and participate to benefit from the course.  Details regarding the course:  Name of the course:Functional Programming in Haskell (July-Oct - 20 hrs) Course duration : July 15 2015 - Oct 2015 Dates of exams : 1 November 2015 and 8 November 2015  Time of exam: 1pm - 4pm Tentative list of exam cities: https://onlinecourses.nptel.ac.in/noc15_cs13/assets/img/Exam%20City-list.pdf FInal List of exam cities will be available in exam registration form Exam registration url - Will be announced shortly   Once again, thanks for your interest in our online courses and certification. Happy learning. """
haskell,39fgzc,ftomassetti,4,Thu Jun 11 10:59:20 2015 UTC,"Oh man, what a disaster.  As awful as eclipse is, this was by far the best actual Haskell IDE (I'm not interested in developing with a text editor)."
haskell,39fgzc,nicheComicsProject,8,Thu Jun 11 19:49:00 2015 UTC,out of interest what do you miss from an IDE when using an editor? I only ask as I've never even considered using an IDE for haskell and maybe I should?  edit: sublime user
haskell,39fgzc,lifow,4,Thu Jun 11 20:38:23 2015 UTC,"An editor lets you edit a file.  If you get a really good one it can give you things like type popovers and compile-as-I-write and so on.  And IDE, in contrast, manages a system.  It does everything the editor does but it also does those things for the system as well.  When working with Haskell in EclipseFP I didn't just get to have the code I was working on as I wrote, it was building the whole system at all times.  If I make a change to some dependancy, all the files in my system that got broke by that change light up.  I also have integrated access to unit tests, performance testing and various other necessary parts of software development.  I get all the tools to manage the whole project lifecycle right in one place.  I don't have to break focus of leaving my editor and typing a bunch of commands, it's just a key sequence (or clicking on a menu until you learn the shortcuts).  And the other thing to remember is that Eclipse is a pretty awful IDE.  It was the best we had for Haskell, but if you ever use Visual Studio+Resharper to work on a large C# project it will be very clear how much time a powerful IDE can save."
haskell,39fgzc,nicheComicsProject,2,Fri Jun 12 04:55:45 2015 UTC,A lot of what you said is available in haskell-mode (emacs). It does compile your entire system (cabal support). It does show all errors in all the files with navigation. It allows you to jump to the source code of the function in a different module (code navigation).  The line between programming editor and IDE is blurry and is shifting all the time.
haskell,39fgzc,vagif,1 point,Fri Jun 12 16:05:38 2015 UTC,"I've used emacs to do Lisp dev for years and I have to be honest: people who say the line is blurring are either not using good IDE's or not leveraging them to their potential.  Emacs is, IMO, the most powerful of all the text editors, but in the end it is a text editor.  You could program everything an IDE has into emacs, but I want to work on my project, not building an IDE.  P.S. I looked at the documentation but I see no mention of cabal support.  On a Haskell wiki it was mentioned that should be possible (presumably meaning: after someone programs it) with ""FlyMake""."
haskell,39fgzc,nicheComicsProject,3,Fri Jun 12 18:36:13 2015 UTC,"You are assuming that we never used IDEs. But the fact is, most emacs (or other powerful programmers editor) users also currently use or used in the past IDE. I have decades of experience with VisualStudio, Eclipse, Intellij IDEA,  Delphi, PowerBuilder, Foxpro.  And i do not miss that experience at all.   but I want to work on my project,   Me too...but in haskell, not java or C#. Unfortunately EclipseFP never worked for me. It was always broken. And for many many other people too. Call me when you have actual working IDE for haskell."
haskell,39fgzc,vagif,1 point,Fri Jun 12 18:41:47 2015 UTC,"The latest EclipseFP that I used meant I needed the following things in path   A working GHC Happy Alex   If you have that, EclipseFP downloads everything you need, and if you have a modern version of GHC it will even sandbox everything for you.  I admit it took some fighting, and I really hate eclipse, but I don't see a better option.  As to your other statements, if that works for you and others then more power to you.  For me personally, I'm not interested in developing in a text editor and as cool as emacs may be it doesn't get anywhere close for me."
haskell,39fgzc,nicheComicsProject,2,Fri Jun 12 18:53:28 2015 UTC,"P.S. I looked at the documentation but I see no mention of cabal support. On a Haskell wiki it was mentioned that should be possible (presumably meaning: after someone programs it) with ""FlyMake"".   You are missing out. Which again brings us back to documenting and informing community. As you see you were mislead by outdated wiki.  Here's the actual up to date documentation on haskell-mode.  You will be amazed how much of IDE functionality available now out of the box without any fiddling.  It does have prerequisites though: ghc, cabal, hasktags, hlint, optionally ghci-ng (if you want some advanced functionality not yet in stock ghci)"
haskell,39fgzc,vagif,0,Fri Jun 12 20:40:21 2015 UTC,"To compile the whole Cabal project, run the following   M-x haskell-process-cabal-build    I'm sorry, but: fail.  An IDE is doing this for me constantly.  I'm sure you can write some code to make this happen, but why?  EclipseFP can do this right now without (too many) issue(s).  EDIT: This is probably more combative than I intend.  I certainly don't look down at you or anyone for using emacs.  It's just not for me.  I don't have time."
haskell,39fgzc,nicheComicsProject,2,Fri Jun 12 21:15:28 2015 UTC,"All commands are on shortcuts. Cabal build for example on C-c; C-c  Reloading the file: C-c; C-l  As for continuous compilation, sure you can set it up. But this is haskell, not java or C#. You do not really need compiling every second like in other languages :)  Anyway, if you are hellbent on persuading yourself that things are bad in emacs-land without even trying, why should i care about it more than you? :))"
haskell,39fgzc,vagif,1 point,Fri Jun 12 21:25:54 2015 UTC,"I made it clear from the start that you won't convert me.  I hope I haven't come off as trying to convert you.  I've used emacs.  For years.  My hands still hurt.  And I'm not going to rip keys off my keyboard, or install a piano peddle or any of that other stuff to be able to use it productively.  Again, it's a powerful text editor.  So powerful you could eventually program it to be about anything.  I'm past the age where such projects appeal to me.  I want batteries included and as little between me and productivity as possible.  I don't want to know about what packages I need and I don't want to know what incantations make emacs actually use them.  EDIT: The point of continuous compile is that fairly quickly you get to the point that your files have dependencies between them.  In EclipseFP, if I make a breaking change, the second I save the file I get an indicator on every file that no longer compiles.  I don't have to vulcan death grip my keyboard for that to happen, pressing save did it already."
haskell,39fgzc,nicheComicsProject,2,Fri Jun 12 21:31:33 2015 UTC,"I'm not really advocating for emacs here. Believe me, the moment there appears an IDE rivaling features of haskell-mode, i'm gone :))  Unfortunately till this day haskell-mode is indeed the most powerful and feature rich IDE for haskell.  But with the advent of javascript powered editors (atom, MS Code) who knows maybe we will soon see something worthy to try."
haskell,39fgzc,vagif,1 point,Fri Jun 12 21:43:02 2015 UTC,I believe I get everything you get from the IDE from SublimeHaskell.
haskell,39fgzc,BethAr,1 point,Wed Jun 17 22:57:06 2015 UTC,"The thing is that I don't want an Integrated Development Environment. I want one with interchangeable parts; one which I can build up (not from the ground up) and say ""oh, so that is how this works""; one which I can turn off or discard subcomponents if they get annoying, slow or buggy. And these parts should be somewhat generic components, not black box plugins that only work in one environment. They can be less generic if that is necessary to interface well with the environment.  A small-scale example is to be able to edit normal prose and then invoking a spellchecker that interactively goes through the document, like ispell or whatever it's called. I don't have to care about the spellchecker when I'm editing text, because that is distracting. I know that there isn't one running in the background, ready to complain. But I can also turn off a sort-of daemon one, if I want such background processes."
haskell,39fgzc,jeandem,2,Sat Jun 13 08:43:00 2015 UTC,"Jumping to definitions, and type hints, IMO. Of course, both of these are available in most editors if you go to the trouble of setting them up. The advantage of an IDE is that you don't have to."
haskell,39fgzc,theonlycosmonaut,3,Fri Jun 12 00:47:25 2015 UTC,"Well, if you try to get basic eclipse and just install a few plugins you'll quickly end up in dependency conflict hell. You have to set the plugins up in any case! There's no silver bullet. Editors like Atom or Sublime resemble IDEs such as Eclipse more and more."
haskell,39fgzc,mallai,2,Fri Jun 12 02:14:20 2015 UTC,"I should have mentioned, I've never actually used an IDE for Haskell - due partly to the fact that I do most of my editing with gvim, and most of my compiling in a VM or container, and I haven't yet got my head around setting up IDE-like features that are server-based. My IDE experience has been limited to lots of C++ with Visual Studio, and some Eclipse for Java at uni. Neither of which involved plugins, so I'll happily concede that point.  Oh, actually, I have used FP complete's online editor, which counts as an IDE, I guess, but very briefly."
haskell,39fgzc,theonlycosmonaut,4,Fri Jun 12 06:00:52 2015 UTC,I recently tried Atom and I was quite surprised. It all just worked. The support for Haskell is basic but it has huge potential.
haskell,39fgzc,mallai,2,Thu Jun 11 19:59:26 2015 UTC,This is just a text editor with a plug in to make it a bit nicer.  It's still for editing a file as opposed to fully managing a project.  But thanks for bringing it to my attention.  I might use it for things that don't need an IDE.
haskell,39fgzc,nicheComicsProject,1 point,Fri Jun 12 18:25:00 2015 UTC,so I guess we need people to step up and help :)
haskell,39fgzc,yitz,1 point,Fri Jun 12 09:43:41 2015 UTC,"This is a duplicate post. But still worth it, because I haven't heard yet that anyone has stepped up to take over maintainership."
haskell,39hnv3,sriramalka,3,Thu Jun 11 19:54:35 2015 UTC,"When cabal fails, it's usually because one of the external programs it used failed. You can use --verbose=1 and --verbose=3 to get more and more detailed information about those external programs, and then you can execute the failed commands yourself, and figure out why those failed.  That being said, let's look at the line where the error occurs:  (//), update, update_, unsafeUpd, unsafeUpdate, unsafeUpdate_,   I think the (//) is a pretty good hint: some step in the pipeline must be interpreting // as the beginning of a single-line C comment and ignoring the rest of the line. Since vector uses the CPP extension, it's probably cpp, the C preprocessor. Try installing cpphs and making sure the cpphs binary is in your PATH, cabal should be able to pick it up and use that instead of whatever buggy cpp it is currently using."
haskell,39hnv3,gelisam,2,Fri Jun 12 02:49:52 2015 UTC,"it could be that its a misconfigured haskell cpp options. I like to use GCC for my CPP rather than CLANG, because it avoids a lot of problems that otherwise happen"
haskell,39hnv3,cartazio,1 point,Fri Jun 12 15:20:16 2015 UTC,"Thank you much.   I got it to work by some combination of moving back to 7.8.3, some ghc-pkg recache, some force-installs. Different packages needed different treatments. Ugh.  I'll try it again with all the latest versions as you suggest."
haskell,39hnv3,etrepum,1 point,Fri Jun 12 03:20:51 2015 UTC,"You could try upgrading your Xcode to the latest, that might be the issue. FWIW I don't have these sorts of problems on OS X 10.10 with GHC 7.10.1."
haskell,39hnv3,gelisam,1 point,Fri Jun 12 07:06:09 2015 UTC,"Upgrading Xcode to the latest requires upgrading to Yosemite, and at this time, I can't risk the move. In a month, perhaps. Thanks for the suggestion though."
haskell,39hnv3,etrepum,1 point,Fri Jun 12 07:18:19 2015 UTC,"For what it's worth, I'm still on OS X 10.6!"
haskell,39ci9j,suntzusartofarse,24,Wed Jun 10 21:03:14 2015 UTC,"Haskell's constraints will set you free :)  At first programming in it was so difficult for me as I had about 8 years of C experience with a few years of C++. Now I find things that Haskell makes principled and easy everywhere. Real world example: I have a friend who maintains a C++ doom port who brought up how difficult it is to ensure a function is reentrant, which is a property needed by the linedef part of the renderer in Doom. It immediately came to me that Haskell already gives us this for free via functional purity(IO shows us the function probably isn't reentrant)! Doesn't exactly help said friend, but I thought it was neat!"
haskell,39ci9j,rezb1t,5,Wed Jun 10 22:34:48 2015 UTC,ZDoom?
haskell,39ci9j,Furyhunter,6,Thu Jun 11 03:53:26 2015 UTC,"Eternity Engine specifically, relating to the last few features of Linked portals that haven't been implemented yet. I think zdoom has a similar portal system, however"
haskell,39ci9j,rezb1t,0,Thu Jun 11 05:41:16 2015 UTC,http://bfy.tw/HUT
haskell,39ci9j,EAT_DA_POOPOO,5,Thu Jun 11 05:29:02 2015 UTC,"I was asking if they were referring to ZDoom, not what ZDoom was."
haskell,39ci9j,Furyhunter,5,Thu Jun 11 05:41:29 2015 UTC,Guess I'm the jackass then. Sorry!
haskell,39ci9j,EAT_DA_POOPOO,2,Thu Jun 11 05:48:59 2015 UTC,"Don't sweat it, it's fine!"
haskell,39ci9j,Furyhunter,45,Thu Jun 11 05:56:50 2015 UTC,"Other random observations:  Random observation #1: be afraid, PHP code-monkey morons like myself have found Haskell now.  Random observation #2: I can't describe how nice it is to just run a binary, send a HTTP request to it and get an answer immediately. No waiting ages for Drupal to bootstrap!  Random observation #3: I've probably heard all these things in Haskell podcasts, reading this subreddit and such. Gosh though nothing can prepare you for the reality of actually programming in Haskell!"
haskell,39ci9j,Tekmo,21,Wed Jun 10 21:04:12 2015 UTC,Note that you can defer type errors to runtime if you pass the -fdefer-type-errors flag to GHC.  This flag turns type errors into exceptions which will be deferred as lazily as possible.  This lets you prototype something quickly like you did with PHP.
haskell,39ci9j,Faucelme,22,Wed Jun 10 21:41:12 2015 UTC,"I also often leave a lot of ""undefined"" to be filled later."
haskell,39ci9j,creichert,13,Wed Jun 10 21:45:36 2015 UTC,See -fwarn-typed-holes (implied by -fdefer-type-errors)[0]. You can use an underscore instead of undefined to get a warning with the expected type.   [0] - http://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/typed-holes.html
haskell,39ci9j,merijnv,6,Thu Jun 11 05:23:27 2015 UTC,"Your comment is confusing. Typed holes are ALWAYS enabled and do not require a flag. You used to be able to use -fno-warn-typed-holes to disable them in 7.8, but that is no longer possible in 7.10.  -fdefer-type-errors is unneeded to use typed holes. Since 7.10 there is also a -fdefer-typed-holes option that defers only holes until runtime, keeping all other type errors as errors. -fno-warn-typed-holes now disables the warning that happens when using -fdefer-typed-holes"
haskell,39ci9j,simonmic,1 point,Thu Jun 11 12:13:12 2015 UTC,"Well, now it's totally clear."
haskell,39ci9j,Vektorweg,7,Fri Jun 12 23:02:35 2015 UTC,Me too. But I write the function types and names and get it all type-checked before I actually implement anything.   I prefer to code only what I need.
haskell,39ci9j,hiptobecubic,2,Wed Jun 10 22:02:41 2015 UTC,"That still happens with undefined, no?"
haskell,39ci9j,Guvante,4,Thu Jun 11 03:08:02 2015 UTC,I believe they are talking about adding types for things that are undefined so that they are strongly typed to the correct type. undefined will check to any type (although only one).
haskell,39ci9j,hiptobecubic,2,Thu Jun 11 07:44:41 2015 UTC,Oh. Yes OK. I just kind of assumed that was happening. :)
haskell,39ci9j,TumbleSteed,8,Thu Jun 11 14:30:00 2015 UTC,"Are there any good posts about what this type of workflow is like? I've wanted the ability to say ""shut up everything else, I'm working on this part"", but I still want the type errors for the parts I'm working on.  I try to get around this by running ghci on just the module I'm working with, but if it's part of a Cabal project (which it usually is), I can't do this because it's dependent on other modules from the project.  I'd ideally like to be able to run ""cabal repl Path/To/Module.hs"", but as of cabal-install-1.18.x (which I'm using so that I can work with LTS Haskell), file targets aren't supported.  Could anyone chime in on how they like to handle these types of situations?  Also, as a bonus, is there any way of telling Cabal to use whatever packages you have installed on your system? When I'm working on a Cabal project, I often want to include/remove libraries while I'm iterating on an idea, but the process of: Add/remove dependency -> cabal configure -> Code; slows me down a lot.  Sorry for the overloaded question."
haskell,39ci9j,talideon,4,Thu Jun 11 00:00:56 2015 UTC,You might be interested in this: https://www.youtube.com/watch?v=52VsgyexS8Q
haskell,39ci9j,Mylos,5,Thu Jun 11 00:17:38 2015 UTC,ghc now has this functionality with _ as any hole. Just fyi!
haskell,39ci9j,twistier,1 point,Thu Jun 11 02:56:54 2015 UTC,"That is great, I'll leave it for now, but when I'm feeling more confident I can see myself using this quite often."
haskell,39ci9j,srhb,40,Thu Jun 11 01:51:44 2015 UTC,"Though this kind of ""straight jacket"" is, as you seem to be implying, a good thing, I feel that I should also point out that this feeling disappears after a while, and then is replaced by exactly the opposite. I feel so ridiculously constrained in languages like PHP that it has become very difficult to relate to the point of view that Haskell is more constraining."
haskell,39ci9j,PM_ME_UR_OBSIDIAN,27,Wed Jun 10 21:51:35 2015 UTC,"Word. Particularly, I feel like programming without the guidance of a very strong type system is ridiculously hard now. What did I forget? What might the outputs here be? Etc..."
haskell,39ci9j,kqr,7,Wed Jun 10 22:26:05 2015 UTC,"Programming with a nice strong type system, you can kind of tune out and go through the motions. If you make a bad assumption, you'll get feedback on it."
haskell,39ci9j,kqr,12,Thu Jun 11 05:01:18 2015 UTC,"My friends who are used to dynamic type systems always say ""How can you have so many problems? You must be inventing problems for yourself. I've never had a problem!""  Then I vocalise those questions you gave examples of, and they go, ""Yeah, I guess... I just know my code so I don't need the type system to know that."" Pah! Watch them write a million tests or suffer a million bugs.  It's funny how people using dynamic type systems seem to think they are superstar programmers who can handle having the system in their head at once, and people who are used to strong, static type systems are the ones to admit that they really... suck at programming and need all the assistance they can get to get it right.  Either there's a causality (bad programmers eventually find their way to static type systems and other tools they need) or one group has not yet realised that they are no better than anyone else."
haskell,39ci9j,Taladar,4,Thu Jun 11 06:12:27 2015 UTC,"It's funny how people using dynamic type systems seem to think they are superstar programmers   In my experience it's the opposite: dynamically typed languages seem easier. When starting out they allow the developer to score quick victories by putting together simple programs very quickly, even non-programmers can do it, this gives people the confidence to continue on to harder stuff. Haskell on the other hand offers no quick and easy victories and is therefore perceived as 'too hard'.  The developer who started working in the dynamically typed language to build simple projects will then use that same language to develop harder ones, since it's what they know.  So these people don't think they're superstars, they probably just think statically typed languages are too hard for them. Seems you have different experiences though, there's probably more than one type of programmer who uses dynamically typed languages."
haskell,39ci9j,hailmattyhall,8,Thu Jun 11 15:32:03 2015 UTC,there's probably more than one type of programmer who uses dynamically typed languages.   I'm going to go out on a limb and say that that is a very safe assumption. ;)
haskell,39ci9j,kqr,2,Thu Jun 11 15:59:06 2015 UTC,"When starting out they allow the developer to score quick victories by putting together simple programs very quickly, even non-programmers can do it, this gives people the confidence to continue on to harder stuff.   I would argue that they allow people to perceive incomplete programs as victories. They test the happy path and are unaware of the many problems lurking in the rarer and exceptional conditions that can happen during the execution of their program.  Static languages force you to confront these situations as well which makes it seem harder but in the end you end up with a program that handles all those cases."
haskell,39ci9j,srhb,3,Thu Jun 11 19:08:37 2015 UTC,"It's funny how people using dynamic type systems seem to think they are superstar programmers who can handle having the system in their head at once   I have never, ever seen anyone express that view. People prefer dynamically typed languages for a wide range of reasons, such as fast prototyping, certain libraries (like RoR or matplotlib or ggplot), tight feedback cycles (compiling a yesod or snap application takes a while) or they simply don't think that static type systems bring enough benefits. That doesn't automatically make them all less aware of their own abilities or worse programmers or people who haven't seen the light.   static type systems are the ones to admit that they really... suck at programming and need all the assistance they can get to get it right.   This comment just sounds like a humble brag."
haskell,39ci9j,beerdude26,11,Thu Jun 11 14:47:52 2015 UTC,"I hear it every day. I work with and have friends who are programmers using dynamic languages, and they keep telling me over and over that I'm worrying about peanuts and that they've never had any problems with a dynamic type system, and that I'm inventing problems for myself.  I'm not bragging, I'm trying to objectively describe the conversations I have weekly. I'm not even saying they are wrong. (Or, at least, that's not a strong point of mine.) I'm open to the possibility that I am an extraordinarily bad programmer, and they just have skills I lack.  Many a time have I been met with the argument of, ""You must be a really bad programmer if you get bugs when you don't have your compiler to help you."" I can only honestly admit that, ""Yes, that's exactly it. I am a terrible programmer and that's why I need my compiler to help me."" At that point the argument often ends because they feel like they've proven their point: I am a bad programmer so I need it, they are good programmers so they don't need it."
haskell,39ci9j,get-your-shinebox,3,Thu Jun 11 15:07:10 2015 UTC,TL;DR: Good PHP programmers have scary mad skills. Seriously.
haskell,39ci9j,HildartheDorf,1 point,Thu Jun 11 16:54:37 2015 UTC,"Arrays for days, mang"
haskell,39ci9j,kqr,3,Fri Jun 12 11:27:43 2015 UTC,I like to think of static type systems as a proper use of humility: http://lesswrong.com/lw/gq/the_proper_use_of_humility/
haskell,39ci9j,Taladar,5,Fri Jun 12 03:55:16 2015 UTC,It's a really common issue.
haskell,39ci9j,beerdude26,10,Thu Jun 11 06:22:44 2015 UTC,"But that would imply that people using dynamic type systems have lower inherent skill levels than those using strong static type systems. I can't stand behind that implication, which is why I didn't mention that effect in my comment."
haskell,39ci9j,Stratege1,5,Thu Jun 11 06:33:12 2015 UTC,Actually I would argue that there is some evidence to support that claim for the subset of dynamic language users who are inexperienced enough to still think they do not need help to write correct programs (as opposed to those who just think static typing is not the right tool to help them in that task). Those usually are the ones who do not even use automated testing in their dynamic language.  Especially true of course when you compare their skill level to that of a strong static language user who has also used dynamic languages in the past.
haskell,39ci9j,TweetsInCommentsBot,9,Thu Jun 11 08:17:02 2015 UTC,"Excellent point, I'm beginning to notice this too. At compile time you wear the straight-jacket of strict type-checking but runtime is a different experience, it's a strong breeze of JustWorks™ which blows away the trepidation I usually feel when trying some PHP code for the first time.  PHP also gets worse as the codebase becomes more complex. Drupal (which is what I'm paid to use) has been making significant strides towards adopting OOP; the extra levels of abstraction and indirection in the codebase and lack of typing in PHP can lead to some obscure runtime errors. There are debugging tools to deal with it, but I'd rather not have to."
haskell,39ci9j,everybodyhatesclowns,3,Thu Jun 11 01:24:57 2015 UTC,"Drupal? Ouch. Whenever I have a project in that, I put all my IO-facing code in a try-catch to emulate ""IO-aware"" code (this isn't done anywhere in the core Drupal code, BTW, any errors are just caught by the default top try-catch wrapper). This works well until I write something that causes a PHP fatal error, which aren't properly catchable (naturally)."
haskell,39ci9j,beerdude26,4,Thu Jun 11 08:46:04 2015 UTC,I'd actually go further and say that that which you experience as a compile time straight-jacket can also be a great guide. Just tried to write the algorithm mentioned here (inverting a Binary Tree) - just on paper that's a lot harder than when you can poke the compiler on wether or not what you have written is sound in terms of types (without it I'd have accidentally written Tree a  -> [a] instead of the more correct Tree a -> [[a]])
haskell,39ci9j,theonlycosmonaut,3,Thu Jun 11 08:10:51 2015 UTC,"@mxcl   2015-06-10 17:07 UTC  Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.     This message was created by a bot  [Contact creator][Source code]"
haskell,39ci9j,theonlycosmonaut,3,Thu Jun 11 08:10:55 2015 UTC,You can see a type system as a cage or as hand rails!
haskell,39ci9j,agumonkey,2,Thu Jun 11 11:12:17 2015 UTC,"More like a roll cage: ""we'll keep you safe when everything disintegrates around you"""
haskell,39ci9j,agumonkey,18,Fri Jun 12 11:30:45 2015 UTC,"To take your title to its logical conclusion, is working in PHP like programming while being insane? ;)"
haskell,39ci9j,jP_wanN,5,Wed Jun 10 23:26:58 2015 UTC,"this implies that ""crazy"" people become sane when they are put in straight jackets, and that they are insane outside of straightjackets. this seems wrong on many levels, but i will meerly wave at them and leave the exploration to yourself"
haskell,39ci9j,agumonkey,3,Thu Jun 11 02:49:31 2015 UTC,"That's how straight jackets work, right?"
haskell,39ci9j,codygman,9,Thu Jun 11 11:49:46 2015 UTC,"Welcome to Perlism #19  The straight jacket thing made me think of Capoeira. It started with very movement limited slaves, turning constraints into opportunity for new ideas and possibilities.  It would be worth a dedicated website to list this kind of experience. I too learned so much by using non mainstream languages. ADA, sml, haskell, Lisp being my first red pill. They reveal abstractions that you can see and use in other situations. And since most programming languages are close, even if you're back in PHP, you can reuse ideas and concepts. For instances, monads, untyped though, can be written in Lisp, JS, etc etc. Typed thinking is a gem among gem to think about correct logic. I often decorate python return statements with type hints so I can reason. Anyway spread the good words around. Or don't and let's enjoy or own tiny snobby circle :)  btw: the ""error conditions last"" way bugged me so much, I searched for a 'negative' paradigm where you'd design error firsts, then fill in the working case. I think Nassim Taleb wrote about systems with this features. He argues that we're very bad at predicting, and thus we should spend more time trying to manage errors rather than to rely on potential correctness.  ps: how did you run into haskell ? a tutorial, a book, and how long did it take for you to start doing something serious in it. I talk a lot but I actually never wrote anything in it. I always toy around, go back to lisps, and write actual code in python because .. libs (ho the sadness)."
haskell,39ci9j,agumonkey,6,Wed Jun 10 22:02:21 2015 UTC,"Welcome to Perlism #19   I have heard that before, didn't realise it was a Perlism however. Good one!   ps: how did you run into haskell ?   Thanks for asking. I'm not sure, my first attempt at learning it was back in 2006 and I gave up due to the online book on the subject being only partially finished. On that attempt I got to higher-order functions, Currying and a really bad and off-putting Monad analogy before the book became incoherent and I gave up.  Things are much better now, with Learn You a Haskell and the lectures by Dr. Erik Meijer."
haskell,39ci9j,TobyGoodwin,2,Thu Jun 11 01:45:33 2015 UTC,"Well, welcome to the FP side of things. The rabbithole goes a long way."
haskell,39ci9j,TobyGoodwin,3,Thu Jun 11 08:22:38 2015 UTC,"Which libs in particular do you have in Python that you don't have in Haskell? I'm still a noob, but I really didn't have problems finding (multiple) appropriate libraries for all parts of the Haskell project I just started."
haskell,39ci9j,Ramin_HAL9001,5,Wed Jun 10 23:06:43 2015 UTC,"Sorry, I wasn't clear enough, the library problem was more about scheme, or elisp. (commonlisp has quicklisp, people seem rather satisfied with libs listed there). While python got me started faster because of larger community, article number etc etc.  psedit: also, I don't even remember thinking Haskell was lacking libraries, it's just I'm still not there with its IO and I don't really click on how fancy HTTP server (among other IO stuff) could work with pure laziness etc etc... mostly functional patterns that I'm not used to. I'm still at the tree recursion level."
haskell,39ci9j,anders_,5,Wed Jun 10 23:30:30 2015 UTC,I'm still at the tree recursion level.   I would say just try to make stuff instead of learning concepts first. Learn them when needed for a project you are trying to complete. It's much faster learning and more rewarding since you have an end result.
haskell,39ci9j,Ramin_HAL9001,3,Thu Jun 11 01:49:56 2015 UTC,"Good point, it was in the context of writing evaluator (scheme in haskell) and such. But you're right I should try to use it for an actual application."
haskell,39ci9j,anders_,4,Thu Jun 11 08:23:52 2015 UTC,"Yes indeed. I remember, many times, staring at Yet-Another-Incomprehensible-GHC-Error, willing it to just run the damn program, even if it does have a type error in it.  Over time, though, several things happen. One is that the errors start to make more sense (my best tip is always to look at the exact location where the error is reported). And you just get more experienced and quicker at finding and fixing type errors. So getting the code past the compiler becomes much less of a burden.  Then, more and more times you'll experience those wonderful moments where you finally get the code to compile... and it works correctly first time!"
haskell,39ci9j,anarcap,8,Thu Jun 11 15:16:57 2015 UTC,"Argh! It's a strait jacket.  (See also: “strait and narrow”, which comes from Matthew 7:14: “strait is the gate, and narrow is the way, which leadeth unto life, and few there be that find it”)"
haskell,39ci9j,_AndrewC_,2,Thu Jun 11 08:18:06 2015 UTC,"Sorry, I noticed the error but it was too late, reddit disallows editing titles."
haskell,39ci9j,deech,5,Thu Jun 11 14:06:51 2015 UTC,"Ha ha! Because it keeps you from doing crazy stuff like accidentally killing yourself? A strait-jacket is a good analogy! According to this site:  http://bjorn.tipling.com/if-programming-languages-were-weapons  If programming languages were weapons used to ""kill"" problems, then PHP would be a garden hose with one end attached to the exhaust pipe of your car and the other end in the driver-side window. That is, it doesn't solve your problem, it just slowly kills you."
haskell,39ci9j,codygman,4,Thu Jun 11 05:33:52 2015 UTC,"C is an M1 Garand standard issue rifle, old but reliable.   C is reliable???  I wonder what that guy's favourite language is, because I couldn't possibly tell from that post."
haskell,39ci9j,beerdude26,3,Thu Jun 11 09:14:20 2015 UTC,"I guess the guy was trying to be fair and non-partisan by criticizing all languages.  And also, I think C is very reliable, it works as expected just about anywhere. That doesn't mean it is produces good, error-free code. It's old, so it lacks safety features."
haskell,39ci9j,anarcap,3,Thu Jun 11 10:07:31 2015 UTC,"He didn't really criticise C though, is my point. ""Old"" isn't really a criticism.  But I suppose you're right about the reliability. it's just not the definition I had in mind (what I was thinking of you can probably guess from where we are ;) )."
haskell,39ci9j,yitz,3,Thu Jun 11 10:22:35 2015 UTC,"I feel like I'm in a straight jacket when I'm writing code that's not in Haskell. It took a while to get used, thought. Keep it up, you'll soon feel out of the water writing php."
haskell,39ef3y,heruur,6,Thu Jun 11 04:36:49 2015 UTC,"Maybe the mapConcurrently introduces potential blocks, races etc that skew the results.  Even if not, an IORef call is a dozen nanos or so, and any GC is going to splat comparisons.  Removing the concurrent complexity (tweak here), it looked a lot more stable, with IORef < MVar < TVar < TMVar (at least with the writes I checked)"
haskell,39ef3y,tonyday567,3,Thu Jun 11 06:40:12 2015 UTC,"Yes, when you run everything in a single thread, then you will get the result you describe. I personally would never use Concurrency primitives in a single-theaded environment though. The reason swapMVar is slow is that it isn't atomic, while the other operations are. If you ignore this one case, the result is consistent with your simplified version.  In either case atomicModifyIORef' is way slower than modifyTVar and modifyIORef' is just unsafe."
haskell,39ef3y,merijnv,5,Thu Jun 11 07:16:24 2015 UTC,"Have you tested with many concurrent readers? The main reason to avoid TVar in practice is the fact that they suffer from thundering herd issues, whereas MVar's enforce fairness and a more efficient wakeup."
haskell,39ef3y,Peaker,5,Thu Jun 11 08:10:47 2015 UTC,"That is weird!  atomicModifyIORef should really be not much more expensive than a single LOCK-based CAS (whose main cost comes from incurring a full memory barrier like the MFENCE instruction, on Intel).  A TVar would also need to synchronize at least once. So it should also pay for at least a single memory barrier.  I guess atomicModifyIORef is doing something really expensive in addition to the CAS."
haskell,39ef3y,cartazio,3,Thu Jun 11 16:34:32 2015 UTC,"atomicModifyIORef has a retry + computation loop where it computes the update, then tries to CAS, and tries again. So if the update function takes any time at all, that can dominate, OR there could be cacheline ping ponging if theres super high contention and you have enough cores. I'll maybe try to look at the code on this thread this weekend when i have some time."
haskell,39ef3y,Peaker,2,Fri Jun 12 05:06:53 2015 UTC,"As I understood it, it doesn't really compute the update -- but rather creates a thunk that would later compute the update."
haskell,39ef3y,fryguybob,1 point,Fri Jun 12 06:06:48 2015 UTC,"Indeed, the CAS loop does not compute the update, but just atomically places a thunk that updates with the previous value.  https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm#L584  The 'ed version forces this thunk after it is put in place.  This benchmark does not talk about much at all if it is not running on the threaded runtime."
haskell,39ef3y,ccaapton,2,Sat Jun 13 15:35:39 2015 UTC,I updated the code to check with different levels of concurrency.
haskell,39dzgt,cartazio,3,Thu Jun 11 02:50:58 2015 UTC,Question: What's the company's name? ◔ ◡ ◔
haskell,39dzgt,well-formed,13,Thu Jun 11 03:16:27 2015 UTC,I'm a little disappointed it isn't actually megacorp.
haskell,39dzgt,Hrothen,10,Thu Jun 11 04:48:29 2015 UTC,I'm pretty sure it's JP Morgan.  OP probably left it out to avoid the issue of whether he had permission to use the company's name publicly.
haskell,39dzgt,mightybyte,5,Thu Jun 11 03:40:40 2015 UTC,Zombocom
haskell,39dzgt,jberryman,2,Thu Jun 11 03:34:16 2015 UTC,i'm pretty sure we could cook up some projects to stress test your lock free queues if you were interested in coming on :).
haskell,39dzgt,vamega,3,Thu Jun 11 03:39:38 2015 UTC,Biggest financial services company by employees. Ik not sure if Carter would be okay with me revealing more.
haskell,39dzgt,well-formed,6,Thu Jun 11 03:22:32 2015 UTC,"i do think we helped sponsor something recently, http://www.composeconference.org/2015/sponsors/"
haskell,39dzgt,vamega,3,Thu Jun 11 03:34:26 2015 UTC,"ah, Skedge! Y'all grew quick!"
haskell,39dzgt,theonlycosmonaut,1 point,Thu Jun 11 03:51:34 2015 UTC,"Whoa, can't believe I didn't see that. I really hope to catch the next one."
haskell,39dzgt,Agathos,2,Thu Jun 11 03:36:25 2015 UTC,I assumed it actually was Megacorp till I saw NYC.
haskell,39dzgt,created_to_post_this,1 point,Thu Jun 11 23:02:17 2015 UTC,Ares Macrotechnology
haskell,39dzgt,created_to_post_this,3,Fri Jun 12 12:28:46 2015 UTC,I'm happy to try to answer any questions.
haskell,39dzgt,Dwarf_muncher,4,Thu Jun 11 03:03:39 2015 UTC,"Here's one. Presume for a moment that megacorp had a European technology headquarters in the wonderful city of Glasgow in Scotland. Perhaps also say that teams working from Glasgow using Python and Java often co-operated with their American colleagues without the need for co-location. Is it possible that someone might be able to join your Haskell team but work at the Glasgow office? (Please say yes because I love Haskell!) For clarity, I don't currently work for megacorp but I may currently be in the recruitment process for a Python job. I say 'may' in case I'm not thinking of the right megacorp."
haskell,39dzgt,acow,3,Thu Jun 11 09:55:53 2015 UTC,This is an interesting question.  I will have to ask my boss.
haskell,39hgn3,everdev,5,Thu Jun 11 19:10:50 2015 UTC,"They both have their problems.   Neither explains what sort of errors entering a to-do item can give. In fact, error checking there was surprising to me, because it looks like you're just asking for strings. Does checking the errors terminate execution? It looks like it just continues running. Your second example looks like it asks for a single to-do, but then operates on a collection of them. Why are you mentioning a specific database program in your second example? What does ""skip"" mean in this context? It looks like it's some sort of print statement, but I'm used to ""skip"" meaning ""do nothing"". I admit I'm totally unaware of notational conventions in scenario-based testing, but I would find something more mathematical looking much more readable than when/then with sort-of-English explanations. Something like newToDo.completed is true ==> newToDo.dueDate is """"   If I had to pick one of them, I'd go for the second, but not be happy about my choice. Personally when I write pseudocode it looks like Python, just with more built-in functions and data structures."
haskell,39hgn3,Barrucadu,2,Thu Jun 11 19:51:53 2015 UTC,"Thanks.  It's just pseudo-code, not meant to actually work or cover all scenarios like error reporting, or handling multiple inputs.  I'm trying to basically get a feel for people's preferences for verbose / English-like syntax (like Ruby) vs. more mathematical syntax (like C).  Your example is helpful though of what syntax makes the most sense to you."
haskell,39hgn3,sambocyn,12,Thu Jun 11 19:57:00 2015 UTC,C syntax is mathematical?
haskell,39hgn3,beerdude26,3,Thu Jun 11 20:12:55 2015 UTC,I'd call it mechanical
haskell,39hgn3,Taladar,6,Fri Jun 12 11:24:31 2015 UTC,One thing I found really irritating in the first example was the large number of capitalized words. I am used to capitalization signifying something important but in your pseudo-code it seemed pretty random what was capitalized and what wasn't.
haskell,39hgn3,theHawke,4,Thu Jun 11 20:14:56 2015 UTC,"Looking over it, I would spontaneously say that the second one is more readable, since the bracketing gives a bit more structure.  However, neither of these exaples has any syntax highlighting which I feel can also provide this structure. Since modern editors basically all have syntax highlighting, this makes the extra structure imposed by the brackets slightly redundant. (This is also the reason why I hate reading haskell without syntax highlighting, it hase a very terse syntax)"
haskell,39hgn3,776865656e,2,Thu Jun 11 20:21:33 2015 UTC,"I don't have sufficiently coherent thoughts at the moment to contribute, but just to say it's a cool little example - I've made various toy languages which try to be more like the first than the second. This one happens to be on GitHub, though it's more of a joke language"
haskell,39fc17,snoyberg,3,Thu Jun 11 10:00:53 2015 UTC,"Kind of related:  On my computer, GHCi sometimes refuses to start and segfaults instead. When I install a package that uses TH, this can happen too, but without any warning. It just says ""failed to install"".   From the output I can see if the compiler is running TH, and if it fails in this scenario, I simply try to install the package again. Yesterday I installed haskelm, and it took almost 10 attemts, but then worked."
haskell,39fc17,tcp_omg,2,Thu Jun 11 12:03:30 2015 UTC,Failing TH should not suddenly start working the next time you try it since it usually works on fixed inputs. This sounds a bit like faulty RAM or an overheating problem or something of that sort.
haskell,39fc17,Taladar,2,Thu Jun 11 13:48:46 2015 UTC,"Yes, I guess that GHCi is invoked and fails with that segfault error, as it does sometimes on my machine. Faulty RAM seems to be a possible explanation."
haskell,39fc17,tcp_omg,3,Thu Jun 11 13:59:59 2015 UTC,"Python's pip package manager also doesn't retry, and I don't really understand why not. (this is one of the most common reasons for a travis job to fail for me, on my Python projects). It seems to me some conservative number of retries should definitely be done, say, 3."
haskell,39fc17,radix,3,Thu Jun 11 15:55:03 2015 UTC,"I opened a stack issue to track this. I don't know of a downside to retry, perhaps someone else will bring itup."
haskell,39fc17,fridofrido,2,Thu Jun 11 16:06:09 2015 UTC,"On Windows, I got a lots of ""does not exist"" messages from cabal, but without a file name, so I have no idea what does not exist... But I think it is related to Haddock somehow."
haskell,39fc17,soenkehahn,2,Thu Jun 11 16:15:57 2015 UTC,Generally I've seen this error too caused by network problems. But currently I'm getting a similar error for asn1-parse-0.9.1. When I do  cabal get asn1-parse-0.9.1   I get a better error message saying:  Unpacking to asn1-parse-0.9.1/ cabal: data is not in tar format   So I suspect there's something else going on. Downloading the tarball manually seems to work though.
haskell,39fc17,soenkehahn,1 point,Fri Jun 12 03:30:20 2015 UTC,Seems like I had a corrupted tarball in my package cache in ~/.cabal. After deleting that the problem went away.
haskell,39fc17,mightybyte,2,Fri Jun 12 04:18:53 2015 UTC,"Hopefully the TUF work for cabal would fix a situation like that. In stack, we already check the hashes of downloaded files, so a situation like that shouldn't ever arise."
haskell,39fc17,longlivedeath,4,Fri Jun 12 13:22:35 2015 UTC,Why not just improve the error message and send a pull request without the fanfare?
haskell,39fc17,hagda,2,Thu Jun 11 16:18:41 2015 UTC,I think the issue is fixed in Cabal HEAD.
haskell,39fc17,hvr_,4,Fri Jun 12 00:47:21 2015 UTC,"I'm a bit confused... you don't know for sure that Hackage glitched for that Travis job, and yet you assume this was the reason, and jump to the conclusion that cabal's package downloading algorithm or alternatively the default mirror needs to change? What if this was simply a glitch on Travis' end? IIRC Travis had to introduce the travis_retry helper to workaround network connectivity issues they were experiencing."
haskell,39fc17,gbaz1,1 point,Thu Jun 11 11:34:32 2015 UTC,"It's entirely possible that the download failed for a different reason. I thought my explanation on that point was pretty clear:   when cabal is unable to download the necessary package from Hackage, usually because Hackage is having a temporary blip   There are plenty of reasons why the download could fail (as you mention). In my experience, the most common cause of this error message is when Hackage is down temporarily.  This statement actually comes with a fair amount of experience on my part. The original reason we created the S3 mirror was to service FP Haskell Center, due to user error reports of failed downloads. Once we put the mirror into place, we didn't receive a single additional report of that kind."
haskell,39jutq,ddlk,6,Fri Jun 12 06:05:07 2015 UTC,"Evariste looking well, considering. :D"
haskell,39jutq,_AndrewC_,-4,Fri Jun 12 10:47:26 2015 UTC,congrats! http://allmalepanels.tumblr.com
haskell,39d2t5,sibip,3,Wed Jun 10 23:18:13 2015 UTC,"Nice, I didn't expect 7.10.2 so soon."
haskell,39d2t5,cocreature,5,Thu Jun 11 07:13:45 2015 UTC,NOBODY expects the...
haskell,39ayyx,tom-md,4,Wed Jun 10 14:59:25 2015 UTC,"Keeping with my tradition of double-announcing:  I deleted the last post announcing SAW because I said ""open source"" when we've actually released it as non-commercial and people don't like surprises (to the point they get repetitive!).  Also, this links to Aaron's blog post about it, perhaps giving a better introduction than the raw http://saw.galois.com page."
haskell,39ayyx,Hakawatha,3,Wed Jun 10 15:01:22 2015 UTC,Is this ever going to be open-sourced? If you're not making money off it you might as well.
haskell,39ayyx,aseipp,3,Wed Jun 10 18:35:07 2015 UTC,"Notice Cryptol and saw-core are both BSD so things have been transitioning that way for a while.  I can't predict the future, certainly not for a project that isn't mine, so I'll leave everyone else to speculate as to the future of SawScript (the main non-commercial part of this work)."
haskell,39ayyx,pipocaQuemada,4,Wed Jun 10 18:51:03 2015 UTC,"I used the predecessor to this tool, and it's very good. This version looks even better!  Now, if Cryptol/SAW 2 could just use Z3 by default as their theorem prover (with the new license change) instead of CVC4, it would already work so nicely under Nix/NixOS ;)"
haskell,39ayyx,sgraf812,3,Wed Jun 10 22:26:06 2015 UTC,"I know you've seen this, but for everyone elses sake: the issue already exists!  https://github.com/GaloisInc/cryptol/issues/196"
haskell,39ayyx,ranjitjhala,5,Wed Jun 10 23:12:29 2015 UTC,"Does this analyze Java code or JVM bytecode?  Could I use this, for example, to analyze a Scala codebase?"
haskell,39bal8,dbushenko,4,Wed Jun 10 16:23:36 2015 UTC,"That's funny, because I just have a similar problem last week end and I stumble upon Haskeleton and Hi. I found both quite interesting (one is a template of the other) but they lack the ability to add files on the fly, which your project seems to have.  Anyway I didn't bother use them at the end (not knowing which one to chose from )  but I like the idea of it. Especially being able to create a project with a decent .gitignore, get all test-suites set up and being able to  add pair file/file_spec on the fly. Is it something trurl can do ? Even though it probably better to have the effort of the communautiy going toward one skeleton tool, I doubt it will happend. Maybe you could provide a convert from Hi to turl ?"
haskell,39bal8,maxigit,3,Wed Jun 10 19:57:25 2015 UTC,"Yep, I really needed to add files on the fly. Working on JSON REST service was a lot like just adding usual entities such as Article, Comment, Book or something else, and writing the boilerplate was too boring. That is why you may create a normal mustache template for one single file, put it to ~/.trurl/repo and generate your boilerplate code for your entities. Also trurl can generate full project skeletons and this is really easy. You may re-use any project skeleton, just pack it as tar archive and put to ~/.trurl/repo."
haskell,39bal8,taylorfausak,2,Wed Jun 10 20:36:01 2015 UTC,Maybe you could provide a convert from Hi to turl   Today I have added the missing feature that prevented me from converting the Hi templates. Now I'm working on importing Hi templates to trurl.
haskell,39bal8,maxigit,1 point,Thu Jun 11 21:23:30 2015 UTC,Haskeleton does support adding new files through the Haskeleton.hs script.
haskell,39bal8,taylorfausak,2,Thu Jun 11 19:00:09 2015 UTC,"Do you mean you can create new file once the project has been created. For example, haskeleson -n data.Foo will create a src/Data/Foo.hs and test/Data/FooSpec.hs."
haskell,39bal8,maxigit,1 point,Thu Jun 11 20:17:38 2015 UTC,"Yes, that is what I meant."
haskell,39bal8,taylorfausak,2,Thu Jun 11 20:22:42 2015 UTC,Is there any documentation about that somewhere (hi or haskeleton) ?
haskell,39bal8,maxigit,1 point,Fri Jun 12 11:42:53 2015 UTC,"Just use trurl, I'm always available for help with it! :-) BTW, today or tomorrow I'm going to import Hi templates to trurl repository."
haskell,39bal8,gergoerdi,1 point,Fri Jun 12 12:05:23 2015 UTC,Hi documents its templates in its readme. Unfortunately I did not document the Haskeleton.hs script. I made an issue for that.
haskell,39bal8,Crandom,1 point,Fri Jun 12 12:27:34 2015 UTC,It looks like templating facilities of Haskeleton and Hi are not so rich. I used mustache templates since it is possible to make almost any template with it.
haskell,39c31h,nicheComicsProject,9,Wed Jun 10 19:29:26 2015 UTC,Is this the one? Haskell Design Patterns: .Extended Modules
haskell,39c31h,peargreen,6,Wed Jun 10 20:07:02 2015 UTC,I think it is!  Thanks so much.  I love this sub. <3  EDIT: To be specific it was this discussion that I was remembering.
haskell,39c6j0,gilmi,7,Wed Jun 10 19:51:48 2015 UTC,"Books like Code Complete are probably still worth a skim, but it's going to be a bit of a mix.   General advice, e.g., on naming things and structuring your code with consideration for what's readable by other programmers, is still applicable - you'll just need to make the conceptual jump yourself to apply it to things like if/how you use point-free style. Advice on writing testable code is useful to keep in mind, but if you're using Haskell, you probably don't need pages dedicated to selling you on the idea, or to be instructed in the mechanics all that much. Keep in mind that it's still possible to write code that's difficult to test in Haskell. Design Pattern related content is more useful for keeping in mind how to communicate with programmers from other ecosystems. It's not as directly useful, since a lot of it boils down to ""recipes for implementing basic concepts in languages that don't support them""   If you read them from the perspective of working with other people, you'll get something out of them, but if you're voluntarily working in an ecosystem that supports/enforces these concepts by default, the verbiage is probably a bit wasted.  It'd be really nice to see some blog posts or books directly focused on working with teams in a functional language/style."
haskell,39c6j0,T-R,1 point,Wed Jun 10 23:33:52 2015 UTC,interesting. thanks! And I agree about the blog posts part
haskell,39c6j0,gelisam,7,Thu Jun 11 14:39:19 2015 UTC,Is this the right subreddit to ask about non-Haskell books? I almost reported your post as spam because your post looks like a clever way to get us to click on referral links to those two books.
haskell,39c6j0,gelisam,5,Wed Jun 10 20:13:24 2015 UTC,"I would like to hear from fellow Haskellers if these book felt relevant for them, exactly because their are non-Haskell books yet frequently recommended as books ""any programmer MUST read"".  I have no problem removing the links to the books."
haskell,39c6j0,Stratege1,2,Wed Jun 10 20:26:27 2015 UTC,"I have no problem removing the links to the books.   Now that you have proved you're a human, you can put the links back, they're useful :)  I haven't read either book, so I'm sorry that my only contribution to this conversation will have been so unconstructive."
haskell,39c6j0,PM_ME_UR_OBSIDIAN,6,Thu Jun 11 00:08:22 2015 UTC,"Having read Clean Code, I have come to the conclusion that it is a terrible book without any merit and should therefor be avoided in favor of better books. Every chapter is written by a different guy - who in his examples is not following the guidelines for what clean code is set out by the other guys, thereby making the whole book an inconsistent mess. That it's also a very Java specific book focusing on the problems Java creates doesn't really help matters. (Not that the general ideas in some parts of the book are necessarily bad, just not well delivered.)"
haskell,399w2p,dons,8,Wed Jun 10 08:28:12 2015 UTC,"Yes, we're hiring again.   1 in Singapore 2 in London   Work with /u/ndmitchell, Roman Leschinsky, /u/augustss, /u/gergoerdi, /u/malcolmw, Andy, /u/dreixel, George, Chris, me"
haskell,399w2p,fruitbooploops,2,Wed Jun 10 08:38:05 2015 UTC,"Hey I'm not at all qualified for this job, I was just wondering what would motivate you guys to write your own compiler? I think it's so cool to see a serious team so invested in Haskell, and I'd love to take a look at what kinds of things you guys have produced if that's at all possible!  Thanks!"
haskell,399w2p,AlpMestan,4,Wed Jun 10 13:02:27 2015 UTC,This talk by /u/augustss might answer some of your questions.
haskell,399w2p,hagda,2,Wed Jun 10 17:24:16 2015 UTC,StrictHaskell maybe...
haskell,399w2p,merijnv,1 point,Wed Jun 10 14:14:14 2015 UTC,"FYI, augustss is responsible for implementing the first ever haskell compiler, and the (semi-serious) running joke is that reimplementing haskell compilers is his hobby, so that'd help explain the cost benefit ratio of writing your own compiler ;)"
haskell,399w2p,created_to_post_this,1 point,Thu Jun 11 07:49:47 2015 UTC,"Right now I don't think I'm good enough for these roles, but I think I can get there. Do you have any advice for how one might develop oneself over a few years so I might be ready in future?  For context what I'm already doing to develop myself is:   I'm a senior developer so growing in that role (though I'm working with OO c#); and doing a maths degree with Open University in my spare time to improve analytical thinking."
haskell,399w2p,created_to_post_this,2,Thu Jun 11 09:40:21 2015 UTC,"2 or 3 years of solid Haskell work, or equivalent in open source, is basically needed. C# won't be much use really. Have to show ability in functional design - we avoid simply typed, mutable code almost entirely."
haskell,399w2p,CharlesStain,1 point,Thu Jun 11 13:19:43 2015 UTC,Perfect thanks. I've done a personal site with Haskell/Yesod and some other personal projects already. I'm going to look for some open source projects needing contributions as a next step. You may hear from me in a few years when I think I'm at the standard you're expecting for Haskell. I love using it so I'm pleased it's beginning to look like a career option.
haskell,397k1a,quchen,36,Tue Jun 9 20:44:19 2015 UTC,"Some thanks are in order:   Franz Thoma, who implemented the warnings in GHC with me Herbert V. Riedel for his help with the compiler and writing the proposal Edward Kmett for preventing us from doing some stupid mistakes (we'll keep the String, alright alright) ;-) ZuriHac and its organizers for giving me the final kick in the butt to actually start implementing/proposing this"
haskell,397k1a,pchiusano,29,Tue Jun 9 20:49:03 2015 UTC,"+1  Long overdue!  Sincere question, does fail in Monad have any supporters whatsoever? Everyone I have talked to about this views it as a complete abomination."
haskell,397k1a,tibbe,18,Tue Jun 9 21:41:50 2015 UTC,"I'm not a supporter of fail (I think GHC should just raise an unconditional error on pattern match failure, just like we do for any other partial function), but I think the proposal overstates the problem of having fail in the Monad class. We could just pretend it's not there without seemingly suffering any problems. I think most people already do. Introducing MonadFail adds some additional complexity to the desugaring and yet another migration (people who promised to help with the BBP migration haven't sent me any patches so far. My libraries still aren't fixed for BBP.)"
haskell,397k1a,Peaker,6,Tue Jun 9 22:45:55 2015 UTC,"I think the main purpose of that complexity is enabling stuff like:  catMaybes xs = [x | Just x <- xs]   But if we all embrace lens, that kind of use case is solved by listOf and folds:  catMaybes = toListOf (folded . _Just)   (Or you can generalize _Just to folded and have it work for all foldables.  This kind of lens code has become so easy to write on the spot, though, that combinators like catMaybes are no longer useful.   So perhaps, in a sense, lens obviates the main use case for Monad's fail!"
haskell,397k1a,Taladar,8,Wed Jun 10 14:36:39 2015 UTC,I am not sure lens is a real contender in terms of reducing implementation complexity.
haskell,397k1a,Peaker,3,Wed Jun 10 17:19:04 2015 UTC,"Well, it takes the complexity outside of the core language, at least :-)"
haskell,397k1a,drb226,4,Wed Jun 10 20:30:04 2015 UTC,"lens is so abstract and powerful, it's pretty much true that forall x. lens obviates x."
haskell,397k1a,smog_alado,1 point,Wed Jun 10 16:32:14 2015 UTC,"To be perfectly honest, the main motivation of the proposal is getting fail out of Monad. Adding it elsewhere is something we can discuss, and indeed I would personally like to see it gone entirely. That's a much bigger change though, so we opted for the almost non-breaking solution."
haskell,397k1a,tejon,8,Thu Jun 11 21:00:40 2015 UTC,"Some view it as a sometimes useful abomination, some don't care, and I'm sure there are plenty of other ""some""s. If I could turn back time I would simply not add special >>= desugaring for do-notation."
haskell,397k1a,roche,7,Tue Jun 9 21:45:21 2015 UTC,"Given how much everyone hates fail, I wonder if there isn't some way to get rid of it completely instead of adding a MonadFail class. That way you don't have to deal with a perpetual increase in complexity, such as the ""MonadFail is a bad name if its a subclass of Applicative"" problem that is mentioned in the proposal."
haskell,397k1a,tejon,11,Tue Jun 9 22:23:22 2015 UTC,"Maybe, maybe not. Worst case is we're paving the way for a deprecated MonadFail class here, allowing for a painless long-term transition."
haskell,397k1a,_jk_,2,Tue Jun 9 22:29:32 2015 UTC,"MonadFail is a bad name if its a subclass of Applicative   Why not just call it ""Partial""?"
haskell,397k1a,776865656e,4,Wed Jun 10 02:27:20 2015 UTC,Because it's not. The whole point of fail is to make seemingly-partial binds total for monads like [].
haskell,397k1a,Tekmo,2,Wed Jun 10 02:48:33 2015 UTC,So... OtherwisePartial? :P
haskell,397k1a,sclv,4,Wed Jun 10 02:54:42 2015 UTC,or Failable ?
haskell,397k1a,augustss,1 point,Wed Jun 10 11:04:08 2015 UTC,"That was the one that jumped to mind for me, too."
haskell,397k1a,cliffordbeshers,6,Thu Jun 11 20:20:44 2015 UTC,"Note that this is used not just for fail but also pattern match failures in a bind, like this:  do Just foo <- m    ...   This will (I think) desugar to:  do x   <- m    foo <- case x of        Just foo -> return foo        _        -> fail ""Pattern match failure at ...""    ..."
haskell,397k1a,cliffordbeshers,10,Tue Jun 9 22:23:34 2015 UTC,"<- desugars via  do pat <- computation     >>>     let f pat = more    more                   >>>         f _ = fail ""...""                           >>>     in  computation >>= f"
haskell,397k1a,yitz,20,Tue Jun 9 22:28:20 2015 UTC,Huge +1 on this from me.
haskell,397k1a,ForTheFunctionGod,20,Tue Jun 9 21:23:53 2015 UTC,I'd argue for no transition. Just make a breaking change. I predict it will affect very few packages.
haskell,397k1a,hsenag,4,Tue Jun 9 23:07:52 2015 UTC,"An addendum to the post suggests you are correct.    2015-06-09: Estimated breakage by compiling Stackage. Smaller than expected.   Given the multiplicity of building software capable of building all packages in a reasonable time, I would suggest a graph of build failures should be our goal for these proposals, rather than educated guesses."
haskell,397k1a,ForTheFunctionGod,5,Wed Jun 10 15:38:23 2015 UTC,"I amended the post with a console command to show the list of packages that would break because of bad desugaring. Note that this may contain false positives, so it's an upper bound. The cleaned up output is:  cabal-src, control-monad-free, dns, doctest, easy-file, fgl, generic-aeson, gitlib-test, haskell-src-exts, heist, hflags, hledger-web, HUnit, jose-jwt, language-java, libgit, mime-mail, MissingH, mongoDB, neat-interpolation, network-multicast, network-simple, pager, pandoc-citeproc, persistent-template, pipes-safe, rethinkdb-client-driver, shell-conduit, singletons, socket-io, Spock, stackage-setup, stackage-update, stackage-upload, streaming-commons, th-desugar, x509-system, xenstore, xmlhtml, yesod-auth-oauth, yesod-gitrepo, yesod-static"
haskell,397k1a,hsenag,5,Wed Jun 10 17:11:37 2015 UTC,That's really great to see.  Thank you.
haskell,397k1a,776865656e,10,Wed Jun 10 21:20:53 2015 UTC,I am +1 on this. But there is an additional cost that isn't covered in the proposal:  This change introduces yet another magical typeclass into the desugaring process. How does it interact with RebindableSyntax and MonadComprehensions?
haskell,397k1a,edwardkmett,8,Tue Jun 9 22:30:04 2015 UTC,"Concerning monad comprehensions see my other comment, http://www.reddit.com/r/haskell/comments/397k1a/monadfail_proposal_mfp_moving_fail_out_of_monad/cs14nd1  RebindableSyntax should be orthogonal to the change; we literally insert the new fail instead of the old fail in a desugaring step and the rest follows automatically. That said, I have not investigated this yet, so I can only guess what I said from the source that I've read."
haskell,397k1a,heisenbug,6,Tue Jun 9 22:49:30 2015 UTC,"I'm for this in spirit, but against it in its current form, because the error can only be a String. I'd say that using MonadThrow, which has throwM :: Exception e => e -> m a, would be much better, as it allows the throwing of arbitrary errors.  The fundamental question is this: what is the error message supposed to signal and who is supposed to consume it? I argue that as far as the program is concerned, it doesn't signal anything specific, because the overwhelming majority of programs won't parse error messages. As far as they are concerned, there's only one way to fail, and the String is only there for fluff, which   fail _ = mzero   acknowledges.   This begs the question of who is supposed to read it. I'd say ""only the programmer"".   The String might help error reporting and debugging.   It's fine if a programmer sees some error during testing, but as /u/heisenbug said, fail != error. Operations like parsing can fail in non-fatal ways and it's not fair to throw some non-localizable, beep-boop-error message into the end user's face if that happens. If one instead used ParsingException Line Column ..., one  could present that in a friendly way, and the Show-instance would still be there as a fall-back.  Lastly, you could have a failS :: String -> m a for the lazy, defined as something like  newtype MonadException = MonadException String  failS :: MonadThrow m => String -> m a failS = fail . MonadException   You probably thought about this more than I have, but to me, it seems that using Exceptions instead of String wouldn't result in any more breakage, nor in any more complexity (due to failS), but would bring in all the benefits of full-fledged exception-handling."
haskell,397k1a,edwardkmett,4,Wed Jun 10 03:12:48 2015 UTC,"In fail as it stands now, the String argument is primarily so that the compiler can insert the pattern-match error messages when it desugars a partial pattern.  Any code using fail directly can already switch to something better.  I agree there's a case for making the errors richer, but I think it would be better to do that later, instead of tangling it up with the current proposal."
haskell,397k1a,ForTheFunctionGod,3,Wed Jun 10 06:53:31 2015 UTC,"I have to agree strings are fine for pattern-matching failures alone, but my comment was motivated by my belief that meaningful exception types would be the right thing to do™, as written here. The pattern-match-functionality could easily be subsumed by inserting throwM PatternMatchException or throwM (PatternMatchException ""Pattern match failure at...) instead of fail ""Pattern match failure at..., but, in addition to that, exceptions would provide a powerful and generally useful failure mechanism. Nothing would be lost and a lot would be gained.  I suppose including a portion of mtl into base would be an issue, but if Data.Traversable and Data.Foldable made it in, we might as well bite the bullet in this case too."
haskell,397k1a,edwardkmett,2,Wed Jun 10 07:43:33 2015 UTC,"For what it's worth, you can always define MonadFail instances in terms of MonadThrow yourself. It won't help with other people's code though."
haskell,397k1a,ForTheFunctionGod,1 point,Wed Jun 10 08:51:54 2015 UTC,With OverloadedStrings you could even avoid the additional PatternMatchException constructor
haskell,397k1a,edwardkmett,6,Thu Jun 11 20:24:27 2015 UTC,"The very big downside of this is you now can't admit handling just this simple String case, you have to worry that they can throw anything they want. You open the barn door wide by broadening scope to an arbitrary exception.  With MonadFail you could work with something isomorphic to Either String. With MonadThrow it internally winds up using a GADT, Typeable, an Exception instance, etc. and you get more stuff coming along for the ride."
haskell,397k1a,hastor,2,Wed Jun 10 11:08:38 2015 UTC,"Why not have  class FailInfo i where failInfo :: i -> String instance FailInfo String where failInfo = id class ... => MonadFail m where    fail :: FailInfo i => i -> m a   Probably answering my own question: this only allows us to interpret the info as a string, other methods in FailInfo would be needed to extract other aspects."
haskell,397k1a,chrisdoner,2,Wed Jun 10 11:29:19 2015 UTC,"With that every invocation of ""fail"" in a module with {-# LANGUAGE OverloadedStrings #-} turned on blows up.  I'd have no objection to adding a more robust method to the MonadFail class that included whatever members you wanted about the location of the error, though."
haskell,397k1a,hvr_,2,Wed Jun 10 11:59:02 2015 UTC,"With MonadThrow it internally winds up using a GADT, Typeable, an Exception instance, etc.   That is true, but is it really so bad? throwM doesn't such much add a burden as a capability: the only way of handling a String is to show it; with arbitrary exceptions, you retain that capability, and gain the ability to do specialized handling of different kinds of errors, if you want.  On the other hand, I admittedly don't know what sort of costs are associated with GADTs. Would there be other, unintended side-effects?"
haskell,397k1a,ForTheFunctionGod,2,Wed Jun 10 11:40:20 2015 UTC,"And now to define how throwM works in a language standard you need to add all of this machinery to the language standard.  That is a lot of work.  And fail will be part of the language standard as it sits front and center in do-desugaring.  My point here is this, you're requiring a larger type, and we have no way to really standardize the functionality you want. Each one of those would give me pause, but the combination largely kills the suggestion for me."
haskell,397k1a,Taladar,2,Wed Jun 10 11:49:03 2015 UTC,"And now to define how throwM works in a language standard you need to add all of this machinery to the language standard.   All right, I now see the seriousness of that issue. I had just naively read & compared the types of fail and throwM, without considering their respective statuses as part of the language spec and a library function. Thanks for enlightening me :)"
haskell,397k1a,stepcut251,2,Wed Jun 10 12:10:56 2015 UTC,"That said, I think there is definitely room in this proposal to add another member to the MonadFail class that takes more information about the location of the pattern match failure, and to give that a default implementation in terms of fail, so if you want more structure for that one exception it can be done in a nicely standardizable form."
haskell,397k1a,RedLambda,0,Wed Jun 10 12:15:13 2015 UTC,"If this is the major complaint, why not call this class DeprecatedMonadFail right away?"
haskell,397k1a,zz_h,2,Wed Jun 10 21:46:32 2015 UTC,"The very big downside of this is you now can't admit handling just this simple String case, you have to worry that they can throw anything they want.   A string is anything. You're just shifting the meaning of the failure from compile-time to run-time."
haskell,397k1a,tel,3,Wed Jun 10 11:41:48 2015 UTC,"It's an interesting suggestion, but you'd lose the ability to locally outlaw failable patterns in do-notation. I.e. let's assume that you want to use throwM in your do-body, but forbid failable patterns. Merging the MonadFail concern into the MonadThrow  class would take away that possibility."
haskell,397k1a,manjunaths,2,Wed Jun 10 11:05:53 2015 UTC,"Do you mean that MonadFail should receive special handling during the do-desugaring, i.e. if you had a function like  f :: (Monad m, MonadFail m) => m (Maybe Int) -> m Int f x = do (Just x') <- x -- failable pattern              if x < 0 then fail ""x shouldn't be negative!""              else return (x*2)   and switched on a {-# LANGUAGE NoFailablePatterns #-} pragma, then the first line would generate an error, while the second one wouldn't? If so, I do see your point. It probably would be odd if MonadThrow with its throwM in lieu of fail received that sort of special treatment too.  (Apologies if I understood you completely incorrectly.)"
haskell,397k1a,tel,3,Wed Jun 10 12:05:58 2015 UTC,I think the idea was that a separate MonadFail would allow you to remove it from the context of the function containing the do notation to outlaw failable patterns and explicit fail calls without affecting unrelated throwM calls.
haskell,397k1a,manjunaths,11,Wed Jun 10 17:36:53 2015 UTC,"Hold on a second.. I thought the single most ugly thing in Haskell was Num and the rest of the numerical hierarchy.  Other than that, I approve."
haskell,397k1a,PokerPirate,5,Wed Jun 10 00:46:07 2015 UTC,...is there a top 10 list of most ugly things in Haskell? =)
haskell,397k1a,sambocyn,5,Wed Jun 10 07:03:54 2015 UTC,Newbie here. What's ugly about Num?
haskell,397k1a,tomejaguar,12,Wed Jun 10 07:47:24 2015 UTC,"Many would prefer to build a more stratified numeric hierarchy atop things like monoid and ring and field. The current system is fairly ad hoc and is based on very informal laws instead of the existing, highly tested numerical hierarchy from abstract algebra. The upshot is that there are a lot of instances floating around of ""Num-like enough"" things which are at best poorly described by the current Num class"
haskell,397k1a,nosewings,6,Wed Jun 10 08:43:28 2015 UTC,highly tested numerical hierarchy from abstract algebra.   Where can I find this ?
haskell,397k1a,edwardkmett,6,Wed Jun 10 13:51:37 2015 UTC,"Sadly: in math books. I think there are a few packages which try to do it in Hackage, but no consensus on how to translate it to Haskell.  If you're interested in learning more (from a math book) then I recommend the following one: http://homepages.math.uic.edu/~acamer4/aluffi.pdf"
haskell,397k1a,Taladar,1 point,Wed Jun 10 15:05:14 2015 UTC,Interesting...thank you.
haskell,397k1a,edwardkmett,3,Wed Jun 10 15:25:27 2015 UTC,You can find a Haskell implementation of this more complex class hierarchy at: https://github.com/mikeizbicki/subhask/blob/master/src/SubHask/Algebra.hs
haskell,397k1a,RedLambda,1 point,Wed Jun 10 19:06:04 2015 UTC,"would proposals support integer literals distinguishing between negative and positive and stuff.  like being able to safely write (0 :: Natural) would be cool. while (-1 :: Natural) becomes a type error like ""no instance for Ring Natural"" or something)."
haskell,397k1a,chrisdoner,1 point,Wed Jun 10 21:22:04 2015 UTC,"Num is ugly, but as far as I know we don't know a better solution. There is always some important type that breaks the laws should we go for a principled approach (floats typically), and fragmenting the classes into a large hierarchy is not really enjoyable to work with either."
haskell,397k1a,edwardkmett,7,Thu Jun 11 21:02:52 2015 UTC,"Why should MonadFail have any superclass at all?  Functor f => MonadFail f appears to make a bit of sense, at least."
haskell,397k1a,chrisdoner,6,Tue Jun 9 22:35:00 2015 UTC,"If we don't give it a superclass we'll end up with a strange Pointed class, which seems to be universally hated due to its lack of laws.  Putting a superclass constraint on MonadFail allows us to assert certain laws when interacting with the super-functions, and narrow down the use case to be pretty precise."
haskell,397k1a,edwardkmett,10,Tue Jun 9 22:46:57 2015 UTC,I honestly don't understand the hate for Pointed.
haskell,397k1a,hvr_,10,Wed Jun 10 02:52:14 2015 UTC,"Pointed gives me no laws to play with that aren't a free theorem.  On the other hand, if I have something like Semiapplicative (called Apply in my semigroupoids package) with just (<*>) in it, I at least get an associativity law. This is quite useful and I can point to many nice instances of it.  e.g. IntMap is Semiapplicative in this manner as are many comonads. (IntMap is also a semimonad with a useful (>>=).)  Then Pointed gives you a pure like function... but no guarantee that it is compatible with (<*>) from Semiapplicative.  So now you need to get a new class who only exists to provide a pair of unit laws: Applicative  But this doesn't work out as cleanly as you'd like. When you use the two combinators pure and (<*>) you infer a weaker type, which is (Pointed m, Semiapplicative m) => ... which is basically never what you want, because the law is central to ensuring the uniqueness of almost every single combinator you can write involving Applicative, so now the types you infer will wind up being weaker than the types you actually mean.  Moreover, people generally don't like to build classes with just laws, and they often don't like to do so for a reason. If you have a class that 'just gives you a law' it means that the default definitions in your superclasses can't take advantage of those laws.  So, if we have to choose between Semiapplicative and Pointed, I'll pick Semiapplicative every time. Mathematicians don't usually start with a set build a pointed set and then add an associative operation with that point as its unit. They usually start with an associative operation and then extend it by telling you its unit if it has one.  The main issue with Pointed is that beyond a couple of lens use cases every use case someone has ever given me has involved completely ad hoc instance-by-instance reasoning. e.g. foldMap point is basically so much nonsense. It mashes together things using a pointed structure and a monoid that have no reason to be at all consistent with each other. At first it seems consistent: it can build a Set element by element, build a list element by element, etc. but it can also mean to build a Maybe by smashing together the Justs with a semigroup! Wat."
haskell,397k1a,edwardkmett,4,Wed Jun 10 11:19:05 2015 UTC,"Then Pointed gives you a pure like function... but no guarantee that it is compatible with (<*>) from Semiapplicative.  If you have a class that 'just gives you a law' it means that the default definitions in your superclasses can't take advantage of those laws.   All of this sounds to me as if we might need a better way to represent the several possible instances of many type classes in Haskell, at least for those type classes that aren't usually unique.   Mathematicians don't usually start with a set build a pointed set and then add an associative operation with that point as its unit. They usually start with an associative operation and then extend it by telling you its unit if it has one.   Could we somehow encode this relationship between the operation and the unit into a class too? In something of the complexity of a mathematical Ring (two binary operations, each with its own requirements and some laws spanning both) we would end up with a tree-like structure, one subtree for each binary operation and its associated laws, unit,.. This feels like there is some expressive power missing in type classes since we can not encode the full mathematical structure in Haskell.  Perhaps a way to encode expected laws into the code would also be helpful, maybe even with the option of running a quickspec style smoke test on them at compile time to weed out the most blatantly law breaking instances."
haskell,397k1a,hvr_,6,Wed Jun 10 17:33:58 2015 UTC,"The issue is more that you're going to incur a bunch of constraints that aren't sufficient constraints for the operation to be fundamental. You can of course 'check' a type that incurs the extra constraints that you use in the meta-theory to justify the canonical nature of a structure, but it'll infer type that is too general.  This would happen even if we gave up on typeclasses and went with implicits like everyone else."
haskell,397k1a,conklech,5,Wed Jun 10 19:25:28 2015 UTC,"I guess it's mostly about the bad power-to-weight ratio that comes with it. If it's to be a superclass, for every Applicative or Monad you also need to define Pointed instances, adding boilerplate. If, however, we had implemented one of the proposed implicit/automatic superclass sugar... so that you'd e.g. automatically get an Pointed instance when you define an Applicative instance (and no Pointed is in scope), I guess there would be less hate..."
haskell,397k1a,ibotty,9,Wed Jun 10 06:56:49 2015 UTC,What about MonadThrow?   https://hackage.haskell.org/package/exceptions-0.6.1/docs/Control-Monad-Catch.html#t:MonadThrow  I'd rather fail just get removed or be deprecated entirely.
haskell,397k1a,ForTheFunctionGod,4,Wed Jun 10 00:55:11 2015 UTC,"This requires admitting all exceptions, rather than just the single String, invoking much heavier language extensions. If we're looking for something potentially standardizable for a Haskell language standard we need to keep that in mind. Extensible exceptions will be very very hard to standardize. None of the extensions they require are standardized today."
haskell,397k1a,drb226,3,Wed Jun 10 11:10:33 2015 UTC,"If the language standard's main purpose is to be old and not keep up with de facto standard Haskell that everybody uses in practice, it seems to have little worth, to me. I understand the desire to adjust a solution to fit into the Haskell 2010 mold but if that mold is kind of crappy (string exceptions? seriously?) and not what people write in industry, I have to wonder: what are we doing here? (We're not the Common Lisp community, at least, whose spec hasn't changed since 1994.)  But it's better than what's currently in Prelude, so at least there's that."
haskell,397k1a,chrisdoner,11,Wed Jun 10 11:33:46 2015 UTC,"I think the language standard could stand to evolve faster than it has, but I do think there is merit in having both the advancing wave of current techniques that thrashes all over the place and a steadily advancing standard behind it.  Putting something into the language in such a central place that fundamentally gets in the way of that strikes me as a poor trade-off. It cuts off that standard ever being useful and you win nothing or very little in exchange in this particular situation.  All of the Foldable/Traversable, AMP, removal of Eq, Show as a superclass of Num, FiniteBits, etc. changes that we've moved into base have been made with an eye towards the fact that the little cottage industry of Haskell compiler writers out there can comply with those changes should we get around to reviving the language standards process, and all of them are more ""in the wings"" of the language than playing with the desugaring of do."
haskell,397k1a,heisenbug,9,Wed Jun 10 11:45:35 2015 UTC,"should we get around to reviving the language standards process   Just for the record, here's a shy attempt (moving slowly) at trying to update the report:  https://github.com/hvr/haskell-report/commits/hvr/h201x"
haskell,397k1a,AshleyYakeley,8,Wed Jun 10 11:50:12 2015 UTC,Have I told you lately that I love you?
haskell,397k1a,heisenbug,5,Wed Jun 10 11:51:40 2015 UTC,Not nearly enough ;-)
haskell,397k1a,theonlycosmonaut,6,Wed Jun 10 18:26:38 2015 UTC,"I view the standard as an important and under-appreciated bit of educational documentation. An important turning point in my Haskell education was when I started looking to the Report when I wasn't sure how something worked. The syntactic distinction between let and where, for instance, eluded me until I consulted the formal rules.  A lot of the other Haskell documentation is written incrementally for people who are following along. For instance, the GHC docs for extensions generally describe how they change things. This poses the challenge of understanding both the ""standard"" and ""extended"" behavior. Things like RankNTypes would benefit from a neutral standardization along the lines of the Report."
haskell,397k1a,alexeyr,2,Wed Jun 10 15:40:39 2015 UTC,"That does not really make sense for [], does it? Maybe I am missing things..."
haskell,397k1a,ignorantone,6,Wed Jun 10 06:58:42 2015 UTC,"I thought so too, but from hackage:  instance  Monad []  where     fail _              = []  instance MonadThrow [] where    throwM _ = []   The only monad which actually reports the error message is IO. Others just resort to whatever default case they have."
haskell,397k1a,hvr_,2,Wed Jun 10 10:43:01 2015 UTC,"There is also  instance e ~ SomeException => MonadThrow (Either e) where   throwM = Left . toException   Weirdly, the ErrorT and and ExceptT transformers do not have a similar instance; they instead prefer throwing exceptions to their inner monad."
haskell,397k1a,gaymenonaboat,5,Wed Jun 10 16:39:23 2015 UTC,"I use MonadThrow in IO, [], Maybe, Either, etc. It depends what kind of sense you're looking for."
haskell,3983r1,Spewface,23,Tue Jun 9 22:58:24 2015 UTC,"One of the reasons I love Haskell too! Unfortunately, my ad hoc testing makes me sad. This snippet   module Main where  import Data.List  main :: IO () main = putStrLn $ show $ (sort $ permutations $ [0..9]) !! 999999   consistently used 1.5 GB of RAM on my 4 GB machine and ran always above 18+ real seconds according to time no matter what optimisation level used (GHC 7.10.1).  On the other hand, using Python 3.4 and this snippet  from itertools import permutations  if __name__ == '__main__':     print(sorted(permutations(range(10)))[999999])   I consistently got under 4 seconds with time and less than 500 MB of RAM. Note that itertools is part of the standard library and is designed to work efficiently with iterators such as range.  What I'm trying to say is that I'm sad that the naïve approach is so much faster in Python. It makes me wonder how much efficiency is lost by using the most visible things in Haskell."
haskell,3983r1,truth_is_an_opinion,8,Tue Jun 9 23:47:47 2015 UTC,"You can speed it up by more than ten times by constructing the permutations in order so you don't need to sort.  More code than the original but arguably more elegant (and no mutation required).  module Main where  main :: IO () main = print (perms [1..10 :: Int] !! 999999)  perms :: [a] -> [[a]] perms [] = [[]] perms xs = concatMap go (eachWithRest xs)   where     go (y, ys) = map (y:) (perms ys)  eachWithRest :: [a] -> [(a, [a])] eachWithRest [] = [] eachWithRest (x:xs) = (x, xs):[(y, x:ys) | (y, ys) <- eachWithRest xs]"
haskell,3983r1,djfletch,9,Wed Jun 10 17:03:22 2015 UTC,I get 0.08s with this:  import Data.Permute.IO import Control.Monad  main :: IO () main = do     p <- newPermute 10     replicateM_ 999999 (setNext p)     freeze p >>= print
haskell,3983r1,toujw,7,Wed Jun 10 03:19:23 2015 UTC,"Which is fast, but pretty un-Haskelly :( It's a real shame that often to get the real speed, we have to start working with mutation."
haskell,3983r1,ocharles,8,Wed Jun 10 11:10:36 2015 UTC,The un-Haskellness of it bothers me too. If we use the immutable type from the package we get something more Haskelly that runs in 0.3s on my laptop:  main = print $ elems $ go (permute 10) 999999   where go p 0 = p         go p n = go (fromJust $ next p) (n-1)   We can also use the ST monad instead of IO and get purity with the same speed of the IO version:  main = print $ elems $ runSTPermute $ do     p <- newPermute 10     replicateM_ 999999 (setNext p)     return p
haskell,3983r1,toujw,6,Wed Jun 10 15:05:45 2015 UTC,mapM_ (const f) [1..x] -> replicateM_ x f
haskell,3983r1,MitchellSalad,5,Wed Jun 10 05:13:39 2015 UTC,"This doesn't seem to sort the permutations. If you don't sort, the original solution is very fast as well."
haskell,3983r1,edvo,1 point,Wed Jun 10 12:25:45 2015 UTC,"I agree, this one sorts too:  module Main where  import           Data.Permute import           Data.List as L import           Data.Text (Text) import qualified Data.Text as T  main :: IO () main = print . flip (!!) 999999 . L.sort . perms . Just . permute $ 10  perms :: Maybe Permute -> [Text] perms Nothing  = [] perms (Just p) = toText p : perms (next p)   where     toText = T.concat . map (T.pack . show) . elems   Takes 6 seconds in my laptop."
haskell,3983r1,clrnd,3,Wed Jun 10 21:30:40 2015 UTC,"I'd imagine that this difference is because in python, the sort is working on the list as if it were a list of integers, not a list of lists of integers.  Once you do this conversion, the compare operator suddenly becomes significantly more efficient and lots of pointers can get thrown away.    when I run the naive approach with Haskell (with O3), I get 8 seconds and 1.5 gigs, and when i run the following, I get 4 seconds and 480mb.  main = print $ sort (toInt <$> permutations [0..9]) !! 999999  toInt l = toIntR $ reverse l   where toIntR [] = 0             toIntR (a:l) = a + 10 * (toIntR l)"
haskell,3983r1,mmirman,2,Thu Jun 11 00:12:42 2015 UTC,"Dang it ._.  I'll try and make a vector implementation, to see if it can get better"
haskell,3983r1,globules,11,Wed Jun 10 00:32:25 2015 UTC,"Well, since the title already says spoiler...  import Data.List  perm :: [Int] -> Int -> [Int] perm [] _ = [] perm xs n = let (q, r) = n `quotRem` product [1..length xs - 1]                 x = xs !! q             in x : perm (delete x xs) r  main :: IO () main = print $ perm [0..9] 999999   Running it in ghci:  λ> :set +s λ> :main [2,7,8,3,9,1,5,4,6,0] (0.00 secs, 518168 bytes) λ>"
haskell,3983r1,globules,1 point,Thu Jun 11 04:26:27 2015 UTC,O_O  I... I think I'm gonna go home and rethink my life.
haskell,3983r1,addition,3,Thu Jun 11 14:39:29 2015 UTC,"It does seem a bit magical when you first look at it.  However, it becomes clearer when you work through an example and consider the properties of permutations in lexicographic order.  Here are the permuations of abcd in lexicographic order.  We want to find the particular permutation at position 11 (counting from 0).   0  abcd  1  abdc  2  acbd  3  acdb  4  adbc  5  adcb  6  bacd  7  badc  8  bcad  9  bcda 10  bdac 11  bdca  <-- posn. 11 in perms of abcd; posn. 5 in perms of acd; ... 12  cabd 13  cadb 14  cbad 15  cbda 16  cdab 17  cdba 18  dabc 19  dacb 20  dbac 21  dbca 22  dcab 23  dcba   Notice that the first letters of the permutations are in lexicographic order: a group of 6 = 3! = (4-1)! 'a's, followed by the same number of 'b's and so on. The size of the groups is determined by the number of permutations on 3 letters.  So, in order to find the first letter at position 11 we divide 11 by (4-1)! giving 1 with a remainder of 5.  This tells us that the permutation we want is in the second group of 6 (counting from 0), so the first letter of our permutation is the one at position 1 (also counting from 0) of abcd (i.e. b).  Also notice that when we strip off the first letter of a group of permutations we're left with all the permutation of the remaining letters, also in lexicographic order.  In our case, after removing the leading b we have:  0  acd 1  adc 2  cad 3  cda 4  dac 5  dca  <-- posn. 5 in perms of acd; posn. 1 in perms of ac; ...   The remainder we calculated above tells us that we're at position 5 in the list of these permutations.  We're trying to solve exactly the same problem, but with a smaller list (i.e. with b removed).  This time around we divide 5 by (3-1)! = 2 giving us 2 with a remainder of 1.  This means our next letter is at position 2 of acd (i.e. 'd').  We keep doing this until our list is empty."
haskell,3983r1,Magnap,1 point,Sat Jun 13 04:06:20 2015 UTC,You are one smart cookie.
haskell,3983r1,hvr_,1 point,Sun Jun 14 13:42:15 2015 UTC,"Congratulations on making a solution that actually follows the spirit, not just the letter, of Project Euler."
haskell,3983r1,kamatsu,9,Sat Jul 4 17:35:11 2015 UTC,"While a nice one liner, I don't think that solution is in the spirit of the Project Euler problem... :-)"
haskell,3983r1,tsahyt,7,Wed Jun 10 11:43:53 2015 UTC,Some unnecessary punctuation there:  sort (permutations [0..9]) !! 999999
haskell,3983r1,Peaker,9,Wed Jun 10 03:55:05 2015 UTC,"I first realised how incredibly flexible Haskell is syntactically, when I learned how to write parsers with it. Having written parsers in C before and a compiler in Java, I've come to consider writing parsers painful. In Haskell my parsers basically look like annotated grammars. It's amazing how concise it is. Thanks to monadic parsing (and generally the monad abstraction) I managed to design and implement a medium sized domain specific language in a work week in Haskell. The productivity boost this language provides at times is almost unreal."
haskell,3983r1,sjoerd_visscher,7,Wed Jun 10 09:08:00 2015 UTC,"Monadic parsing is overkill -- requiring either backtracking or unmodular parser compositions.  If we have:  parseA <|> parseB   And both of these have a common prefix, we pay a big performance penalty (or we'll also need to try to explicitly backtrack).  The ""solution"" is to extract the common prefix outside like:  prefix >> (suffixA <|> suffixB)   But this breaks modularity! The common prefix between those two parsers is coincidental, could come from different software modules, and should not necessarily even be exposed.  If we had good Applicative parsing instead, we could have our parser pre-compiled into an efficient DFA with better error messages, no need for backtracking, etc.  Sure, Applicative parsers cannot do everything monadic ones can. But IME most parsers don't really need that power. Or if they do, it can often be layered as an extra parsing step after the main Applicative parser.  Only question is, where are the nice pre-compiling Applicative parsers? Why do we only have so many Monadic ones?"
haskell,3983r1,tsahyt,1 point,Wed Jun 10 21:51:43 2015 UTC,"There's https://hackage.haskell.org/package/uu-parsinglib, but I think there are more."
haskell,3983r1,bstamour,1 point,Thu Jun 11 13:01:01 2015 UTC,Write a parser for C++ :D
haskell,3983r1,mstksg,2,Wed Jun 10 23:50:38 2015 UTC,"Eh, maybe I'll have time to write a tiny C compiler in Haskell one day, but I'll continue to stay away from C++ if I can. I can only imagine how horrible it would be to write a parser for it, considering that there are some weird features in the syntax of the language that only exist to make it parseable in the first place (like the required space after nested template <..> brackets). Actually this just made me curious, and I found this PhD thesis (via StackOverflow). On page 147 it states   The C++ grammar is ambiguous, context-dependent, and potentially requires infinite lookahead to resolve some ambiguities   int(x), y, *const z;  // int x; int y; int *const z;   Is a comma-separated list of declarations in which the first is redundantly parenthesised, whereas changing the final list element:   int(x), y, new int;   // ((int(x)), (y), (new int));   gives a list of expressions, the first two of which are redundant, and the third causes a memory leak.   shivers... C++ is the stuff my nightmares are made of."
haskell,3983r1,mstksg,2,Thu Jun 11 09:10:49 2015 UTC,"like the required space after nested template <..> brackets   This has been fixed in C++11. You should look at C++ again, now that C++11 and C++14 are here. While I won't suggest writing a parser for it, the language has gotten a lot easier to use for everyday programming tasks*.  * What I mean by this is unless you're contributing to the boost libraries, the vast majority of C++'s complexity doesn't tend to be a problem."
haskell,397dag,mightybyte,4,Tue Jun 9 20:00:54 2015 UTC,Thanks for the upload. Loving the improved quality of videos!
haskell,397dag,katychuang,3,Tue Jun 9 20:14:51 2015 UTC,"I really enjoyed the talk. Looking forward to part 2.  I feel it could have been a bit faster paced, and focused more on concrete examples of how X technical decision enables Y useful feature of diagrams. Of course, I come from a graphics background.  To use the opening example, I could tell that aFunction would draw a Sierpiński triangle, but I had to wait to see the better alternative from diagrams. I think the better sequence would have been “Here’s a pretty diagram. It’s called the Sierpiński triangle. Here’s how you express it in Asymptote: (big, ugly code). Here’s how you express it in diagrams: (small, pretty code).”"
haskell,3957e1,chrisdoner,18,Tue Jun 9 09:55:33 2015 UTC,Reminds me a bit of https://halcyon.sh/. Is there an overlap or is Stack addressing a totally different problem?
haskell,3957e1,RedLambda,12,Tue Jun 9 10:13:54 2015 UTC,"Halcyon's focus is specifically on the deployment stage of the project life cycle, Stack's focus is specifically on the development stage. It's interested in the iterative source-level hacking, getting dependencies on demand, Docker support, things like that. There's some overlap here and there (e.g. helping with installing GHC automatically), but developing with Stack and then deploying with Halcyon is a perfectly reasonable workflow."
haskell,3957e1,myetech,24,Tue Jun 9 10:57:02 2015 UTC,"Halcyon author here. It seems to me there is quite a bit of overlap between the two tools. The main difference appears to be that Stack attempts to replace cabal-install, while Halcyon builds on top of it."
haskell,3957e1,codygman,5,Tue Jun 9 12:07:46 2015 UTC,"I also thought that Halcyon was more focused on deployment rather than development. Is this how you develop with Halcyon? Can you perhaps detail your development process?  I installed Halcyon on my girlfriends mac and went through the tutorial a bit ago. I got stuck when I couldn't figure out how to start a repl while following the tutorial. Perhaps you could add a ""developing"" section like this to the tutorial?"
haskell,3957e1,drb226,4,Tue Jun 9 21:06:17 2015 UTC,"Is it fair to say that Halcyon does attempt to provide a point of abstraction where the user doesn't need to use or think about cabal-install? In that sense, would it be fair to say cabal-install is just an implementation detail of Halcyon?"
haskell,3957e1,myetech,18,Tue Jun 9 15:12:36 2015 UTC,"With Halcyon, I’ve tried to augment the capabilities of cabal-install, while remaining compatible with it.  My goal has always been to show people a concrete vision of how Cabal could be improved, with the eventual goal of merging these improvements into Cabal. [1] [2] [3] [4] [5] [6] [7] [8]  For example, you can use Halcyon to install GHC and cabal-install — and stop there.  You can then continue using these tools as you’ve always had.  Or, you can go one step further, and also use Halcyon to build a Cabal sandbox for your project.  Once you’ve done that, you can tell cabal-install to use this sandbox, and get back to your regular workflow.  Finally, you can also use Halcyon to build your entire project — whether on a development machine, on a continuous integration server, or on the deployment target — as thoughtbot showed in “Building Haskell Projects with Halcyon”.  At all stages of the process, Halcyon makes use of openly-available infrastructure.  You are never locked into depending on a service provided by any single company, including my own."
haskell,3957e1,chreekat,5,Tue Jun 9 15:51:46 2015 UTC,"fwiw, all of the infrastructure for stack is free/open source. Early on I heard it stated that one goal was to not lock anyone to any particular infrastructure."
haskell,3957e1,myetech,11,Tue Jun 9 16:38:50 2015 UTC,"With Halcyon, you can use any Cabal package repository, including Hackage, Stackage, or a repository that you host yourself. It seems to me Stack uses Stackage snapshots to resolve package dependencies. Can you use Stack without depending on Stackage?"
haskell,3957e1,chreekat,7,Tue Jun 9 17:50:12 2015 UTC,Looks to be in progress.
haskell,3957e1,drb226,2,Tue Jun 9 18:29:14 2015 UTC,"The intention is that yes, you can use Stack without depending on stackage.org. I think there are some spots that still have particular stackage repositories hardcoded in, because Stack has undergone heavy/rapid development lately. But the plan is that each component is open source, and should be replaceable by your own thing if you want."
haskell,3957e1,andrewthad,15,Wed Jun 10 06:03:13 2015 UTC,"This looks really helpful. I'm trying this out right now at work. In thirty more minutes, I will know for sure if it's helpful.\  UPDATE: Now that I've been using this for two hours, I can say that I'm really pleased with it. The close integration with stackage LTS fits my workflow very well, and I'm pretty excited about not having to rebuild the whole sandbox every time I start a new application. For web application development at my office, I consider stack a serious contender to cabal-install. Can't wait to see the future of it."
haskell,3957e1,fruitbooploops,0,Tue Jun 9 12:50:58 2015 UTC,"I'm sorry but I can't figure out how this is useful? Seriously... What does this do that cabal install doesn't, besides download ghc (which I've already downloaded lol)?"
haskell,3957e1,_AndrewC_,2,Wed Jun 10 13:07:42 2015 UTC,"Two important things it does are 1. base your packages on stackage LTS (Long Term Support) by default, which means all the package versions are compatible, avoiding ""cabal hell"" where you can't install packages, and 2. make 3 layers of packages: a few core ones, then the stackage set, then your added ones for a particular project on the top in a ""sandbox"", preventing them version-clashing with ones from other projects, avoiding ""cabal hell"". It automates a lot of things for you so you don't have to (learn to and) remember to do all that manually."
haskell,3957e1,fruitbooploops,1 point,Thu Jun 11 05:30:10 2015 UTC,That's great! Now if they can get it to work with the Haskell IntelliJ plugin I'll be totally sold!
haskell,3957e1,drb226,16,Thu Jun 11 06:03:26 2015 UTC,"Note that stack neatly answers the problem with curation by allowing you to override stackage snapshot dependencies via the ""extra-deps"" section of your project's stack.yaml. See the FAQ for details.   Using stackage locks down your dependency bounds to a single version.   Not anymore! Well, using stack does lock your dependency bounds to a single version, but now you get to choose which version, instead of being stuck with the stackage version. If you don't want to bother choosing for every single dependency, you can go with the default: stackage versions of things which are known to work together.  It's all the convenience and safety of curation, with the flexibility to make appropriate deviations for your project."
haskell,3957e1,mightybyte,2,Tue Jun 9 14:35:06 2015 UTC,"Note that stack neatly answers the problem with curation   No, it doesn't.  You could already override dependencies before by editing versions in the config file manually.  But that's not good enough because the whole premise locks versions down too much, making it much more prone to not build when one version is changed.  The solution is for people to put correct version bounds on their packages and use cabal."
haskell,3957e1,eegreg,3,Thu Jun 11 03:32:58 2015 UTC,"I think you are confused about what we mean by curation. What you are describing is the normal semantic versioning and dependency specification process that goes on with most software today. And that of course is a good thing that everyone needs to keep doing.  Curation goes beyond that and tests that certain packages work together beyond just the version bounds (for example by building and running the test suites of all versioned packages). This can catch many things that version bounds cannot, for example if one package was relying on buggy behavior of another that got fixed without a type change.  Curation necessarily places restrictions on versions because testing all possible combinations of dependencies takes extra resources. At a minimum it takes time to run tests, so the just released dependencies are always going to have some delay before they end up in a curated collection."
haskell,3957e1,mightybyte,0,Thu Jun 11 05:16:53 2015 UTC,"I think you are confused about what we mean by curation. What you are describing is the normal semantic versioning and dependency specification process that goes on with most software today.   It is actually the other way around.  I am not describing semantic versioning, I am describing the PVP.  Semantic versioning says nothing about the specification of version bounds on dependencies, but the PVP does.   And that of course is a good thing that everyone needs to keep doing.   But the fact of the matter is that stackage advocates tend to not it.  They frequently violate the PVP by not specifying upper bounds on their dependencies.  In fact, I've actually talked to users who told me that they thought they didn't have to specify version bounds because they were using stackage!   Curation goes beyond that and tests that certain packages work together beyond just the version bounds (for example by building and running the test suites of all versioned packages). This can catch many things that version bounds cannot   This distinction usually doesn't matter in practice.  In five years of professional Haskell development I can count on one hand the number of times running tests instead of just checking whether something builds has been an issue with package dependencies from hackage.  But I've been been burned countless times by dependencies with missing version bounds.  Without stackage, test suite failures would still most likely be caught in the normal process of most developers' normal release testing."
haskell,3957e1,LadenSwallow,19,Thu Jun 11 12:39:03 2015 UTC,"This looks really cool, in particular I'm really looking forward to this feature request: Support git repos / http folders in packages stanza, I'm particularly hopeful that it might stop unwanted cruft ending up on hackage."
haskell,3957e1,snoyberg,18,Tue Jun 9 12:48:29 2015 UTC,"Thanks for pointing to that issue. Knowing what features are most important to people helps me and others working on the codebase know what to prioritize. I've bumped the milestone for that issue to the next release and added a comment about how I think we can implement it easily.  EDIT Mini-update: most of this is now implemented on https://github.com/commercialhaskell/stack/compare/199-remote-packages. Just need to add the code for cloning a Git repo.  EDIT2 And it's complete on that branch, just needs testing before being merged to master."
haskell,3957e1,akurilin,13,Tue Jun 9 13:01:22 2015 UTC,Typical snoyberg ;)
haskell,3957e1,_AndrewC_,8,Wed Jun 10 02:51:24 2015 UTC,I don't think it's possible to be more responsive.
haskell,3957e1,LadenSwallow,3,Wed Jun 10 05:52:44 2015 UTC,Thank you very very much. For me this is the killer feature. (Personally I find add-source really inelegant.)
haskell,3957e1,andrewthad,7,Wed Jun 10 07:18:13 2015 UTC,"I just started with stack about an hour ago, and I also feel like this would be an important feature. I am actually about to put a cron-compat package up on hackage (that makes it build with the versions of transformers and mtl that stackage lts 7.8.4 supports), but I think that ultimately, one-off fixes like this are probably better off as github forks. Having stack support that would be good."
haskell,3957e1,cocreature,3,Tue Jun 9 13:28:54 2015 UTC,+1 on that
haskell,3957e1,snoyberg,19,Tue Jun 9 13:49:11 2015 UTC,"Thank you to everyone who has contributed code, ideas, feedback, and bug reports to get us to this state. I just wanted to point out some more useful resources for people looking to get started:   The downloads page has binaries and packages for difference OSes and Linux distros The FAQ answers a bunch of random questions The transition guide is a stub page to help people familiar with other build tools pick up stack The architecture page gives some details on how stack works internally, which would be useful for people looking to do corner-case stuff or work on the deep internals   Also, there's a newcomers label for issues that are easy to get started with, and a discuss label for items that feedback would be especially useful on."
haskell,3957e1,jhedev,6,Tue Jun 9 11:13:21 2015 UTC,Should I open an issue for questions/thoughts regarding wiki content? Or just edit it?
haskell,3957e1,snoyberg,4,Tue Jun 9 12:44:22 2015 UTC,"If you know the content you want to add, just go ahead with it. If you have questions about some things in stack, an issue with the question label would be a great way to ask (or even here on Reddit).  Thank you for contributing!"
haskell,3957e1,jimpeak,8,Tue Jun 9 12:49:22 2015 UTC,"As a haskell newbie on Windows, this is very much welcomed.    It's really easy to get going with Haskell. You can just run stack build in a package directory and it will automatically download and install GHC, the standard Haskell compiler, for you, download the package index and install packages that are needed.   Maybe this is wishful thinking, but are hackage dependencies still built locally or are they downloaded pre-compiled from somewhere (if that is even possible)? I always faced problems when building any postgresql-related packages for example, even after setting up my environment so that all dependencies are available to the build process. This would help a great deal in this kind of scenarios."
haskell,3957e1,snoyberg,11,Tue Jun 9 13:26:42 2015 UTC,"We don't currently do binary downloads of packages, but there's an open issue for it (on my phone, sorry for lack of link). Definitely something to aim for in the future.  In the meantime, the docker support provides all of Stackage precompiled."
haskell,3957e1,acow,5,Tue Jun 9 13:47:09 2015 UTC,"I think we can do it. I've been using my binary cache for Nix stuff hosted on S3 between a couple OS X machines, and it works great. Replicating the Nix hashing isn't trivial, but it is clearly possible."
haskell,3957e1,radix,3,Tue Jun 9 16:18:56 2015 UTC,I think this is the ticket: https://github.com/commercialhaskell/stack/issues/117  This would make CI times a lot faster on Travis!
haskell,3957e1,jkozlowski,10,Tue Jun 9 21:40:33 2015 UTC,Does this deprecate stackage-cli?
haskell,3957e1,drb226,7,Tue Jun 9 13:43:47 2015 UTC,"Basically, yes. See my other comment."
haskell,3957e1,cameleon,7,Tue Jun 9 14:17:20 2015 UTC,"I just tried it out on a multi-package project, and it seem to work well. One thing I ran into was that stack ghci didn't do what I hoped: it just loaded a single file in the repl, using the stack package database. I was hoping it would at least add one of the packages as the input directory, and ideally all of them. That fits with the way I usually develop. I found this issue which is kind of related. Should I add a comment there, file a new issue, or is this comment enough feedback?"
haskell,3957e1,snoyberg,6,Tue Jun 9 13:58:40 2015 UTC,"I definitely think that stack repl issue is the right one. Whether we merge them into one command or keep them separate, the intention is definitely there to load in a package with its source dirs, extensions, autogen files, etc."
haskell,3957e1,cameleon,5,Tue Jun 9 15:55:11 2015 UTC,"Please add a comment to that issue. As you can tell, we have plans to significantly improve stack ghci, we just haven't gotten there yet."
haskell,3957e1,cocreature,2,Tue Jun 9 14:11:35 2015 UTC,Done. Good to hear it's planned!
haskell,3957e1,eegreg,8,Tue Jun 9 14:37:21 2015 UTC,"A few questions and suggestions:   How should add-source dependencies be dealt with? As far as I understand it, adding it to packages won't reinstall on changes. I find it extremely unintuitive that it falls back to lts with no warning. I tried it on a project where I had a too new lens dependency so it chose lts and started downloading ghc-7.8 while I need a nightly snapshot and 7.10. There should be a big warning pointing out that no snapshot matched and also what caused problems and then the snapshot should be chosen by the user instead of defaulting to lts. This seems to make some of the stackage tooling, in particular the sandbox stuff redundant. Should this replace the stackage tooling or what is the relation there? I'd like an option to fix the buildplan to nightly,lts,… when running stack build instead of running it, then cancelling when it does the wrong thing, manually editing the yaml file and rerunning it. Some automation for adding extra-deps matching the constraints in the .cabal file would be nice. Especially with transitive dependencies that gets tedious. Also something that bumps the extra-deps to the latest packages satisfying the contraint.   Overall I am pretty impressed, good job! Thanks for making our life easier."
haskell,3957e1,cocreature,5,Tue Jun 9 14:11:20 2015 UTC,"How should add-source dependencies be dealt with? As far as I understand it, adding it to packages won't reinstall on changes.   Are you sure about that? Maybe you can describe what you are attempting in more detail.   I find it extremely unintuitive ..   Can you open a github issue for that?   This seems to make some of the stackage tooling, in particular the sandbox stuff redundant. Should this replace the stackage tooling or what is the relation there?   Yes, stack contains most of the functionality of the stackage-cli tools and it definitely replaces the stackage sandbox functionality.   I'd like an option to fix the buildplan to nightly,lts,… when running stack build ...   Perhaps a stack init command?   Some automation for adding extra-deps ...   One thing you can do right now when switching to using stack is to first run cabal freeze to get a full working transitive dependency list."
haskell,3957e1,drb226,1 point,Tue Jun 9 14:31:51 2015 UTC,"Oh you are right about the local dependencies, perfect :)  I'll open a github issue for that.  stackage init sounds good.  Thanks for the cabal freeze tip."
haskell,3957e1,bheklilr,10,Tue Jun 9 14:44:18 2015 UTC,"I'd like to note that this tool is the spiritual successor to stackage-sandbox. It uses a conceptually similar but functionally superior technique for sharing package installs that is a lot more flexible and less brittle than stackage-sandbox.  Note that if you want multiple packages to be built against the ""same sandbox"", then just put them all under the same stack.yaml rather than having a separate stack.yaml for each one. Even if you don't, projects using the same LTS version will automatically share their LTS dependencies. The three-tiered package database strategy makes this both safe and effortless."
haskell,3957e1,snoyberg,5,Tue Jun 9 13:35:35 2015 UTC,I tried it out at work and it didn't seem to use the HTTP_PROXY environment variable.  Is this delegated to another sub-tool or is there just no support for it?  For the record cabal works fine behind the proxy.
haskell,3957e1,ndmitchell,7,Tue Jun 9 14:35:26 2015 UTC,"Good catch, can you open an issue? I think this is a simple change to make actually, IIRC we added this support to http-client a while ago."
haskell,3957e1,snoyberg,8,Tue Jun 9 14:38:59 2015 UTC,"And we made it the default, since I predicted that if it wasn't then every app would get big reports one after another :)"
haskell,3957e1,tomejaguar,1 point,Tue Jun 9 17:36:39 2015 UTC,Do you also have the HTTPS_PROXY variable set? stack makes all of its connections securely.
haskell,3957e1,herbadah,5,Thu Jun 11 16:40:38 2015 UTC,"Packages are installed into isolated package databases by default. There is a layering of three package databases: The global database, the snapshot database, and your personal project's database. Many projects can share the same global database (base, bytestring, etc.) and the snapshot database (e.g. text, haskell-src-exts, etc.)—which means no unnecessary rebuilding of packages—and yet each project has its own package database, so they are isolated from each other and cannot break each other.   This is a great idea, but why stop at the project level?  Why not give every package its own database?  This gives us Nix style flexibility without requiring GHC 7.10.  (I have a project where I'm working on this, but it's some way off.)"
haskell,3957e1,snoyberg,9,Tue Jun 9 20:12:43 2015 UTC,Docs?
haskell,3957e1,ndmitchell,3,Tue Jun 9 20:32:23 2015 UTC,"If you're asking ""where are usage docs?"" check out the readme and the wiki on Github. They can definitely use some expansion, which many of us are working on doing.  If you're asking something else, can you clarify?"
haskell,3957e1,snoyberg,4,Wed Jun 10 13:22:59 2015 UTC,"Binary installs of your personal projects are also isolated into that directory.   Does this mean if I install shake locally, and then another package (e.g. hoogle) depends on it, then I will be using my version of shake or the one from Cabal?"
haskell,3957e1,ndmitchell,2,Tue Jun 9 10:26:01 2015 UTC,"When you say ""install shake locally,"" you mean run stack build inside the shake directory? If you do that, then only packages in the same project will have access to that version of shake. If you want to use a locally modified shake in another project, you'd need to reference its source directory in packages inside stack.yaml, otherwise it will download it from the package index and use that copy (i.e., whatever's on Hackage)."
haskell,3957e1,snoyberg,3,Tue Jun 9 10:51:10 2015 UTC,"I do mean run stack build. Is there a way for me to ""force"" my Shake to be the global Shake that everyone picks up? I realise that may be outside the design space."
haskell,3957e1,polux2001,2,Tue Jun 9 10:55:21 2015 UTC,"You can do that by having a package index that contains that modified version and adding it to your list of package indices (search for ""I have a custom package index I'd like to use, how do I do so?"" on the FAQ). But that's not well supported at all right now, especially not for the example you're giving.  I have some ideas (especially tied in with issue 198). With that issue, we could theoretically say ""please use this other package when it's needed, but otherwise ignore it,"" which seems to be the behavior you're looking for. Then the question is whether we allow that value to be set at the global config level instead of just at the project level."
haskell,3957e1,eegreg,4,Tue Jun 9 10:59:53 2015 UTC,"Is it possible to start a new project using stack without ever writing a cabal file? It seems like it isn't, but the documentation still has holes so I'm not sure."
haskell,3957e1,rikvdkleij,3,Wed Jun 10 14:05:19 2015 UTC,"You can run stack ghc, but that only uses dependencies that are installed by stack build. stack uses Cabal (the library) and .cabal files, so stack build won't be able to find a build target to get started with until you have a .cabal file."
haskell,3957e1,hdgarrood,10,Wed Jun 10 19:02:57 2015 UTC,"I wonder why all this effort is not put in cabal-install and ghc-mod. As a Haskell newcomer I suffered a lot from getting up to speed with Haskell it's ecosystem (including ghc-mod) and changes between versions. Of course I can learn yet another tool but it would be nice if the Haskell world would choose one direction. Also with tools for cool IDE support. For example, this issue cost me a lot of time and it is not good for Haskell: https://github.com/kazu-yamamoto/ghc-mod/issues/417  I wrote IntelliJ plugin for Haskell (which depends on cabal (sandbox) and ghc-mod) and encountered a lot of problems."
haskell,3957e1,rikvdkleij,2,Wed Jun 10 08:35:50 2015 UTC,"I think it's quite rude to reply to ""here's a tool that you can have for free"" with ""you should have worked on something else and given us all the results for free, instead"". You're not being forced to use it. It's not up to anyone other than FPComplete themselves to decide what to work on.  As to why a new tool was created instead of working on cabal-install, I would speculate that this may be because cabal-install has been around for a long time and has assumptions baked-in which are no longer appropriate or desirable. For example, sandboxes were only introduced in 1.18. Starting afresh means you have a lot more freedom to design a good user interface without worrying about backwards compatibility."
haskell,3957e1,rikvdkleij,9,Wed Jun 10 12:28:36 2015 UTC,"Sorry, it was not my intention to be rude. It was meant to be a question. Thanks for  your reply."
haskell,3957e1,_AndrewC_,3,Wed Jun 10 13:25:41 2015 UTC,"Hopefully Halcyon, Stack and Cabal-install will benefit from each other."
haskell,3957e1,beerdude26,1 point,Wed Jun 10 13:43:06 2015 UTC,My understanding is that there's a divergence of direction between the cabal team and the stackage team.
haskell,3957e1,vagif,3,Thu Jun 11 11:49:04 2015 UTC,"Here's my first issue already: the URL to the Github issue tracker is incorrect, it should be https://github.com/commercialhaskell/stack/issues :)"
haskell,3957e1,drwebb,6,Tue Jun 9 10:38:27 2015 UTC,"Fixed, thanks. ;-)"
haskell,3957e1,BoteboTsebo,3,Tue Jun 9 10:43:26 2015 UTC,Are there any changes necessary for emacs haskell-mode to work with this? Or would it just transparently work with cabal / ghci just like it does now with sandboxed projects?
haskell,3957e1,BoteboTsebo,4,Tue Jun 9 15:45:45 2015 UTC,"I'm currently using the setup drwebb just mentioned: https://github.com/commercialhaskell/stack/blob/master/.dir-locals.el  stack exec ghci works, though obviously C-c C-c and such still run cabal build, etc. but I'm working on generalizing that so it can run stack build, etc. There is no stack repl yet, but is planned: https://github.com/commercialhaskell/stack/issues/130"
haskell,397on1,gallais,5,Tue Jun 9 21:14:37 2015 UTC,"How does this compare to ""GADTs meet their match Pattern-matching warnings that account for GADTs, guards, and laziness.""? http://research.microsoft.com/en-us/um/people/simonpj/papers/pattern-matching/gadtpm.pdf  ""Acknowledgments We are grateful ... to Jacques Garrigue and Jacques Le Normand for explaining OCaml’s behaviour. """
haskell,397on1,kurtel,2,Wed Jun 10 10:21:31 2015 UTC,"How does this compare to ""GADTs meet their match   They refer to it (p. 2. footnote 2), and it appears in the bibliography."
haskell,397on1,heisenbug,1 point,Wed Jun 10 13:44:57 2015 UTC,"Ugh, I don't speak ML fluently enough to be able to read this paper. It looks very interesting."
haskell,3959r0,bas_van_dijk,34,Tue Jun 9 10:23:51 2015 UTC,"I'm proud to announce that the day after I came back from ZuriHac 2015 we at LumiGuide had the grand opening of our bicycle parking and guidance system that we developed for the city of Utrecht. To our knowledge it's the first system in the world that guides cyclists to available parking space on a city-wide level.  The optical sensors that detect if there's space to park your bicycle are based on a computer-vision algorithm. Haskell is used throughout the system:    We used GHCJS for building our highly interactive web-client for calibrating the optical sensors. The central management server is also written in Haskell. Haskell was also used to implement the binary protocols used for communicating with the displays and to interface with third-party parking facilities.   EDIT: I forgot to mention that Nix, NixOS and nixops also form an integral part of our system. We use them on our physical image analysis servers, our dedicated central web-servers and our development machines (that MacBook Air I was holding in the picture was actually running NixOS at the time I switched on the system)."
haskell,3959r0,julesjacobs,4,Tue Jun 9 10:40:09 2015 UTC,Is there a description of the CV algorithm somewhere?
haskell,3959r0,coubeatczech,4,Tue Jun 9 11:03:35 2015 UTC,Not at the moment. The patent process is pending so it's still a trade secret.
haskell,3959r0,coubeatczech,5,Tue Jun 9 13:26:25 2015 UTC,Can you briefly describe which kind of technique/architecture did you use for frontend? Did you wrap any native .js library or rather not?
haskell,3959r0,meiersi,5,Tue Jun 9 22:10:32 2015 UTC,We used blaze-react which is a wrapper around Facebook's React library. It was developed by my former colleagues at Better: Simon Meier and Alex Sayers.  The library is rough around the edges but that was acceptable to us since the calibration tool is used by our internal calibration team and not directly by customers.  I can definitely recommend the virtual DOM approach for frontend development.
haskell,3959r0,sfvisser,1 point,Tue Jun 9 22:45:17 2015 UTC,Thanks! Will look at it.
haskell,3959r0,augustss,6,Wed Jun 10 07:31:31 2015 UTC,Congratulations! Great work!
haskell,3959r0,cameleon,4,Tue Jun 9 12:49:52 2015 UTC,"Thanks Simon, without blaze-react we wouldn't have finished this project in time."
haskell,3959r0,arianvp,4,Tue Jun 9 22:49:12 2015 UTC,"Nice work!  Too bad the sensors won't be counting my bike anymore, it recently got stolen right at the spot from the picture on that page. Maybe we can install some Haskell to prevent theft. ;)"
haskell,3959r0,borsboom,5,Tue Jun 9 16:11:23 2015 UTC,Thanks Sebastiaan and I'm sorry to hear about your stolen bike. That's unfortunately a common theme in the Netherlands.  Fortunately there's interest from municipalities for also using our system for doing video surveillance. So in the future we can at least see exactly when and who stole your bicycle and the sensors will scare of potential bicycle thiefs.
haskell,3959r0,Faucelme,6,Tue Jun 9 19:33:54 2015 UTC,"Very, very cool!"
haskell,3959r0,borsboom,6,Tue Jun 9 12:27:48 2015 UTC,Thanks for the compliments Lennart!   Just showing that Haskell can also be used outside of FinTech ;-)
haskell,3959r0,edwardkmett,5,Tue Jun 9 22:57:22 2015 UTC,Congratulations /u/bas_van_dijk!
haskell,3959r0,edwardkmett,4,Tue Jun 9 12:38:13 2015 UTC,"Awesome! I study here so that's really cool. Haskell impacting my daily biking life :)   parking here in Utrecht is a real problem which I struggle with everyday. Its hard to believe as an outstander just how many bikes are here.  If you need help maintaining this in the summer, I'm looking for a summer job! haha."
haskell,3959r0,tomasos,6,Tue Jun 9 14:26:09 2015 UTC,"Hi arianvp, I hope the system will help you find a parking spot more quickly on your way to your studies.  It's pretty cool that this Haskell-based system got deployed in Utrecht which IMHO is the Haskell-centre of the Netherlands.  Let's get in touch about that summer job ;-)"
haskell,3959r0,acow,4,Tue Jun 9 19:38:07 2015 UTC,"Wow, my two main interests on the Internet (bicycle infrastructure and Haskell) converge.  Never expected a link to bicycledutch from /r/haskell.  Now I need to find that icon I made a while back that adds wheels to the Haskell logo to make a Haskellcycle."
haskell,3959r0,proycon,4,Tue Jun 9 18:16:41 2015 UTC,"Not haskell-related, but I found this presentation about balancing bikeshare systems very interesting."
haskell,3959r0,bgamari,5,Tue Jun 9 20:25:52 2015 UTC,"That was an interesting presentation. Thanks for sharing!  In a while, when we have more data to work with, we are going to start modelling the in- and out-flow of parking facilities. Then we can use these models to predict the number of free parking spots that will be available in the future taking your travel distance into account.  I can't wait to start visualising similar behavioural patterns that Raphaël Cherrier showed in his talk and show the bicycle dynamics of Utrecht city!"
haskell,3959r0,deech,2,Tue Jun 9 22:13:24 2015 UTC,Now I need to find that icon I made a while back that adds wheels to the Haskell logo to make a Haskellcycle.   That would be cool!
haskell,3959r0,Kah0ona,5,Tue Jun 9 21:47:49 2015 UTC,Found them on an old hard drive:   Haskellcycle Haskell sharrow
haskell,3959r0,maerten,1 point,Wed Jun 10 19:22:48 2015 UTC,Nice :-)
haskell,3959r0,paulkoer,3,Wed Jun 10 21:51:26 2015 UTC,"Congratulations, Bas!"
haskell,3959r0,lpsmith,4,Tue Jun 9 13:26:05 2015 UTC,Thanks Edward. BTW lens and linear were very helpful in this project.
haskell,39710m,radix,5,Tue Jun 9 18:41:49 2015 UTC,"There are a few basic themes here (and here is a hosted version of the demo site).  I recently switched my site over from Jekyll to Hakyll and was pleased by how minimal the initial set of files and styling is.  Hakyll is effectively a blank slate to allow you to experiment and play around with making your own templates and CSS.  If you have never attempted to do your own CSS stuff before, I suggest you give it a shot.  Hakyll is a great platform to learn on."
haskell,39710m,AIDS_Pizza,9,Tue Jun 9 19:19:00 2015 UTC,"Author of the hakyll css garden here. Thanks @AIDS_Pizza for linking them. I haven't spent much time creating new themes lately, didn't know anyone was interested! I'm open to taking requests."
haskell,39710m,katychuang,3,Tue Jun 9 20:25:30 2015 UTC,This is great. I really wish there were more of this kind of work.
haskell,39710m,imalsogreg,3,Tue Jun 9 23:17:03 2015 UTC,"Thanks for the links /u/AIDS_Pizza and for the content /u/katychuang. I actually found that site before, but I was confused because I didn't notice the theme-switcher at the top! (I guess it was a case of ""header blindness"").  For the record, I've done plenty of CSS/HTML stuff. Enough to know that I'm a pretty bad designer, and also I hate working on it, which is why I like having resources like these :)  I am interested in blogs, but I also wonder if anyone has a decent template for documentation and/or books.  It'd be absolutely lovely to have a page with browseable thumbnails / categories and a way to download templates without the content of some random other site. Wishful thinking, I know, and I certainly don't have any time to dedicate to such a project! :-("
haskell,39710m,AIDS_Pizza,3,Tue Jun 9 23:42:15 2015 UTC,"The thing about Hakyll as I am sure you know is that each site is going to be compiled differently based off of the rules defined in the site.hs file.  If you have a (mostly) unmodified site.hs file, you may end up with being able to just tear out the /css and /templates directories to get the job done."
haskell,39710m,katychuang,2,Wed Jun 10 00:18:17 2015 UTC,"Yea, that flexibility given in site.hs has stumped me in figuring out how to package themes for distribution..."
haskell,39710m,katychuang,2,Thu Jun 11 05:17:50 2015 UTC,"... I also wonder if anyone has a decent template for documentation   Here's a long list of documentation examples and generators (beautiful-docs), as far as I know, there aren't any haskell based documentation generators."
haskell,39710m,ericpashman,1 point,Thu Jun 11 05:16:14 2015 UTC,"Just FYI, the CSS for the non-default themes is not loading on the demo blog posts. (All of them do load on the demo home page.)"
haskell,39710m,katychuang,1 point,Thu Jun 11 22:23:22 2015 UTC,Thanks for the heads up!
haskell,39710m,MnO2,4,Wed Jun 17 23:47:02 2015 UTC,"I created haspot that integrates ghost's cesper theme and hakyll. Basically it is a default theme from my blog with a few settings (title, banner, author) could be set by a yaml. At this moment it is not possible to install a new theme, but the future plan is to make it like Octopress that you could install other themes."
haskell,394v1m,vitalijzad,3,Tue Jun 9 07:20:29 2015 UTC,"As a programmer working with Haskell in Rome, I'd be very happy to help organizing meetups in my city, if there's interest."
haskell,394v1m,rostayob,3,Tue Jun 9 17:05:01 2015 UTC,"Hi, I live in Padova and will gladly come to Rome if anything consistent is organized!"
haskell,394v1m,meditans,4,Tue Jun 9 18:13:33 2015 UTC,"Treviso here, nice to see a fellow haskeller so close!"
haskell,394v1m,_mjnd_,1 point,Tue Jun 9 19:46:25 2015 UTC,Now we can also speak in our subreddit: http://www.reddit.com/r/Haskell_ITA/
haskell,394v1m,fgaz_,1 point,Tue Jun 9 21:34:08 2015 UTC,I live in Treviso too!
haskell,394v1m,CharlesStain,2,Thu Jun 11 18:44:49 2015 UTC,"Hey Francesco, I'm working remotely with Haskell in Rome as well. Feel free to drop me a line."
haskell,394v1m,kaukau,1 point,Tue Jun 9 19:47:42 2015 UTC,Please join our subreddit: http://www.reddit.com/r/Haskell_ITA/
haskell,394v1m,CharlesStain,3,Tue Jun 9 21:33:21 2015 UTC,"Good! I also live in italy, in Trento!"
haskell,394v1m,ocramz,2,Tue Jun 9 18:09:41 2015 UTC,"Italian here! Glad to see this happening, although a name which doesn't remind me of a train company might have been more effective I think :P"
haskell,394v1m,jnotarstefano,1 point,Tue Jun 9 11:49:25 2015 UTC,"Well, ItaloHaskell was the name of an Italian Summer meetup held in 2008:  https://wiki.haskell.org/ItaloHaskell  The name is inspired by AngloHaskell. Maybe it could be changed into ItalicoHaskell, I don't know."
haskell,394v1m,edwardkmett,2,Tue Jun 9 12:34:56 2015 UTC,Ciao a tutti :) Marco
haskell,394v1m,leonardo_m,2,Tue Jun 9 20:52:44 2015 UTC,"/u/vitalijzad, /u/ocramz and me met on #haskell.it and created /r/Haskell_ITA. Ideally, we should strive not to duplicate content between /r/haskell and there, so we should use it to discuss meetups, events or Haskell topics in Italian. English is still welcome, especially if you want to announce that you will be in Italy!"
haskell,394v1m,edwardkmett,2,Tue Jun 9 21:36:50 2015 UTC,I'm actually visiting Italy (just outside of Siena) for the next week or so in case any local Haskellers would like to meet up.
haskell,394v1m,tittoassini,1 point,Tue Jun 9 09:38:09 2015 UTC,"Unfortunately, the community is still in its formation phase. Let's keep in touch, next time we will be able to organize something."
haskell,394v1m,edwardkmett,1 point,Tue Jun 9 10:37:39 2015 UTC,Edward is a good Haskell programmer. It's worth trying to organize a small meeting in Siena or Florence during 20 or 21 Jun.
haskell,394v1m,tittoassini,0,Wed Jun 10 14:30:24 2015 UTC,I'm unfortunately heading back to the states on the 16th of June.
haskell,394v1m,blacktigr,1 point,Wed Jun 10 14:58:25 2015 UTC,"Hi Edward, will you be passing also by Florence or nearby?"
haskell,394v1m,edwardkmett,1 point,Sun Jun 14 06:44:12 2015 UTC,I'm actually heading through Florence on the way to Bologna tomorrow. I don't have too many plans behind getting on a train.
haskell,394v1m,tittoassini,1 point,Sun Jun 14 21:17:06 2015 UTC,"Hi Edward, sorry for the late answer.  If you plan to stop a few hours in Florence, though unfortunately today the weather is not ideal for a touristic walk, it would be great to meet.  I leave you my email and tel number: tittoassini@gmail.com +39 3348577042.  If it is not possible, I hope that there will be another chance soon.   Let us know sooner when you pass by.   You work is much admired and we shall try to organise a proper meeting."
haskell,39314y,turnersr,10,Mon Jun 8 22:03:19 2015 UTC,Why you stalkin' my class?
haskell,39314y,HeroofTimeMoM,5,Mon Jun 8 22:42:37 2015 UTC,"These are wonderfully designed and written lectures.   The homework problems, you refereed in syllabus, are they at the end of the lectures, or something special accessible only to students?"
haskell,39314y,mishach,5,Tue Jun 9 02:22:32 2015 UTC,"If you scroll through a lecture (such as Arrays and Mutability) you will find a black-bordered box that describes a homework assignment.  Not all lectures have these, especially toward the end because he wanted us to focus on our final projects (due tomorrow at 8 am :P)  And yes, he is one of the best lecturers I have ever had."
haskell,39314y,HeroofTimeMoM,2,Tue Jun 9 02:49:21 2015 UTC,"He is the best lecturer I ever had, hands down."
haskell,39314y,dmjio,8,Tue Jun 9 17:11:22 2015 UTC,Too bad there aren't videos of the lectures. Looks like a great class.
haskell,39314y,joehillen,7,Tue Jun 9 00:12:20 2015 UTC,There is also: CMSC-16100
haskell,39314y,csoroz,3,Tue Jun 9 10:43:10 2015 UTC,"161 was my intro to Haskell, and Kurtz is great. It was definitely a whirlwind of a course for me at the time, but very fun."
haskell,39314y,markandrus,5,Tue Jun 9 17:01:59 2015 UTC,Wow really nice!  The Lens and Parallel lectures are amazing.
haskell,39314y,clrnd,1 point,Tue Jun 9 02:19:24 2015 UTC,"I get an error following the link to the ""Parsing and Monads"" lecture of the Spring 2014 class.  Anybody know if the lecture is roughly equivalent to the 2011 ""Monads and More"" slides or the ""Parsing and Continuations"" slides? Or know the correct URL for the 2014 lecture?"
haskell,39314y,thoth7907,2,Tue Jun 9 16:57:11 2015 UTC,"Found here: https://github.com/nahuel/misc/tree/master/haskell/CS240h  Edit: this seems to be exactly like 2011 ""Parsing and Continuations"""
haskell,39314y,csoroz,1 point,Tue Jun 9 18:28:57 2015 UTC,Thanks so much!
haskell,3935mj,edwardkmett,3,Mon Jun 8 22:36:21 2015 UTC,Please submit a talk for CUFP!
haskell,3935mj,ReinH,2,Mon Jun 8 23:02:07 2015 UTC,OT but when do tickets for this go on sale? Where would I get them from?
haskell,3935mj,dkubb,1 point,Thu Jun 11 04:14:39 2015 UTC,https://regmaster4.com/2015conf/ICFP15/register.php  You can register today.
haskell,392u66,joehillen,6,Mon Jun 8 21:15:01 2015 UTC,Very interesting paper. I would love if anyone had any more papers in the area. My one concern is on persistence. Allowing functions in your database as first class members is actually really interesting and very neat! But doesn't that cause complications when persisting to disk? How would you capture the environment of a closure?
haskell,392u66,pridefulpropensity,2,Tue Jun 9 02:13:42 2015 UTC,"acid-state just records all fully applied function applications and saves those to a log, IIRC. Running the log recreates the database in memory. Perhaps they do something similar?"
haskell,392u66,beerdude26,9,Tue Jun 9 07:11:01 2015 UTC,"I apologize if this is out-of-place, but I don't understand this fascination with databases: Just make streams of discrete events first class and derive everything (all other state) from those events. (This is essentially CQRS/ES; which expands to ""Command Query Responsibility Segregation/Event Sourcing"").  You can, of course, store all your (derived) state into whatever data storage you want, but Event Sourcing makes most of this problem go away.  EDIT: in fact, this is what (stateful) databases already do: the write-ahead-log is exactly this. (Except that Event Sourcing preserves everything from the past. We can do that these days because progress on storage.)  EDIT#2: Regarding storage capacity: I recall that ~10-15 years ago that 1PB was an almost unfathomable amount of storage, but these days you can get 6TB+ consumer level disk drives. Add enough of those to a rack and add a little bit of erasure encoding and you've easily got 1PB of storage... cheap!)"
haskell,392u66,Oremorj,15,Mon Jun 8 22:19:22 2015 UTC,"Event streams on their own don't give you the whole ecosystem that you want.  First of all, streams don't have a notion of schema.  I.e., if a stream is something of type Stream a, then streams on their own don't tell you what range of types you can instantiate for a, and what operations they ought to have.  Second: the relational model has query languages.  Looking at it from a functional programming perspective, the most interesting one is relational algebra, which is basically a functional language built around a Relation a type, with operations that look very much like, for example:  -- Look, ma, it's a `Functor`! project :: (a -> b) -> Relation a -> Relation b  -- Look, ma, it's a `MonadPlus`! restrict :: (a -> Bool) -> Relation a -> Relation a  -- Look, ma, it's an `Applicative`! crossJoin :: Relation a -> Relation b -> Relation (a `Product` b)   The stream-world counterpart to relational query languages is high-level stream processing systems like Spark Streaming that provide very similar operations over streams—or even simple SQL queries over streams.  There's a higher commonality here—the theories of relational queries and stream transformations are very similar, and there's potential for unifying them at least partially by bringing in concepts like functors, applicatives, monads and so on.  Then RDBMSs and streaming systems start to look less and less as completely different things, and more like two flavors of the same thing.  Third: a lot of the recent stream querying/transformation functionality is in reality a blend of relational and stream processing.  For example, Spark Streaming's stream-to-stream joins are really relational joins of batches of data from two streams.  Basically, it's built around something like:  toBatches :: Stream a -> Stream b -> Stream (Relation a, Relation b)   ...and then the framework fmaps a relational query over the batched stream, and binds the result to something like toStream :: Relation a -> Stream a.  Fourth, the streaming data world doesn't yet have much in the way of the data integrity infrastructure that the relational world does.  How do you put a constraint on the data that flows through a stream?  How do you exploit such constraints?  One off-the-cuff idea is that this problem has ties to dependently-typed programming—a constrained stream is a stream together with a set of proofs about the nature of its contents.  (And again, could such a theory be unified with the relational concept of constraints?)  So yes, I would say databases are just as relevant today as ever, even in the face of the emerging streaming systems."
haskell,392u66,sacundim,4,Tue Jun 9 00:13:12 2015 UTC,"I'm not sure what you're saying because ""forall a . Stream a"" is not what I'm talking about. I'm talking about ""Stream a"" for some known ""a"". That doesn't mean you can't abstract over ""forall a. Stream a"".  Btw, most of the relational model works in a streaming context. For example, there's such a thing as joins for infinite streams. It's called ""zip"" in functional terms."
haskell,392u66,Oremorj,5,Tue Jun 9 01:25:14 2015 UTC,"Btw, most of the relational model works in a streaming context. For example, there's such a thing as joins for infinite streams. It's called ""zip"" in functional terms.   Yes... and no.  It depends on what we mean by ""stream.""  Here it's useful to import the FRP distinction between an Event type and a Behavior type (see, e.g., Conal Elliott's paper):  type Event a = [(Time, a)]   -- where the list is ordered by `Time`  type Behavior a = Time -> a   A Behavior has exactly one value at any point in time.  An Event has zero or more values at any point in time.  So there is some interchangeability:   A discrete Behavior can be modeled as a memory cell (to hold the current value) and an Event to broadcast changes to the value; An Event a can be modeled as a Behavior [a].   Behavior is a variant of the Reader monad, so it has a ""zippy"" applicative instance:  -- ""Zip"" two behaviors; at any point in time, the result will -- have a result that depends on the simutaneous value of the -- two input behaviors.  zipWith :: (a -> b -> c) -> Behavior a -> Behavior b -> Behavior c zipWith f as bs = \t -> f (as t) (bs t)   But specifying an interesting ""zip"" operation is more difficult for Event, because separate Events don't have to ""line up""—the events may fail to have values at times when the other does.  But note that up-and-coming stream processing/CQRS/reactive data/lambda architecture/etc. systems normally have a base semantics that corresponds to Event, not Behavior.  So how do they join streams?  Well, there are three core approaches:   Join batches of events drawn from the streams.  Transform the raw :: Event a into a batches :: Behavior [a] such that the behavior takes on batches as its values.  Then you can do the zipWith operation shown above on batches that ""line up."" Slight variant: join windows of the event streams.  Also an Event a -> Behavior [a] transformation. Emit a subset of the cross product of the Events.  Basically, you save the whole history of events of one of the streams, listen to the other stream, and for each event in the other stream, you look up ""matching"" events from the first stream, and emit a value for each pair of events that ""match.""  This is less like the Haskell zip function and more like concatMap.    It is instructive to read this page of the Samza docs in that light.  When they talk about ""stateful stream processing"" it's basically about how to bridge the gap between an infrastructural system that has Event semantics and a transformation that wants Behavior semantics.  An example quote:   Stream-stream join  Example: Join a stream of ad clicks to a stream of ad impressions (to link the information on when the ad was shown to the information on when it was clicked)  A stream join is useful for “nearly aligned” streams, where you expect to receive related events on several input streams, and you want to combine them into a single output event. You cannot rely on the events arriving at the stream processor at the same time, but you can set a maximum period of time over which you allow the events to be spread out.  In order to perform a join between streams, your job needs to buffer events for the time window over which you want to join. For short time windows, you can do this in memory (at the risk of losing events if the machine fails). You can also use Samza’s state store to buffer events, which supports buffering more messages than you can fit in memory."
haskell,392u66,sacundim,4,Tue Jun 9 03:05:50 2015 UTC,"Do you (or does anyone else here who's done this) have any recommendations for database systems designed for this? This is how we've modeled our data at slant.co, but just directly on PostgreSQL. I'm particularly wondering about any that can take advantage of the commutativity of some events for distribution/parallelizing playback."
haskell,392u66,T-R,3,Tue Jun 9 04:10:46 2015 UTC,Could you provide some learning materials for this idea? It sounds a lot like FRP in a way.
haskell,392u66,Jookia,3,Mon Jun 8 23:06:45 2015 UTC,"It's very much like FRP (in principle, at least). A google search should hopefully turn up useful things, but    https://www.youtube.com/watch?v=8JKjvY4etTY  seems like a relevant talk. I actually came upon the concept from an earlier talk of Greg Young's (after having indepently re-re-re-invented it and thinking I was so clever[1]) and haven't fully watched this one, but he usually argues pretty well for CQRS/ES, so I feel reasonably comfortable referring you to this one :).  [1] It's been reinvented several times. WAL (not quite the same, but...), Log-Structured File Systems, (etc.)"
haskell,392u66,Oremorj,1 point,Mon Jun 8 23:15:08 2015 UTC,Thanks! I think it even solved a problem I've put on hold. Most the time I feel like the functional programming ecosystem is another planet. I'm continually amazed at what others come up with.
haskell,392u66,Jookia,2,Tue Jun 9 00:24:59 2015 UTC,"Basically ""database"" frp"
haskell,392u66,Crandom,2,Mon Jun 8 23:18:44 2015 UTC,"There's nothing stopping you folding the events into a relational store. Here's roughly what we did at fynder:  The Command part of CQRS is a Free Monad that has access to the relational db and produces Events. We used the db constraints as part of our domain model in that we'd open a transaction, try and apply the events that the Free Monad wanted to produce to the database and roll back the transaction before The events produced are appended to the event stream. An example of a Command might be:  bookEvent :: BookCmd -> CommandT BookingId bookEvent (BookCmd eventId userId) = ...   Events produced might look like:   BookingCreated BookingId UserId EventId  UserCharged UserId Ammount  ...   As you rightly say you can now do what you want with the events and they are your golden source. We actually kept the Events in a table and folded the Events back into the relational (postgres) database which was also our Query database too. So we had both event semantics and arbitrary query ability. So depending on your schema you might end up with to following SQL getting run:   insert into bookings (user_id, class_id, ....)  value (userId, classId, ....)  returning id   ....  That was pretty cool as you could join the event stream to the current state of the entities they express which is great for analytics etc.  Here's what I'd do now:  I'd have a RDBMS in front of the Event stream (which I'm looking pretty hard at Kafka for). I would do the operations on the DB as part of the Command as before, but send the Events to the log (kafaka) and I'd commit the transaction when the events were received instead of aborting. There's a great write up of this idea here:  http://blog.confluent.io/2015/05/27/using-logs-to-build-a-solid-data-infrastructure-or-why-dual-writes-are-a-bad-idea/"
haskell,392u66,b00thead,4,Tue Jun 9 09:21:15 2015 UTC,"Here is the companion, or probably even the prelude to, paper by the same authors: http://referaat.cs.utwente.nl/conference/15/paper/7282/on-the-potential-of-functional-relational-databases.pdf"
haskell,392u66,darchon,3,Tue Jun 9 08:50:09 2015 UTC,"Neat paper, going to need to spend some time to chew on it.  I do have some dumb initial post-skim comments, though.  First, do we really want to allow arbitrary functions as values in relation attributes?  IIRC one of the properties of the vanilla relational model is that all queries terminate in finite time.  If an attribute can hold arbitrary partial functions, and the query language allows those functions to be applied, then this property goes away.  Maybe a restriction to total functions would be a good idea  Second: the paper stresses the ability to store any type of data in a relation, by recalling that the relational model is agnostic to what are the primitive types.  But there's a tension here, because the relational model is opinionated about how complex data ought to be represented.  I would think that we don't really want a functional RDBMS to be completely agnostic to the structure of the data types are are stored in it—it should recognize and exploit isomorphisms like this one:  Relation pk (a, (b, c))  ~  Relation pk (a, b, c)   So that, for example, by flattening the product types the storage engine can maintain CBO statistics for the b values of a Relation pk (a, (b, c)) independently of the c values."
haskell,392u66,sacundim,3,Mon Jun 8 22:24:57 2015 UTC,You can fix the first problem by restricting the stored functions to be total
haskell,392u66,Tekmo,13,Tue Jun 9 02:09:54 2015 UTC,Yes.  So we need not be mortified by that issue; but perhaps morte-ified would be good? :-P
haskell,392u66,sacundim,1 point,Tue Jun 9 03:11:18 2015 UTC,ba-dum tish
haskell,392u66,beerdude26,1 point,Tue Jun 9 07:03:42 2015 UTC,"Neat paper. Also, cool to see students at my former university are using Haskell. In '08 we used miranda to learn functional programming."
haskell,390dyx,edwardkmett,10,Mon Jun 8 09:35:47 2015 UTC,"It's nice to have the invisibility of terms given a name as I hadn't known how to describe it, having done the read.show with type annotation equivalent, and used Proxy types to tell the compiler the type I want without having a source-level term for it.  Also the forall vs pi quantifiers came up for me recently trying to express a vector with type-encoded natural size in its type but from a user-provided runtime value. This was trivial in Idris because the type just depends on the value, but requires two types in Haskell with singletons, it seems like ""faking"" it with a bunch of infrastructure because of this ""type-world vs value-world separation"" that's been causing me some existential grief, so this video comes at a coincidental time.  Is it possible to get anything near as useful as Agda's code generation for Haskell? The most practical thing I've seen so far is a case split, but that's a special case (hur). Djinn has its practical use within a small space but can it be generalized to work on ""real"" Haskell 2010 code? I.e. involving recursive data types and type classes. I have infinite optimism in this area but no knowledge to support it. Even if a Djinn-like tool generated various possible permutations of implementations of ambiguous types like [a] -> Int or [a] -> [a], it seems like you could drill down to what you wanted in short order without having to actually write code. And backed by hoogle and type info of every expression in your project the completion possibilities seem like they could be substantial.  Some funny quotes:   When you work in the old-fashioned mode where you write in an editor and you send your completed file and you get back abuse …   and   When you get an error message from GHC, you should think of that as Simon talking to you."
haskell,390dyx,chrisdoner,4,Mon Jun 8 12:29:00 2015 UTC,"When you get an error message from GHC, you should think of that as Simon talking to you.   I think just this is what attracted me to Haskell from the very first minute I used ghci. There is an incredibly intense pleasure that arises from being corrected by someone who writes and thinks like this:   Conversely, most languages will accept the expression   speed + distance   where speed is a variable representing speed, and distance represents distance, even though adding a speed to a distance is as much nonsense as adding a character to a boolean."
haskell,390dyx,michaelt_,2,Mon Jun 8 14:33:40 2015 UTC,Idk if I would describe it as incredibly intense pleasure... But glad to know us haskellers are passionate!
haskell,390dyx,fruitbooploops,2,Tue Jun 9 06:37:12 2015 UTC,"I also learned a new word, ""banjaxed""."
haskell,390dyx,Oremorj,5,Mon Jun 8 22:11:28 2015 UTC,"As I understand this talk, Conor proposes new type checking rules for a dependently typed language with type inference. Does this new approach help in any way with non-dependently typed languages like  Haskell?"
haskell,390dyx,profunctor,15,Mon Jun 8 12:50:46 2015 UTC,"I think the main point here is that several issues have been conflated. Inferred/manual, erased/retained, invisible/visible, type/value. In Haskell sans type classes you have inferred erased invisible types and manual retained visible values. His point is that things don't need to line up that way. Type classes give you inferred retained invisible values. Other combinations make sense too.  This applies to non-dependently typed languages too, but it's a more obvious concern in dependently typed languages. Soon everything will be dependently typed anyway, non dependent types are a legacy technology."
haskell,390dyx,julesjacobs,6,Mon Jun 8 13:06:13 2015 UTC,"Soon everything will be dependently typed anyway, non dependent types are a legacy technology.   Someday. But I don't think it will be so soon. There is still a long way to go. Even in Agda and Idris - and even in Coq - proofs of even simple assertions can be painfully complex to write and understand. And in DT languages you lose the expressiveness and elegance of purity by introducing strictness.  But I think we will get there, and I am looking forward to it."
haskell,390dyx,yitz,12,Mon Jun 8 14:54:13 2015 UTC,"And in DT languages you lose the expressiveness and elegance of purity by introducing strictness.   Since when? You know Agda has lazy backends (e.g., MAlonzo, UHC Core) right? Totality has nothing whatsoever to do with strictness. I really wish folks would stop assuming it does; just as much as Conor wishes they'd stop assuming totality means Turing-incompleteness."
haskell,390dyx,winterkoninkje,2,Mon Jun 8 20:41:08 2015 UTC,How does totality not mean turing-incompleteness? Isn't that what halting problem implies?
haskell,390dyx,Kyraimion,7,Mon Jun 8 21:14:13 2015 UTC,https://personal.cis.strath.ac.uk/conor.mcbride/TotallyFree.pdf is what is probably being referred to.
haskell,390dyx,anders_,3,Mon Jun 8 21:33:01 2015 UTC,"From the discussion:  ""However, the key message of this paper is that the status of generalrecursive definitions is readily negotiable within a total framework. There is no need to give up on the ability either to execute potentially nonterminating computations or to be trustably total. There is no difference between what you can do with a partial language and what you can do with a total language: the difference is in what you can promise, and it is the partial languages which fall short"""
haskell,390dyx,kurtel,-1,Tue Jun 9 07:40:34 2015 UTC,"I'm not talking about whether there are lazy backends, or about whether you can provide special annotations or techniques to express laziness in your language.  I am talking about Haskell as language for which non-strict semantics are among its fundamental defining qualities - it defines the meaning of a Haskell program. It changes the way you think about code when you read and write it. It's liberating. That was the bold experiment of the original Haskell committee, and it has proven to be a grand success.  DT provides great power and expressiveness in a different direction, and apparently there is some dissonance between that kind of power and the power of non-strict-by-default. But if Conor can give us a deeper understanding of types that shows us how they are really both part of the same thing, we would all be very pleased."
haskell,390dyx,yitz,2,Tue Jun 9 21:34:08 2015 UTC,apparently there is some dissonance between that kind of power and the power of non-strict-by-default   Where do you get this? It's simply false.
haskell,390dyx,kamatsu,1 point,Wed Jun 10 04:00:17 2015 UTC,"This post by Dan Doel illustrates that dissonance.  The post talks about what a true free monoid might look like in Haskell. It actually isn't as simple as you might think. Dan writes about that difficulty: ""This is a consequence of laziness and general recursion. To model a language with those properties, one needs to use domains and monotone, continuous maps, rather than sets and total functions.""  The DT approach focuses on sets and total functions, while the non-strictness semantic approach focuses on domains and monotone continuous maps. It's not that the two approaches are mutually exclusive; of course not. But it's a different focus. That definitely makes a difference in how you naturally express things - the basic feel of the language."
haskell,390dyx,yitz,1 point,Sun Jun 14 12:28:42 2015 UTC,"The denotational semantics ascribed to a non-total, non-strict language is indeed more difficult than that of a total language, dependently typed or not. But the denotational semantics are just capturing the consequences of the evaluation strategy in a non-total setting. The choice of evaluation strategy alone is not in conflict with the totality or type system of the language."
haskell,390dyx,kamatsu,1 point,Sun Jun 14 13:20:13 2015 UTC,"No, the denotational semantics of a non-total non-strict language are easier and more natural, not more difficult. The point is exactly that you are not ""capturing the consequences of the evaluation strategy"". Non-strictness frees you from the obligation to specify an evaluation strategy at all. That is where the power and expressiveness come from.  But it is awkward to work that into the context of a language in which, for whatever reasons, you do prefer to assume things about the evaluation strategy, such as strictness."
haskell,390dyx,yitz,1 point,Sun Jun 14 16:50:12 2015 UTC,"No, the denotational semantics of a non-total non-strict language are easier and more natural, not more difficult.   Easier/more natural than what? A total language? Hardly true. Total functions and sets are pretty straightforward.   But it is awkward to work that into the context of a language in which, for whatever reasons, you do prefer to assume things about the evaluation strategy, such as strictness.   But total languages don't assume anything about the evaluation strategy.   You are conflating totality and strictness. Totality and non-strictness are completely compatible.  This comment you made earlier:   the non-strictness semantic approach focuses on domains and monotone continuous maps.   Only applies for non-strict, non-total languages. Total non-strict languages have more or less the same denotational semantics as total strict ones."
haskell,390dyx,kamatsu,12,Sun Jun 14 17:01:05 2015 UTC,And in DT languages you lose the expressiveness and elegance of purity by introducing strictness.   ?
haskell,390dyx,gallais,2,Mon Jun 8 15:54:18 2015 UTC,Aren't there big limitations? Can the type checker check a possibly infinite heterogeneous list?
haskell,390dyx,vincentrevelations,14,Mon Jun 8 17:34:56 2015 UTC,"Why not?  How exactly do you propose to get your hands on a possibly-infinite heterogeneous list? Presumably you'll have to construct it from pieces. And each of those pieces will have some finite description of how they're constructed (you do plan on finishing your code, right?). Thus, they will be as easy/hard to check as any other finite description of a value. Moreover, even if there are infinitely many pieces, there will be some finite description of how many there are and what they look like; so that's no escape either."
haskell,390dyx,winterkoninkje,2,Mon Jun 8 20:47:04 2015 UTC,"Say I lazily generate a list of all the natural numbers. Each number is wrapped, and the wrapper's type reflects whether the Collatz conjecture holds for that number. Over this list, I want to map a function which only takes numbers for which it holds.   I think you can write that, but the type checker will never finish (if it does Erdos owes you $500)."
haskell,390dyx,vincentrevelations,8,Mon Jun 8 22:05:51 2015 UTC,"I think that you won't be able to write it; the compiler will require that the function that any term used at type-level is terminating/total, and the termination check will (without a manual proof) reject the program at the ""wrapping"" stage."
haskell,390dyx,rpglover64,2,Mon Jun 8 22:38:27 2015 UTC,"Whether the conjecture holds for a number can always be checked in finite time, even if there's a number for which it doesn't.   The program should be rejected, of course, but the compiler can't know the differences with similar cases where we use a proposition that we do know is always true. That means it has to reject both. Don't know how far this goes but that's a lot of valid things we can't write. You'd have to provide an oracle. Hmm, can we use coerce?"
haskell,390dyx,vincentrevelations,4,Mon Jun 8 23:06:37 2015 UTC,"How do you determine in finite time that the conjecture fails to hold for a particular number? Isn't it possible that the Collatz sequence of a number never repeats?  Now that I think I understand your question better (and have actually watched the talk), I think the simple solution to the problem is that the type is not erased and the typechecker verifies that each number's Collatz type can be computed at runtime."
haskell,390dyx,rpglover64,4,Tue Jun 9 01:09:36 2015 UTC,"I have no idea what ""wrapper"" you mean, nor where you think the typechecker will fail. We can have an infinite stream of natural numbers; that typechecks just fine. And we can define a predicate of natural numbers returning whether the Collatz conjecture holds for that number; that typechecks just fine. You can filter the infinite stream to only include those natural numbers for which it succeeds/fails; I see no reason why that shouldn't typecheck either.  The only place I can see running into issues is if you desire to stipulate that the filtered list is finite (or infinite, or has any other property). But there's nothing special about the Collatz conjecture here, this same problem holds for filtering any infinite stream. If you want the type to encode whether the result is in/finite, then you'll need to provide some proof of that fact. The only difference vs, say, filtering the nats by whether they're even or not is that it's easy to provide the proof of infiniteness for the even nats.  Coq agrees:  Axiom Collatz : nat -> Prop. Axiom Collatz_decidable : forall n, {Collatz n} + {~Collatz n}.  CoInductive Stream (A : Set) : Set :=     | Cons : A -> Stream A -> Stream A     | Skip : Stream A -> Stream A     . Implicit Arguments Cons [[A]]. Implicit Arguments Skip [[A]].  CoFixpoint natsFrom (n:nat) : Stream nat :=     Cons n (natsFrom (S n)).  CoFixpoint filter {A:Set} {P:A->Prop} (f : forall a:A, {P a} + {~P a}) (xs : Stream A) : Stream {a:A | P a} :=     match xs with     | Cons x xs' =>         match f x with         | left  p => Cons (exist _ x p) (filter f xs')         | right _ => Skip (filter f xs')         end     | Skip xs' => Skip (filter f xs')     end.  Definition quux : Stream {n:nat | Collatz n} :=     filter Collatz_decidable (natsFrom 0)."
haskell,390dyx,winterkoninkje,-1,Tue Jun 9 00:13:25 2015 UTC,"I have no idea what ""wrapper"" you mean   Just a constructor like (CollNumber 1) : Coll True.   You can filter the infinite stream to only include those natural numbers for which it succeeds/fails   I left this step out. I suppose you can always do that. Or just fake it and assume it's always true, it's a phantom type anyways."
haskell,390dyx,vincentrevelations,2,Tue Jun 9 00:43:36 2015 UTC,"Seeing as the constructor for such a wrapper would invoke some sort of collatz program, you wouldn't be allowed to lie in the types and say that this collatz program definitely terminates, which would make this example impossible. But not lying in types is a good thing!"
haskell,390dyx,kamatsu,2,Tue Jun 9 08:33:51 2015 UTC,"I'm not sure what exactly you mean by the wrapper type, but either the type checker will reject your program because your wrapper type does not match the input type of the function, or you simply can't write a program that computes the list in the first place. Type checkers of dependently typed programs will not check everything case by case. It is up to YOU, the programmer, to give a (finite) proof that works for all cases."
haskell,390dyx,julesjacobs,3,Mon Jun 8 23:14:11 2015 UTC,"And in DT languages you lose the expressiveness and elegance of purity by introducing strictness.   Huh? DT languages can be lazy, you know."
haskell,390dyx,kamatsu,2,Mon Jun 8 16:27:02 2015 UTC,"DT languages can be lazy, you know.   but not useful?    edit: What I mean is, how do you give any dependently typed guarantees on values without eager valuation of all thunks?  You can't return a lazy sequence that is typed to a particular size right?"
haskell,390dyx,runT1ME,5,Mon Jun 8 18:39:55 2015 UTC,"You don't need to know the particular length of a finite list in order to know that it has some (finite) length. That's the whole point of dependently typed languages: we can define a function of type Pi n:nat, forall a:Type, a -> List n a. When we lift n to the type level, we don't —and can't— know what it actually is at compile time; we only know it's a nat. But that's sufficient to know the list is finite. When we append lists: Pi n, m:nat, forall a:Type, List n a -> List m a -> List (n+m) a we don't need to know what the lengths of the lists are; we only need to know that they are finite and that addition preserves finiteness.  The reason for desiring totality is that eventually we'll need to decide equality of types in order to decide whether we're allowed to pass a particular argument to a particular function. But we don't need strictness to guarantee totality. It helps, of course; but isn't necessary."
haskell,390dyx,winterkoninkje,2,Mon Jun 8 20:54:22 2015 UTC,"Why not? Dependently typed languages only need a type distinction between finite lists and potentially infinite lists. The latter have to be evaluated lazily of course, but finite lists can be evaluated strictly or lazily. The same is true for lists that have a length that is determined by their type. With some extensions you can even do lists typed to a particular size in Haskell, and Haskell is lazy."
haskell,390dyx,julesjacobs,2,Mon Jun 8 19:04:30 2015 UTC,"Can bottom not exist in a finite, lazy list? How do you ensure that without evaluating the thunks?"
haskell,390dyx,runT1ME,8,Mon Jun 8 20:41:10 2015 UTC,"I think you missed the point of the type system altogether. A total language guarantees all terms, if you were to fully reduce them, would reach a normal form.   But that is a hypothetical. There is no need to reduce them at all if you don't need to.  Total languages are even better computationally speaking because not only can you freely choose lazy evaluation, but you generally get evaluation order agnosticsm. You can pick redexes at random if you wanted to, and confluence guarantees your semantics are preserved."
haskell,390dyx,tactics,3,Mon Jun 8 22:48:07 2015 UTC,"The same question comes up in strict languages. How do you ensure that a function of type Bool -> Bool always terminates? A thunk is just a function of type () -> t, so how do you ensure that that terminates? The answer is the same in both cases: with a termination checker."
haskell,390dyx,julesjacobs,2,Mon Jun 8 21:22:53 2015 UTC,"The same question comes up in strict languages. How do you ensure that a function of type Bool -> Bool always terminates? A thunk is just a function of type () -> t, so how do you ensure that that terminates? The answer is the same in both cases: with a termination checker.   Hi, thanks for the response.  I'm new to this dependent typing stuff, but I'm still not sure I understand.   A function from bool to bool seems easy to ensure it terminates.  As long as you don't allow unbounded recursion and you aren't side effecting or able to create a bottom of any kind, how could it not return?   However, () -> t well, I dunno, that seems a lot more difficult to ensure totality?  Maybe that's where I'm confused."
haskell,390dyx,runT1ME,6,Mon Jun 8 21:48:25 2015 UTC,"As long as you don't allow unbounded recursion and you aren't side effecting or able to create a bottom of any kind, how could it not return?   The same reasoning applies to thunks. How could a function of type () -> t not return a t when called?  Edit: Re:   Can bottom not exist in a finite, lazy list? How do you ensure that without evaluating the thunks?   I feel like the confusion is similar to a Java programmer asking:   Can null not exist in a variable of type Foo? How do you ensure that without testing whether it's null?   The answer is simply: it's statically ruled out by how the language is constructed. Just like in Haskell a value of type Foo can't be null, in a total language a function of type () -> t, or any type a -> b for that matter, will simply always terminate because you can only write terminating functions. If you write a non-terminating function the type checker will deny it. There are several ways that can be done, the two most prominent being:   Simply disallowing ALL recursive functions. You have to write all programs in terms of built-in recursion combinators that ensure termination by construction. Having a guardedness checker that ensures that a recursive function can only call itself on a strictly smaller argument. For example f (x::xs) = 1 + f xs is fine because xs is strictly smaller than x::xs.   Note that like in Haskell, you can't write a non-recursive non-terminating program. For example the non-recursive y-combinator is ill typed in Haskell and in dependently typed languages."
haskell,390dyx,julesjacobs,1 point,Mon Jun 8 22:16:02 2015 UTC,Just like with strict lists I would say. Why would this change anything ?
haskell,390dyx,bartavelle,8,Mon Jun 8 20:43:46 2015 UTC,"It's not new type checking rules or a new type theory; rather, it's a call for a rethinking of surface language design. In the current Hindley-Milner paradigm, languages tout their ability to hide types from the programmer and refuse to let the programmer play with them, often forcefully insisting that the type checker be allowed to guess the type of an expression rather than let you explicitly specify the type yourself. (e.g., show . read in Haskell, try to call yourFunc<YourType>(yourParam) in Swift, etc.)  Conor is saying this is ridiculous, and doubly so in a dependently-typed context: HM has been superseded. In the ""new regime"", types are explicit, visible, and the central focus of the programmer -- they should not be hidden in the syntax, and direct control over them should always be in the hands of the programmer, and certainly never forcibly guessed by HM."
haskell,390dyx,dnkndnts,5,Mon Jun 8 13:13:34 2015 UTC,The new type annotation punning feature of GHC (introduced by /u/augustss) will soon solve the problem of show . read in Haskell.
haskell,390dyx,yitz,4,Mon Jun 8 14:55:40 2015 UTC,What's that then?
haskell,390dyx,tomejaguar,12,Mon Jun 8 15:22:57 2015 UTC,"Type sections, show . (:: Int) . read. Currently available in Mu and on by default. It's a great feature."
haskell,390dyx,ndmitchell,2,Mon Jun 8 16:04:16 2015 UTC,It's absolutely the right thing to do. We write types which will be thrown away in order to distinguish exactly which invisible values will be used at run time. That is progress.
haskell,390dyx,pigworker,1 point,Tue Jun 9 21:39:48 2015 UTC,"Ahem, right. Well, it does solve the immediate problem at hand."
haskell,390dyx,yitz,8,Sun Jun 14 18:38:01 2015 UTC,I imagine he means being able to write show . (:: Double) . read instead of (show :: Double -> String) . read. It was described here.
haskell,390dyx,chrisdoner,4,Mon Jun 8 16:09:39 2015 UTC,Sugar like (:: T) ==> (\x -> x :: T) I think. Or was it (:: T) ==> (id :: T -> T)?
haskell,390dyx,tel,0,Mon Jun 8 16:20:43 2015 UTC,The Prophet has spoken; the Promised Land awaits!
haskell,390f1a,JPMoresmau,10,Mon Jun 8 09:49:57 2015 UTC,"This is such a simple app, but makes my life so much better. The sheer speed of feedback is amazing.  I run it in a tmux pane, next to my editor. No fussing with ghc-mod integration in Vim."
haskell,390f1a,stunt_penis,1 point,Mon Jun 8 15:42:06 2015 UTC,I second that. I use tmux and usually do a cabal repl which takes ages to load the required module. ghcid is blazing fast (at leas for small project). I started using ghic today and I love it so far.
haskell,390f1a,maxigit,4,Tue Jun 16 19:58:19 2015 UTC,I need this so hard. Syntastic's error messages are nigh unreadable with ghc-mod.
haskell,390f1a,ephrion,1 point,Mon Jun 8 18:31:22 2015 UTC,Yes. It's sad :(
haskell,390f1a,hiptobecubic,4,Tue Jun 9 04:33:33 2015 UTC,"Great tool. I have something similar I use for pretty much everything. It's been on my ""write a blog post about this"" for three years now :(. I should really work on that....  onmodify ()  {      TARGET=${1:-.};     shift;     CMD=""$@"";     echo ""$TARGET"" ""$CMD"";     ( if [ -f onmodify.sh ]; then         . onmodify.sh;     fi;     while inotifywait --exclude '.git' -qq -r -e close_write,moved_to,move_self $TARGET; do         sleep 0.2;         if [ ""$CMD"" ]; then             bash -c ""$CMD"";         else             build && run;         fi;         echo;     done ) }   No one ever said bash was pretty. Any way, usage is  onmodify ./some/path ""thing --args && otherthing && this is just a bash cmd that is eval'd""   which sets up inotify (linux only) to watch everything under ./some/path and runs the command whenever it changes. For me, it's often something like  onmodify . ""nosetests --with-id --failed || fart_noise""   which runs python tests and plays some randomized rude noises if I break something."
haskell,390kzi,apsod,16,Mon Jun 8 11:04:18 2015 UTC,"So what you've described is usually called an ""applicative morphism"", e.g. when you have an arrow phi :: (Applicative f, Applicative g) => f a -> g a which has the following properties  pure a = phi (pure a) fmap f (phi x) = phi (fmap f x) phi x <*> phi y = phi (x <*> y)   These properties imply the ""linearity"" equations you describe.  So what you're looking for is ""when are natural transformations exactly Applicative morphisms?"" which is kind of a weird question to find an answer to. The set of all natural transformation is not constrained by applicative laws and so there is a high likelihood of them cheating ways that break structure.  So I don't know a good answer to your question directly.  But there is an interesting related question which has a great answer. In particular, it's possible to find a type construct K such that the set of natural transformations forall a . f a -> g a correspond exactly to the applicative morphisms forall a . K f a -> g a when g is an Applicative. In this case there's no demand that f is Applicative at all, K will turn it in to one.  {-# LANGUAGE GADTs, RankNTypes #-}  data K f a where   Unit :: a -> K f a   Ap   :: f x -> (x -> b -> a) -> K f b -> K f a  instance Functor (K f) where   fmap f (Unit a) = Unit (f a)   fmap f (Ap fx xba ffb) = Ap fx (\x -> f . xba x) ffb  instance Applicative (K f) where   pure = Unit   Unit g <*> y = fmap g y   Ap fx xba ffb <*> y = Ap fx (\x -> uncurry (xba x)) (liftA2 (,) ffb y)  liftK :: f a -> K f a liftK f = Ap f const (Unit ())  lowerK :: Applicative g => (forall x . f x -> g x) -> (K f a -> g a) lowerK k x = case x of   Unit x -> pure x   Ap fx xba ffb -> fmap xba (k fx) <*> lowerK k ffb   This should satisfy laws like, for any phi :: forall a . f a -> g a and applicative g  pure a = lowerK phi (pure a) fmap f (phi x) = lowerK phi (fmap f (liftK x)) phi x <*> phi y = lowerK phi (liftK x <*> liftK y)   Edit: To add, since I left it out this morning, the above construction can be found as the composition of the standard Free Applicative structure and Coyoneda which is the ""free Functor"". I didn't just pull it out of nowhere, but it does have a sort of nice appealing look, especially if I wrote it more like this  data K f a where   Unit :: a -> K f a   Ap :: (f l, K f r) -> ((l, r) -> o) -> K f o"
haskell,390kzi,tel,3,Mon Jun 8 16:14:01 2015 UTC,"Thank you! This looks very interesting!  Am i correct in understanding that what's essentially going on here is that K delays the ""application"" until you provide it with a natural transformation to an applicative?"
haskell,390kzi,tel,3,Tue Jun 9 12:17:22 2015 UTC,"That's a pretty exact way of understanding it, yep! K adjoins just enough structure to f to ensure that it's an Applicative."
haskell,390kzi,ReinH,1 point,Tue Jun 9 13:16:20 2015 UTC,"For a similar construction, see the free applicative: https://hackage.haskell.org/package/free-4.12.1/docs/Control-Applicative-Free.html"
haskell,390kzi,Spewface,2,Wed Jun 10 05:00:43 2015 UTC,"In your first definition of phi, do you mean to leave out g from the type signature?"
haskell,390kzi,tel,2,Mon Jun 8 18:42:28 2015 UTC,"Nope, typo! Thanks, fixed now."
haskell,390kzi,tomejaguar,3,Mon Jun 8 18:44:39 2015 UTC,"A subset of applicatives for which every natural transformation is an applicative morphism?  Well, there's the empty set, and the set containing just the identity applicative, for a start.  What is the context?"
haskell,390kzi,Umbrall,3,Mon Jun 8 13:27:54 2015 UTC,"Yes, this was, i think, my question. Though I'm lacking in terminology and general knowledge of what I'm talking about.    The context is me playing around with linear algebra, using something like the following:  data Linear a f g where     Diagonal    :: f a -> Linear a f f     RowMatrix   :: g (f a) -> Linear a f g     ColMatrix   :: f (g a) -> Linear a f g   Where a is the scalar type and with some appropriate constraints.  feeling a general lack for something like:      Projection  :: (forall a. f a -> g a) -> Linear a f g    Which won't misbehave. Noting (perhaps incorrectly) that Readerish things behave something like this, for example Maybe, ZipList, Map, Fixed-size vectors &c. while Lists does not."
haskell,390kzi,tomejaguar,2,Mon Jun 8 20:19:07 2015 UTC,"Well it seems he means linear in the context of linear algebra, in that the arguments are linear. But it doesn't seem to correlate to functors much"
haskell,390kzi,tel,3,Mon Jun 8 14:48:36 2015 UTC,"Seems to me more like s/he is using ""linear"" to mean ""preserving structure"" more generally, by analogy with linear transformations."
haskell,390o3x,__Joker,6,Mon Jun 8 11:40:23 2015 UTC,"This article seems little flame-baity from the author, wanted to know the views from this community."
haskell,390o3x,winterkoninkje,4,Mon Jun 8 14:20:51 2015 UTC,"I think there's a point missing in the idea of ""Compositionality, but at a cost"". The cost is that we must factor our programs in a particular way; the benefit is that our programs are factored to assist local reasoning. But local reasoning isn't just a benefit for the compiler, it's a benefit for humans as well. The more we can rely on local reasoning, the easier it is to keep the relevant parts of the program in mind and the easier we can refactor things. This may not mean much for ""interaction"", but it means a heck of a lot to programmers of all stripes."
haskell,390o3x,rdfox,2,Tue Jun 9 00:41:14 2015 UTC,"Heterogeneous lists are possible in Haskell but if you can follow all the type-level programming in HList your are a far more expert hakeller than I am. The haskell ethic of type safety gives a result almost perfectly opposite to the Perl ethic. In haskell, easy things are possible and hard things are (occasionally) easier than they would be in Perl. One thing in haskell's favor is that performance can be very good and that is unheard of in languages that don't at-least enforce type stability. I'm starting to lean towards F# as a good compromise between theory and practice.  It's actually pretty easy to get things done without heterogeneous lists. The thing that bugs me most in Haskell is the lack extensible records which leaves you on a conceptual desert island, cut off from the many object-oriented libraries that are available to everyone else."
haskell,390o3x,kamatsu,9,Mon Jun 8 15:32:51 2015 UTC,Modern heterogenous lists aren't too bad. They just have a list of types attached to the types.  data HList :: [*] -> * where    Nil :: HList '[]    Cons :: x -> HList xs -> HList (x ': xs)
haskell,390o3x,sacundim,9,Mon Jun 8 15:37:38 2015 UTC,"Heterogeneous lists are possible in Haskell but if you can follow all the type-level programming in HList your are a far more expert hakeller than I am.   But keep in mind that the article's contrasting example is a heterogeneous list in Python:  >>> g = lambda x: x**2 >>> [1, 'a', ""hello"", g]   That's not hard to replicate in Haskell:  import Data.Dynamic  example :: [Dynamic] example = [ toDyn (1 :: Int)           , toDyn 'a'           , toDyn ""hello""           , toDyn ((**2) :: Float -> Float)           ]   If you really, really want dynamic types Haskell lets you have them.  It's just that, as you point out, most of the time that's not what anybody really wants."
haskell,390o3x,cdxr,4,Tue Jun 9 00:40:59 2015 UTC,"Have you looked at vinyl? The Rec f rs type is a heterogeneous list of elements with types given by rs, with a functor f applied over each element. You have an HList when f is Identity, and you have an extensible record when f tags each value with a type-level symbol. These definitions have become much simpler with type-level lists."
haskell,390o3x,PM_ME_UR_OBSIDIAN,3,Mon Jun 8 16:28:01 2015 UTC,"I'm starting to lean towards F# as a good compromise between theory and practice.   I personally find it quite good, but HKTs are tough to give up."
haskell,390o3x,ezyang,1 point,Tue Jun 9 00:51:34 2015 UTC,"""And the way we will do it is with logical relations"""
haskell,390o3x,jonsterling,1 point,Mon Jun 8 17:17:34 2015 UTC,"Nice article, I agree with some of it. In particular, the C-H part and the effects part are spot on (from my perspective); I don't really agree with the section “ Compositionality, but at a cost”, and I am not sure whether I agree with “Compositionality v. interaction”."
haskell,391ihh,jleitgeb,3,Mon Jun 8 15:54:58 2015 UTC,"This would be SO MUCH BETTER with a real world example. (It would also have to be much more involved, though.)"
haskell,391ihh,PM_ME_UR_OBSIDIAN,2,Tue Jun 9 00:50:16 2015 UTC,"Nice. It remembers me the first Pearl of Functional Programming by Richard Bird, but I don't find any link to buy a book, and I googled a little without success. Can anyone tell me what document is the author refering to?"
haskell,391ihh,freinn,1 point,Mon Jun 8 20:33:48 2015 UTC,Thanks for your feedback. Which document are you referring to? How to Program It?
haskell,391ihh,jpvillaisaza,2,Mon Jun 8 20:39:34 2015 UTC,"Yes. I didn't find it at Amazon. So many Spaniards like Haskell, I say this because I am one and maybe you too xD."
haskell,391ihh,freinn,4,Mon Jun 8 20:44:56 2015 UTC,"There are links to Simon Thompson's How to Program It in HTML and PDF in http://www.haskellcraft.com/craft3e/Prob_solving.html, as well as links to other examples and the Where do I begin? paper (which has more references).  I'm from Colombia, so some Spanish ancestry I suppose. :)"
haskell,391ihh,jpvillaisaza,2,Mon Jun 8 20:55:17 2015 UTC,"Thanks, that's a very nice source of information, bookmarked."
haskell,390msw,gilded_honour,3,Mon Jun 8 11:25:50 2015 UTC,"I've always followed the Ubuntu instructions on https://github.com/bitemyapp/learnhaskell , never had trouble with it."
haskell,390msw,akurilin,2,Mon Jun 8 15:38:45 2015 UTC,# PPA with versions of GHC and cabal more recent than official repos sudo add-apt-repository -y ppa:hvr/ghc sudo apt-get update  sudo apt-get install -y pkg-config build-essential autoconf automake \   ghc-7.8.4 cabal-install-1.20  cabal update && \   cabal install alex doctest ghc-mod happy 'hi==0.0.8.2' hlint hoogle pointfree pointful stylish-haskell && \   hoogle data   replace versions as appropriate
haskell,390msw,timmy_tofu,2,Mon Jun 8 15:43:20 2015 UTC,"First off, Haskell Platform includes GHC, so there is no need to separately download or install GHC. Further, you can't mix-n-match GHC and Haskell Platform (or any pre-built Haskell package for that matter).  To install the platform from the ""Generic Linux Binaries"" of the page you referenced, you were doing the right thing. Did you perhaps cd into that bin dir to run activate-hs? If you did, you need to supply the ghc-root argument, since it won't be able to figure it out from the path of the script. You can do this like so:  sudo /usr/local/haskell/ghc-7.8.3-x86_64/bin/activate-hs /usr/local/haskell/ghc-7.8.3-x86_64   Note the under-bar in x86_64 the web page has a typo.  Your GHC 7.10.1 installation won't be of any use for things built with the Platform, which in that version uses 7.8.3. A new version of the platform, based on the upcoming GHC 7.10.2 is due out this month.  Finally, the Platform you installed has Cabal 1.18.1.3."
haskell,390msw,MtnViewMark,4,Mon Jun 8 13:50:38 2015 UTC,"Looks like haskell platform causes more confusion than actually helps.  There was a big discussion on reddit about the need of haskell platform and most commenters agreed that the only (remotely) viable use case for haskell platform nowadays is windows installation.   On linux just install ghc, alex, happy and cabal-install. And you are all set."
haskell,390msw,vagif,4,Mon Jun 8 15:27:36 2015 UTC,"What  an uncalled for comment. This was a relatively simple question, with a relatively simple answer, which was graciously provided below. I don't see why, rather than being helpful and answering the question, you chose to take this opportunity to tell somebody to do something else entirely.  It seems to me that what causes confusion is when people respond to simple questions with simple answers with only mildly relevant diatribes."
haskell,390msw,sclv,1 point,Tue Jun 9 23:56:23 2015 UTC,"For one thing, it's the wrong version of GHC. That version of Haskell Platform requires 7.8.3. You should also be able to use 7.8.4 in practice. But going back to the 7.6.* series, or forward to the 7.10.* series, won't work without some tweaking."
haskell,390msw,yitz,1 point,Mon Jun 8 18:34:29 2015 UTC,"Finally I fixed it, thank you. I just had to install cabal-install. My ghc version was 7.10.1"
haskell,390msw,clrnd,0,Tue Jun 9 02:50:13 2015 UTC,"I have no experience with the platform, but the source for activate-hs seems to look for your ghc installation dir. I installed GHC from a ppa, so mine is /opt/ghc/7.8.4/, so I'd have to call the script like:  sudo /usr/local/haskell/ghc-7.8.3-x86-64/bin/activate-hs /opt/ghc/7.8.4/  This is all guessing nevertheless.  You can update cabal via cabal update && cabal install cabal-install.  Do you really need the platform? GHC and Cabal alone are enough I'd say :P"
haskell,390msw,mn-haskell-guy,0,Mon Jun 8 12:20:23 2015 UTC,"To update cabal, run:  cabal update cabal install cabal-install   and look in ~/.cabal/bin for the new cabal binary.  If you can't find the new cabal binary, see this SO answer:  http://stackoverflow.com/a/30709928/866915"
haskell,390icj,marido73,3,Mon Jun 8 10:32:00 2015 UTC,Make sure you post this on Stack Overflow as well :)
haskell,390icj,beerdude26,1 point,Mon Jun 8 11:22:52 2015 UTC,/r/haskellquestions for completeness.
haskell,390icj,tejon,1 point,Tue Jun 9 02:45:12 2015 UTC,"You should use HDBC-odbc to connect to your database as usual, and then use hdbcConnect to run your queries, I think. Note that I haven't tried this out."
haskell,38xyrc,winterkoninkje,11,Sun Jun 7 20:12:16 2015 UTC,"test-framework is mostly in life-support mode (and supports all GHCs back to 7.0). I.e. it gets kept working (if e.g. new GHC releases aren't compatible), but there's no active development of new features going on. tasty works only with GHC 7.4 or later, but in return is actively developed   So unless your package still supports GHC 7.0 (and you want to test it), I'd suggest going with tasty (even though test-framework will be kept alive for the foreseeable future)"
haskell,38xyrc,hvr_,15,Sun Jun 7 20:54:02 2015 UTC,"hspec is also a nice, actively maintained alternative. (I can't compare since I don't use tasty)"
haskell,38xyrc,semanticistZombie,5,Sun Jun 7 23:05:44 2015 UTC,"tasty wraps other test-libs (amongst which hspec) and provides a uniform CLI to them.  I think there is a slight difference in understanding of what a ""Test Framework"" means.  Personally I call hspec and HUnit, QuickCheck, SmallCheck: test libraries. And I reserve the ""Test Framework"" for anything that wraps over test libs, like tasty and test-framework.  Arion is another interesting project: it watches the source directory and runs tests automatically when related files changed."
haskell,38xyrc,cies010,9,Mon Jun 8 08:05:20 2015 UTC,"And I reserve the ""Test Framework"" for anything that wraps over test libs, like tasty and test-framework.   This is exactly what hspec does, in addition to providing another way to write tests. From the hspec webpage:   integration with QuickCheck, SmallCheck, and HUnit   It also does cool stuff around parallelisation of tests and automatic test discovery. I would certainly call it a framework."
haskell,38xyrc,Crandom,3,Mon Jun 8 14:37:13 2015 UTC,"You're right, I stand corrected. :)  I did not know it integrated with other test-libs.. Thus it's a framework, even by my own definition!"
haskell,38xyrc,cies010,1 point,Tue Jun 9 09:10:57 2015 UTC,"Even so, tasty is focused on running tests and keeping them organized, independently of how you specify them. Whereas Hspec is a way of specifying tests."
haskell,38xyrc,yitz,1 point,Tue Jun 9 21:42:40 2015 UTC,and what about cabal's own detailed-0.9?
haskell,38xyrc,ibotty,6,Mon Jun 8 06:57:48 2015 UTC,"Hspec is very, very nice and will be an easy switchover from people who know rspec/mocha from other languages."
haskell,38xyrc,Crandom,1 point,Mon Jun 8 07:15:37 2015 UTC,"Yes, and you can use Hspec from tasty, too."
haskell,38xf7u,cipher2048,10,Sun Jun 7 17:43:13 2015 UTC,"You're right, calling curried functions with one argument at a time is not so cheap. This is why GHC generates special code when a function is applied to all the argument it needs (such a function application is called saturated application). See https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls"
haskell,38xf7u,pycube,12,Sun Jun 7 17:52:17 2015 UTC,"There is also a paper on this by Simon M/SPJ. There is a link to it on that page but it seems like it's dead, here is a working one: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.9317&rep=rep1&type=pdf"
haskell,38xf7u,glg00,3,Sun Jun 7 18:46:32 2015 UTC,Cool! Those seem like good reads. Thanks!
haskell,38xf7u,edsko,1 point,Sun Jun 7 19:06:45 2015 UTC,I also explain this in a fair amount of detail in my blog post Understanding the RealWorld.
haskell,38xf7u,evincarofautumn,4,Mon Jun 8 11:52:50 2015 UTC,"While Haskell’s type system deals only in unary functions, GHC’s code generation deals in functions of any arity—it produces simple calls for fully applied functions, and only allocates closures in the case of partial application. This is a definite oversimplification; /u/simonmar would probably know more."
haskell,38xf7u,MrWoohoo,4,Mon Jun 8 06:18:18 2015 UTC,I always had assumed the compiler generates different entry points for each arity and called the right one based on the number of args given in the calling statement.
haskell,38wels,edwardkmett,5,Sun Jun 7 11:53:47 2015 UTC,"It's been pointed out (not in these terms) that one could make the traditional replacement of ""Fam X"" (some set S; some family P : S -> X, picking a collection of X-things out as the image of P) by ""Pow X"" (some T : X -> *, representing a collection of sets by comprehension, giving for each candidate x : X, the set of possible proofs that it's in the collection). Modulo (large, problematic) issues of equality, the two notions are equivalent but can have different pragmatics. Here, X is *. Fam * is hard to work with in Haskell but easy in dependently typed languages. Pow * is easier to work with in Haskell, where you can write type level programs which treat types as data.  I was trying to keep close to the spirit of the ""Fam *"" presentation used by Abbott, Altenkirch and Ghani, and to emphasize that shape is the prior notion, the freely chosen thing on which the position set depends. Of course, that's not so easy to do, as we need both type-level and value-level versions of shapes.  So it may be a good steer to use Pow instead of Fam in a Haskell context. The proposal was  data Con shapeGives x =    forall pos. shapeGives pos :<: (pos -> x)   and then you have  data ISh :: * -> * where   I :: ISh () data KSh :: * -> * -> * where   K :: a -> KSh a Void data SumSh :: (* -> *) -> (* -> *) -> (* -> *) where   L :: f p -> SumSh f g p   R :: g p -> SumSh f g p data ProdSh :: (* -> *) -> (* -> *) -> (* -> *) where   P :: f p -> g q -> ProdSh f g (Either p q) data TensorSh :: (* -> *) -> (* -> *) -> (* -> *) where   T :: f p -> g q -> TensorSh f g (p, q)   which feels kind of weird to me, but works.  Let's see if we can define composition. The issue is that the type of the inner component of the position depends on the value of the outer component in a way that makes use of a function contained in the shape. At the moment, I'm not seeing how to escape from that, but it's worth poking it a bit harder."
haskell,38wels,pigworker,15,Sun Jun 7 14:35:28 2015 UTC,data ISh :: * -> * where     This is Conor planting pun material for future usage.
haskell,38wels,gasche,6,Sun Jun 7 19:53:27 2015 UTC,Reading ∃ as summation   :o :O :◯
haskell,38wels,evincarofautumn,6,Sun Jun 7 17:48:51 2015 UTC,"Well, the dependent sum type expressed by Sigma corresponds to the existential quantifier in constructive logic :)"
haskell,38wels,PM_ME_UR_OBSIDIAN,8,Sun Jun 7 20:12:50 2015 UTC,"Exactly. ""There exists sum x such that..."""
haskell,38wels,tactics,9,Sun Jun 7 20:30:14 2015 UTC,"As someone fairly new to the whole FP scene and no formal education in TT, there's a thorny question that keeps pricking the back of my mind: why exactly wasn't Haskell written with dependent types in the first place? As I understand, Haskell was birthed nearly twenty years after Martin-Lof's revised publication. What was the motivation for not using that type theory? Wasn't Haskell intended to be a research language?  Because we all seem to be in a 20+ year long penance for that decision. I could understand if Haskell was written in 1970 or something, before any of this stuff existed, but it wasn't, and in fact, MLTT wasn't even particularly new when Haskell was written. To put this in today's terms, can you imagine if by 2033, we still didn't have a HoTT implementation? shudders  Dear God I think I just scared myself. Now I know how Martin-Lof must feel looking at the world."
haskell,38wels,dnkndnts,30,Sun Jun 7 17:57:42 2015 UTC,"I really don't think Haskell could have adopted dependent type theory as its basis, in the state that TT was in at the time, and I'm glad its designers did not. For example, the status of pattern matching was not clear in TT at that time. There's a long way to go from having a foundational theory to a reasonable language design.  It's also rather implausible, given the interests of the group who came together to create Haskell, which were primarily concerned with lazy functional programming. In many ways, ML had rather settled the broad thrust of how types for functional programs ""should"" work, which is why ""type inference"" is still talked about as one thing to be good or bad at, rather than an astonishing alignment of multiple things which can and should be picked apart.  It's possible to have interesting dependently typed ""research languages"" now, with some non-toy usability. It might have happened a bit earlier, if some folk hadn't been quite so fingers-in-ears in the late 90s and early 00s. Truly stunning fud is still occasionally spouted by people who should know better, naming no names. But there's no way Haskell could have taken that route at its birthtime and still served the needs of its creators, or my needs today.  I'm loving the fact that lots of people are picking up a bit of a dependently typed hobby, but Haskell remains my getting-stuff-done language, and very glad I am of that, too."
haskell,38wels,pigworker,10,Sun Jun 7 18:45:50 2015 UTC,"For example, the status of pattern matching was not clear in TT at that time. There's a long way to go from having a foundational theory to a reasonable language design.   I kind of figured that might have been it. My first reaction after reading ML's 1975 paper was ""If somebody told me to implement that in a 'normal' programming language... how the hell would I do it?"" It's certainly non-trivial, that's for sure. That being said, 20 years is a long time."
haskell,38wels,dnkndnts,16,Sun Jun 7 19:23:12 2015 UTC,Haskell has good type inference. Languages with dependent types historically do not.  We've slowly been extending Haskell towards the world of dependent types while trying to retain that property.
haskell,38wels,dnkndnts,11,Sun Jun 7 18:02:08 2015 UTC,"Haskell has good type inference. Languages with dependent types historically do not.   True, but when you're programming in Agda/Idris, do you really miss it? The ability for the compiler to fill in holes is, in my opinion, exponentially more useful than type inference.  I sometimes even fantasize about a world where I don't call functions by name, but rather by expressing a type signature. People think this sounds crazy -- how would the compiler know which implementation to pick? How should it know that I want to use + and not *? To which I reply: the same way I know I wanted to use + and not *. There is a distinction, because apparently the difference is important to me; and if the difference is important to me, why not explain to the compiler why it's important?  Ok so I think I just came out of the closet as a crazy person. But that is how I think programming should be done."
haskell,38wels,AndrasKovacs,8,Sun Jun 7 18:22:03 2015 UTC,"I'm slightly confused here as to what we and /u/edwardkmett mean by ""type inference"". I tend to mean ""ability to infer implicit terms"" by it, so by my reckoning Agda has far superior type inference than Haskell; after all, all the higher-order unification / eta-extensionality machinery is just missing in Haskell (not that there would be much use for it, currently).  But I get the impression that people some mean ""ability to guess type signature for bindings"" by type inference, and therefore they find that Haskell has better type inference, since apparently Agda bindings require type annotations. To me this is rather wrong, because Hindley-Milner style inference and generalization could be perfectly well implemented in Agda for the same fragment for which it works in Haskell. It's a matter of language design that they aren't implemented. Simply put, there's not much of a user demand for it in Agda-space. And I should mention too that local let-generalization is actually turned off by default in GHC 7.10 if we use GADTs or type families."
haskell,38wels,dnkndnts,5,Sun Jun 7 20:02:57 2015 UTC,"You're right, there's definitely ambiguity. I was referring to HM inference on bindings, and its absence in Idris/Agda being insignificant."
haskell,38wels,dnkndnts,9,Sun Jun 7 20:16:19 2015 UTC,"when you're programming in Agda/Idris, do you really miss it?   I wind up wanting it more often than I thought I would at least.  To further complicate the story, we've started picking up hole-filling in Haskell. =)"
haskell,38wels,SkoomaMudcrab,3,Sun Jun 7 19:51:57 2015 UTC,"Oh really? Wow, I've completely missed that. How do I use it? Does it work in haskell-mode in emacs?"
haskell,38wels,dnkndnts,5,Sun Jun 7 20:00:07 2015 UTC,"You can read about this feature here or watch it here. Not sure about emacs, though it's obviously possible since it works for Agda."
haskell,38wels,bartavelle,6,Sun Jun 7 20:20:47 2015 UTC,"GHC will now infer the type of _'s and include it in an error message along with what is in local scope that can be used to fill the hole. (It doesn't tell you constraints on those types yet though.)  We need better tooling support around this compiler feature, but we're slowly getting there."
haskell,38wels,pigworker,6,Sun Jun 7 20:17:11 2015 UTC,"Ok, I just tried it in one of my projects, and it worked perfectly for giving me the type of the hole. I'm so glad you mentioned this. Even without magical code inference, it's really useful."
haskell,38wels,tomejaguar,5,Sun Jun 7 20:27:44 2015 UTC,"Before we used to have to turn on ImplicitParams, and use ?foo for holes, but you didn't get any help with what could be used to fill the hole from the local context."
haskell,38wels,pigworker,3,Sun Jun 7 21:36:41 2015 UTC,"Just a note : I have been using this for a while with ghc-mod. Just write ""undefined"" at the hole and ask it to tell me its type."
haskell,38wels,dnkndnts,5,Sun Jun 7 21:06:12 2015 UTC,_ works better than undefined or the ?foo trick now. You get all the things that can be used to fill the hole in local scope.
haskell,38wels,conklech,8,Sun Jun 7 21:35:25 2015 UTC,There's no such thing as good type inference.
haskell,38wels,SkoomaMudcrab,2,Sun Jun 7 18:13:31 2015 UTC,Please expound.
haskell,38wels,pigworker,14,Sun Jun 7 19:11:42 2015 UTC,Certainly. Here are 45 minutes of your life you won't get back.
haskell,38wels,SkoomaMudcrab,3,Sun Jun 7 19:15:12 2015 UTC,You can watch him discuss the evils of Hindley-Milner and the ridiculousness of the entire paradigm here: https://www.youtube.com/watch?v=ad4BVmPni7A
haskell,38wels,tactics,1 point,Sun Jun 7 19:16:40 2015 UTC,And here's the /r/haskell discussion of the Youtube video the others mention.
haskell,38wels,SkoomaMudcrab,-1,Mon Jun 8 19:51:04 2015 UTC,"Dependent types mean totality. And total languages are highly impractical. Turing completeness, not having to prove termination of anything, not having to use unary numerics - all of those are benefits of independent types.  Edit: type inference, too. All in all, Haskell is a great middle ground between research wackiness and getting stuff done. Thank goodness it isn't dependently typed!"
haskell,38wels,pigworker,22,Sun Jun 7 18:19:52 2015 UTC,"False in almost all respects.  There are non-total dependently typed languages (and most of the total ones let you cheat). A language can be total and Turing complete: modern dependently typed languages are. It is possible to do binary arithmetic (and even use machine arithmetic, if you trust it) in a language with dependent types: Idris does this.  Oh, and you seem to think Haskell isn't dependently typed. It's not ""full-spectrum"" dependently typed, but the key hallmark of being able to ""learn by testing"", doing a case split which refines the return type differently in different branches, has been with us for quite some time. The possibility but inconvenience of the singleton type construction, allowing values to cross the ::, is something we can mitigate by doing a better job of being dependently typed."
haskell,38wels,SkoomaMudcrab,-4,Sun Jun 7 18:57:39 2015 UTC,"Thanks for the lecture, b-b-but I'm afraid I can't go past   A language can be total and Turing complete   Has someone solved this already? Did I suffer a massive memory loss and spend years in a cryo chamber?"
haskell,38wels,co_dan,8,Sun Jun 7 20:10:07 2015 UTC,Coinduction solves this issue...
haskell,38wels,pigworker,3,Sun Jun 7 20:28:29 2015 UTC,"How does it?  In this paper it is explicitly stated that total functional programming languages are not Turing-complete.   There are two obvious disadvantages of total functional programming    Our programming language is no longer Turing complete!    In fact, it is said that codata and coinduction only solve the ""If all programs terminate, how do we write an operating system?"" problem, but not the problem of a lack of Turing completeness.  This same distinction of total languages and Turing-complete languages is supported here and here   So how is that possible that languages like Agda, Coq or Idris can answer that question? That’s simple: they are not Turing-complete (or at least their terminating subsets are not Turing complete). They prohibit user from using some constructs, probably the most important one being general recursion.   So I'm still curious as to what /u/pigworker meant when he said that a total language may be Turing-complete."
haskell,38wels,co_dan,17,Sun Jun 7 21:16:30 2015 UTC,"Since you ask, consider reading my paper on the subject in which I respond to that particular remark in Turner's excellent paper. I see David around, and I think I've convinced him that his ""disadvantage"" is overly pessimistic.  Thank you for the other links. I'll be popping up there shortly.  The expressive weakness is entirely on the side of the partial languages, which cannot make strong promises about the good behaviour of programs, because the possibility of looping or finite failure is pervasive. Total languages allow us to acknowledge the potential infinitude of potentially infinite processes and run them on a suck-it-and-see basis, just like when you run a partial program. The only thing you can't do is lie.  The problem when you insist on being able to lie is that you can't expect people to believe you when you tell the truth.  Argue in favour of inexpressivity if you like, but be aware that that is what you are doing."
haskell,38wels,dnkndnts,3,Sun Jun 7 21:42:17 2015 UTC,"Wow. That is so cool, thank you for your work."
haskell,38wels,tailcalled,2,Mon Jun 8 20:01:45 2015 UTC,"I am sorry, I don't mean to be rude or anything, I really enjoyed your paper, but I don't see how it eliminates the problem (or rather a non-problem IMHO) of Turing-incompleteness.  According to the usual terminology (completeness, computability, totality), a total language can not be Turing complete. This a well-known Richard's Paradox -- heck, even you had a posting specifically about it: https://mail.haskell.org/pipermail/haskell-cafe/2003-May/004343.html!  So, under the terminology that is used by me, people who taught my computability classes, and was used by you at some point, a total language can not be Turing complete. I can only assume that when you claim that the usage of coinductive data can make a language Turing-complete you use some other definitions (e.g. your definition of ""semantics"" or ""completeness"" or ""total"" is different). Maybe defining the aforementioned notions would shine some light on this?"
haskell,38wels,pigworker,1 point,Tue Jun 9 15:56:52 2015 UTC,"You're clearly not sorry, but be that as it may.  We all know that executing Turing machines is a potentially infinitary process.  It is perfectly clear that total languages with coinduction can express in what way executing Turing machines is a potentially infinitary process. That is, they can document the consumer risk in running such a program.  Many of us have mistaken the inability to promise that a computation is finitary for the inability to express the computation at all. The truth is that we can express all computations in total languages, and we can be conservatively accurate (but never entirely precise) about their finitary status. That is, there are some computations about which a total language must be strictly pessimistic. That's a world away from ""programs we can't write"".  If, in the past, I have also been wrong about this (and I expect I have), I apologize. I've since learned. I can only ask that others also learn."
haskell,38wels,radix,1 point,Tue Jun 9 21:22:46 2015 UTC,"I really do not want to be rude, so I do apologize for coming of as such.  I am not trying to say that total languages are bad or inexpressive - I don't think that is the case.   The truth is that we can express all computations in total languages, and we can be conservatively accurate (but never entirely precise) about their finitary status.   I still don't understand why, tho. Can we write that evil function in a total language?"
haskell,38wels,AndrasKovacs,5,Mon Jun 22 08:57:00 2015 UTC,"You can have your cake and eat it to. For example, Idris is a total language, but you can freely turn the totality checker on/off whenever you want to with %total and %partial."
haskell,38wels,conklech,3,Sun Jun 7 21:31:18 2015 UTC,Consider the monad  codata Partial a = Finished a | Later (Partial a)   Note: codata means potentially infinite.
haskell,38wels,mapastr,10,Sun Jun 7 21:51:58 2015 UTC,"Consider also the monad (ha, appropriate given the original topic)  Free (Con (s <| p))   and now write a function  foo :: forall i. s i -> Free (Con (s <| p)) (p i)   which describes a general recursive partial function of type  forall i. s i -/> p i   as a call-response tree explaining how one call expands into zero or more recursive calls.  Or if you want the more simply typed version, the free Monad which looks like  data RecOrac s t x    = Ret x    | Rec s (t -> x)   and write  foo :: s -> RecOrac s t t   for the description of a partial function in s -/> t.  Every time you feel the urge to have foo make a recursive call, even if you can't justify it structurally, you can always have foo emit a Rec s k, where s is the argument you'd have given to foo and k is the continuation which says how you'd keep going if the recursive call ever delivered a result. You can write any old general recursive program this way, without making any commitment as to in what way you intend to run it. Handle the Rec effect any way you like: your implementation of foo tells you everything you need to know to make progress on demand. Now you just need to manage demand. Ultimately, you can hand off to a runtime that keeps trying a bit more if you haven't hit ctrl-c.  That is, the way way to say what a general recursive program is, without being in any way prescriptive about how you run it, is given by the (inductive) free monad on the container whose shape and positions are exactly the domain and codomain of your partial function.  Saying you can't program general recursion in a total language is just the same kind of wrong as saying you can't program IO in a pure language.  [edit: added a little more detail]"
haskell,38wels,stevana,3,Sun Jun 7 22:17:45 2015 UTC,"Thanks, this is a really good explanation, and very intuitive given an understanding of how IO effects actually work in Haskell."
haskell,38wels,pigworker,6,Sun Jun 7 22:52:44 2015 UTC,"A total program indeed can not go into a really unresponsive infinite loop - but neither can non-total programs! We never observe an infinite number of Turing-machine steps; someone always pulls the plug or hits Ctrl-c. Total programs have the same observable behavior as non-total programs; it's just that ""pulling the plug"" must be internal to the program, and there is no world-stopping out-of-context event from the inside semantics perspective.   Non-total languages can't guarantee totality for actually total functions, much like non-pure languages can't guarantee purity for actually pure functions. In total languages partiality is an effect, somewhat like some other effects in Haskell which can be tracked via the type system."
haskell,38wels,stevana,6,Sun Jun 7 21:24:45 2015 UTC,"Meta-comment: please don't downvote comments to oblivion merely for being ""wrong,"" especially when that wrongness is discussed below!  Downvote comments that are not constructive."
haskell,38wels,pigworker,1 point,Mon Jun 8 19:53:01 2015 UTC,This is just false.
haskell,38wels,tailcalled,5,Sun Jun 7 19:40:29 2015 UTC,"What about indexed containers?   Is it possible to even write the mere definition, never mind fancy operations on them (such as composition)?"
haskell,38wels,sjoerd_visscher,3,Sun Jun 7 14:12:32 2015 UTC,Try it Pow-style.  data ICon (shapeGives :: (ix -> *) -> (ox -> *)) (s :: ix -> *) (o :: ox)   = forall pos. shapeGives pos o :<: (forall (i :: ix). pos i -> s i)
haskell,38wels,tailcalled,2,Sun Jun 7 14:41:23 2015 UTC,"Yeah, I was thinking of the Fam^2 presentation... The Pow^2 one is quite brutal... It seems like Fam Pow works as well though, using the same trick as in the article to get rid of the Fam."
haskell,38wels,tailcalled,1 point,Sun Jun 7 20:23:04 2015 UTC,Fam2 will...have to wait.
haskell,38wels,tailcalled,3,Sun Jun 7 20:41:05 2015 UTC,"The tensor is actually a pretty cool trick that I wasn't aware of before.  I wonder if we can make it more efficient by letting the container choose the representation. Essentially, a lot of inefficiency lies in using functions instead of a proper data structure, right? But the only reason we use functions is because they work with arbitrary position types, and the position type is only used in the function that maps from positions to values, so if add a functor to the container that is represented by the positions...  This might have been a bit confusing. I'll try sketching it, but using the ""pow X"" style because I prefer that.  data FasterCon s x = forall pp. s pp :<: pp x   We would probably want some typeclass that provides actual positions. This is closely related to Representable.  class PowContainer s where     type Pos s :: * -> *     iso1 :: s pp -> pp a -> (Pos s pp -> a)     iso2 :: s pp -> (Pos s pp -> a) -> pp a   Then we should have that Con (Equal (Pos s)) x ~ FasterCon s x, where  data Equal a b where     Refl :: Equal a a"
haskell,38wels,tailcalled,2,Sun Jun 7 17:21:24 2015 UTC,Or reuse Representable?  data FasterCon s x = forall pp. Representable pp => s pp :<: pp x
haskell,38wels,julesjacobs,2,Sun Jun 7 17:46:26 2015 UTC,"I guess that could work. I kinda dislike that s could have components that are not representable, but it seems like it would work."
haskell,38wels,pigworker,2,Sun Jun 7 17:55:45 2015 UTC,"You could look into it as encoding a left kan extension using a corepresentable profunctor rather than a function space from the positions.  data instance Con (s <| p) x = forall i. s i :<: (p i -> x)   is exists i. s i * q i x -- for a profunctor q which is corepresented by p, but that looks like a form of profunctor composition, because 's i' is another profunctor in its own right which ignores its input, and that traces a similar lan-style end (which makes sense when you go into profunctor composition as a form of kan extension in its own right)."
haskell,38wels,julesjacobs,2,Mon Jun 8 16:43:28 2015 UTC,But are there any corepresentable profunctors that are faster than the ordinary function space?
haskell,38y16c,cocreature,12,Sun Jun 7 20:30:09 2015 UTC,"My Haskell wishlist is very selfish. I just want a bigger, faster brain."
haskell,38y16c,gfixler,6,Mon Jun 8 02:39:33 2015 UTC,"I don't get it: if it's a wishlist, why do so many entries already have associated packages?"
haskell,38y16c,gelisam,3,Sun Jun 7 21:44:48 2015 UTC,This confused me as well.
haskell,38y16c,Mob_Of_One,2,Sun Jun 7 23:41:24 2015 UTC,It feels like there's some overlap with awesome-haskell. I wonder if instead of listing existing libraries there could be links to sections in awesome-haskell.  e.g. something like:  See awesome-haskell#distributed-computing
haskell,38y16c,rehno-lindeque,1 point,Mon Jun 8 10:42:49 2015 UTC,"I guess it's kinda hard to seperate them. If there are no libraries, then it's hard to know if your wish is already fullfilled."
haskell,38y16c,NiftyIon,3,Mon Jun 8 07:08:13 2015 UTC,Check out the yet unpublished Frames package for data processing / visualization.
haskell,38y16c,FPguy,2,Sun Jun 7 23:50:09 2015 UTC,I like the idea. It could also make it easier to coordinate efforts to fill some of the gaps in the haskell ecosystem.
haskell,38vsef,maxigit,14,Sun Jun 7 06:27:57 2015 UTC,"-1  My sentiments are well expressed by the three posts of Malcolm Wallace on the café thread: here, here, and here."
haskell,38vsef,yitz,10,Sun Jun 7 18:31:27 2015 UTC,"My opinion (sorry but I'm posting on here because I don't like Haskell cafe) +1 for a shorter syntax -1 for it by default (just activate it in your cabal file) -1 for the proposed syntax  The problem with import Data.Map(Map) as M is everybody understand it as : import Data.Map.Map as M, you get M.Map in scope and nothing else.  What about import Data.Map as M and [qualified] (Map)?"
haskell,38vsef,matchi,11,Sun Jun 7 06:44:38 2015 UTC,"How about adding an exposing keyword?  For example:  import Data.Map as M exposing (Map)  This would solve the clarity issue while also being fairly intuitive by virtue of being the opposite of hiding. Of course it isn't a perfect fit, but I find the wording clearer than and."
haskell,38vsef,acow,2,Sun Jun 7 21:35:16 2015 UTC,"I may be unique, but I am a counter-example to the assertion that everybody understands import Data.Map.Map as M to mean anything in particular. Usually we import modules, not types, so I'd have to check the manual because this form of import looks like a type error!"
haskell,38vsef,acow,3,Mon Jun 8 05:14:53 2015 UTC,"Maybe, but when I read import Data.Map(Map) as M, whatever import and as M I expect it to affect  Data.Map(Map), so it's a bit weird that the as M dealing with the full Data.Map instead of Data.Map(Map).  Having say that, when I first discover the Haskell import syntax I didn't understand anything until I got to the see the table with all the different cases explain. I can deal with an extra case.  Also, even though I do think this syntax is not the best, I would probably use it."
haskell,38vsef,cocreature,1 point,Mon Jun 8 08:09:15 2015 UTC,"Yeah, I've looked at that table a lot. I think import syntax is one of those things where your best bet really is to read the manual, as it were."
haskell,38vsef,cocreature,3,Mon Jun 8 14:24:28 2015 UTC,Why would one disable a change that doesn't break backwards compatibilty by default? Only because haskell 2010 doesn't contain it?
haskell,38vsef,RedLambda,11,Sun Jun 7 06:51:20 2015 UTC,"Because it becomes specific to GHC (and a certain version of it) and it's not written anywhere. Give a such file to someone which doesn't use GHC (or an older version) and he'll get the syntax error without explanation or clue how to solve it. If you add a language pragma, at least he should get an nice error message, ""this pragma doesn't exist or is not implemented ...."" which basically says, get the latest GHC version ;-)."
haskell,38vsef,acow,6,Sun Jun 7 07:01:07 2015 UTC,"Fair enough, although for a new ghc version you could just depend on a newer base version. I'm kinda sad that haskell prime seems to have died off and now we need to hide everything unter flags or pragmas."
haskell,38vsef,tomejaguar,10,Sun Jun 7 07:49:24 2015 UTC,"Wait, weren't those pragmas introduced for the very purpose of making it possible to reference syntax extensions relative to the Haskell Report? Or put differently, those language pragmas are what make Haskell truly modular..."
haskell,38vsef,theonlycosmonaut,7,Sun Jun 7 08:12:06 2015 UTC,"The problem is, by using it, you force everybody using your package to upgrade to a new version of GHC even though, your code might have been compatible with older version. Another way of doing it (which stays compatible with older version) would be to define a new preprocessor expanding the new syntax in standard haskell."
haskell,38vsef,tomejaguar,2,Sun Jun 7 08:03:17 2015 UTC,This is true of every language pragma. Has MultiWayIf caused a lot of trouble for you?
haskell,38vsef,theonlycosmonaut,6,Mon Jun 8 05:05:57 2015 UTC,"Has there been any work on a simple, closer to first-class, import syntax (that doesn't go as far as a full-fledged module system)?"
haskell,38vsef,Taladar,2,Sun Jun 7 09:52:39 2015 UTC,Could you expand on that? What did you have in mind?
haskell,38vsef,dagit,5,Mon Jun 8 12:02:55 2015 UTC,"I don't really know, which is why I was asking, but I imaging things like assignment statements for modules.  Instead of  import qualified Data.Map as M   you could write  M = Data.Map"
haskell,38vsef,acow,3,Mon Jun 8 13:12:23 2015 UTC,"I like the look of that. Clean, simple. Though it doesn't really cater for non-qualified imports, does it?  Come to think of it, for some irrational reason I've always wanted to be able to import modules in a limited scope (for example, in a where clause). Seems like that would be a natural extension of this idea."
haskell,38vsef,acow,3,Tue Jun 9 11:50:45 2015 UTC,I really don't see how having two ways to write something is somehow less confusing to beginners than having a single way.  I also don't see how you could fit that proposed syntax onto a single reasonably short line for anything slightly more complex than a single symbol in the import list.
haskell,38vsef,Taladar,3,Sun Jun 7 14:02:39 2015 UTC,I also don't see how you could fit that proposed syntax onto a single reasonably short line for anything slightly more complex than a single symbol in the import list.   For me that's what this boils down to. It's not actually shorter when you're importing many things. I also find it confusing.
haskell,38vsef,edwardkmett,3,Sun Jun 7 15:32:13 2015 UTC,"It is literally no different if you want to just use long explicit import lists. A fairly common style, though, is to import qualified if you want to use a bunch of names, but still want to establish a source or avoid clashes. This is fine, and how text, bytestring, vector, etc. are often used. The pinch currently felt is that the central type names of these modules are unique, so folks do the two-line import dance.  But again, the syntax for long import lists without qualified names is not touched."
haskell,38vsef,mboes,3,Mon Jun 8 05:03:14 2015 UTC,"The goal is not to have more ways in the long run. If people adopt the new syntax, the old will be used less and less over time.  As to your second paragraph, that is really what this is aimed squarely at. Off the top of my head, people do import one unqualified name for Text, ByteString, Vector, Set, Map, and sometimes a view pattern plus a type name for Sequence. There are many more examples, of course, but these are core types we want people to be using regularly because their surrounding functionality has been so well tuned."
haskell,38vsef,edwardkmett,2,Mon Jun 8 04:57:39 2015 UTC,"I understand what it is aimed at, I just don't see the give problem with the current two line approach. Essentially it is one of those ""if we introduce additional syntax we can save a few characters when typing"" arguments to me which I never found very compelling considering the mental overhead of being required to be able to read both."
haskell,38vsef,acow,8,Mon Jun 8 06:30:16 2015 UTC,"I confess I find the proposal pretty ugly to look at, especially when compared with earlier proposals which just reused existing (conditional) keywords like  import Data.Map (Map) as Map"
haskell,38vsef,winterkoninkje,5,Sun Jun 7 09:51:09 2015 UTC,How does this differ from the proposal in the -cafe thread?
haskell,38vsef,winterkoninkje,7,Sun Jun 7 10:27:43 2015 UTC,It is pretty much the syntax the thread started with.  I was referring to not liking the andAs stuff that started later.
haskell,38vsef,Taladar,3,Sun Jun 7 10:56:05 2015 UTC,"Wow, that looks great! It's the same unqualified import syntax we've always had, but an as suffix creates a local namespace for the module being imported. This is really elegant!  You should carry the flag for this proposal. It's a pretty awesome job, and I've been hogging it. You get to meet interesting people and have lots of memorable interactions."
haskell,38vsef,winterkoninkje,3,Mon Jun 8 05:10:43 2015 UTC,"this seems like it is fixing a cultural problem, which is that in the haskell community we tend to have many ModuleName.ModuleName types  why do we not adopt the pattern from <oop-lang> where this type would be ModuleName.T  this is the number one problem i have when trying to do all my imports qualified. operators are also a problem, but i think it is reasonable to special case them because frequently they are ""syntax modification"" in spirit, if not deed"
haskell,38vsef,Taladar,10,Sun Jun 7 14:53:19 2015 UTC,"While that's the common style in ML (and one Henning Thielemann has advocated for since forever), I find it quite disgusting. I'd much rather have a single line at the top of my program saying import Foo.Bar.Baz (Baz) than to pollute the entire code base with extraneous .T suffixes on all my types."
haskell,38vsef,winterkoninkje,4,Sun Jun 7 22:47:07 2015 UTC,"A much better approach —and a radical one— would be to reconsider what type identifiers really identify: namely, a ""type"" is really a module collecting many disparate things (a name for the type, data constructors, record lenses, pattern destructors, induction principles, typeclass instances,...).   Given a first-class module system that can properly combine all these different facets of a ""type"", we can almost always use our name for the module rather than needing to project out a name of the underlying carrier from the module. The only time we need to refer to the underlying carrier is when we're constructing new type modules from old ones, or ensuring they unify in the right way (e.g., ML-functors, or newtypes). But in these cases, the important thing is to gain access to the identity of the carrier, not a name for that identity."
haskell,38vsef,autowikibot,1 point,Sun Jun 7 23:02:03 2015 UTC,There are many examples in Haskell of modules exporting more than one type. Your proposal of exporting one type power module feels quite limiting.
haskell,38vsef,Peaker,2,Mon Jun 8 06:32:45 2015 UTC,"I never suggested that every module should export only one type, nor that all modules constitute types. What I said is that every type identifier equipped with its associated desiderata forms a module.  Notably, even modules which happen to export a single type (or a single main type plus whatever associated types) should not be identified with type modules. Down that road the madness of OOP lies. The module for maps —containing a sum type, with private constructors Bin and Tip, and private patterns Bin and Tip, and the public function generating a Data module from the Data modules for its parameters, etc— should not be confused with the module which contains that type along with a large collection of operations over it. The conflation of these two modules is why we have such screwy rules about whether data constructors/patterns are available or not in client code, and how this impacts -XDerivingTypeable, etc. Nevertheless, if some library designer doesn't have problems with OOP or the attendant visibility issues of conflating these two modules, they're free to design a single module which considers all the operations over a type to be ""part of the type itself"" and hence can treat their library module as a type in order to take advantage of the pun."
haskell,38vsef,andrewthad,2,Mon Jun 8 20:24:41 2015 UTC,"I am confused about the modules you are talking about. They seem to be neither Haskell modules as in the ones defined in one file, with imports and export list,... nor algebraic modules."
haskell,38vsef,tomejaguar,2,Mon Jun 8 22:02:00 2015 UTC,"I mean whatever it is that causes us to use the same word for Haskell modules, Agda modules, ML modules, etc. A module is a particular sort of (dependent) record, a namespace which can be passed around. That many languages only allow one module per file is an unfortunate engineering concern."
haskell,38vsef,RedLambda,1 point,Tue Jun 9 00:20:48 2015 UTC,"Module (mathematics):       In abstract algebra, the concept of a module over a ring is a generalization of the notion of vector space over a field, wherein the corresponding scalars are the elements of an arbitrary given ring (with identity).  Thus, a module, like a vector space, is an additive abelian group; a product is defined between elements of the ring and elements of the module that is distributive over the addition operation of each parameter and is compatible with the ring multiplication.  Modules are very closely related to the representation theory of groups. They are also one of the central notions of commutative algebra and homological algebra, and are used widely in algebraic geometry and algebraic topology.     Interesting: Mathematics Mechanization and Automated Reasoning Platform | List of commutative algebra topics | List of abstract algebra topics | Hodge–Tate module   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
haskell,38vsef,chreekat,2,Mon Jun 8 22:02:29 2015 UTC,"Many many contexts (haddock, error messages, and more) do not qualify all names.  It is quite confusing to see just an unqualified T everywhere."
haskell,38vsef,lostman_,3,Sun Jun 7 21:05:09 2015 UTC,"If anyone needs an example of where this is frustrating, look at numeric-prelude, where every single module has a data type named C."
haskell,38vsef,taylorfausak,2,Mon Jun 8 13:36:11 2015 UTC,"i do not entirely follow. if i am not mistaken, in the haddocks / errors for that module, you would see T bare, but in modules that import it qualified it will be qualified in the errors as well as the haddock  do you think it is onerous to have to think of what module you are in when reading an error? maybe so, but i think it is inferred by context. either the error file path or the file you are in where your editor has set errors in the gutter, these disambiguate the problem quite well for me  edit: i am less sure about haddoc then ghc errors. investigating now to see if what you say is true"
haskell,38vsef,chreekat,2,Sun Jun 7 22:40:36 2015 UTC,in modules that import it qualified it will be qualified in the errors as well as the haddock   It won't be qualified in the Haddock.
haskell,38vsef,anders_,3,Mon Jun 8 06:07:37 2015 UTC,"Maybe we could have the convention of adding a type T = ... synonyms to modules which expose only one central type. On the other hand, what do we do for modules which expose more than one type?  Also, how would you keep apart Data.ByteString.T and Data.ByteString.Lazy.T? What module aliases would you chose (as B.T and BL.T are probably no sensible typenames)?"
haskell,38vsef,twanvl,2,Sun Jun 7 16:26:38 2015 UTC,"i think that modules with multiple types get treated the same as they did before, or maybe it now becomes a smell you can look at to say ""maybe this module should be broken up""  as for your bytestring example, i think once you embrace qualified imports it becomes not at all alarming to have  ByteString.T  ByteString.Lazy.T"
haskell,38vsef,kamatsu,3,Sun Jun 7 16:41:59 2015 UTC,"I thought about this for a while, and have a longer reply if you care to read it. I'll extract the most important pro and con here, though:  Pro: Removes the most common need for what I consider a surprising fact (namely, a module can be imported twice).  Con: Makes the difference between these two lines very surprising:  import Foo (f) as F import Foo as F   That ""con"" makes for a -1 all by itself. I would grimace every time I tried to teach it to a new Haskeller.  I like the idea of trying to improve imports, though. :)"
haskell,38vsef,fridofrido,3,Sun Jun 7 20:41:09 2015 UTC,"I'm sorry but I grimace every time I hear about ""teach it to a new Haskeller"" argument.  How many thousands of time do I have to  import qualified Data.Map as M import Data.Map (Map)  import qualified Data.Text as T import Data.Text (Text)   in almost every module I work with.  It looks like this should be solved by: https://ghc.haskell.org/trac/ghc/wiki/ModuleReexports  which enables reexporting modules with different names. So I'd just make a module Core which reexports a ton of stuff.  -- Control.Monad as Monad -- Data.Map as Map -- Data.Traversable as Traversable  I sometimes wonder about Haskell module names. What does 'Control' in Control.Monad really tell me? Just more letters to type. And Data.Traversable? Why Data?  import Applicative import Monad -- Monad, like he is, everyone sees import Traversable   Kudos to package maintainers that ditch the unnecessary prefixes!  import Pipes   That's nice."
haskell,38vsef,rdfox,2,Mon Jun 8 01:00:04 2015 UTC,"Hear, hear! The post Towards a better Haskell package agrees with you about Control.Monad:   Use a short top-level namespace. There is no need for long module prefixes when a creatively chosen package name suffices. A quick import Parsec is more convenient than import Text.ParserCombinators.Parsec. Top level namespaces like Control, Data, and Text rarely add anything."
haskell,38vsef,hvr_,1 point,Mon Jun 8 13:51:22 2015 UTC,"Your gripe about double imports and a weird top namespace fall into my category of ""I hate having to explain this to newcomers"", so I don't see why that is an invalid way of looking at things."
haskell,38vsef,twistier,3,Mon Jun 8 23:23:08 2015 UTC,Why not:  open import Data.Map as M using (Map)   ;)
haskell,38vsef,acow,3,Sun Jun 7 14:16:12 2015 UTC,I would love to have Agda style modules in Haskell as well. Nested modules would also be useful. But parameterized modules make little sense in Haskell.  One thing that Haskell does better than Agda is allowing multiple modules with the same name. So you can write  import qualified Data.Map as M import qualified MyExtraMapUtils as M
haskell,38vsef,hvr_,2,Sun Jun 7 14:36:55 2015 UTC,Can do that in Agda:  module M where    open import Data.Map public    open import MyExtraMapUtils public
haskell,38vsef,acow,1 point,Mon Jun 8 16:59:11 2015 UTC,"But parameterized modules make little sense in Haskell.   Personally I think parametrized modules would be very useful. For example, a very simple usage idea would be to specialize types: Write polymorphic library, but import it monomorphically -> better error message, less type annotations, and also possibly better performance (if the compiler can also specialize)"
haskell,38vsef,cocreature,2,Mon Jun 8 12:19:26 2015 UTC,"I've been playing with F# today and I have some thoughts:   Why not just make qualified imports available without the import? In F# List.map does what you expect, no import necessary. Can we just go back to Haskell98? import Data.List adds nothing to import List except keystrokes and line noise."
haskell,38vsef,nanothief,2,Sun Jun 7 23:00:45 2015 UTC,"Implicit imports are available in GHCi (only):   To make life slightly easier, the GHCi prompt also behaves as if there is an implicit import qualified declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the flag -fno-implicit-import-qualified."
haskell,38vsef,jP_wanN,2,Mon Jun 8 05:37:31 2015 UTC,I'd be happy with something much less ambitious:  import qualified Data.Map as M import M (Map)
haskell,38vsef,nanothief,2,Mon Jun 8 00:38:52 2015 UTC,"FWIW, I think that's a pretty valid request with new or old import syntax."
haskell,38vsef,RedLambda,3,Mon Jun 8 05:19:12 2015 UTC,woudn't that break swapping imports such as  import qualified Data.OldFoo as Data.Foo import qualified Data.Foo      as Data.NewFoo   if the LHS can refer to RHS aliases? Would the order of imports matter for deciding what M refers to?
haskell,38vsef,nanothief,2,Mon Jun 8 06:04:13 2015 UTC,"That's a really good point. One could probably come up with rules for allowing both uses, but they'd be complicated."
haskell,38vsef,Peaker,2,Mon Jun 8 14:18:10 2015 UTC,"While the syntax is arguably confusing, I don't have a problem with it so big +1 from me."
haskell,38vsef,nanothief,2,Sun Jun 7 06:50:49 2015 UTC,"How about import Data.Map (Map), * as Map for importing Map unqualified, and the rest qualified under Map?  This could be then made more flexible, eg  import Some.Module (*::types), func as F, * as FC   Would import all types unqualified, func as F.func, and the rest under FC.  To import everything qualified, import Some.Module (), * as FC would work (as well as the existingimport qualified Some.Module as FC)"
haskell,38twbp,niobium0,5,Sat Jun 6 19:57:25 2015 UTC,"I'm quit curious on answers about this too. I love the concept of extensible effects, but without the ability to nest ""safe effectful"" computations like writers and readers within in an existing effect stack like one can do with a monad transformer stack I have a hard time wanting to leverage it."
haskell,38twbp,dukerutledge,2,Sat Jun 6 21:57:41 2015 UTC,"I know you can do some magic with monad coproducts as per this talk, but there are some caveats with monads that aren't distributive. (Exactly what concrete caveats this implies is lost on me.)"
haskell,38twbp,PM_ME_UR_OBSIDIAN,13,Sun Jun 7 07:25:58 2015 UTC,"In general monads don't distribute over each other. If they did, then with such an   forall a. m (n a) -> n (m a)   we could write a new monad for their composition.  This is one way that monad transformers are born.   ReaderT is born from such a distributive law:  m (e -> a) -> e -> m a   WriterT is born from one in the other direction:  (e, m a) -> m (e, a)   StateT doesn't fit this mold, neither does ContT, so this isn't the only way to build a monad.  We can build a monad coproduct (for some effects) using the free monad approach Rúnar advocates for there, but not all of them, and the generalizations to that approach that add more cost us the ability to pass the laws for some of the other effects.  You can think of the mtl's classes as effectively providing the same coproduct / theory, and the concrete selection of an instance as picking a handler.  There are some monads for which we do have a good notion of a coproduct among them. These monads are what Ghani and Uustalu call ""Ideal Monads"".  Everything that can be encoded in that free fashion is ideal, but not all ideal monads are free."
haskell,38twbp,edwardkmett,3,Sun Jun 7 08:45:54 2015 UTC,"That was amazingly helpful, thank you so much!"
haskell,38twbp,PM_ME_UR_OBSIDIAN,5,Sun Jun 7 17:28:14 2015 UTC,I am very curious to hear some answers as well. That session types / indexed monads concept does look promising though..
haskell,38twbp,ocramz,3,Sat Jun 6 22:41:02 2015 UTC,"... packages which allow to leverage the type system for effectful programming purposes?    This is pretty vague. Do you mean paclages that encode effect restriction (extensibe-effects), or like libraries that encode effect interleaving (pipes/conduit)?"
haskell,38twbp,tWoolie,3,Sun Jun 7 07:14:48 2015 UTC,The former.
haskell,38twbp,seriousreddit,6,Sun Jun 7 20:37:51 2015 UTC,"My favorite implementation of effects systems like this (""algebraic effects handlers"") is in Sam Lindley and Conor McBride's Frank language.   Essentially, when an effectful primitive is called, one can imagine it as an ""exception"" being thrown to be handled by the closest enclosing effect handler, before computation resumes. It allows for a more natural style of effectful programming than the monadic style (application is just application rather than =<<), and programs can easily mix and match ""concrete representations"" (i.e., handlers) of effects."
haskell,38nooh,IQue,30,Fri Jun 5 11:48:33 2015 UTC,"Frederick's experiences echo that of many others who've taken the leap. All of these points echo our experience at fynder. Another couple of points to add (I'll add some more as I think of them):  You can get away with bad code at the periphery of your systems for longer. At fynder we had a pretty nasty data scraping and import utility that grew over time and became pretty unwieldy. However it still worked and was easy to change without breaking. It also fed data into a system that had a very strong guarantee of integrity so there was another line of defence. (I've seen /u/ryantrinkle say similar to this too)  You can go a long way with a small number great programmers laying out the types and the structure, with lesser able programmers ""filling in the gaps"" as they get up to speed. For example at fynder /u/ocharles came up with a great use of singleton types to make our socket.io communications safer [1]. Even though I could never come up with that from scratch, I was able to add to it and extend it quite happily after a 20 minute explanation (and some follow up questions).  You don't get either of those benefits with, say python, the language I use day to day at the moment. Once your python codebase looses a certain amount of cohesion, it's way harder to refactor your way out, and I think you end up staring down the barrel of a re-write a lot sooner. Equally there's no culture of common fundamental patterns (Functor, Applicative, Monad) that everyone understands so you can't really have a few rock stars implement the core of your system and people of lesser abilities code around the core. You end up having to code to the lowest common denominator whereas in Haskell you can program up to the strongest level more easily.  [1] https://ocharles.org.uk/talk.pdf"
haskell,38nooh,b00thead,26,Fri Jun 5 12:50:27 2015 UTC,"It can't be expressed enough IMO how good the refactorability of Haskell code is and how important that is for a business (especially in a startup environment). Unfortunately I think this property is a bit of ""you have to see it to believe it"" and it's really hard to explain to someone a) why it is that way and b) why it's important.  I do think it's something we as a community should get better at communicating though."
haskell,38nooh,theonlycosmonaut,18,Fri Jun 5 12:58:19 2015 UTC,"""Move fast and don't break stuff""?"
haskell,38nooh,cies010,6,Fri Jun 5 13:29:27 2015 UTC,"a) why it is that way and b) why it's important.   a) I usually make an example of a User model that had an age property. This being an obvious mistake we refactored it to birthdate.  After doing so my compiler (and sometimes the editor/IDE) can help me by guaranteed exhaustingly pointing me where the remaining occurrences of age are. In dynamic languages I need use multi-file find for this, without guarantees. (In Haskell I still use multi-file find for occurrences in the documentation I might have overseen). I proceed by explaining how this stretches to the browser side with something like GHCJS.  b) Importance is mainly understood by making a business case. Show 'm the money; or in this case, the stacks of money one does not need for making refactorings/testing/headachepills/sleepingpills."
haskell,38nooh,ignorantone,9,Fri Jun 5 18:44:10 2015 UTC,"For a) wouldn't most (any?) other statically compiled language (or at least the ones I'm familiar with, such as C++, Java) find such an error? This specific example does not seem like motivation to choose Haskell over most other statically typed languages.  Now if age was an int, and you changed age to daysEmployed, also an int, then you'd wrap it in a newtype to make sure you fixed up all use sites to handle the new meaning. The capabilities afforded by newtype is something that sets Haskell apart from the previous mentioned alternatives."
haskell,38nooh,kamatsu,9,Sat Jun 6 01:59:34 2015 UTC,C has newtypes.   struct newtype {   int contents; }
haskell,38nooh,pycube,9,Sat Jun 6 08:44:58 2015 UTC,"But it doesn't have -XGeneralizedNewtypeDeriving, which can be very useful for numeric types  (deriving Num for a newtype etc)."
haskell,38nooh,cies010,5,Sat Jun 6 11:17:41 2015 UTC,"Good point. I was showing the difference between Haskell and dynamically typed langs. C++/Java do have types, but are also more verbose and often a little more low-level then Haskell and the dynamic langs.  You've show already how to change the example, and /u/kamatsu has provided a C++ counter example.  I'd change the example into something that uses Maybe instead of null and of a -1 value to signify absence of a value. This is an easy to grok example to show clearly how a better type system catches some bugs.  Next up would be to explain that in Haskell it is possible reduce the kind of operations to only those that make sense as the type system can limit the possible side-effects."
haskell,38nooh,ignorantone,1 point,Sat Jun 6 09:55:56 2015 UTC,"Yeah, those are good examples."
haskell,38nooh,MitchellSalad,18,Sat Jun 6 18:33:01 2015 UTC,-- | Preprocess raw inputs and yield them downstream. preprocessInputs :: Monad m => Pipe RawInputs Inputs () preprocessInputs = do     rawInputs <- await     let refinedInputs = preprocess rawInputs     yield refinedInputs   Pfft.  preprocessInputs = Pipes.Prelude.map preprocess   Can I have a job now?
haskell,38nooh,quchen,5,Fri Jun 5 18:29:51 2015 UTC,"You already have a job. Writing Haskell. Don't be greedy! :-P  Looking at the function below that uses ($!!), maybe they forgot a strictness annotation there? If that was the case, the explicit map would make more sense.  On the other hand, you can just create a pipe that (WH)NFs everything flowing downstream as well, which is more compositional."
haskell,38nooh,MitchellSalad,5,Sat Jun 6 12:07:10 2015 UTC,I have a job writing Haskell? That's news to me!
haskell,38nooh,quchen,1 point,Sat Jun 6 17:38:21 2015 UTC,"You're not Neil Mitchell? Woops, I always assumed you were ..."
haskell,38nooh,Ari_Rahikkala,4,Sat Jun 6 21:54:42 2015 UTC,"For future reference, Neil Mitchell is /u/ndmitchell."
haskell,38nooh,augustss,1 point,Sun Jun 7 03:50:25 2015 UTC,He's not.
haskell,38nooh,beerdude26,18,Sun Jun 7 00:20:20 2015 UTC,"We were not focused on writing “beautiful code” or interested in solving challenges that weren’t real to our business, we wanted to build something that could make us money as fast as possible.   This is what I like to hear. This is what makes businesses choose Haskell.  EDIT:   I changed one line of code from  map outputParticipant parts  to  map outputParticipant partsusingparListChunk 10 rdeepseq   my thoughts (kind of NSFW)"
haskell,38nooh,Octopuscabbage,9,Fri Jun 5 11:52:54 2015 UTC,Parallel map is really the dankest shit ever.
haskell,38nooh,PM_ME_UR_OBSIDIAN,4,Fri Jun 5 15:57:02 2015 UTC,"the level of safety and guarantees that the language and compiler gave us was a clear win in an environment that was largely about numerical algorithms, mathematical formulas and data transformation.   Isn't that a problem space where you get almost no help whatsoever from type systems?"
haskell,38nooh,theonlycosmonaut,11,Fri Jun 5 16:56:44 2015 UTC,"I once ported some numeric calculations to the numeric package and found a minor bug thanks to the type system. You do have to opt in, but once you do you can get a lot of help from the compiler. It also lets you use type signatures as actual documentation which is pretty sweet.  EDIT: oops, I actually meant the dimensional package. Erk."
haskell,38nooh,Fylwind,17,Fri Jun 5 23:59:36 2015 UTC,"That's not really true. We had many types for different types of numbers, like Money, Percentage, Rate of Return (a more specific percentage) etc.. This all ensured we were using the correct dimensions at least, which can be surprisingly hard to get right in ""untyped"" numerical calculations."
haskell,38nooh,AndrasKovacs,7,Fri Jun 5 18:18:31 2015 UTC,Does this mean you end up with a lot of wrapping and unwrapping of these types?
haskell,38nooh,ignorantone,9,Sat Jun 6 03:03:31 2015 UTC,Data.Coerce helps a lot with that.
haskell,38nooh,codygman,5,Sat Jun 6 07:10:49 2015 UTC,"Besides coerce, the lens library can help make (un)wrapping less tedious."
haskell,38nooh,sambocyn,8,Sat Jun 6 20:58:58 2015 UTC,Well data transformations (and validation) with free monads give you a lot of help from the type system. In fact its what I'm doing at my day job right now.
haskell,38nooh,codygman,3,Fri Jun 5 22:26:18 2015 UTC,"can you give an example of that? I read the haskellforall posts in free monads. I get ""reinterpreting"" (like execution versus visualization), but not ""validation""."
haskell,38oy59,cobbpg,3,Fri Jun 5 17:15:53 2015 UTC,LambdaCube was one of my motivations to explore Haskell. Thanks for the good work!
haskell,38oy59,SrPeixinho,8,Fri Jun 5 18:53:53 2015 UTC,"We’ve lived with the EDSL for years, and believe me, we’ve spent a long time thinking about the issues. The bullet points on the website are admittedly kind of rushed, and they don’t tell the whole story. For us, moving towards an independent language has very important benefits:   The language is not tied to Haskell any more. It can be used in combination with any other language. This is an absolute must. We are not limited by Haskell’s type system, so we can create our own that matches the domain much better. With the EDSL we had to jump through elaborate hoops to be able to capture all the constraints we wanted to, and the error messages tended to be quite dreadful as a consequence (I personally got C++ template flashbacks sometimes). We don’t want a compromise where we sacrifice either domain modelling or usability, and a separate language allows us to reach a much sweeter spot. We can get much better compilation performance, because we can inspect assignments and don’t have to do silly things like recover sharing. Speedy compilation absolutely matters to us (it’s really non-negotiable if we are to compete with existing graphics programming tools), and that’s just not going to happen with an EDSL compiled with GHC. 3rd party libraries cannot be used in shader code anyway, so the loss of code reuse opportunities is not as big as it seems."
haskell,38oy59,divip,3,Sat Jun 6 00:51:44 2015 UTC,"Speedy compilation absolutely matters to us (it’s really non-negotiable if we are to compete with existing graphics programming tools), and that’s just not going to happen with an EDSL compiled with GHC.   Is re-implementing ghc and all the accompanying tools from scratch really faster than just improving ghc's performance?"
haskell,38oy59,gergoerdi,3,Sat Jun 6 08:50:52 2015 UTC,"Well, LambdaCube requires a rather different set of tools than Haskell, and it is a distinct language despite the similarities. If this wasn’t the case, we’d just stick to using Haskell in the first place.  Anyway, this is not just about GHC, but the fact that an EDSL approach turns non-issues like the aforementioned observation of sharing into nasty problems that force us to choose between bad compilation performance (exponential time just to build a graph) or bad usability (using awkward explicit let bindings or Template Haskell). Even assuming that GHC itself is blazing fast to compile and always generates high-performance output is not sufficient, because that’s just part of the story."
haskell,38oy59,csabahruska,2,Sat Jun 6 12:16:43 2015 UTC,"I'm sure I'm misunderstanding, but the website says it is haskell98 + stuff.  And the todo list seems to be mainly ""implement a whole bunch of stuff ghc already has"".  Did you write a compiler?  What is the compiler outputting?  Is it reduced to only outputting GLSL now?"
haskell,38oy59,divip,1 point,Sat Jun 6 20:06:31 2015 UTC,"I answer some of your questions. We wrote a compiler which outputs graphics pipeline description. We call this description ""Intermediate Representation"". Currently there are two interpreters for IR code: one for WebGL and one for OpenGL. Currently IR code cannot express arbitrary applications, only graphics pipelines (basically shaders + render calls). So LambaCube 3D is a language for describing graphics pipelines with Haskell98 constructions (e.g. functions, expressions, patterns, type classes, ADTs etc.)"
haskell,38oy59,divip,2,Sun Jun 7 00:18:28 2015 UTC,"Currently there are two interpreters for IR code: one for WebGL and one for OpenGL.   So, how do I use it?  Do I have to embed an interpreter into my application?"
haskell,38oy59,fruitbooploops,1 point,Sun Jun 7 23:01:09 2015 UTC,Basically yes. Another option is to transpile the IR to the language you’re using to write your application and compile it as part of your normal build process.
haskell,38oy59,fruitbooploops,2,Mon Jun 8 00:17:22 2015 UTC,Have you looked into using something like data-reify for observable sharing? Kansas Lava has been getting good mileage out of it.
haskell,38oy59,fruitbooploops,2,Mon Jun 8 04:37:37 2015 UTC,"I have tried it one year ago, but it did not play well with type level naturals (Nat kind) what we use in the EDSL."
haskell,38oy59,HKei,2,Sun Jun 7 12:38:53 2015 UTC,"We do not reimplement GHC. The current code-base of the LambaCube compiler is ~4.6 kLOC which is not comparable with GHC's code-base. I think modifying GHC (replacing its back-end, etc.) would cost lot more effort."
haskell,38oy59,fruitbooploops,2,Sun Jun 7 13:11:18 2015 UTC,"Hi, I am one of the authors. As I see it is possible that LambdaCube 3D can be fully Haskell98 compatible at some point, so some of the cons could be eliminated. I updated the homepage according to this. Note that we don't want to be GHC compatible which means that the evaluation order can be different (Haskell98 does not fix the evaluation order) and .hi files cannot read by the LambdaCube compiler."
haskell,38oy59,gfixler,1 point,Sun Jun 7 23:07:08 2015 UTC,"I don't really sympathize with you, they should be doing what's best for the platform, and targeting hobby users is clearly not their goal."
haskell,38oy59,eriksensei,5,Sat Jun 6 08:28:29 2015 UTC,"they should be doing what's best for the platform   I believe the point is that he or she feels that this is not what is best for the platform.  It is a big pile of negatives, with one very tiny and entirely subjective positive.   and targeting hobby users is clearly not their goal.   That is not clear to me, nor does it seem relevant at all.  What does hobby users have to do with the concerns raised?  I share those concerns and I am looking at it from a professional ""I want to use this to make money"" view."
haskell,38oy59,_deepfire,1 point,Sat Jun 6 01:01:55 2015 UTC,"I was assuming there were grander benefits, the person I responded to prefaced their comment by stating they were a hobbyist, which I took to mean these were primarily hobbyist issues, especially since they were the only ones upset. If they're making a move that's bad for time locked hobbyists, it's not a stretch to assume they're not targeting time locked hobbyists  Not to mention- this person doesn't seem concerned with what's best for the platform, but what's best for their use of the platform. Very different things"
haskell,38oy59,TotesMessenger,1 point,Sat Jun 6 01:14:03 2015 UTC,"the person I responded to prefaced their comment by stating they were a hobbyist, which I took to mean these were primarily hobbyist issues, especially since they were the only ones upset.    Being a hobbyist doesn't mean their concerns only apply to hobbyists.  And what makes you think they are the only person ""upset""?   If they're making a move that's bad for time locked hobbyists   ""If they are making a move that is bad for people with hair..."".  Look at the actual arguments put forth, not a casual mention of the fact that they are a hobbyist.  How is having to learn a whole not ""almost Haskell but not really Haskell and missing a bunch of stuff"" not a downside for a professional?   this person doesn't seem concerned with what's best for the platform, but what's best for their use of the platform.    I don't see anything like that.  Nothing in their post suggests that.  Obviously their motivation is to their own use of the software, everyone's is.  But you seem to be assuming that everyone else on the planet must be in complete disagreement for some reason.  All the downsides listed apply to anyone considering using it.  I do not want to learn a new language that is missing all sorts of features, tools, etc and can't interoperate cleanly with any other language, just so that the syntax can subjectively be a little nicer."
haskell,38p89t,joehillen,12,Fri Jun 5 18:16:53 2015 UTC,Fun fact: I built build.elastic.co which is written in Haskell using Spock.
haskell,38p89t,Mob_Of_One,6,Fri Jun 5 18:36:53 2015 UTC,"Y'all using Bloodhound anywhere? Has anyone at Elastic.co tried it? So far as I'm aware, it's the only viable Elasticsearch client in Haskell that has been put together (has the endorsement of the authors of prior attempts) and it goes further in speccing out the API as a datatype than the Scala clients I looked at before beginning on it."
haskell,38p89t,drewr,3,Fri Jun 5 19:04:51 2015 UTC,"We've tended to use direct HTTP through wreq for the small things we have, but we're not opposed to Bloodhound at all. In fact, because it exists we haven't seen much priority in creating our own. As we build out more stuff on Haskell we'll almost certainly use it and contribute. We need more people though."
haskell,38p89t,Mob_Of_One,6,Fri Jun 5 19:38:51 2015 UTC,"Do you think the deeper points (not strictly about a client library) regarding executable/testable/readable specifications will go anywhere? Not having a spec for the Elasticsearch API makes writing a client library for it feel very precarious.  As an example (I made this point in the GH issue, I'll repeat it here), there is a lot more I could do to enforce type-safety. For example, the document type / request type / reply type are all totally uncoupled and it's up to you to assert what you expect to get back. Ditto schemas <---> queries.  I haven't unified it under a GADT/fundep MPTC because I'm worried about API churn from Elasticsearch and because I don't have a concise and precise specification telling me what I can expect, so I'd have to develop all of it empirically and eat the cost/risk of the increased surface area with no guarantees about API component stability.  Now, I don't think this significantly tarnishes the utility of Bloodhound. The original problem was type-safe query construction and composition – that problem now has a reasonable answer where I do not think one previously existed but it burns my tail to ignore so many opportunities for improved type-safety because I don't know what ES is going to do now or in the future. That I no longer use Elasticsearch in my day-to-day means I don't even have the benefit of practical work driving me to find bugs/problems, so I have to sit on it and wait for my commercial users of the library to tell me what they want."
haskell,38owdh,Spewface,11,Fri Jun 5 17:04:52 2015 UTC,It would be possible with Associated pattern synonyms https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms. I don't know if it is currently being worked on though.
haskell,38owdh,Rafbill,2,Fri Jun 5 18:04:15 2015 UTC,FWIW I haven't even started working on this.
haskell,38owdh,gergoerdi,9,Mon Jun 8 07:21:19 2015 UTC,Maybe you could use an associated data type and then use a prisms as type class members to represent your constructors?
haskell,38owdh,paf31,7,Fri Jun 5 17:53:46 2015 UTC,"If we added the bidirectional syntax for pattern synonyms (did that go in in 7.10?) then you could use matching on the prism and 'reviewing' through the prism to build up and tear down the ""constructor"" even if the associated pattern synonym work never gets completed."
haskell,38owdh,edwardkmett,12,Sat Jun 6 09:06:17 2015 UTC,"It's in 7.10  class Foo a where   term1   :: Prism' a ()   term2   :: Prism' a Int   term3   :: Prism' a String   recurse :: Prism' a a  instance Foo Bar where   term1 :: Prism' Bar ()   term1 = prism (\() -> Bar1) $ \case     Bar1 -> Right ()     bar  -> Left bar    term2 :: Prism' Bar Int   term2 = prism Bar2 $ \case     Bar2 i -> Right i     bar    -> Left bar    term3 :: Prism' Bar String   term3 = prism Bar3 $ \case     Bar3 str -> Right str     bar      -> Left bar    recurse :: Prism' Bar Bar   recurse = prism BarR $ \case     BarR b -> Right b     bar    -> Left bar   The bidirectional patterns:  pattern Term1 :: () => Foo s => s pattern Term1 <- (preview term1 -> Just ()) where         Term1 = review term1 ()  pattern Term2 :: () => Foo s => Int -> s pattern Term2 a <- (preview term2 -> Just a) where         Term2 a = review term2 a  pattern Term3 :: () => Foo s => String -> s pattern Term3 a <- (preview term3 -> Just a) where         Term3 a = review term3 a  pattern Recurse :: () => Foo s => s -> s pattern Recurse a <- (preview recurse -> Just a) where         Recurse a = review recurse a   and  foo :: Foo a => a -> IO () foo Term1       = putStrLn ""term 1"" foo (Term2 n)   = print n foo (Term3 s)   = putStrLn s foo (Recurse f) = foo f   This has proven useful in my code"
haskell,38owdh,Iceland_jack,8,Sat Jun 6 17:19:24 2015 UTC,There you go then. I was waiting for it to go in to add a bunch of prism-based patterns to lens. I suppose it is time to think about their inclusion.
haskell,38owdh,edwardkmett,7,Sat Jun 6 17:49:55 2015 UTC,"Your code (although not completely clear for me, because you seem to have two different foo) reminded me of a technique I've seen in some of the papers by Oleg Kiselyov and Ken Shan employed to write down ""linguistic theories"" (some formalization of a grammatical combinatory machinery and a lexicon).  That technique/style was really a delightful discovery for me. Being also a theoretical linguist, I have always been unsatisfied with my attempts to express grammatical theories in a language like Haskell.  What were my perceived problems?.. (Simplified.) The meaning of lexicon items (words, morphemes) resemble functions. So I'm inclined to define them as functions (by the usual equations like f x = expr). But that doesn't capture that the lexicon is thought of as a closed set. (At least, think about the set of morphemes of a language.) I want guarantees that wherever I use a word (or a morpheme) in my code, I use one from the fixed set (and not an arbitrary function). This leads to another design: let the words/morphemes be constructors from an ""enum"" type representing the lexicon (like data Lexeme = Wolf | Fox | Big | Small | Go | Me), and write an interpret :: Lexeme -> Meaning function to assign meanings to them. Another related issue with ""words as functions"" was that apart from the meanings a word (as any sign) must be assigned other values like the pronunciation/spelling etc. This is solved by the data type approach.  But the data type approach has its drawbacks. The words should be typed (the types reflecting their combinatory syntactic properties). And the meanings have different types (the same reason), so we can't write an interpret function really, such that it would give meanings of different types. Ok, so we should go for GADTs insetad of a simple data type with nullary constructors then. But somehow I didn't like GADTs much (I can't remember now why; perhaps, I never really had a need to implement this).  Something that never came to my mind was the design I saw in a paper by Kiselyov and Shan(?).  Represent the lexicon as a class, its methods being the words. So, the types of each of the words are fixed. Now, different instances implement different ""sides"" of the signs (meanings, spellings), or perhaps their interpretations in different grammatical frameworks (different theories). (In the actual code, the class must be heavily parameterized, of course, by the functor-like types of the interpretation framework.)  Your suggestion seems to bring together the ""lexicon as a class"" and ""lexicon as a data type"" . I have no idea yet whether this could be nice for the things I'm thinking about."
haskell,38o0f7,nikita-volkov,13,Fri Jun 5 13:28:24 2015 UTC,"I wouldn't put them together like that.  Your type parameter is now neither co- nor contravariant and it's unlikley you'll be able to do anything useful with it.  If you write  newtype Codec a b = Codec (Decoder a, Coder b)   then you have what I call a ProductProfunctor though /u/edwardkmett may have a different name for the same thing. Your type parameters can vary independently of each other, but in general you will write code that consumes or emits a Codec a a where the parameters match.  [EDIT: Corrected username, thanks /u/rpglover64]"
haskell,38o0f7,tomejaguar,18,Fri Jun 5 13:51:35 2015 UTC,"You mean ""/u/edwardkmett"". I hear that if you say his username in a thread three times in pitch darkness during the witching hour, he appears and lensifies your current project, but curses you to never understand the lens library."
haskell,38o0f7,rpglover64,23,Fri Jun 5 15:07:47 2015 UTC,starts looking for projects by rpglover64
haskell,38o0f7,edwardkmett,4,Fri Jun 5 16:37:46 2015 UTC,It's essentially the same reason that /u/edwardkmett separates the positive and negative occurrences of a type variable in his article on PHOAS.  (The benefits in that case are probably more substantial than you'll get with a decoder though.)
haskell,38o0f7,tomejaguar,9,Fri Jun 5 14:37:05 2015 UTC,"With a little trick you can compose both with Applicative, with the use of a helper function for the decomposition (division). I use that for the Applicative instance in fclabels[0] and for a toy pickler[1] (parsing+printing or coding/decoding) library on top of that.  Your code would look a bit like this:  data User { name, address :: String, age :: Integer }  userCodec :: Codec User userCodec = Codec $   User <$> name    >- nameCodec        <*> address >- addressCodec        <*> age     >- ageCodec  nameCodec, addressCodec :: Codec String ageCodec :: Codec Integer   The idea is to have an Applicative instance for a possibly diverging type CodecD a b and a wrapper type Codec a = CodecD a a to close the type again for prettier composition.  data CodecD a b =   { code   :: a -> ByteString   , decode :: ByteString -> b   } instance Functor     (CodedD a b) ... instance Applicative (CodedD a b) ...  data Codec a = CodecD a a infix 5 >- (>-) :: (b -> a) -> Codec a -> CodecD a b   A bit like what /u/tomejaguar explains.  [0] https://github.com/sebastiaanvisser/fclabels/blob/master/src/Data/Label/Poly.hs  [1] https://github.com/sebastiaanvisser/pickler/blob/master/src/Pickler.hs"
haskell,38o0f7,sfvisser,5,Fri Jun 5 14:42:27 2015 UTC,"This is a nice approach.  I'm using ""product profunctors"" a lot in Opaleye, but the combination of Applicative plus >- operator provides perhaps a more pleasant interface.   data Codec a = CodecD a b   I guess you mean data Codec a = CodecD a a, as you wrote elsewhere."
haskell,38o0f7,tomejaguar,2,Fri Jun 5 14:47:58 2015 UTC,"Yes thanks, I wish reddit would type check my pseudo code. :)"
haskell,38o0f7,sfvisser,1 point,Fri Jun 5 14:48:55 2015 UTC,Thanks! This is quite interesting!
haskell,38o0f7,mightybyte,6,Fri Jun 5 16:31:15 2015 UTC,"You may already know this, but I feel obligated to mention that if you change Decoder to (ByteString -> Maybe a), then Codec is a prism."
haskell,38mxjw,acwalker,3,Fri Jun 5 06:40:51 2015 UTC,"ooo. No time to look at this in detail now, but this is very relevant to my interests."
haskell,38mxjw,stepcut251,3,Fri Jun 5 10:32:23 2015 UTC,"I have skimmed only over the README, but it seems like it was a great deal of fun to build, as well as I well-thought piece of software. Nice stuff!"
haskell,38mxjw,CharlesStain,5,Fri Jun 5 10:38:06 2015 UTC,Thanks! It was a great deal of fun to build. It's definitely a thrill when you first receive someone's voice - much like when you first build an analog radio.
haskell,38mxjw,desijays,4,Sat Jun 6 01:07:55 2015 UTC,Can someone tell me what this library is about? What is software defined radio? When would I want to use something like this...or does it have any other application? I read the readme on the Github page but couldn't understand much.
haskell,38mxjw,autowikibot,8,Sat Jun 6 07:20:43 2015 UTC,"https://en.wikipedia.org/wiki/Software-defined_radio  Usually, radios are implemented using analog components. With software defined radio, signal processing is implemented on a computer processor instead. This means that by simply changing the software you can have a completely different kind of radio.  You still need some hardware to digitise the signal coming from the antenna. Fortunately, this USB dongle exists: http://sdr.osmocom.org/trac/wiki/rtl-sdr which you can get on ebay for only $15.  You might want to use this library to listen to AM or FM radio, to listen to police or emergency services (if thats legal where you live) or air traffic control, or to listen to shortwave transmissions from the other side of the world. Real SDR libraries like GNURadio are capable of far more. An entire GSM stack has been built, for example.  For more cool stuff you can do with the cheap USB dongle, see: https://www.reddit.com/r/RTLSDR/"
haskell,38mxjw,int3_,4,Sat Jun 6 08:13:32 2015 UTC,"Software-defined radio:       Software-defined radio (SDR) is a radio communication system where components that have been typically implemented in hardware (e.g. mixers, filters, amplifiers, modulators/demodulators, detectors, etc.) are instead implemented by means of software on a personal computer or embedded system.  While the concept of SDR is not new, the rapidly evolving capabilities of digital electronics render practical many processes which used to be only theoretically possible.    Image i     Interesting: Tucson Amateur Packet Radio | 3.5G | GNU Radio | Demodulation   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
haskell,38p65g,musicmatze,4,Fri Jun 5 18:04:33 2015 UTC,Check out rest-core and rest-snap.
haskell,38p65g,mightybyte,1 point,Fri Jun 5 19:48:00 2015 UTC,api-builder might also be relevant.
haskell,38p65g,tejon,1 point,Fri Jun 5 23:23:10 2015 UTC,Also might be of interest to you: https://haskell-servant.github.io/
haskell,38mt0y,SrPeixinho,8,Fri Jun 5 05:54:24 2015 UTC,"Sure. I occasionally play with ULC myself (1, 2)."
haskell,38mt0y,roche,7,Fri Jun 5 10:56:30 2015 UTC,"given the adoration for types, I always feel like I'm offending someone when I talk about it   No, not at all. All functional programming stems from LC. Have a look at how many modern FP techniques are in this awesome LC/Church encoding book from 1975. Whoever has been telling you it's irrelevant doesn't know what they are talking about."
haskell,38mt0y,jaybee,5,Fri Jun 5 16:50:33 2015 UTC,Absolutely! I enjoy your posts on it :-)  Edit: blog would be great too!
haskell,38mt0y,statusfailed,1 point,Fri Jun 5 11:52:31 2015 UTC,"Sure, do it. I'll read anything vaguely Haskell-related that I can get my hands on."
haskell,38mt0y,MitchellSalad,1 point,Fri Jun 5 06:41:25 2015 UTC,I'd be interested.
haskell,38mt0y,cocreature,1 point,Fri Jun 5 06:58:13 2015 UTC,"Sounds good to me.  Especially given some of the related stuff you've discussed before, I'd be interested - and I definitely don't think it would be offensive or disruptive.  If you're unsure about that, and you're going to blog, I'd suggest setting up Google Analytics on your blog.  Not everyone votes on things on reddit, but the number of viewers / average time on the page stats can certainly be motivating :)"
haskell,38kuzk,RedditWithBorders,6,Thu Jun 4 21:36:19 2015 UTC,Please do elaborate on how you set-up and deploy to your DO droplet! :)
haskell,38kuzk,kjandersen,4,Thu Jun 4 22:18:27 2015 UTC,"I did deployment manually. I pretty much followed the README I created in my Github repo, except for one small change.  To run in 'production', I used upstart/initctl on Ubuntu following this SO answer. If you want your process to be automatically reloaded, I think you can add respawn to the configuration script.  Since I was running on a droplet with 512mb RAM, I had to create a temporary swap file, described in this SO answer, in order to install cabal and the dependencies.  I currently have no health checks in place for my website. It won't automatically respawn, either. I haven't noticed any performance problems (yet). I get about ~400 visitors per day, so I don't see performance being an issue just yet.  I'm starting small and scaling as necessary. I hope that answered some questions, but if you want to know something specific, I'll try to answer it."
haskell,38kuzk,k-bx,7,Fri Jun 5 02:45:52 2015 UTC,"Highly recommend, in order to save some money, to not run cabal on production server, but rather build project on a linux machine (or in a VM), and only transmitting binary to server.  This will: 1. save you time on compilation 2. save you money, since you can buy a smaller droplet for an app now, probably"
haskell,38kuzk,yitz,3,Fri Jun 5 05:58:20 2015 UTC,Any reason you didn't use keter? Seems just what you need here.
haskell,38kuzk,LukeHoersten,3,Sun Jun 7 18:35:14 2015 UTC,I recommend checking out https://www.terraform.io for DO and AWS deployment setups. I've been using it lately and it's awesome.
haskell,38kuzk,nulloid,4,Fri Jun 5 03:48:05 2015 UTC,"Were there any particular reasons why you chose DigitalOcean for hosting? (Currently I'm looking for hosting services, and I'd like to hear your opinion on DigitalOcean's services.)"
haskell,38kuzk,nulloid,7,Fri Jun 5 01:11:50 2015 UTC,"DigitalOcean is the most straightforward, simplest hosting provider that I've found. You can spin up a new instance (droplet) really quickly.  Also, after attending some hackathons in college, I was gifted with DO credit, which made it really easy to choose DO.  I've also used Amazon AWS, Heroku, and Google App Engine. None of them are nearly as easy to use as DigitalOcean for what I want to do. I've never had any problems with DigitalOcean, nor have I felt limited, but I have also never hosted a high-traffic application.  I'd say just give it a trial run if you can."
haskell,38kuzk,gilded_honour,1 point,Fri Jun 5 02:55:35 2015 UTC,Thank you for the answer. I think it suits my needs -I'll check it out along with OpenShift (which a number of sources suggested as well).
haskell,38kuzk,gilded_honour,3,Fri Jun 5 13:00:21 2015 UTC,What's it applicable for?
haskell,38kuzk,musicmatze,3,Fri Jun 5 03:41:48 2015 UTC,Mostly for language-learners who want to know the pronunciation of certain words/phrases. You could also attach the audio file to flash cards like in Anki.
haskell,38kuzk,herbadah,3,Sat Jun 6 04:43:43 2015 UTC,and why don't they go to google translate instead?
haskell,38kuzk,erikd,3,Sat Jun 6 12:12:24 2015 UTC,Because Google Translate doesn't have a button that lets you download the audio file. You have to know the URL to use.
haskell,38mr0z,theonlycosmonaut,2,Fri Jun 5 05:35:19 2015 UTC,"Author here. As well as just getting this package out there, I wanted to tender recommendations for making this usable from the client-side. I'd love to make this package usable in GHCJS, Haste, Fay, etc. as generating CUIDs client-side is a big use case. However, I'm unsure how compatible these technologies would be with each other and the native server-side approach this package implements.  Is it even a good idea to try to fit several targets into the one package?"
haskell,38or9x,wendobas,3,Fri Jun 5 16:31:40 2015 UTC,"With arrows:  > (length . filter (isInfixOf ""HH"")) &&& length $ replicateM 8 ['H', 'T'] (201,256)   I got the nums, but couldn't managed to just divide them. Neither uncurry (/) nor uncurry (%) nor uncurry (/) . fromIntegral &&& fromIntegral works. I hate numerical typeclasses of Haskell. I just want to divide two Num's, but now I have to read everything about Num and Integral and Fractional and Ratio and Float and Double and give explicit types and read exceptions of GHCi's inference rules etc."
haskell,38or9x,utdemir,2,Sat Jun 6 22:07:05 2015 UTC,"Agreed, the numerical type classes are a real burden to deal with frequently"
haskell,38or9x,fruitbooploops,2,Sun Jun 7 09:37:55 2015 UTC,You can use genericLength instead of length:  length :: [a] -> Int  genericLength :: Num n => [a] -> n
haskell,38or9x,Tekmo,2,Sun Jun 7 20:15:16 2015 UTC,"You could add a variable to value of replicateM and avoid hard coding the total length.  let options = replicateM 8 ['H', 'T'] in length (filter (isInfixOf ""HH"") options % length options"
haskell,38or9x,Guvante,2,Fri Jun 5 18:20:54 2015 UTC,"Avoiding the hardcoded 2^8 without a variable  (length . (filter (isInfixOf ""HH"")) >>= \a -> (a %) . length) $ replicateM 8 ['H', 'T']"
haskell,38or9x,trubple,2,Fri Jun 5 19:53:06 2015 UTC,"Here is a linear solution:  import Data.Ratio  hhs n = getsum (iterate hhs' (0, 1, 0, 1) !! (n-1)) % 2^n   where     hhs' (a, b, c, d) = (a+b+c, d, a+c,b+d)     getsum (a,_,c,_) = a+c   -- hhs 8 => 201 % 256"
haskell,38or9x,kuribas,2,Sun Jun 7 11:56:59 2015 UTC,let fib = 1 : 2 : zipWith (+) fib (tail fib) in 1 - (fib !! 8) % 256
haskell,38or9x,Syzygies,-4,Mon Jun 8 01:16:48 2015 UTC,(28 - 8) / 28 = 0.96875
haskell,38or9x,qnix,1 point,Fri Jun 5 20:16:47 2015 UTC,So there are 8 sequences of 8 coin flips that don't contain HH?
haskell,38llye,begriffs,3,Fri Jun 5 00:35:22 2015 UTC,Really interesting! Is there a way to download the video?
haskell,38llye,pimiddy,6,Fri Jun 5 08:05:09 2015 UTC,youtube-dl is able to do that:   [generic] 2015-06-03-haskell-continuations: Requesting header WARNING: Falling back on generic information extractor. [generic] 2015-06-03-haskell-continuations: Downloading webpage [generic] 2015-06-03-haskell-continuations: Extracting information [download] Destination: Continuation Passing Style in Haskell-129301223.hd.mp4 [download]  45.6% of 462.34MiB at  4.27MiB/s ETA 00:58
haskell,38llye,kqr,1 point,Fri Jun 5 09:47:20 2015 UTC,"Works great indeed, thanks!"
haskell,38llye,pimiddy,2,Fri Jun 5 11:08:04 2015 UTC,the link is http://player.vimeo.com/external/129301223.hd.mp4?s=7d047e5e32eb41d71cfad82086ee188f
haskell,38llye,heisenbug,2,Fri Jun 5 14:47:11 2015 UTC,"As a Haskell newb coming from javascript, I've spent most of the last 24 hours trying to find good resources on continuations and CPS. Thanks!"
haskell,38kl9z,heisenbug,15,Thu Jun 4 20:45:00 2015 UTC,"Idris's ""bang notation"" is enviable: http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf (page 22)"
haskell,38kl9z,maninalift,9,Thu Jun 4 21:02:52 2015 UTC,"For example, the expression. . .  let y = 42 in f !(g !(print y) !x)   . . . is lifted to:  let y = 42 in do y' <- print y                  x' <- x                  g' <- g y' x'                  f g'    I want that so bad!"
haskell,38kl9z,joehillen,5,Thu Jun 4 22:43:50 2015 UTC,You can almost do this by defining:  (!) = (=<<)   ... but it doesn't work for functions of multiple arguments
haskell,38kl9z,Tekmo,3,Thu Jun 4 23:55:01 2015 UTC,"Are the uses of this close to ""idiom brackets""?"
haskell,38kl9z,imz,7,Fri Jun 5 00:20:04 2015 UTC,"Idris also has idiom brackets, but !-notation is more expressive, I think, though more syntactically obtrusive."
haskell,38kl9z,rpglover64,7,Fri Jun 5 05:26:44 2015 UTC,"!-notation and idiom brackets target different abstractions. Idiom brackets are a notation for working with Applicative, while ! is for working with Monad."
haskell,38kl9z,davidchristiansen,5,Fri Jun 5 07:59:40 2015 UTC,"Right. What I meant by ""more syntactically obtrusive"" was that if you could express the same computation in both, [| f a b c |] is more pleasant to read than return f !a !b !c (which IIUC are more or less equivalent assuming a coherent Monad and Applicative instance.)"
haskell,38kl9z,rpglover64,4,Fri Jun 5 14:08:48 2015 UTC,Shouldn't it be return (f !a !b !c) if f is a pure function?
haskell,38kl9z,imz,2,Fri Jun 5 16:07:21 2015 UTC,Probably.
haskell,38kl9z,rpglover64,2,Fri Jun 5 18:06:19 2015 UTC,"Ah, I see what you mean.  Also, in the Idris prelude, return is just an alias for pure, so return (f !a !b !c) should indeed be the same!"
haskell,38kl9z,davidchristiansen,1 point,Sat Jun 6 18:17:07 2015 UTC,Very interesting!
haskell,38kl9z,imz,2,Fri Jun 5 06:03:49 2015 UTC,"Not nearly as pretty but....  {-# LANGUAGE NoMonomorphismRestriction #-}  import Control.Applicative import Control.Monad  (%) = (join .) . (<*>) (?) = (<$>) (!) = (=<<) (#) = (<*>) inc = return . (+ 3) a = return 3 gar a b c d = print $ a + b + c + d infixr 6 ! infixl 7 % infixl 8 ?,#  *> print ! gar ? a # (inc ! a) # a % a 15 ()   Some type classing magic might let this work with only a single operator, but that implementation is left as a thought exercise for the reader."
haskell,38kl9z,WarDaft,14,Fri Jun 5 01:12:56 2015 UTC,Excessive syntactic sugar causes cancer of the semicolon.
haskell,38kl9z,SkoomaMudcrab,9,Thu Jun 4 20:50:50 2015 UTC,"But Haskell's semicolon is vestigial anyway, who would miss it?"
haskell,38kl9z,tejon,6,Thu Jun 4 20:55:42 2015 UTC,"Not sure if you're joking. If serious, machine generated code would miss the simplicity of being able to use semicolons and braces. At least I think I read somewhere that's one reason for having them."
haskell,38kl9z,ignorantone,5,Thu Jun 4 21:31:06 2015 UTC,"Was joking, but yes, also useful in GHCi."
haskell,38kl9z,tejon,2,Thu Jun 4 22:41:25 2015 UTC,"I hear that quote a lot, and i still don't think it means anything.   are you saying that the code becomes harder to read? because I, for example, use lambdacase a lot, and it makes functions/expressions easier to read. and easy to turn an expression into a local function, and easier to rename functions, etc:"
haskell,38kl9z,sambocyn,6,Sat Jun 6 22:38:24 2015 UTC,Can you give an example with the rest of the do block (the ... in your example) filled in? I don't understand where that part goes in your notation.
haskell,38kl9z,gelisam,1 point,Thu Jun 4 20:56:24 2015 UTC,Ony the first line following the \do would be desugared (as shown above) the rest would be desugared by standard do rules.
haskell,38kl9z,gelisam,2,Thu Jun 4 21:46:00 2015 UTC,"But where does the rest of the the block go? Is it supposed to look like \do ('*' : rest) -> second_line? Where does the third line go? Or does the do begin an indented region in which the first line looks like an expression but is actually a pattern, like this?  \do x     second_line     third_line"
haskell,38kl9z,kamatsu,1 point,Fri Jun 5 01:49:25 2015 UTC,"Yes, like this. It would only eliminate the opposing arrows with their respective ""domain"" parts."
haskell,38kl9z,quchen,5,Fri Jun 5 07:14:26 2015 UTC,Dislike it. I don't see the pattern come up very often.
haskell,38kl9z,joehillen,5,Fri Jun 5 03:02:10 2015 UTC,"I don't see this pattern very often, and even if, I don't like the sugar. It makes the first line of do-notation behave in a special way, looking like a simple statement, when it is actually a binding statement. Since the rest of the potentially large do-block is going to be business as usual, this introduces an awkward special case.  (PS: Is that you, Gabor?)"
haskell,38kl9z,joehillen,2,Fri Jun 5 11:40:12 2015 UTC,"It changes the ""first line"" just like \expr -> case expr of {...} changes to \case {...}. But don't get me wrong, this is not a proposal, just gathering info.  PS: Yes :-)"
haskell,38kl9z,levischuck,3,Fri Jun 5 13:08:25 2015 UTC,Isn't pattern matching just sugar for case anyway? Why can't you use \case?
haskell,38kl9z,imz,3,Thu Jun 4 22:39:29 2015 UTC,"Because a pattern match failure in \case will error, while my suggestion happens in Monad (in future hopefully MonadFail) context, and thus provides a well-defined failure mode."
haskell,38kl9z,imz,4,Thu Jun 4 22:45:42 2015 UTC,Can't you add _ -> fail to the end of your cases?
haskell,38kl9z,quchen,4,Thu Jun 4 22:48:50 2015 UTC,"Of course you can, but that clutters my code with the uninteresting cases. The point of syntactic sugar is to focus on the business logic and hide the boilerplate."
haskell,38kl9z,imz,2,Thu Jun 4 23:00:10 2015 UTC,Sounds a lot like how Erlang shapes things into programming for what is expected and subsequent clarity.
haskell,38kl9z,imz,2,Fri Jun 5 12:19:48 2015 UTC,"I've never known that a pattern match failure inside a do wouldn't crash, but rather be accommodated in the monad!.. Is that really so?"
haskell,38kl9z,imz,5,Fri Jun 5 00:14:18 2015 UTC,"Yes. That's why there is a fail method in Monad currently. Look up ""desugaring monad do notation"" for more."
haskell,38kl9z,imz,3,Fri Jun 5 07:20:07 2015 UTC,"I think that's confusing. (I've written a related example above.) The compiler doesn't warn about non-exhaustiveness, but the code may ultimately ""crash"". That's a false illusion of safety when writing and compiling such code."
haskell,38k5qd,zandekar,6,Thu Jun 4 19:22:37 2015 UTC,"""For every complex problem there is an answer that is clear, simple, and wrong.""  Your suggestion assumes that you can reach each new sync-state continuously w/o accounting for major disruptive package version update waves or ""non-linear"" package updates"
haskell,38k5qd,hagda,1 point,Thu Jun 4 20:03:44 2015 UTC,"That does not mean it is wrong.  What is needed is conceptually a single repository of code where continuous integration happens, and where large scale, atomic refactoring happens.   The lack of large scale refactoring because package distribution is in a sorry state does not mean that continuous integration is a bad idea!"
haskell,38k5qd,hastor,3,Fri Jun 5 06:09:45 2015 UTC,You can't take an entire ecosystem of a language's libraries and do atomic refactorings as if it was all your own code. That just won't work at that scale.
haskell,38k5qd,Taladar,1 point,Fri Jun 5 08:21:27 2015 UTC,Why?
haskell,38k5qd,hastor,1 point,Wed Jun 10 21:49:12 2015 UTC,Mostly because you can't get everyone to change their libraries in a short time frame and you can't have a single person do it because of the variety of locations and access rights to source repositories.
haskell,38k5qd,Taladar,1 point,Thu Jun 11 07:44:50 2015 UTC,That's a lack of tooling only.  The size of haskell code on hackage is not a problem as these kinds of refactorings are done on much larger code bases regularly.
haskell,38k5qd,hastor,1 point,Sat Jun 13 00:47:43 2015 UTC,There will never be a tool that convinces everyone in the entire ecosystem of a language to give a single person commit access to their repos.
haskell,38k5qd,Taladar,1 point,Sat Jun 13 05:57:38 2015 UTC,"Debian doesn't have commit access to all upstream repos, but that doesn't seem to affect their ability to fix things.  Refactorings would be similar.  The maintainer can take or leave the patches, but the patches will be part of the ecosystem and used by 99% of the people.  This is similar to how 99% of people use Debian / Ubuntu and upstream is somewhat ignored in the sense that ""commit access"" is not such a big deal."
haskell,38k5qd,hastor,1 point,Sat Jun 13 19:03:25 2015 UTC,"Debian and Ubuntu do add their own patches, however their system is still fundamentally different to the one proposed here, maintainers of individual packages or limited parts off the distro fix local breakage (one package and it's dependencies), the one proposed here would use the system to create patches which would be required for the entire system to keep working at all."
haskell,38k5qd,Taladar,1 point,Sun Jun 14 01:20:47 2015 UTC,"Yes, it is not the same, and those patches would be required.  I'm just saying that ""author's control"" of their repo is not very important.  I downloaded hackage and put it into a repo myself in a few hours, and it's not a big deal at all.  I also did some simple refactoring of a breaking change using perl, and it also wasn't a big deal.  Snoyberg seems to be doing the same in stackage.  It's really not a big deal to do the actual fixes.  It is a lot more work getting patches accepted upstream, which is why it is better to abstract away upstream and put everything, conceptually, into a single repository.  I'm talking about what should be done to make hackage useful for professional use, when people's taste or preferences is much less important than not wasting expensive engineers' time.  It is simply wasteful and unnecessary with no real engineering benefits to allow the cabal/hackage chaos to continue.  FPComplete, or the commercial haskell group have the possibility to define a standard that is efficient, where something like stackage is used, which guarantees a simple invariant (things compile and tests pass), then gather all code in one giant repo so we can all move forward fast, and then those who don't want to be part of that can choose to develop better tooling where the invariant (things compile and tests pass) work for a wider set of constraints than the simple stackage model.  However, requiring lots of work to be done by each developer to allow for some theoretic benefit of some developer who doesn't want to follow the crowd is inefficient, and should be discouraged."
haskell,38k5qd,hastor,7,Sun Jun 14 19:36:14 2015 UTC,"What's the benefit of this workaround over just addressing the underlying issue, namely correcting incorrectly specified version bounds?"
haskell,38k5qd,RedLambda,1 point,Thu Jun 4 20:15:21 2015 UTC,Because there is no machine support for checking the validity of version bounds except for stackage?  When we get that tool we won't need to talk about version bounds as it all happens automatically. Until then we need something that does not depend on the almost always erroneous choice of a developer.
haskell,38k5qd,hastor,6,Fri Jun 5 06:13:36 2015 UTC,"Actually the http://matrix.hackage.haskell.org/ is exactly an attempt to get machine support for checking the validity of version bounds. As an arbitrary example, see http://matrix.hackage.haskell.org/package/purescript  And it's used to correct version constraints, rather than just to pick one single combination (though it could probably be used to do that too)."
haskell,38k5qd,dcoutts,5,Fri Jun 5 08:17:22 2015 UTC,"It can't all happen automatically. That would assume that everyone, in every package, has 100% automated test coverage, not just of their code but also of all required and all potentially undesirable behaviour."
haskell,38k5qd,Taladar,1 point,Fri Jun 5 08:23:19 2015 UTC,Running the tests that do exists for a given set of versions will in all cases give stronger guarantees than just guessing.  You're making perfect the enemy of good.
haskell,38k5qd,hastor,1 point,Wed Jun 10 21:48:49 2015 UTC,No...I am saying the benefits of this proposed tool are much smaller than you describe in your comment I replied to which is an important point considering the huge downsides and costs it would incur.
haskell,38k5qd,Taladar,11,Thu Jun 11 07:51:51 2015 UTC,"Requiring people to work with the latest sync-state to upload something is too restrictive.  Maybe I have a large package and I want it to work with the latest of everything except one particular package because upgrading to the latest version of that package would be too costly for me.  That's a perfectly reasonable situation.  Upgrading is not free and everybody makes their own value judgments in each case.  This whole sync-the-world notion is too centralized and not very feasible as an ecosystem expands and complexity increases.  What does work?  Version bounds.  They allow each package to determine and broadcast what things they work with.  They're simple, effective, and scalable because the work is distributed to each individual package maintainer.  Version bounds...use them religiously and keep them up to date."
haskell,38k5qd,mightybyte,3,Thu Jun 4 20:02:14 2015 UTC,"My own dead horse is adding a breaks-dependencies: field to library packages, with the same format as a dependency version constraint, which is defined as ""this library version may not be compatible with versions of itself which match this setting, but is guaranteed compatible with all other versions."" It always implies && > version and if omitted or otherwise invalid is set to < version. This means that without it, behavior is identical to current Cabal.  But if present, it allows this:  name: some-package version: 1.2.0.1 breaks-dependencies: < 1.1.0.0   to satisfy this:  name: older-dependent-project build-depends:   some-package >= 1.1 && < 1.2    -- defensive version bounds   Despite older-dependent-package specifying a dependency that excludes library-package-1.2.0.1, the library's author knows (and who could know better?) that the new version didn't break anything for a project built against 1.1.*, and can say so, allowing the dependency to still be satisfied with no work on the dependent side.  It's not panacea or proof against error, but it pushes the decision to a place where it can be made by fewer individuals, based on greater knowledge. It also removes the worry that some package maintainer didn't read, didn't understand, or just doesn't like the PVP, because they can still indicate the part of it that matters at compile time.  And once adopted, best practice for authors becomes to specify the single unique version of dependencies they're building against. The cleanest bounds possible.  And did I mention it's fully backwards compatible? I mean, I did, but just sayin'."
haskell,38k5qd,tejon,5,Fri Jun 5 00:39:42 2015 UTC,"It's quite common for a package to support multiple major versions of a build-dependency (by either not being affected by the breaking change, or by using conditional compilation via MIN_VERSION_...() or similiar).  How would that continue working with your breaks-dependencies? As an extreme example, what would happen if base started using breaks-dependencies: ...?"
haskell,38k5qd,hvr_,2,Fri Jun 5 09:50:04 2015 UTC,"The answer here is that breaks-dependencies: is misnamed for convenience; the contents of the field are cleaner when thinking of it as an exclusion, but the way it's used is inclusive.  base is a poor example right now because a major breaking change happened on the current version; base-4.8.0.0 should have breaks-dependencies: 4.8.0.0 which is identical to current behavior (same as if the field were omitted). It's also rigidly in line with the PVP for obvious reasons, which makes this all less interesting. :)  For a better example, let's go with text. As far as I can tell, it hasn't had an actual breaking change since 1.0.0.0 (possibly earlier). Let's say this pattern continues and text-1.3.0.0 is released with a snazzy new feature or an extra instance or something, but no breaks to existing code.  Now, cairo currently requires text >= 1.0.0.0 && < 1.3. Without breaks-dependencies, Cabal would reject this new version based on that constraint. Downstream users would have to stick with text-12.* until cairo is updated, and the cairo maintainers need to find out about the change, update their constraints, and push a new version -- and so does everyone else depending on text. It's not a huge amount of work for each of them, but the sum total comes out to quite a lot; for many packages there will be delays, some might even be abandoned and stay broken indefinitely; and the pisser is, it's a false positive and /u/bos knows that but really can't do much about it.  With this proposal, he can add breaks-dependencies: < 1.0 and now nobody else has to do any work. Behind the scenes, when Cabal's dependency resolver makes its list of versions that match a build-depends constraint, it would then scan later versions and append the list of what's backwards-compatible. I.e., where it currently checks the range against the available versions and gets:  1.2.1.1, 1.2.1.0, 1.2.0.6, (...), 1.0.0.0   It will then scan the text version list again, looking only at versions not on the current acceptable list and newer than its minimum, and look for breaks-dependencies ranges which do not exclude versions already on the list. This immediately finds that 1.3.0.0 does not break a dependency on 1.2.1.1, and the acceptable list for cairo is now:  1.3.0.0, 1.2.1.1, 1.2.1.0, 1.2.0.6, (...), 1.0.0.0   Everything else works exactly as it already does. Edit: the info on what version-equivalent was satisfied in the actual constraint can be retained for each package, and reported to the compiler when there are version checks in code."
haskell,38k5qd,tejon,3,Fri Jun 5 17:55:52 2015 UTC,But if they know that they don't break anything that builds against 1.1.* ... shouldn't it still be versioned in 1.1.*? Isn't that how versioning is supposed to work?
haskell,38k5qd,WarDaft,1 point,Fri Jun 5 01:28:53 2015 UTC,"You're not ""supposed to"" reference an expired pointer, so let's all go back to C++, right?  Seriously though, a gentlemen's agreement just doesn't work at scale, and that's really all the PVP is. It's not represented in the tooling at all, and the point of this idea is to cover that gap at least a little."
haskell,38k5qd,tejon,2,Fri Jun 5 02:13:19 2015 UTC,"My point is that they're equivalent. The exact purpose of updating to 1.2 instead of another 1.1.* is to declare that it's a breaking build. You're simply offering another way of saying the same thing that's no more likely to stick than the PVP. There's nothing at all stopping the exact same pattern happening with breaks-dependencies as happens with the version number. Then do we move onto a third field called really-breaks-dependencies-for-sure-this-time? If someone is misusing the existing system, then they'll misuse the exact same system phrased slightly differently."
haskell,38k5qd,WarDaft,1 point,Fri Jun 5 13:04:25 2015 UTC,"They're equivalent in the same way that doing long division on paper is equivalent to using a calculator. Yes, you get the same result if no mistakes are made. But one way takes longer and has a much higher chance of mistakes. Why favor that way?  Presumably if this were to happen, cabal configure would include it. That's already an incalculable improvement in awareness of its existence over the PVP, never mind that this field has a clear-cut definition with no potential for arbitrariness or misunderstanding or disagreement; in fact, its use fixes those by establishing a concrete shared context about what's potentially broken and what's not. If that context happens to match the PVP, nothing's lost. If it doesn't, something is gained."
haskell,38k5qd,tejon,1 point,Fri Jun 5 18:08:42 2015 UTC,Packages usually break something when they make a significant version change. Whether or not a dependent package breaks depends entirely on which subset of the other package's API is used in that package.
haskell,38k5qd,Taladar,1 point,Fri Jun 5 08:20:17 2015 UTC,"Significant version changes are also frequently used to indicate major new features, even when they don't break anything. That gives false positives, and creates a whole bunch of needless work. Long example involving text elsewhere in this thread.  Edit: The subset issue is a different topic entirely. Haskell packages are often too big and fragile. The orphan instances problem has made this an unfortunately attractive pattern."
haskell,38k5qd,tejon,2,Fri Jun 5 17:58:59 2015 UTC,"Significant version changes are also frequently used to indicate major new features   Those major new features also frequently include breaking changes.  So that case is fine as things are.  My experience is that this situation you are trying to address is rather rare.  It does seem to have happened in the case of text, but that's just one example.  Yes, it caused a lot of pain, but once people figure it out they bump their version bounds and the problem is behind us.  I'm sure /u/bos will be more careful in the future to make sure he's not needlessly doing major version bumps."
haskell,38k5qd,mightybyte,1 point,Fri Jun 5 18:47:32 2015 UTC,"The point was that the author of the dependency will often say something is a breaking change (and be correct) while it is not a breaking change for your use of the dependency. That makes the author of the dependency a bad source for that kind of information.  The major version change without any breaking changes you mention does happen but I would argue that it happens much less frequently, even less so if you include the minor version number as well which usually signifies breaking changes too."
haskell,38k5qd,Taladar,1 point,Fri Jun 5 18:18:18 2015 UTC,"I don't see how this is relevant, though. breaks-dependencies will never cause a break that doesn't already exist; it only mends false positives (and perhaps rare false negatives) based on different interpretations of (or simple failure to use) the PVP. The worst case is identical to the current environment."
haskell,38k5qd,tejon,1 point,Fri Jun 5 18:35:21 2015 UTC,It is relevant because major effort and complexity for fixing a rather small percentage of the cases might not be worth it.
haskell,38k5qd,Taladar,4,Fri Jun 5 18:52:26 2015 UTC,Who is going to pay for all this compilation? I'm not sure if you understand the magnitude of what you're asking for.
haskell,38k5qd,ReinH,1 point,Thu Jun 4 20:52:51 2015 UTC,Other issues aside.. Some of the compilation pain could be eaved by only type checking things and not actually doing any code gen...  Of course that means no tests could be run.
haskell,38k5qd,stepcut251,1 point,Fri Jun 5 00:04:52 2015 UTC,Who is going to pay for all this compilation?   Probably Travis CI? Compiling a few reverse dependencies on every release seems like a lot less effort than compiling every dependencies on every commit.
haskell,38k5qd,gelisam,3,Fri Jun 5 02:44:17 2015 UTC,"Let me tell you, it's not just a ""few reverse dependencies"" we're talking about...  As I'm working on http://matrix.hackage.haskell.org/ I'm currently facing to compute all install-plans which are affected by a new addition (or even just a .cabal revision) injected into the Hackage package pool, and that's far from trivial (even though it may appear so, if you have something like http://packdeps.haskellers.com/reverse/ in mind, which is a very oversimplified reverse-dependency report). And a very significant amount of cpu time actually goes into re-solving the install-plans to decide whether a rebuild is actually needed."
haskell,38k5qd,hvr_,-1,Fri Jun 5 09:23:39 2015 UTC,See my other comment. One full stackage build <= 1 minute of high paid consulting time. For an incremental build we are taking about seconds.  Should we put the alternative cost of Haskell programmers' time at $1 USD per hour?  It makes complete sense for any commercial enterprise with only a single employee to sponsor this.
haskell,38k5qd,hastor,3,Fri Jun 5 06:26:20 2015 UTC,"See my other comment.   You've made a bunch of comments. The polite thing to do would be to link me to the one that you want me to read.   For an incremental build we are taking about seconds.   For a sufficiently large number of seconds, sure. Similarly, the sun will also explode some seconds from now, which brings me back to my original comment about magnitudes.  You don't seem to have an understanding of the how much time, cpu, and memory it actually takes to compile haskell packages, the size of a median dependency graph and thus the amount of compilation involved, how much time and effort it takes to even generate a full install-plan for a median size dependency graph, the algorithmic complexity of generating an install-plan based on graph size and how that impacts 95th% performance, or the full lifecycle cost of building, running, and maintaining a system that would do all of these things (the idea that you would only have to pay for the time actually spent compiling is a fantasy).  I suppose this is all missing the point though. Even if you had an oracle that could magically and instantly tell you all of these things, this design still wouldn't actually solve the problem. It's unfit. See various other comments.  But even that is missing the point. Not only would this system not work, it isn't even the system that we want. The point isn't to optimize for a system where ""every developer and user would be using similar versions of the software"". The point is to make possible a system where individual developers are able to use and release different versions of the software."
haskell,38k5qd,ReinH,2,Fri Jun 5 22:10:12 2015 UTC,How does one do backward compatibilty breaking updates in this case? You can't just stop doing updates to your package because other packages (that might not even be maintained anymore) depend on your package.
haskell,38k5qd,cocreature,0,Thu Jun 4 19:41:15 2015 UTC,You would just upload it as normal and if it compiles/tests it would become part of the new sync-state. When people sync they will pick up the compatibility breaking version and it will be ok because they will also pick up the dependencies that work with it and everything will be consistent.  If someone is depending on an older version of your software they will notice they are not part of new sync-states and so will update their software and it will become part of the new sync-states.  There could also be a history of sync-states so if you want some old package you could ask for the most recent sync-state containing a working version of that package.  Unmaintained software preventing new sync-states because they don't work would eventually be booted out to allow new sync-states. They could then become part of a historical archive.
haskell,38k5qd,Taladar,2,Thu Jun 4 20:03:01 2015 UTC,"When people sync they will pick up the compatibility breaking version and it will be ok because they will also pick up the dependencies that work with it and everything will be consistent.   No they won't, not unless the authors of the dependencies between your package and their package all updated their packages already. It would essentially block anyone from uploading a new version of their package that still depends on the old version of your package and intermediate dependencies."
haskell,38k5qd,chrisdoner,2,Fri Jun 5 08:33:31 2015 UTC,"I'm quite sure you just described Stackage. Replace ""sync-state"" with ""snapshot"". What differs is the granularity, i.e. Stackage produces a snapshot nightly because it takes a few hours to compile and run tests. Doing that for every package upload would require much more computing power. In any case the only things that end up in a snapshot are packages known to compile and pass tests together. Also typically uploading a package breaks other packages. E.g. this doctest upload broke the listed packages in the sense that their upper bounds are not satisfied. Each author will now review whether they can indeed bump their dependency and go ahead. Once done, a full build (as opposed to just a version constraint check) will kick off."
haskell,38k5qd,hastor,1 point,Thu Jun 4 21:54:51 2015 UTC,I'll just note that a few hours of computer power on Amazon's most high end machine costs about 60 seconds of ekmett's time.
haskell,38k5qd,RedLambda,1 point,Fri Jun 5 06:20:30 2015 UTC,"I don't agree with overloading the term package breakage to also include the expected event as per PVP that a new uploaded major version release of a package simply isn't yet allowed by another package's version constraints. The package isn't broken, there's still a perfectly valid install-plan available, just not with all the latest package versions..."
haskell,38k5qd,yitz,1 point,Thu Jun 4 23:05:37 2015 UTC,"Furthermore, there is an install plan that does include the new release if it is in fact compatible - use --allow-newer.  It is a fallacy that PVP constraints prevent anything. They just add expressiveness and predictable semantics to version bounds. The set of install plans available is completely a function of the features available in your build tool for finding them.  The misconception that PVP is limiting comes from limitations of cabal as a tool in its early days."
haskell,38k5qd,hastor,1 point,Tue Jun 9 22:03:58 2015 UTC,"It is an improvement, but being totally hands off other people's code is not going to work. Other packages might simply be buggy in how they use your library and you need to be able to patch them.  Introducing some invariant checking is good, but there is also a social component around fixing broken code and being able to do large scale refactoring on Hackage."
haskell,38k5qd,imalsogreg,1 point,Fri Jun 5 06:05:18 2015 UTC,"There is something I like a lot about your idea - automated dependency bound twiddling and test-suite running. Less fond of making developers participate directly and having a single sync-state. What do you think about having dependency-bound twiddling and test-running done by a third-party server? And instead of there being a single sync-state goal, the system just logs the outcomes for whatever combinations of dependencies it tried to use for a build. (testing all combos wouldn't be possible of course - you'd use some heuristics to strategically test certain dependency bound tweaks). The server could provide devs with modified versions of their libraries' cabal files with loosened bounds still passing tests (or even allow the server to modify their Hackage packages on their behalf if they're brave)."
haskell,38g0ow,drwebb,4,Wed Jun 3 23:40:43 2015 UTC,Hmm no screensoths no example reports? Would be nice to see what that tool produces...
haskell,38g0ow,svenheyll,8,Thu Jun 4 16:16:29 2015 UTC,Amazing: on time and without bugs. Added bonus - it'll also prove to be maintainable over time.
haskell,38g0ow,mallai,8,Thu Jun 4 02:11:38 2015 UTC,How did they prove the abcense of bugs? I would like that tool!
haskell,38g0ow,tomasos,3,Thu Jun 4 08:18:27 2015 UTC,"I'm guessing that when they say    delivered it defect-free into a production environment where it has proven robust    they mean that unlike previous projects, they've delivered it with no known flaws, and they're mentioning it because they're more used to not meeting all design goals in version 1."
haskell,38g0ow,_AndrewC_,3,Fri Jun 5 08:33:19 2015 UTC,"Yep, that makes sense. I was just poking a bit at the old 'we have no bugs' as opposed to the more correct 'no known bugs' :)"
haskell,38g0ow,tomasos,2,Fri Jun 5 09:54:23 2015 UTC,They just ran their lingo thing on all possible inputs duh.
haskell,38g0ow,jberryman,1 point,Thu Jun 4 17:33:49 2015 UTC,I guess they didn't get the Haskell memo about avoiding success... =)
haskell,38gxjc,spindakin,7,Thu Jun 4 03:22:13 2015 UTC,"I'm pretty sure if you can work out a patch for how to do it they'd accept it.  At the very least, file an issue with the GHC tracker at least to remind folks that this is an issue and subtly prod it along."
haskell,38gxjc,edwardkmett,6,Thu Jun 4 09:35:06 2015 UTC,"Checking for duplicate issues on Trac turned up a comment explaining why this is the way it is right now:   I had a brief go at implementing local declaration splices but soon realized that implementing this involves quite a bit of replumbing. The splices would have to break up mutually-recursive groups within class, instance, and let declarations, and that would require changes to several bits of HsSyn. So, I settled for just fixing the panic and waiting for someone to scream loudly that they need this feature.   This is talking about $(...) splices, which I thought had different behavior from quasiquoters (splitting up which declarations can be referred to where in a module). However, GHC HEAD (but not 7.10.1) seems to treat quasiquoters as syntactic sugar for untyped splices now (cf. #10047), which has me rather confused. Either way, there doesn't seem to be a separate ticket for this yet, so I'll submit one in the morning.  edit: Yipes, the fix for #10047 seems to have introduced a nasty regression, breaking the name resolution behavior for quasiquoters. This should work, and does on 7.10.1:  {-# LANGUAGE QuasiQuotes #-}  thing = okay [wow|stuff|] okay = 3   ...but it produces an error on GHC HEAD:  /tmp/runghcXXXX1804289383846930886.hs:3:9: error:     Not in scope: ‘okay’   Guess I'll be submitting two Trac tickets in the morning..."
haskell,38gxjc,edwardkmett,4,Thu Jun 4 10:42:09 2015 UTC,"Historically, splices partitioned your file top to bottom. This lets you use things defined in a splice in the module and vice versa, but causes issues like this, (further back you couldn't do either of those things). I wasn't even aware they changed that in 7.10.1. Neat."
haskell,38gxjc,edwardkmett,3,Thu Jun 4 13:42:38 2015 UTC,"Normal $(...) splices still behave that way in 7.10.1, it's quasiquoters that aren't supposed to have the restriction. I believe they've had that property since they were introduced, which has been one of the main advantages in using them over $(...) splices."
haskell,38gxjc,sclv,1 point,Thu Jun 4 15:16:33 2015 UTC,Good to know. I pretty much splice my way through everything.
haskell,38gxjc,chrisdoner,4,Thu Jun 4 22:13:04 2015 UTC,"Will do! Both the ticket and investigating a patch, when I get the time."
haskell,38ecmr,cocreature,22,Wed Jun 3 17:36:44 2015 UTC,"This is why I'm still optimistic about the way Nix-based solutions (well, cabbage) work. I host a binary cache of Stackage, and a user can build against a Stackage release and download binaries. But the user can also build without any additional constraints and still benefit from the binary cache in that whenever the solver would build a package identical to that specified by Stackage, it is pulled from the binary cache. You also build up your own local store of built packages, so everything grows organically without closing the world."
haskell,38ecmr,acow,7,Wed Jun 3 18:06:34 2015 UTC,I love this. And I agree with the article that curation by itself is insufficient for some people's needs. But why not reap the benefits of curation and customization? No need to throw the baby out with the bathwater.
haskell,38ecmr,drb226,8,Wed Jun 3 18:51:24 2015 UTC,"Absolutely, as I keep saying, the two major solutions to cabal hell are nix-style management and curated collections. We need both.  Yes that's partly because you can't always live inside the cozy world of a collection curated by someone else, sometimes you need bleeding edge rather than stable, or just different things from other people. Or perhaps you're the person trying to make a new collection that works with a about-to-be-released ghc version or whatever.  And we can do nix-style management and curated collections either integrated in cabal/hackage or on top. There are people actively pursuing both approaches for both solutions."
haskell,38ecmr,dcoutts,6,Thu Jun 4 14:18:53 2015 UTC,"In what situations would you say we need curated collections?  In other words, can you (somewhat) precisely characterize the situations where curated collections provide something not achievable by one of the other solutions you mention?"
haskell,38ecmr,mightybyte,6,Thu Jun 4 14:29:33 2015 UTC,"Perhaps 'need' is too strong, but there are many situations where users would be happy to live in a world of stable packages that are managed by someone else. Yes it takes flexibility and choice away from them, and it cannot work for every obscure or latest package, but it can work for a big enough set of users enough of the time to be very useful.  It's almost exactly the same as the distro model. You use debian stable or testing, and in addition to removing the work of building things, it's removed the work (and choice) of which versions of things to use. That doesn't work for everyone, or for all packages, but it works for many users.  What I want is for it to be easy to use collections (including adjusting and combining them), and be easy to define and distribute them, and for the cabal ui to help with that, e.g. in the error cases and in making the configuration more explicit rather than having to be an encoding in terms of other more general things.  I should also say that I think having accurate bounds on the upstream packages is still required. I'm not suggesting we move to a model where we only use collections and have no accurate bounds in .cabal files. There are still plenty of cases where collections are not a solution and we need to know the more general bounds and find solutions outside of a curated collection."
haskell,38ecmr,dcoutts,3,Thu Jun 4 14:49:11 2015 UTC,"I suppose part of the problem is that the tooling isn't ready yet. I use cabbage every day, but I still need to ensure it works smoothly on Ubuntu, and start populating the binary cache for Linux platforms. I've received an offer to provide a Mac build box that will become available in a few weeks, then it's a matter of automating the Linux builds, too. I don't think there's any willingness to piggyback on Nix as the package manager for the Cabal build system, but its Windows support is seeing some attention, so there is a tiny glimmer of hope that we could offer binaries for Windows, too.  I think the interplay between Stackage curation providing a basis for binary caches and the free-for-all of hackage riding on Nix is really fantastic."
haskell,38ecmr,acow,5,Wed Jun 3 21:16:13 2015 UTC,"Vishal Agrawal is currently working on ""Nix-like"" features for Cabal as his Google Summer of Code project."
haskell,38ecmr,spindakin,7,Thu Jun 4 07:58:51 2015 UTC,"Yes, I tend to think that a nix-like approach will ultimately prove to be the best solution--or at least one of the biggest pieces of the puzzle."
haskell,38ecmr,mightybyte,9,Wed Jun 3 18:13:26 2015 UTC,"The work to integrate it into cabal is being done as we speak, which looks promising!"
haskell,38ecmr,Crandom,7,Wed Jun 3 18:28:00 2015 UTC,"Yeah, I was really glad to see that included in this year's batch of Google Summer of Code projects."
haskell,38ecmr,mightybyte,5,Wed Jun 3 18:32:01 2015 UTC,"A big issue is whether two versions of a single package should ever be used to compile a program. Say package B depends on package A version 1 and package C depends on package A version 2, and you depend on packages B and C. You could compile B with A.1 and C with A.2. However this does not work if B and C expose details of A, for example if one of the functions in B returns a value of a type defined in A, and one of the functions in C takes a value of that type, you cannot safely pass that value from B to C, even if the types still match. Maybe A.1 has a different internal invariant on that type than A.2 has, and passing a value from A.1 to A.2 may cause errors. On the other hand if B and C both depended on the same version of A you would want to allow passing those values from B to C. And if either B or C only used A internally then you would also allow B to depend on A.1 and C on A.2.  I think a proper module system automatically solves this issue. If some module B only uses A internally, then only the implementation of the module depends on A, and the signature of B does not depend on the signature of A. If B exposes details of A then the signature of B does depend on the signature of A. So this would give you precisely the right criterion for when it is safe to use multiple versions of the same module even in an arbitrarily complicated network of modules that depend on different versions of other modules."
haskell,38ecmr,julesjacobs,3,Thu Jun 4 00:24:34 2015 UTC,"What if A.1 and A.2 provide different implementations of a function but does not define the types involved, e.g. the change of starting indexing from 1 instead of 0 as in the latest srcloc release? This doesn't seem bullet proof to me and could lead to bugs that are very hard to track down."
haskell,38ecmr,bergmark,3,Thu Jun 4 01:35:00 2015 UTC,"You could add a dependency on A in the signature in that case, even though that dependency would not be necessary for the signature to compile.  Arguably if you want data to have a library specific invariant you should wrap it in its own type, which would force you to add that dependency if you are passing those values in or out of your module."
haskell,38ecmr,julesjacobs,2,Thu Jun 4 01:50:34 2015 UTC,I thought the backpack work was a prelude to offering the ability to distinguish internal and external dependencies (i.e. a dependency is external if one of its types appears in a downstream package's exposed definitions). This would be inferring a de facto signature rather than an explicit one.  It seems like this would also be a boon to tooling that automates PVP compliance to some extent.
haskell,38ecmr,acow,5,Thu Jun 4 00:39:51 2015 UTC,"cabal was not designed for package curation and freezing. These features have been hacked in and Stackage has been iterating on which hack it uses to peg dependencies (remote-repo, cabal.config, now cabal.sandbox.config).  So I don't see a problem here with curation per se; this seems like a UI/UX problem. cabal-install doesn't tell the user where something is pegged (or even explicitly that it is pegged) or suggest any reasonable course of action (or take any automated action).  Fundamentally cabal-install has no knowledge that curation is going on. Tooling that understood package sets could  present a different UI/UX and help users get the packages they need for their build."
haskell,38ecmr,eegreg,6,Wed Jun 3 19:50:45 2015 UTC,"cabal-install doesn't [...] suggest any reasonable course of action (or take any automated action).   IMO, this (i.e. explaining why the solver couldn't find a solution) is a difficult problem, and certainly does not have a unique answer (somtimes it's just N constraints forming a contradiction when combined, relaxing any single of those constraints can unlock a solution already -- but which of those relaxations is the most desirable one?), since the cabal build-dependency specification language is rather rich with its version ranges and the dynamic cabal conditionals (i.e. automatic cabal flags).  Do you have an algorithm/heuristic in mind, by which the cabal solver could compute a suggestion?"
haskell,38ecmr,hvr_,5,Thu Jun 4 06:21:31 2015 UTC,"Stackage has been iterating on which hack it uses to peg dependencies (remote-repo, cabal.config, now cabal.sandbox.config)   Those three things you mention are all features explicitly programmed into cabal to allow dependency pegging."
haskell,38ecmr,drb226,11,Thu Jun 4 00:53:13 2015 UTC,cabal was not designed for package curation and freezing. These features have been hacked in   How is the cabal.config freeze file a hack?  I think it's a perfectly reasonable solution to the problem of fixing yourself to a certain set of dependencies.  This user would have gotten the same result regardless of what method of curation he used.   So I don't see a problem here with curation per se; this seems like a UI/UX problem.   Well then we must be using a different definition of curation.  In my mind curation means that you restrict yourself to certain versions of certain packages that have been verified to work together.  That was exactly the problem in this case because the restriction disallowed the versions that the user actually needed.
haskell,38ecmr,mightybyte,3,Wed Jun 3 20:36:28 2015 UTC,"There is a difference between dependency pegging and semantically understanding that there is a curated package set.  It should be easy to treat a curated package set as a strong preference rather than a hard peg and to be able to suggest to the user how they can go outside that preference in the most conservative way possible to satisfy a build. Theoretically this could be done in the pegging case also, but the tool no longer knows whether you manually changed things in the cabal.config"
haskell,38ecmr,eegreg,5,Thu Jun 4 01:17:50 2015 UTC,"It should be easy to treat a curated package set as a strong preference rather than a hard peg and to be able to suggest to the user how they can go outside that preference in the most conservative way possible to satisfy a build.   As the author of stackage-sandbox, I absolutely agree that this is a deficiency in the stackage-sandbox approach."
haskell,38ecmr,drb226,3,Thu Jun 4 01:32:05 2015 UTC,"That's an interesting idea, optionally making it a strong preference rather than a hard constraint. That's something we can do if we properly integrate the feature into cabal/hackage rather than layering it on top. And similarly, we can produce better error messages in the hard constraint approach, because then the solver knows you're using a collection and so can better explain why something isn't possible."
haskell,38ecmr,dcoutts,2,Thu Jun 4 14:21:41 2015 UTC,"That's an interesting idea, optionally making it a strong preference rather than a hard constraint.   ...so even with collections that's no free pass for package maintainers to skip adding proper upper bounds and instead relying solely on stackage to provide compatible package versions, as the solver would still be allowed to access package versions outside the collections (albeit with some  penalty score)?"
haskell,38ecmr,hagda,4,Thu Jun 4 16:08:28 2015 UTC,"no free pass for package maintainers to skip adding proper upper bounds   Indeed. We still want accurate version constraints.  Collections are useful for end users who don't need anything complicated. Power users and package authors still need the full flexibility, and so need accurate version constraints. Indeed, preparing sensible package collections needs or at least greatly benefits from accurate constraints.  To be clear, I'm also an advocate of the hackage trustee approach where we fix up package constraints after the fact. This can make just building from hackage with no collection work more of the time. The http://matrix.hackage.haskell.org/ site is a great project to try and get a handle on what works and to help trustees and others fix things up."
haskell,38ecmr,dcoutts,1 point,Thu Jun 4 16:51:29 2015 UTC,I think that matrix site needs a front page description...
haskell,38ecmr,oerjan,3,Fri Jun 5 03:41:56 2015 UTC,"hvr hasn't really announced it yet, it's still work in progress. But the trustees are using it already."
haskell,38ecmr,dcoutts,6,Fri Jun 5 08:12:34 2015 UTC,"It should be easy to treat a curated package set as a strong preference rather than a hard peg and to be able to suggest to the user how they can go outside that preference in the most conservative way possible to satisfy a build.   This sounds a lot like what we already can do with version bounds and --allow-newer.  But with version bounds we have a lot more expressivity for defining the curated set.  Also, the version bound approach distributes the burden around the whole community (provided we make upper bounds mandatory on hackage) rather than centralizing the problem."
haskell,38ecmr,mightybyte,2,Thu Jun 4 01:41:20 2015 UTC,"There are problems with this reasoning. First, a package can't decide for itself what version to use of another package without getting multiple versions of a package. That's bad.  Supporting multiple versions of packages is a great way to build crappy software because buggy package live happily together with same ones.  Ensuring that people are notified when their software breaks other people's stuff is what should ensure that the situation in the blog post does not happen. THAT is where tooling is needed.  Incidentally if the package had been part of stackage I'm sure someone would have been notified.  We need to stop helping ourselves build crappy software using manual and buggy processes.  Software development needs communication between package maintainers when things break and this is the kind of social system that stackage enables."
haskell,38ecmr,hastor,4,Thu Jun 4 06:22:39 2015 UTC,"There are problems with this reasoning. First, a package can't decide for itself what version to use of another package without getting multiple versions of a package. That's bad.  Supporting multiple versions of packages is a great way to build crappy software because buggy package live happily together with same ones.   I don't understand how this has anything to do with my comment.   Incidentally if the package had been part of stackage I'm sure someone would have been notified.   Yes, but we don't need stackage for this.  All we need is a simple monitor that emails maintainers when any of their direct dependencies have a major version bump.  But this blog post was about curation and that's not curation."
haskell,38ecmr,mightybyte,3,Thu Jun 4 06:44:57 2015 UTC,"cabal-install doesn't tell the user where something is pegged (or even explicitly that it is pegged)    It does say that it is pegged, it will list the constraint as ""global""   rejecting: base-4.7.0.1/installed-c64..., [...] (global constraint requires <4)"
haskell,38ecmr,bergmark,3,Thu Jun 4 01:39:11 2015 UTC,"What does a global constraint mean? One thing that would help is telling where it came from. Is it some other package, the local project.cabal, cabal.config, cabal.sandbox.config ~/.cabal/config ?  This is what I call a UX problem."
haskell,38ecmr,eegreg,5,Thu Jun 4 03:55:39 2015 UTC,"I had thought about adding a ticket for this before, did that now https://github.com/haskell/cabal/issues/2643"
haskell,38ecmr,bergmark,3,Thu Jun 4 04:31:25 2015 UTC,"Btw, I don't think a global constraint can originate from another package currently. So it can only come from the CLI or from a config/cabal file afaik."
haskell,38ecmr,hvr_,3,Thu Jun 4 06:10:35 2015 UTC,"Which requires doing it properly in cabal, rather than hacking it on top.   Hacking it on top is excellent for prototyping, but now that we've worked out the design space better I think it's time to integrate and support curated collections properly."
haskell,38ecmr,dcoutts,1 point,Thu Jun 4 14:22:52 2015 UTC,"Fundamentally cabal-install has no knowledge that curation is going on. Tooling that understood package sets could present a different UI/UX and help users get the packages they need for their build.   I agree. This can, should (and is) being added to cabal/hackage, so that we can present a better UI/UX."
haskell,38ecmr,dcoutts,-2,Thu Jun 4 14:27:25 2015 UTC,It is the other way around. We must move to a closed world system to deal with the combinatoric explosion of possible dependencies.  Using humans to gauge whether a new source distribution will be compatible with the previous version is an enormous waste of everyone's time. Again and again it is wrong. I will say that it is almost NEVER correct.  WHY didn't the author ensure that his package works with the single closed world that everyone uses?
haskell,38ecmr,hastor,10,Thu Jun 4 06:08:50 2015 UTC,WHY didn't the author ensure that his package works with the single closed world that everyone uses?    I must have missed the memo I guess.... as I'm not limiting myself to nor using that single closed world you talk about..
haskell,38ecmr,hagda,12,Thu Jun 4 09:42:47 2015 UTC,The user's dependency plays perfectly nice with the rest of the ecosystem.  That's why it built with no trouble when not using stackage.
haskell,38ecmr,mightybyte,-4,Thu Jun 4 02:35:21 2015 UTC,But that is all you know. By introducing one additional dependency in the project it would be cabal hell.   I don't see how building a small package is relevant. We must be able to build large software systems and stackage emulates such a large system so that any system that depends on a subset will work.
haskell,38ecmr,hastor,9,Thu Jun 4 02:52:13 2015 UTC,"By introducing one additional dependency in the project it would be cabal hell.   No it wouldn't.  You're just speculating and spreading FUD.  In fact, the user was introducing two new dependencies and without stackage everything worked fine.  No cabal hell.  In this situation it was exactly reversed: hackage was heaven and stackage was hell.   I don't see how building a small package is relevant.   This wasn't a small package.  The successful install plan had more than 90 dependencies.  Building large systems is not sufficient.  We must build robust systems.  The closed world that curation imposes on us is not robust.  We need tools that are not encumbered by the limitations of curation."
haskell,38g5ts,klaxion,39,Thu Jun 4 00:12:52 2015 UTC,"I think hyping up closures is roughly equivalent to hyping up having native UTF-8 string support.  I mean..  Yeah, that's nice, but so?  It's a tiny implementation detail.  I don't care if strings are natively UTF-8, I care about their API and performance.  I don't really care if you can create closures, I care about the API and performance of functions.  It happens that closures are more or less the only method that gives a sane API and performance for manipulating functions as first-class values.  But focusing on closures is entirely looking at the wrong thing.  Instead, look at operations you can perform. I think the best practical example is just plain function composition.  (.) :: (b -> c) -> (a -> b) -> (a -> c) f . g = \x -> f (g x)   This humble little operator is amazing in real code. Composing functions together is now just a single token. It makes it trivial to write super-tiny, easily-testable functions and glue them together however you require.  The fact that its arguments are just plain regular functions and its return value is just a plain regular function is why it's so incredibly useful. The fact that closures are the best option for implementing it isn't very important. The fact that you can create new functions anywhere, pass them around however you like, and use them anywhere? That's where the big win is."
haskell,38g5ts,c_wraith,8,Thu Jun 4 00:46:30 2015 UTC,"Agreed on the hyped up factor. Every language has something like that. Like, how many monad tutorials does Haskell have?"
haskell,38g5ts,pyry,13,Thu Jun 4 08:13:03 2015 UTC,One per Haskell programmer.
haskell,38g5ts,mhd-hbd,6,Thu Jun 4 10:41:12 2015 UTC,Lower bound
haskell,38g5ts,danharaj,9,Thu Jun 4 19:40:24 2015 UTC,UTF-8 strings... Eh.  UTF-8 identifiers and user defined mixfix? Now we're talking.  _⁻¹ : ℚ → ℚ
haskell,38g5ts,mhd-hbd,1 point,Thu Jun 4 10:42:26 2015 UTC,M...mix Fix?
haskell,38g5ts,fruitbooploops,1 point,Sun Jun 7 09:41:07 2015 UTC,"Agda supports infixl, infixr, postfix, prefix, and... Whatever if/then/else is:  if_then_else_ : ∀{A} → bool → A → A → A if_then_else_ false _ x = x if_then_else_ true x _ = x   That's how if-expressions are defined in Agda."
haskell,38g5ts,mhd-hbd,1 point,Sun Jun 7 22:38:16 2015 UTC,"valid Agda, yes?"
haskell,38g5ts,sambocyn,2,Sun Jun 7 20:09:32 2015 UTC,Yep. As long as you define ℚ to be a type.
haskell,38g5ts,mhd-hbd,2,Sun Jun 7 22:35:55 2015 UTC,"I would imagine the part /u/klaxion is interested in isn't the implementation method, but rather that closures give you proper first order functions (formally speaking, a closed category). Whether this is implemented by closures or whatever-you're-imagining isn't important, as you say, but the fact that you can have lambdas that can access the outside scope is kinda important."
haskell,38g5ts,tailcalled,30,Thu Jun 4 17:40:24 2015 UTC,"It's important to distinguish between 'closures' and 'first-class functions with lexical scope'.  People will rightly point out (and have) that closures are an implementation detail---in particular, closures are a technique for implementing first-class functions with lexical scope.  (The technique is just to represent the function-with-lexical-bindings as a pair of the bindings which are in scope when it's created and the actual code of the function).  In Haskell, bindings can't be mutated, so the idea of a closure hiding mutable state the way an object does in a more OO language doesn't really make sense.  However, in Scheme, say, variables are mutable.  Once you have mutable variables in your language, you're eventually going to want some way to hide your mutable variables from others and share them between your own functions.  The way OO languages provide mechanisms to deal with these necessities is via baroque systems of classes, objects, fields, methods, access control, inheritance, subtyping, and so on.  And that's a lot of machinery to handle \begin{functional-programmer-ranting}what should be the extremely rare\end{functional-programmer-ranting} cases where you actually need mutable state.  Since you want a language that doesn't absolutely suck to use, you already have first-class functions, obviously, and so it's worth observing that you can take advantage of lexical scope and first-class functions to do all the data-hiding, etc. stuff you need.  An interesting historical note can be found in http://deptinfo.unice.fr/~roy/JAOO-SchemeHistory-2006public.pdf, which is the slides from Guy Steele's talk on the History of Scheme.  Starting on slide 18, he discusses the evolution of Scheme as an experiment to understand objects and actors."
haskell,38g5ts,deviant-logic,18,Thu Jun 4 01:54:37 2015 UTC,"The venerable master Qc Na was walking with his student, Anton. Hoping to prompt the master into a discussion, Anton said “Master, I have heard that objects are a very good thing – is this true?” Qc Na looked pityingly at his student and replied, “Foolish pupil – objects are merely a poor man’s closures.”  Chastised, Anton took his leave from his master and returned to his cell, intent on studying closures. He carefully read the entire “Lambda: The Ultimate…” series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system. He learned much, and looked forward to informing his master of his progress.  On his next walk with Qc Na, Anton attempted to impress his master by saying “Master, I have diligently studied the matter, and now understand that objects are truly a poor man’s closures.” Qc Na responded by hitting Anton with his stick, saying “When will you learn? Closures are a poor man’s object.” At that moment, Anton became enlightened.  -- Anton van Straaten"
haskell,38g5ts,stepcut251,16,Thu Jun 4 03:52:10 2015 UTC,"Closures aren't a semantic feature; they're an implementation technique. I'm not sure if you could finagle some way of saying GHC uses closures, but it certainly doesn't do them the same way languages ""with closures"" do.  So, I just think it's orthogonal. Haskellers don't care one way or another about closures. We care about functions and binding and scope."
haskell,38g5ts,tel,2,Thu Jun 4 03:06:45 2015 UTC,"Agreed. Haskell doesn't have closures at all. The Haskell Report defines the language entirely in terms of denotation semantics, not operational semantics. Compilers may or may not use objects, closures, or whatever under the hood in their implementation. But in most day-to-day Haskell programming you don't need to be aware of those low-level details."
haskell,38g5ts,yitz,3,Thu Jun 4 10:38:15 2015 UTC,"From section 1.2 of the Report:   Although the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda calculus with a straightforward denotational semantics.   The report largely specifies identities between Haskell surface syntax and this putative kernel calculus.  Which induces a denotational semantics on the language (parameterized on the denotational semantics of said calculus), but it certainly doesn't provide that semantics directly.  Also, an operational semantics doesn't prescribe how a language is implemented, only how it behaves.  An operational semantics for a language defined in terms of substitution can be implemented via closures or vice-versa."
haskell,38g5ts,deviant-logic,1 point,Thu Jun 4 15:38:24 2015 UTC,"Of course. I was referring to the basic approach, not to the question of what formal semantics have been explicitly specified.  The bottom line is that I agree with /u/tel that closures are an implementation technique. You can implement their functionality in a number of different ways in Haskell, depending on the context and how you define your requirements. And Haskell compilers may or may not use some technique internally which you might identify as being a ""closure"". But it doesn't make much sense to ask whether Haskell ""has"" closures or ""uses"" closures as an inherent part of the language."
haskell,38g5ts,yitz,12,Sun Jun 7 18:49:36 2015 UTC,"C++ lambdas are recent, and attempt to imitate functional lambdas but with compromises based on the priorities of that language. Closures have a cost - in C++, you're not (normally) supposed to have a price for abstraction unless you explicitly say you're willing to pay. Hence slightly clunky pseudo-lexical-scope.  As for classes - well yes, a closure stores information, a class stores information, there's some relationship and in C++ it was convenient to model a closure as a kind of anonymous class. That's to fit with the rest of the language - it doesn't mean a closure is the same thing as a class any more than it means an enumerate is the same thing as a class - the ""implemented as"" relationship is one way.  In functional languages, closures aren't even the abstraction. Lexical scope is the abstraction, closures are how that's implemented. That is, you have a nice simple rule for whether an identifier is in scope irrespective of potentially deeply nested function definitions.  In C++ prior to C++11 if you want to pass information into a function you'd need an explicit parameter. Or you could replace the function with a class, and reference that information as a member variable via the implicit this. It's extra clutter, extra code to write etc, which is why C++11 introduced a lambda - eliminating a lot of, but not quite all of, that clutter.  It's interesting here that you immediately leap to classes just because C++ implements lambda as an anonymous class, when each lexical-scope variable is really more like an implicit parameter. I even dimly remember a time when Python didn't have lexical scope for its lambda, so you'd end up writing x=x defaulted parameters explicitly to work around that. Again, a little extra something to think about and a little bit of extra clutter.  Why does OOP have classes when you can already bundle up data as parameters to functions? Or as C structs? Or as Pascal records? Or as Haskell algebraic data types? Simple - none of these things is ""just"" a way to bundle up data.  BTW - lexical scope predates OOP. The first C++-style OOP predates the term OOP, in the Simula language in the 60s (the term OOP was coined by the Smalltalk crowd in the 70s). Lexical scope was invented for lambda calculus by a mathematician in IIRC the 1930s, though AFAIK it wasn't included in a programming language until Scheme. So arguably the question is ""why have objects when lexical scope already exists?"". And IMO (I'm actually still more a C++ programmer than a Haskell programmer) the answer is because they're simply not the same thing, irrespective of one particular language using one to fake the other.  In any case C++, Java and Python (no doubt among others) copied lambda from functional languages. When imperative languages copy functional languages that doesn't mean the functional languages had a bad idea - quite the opposite, really.  EDIT Incidentally, the nearest thing to a C++ class in Haskell is probably a typeclass (definitely not a closure). Actually, a typeclass is closer to a Java interface. You know that rule in OOP that you should ""prefer composition to inheritance""? The implementation-inheritance that's specifically meant to be avoided isn't possible in Haskell - a typeclass can inherit from another typeclass but typeclasses don't include implementation details (that's the instances job) so in Haskell you must use composition rather than inheriting implementation."
haskell,38g5ts,ninereeds314,5,Thu Jun 4 00:59:36 2015 UTC,"One important difference is that by manipulating state through closures, you end up creating a new closure for any context where some ""variable"" has been changed. This means that ""stateful"" changes only propagate to things that can somehow see the closure introducing the change - such as things that are in the scope of that closure, etc. This means you can approximate state... but importantly, there's no way for a closure to ""store"" its state and then change it later (rather than creating a new closure). So there's no way that you can make a closure, modify its state, and then have its preconditions violated by some other caller elsewhere in the program - whereas doing that with objects is trivial, and arguably the whole point of objects. Try to create a ""shared counter"" object using objects - with ""increment"" and ""read"" methods. You should easily be able to increment it and read it, then somewhere else, read it and see that it's been incremented. Now try to do that with Haskell closures... you'll end up needing to come up with some additional abstraction or convention - like using an explicit ""accumulator"", continuation passing style, or monads... and even then you still won't be able to just modify the counter, with the modifications to its state persisting in other contexts. Instead, you'll have to restructure your program to make the changing state explicit.  (Granted, in an impure language - or even in unsafe Haskell - the closure could still store a reference to global state, etc... but that's more like a workaround than a feature of closures)."
haskell,38g5ts,MethodOverDrive,3,Thu Jun 4 01:24:43 2015 UTC,"The reason you would have trouble making a shared counter in Haskell is because of immutability, not some quality of closures. In languages with both unrestricted mutation and closures you can easily rig up a shared counter without global state. In Javascript this is even a common design pattern:  var counter = (function() {     var c = 0;     return {         inc: function() {             c++;         },         read: function() {             return c;         }     }; })();   counter.inc() and counter.read() work as expected, leveraging closures to store the state, change it, and read it later."
haskell,38g5ts,stevely,3,Thu Jun 4 01:46:56 2015 UTC,"I'm not saying that closures prevent immutability, but they also don't enable it, which is what /u/klaxion seemed to be implying by saying you could basically get fragile, stateful programming out of closures. As I (briefly) qualified in my original response, when you have mutable references of any kind, closures obviously don't prevent mutating them. The trick you present of avoiding global state is definitely cool. But my point was just that you definitely can't have shared, mutable state from closures alone. In Haskell, a closure would really only have ""state"" in terms of what its bindings mean in the lexical scopes nested within it (or things that uses that function, etc). You couldn't make a fresh counter in a global scope and then repeatedly call the methods of that counter from different places in the program, which you could easily do with the Javascript example - and obviously could also do in Haskell with some kind of mutable state (like IORef)... but even then, in the Haskell version you would probably be passing around new versions of closures that have different things bound.... whereas in the JS version you can keep using the original closure and manipulate the single, original enclosed value.  In JS, you can ""leverage closures to store the state"" more elegantly, but try writing the same thing without using ++, assignment, or any other operation that fundamentally modifies state."
haskell,38g5ts,MethodOverDrive,0,Thu Jun 4 03:46:34 2015 UTC,"but even then, in the Haskell version you would probably be passing around new versions of closures that have different things bound..   I don't think so:  import Data.IORef  data Counter = Counter { get :: IO Int, inc :: IO () }  newCounter :: IO Counter newCounter = do   ref <- newIORef 0   return Counter { get = readIORef ref, inc = modifyIORef ref (+1) }   In ghci:  *Main> c <- newCounter  *Main> get c 0 *Main> inc c *Main> inc c *Main> get c 2"
haskell,38g5ts,pbvas,2,Thu Jun 4 09:03:06 2015 UTC,"But ref is not changed in your example, nor are any closures."
haskell,38g5ts,psyker,1 point,Thu Jun 4 12:50:10 2015 UTC,Not sure what you mean; I think my Haskell implements exactly the semantics of the Javascript above...
haskell,38g5ts,pbvas,1 point,Thu Jun 4 15:27:19 2015 UTC,"But the Haskell version makes the statefulness explicit through the use of IORef (i.e., you are confined to the IO monad), which is arguably better than implicit mutable state of the JS example."
haskell,38g5ts,glg00,3,Fri Jun 5 00:36:08 2015 UTC,"Purity.  The thing that that prevents Haskell from retreading that path is purity (aka immutability).  IMO this is the single most important characteristic of Haskell.  It is also what sets it apart from literally ALL other languages in mainstream use.  The other replies in this sub-thread go into more detail, but I thought it deserved more concise emphasis."
haskell,38g5ts,mightybyte,3,Fri Jun 5 16:24:07 2015 UTC,Purity is not AKA immutability. Those are different concepts. Immutability = variables cannot be mutated after they are bound. You can't define x = 1 and then later say x = 2. Purity = functions have no side effects and always have the same return value for the same input. AKA referential transparency.
haskell,38g5ts,kyllo,1 point,Thu Jun 4 13:43:17 2015 UTC,"Ahh, good point.  I conflated the two as a more concise nod at some of what ""purity"" means for the benefit of people who might not know."
haskell,38g5ts,mightybyte,2,Thu Jun 4 14:07:59 2015 UTC,"TBH I'm not really aware of closure-based design patterns. Some styles of code depend on some way to access the data, but lexical scope is just one particularly convenient way to access that data. There's plenty of idioms that rely on lexical scope, but not on a scale I'd call a design pattern.  I guess maybe continuation passing style? But I've never felt the need to use it TBH - since the point is to define control flow, I suspect it's more for the formal semantics crowd and for compiler writing.  I was serious about the implicit parameters point, though. Basically, implicit parameters are another way to implement lexical scope - an alternative to closures.  [EDIT - stupid mistake above - you need a closure to implement partial application too, including those implicit parameters. I let the memory of ye ancient Python along with not thinking about currying etc deceive me. Presumably when Python didn't have lexical scope for lambda, that was so the VM compiler didn't need to determine which extra identifiers to capture.]  Closures require an implicit parameter to point to the closure - I guess maybe that's part of the like an OOP this/self parameter and possibly part of your reasoning. But that's still just one way to implement lexical scope. Lexical scope is lexical scope - not one facet of its implementation. The implicit pointer parameter is not what it's for in either case - it's just an implementation detail.  If you really want to understand the benefits of lexical scope and closures, you could read the famous Scheme ""lambda papers"". I confess I've personally only read a few little bits a long time ago."
haskell,38g5ts,ninereeds314,2,Thu Jun 4 14:33:16 2015 UTC,"ALGOL 60 had lexical scope, no? Certainly C, which predated Scheme, but ALGOL at least allowed nested functions."
haskell,38g5ts,shift_reset,2,Thu Jun 4 01:42:45 2015 UTC,"C doesn't have lexical scope except in the sense that it doesn't have nested function definitions (a GCC extension supports this, but it's not standard) - sure the scope is lexical but only by sidestepping the point. Pascal I think had nested procedures but I'm not sure about lexical scope - it's a long time since I used Pascal. I bought some Algol books a little while back and I've never had much trouble reading Algol on the few occasions I've needed to, but I've not attempted to learn it or its history so I don't really know.  I know John McCarthy, original designer of LISP, also influenced the design of ALGOL but I didn't think either of those languages had lexical scope. Of course McCarthy was aware of it from lambda calculus - I assumed it was perceived as too costly at the time. After all, this was a time when the idea of even recursive functions/procedures in programming languages was shiny and new.  But I could easily be wrong."
haskell,38g5ts,ninereeds314,2,Thu Jun 4 02:01:31 2015 UTC,"Lexical scope in C is in terms of block nesting, it has nothing to do with function nesting:  int x; void foo() {   int y;   if (bar) {     int z;     // x, y, and z are in scope here   }   // x and y are in scope here } // x is in scope here"
haskell,38g5ts,Barrucadu,3,Thu Jun 4 02:18:57 2015 UTC,"Yes, but again that's missing the point of lexical scope. Every block structured language has lexical scope in that trivial sense, but we just call that block structuring.  In particular block structuring doesn't need closures - strictly speaking it doesn't even necessarily need a stack until you add recursion to the mix and, even then, stack frames are enough.  When people talk about lexical scope they mean that nested function definitions can see variables in outer function definitions, as with lambdas referring to variables defined by the parent (or grandparent etc) function. Add on the fact that the functions are called from a different place than where they're defined (especially when passing/returning those functions) and you can't even be sure the stack frame for the parent function is still there when the nested function is called. Hence closures - a heap-allocated block of storage capturing the relevant values for the nested function to reference when called.  Sure the term reads a little ambiguously, but a lot of jargon is a bit like that - it means what people understand it to mean, whereas what it actually says is a sometimes-misleading fluke of history."
haskell,38g5ts,ninereeds314,2,Thu Jun 4 02:58:05 2015 UTC,"To add to that, lexical scope is also called static scope and is contrasted with dynamic scope, where variables (effectively) refer to names in a global dictionary. Consider this (python style) code:  def foo():     x = 1     def bar():         print(x)     return bar baz = foo() x = 2 baz()   In a language with lexical scope, this code would print 1; in a language with dynamic scope (emacs lisp is the only one that comes to mind), this code would print 2."
haskell,38g5ts,rpglover64,3,Thu Jun 4 03:29:07 2015 UTC,"Every block structured language has lexical scope in that trivial sense, but we just call that block structuring.   No, they don't.  Look at perl for example.  Just having blocks does not mean it is lexically scoped, and lexical scoping does not require nested functions.  http://whatis.techtarget.com/definition/lexical-scoping-static-scoping"
haskell,38g5ts,ninereeds314,2,Thu Jun 4 14:13:41 2015 UTC,"On block structuring, good point and +1. I've learned the basics of Perl a few times and hated it - I don't recall this but it might be something I once knew but repressed.  On ""does not require nested fuctions"" - I know, I never really said otherwise, I probably implied it but only because - as I said - I consider that sense of lexical scope trivial.  So formally ""lexical scope"" means what it actually says and you look for the violations, but no-one ever even cared enough to coin the term AFAICT until there were nested functions/procedures. That's where the point of lexical scope arises, and that's why the term on its own is misleading.  Of course at this point I'm only continuing this to see if I actually turn out to be wrong about that."
haskell,38g5ts,sacundim,10,Thu Jun 4 13:15:32 2015 UTC,"Touring around other languages like javascript, some of these functional-ish languages seem to make a big deal of closures as part of the functional paradigm.  To me it looks like OOP by another name - passing state and associated method around as a bundle.   IMHO, this is a non-issue.  What it comes down to is that functional programming has never been all that opinionated about the choice between union types + case analysis vs. first class functions/behaviors + dynamic dispatch.  Heck, here's an example that combines both:  map :: (a -> b) -> [a] -> [b] map _ [] = [] map f (a:as) = f a : map f as   That's basically a switch statement, one of whose branches dispatches to a dynamically supplied behavior.  Meh, what's the big deal.  The choice between static and dynamic comes down to what behaviors you want to fix at compilation time and which you want to leave open, and that's just that.  Easy to learn, hard to master...  OOP, on the other hand, has long been extremely judgmental about this, insisting that first class behaviors + dynamic dispatch is The One True Way.  ""Switch Statements Smell"" and all that jazz.  So in the pursuit of this vision they have crippled their languages, doing things like banning plain old record types (!) in order to force objects on programmers.   All in all closures feel a bit like OOP-in-sheep's clothing.   Closures existed well before the term ""object-oriented programming"" was invented.  And don't forget that one of the biggest influences on Smalltalk was Lisp.  Frankly, you're committing one of the common sins of the OOP crowd—crediting OOP for things that it doesn't deserve credit for."
haskell,38g5ts,kamatsu,5,Thu Jun 4 18:44:33 2015 UTC,"Haskell has closures but doesn't have mutable state captured in them. So closures aren't used to the same effect that they are in, say, Scheme."
haskell,38g5ts,SkoomaMudcrab,3,Thu Jun 4 04:28:57 2015 UTC,"Lexical closures are an improvement on OOP in terms of expressiveness, sure. Basically, an OOP object is, in Lisp, a let over a lambda; and an OOP class is a lambda over a let over a lambda (for static vars add another let on top). So lexical closures allow one to implement an OOP object system, but also a lot more combinations, like a class factory or a factory of class factories.  But ultimately, as you've said it: whether it's objects or closures, you're still bundling together functions with state. And that is contrary to the Functional Way, where functions are separate, composable and easily testable. Bundles of state + functions are not, in general, composable or easily testable, and are not the approach Haskell is about."
haskell,38g5ts,garethrowlands,2,Thu Jun 4 14:09:46 2015 UTC,"Touring around other languages like javascript, some of these functional-ish languages seem to make a big deal of closures as part of the functional paradigm   That's because they are not functional languages, and the people saying those things are just trying to cash in on the perceived increasing popularity of functional programming.  Functional programming is not about higher order functions or closures any more than driving a car is about wheels and transmissions.   To me it looks like OOP by another name    That's because you are viewing it through that lens.  You don't write OO code using closures.  It is not a replacement for objects, it is a useful feature on its own (that predates objects).   How do haskellers view closures?   As a basic requirement.  This is like ""how do you view strings"".  I'm not going to use a language without them, because they are used all the time for everything."
haskell,38cckm,hvr_,5,Wed Jun 3 08:32:02 2015 UTC,It's particularly great to see work on improving the performance. GHC is great but productivity gains from using Haskell can be eaten up by long compile times....
haskell,38cckm,mallai,5,Wed Jun 3 15:40:16 2015 UTC,"It's ok if you can use -O0 locally and -O2 on production, at least it greatly improved experience for me."
haskell,38cckm,k-bx,2,Wed Jun 3 16:46:32 2015 UTC,"What's a convenient way to switch between -O0 and -O2 somehow globally? Say, when I'm creating a fresh sandbox and for building during development. I want to avoid having to give --ghc-option=-O0 to every command.  EDIT: I tested on my project with cabal clean followed by cabal build. Here are the times:  cabal build --ghc-option=-O0  18.5s  cabal build  39s  cabal build --ghc-option=-O2  42s"
haskell,38cckm,mallai,1 point,Wed Jun 3 17:57:30 2015 UTC,You can use a flag and put the option in your cabal file  if flag(development)   ghc-options: -O0 else   ghc-options: -O2   and then just make sure you cabal configure -fdevelopment as appropriate.  edit: s/O2/O0/
haskell,38cckm,timmy_tofu,2,Wed Jun 3 22:19:40 2015 UTC,"thanks. So, I configure once and ghc-mod and all other tools should use that setting?"
haskell,38cckm,mallai,2,Wed Jun 3 23:15:27 2015 UTC,"I don't know exactly how ghc-mod works, but anything that somehow calls cabal build either directly or indirectly should be covered."
haskell,38cckm,timmy_tofu,2,Thu Jun 4 00:06:03 2015 UTC,"That's a very bad idea and cabal will tell you so as well, as then you take away the control from cabal to configure your optimisation settings via its CLI   -O --enable-optimization[=n]       Build with optimization (n is 0--2, default is 1)     --disable-optimization          Build without optimization   as well as the optimization property in the cabal.config file..."
haskell,38cckm,hagda,3,Thu Jun 4 11:37:58 2015 UTC,"But that option is only available in cabal install command. During dev, I'd like to do cabal build without optimizations. But, yes, setting it in cabal.config is probably better to have a global option. I hope it can be overridden by CLI.  EDIT: so, in your project create an empty file cabal.config. Add the line optimization: False. This will turn the optimization off by default for all cabal commands. But, if you want to override you can execute either cabal build --ghc-option=-O2 or cabal install --enable-optimization=2.  What is good about using cabal.config in you project, is that the sandbox will also be installed without optimizations. Unfortunately, for my project, no optimizations cuts down install time of the dependencies in the sandbox only from 4min37s to 4min12s, so it's not worth it."
haskell,38cckm,mallai,4,Thu Jun 4 14:27:24 2015 UTC,But that option is only available in cabal install command.   and in cabal configure (which afaik is honoured by a subsequent cabal build)  (cabal install = cabal configure + cabal build + cabal copy + cabal register)
haskell,38cckm,hagda,1 point,Thu Jun 4 16:12:01 2015 UTC,Also s/-0/-O/ in case anybody wants to copy-paste.
haskell,38cckm,conklech,2,Thu Jun 4 01:46:51 2015 UTC,Thanks for keeping this up!
haskell,38br54,gbaz1,3,Wed Jun 3 04:50:01 2015 UTC,I can do this. How and where should I start?
haskell,38br54,wbaig,1 point,Wed Jun 3 16:09:06 2015 UTC,"Great! start by joining the haskell-platform list (http://projects.haskell.org/cgi-bin/mailman/listinfo/haskell-platform) then email mark and the list to offer your assistance. I imagine the trick is to A) learn the new platform build process and B) teach it to autogenerate html files, then C) redesign it to be in sync with the current haskell.org design.  The first few steps don't require any special access anywhere, though they may require guidance from people like Mark that know the platform build process.  Once it comes to ""making it happen"" the haskell-infra admin team is ready to help figure out that last mile. You can always reach it at ""admin at haskell.org"" or on the #haskell-infrastructure irc channel on freenode."
haskell,38br54,afcowie,3,Wed Jun 3 17:40:25 2015 UTC,"I thought the consensus was that with the emergence of the stackage package set, the Haskell Platform was no longer something that we needed to promote. It seemed it was getting in the way for more people than it was helping anyway."
haskell,38br54,Tekmo,24,Wed Jun 3 04:53:47 2015 UTC,"That's nowhere near a consensus. That's a particular set of active voices. The platform is still very popular and widely used. Furthermore, use of it doesn't preclude stackage. And active work is underway to improve cabal, which will also help with issues tied to using the platform with  sandboxes more easily.   In any case, this post isn't about the same arguments again. It's signal boosting a call for help with the site. There's room for many tools and approaches. This is a request for help with one of them."
haskell,38br54,tejon,7,Wed Jun 3 06:46:03 2015 UTC,I thought windows users still benefited from the Haskell Platform
haskell,38br54,dcoutts,15,Wed Jun 3 05:22:24 2015 UTC,"Windows user here. I dumped Platform the day MinGHC happened, and have never looked back."
haskell,38br54,dons,9,Wed Jun 3 06:23:23 2015 UTC,"The platform gets unfairly blamed for the problem where people want to start a new minimal sandbox, but cabal currently puts everything from the global package db into each new sandbox.  We need to be clear about where in our stack our problems are, and then we need to fix them where they are.  In this case the problem is with how cabal constructs the sandbox, and the fix is not so hard. Someone started working on it at ZuriHac this weekend."
haskell,38br54,ndmitchell,14,Wed Jun 3 10:25:32 2015 UTC,"the consensus    Windows HP is still installed by thousands of people every month. Stackage is still a comparatively complicated list of steps you have to do, compared to a one-click install.  It's important to think from the point of view of beginners; of students; of people who want to build some Haskell app, but don't care about Haskell. Not everyone is a dev/enthusiast who is willing to execute multiple, independent steps to get a working Haskell env."
haskell,38br54,deech,15,Wed Jun 3 07:11:26 2015 UTC,"And those poor people get totally shafted the second they try installing something that requires a bump in the network package. While it does have a large user base, if they do anything significant, they become sad users.  Source: I'm a Windows user who has been shafted by the Platform."
haskell,38br54,wrvn,8,Wed Jun 3 07:50:20 2015 UTC,"Also it's super annoying that the user's Cabal-made bin directory (C:\Users<your-username>\AppData\Roaming\cabal\bin) is not added to PATH and the user has to do it manually.  This is a nasty surprise when they first install HP, upgrade cabal-install, and invoking cabal on the command line runs the old version that ships with HP and not the new one.  Also it doesn't include a full complement of autotools. I'm not near a Windows machine so I don't know for sure, but I think it was autoheader or autoconf or something like that. It's a real impediment to compiling combined Haskell/C projects on Windows."
haskell,38br54,dcoutts,3,Wed Jun 3 11:26:39 2015 UTC,It would be awesome of Haskell Platform could be integrated with MSYS2 somehow as that would provide tons of precompiled libraries for windows. Sadly mingw that ships with GHC is still stuck at now ancient 4.5 version while MSYS uses version 4.9 and will soon switch to 5.1 i guess :(
haskell,38br54,ndmitchell,11,Wed Jun 3 21:08:45 2015 UTC,"Can't we just fix it? You made it possible to rebuild network using minghc, we can apply the same thing to the Windows platform installer.  This is nothing to do with ""bundle many libs"" vs ""bundle very few"". It's ""just"" a case of bundling a bit more of the mingwin tools. You've already worked out which bits of mingwin needs to be bundled, we can just do the same for the windows platform installer.  Volunteers? Look at what Neil worked out had to be bundled, and go help Mark and the others on the platform mailing list to do the same for the HP windows installer. Everyone will thank you for it."
haskell,38br54,mallai,5,Wed Jun 3 10:21:28 2015 UTC,"Yes, fixing it would be great! And agreed, it's entirely unrelated to what libraries you ship. I should also say Michael Snoyman was the one who figured out the right set of tools."
haskell,389tpg,sdroege_,16,Tue Jun 2 20:44:45 2015 UTC,"Yes, this is basically the same philosophy I took with hs-nacl. It's waaaay easier to play with the design space, types, and implementation details when it's all in one package.  It also makes it a lot easier to point people to the latest documentation I think, which can be complete (and documentation is no longer is scattered among packages if you don't consolidate it).  Sounds like a good win to me!"
haskell,389tpg,aseipp,2,Tue Jun 2 21:36:50 2015 UTC,"I kind of wonder how your case differs from categories-extra, which ended up being split into a whole bunch of smaller packages."
haskell,389tpg,Taneb,6,Wed Jun 3 02:20:48 2015 UTC,I think that was a mistake. The number of transitive dependencies is the reason I avoid depending on most Ed's packages.
haskell,389tpg,roche,10,Wed Jun 3 07:19:20 2015 UTC,"Before it was the ""size of the one package when they only wanted a little piece of it"" that was the reason people were avoiding category-extras.  Pick your poison.  I am interested in working on stuff that happens to build on top of that foundation, so I need something to make the interconnections, and orphans are not an option, so we're left with one monolithic package or lots of little ones with dependencies.  At least with the mound of smaller packages when something out on the lunatic fringe changes only us lunatics pay for it, with one package, every user pays for every small change.  The price of course is that it is harder to think thoughts about changes that cut across the boundaries between packages."
haskell,389tpg,edwardkmett,2,Wed Jun 3 16:06:31 2015 UTC,"Before it was the ""size of the one package when they only wanted a little piece of it"" that was the reason people were avoiding category-extras.   But see, the current solution doesn't avoid that. When I want a little piece of it, I end up depending transitively on half of your stuff."
haskell,389tpg,roche,5,Thu Jun 4 07:03:33 2015 UTC,And before you'd have ended up depending locally on all of it.  The situation winds up unacceptable to you either way. I can't change that without compromising my ability to build on top of what I've written.
haskell,389tpg,edwardkmett,2,Thu Jun 4 09:32:45 2015 UTC,"As someone that used to be firmly in the ""let's make package smaller"" camp, I can't agree more to this now.  large transitive dependencies are commonly a pain to deal with how the haskell tools / community / ecosystem is organised."
haskell,389tpg,vincenthz,0,Wed Jun 3 09:05:50 2015 UTC,More people complaining about dependencies?
haskell,389tpg,Mob_Of_One,4,Wed Jun 3 03:31:48 2015 UTC,"Does pivotcloud actually use all these or is it mostly ""for fun""?"
haskell,389tpg,dogodel,3,Tue Jun 2 22:19:42 2015 UTC,"you can find what pivotcloud was using there: ac-crypto-prim (which we manage to opensource before closing). In a nutshell, we were using most of the crypto packages (hash, aes, ..), along with some cryptonite stuff (chacha/salsa/pbkdf2), along with some extra openssl bindings for ECC / AES.  My short term plan is to take those openssl bindings and package it properly as a cryptonite-openssl bolt-in package."
haskell,389tpg,vincenthz,2,Wed Jun 3 08:24:36 2015 UTC,"pivotcloud is no more, so i imagine its because he likes to work on crypto code :)"
haskell,389tpg,cartazio,2,Wed Jun 3 04:25:18 2015 UTC,ah that's a shame. Didn't they exhibit at RSA recently?
haskell,389tpg,dogodel,5,Wed Jun 3 13:52:26 2015 UTC,How does lazy evaluation affect timing side channel attacks against encryption algorithms?
haskell,389tpg,swenty,10,Tue Jun 2 23:12:16 2015 UTC,Notice the library is more of a collection of C implementations skiing with Haskell bindings and an api.
haskell,389tpg,tom-md,6,Wed Jun 3 00:30:44 2015 UTC,"Most of cryptonite is quite strict and most of the time only externally pure (some mutable API are also exposed for power users). Inside, it's using some C implementations (as @tom-md pointed out), mutable buffer / structures, and haskell core strict primitive.  This help avoid your sensitive data to be spread all over your memory N times, laziness issues (IO, unboxed primitive, etc), and does improve performance substantially.  edit: do note, that not everything is up to the same standard, for (my) time reason and some haskell capability (for example not having a mutable integer interface exposed). For example, the DES implementation (which no one should use anymore really) forked from 'Crypto', is actually terribly slow and probably very questionable for timing reason."
haskell,389tpg,vincenthz,2,Wed Jun 3 09:12:43 2015 UTC,"(Take with a grain of salt; I'm no crypto expert)  My bet is, ""Not much, it's still hard to avoid.""  You will often be working with data whose whnf is the same as their nf (Words, strict Bytestrings, etc.), and many sources of timing attacks (e.g. short-circuiting comparisons) are present in strict code as well as lazy code."
haskell,389tpg,rpglover64,2,Wed Jun 3 00:25:35 2015 UTC,"Thanks for your great work on crypto packages!  What about tls, and other related packages such as asn1 and x509, not included on the cryptonite list in this post? Together with some of the packages moving to cryptonite, those are a cornerstone of many production web apps in the wild."
haskell,389tpg,yitz,2,Wed Jun 3 22:35:28 2015 UTC,I think Vincent covers that in this answer:  https://github.com/vincenthz/cryptonite/issues/4  So they will be upgraded in time.
haskell,389tpg,tekul,1 point,Thu Jun 4 08:51:17 2015 UTC,"To me it sounds like that time is now, or very soon."
haskell,389tpg,yitz,1 point,Thu Jun 4 08:53:46 2015 UTC,it's a work in progress; I should get the first port by early next week I think.
haskell,389tpg,vincenthz,3,Thu Jun 4 20:35:21 2015 UTC,"First of all thanks for your efforts in this area!  I think the single package issue shows yet another error in how cabal works. Versioned dependencies should be on source code distribution units. One such unit of distribution should be able to contain multiple libraries.   Stackage, by fixing the hash of source code is one unit of distribution with no need for versioning for internal dependencies. Cryptonite is similar with multiple libraries internally and no need for cross library versioning."
haskell,389tpg,hastor,1 point,Wed Jun 3 05:41:45 2015 UTC,"yes, the way cabal / packaging / versioning work currently is not ideal IMO.  I like hashes in this context, but a middle ground would be to introduce versioning on module inside a package. Which would let people express much better their dependencies : ""I'm depending on API version 4 or 5 of module A.B.C in package foo, but the rest of the modules in the same package do not matter to me"""
haskell,389tpg,vincenthz,2,Wed Jun 3 08:34:26 2015 UTC,"More granular versioning (while still requiring a compound versioning) breaks down if enough packages keep depending on the global compounded package version (which then would inevitably increment faster, as it has to follow each of its modules' version bumps). This is one of the benefits (which ones pays with more overhead  managing the inter-package deps) of splitting into individual packages, as package major version increments don't necessarily (unless there's affected inter-package re-exporting going on) require other packages to perform a major version increment as well."
haskell,387uct,seanseefried,13,Tue Jun 2 13:56:00 2015 UTC,This deserves a cross-post to /r/haskellgamedev
haskell,387uct,tejon,1 point,Tue Jun 2 15:06:09 2015 UTC,"Thanks, I didn't even know that one existed!"
haskell,387uct,mkaito,5,Tue Jun 2 23:38:24 2015 UTC,"Wait, you can deploy Haskell on Android? I thought Java was the only thing that runs there. Hell, I've steered clear of any Android development because I hate Java!"
haskell,387uct,JPMoresmau,9,Tue Jun 2 16:15:03 2015 UTC,"It's fairly complex to do so, from the readme:   But building it for mobile devices ain't that easy.  Apart from requiring a GHC cross-compiler, you must cross-compile various C libraries and then build cross-compiled versions of all the Haskell libraries which, unfortunately, doesn't work out of the box for some libraries when installing them with Cabal.  So, with the aid of Docker I wrote a script to build a fully fledged Android build environment. This builds on earlier work that I did in the docker-build-ghc-android repo. docker-build-ghc-android just builds a GHC 7.8.3 cross-compiler targetting ARMv7, while this repo builds all the C and Haskell libraries required to build Epidemic.  In conjunction with android-build-epidemic-apk you can build an APK for installation on your Android device."
haskell,387uct,gelisam,9,Tue Jun 2 16:27:40 2015 UTC,Check out the cool things Keera Studio are doing: http://keera.co.uk/blog/all-posts/
haskell,387uct,mkaito,6,Tue Jun 2 17:33:01 2015 UTC,"Yes, please do. I corresponded with them regularly and they were very helpful."
haskell,387uct,kyllo,5,Tue Jun 2 23:40:22 2015 UTC,"There is a thing called NDK which allows you to run native code such as C, C++, and apparently Haskell. The NDK doesn't have an API for the GUI stuff like Activities which Android is known for though, so it's better suited to stuff like games which have a non-standard UI anyway."
haskell,389jo5,wordwake,1 point,Tue Jun 2 19:51:13 2015 UTC,"I got something working, but it would be great to hear about better alternatives - of which I'm sure there are plenty."
haskell,38704v,NorfairKing,31,Tue Jun 2 08:31:08 2015 UTC,Yi is not dead and currently more actively worked on than ever in the last decade. Just check the git repositories. It has huge potential and time invested there is much more likely to give us the Eclipse equivalent than any Emacs or Vim integration of various tools. You're right that there's not enough documentation or tutorials.
haskell,38704v,carstenm,8,Tue Jun 2 10:55:46 2015 UTC,Any plans for ide-backend integration?
haskell,38704v,cies010,6,Tue Jun 2 13:42:13 2015 UTC,Maybe save someone some googling:  https://github.com/yi-editor/yi  https://wiki.haskell.org/Yi
haskell,38704v,hans2504,1 point,Tue Jun 2 19:57:06 2015 UTC,Thanks for the links
haskell,38704v,carstenm,4,Tue Jun 2 22:41:16 2015 UTC,The last decade?!
haskell,38704v,tomejaguar,3,Tue Jun 2 21:30:48 2015 UTC,Started in 2005 and it's been very active the last two years.
haskell,38704v,carstenm,8,Tue Jun 2 22:43:34 2015 UTC,"""Dead"" or not it's still a very nice project and definitely complete enough to work with. I now use Yi where I used to use Vim for editing Haskell, so far it's been great."
haskell,38704v,Alyte,2,Tue Jun 2 13:30:46 2015 UTC,But...  cabal: Error: some packages failed to install: text-icu-0.7.0.1 failed during the configure step. The exception was: ExitFailure 1 yi-0.12.0 depends on yi-language-0.2.0 which failed to install. yi-language-0.2.0 failed during the building phase. The exception was: ExitFailure 1 yi-rope-0.7.0.1 depends on text-icu-0.7.0.1 which failed to install.   Now what?
haskell,38704v,gfixler,1 point,Tue Jun 9 08:21:36 2015 UTC,Err I had the same problem IIRC but I forgot how to fix it. terribly sorry :(
haskell,38704v,Alyte,1 point,Tue Jun 9 18:04:13 2015 UTC,No worries. /u/ethercrow has my back:  http://www.reddit.com/r/haskell/comments/38704v/is_the_yi_editor_dead/cs0ku2f?context=3
haskell,38704v,gfixler,20,Tue Jun 9 18:16:55 2015 UTC,"It was probably never alive, if living is defined by having users other than its authors.  I think you might have more fun adding Haskell to Emacs via GHC or Hugs. I've tested this out so that I could run M-x run-haskell ""Hello!"" and get back the result, by compiling Emacs and the GHC runtime into the same process. For calling back into Emacs, the plan was to orchestrate an Haskell→Emacs FFI, by passing in a struct of pointers to functions of interest like INSERT or GOTO-CHAR, or alternatively EVAL which would return a lisp object that could be called as a function provided the right safety precautions were put in place. E.g.  import Emacs  insertAtEndOfBuffer :: Text -> Emacs () insertAtEndOfBuffer text =   saveExcursion (do max <- pointMax                     gotoChar max                     insert text)   (Then I load this module and run M-: insertAtEndOfBuffer ""hello!"" RET.)  where saveExcursion, pointMax, gotoChar and insert all come from the Emacs module, but they are actually aliases for calling the pointers provided by the Emacs monad's context. Alternatively,  pointMax :: Emacs () pointMax = unsafePerformIO ((evalFunction ""pointMax"" :: IO (IO ())) >>= liftIO)   But I got sidetracked by other things.  I still think this is a good idea and much better than talking to Haskell via a pipe or sockets or whatever. It's possible to make Haskell a native language of Emacs like Emacs Lisp. Aside from Elisp itself, Emacs is a well-designed editor with decades of experience about what makes an extensible environment work and what doesn't. In practical terms, it's not worth throwing away to start from scratch like Yi, unless you have theoretical interest in editors or very limited requirements."
haskell,38704v,chrisdoner,11,Tue Jun 2 08:54:37 2015 UTC,"It was probably never alive, if living is defined by having users other than its authors.   You program your config files IIRC. This brings users very close to being authors. I just by commit logs, and therefor I consider Yi to be alive!   In practical terms, it's not worth throwing away to start from scratch like Yi, unless you have theoretical interest in editors or very limited requirements.   I don't agree. TextMate, Sublime and Atom all started from scratch and have gained considerable user bases. But then they are not extensible enough to be compared to Emacs. Well Eclispe/IntelliJ/NetBeans have also started more recently then Emacs and have considerable user bases.  Emacs has plenty flaws, and ELisp is not fast nor type-safe, and gives me a lot of runtime errors (especially after updates of packages).  I have my hopes up for Yi. And I think it is a great effort to work on such a daunting task.  Finally some words of thanks to you Chris, as I use Emacs to write Haskell currently, and keep up a significant effort to make that a rather well tooled environment. Thanks for that!"
haskell,38704v,cies010,5,Tue Jun 2 13:40:40 2015 UTC,"In practical terms, it's not worth throwing away to start from scratch like Yi, unless you have theoretical interest in editors or very limited requirements.   I don't agree. TextMate, Sublime and Atom all started from scratch and have gained considerable user bases.    Everthing I've seen of Yi indicates that it's supposed to be basically Emacs with Haskell as the main language. Sublime Text and TextMate are not trying to be anything like Emacs. They're conventional editors with conventional ""plugin"" systems. And Atom is based on Sublime Text, but in the browser. The userbase is for people who don't want or like or know Emacs. If all that is true, then the question I raise is whether in the case of Yi it's worth re-implementing the whole of Emacs (and you will want to do that eventually in an extensible editor) just to have a better extension language? And my answer is, practically speaking, no, whole lifetimes worth of development have been spent on Emacs. Unless you have specific interest in implementing editors, in which case, the answer is always ""why not?"""
haskell,38704v,chrisdoner,5,Tue Jun 2 17:30:18 2015 UTC,You're forgetting the fact that Yi is supposed to be embeddable. This may not be important for a typical emacs user but plenty of people would love to have something like Yi inside leksah.
haskell,38704v,Categoria,2,Tue Jun 2 21:01:43 2015 UTC,"I've never seen Yi as a re-implementation of Emacs, but I take your word for it.  Totally agreeing that Emacs is awesome, and hard to beat at it's game. Though I think that if a hacker editor like Emacs will every be knocked of it thrown then it must be by using a language that is able to do so.  Haskell might just be that language.  The ""likely or not"" debate aside: a have my hopes up for Yi. :)"
haskell,38704v,cies010,3,Wed Jun 3 07:39:29 2015 UTC,"Emacs has plenty flaws, and ELisp is not fast nor type-safe, and gives me a lot of runtime errors (especially after updates of packages).   Er, the messages you see when updating packages are actually compile-time and are warnings, and they are just there because the elisp byte-compiler is somewhat aggressive about printing warnings - they don't actually correspond to bugs."
haskell,38704v,catern,4,Tue Jun 2 19:31:46 2015 UTC,"I mean that I get incompatibilities after updating packages. Emacs' package system is not mature enough (pinning versions seems to be hard somehow), and there's no type system to ensure compatibility between all parts to some degree."
haskell,38704v,cies010,2,Wed Jun 3 07:43:49 2015 UTC,"I was actually hoping for the vim part of Yi. I can't read or write elisp, but I can imagine it's already a lot nicer than vimscript."
haskell,38704v,SeriousBug,6,Tue Jun 2 09:38:41 2015 UTC,Perhaps evil or spacemacs would suit you?
haskell,38704v,cies010,3,Tue Jun 2 10:07:14 2015 UTC,I recently found Spacemacs and must say it is pretty solid. I came from bbatsov's Emacs Prelude.
haskell,38704v,conklech,4,Tue Jun 2 13:43:30 2015 UTC,"Echoing /u/sgraf812 - spacemacs is great, but its somewhat casual release cycle seems to cause (to me) nearly-unacceptable breakage; you're basically using development versions no matter what you do. It's very promising, but not yet quite the haven for emacs newbies that it aims to be--you have to get your hands dirty and fix stuff.  (The ""release"" cycle is basically bumping the release branch to the latest commit at the beginning of every month. I just updated to the new release, and feature I rely on was broken by a day-old commit that hadn't been tested. I reverted and filed a bug.)"
haskell,38704v,codygman,4,Tue Jun 2 20:12:14 2015 UTC,"It is still in alpha though, so this is partially expected I guess."
haskell,38704v,conklech,3,Tue Jun 2 20:39:39 2015 UTC,"I agree; totally reasonable. Just fair notice.  By the way, I forgot to mention that by default autosave is disabled, so crashing bugs (I've encountered two) can cause data loss."
haskell,38704v,sgraf812,3,Tue Jun 2 21:53:30 2015 UTC,I also had it completely unusable once when it updated it plugins which assumed a newer version of spacemacs itself. Seems like they need better version management.
haskell,38704v,cies010,3,Tue Jun 2 22:12:27 2015 UTC,"I think it is a problem with Emacs' default package manager. See my other comment on ""incompatibilities""."
haskell,38704v,cies010,1 point,Wed Jun 3 07:45:17 2015 UTC,"I think it is a problem with Emacs' default package manager. See my other comment on ""incompatibilities""."
haskell,38704v,conklech,2,Wed Jun 3 07:44:34 2015 UTC,"That may also be true; of course /r/haskell readers will be sensitive to the downsides of not having any static guarantees. But neither of the problems I was alluding to was in that category: in one case, a custom spacemacs function had a logic error and looped when an assumed precondition wasn't met. The situation I mentioned in the post apparently arose from conflicting imports."
haskell,38704v,cies010,2,Wed Jun 3 16:24:10 2015 UTC,"in one case, a custom spacemacs function had a logic error and looped when an assumed precondition wasn't met.   This is something different indeed.   The situation I mentioned in the post apparently arose from conflicting imports.   This might be a case that could be fixed with a proper package mgr. The current package mgr does not allow to pin versions, to it is very hard for devs to know what gets installed with users install Spacemacs. This import bug you describe might have been caught if pinnen-versions were updated on a beta-release first. Now all users basically have a non-dertermained, non-tested set of packages: untestable."
haskell,38704v,rdfox,3,Wed Jun 3 17:00:59 2015 UTC,What layers do recommend for haskell development?
haskell,38704v,cies010,3,Tue Jun 2 19:00:19 2015 UTC,"The ""Haskell"" one? I found a bug and fixed it with a workaround (when you run into the bug just look for the message in Spacemacs' Github issues)"
haskell,38704v,vijaykiran,3,Wed Jun 3 07:46:51 2015 UTC,The Haskell layer has been working good for me : https://github.com/syl20bnr/spacemacs/tree/master/contrib/!lang/haskell
haskell,38704v,sgraf812,1 point,Wed Jun 3 08:19:46 2015 UTC,"Except that the frequent updates somehow have the tendency to break things for me. Otherwise it's as solid as every other extensible IDE (in the positive sense).  I wish I would better come along with emacs so that I knew how to properly write and contribute to language bindings, but I don't really like to ""waste"" my time on elisp."
haskell,38704v,cies010,2,Tue Jun 2 18:47:48 2015 UTC,"Except that the frequent updates somehow have the tendency to break things for me.   I think it is a problem with Emacs' default package manager. See my other comment on ""incompatibilities""."
haskell,38704v,enolan,3,Wed Jun 3 07:45:50 2015 UTC,You might look into neovim's fancy plugin support. Should be simple enough to write Haskell bindings if they don't already exist.
haskell,38704v,rdfox,6,Tue Jun 2 11:31:10 2015 UTC,i've been keeping my eyeballs an this
haskell,38704v,Categoria,1 point,Tue Jun 2 14:22:32 2015 UTC,There's a Haskell api binding but no one has used it as far as I can tell.
haskell,38704v,Alyte,7,Tue Jun 2 19:01:27 2015 UTC,"I've used Yi. It's certainly a pretty good Vim clone. If you're a vanilla vim user then Yi should feel pretty comfortable to you. Its only deficiency in this aspect is macros IIRC.  It definitely seems like yi isn't active lately but I think these things come in cycles. Personally, I think the problem with Yi is that it's aimed at people who would like to write plugins in Haskell. But there's almost no documentation on how to do that. So the people who are interested enough in trying it out don't end up committing because they haven't written any plugins.  On the plus side, they've done a lot of good work with dependencies and such. I'm pretty sure the prelude problem is mostly solved now. Making it far more approachable for contributors."
haskell,38704v,ethercrow,6,Tue Jun 2 16:10:08 2015 UTC,"Yep, I agree. I wanted to write plugins, I could find a few examples and get a rough idea but beyond that not much. Still confused. Just a guess: perhaps it's because Yi isn't done yet/is changing and they don't want plugins to be written? I haven't seen this said anywhere but it would make sense. Also, on their site they acknowledge plugins being hard to make as a problem. So I guess they might be working on it too."
haskell,38704v,rdfox,2,Tue Jun 2 18:25:26 2015 UTC,What's wrong with vim macros in yi?
haskell,38704v,codygman,3,Wed Jun 3 00:28:57 2015 UTC,If someone finds a good tutorial I will give it another shot. Last time I tried Yi I couldn't figure out how to do basic things.
haskell,38704v,rdfox,2,Tue Jun 2 19:05:30 2015 UTC,I'm guessing you mean in regards to extensions?
haskell,38704v,codygman,3,Tue Jun 2 20:43:01 2015 UTC,Yes. Could you share some of your .spacemacs? I just installed spacemacs and want to configure for Haskell development.
haskell,38704v,mneq,1 point,Tue Jun 2 20:54:17 2015 UTC,"I don't have many customizations and this would probably be a better guide, but here's my .spacemacs in case it can help you somehow.  ;; -*- mode: dotspacemacs -*- ;; This file is loaded by Spacemacs at startup. ;; It must be stored in your home directory.  (defun dotspacemacs/layers ()   ""Configuration Layers declaration.""   (setq-default    ;; List of additional paths where to look for configuration layers.    ;; Paths must have a trailing slash (ie. `~/.mycontribs/')    dotspacemacs-configuration-layer-path '()    ;; List of configuration layers to load. If it is the symbol `all' instead    ;; of a list then all discovered layers will be installed.    dotspacemacs-configuration-layers '(                                        auto-completion                                        syntax-checking                                        (haskell :variables                                                 haskell-enable-haskell-process-log t                                                 haskell-enable-ghci-ng-support t)                                        purescript                                        extra-langs ;; Idris, Nim, etc                                        python                                        (git :variables                                             git-magit-status-fullscreen t                                             git-enable-github-support t                                             git-gutter-use-fringe t)                                        (colors :variables colors-enable-nyan-cat-progress-bar ,(display-graphic-p))                                        clojure                                        org                                        scala                                        rcirc                                        restclient                                        ;; if using develop branch                                        ;; shell                                        )    ;; A list of packages and/or extensions that will not be install and loaded.    dotspacemacs-excluded-packages '()    ;; If non-nil spacemacs will delete any orphan packages, i.e. packages that    ;; are declared in a layer which is not a member of    ;; the list `dotspacemacs-configuration-layers'    dotspacemacs-delete-orphan-packages t))  (defun dotspacemacs/init ()   ""Initialization function. This function is called at the very startup of Spacemacs initialization before layers configuration.""   (autoload 'haskell-indentation-enable-show-indentations ""haskell-indentation"")   (autoload 'haskell-indentation-disable-show-indentations ""haskell-indentation"")   ;; This setq-default sexp is an exhaustive list of all the supported   ;; spacemacs settings.   (setq-default    ;; Specify the startup banner. Default value is `official', it displays    ;; the official spacemacs logo. An integer value is the index of text    ;; banner, `random' chooses a random text banner in `core/banners'    ;; directory. A string value must be a path to a .PNG file.    ;; If the value is nil then no banner is displayed.    ;; dotspacemacs-startup-banner 'official    dotspacemacs-startup-banner 'official    ;; List of themes, the first of the list is loaded when spacemacs starts.    ;; Press <SPC> T n to cycle to the next theme in the list (works great    ;; with 2 themes variants, one dark and one light)    dotspacemacs-themes '(solarized-dark                          solarized-light                          leuven                          monokai                          zenburn)    ;; If non nil the cursor color matches the state color.    dotspacemacs-colorize-cursor-according-to-state t    ;; Default font. `powerline-scale' allows to quickly tweak the mode-line    ;; size to make separators look not too crappy.    dotspacemacs-default-font '(""Source Code Pro""                                :size 13                                :weight normal                                :width normal                                :powerline-scale 1.1)    ;; The leader key    dotspacemacs-leader-key ""SPC""    ;; Major mode leader key is a shortcut key which is the equivalent of    ;; pressing `<leader> m`. Set it to `nil` to disable it.    dotspacemacs-major-mode-leader-key "",""    ;; The command key used for Evil commands (ex-commands) and    ;; Emacs commands (M-x).    ;; By default the command key is `:' so ex-commands are executed like in Vim    ;; with `:' and Emacs commands are executed with `<leader> :'.    dotspacemacs-command-key "":""    ;; If non nil the paste micro-state is enabled. While enabled pressing `p`    ;; several times cycle between the kill ring content.    dotspacemacs-enable-paste-micro-state t    ;; Guide-key delay in seconds. The Guide-key is the popup buffer listing    ;; the commands bound to the current keystrokes.    dotspacemacs-guide-key-delay 0.4    ;; If non nil a progress bar is displayed when spacemacs is loading. This    ;; may increase the boot time on some systems and emacs builds, set it to    ;; nil ;; to boost the loading time.    dotspacemacs-loading-progress-bar t    ;; If non nil the frame is fullscreen when Emacs starts up.    ;; (Emacs 24.4+ only)    dotspacemacs-fullscreen-at-startup nil    ;; If non nil `spacemacs/toggle-fullscreen' will not use native fullscreen.    ;; Use to disable fullscreen animations in OSX.""    dotspacemacs-fullscreen-use-non-native nil    ;; If non nil the frame is maximized when Emacs starts up.    ;; Takes effect only if `dotspacemacs-fullscreen-at-startup' is nil.    ;; (Emacs 24.4+ only)    dotspacemacs-maximized-at-startup nil    ;; A value from the range (0..100), in increasing opacity, which describes    ;; the transparency level of a frame when it's active or selected.    ;; Transparency can be toggled through `toggle-transparency'.    dotspacemacs-active-transparency 90    ;; A value from the range (0..100), in increasing opacity, which describes    ;; the transparency level of a frame when it's inactive or deselected.    ;; Transparency can be toggled through `toggle-transparency'.    dotspacemacs-inactive-transparency 90    ;; If non nil unicode symbols are displayed in the mode line.    dotspacemacs-mode-line-unicode-symbols t    ;; If non nil smooth scrolling (native-scrolling) is enabled. Smooth    ;; scrolling overrides the default behavior of Emacs which recenters the    ;; point when it reaches the top or bottom of the screen.    dotspacemacs-smooth-scrolling t    ;; If non-nil smartparens-strict-mode will be enabled in programming modes.    dotspacemacs-smartparens-strict-mode nil    ;; If non nil advises quit functions to keep server open when quitting.    dotspacemacs-persistent-server nil    ;; The default package repository used if no explicit repository has been    ;; specified with an installed package.    ;; Not used for now.    dotspacemacs-default-package-repository nil)   ;; User initialization goes here    ;; use authinfo.gpg   (setq rcirc-authinfo-support t)    )  (defun dotspacemacs/config ()   ""Configuration function.  This function is called at the very end of Spacemacs initialization after layers configuration.""   (setq rcirc-server-alist         '((""irc.freenode.net""            :user ""codygman""            :channels (""#emacs""))))    ;; load custom org agenda mode stuff   ;; (load-file ""~/.emacs.d/org-mode-day-planner.el"")   ;; (eval-after-load 'org-agenda)   (evil-leader/set-key ""or"" 'org-remember)   (evil-leader/set-key ""oc"" 'org-capture)   (evil-leader/set-key ""oa"" 'org-agenda) )  ;; Do not write anything past this comment. This is where Emacs will ;; auto-generate custom variable definitions."
haskell,38704v,ethercrow,2,Tue Jun 2 21:17:37 2015 UTC,I had exactly the same experience!
haskell,38704v,mneq,3,Tue Jun 2 21:04:39 2015 UTC,"I've been interested in Yi for a while, but I've never been able to install it successfully. It doesn't seem to matter if I install in Linux or Windows; I tried most recently in Windows. That was not fun; getting cabal to install just the dependencies was massively frustrating. (charsetdetect-ae, in particular, fails to install and gives some rather mystifying errors without tweaking a C file in libcharsetdetect.) Yi.Types also imports from vty unconditionally, so -f-vty still results in breakage. I really, really want to use Yi. But I can't, because I can't build it."
haskell,38704v,gfixler,3,Wed Jun 3 15:48:42 2015 UTC,"Yi.Types also imports from vty unconditionally, so -f-vty still results in breakage.   Just fixed that in master, it was probably caused by a merging accident. Thank you for reporting."
haskell,38704v,ethercrow,1 point,Wed Jun 3 17:49:44 2015 UTC,"Oh nifty, I may come back to this later. Thanks :)"
haskell,38704v,gfixler,1 point,Thu Jun 4 17:50:44 2015 UTC,I'm getting this:  cabal: Error: some packages failed to install: text-icu-0.7.0.1 failed during the configure step. The exception was: ExitFailure 1 yi-0.12.0 depends on yi-language-0.2.0 which failed to install. yi-language-0.2.0 failed during the building phase. The exception was: ExitFailure 1 yi-rope-0.7.0.1 depends on text-icu-0.7.0.1 which failed to install.
haskell,38704v,Bzzt,1 point,Tue Jun 9 08:22:40 2015 UTC,"text-icu failed to install, error message was somewhere earlier in the build log. Most probably you don't have icu4c libraries and headers on your system.  If you're using OS X then there's additional caveat: you have to tell cabal where to find said libraries and headers, see http://stackoverflow.com/questions/7420514/using-text-icu-library-in-haskell-on-mac-os"
haskell,38704v,Bzzt,1 point,Tue Jun 9 14:12:41 2015 UTC,Thanks. I'm on Linux. One of these days I'll understand how to find which headers I'm missing when my Haskell builds fail.
haskell,38704v,codygman,1 point,Tue Jun 9 18:16:22 2015 UTC,not compiling on nix... ah well.
haskell,38704v,codygman,2,Tue Jun 2 18:17:40 2015 UTC,"nixpkgs master works, but i understand that isn't the most cheery answer to your problem"
haskell,38704v,codygman,1 point,Tue Jun 2 19:15:36 2015 UTC,Well I've gone this long without yi... I can wait another few weeks.  Good to know a solution is in the pipeline.
haskell,38704v,Bzzt,1 point,Tue Jun 2 20:07:09 2015 UTC,Is there an easy way to backport from master to unstable?
haskell,38704v,codygman,1 point,Tue Jun 2 20:42:20 2015 UTC,"i don't know what you want for a backport, but you can always build just the package you want from the master branch. alternatively you can use the nixpkgs-channel repository to find the commit your local channel can be updated to and try to cherry-pick the changes to the nix-expressions you need from the master branch of the nixpkgs repository. that way you should get the same updated software you want, bot not having to rebuild a bunch of other stuff that has changed as well"
haskell,387ex0,logicchains,42,Tue Jun 2 11:39:49 2015 UTC,"Lazy state and lazy writer cannot be captured by any effect system. Quite simply anything using ""free"" is going to be pulling effects from the wrong end of an infinitely long queue when you do something like  foo = do   foo   modify (1:)   which works fine with Control.Monad.State today.  On the other hand, you might be working in a strict language, like Idris, where these things just don't exist, so you haven't lost anything yet.  Next, if you use a simple free monad full of effects you have the wrong asymptotics for left associated joins and can't handle Cont r effects. On the other hand, you might be in a proof assistant of some sort that requires strictly positive types, and this wasn't in the cards anyways.  Another issue with the direct ""free"" encoding is that left associated (>>=)'s in a normal free monad are potentially very slow, having the wrong asymptotics.  If it is available, and you use Codensity applied to such a free monad then you can fix those asymptotics, in exchange for getting the wrong asymptotics for repeatedly accessed structures. Codensity also results in structures that are ""too big"". The approach in that paper is Codensity based, so it holds here.   Codensity ((->) s) a is isomorphic to State s a, not s -> a.   Codensity m is much bigger than m in general.  You can fix that by taking the right Kan extension of your responses along your request types, splitting up your open sum type into two open sum types. One of requests and one of responses:  Eff xs a = forall r. (a -> Request xs r) -> Response xs r   You get a much uglier monad. Evaluation becomes less efficient as (>>=) no longer comes for free, but now you can handle Reader effects without the system constantly worrying you might be secretly working with State, while trying to quotient out that concern by just not exposing the methods a user would need to do so`, so that is something.  I wrote a library for that back in 2009.  http://hackage.haskell.org/package/monad-ran  Inside of it I included all of the mtl effects, but my state and writer were (necessarily) strict.  Next, there are other effects I tend to 'accrete' multiple times such as the Scope b transformer in Bound. It can be encoded as an effect, but without reflection without remorse it means that when you revisit a branch of your syntax tree you pay to re-evaluate the whole thing, from scratch, every time. This doesn't yield a very fast compiler.  If you use reflection without remorse you get terrible constant factors, but now you don't have the usual Codensity/Kan extension problems. I don't know how to handle Cont effects under that model, but it may be possible.  The version in that paper requires Typeable state. StateT (State s) (ST s) is something that can be quite useful, and neither monad involved is Typeable. With more modern type system features you can avoid that concern with closed type families or other tricks, but you now have traded a lot of inference for multiple states. YMMV, but I prefer inference to scoped type variables and a ton of manual signatures.  There are a lot of reasons to be wary of effect systems as a total replacement for the mtl.  On the other hand, for the effects that they can handle, using effect handlers remains a reasonable point in the design space. And effects like lazy state, backwards state, the tardis, lazy writer, bound scopes, etc. aren't really in that subset.  I perfectly well understand the desire of folks to avoid the mtl classes and the n2 instances you need to work with them, but, finally, there is one last issue that keeps me from loving effect systems: Handlers lie.  You can have a handler for Cont r effects and a handler for Writer e effects, but when you compose them you fail to pass the MonadWriter laws!!!  In the mtl we can signal that by the lack of a MonadWriter instance. With the handler model you get no indicator that your attempt to handle one class of effect caused you to fail to handle another in a law-abiding manner.  For basic Lawvere theories you get by fine for the things that fit, but for things like Cont r which go beyond that model there are silent law failures!  We have to write the ""O( n2 ) instances"" in the mtl because some of them are very very deliberately missing.  This combination of factors make me very leary of effect handlers in a lazy language. I'm much more amenable to the notion of them in a strict language where I have to use strictly positive types such as Idris, however, but you need to implement them carefully (e.g. without remorse) or you get the wrong asymptotics, and you need to concern yourself with handlers that may cause other handlers to lie about passing the laws that are carried along with their effects."
haskell,387ex0,edwardkmett,8,Tue Jun 2 15:23:46 2015 UTC,"No, they are not. See Edward Kmett's comments in http://www.reddit.com/r/haskell/comments/1j9n5y/extensible_effects_an_alternative_to_monad/"
haskell,387ex0,int_index,5,Tue Jun 2 12:22:56 2015 UTC,"One of the objections was performance, which is (IIUC) neatly solved with the ""Reflection without Remorse"" approach. I wonder if any of the other objections have lessened with time and progress or if any new ones have arisen."
haskell,387ex0,rpglover64,11,Tue Jun 2 14:59:11 2015 UTC,"Reflection without remorse resolved the asymptotics issue amazingly well, but the constant factors are still troubling. I've been struggling to get a ""win"" out of it in production."
haskell,387ex0,edwardkmett,10,Tue Jun 2 15:25:55 2015 UTC,"One of the objections was performance, which is (IIUC) neatly solved with the ""Reflection without Remorse"" approach.   No, it is not.  It is addressed by my monad-classes, however."
haskell,387ex0,roche,2,Tue Jun 2 15:32:55 2015 UTC,Would you recommend the use of your package in production as an alternative to mtl?
haskell,387ex0,rpglover64,6,Tue Jun 2 17:27:33 2015 UTC,"I am using this package in production. In fact, the needs of my system at work were one of the big drivers behind this development."
haskell,387ex0,roche,5,Tue Jun 2 18:50:40 2015 UTC,"My understanding is that extensible effects are essentially a fancy way of taking free monads of coproducts of functors, with various type tricks used to make them practical."
haskell,387j4l,asswaxer,21,Tue Jun 2 12:22:45 2015 UTC,"Just to clarify the appropriate use of terminology. Here, X, Y and Z are not types. Direction is a type, and X, Y and Z are the values which inhabit it. Other commenters have explained how to obtain an exhaustive list of such values."
haskell,387j4l,pigworker,1 point,Tue Jun 2 13:03:50 2015 UTC,"I would normally call X, Y and Z type constructors in this particular context. Do you think that makes sense?  E: got schooled below, thank you kind folks."
haskell,387j4l,PM_ME_UR_OBSIDIAN,10,Tue Jun 2 15:13:57 2015 UTC,I think folks usually call those “data constructors” or just “constructors”
haskell,387j4l,jonsterling,9,Tue Jun 2 15:25:20 2015 UTC,"Direction is a type constructor. Type constructors live at the type level and are used as part of the type checker. Type variables can unify with type constructors and other type variables.  X, Y, and Z are data constructors. They live at the value level and are used to construct values that have a given type."
haskell,387j4l,edwardkmett,2,Tue Jun 2 15:46:34 2015 UTC,"Awesome, thank you!"
haskell,387j4l,PM_ME_UR_OBSIDIAN,16,Tue Jun 2 15:59:26 2015 UTC,Add deriving (Enum) to the end of the data declaration. This gives you an instance of Enum.
haskell,387j4l,tailcalled,25,Tue Jun 2 12:27:32 2015 UTC,"You probably want deriving (Enum,Bounded), and then you can use [minBound..maxBound] to represent a list of all the data constructors."
haskell,387j4l,andrewthad,3,Tue Jun 2 12:36:30 2015 UTC,"Whoops, yeah."
haskell,387j4l,tailcalled,8,Tue Jun 2 12:38:37 2015 UTC,If you add deriving Enum you can do enumFrom X to list all.
haskell,385b3k,dalaing,12,Mon Jun 1 23:27:23 2015 UTC,"I just came here to complain because I read the title as ""Free Coffee"" and there's no such thing there.  Have a good day."
haskell,385b3k,bananu7,5,Tue Jun 2 10:00:13 2015 UTC,So how long until we have -XDerivePairedFunctor? :)
haskell,385b3k,rampion,3,Tue Jun 2 02:32:38 2015 UTC,"Heh.  I spoke to Ed a little bit about the Pairing trick after Lambda Jam, and he mentioned that the pairings aren't necessarily unique (because of something to do with adjunctions).    Unfortunately it was loud at the bar, I was tired, and I had questions for Ed based on his talk, so I just mentally bookmarked that point and moved on without thinking about it much further :/  By the end of this series I should have a small handful of useful but boilerplate-y things, so I might have a play around with generics and/or Template Haskell and see how far I can get."
haskell,385b3k,edwardkmett,5,Tue Jun 2 02:59:26 2015 UTC,"If you have f -| g -| h then you can pair g with either f or h.  newtype Const a b = Const a  newtype Lim f = Lim (forall a. f a) data Colim f where   Colim :: f a -> Colim f   gives you a threeway adjunction like that:  Colim -| Const -| Lim   (This is weaker than the corresponding construction in ""real"" category theory because parametricity is a stronger claim than naturality, so you can't use this version to derive products and coproducts from the adjoints to the diagonal functor.)  This is why the Zap machinery in older versions of the adjunctions package wound up being based on passing a data type instead of a class, figuring that you could compose the structures as you needed.  http://hackage.haskell.org/package/adjunctions-0.5.2/docs/Data-Functor-Zap.html"
haskell,385b3k,markandrus,2,Tue Jun 2 08:15:10 2015 UTC,"Ah, that makes more sense.  I was trying to work out what issues would arise if you went back and forward multiple times through the same pairing."
haskell,385b3k,manpacket,3,Tue Jun 2 09:24:44 2015 UTC,Fantastic post! The way I've written interpreters for free monads before (much like the interpret example you gave) has always felt a little ad hoc to me. I'm glad to see there is a more general pattern to follow. Looking forward to future posts.
haskell,385b3k,edsko,3,Tue Jun 2 08:14:45 2015 UTC,Is video available anywhere?
haskell,385b3k,heisenbug,7,Tue Jun 2 03:40:26 2015 UTC,"It normally takes a little while until the talks are uploaded.  You can keep an eye on the YOW! Youtube channel, but I can also post a link to it in /r/haskell when it comes out."
haskell,385b3k,heisenbug,3,Tue Jun 2 03:53:51 2015 UTC,"Very nice article! You mention adjunctions in the comments below, but what precisely is the connection between Pairing and adjunctions? (The curry/uncurry example is of course every computer scientist's favourite example of an adjunction :)"
haskell,385b3k,andrewthad,2,Tue Jun 2 11:24:53 2015 UTC,The curry/uncurry adjunction (isomorphism) is not a free/forgetful/cofree-like adjunction.
haskell,385b3k,sciolizer,2,Tue Jun 2 12:01:50 2015 UTC,"There is still a pairing for that adjunction though:  instance Pairing ((->) a) ((,) a) where   pair p f = uncurry (p . f)  instance Pairing ((,) a) ((->) a) where   pair p f g = p (snd f) (g (fst f))"
haskell,385b3k,gatlin,1 point,Tue Jun 2 12:08:49 2015 UTC,Great to see it goes both ways :-)
haskell,383brp,edsko,7,Mon Jun 1 15:36:47 2015 UTC,"The security paragraph reminds me, we forgot doing the keysigning party! :-| Great job on the Cabal hacking though!"
haskell,383brp,quchen,2,Mon Jun 1 18:01:20 2015 UTC,"Yep, I made that same observation at the pub on Sunday! Oh well, next time :)"
haskell,383brp,ocharles,5,Mon Jun 1 18:06:10 2015 UTC,"Since we talked a bit over the weekend, there has got to be a shared secret among (just) us. My fingerprint is   73C9 44F6 FC05 E4C0 2665 B580 BAD0 B1A4 F959 052C   and our shared secret is that uhmmm you have a beard!"
haskell,383brp,quchen,3,Mon Jun 1 18:17:14 2015 UTC,Tell me my beard length to the nearest mm and I'll sign your key. Deal?
haskell,383brp,ocharles,7,Mon Jun 1 18:44:40 2015 UTC,"Nice work! Clearly, we need more ZuriHac events per year... can't wait to see what's next... =)"
haskell,383brp,RedLambda,3,Tue Jun 2 07:14:41 2015 UTC,Actually we want to run a couple infrastructure focused hackathons in London.
haskell,383brp,dcoutts,1 point,Tue Jun 2 08:37:01 2015 UTC,I would absolutely 100% come to these.
haskell,383brp,Crandom,4,Wed Jun 3 17:36:19 2015 UTC,"Good work! It looks like the separate sections per remote-repo would also be useful for setting separate username/password combinations for, say, an internal and external hackage and being able to upload to both of them."
haskell,383brp,cameleon,1 point,Mon Jun 1 18:51:06 2015 UTC,Yes indeed. Want to send us a patch? :-)
haskell,383brp,dcoutts,2,Mon Jun 1 23:26:43 2015 UTC,"I could definitely do that since we would be able to use it internally, however, we depend on one extra thing: HTTPS support. Our internal hackage is only accessible over HTTPS, and last I checked, cabal (or actually the HTTP package) couldn't handle that. Is that still the case?"
haskell,383brp,cameleon,3,Tue Jun 2 12:07:43 2015 UTC,I have an open pull request to add that support -- I don't know what remains to be done before it can be merged: https://github.com/haskell/cabal/pull/2613
haskell,383brp,gbaz1,2,Tue Jun 2 15:44:50 2015 UTC,"Nothing afaik, just time to review."
haskell,383p16,gracjan,7,Mon Jun 1 17:03:43 2015 UTC,"I really like these updates. I don't use Emacs or haskell-mode, but I like how it shows the project is active, it makes me want to be involved, and I imagine it's a nice way for users to stay up-to-date on improvements to haskell-mode itself."
haskell,383p16,MaxGabriel,3,Tue Jun 2 03:12:47 2015 UTC,Glad you like it!  Helping people to get involved is my goal with those updates.
haskell,383p16,deadmaya,4,Tue Jun 2 07:13:28 2015 UTC,"Thank you for such posts. Firstly, it reminds me to update haskell-mode. Secondly, it makes it easier to find new features and fixed stuff. Previously I was reading commits :D And it wasn't cool. So keep posting!   Update after I've read the post  Nice month! I am very happy to see how the mode being improved more and more."
haskell,383p16,jaseemabid,3,Tue Jun 2 11:16:56 2015 UTC,Every month haskell-mode gets more and more solid. All the really small but annoying problems you have experienced? Probably one or two is already fixed!  You may use melpa-stable for somewhat stable experience or just melpa directly if life on the bleeding edge is your thing.
haskell,3825hc,ibotty,12,Mon Jun 1 08:44:33 2015 UTC,"It’s a little bit weird instead of having M (m r) we instead have M (m (Proxy ...)) however this doesn’t seem like a big deal because we have Pure to promote an r to a Proxy .... r. So we can lift some m r to Proxy a' a b' b m r with M . fmap Pure. It’s still not clear to me why this is a benefit though.   Without that you can't interleave side effects in m with further streaming - you would only have the ability to terminate with a side effect. It returns a Proxy because it's basically a free monad, so it's ""returning"" the next step of the computation (which may be to terminate with Pure, but it doesn't have to be)"
haskell,3825hc,ocharles,5,Mon Jun 1 18:08:39 2015 UTC,"Oh look, another free monad!  data ProxyF a a' b b' res =     Request a' (a -> res)     | Respond b (b' -> res)     deriving Functor  -- use a newtype here if you're implementing this for real -- but this type is isomorphic to the one listed in the article. type Proxy a a' b b' m r = FreeT (Proxy a a' b b') m r   The 'include a ""pure"" constructor' is a Haskell antipattern, IMO.  It locks you into an implementation of >>= that has quadratic cost if you use the wrong associativity.  If you're writing a free monad, use one of the packages that implement them efficiently."
haskell,3825hc,ryani,18,Mon Jun 1 16:35:11 2015 UTC,"This is how pipes was implemented back in the old days.  The reason I no longer use the FreeT type was for a constant-factor performance improvement.  I also am the one who came up with the name FreeT for what was previously known as Coroutine and wrote up the first implementation of FreeT on Hackage which was later merged into the free library, so the correspondence to the free monad transformer was not lost on me.  I'm also quite aware of the quadratic time complexity for certain operations, but the naive implementation of a free monad has very good constant factors and pipes is structured in such a way that you avoid the cases with quadratic time complexity.  For example, instead of writing:  replicateM 10 foo   You instead write:  Pipes.Prelude.replicateM 10 foo   That gives a right-associative bind and also streams the results.  Same thing for sequence and mapM, which have right-associative streaming versions in Pipes.Prelude."
haskell,3825hc,Tekmo,2,Mon Jun 1 18:30:03 2015 UTC,"I'm not sure how you can really avoid the 'quadratic costs', at the very least you're paying a penalty for any abstraction.  Any time you write  do    x <- some_function    rest of computation   You pay for an extra layer of >>= for all the binds inside of some_function.  While it's not 'quadratic', since we aren't talking about recursive functions here, it's still a penalty on abstraction that gets worse the more abstraction you use.  Is the performance a lot worse using some of the ""Free Monads for less"" techniques instead of naive Free/FreeT?"
haskell,3825hc,ryani,8,Mon Jun 1 19:19:51 2015 UTC,"There was a long discussion about it here including benchmarks.  For some benchmarks the alternatives were between 1.5x to 3x times slower.  Yes, you will get a constant factor overhead for sequencing two large computations, but it's small (at least, smaller than the constant factor slowdown from using another implementation)."
haskell,3825hc,Tekmo,6,Mon Jun 1 19:47:33 2015 UTC,"Have you tried the Reflection Without Remorse approach? It has benchmarked pretty well for me in my OCaml implementation, at least."
haskell,3825hc,twistier,3,Tue Jun 2 02:03:10 2015 UTC,Not yet.  Is there a standard implementation of it in Haskell?
haskell,3825hc,Tekmo,4,Tue Jun 2 02:45:10 2015 UTC,"I'm not aware of a standard one. I guess that's a blocker.  Edit: I should also point out that the fastest version I've written is more like operational than free, but it's not like the operational version you will probably find first. From memory, it's something like this:  data Free f a   = Return a   | forall e. Bind (f e) (TSequence (Kleisli (Free f)) e a)"
haskell,3825hc,twistier,5,Tue Jun 2 02:50:01 2015 UTC,"Atze van der Ploeg has implemented it himself, using his type-aligned library, here.  The extensible-effects library implements it separately also using type-aligned here.  I studied using type-aligned in this way while trying to construct an optimized library of combinators for something equivalent to Producer a m r and FreeT (Producer a m) m r in the pipes sense: https://github.com/michaelt/remorse In the end I had to omit the use of type-aligned from my tests, for reasons that will be clear if you look at the lines marked 'remorse' here http://michaelt.github.io/bench/a.html  and compare it with a similar without a type-aligned free monad like the one in the middle of the page here: https://github.com/michaelt/series"
haskell,3825hc,michaelt_,2,Tue Jun 2 07:37:19 2015 UTC,there is also an implementation in (a branch of) ekmett's free.
haskell,3825hc,twistier,2,Tue Jun 2 08:16:50 2015 UTC,"Unfortunately, type-aligned's ""FastQueue"" is really, really slow. That's why I don't recommend it."
haskell,3825hc,NiftyIon,4,Tue Jun 2 11:22:46 2015 UTC,"Could you elaborate on the quadratic cost thing, or provide a link to more info? I'm very curious."
haskell,3825hc,ryani,10,Mon Jun 1 17:25:55 2015 UTC,"Sure.  I'll use a simpler monad just to give you the example.  data M a = Pure a | Read (Char -> M a) instance Monad M where     return = Pure     Pure a >>= f = f a     Read k >>= f = Read (\c -> k c >>= f)  read :: M Char read = Read (\c -> return c)   This type represents programs that need some number of characters of input, dependent on the input, before giving a result.  For example, a program could read matched pairs of () until the first ( is closed, then report the the maximum depth of () found.  Now, consider this function:  ignore :: M () ignore = read >>= \_ -> return ()  ignoreN_1 :: Int -> M () ignoreN_1 0 = return () ignoreN_1 n = ignore >>= \_ -> ignoreN_1 (n-1)  ignoreN_2 :: Int -> M () ignoreN_2 0 = return () ignoreN_2 n = ignoreN_2 (n-1) >>= \_ -> ignore   These two implementations of ignoreN both skip n characters.  Now consider how many times >>= has to be evaluated in each of these cases.  First, ignore:  ignore = read >>= \_ -> Pure () -- read ignore = (Read (\c -> Pure c)) >>= \_ -> Pure () -- one evaluation of >>= ignore = (Read (\c -> Pure c >>= \_ -> Pure ())) -- one evaluation of >>= ignore = (Read (\c -> (\_ -> Pure ()) c)) -- simplify ignore = (Read (\c -> Pure ()))   So ignore evaluates >>= twice.  Now, ignoreN_1.  The base case (return ()) evaluates >>= 0 times.  The recursive case:  ignoreN_1 n -- evaluate ignore >>= \_ -> ignoreN_1 (n-1) -- 2 evaluations of >>= in ignore (Read (\c -> Pure ())) >>= \_ -> ignoreN_1 (n-1) -- 1 evaluation of >>= Read (\c2 -> (\c -> Pure ()) c2 >>= \_ -> ignoreN_1 (n-1)) -- beta c2 Read (\c2 -> Pure () >>= \_ -> ignoreN_1 (n-1)) -- 1 evaluation of >>= Read (\c2 -> (\_ -> ignoreN_1 (n-1)) ()) -- beta Read (\c2 -> ignoreN_1 (n-1))   So we have this equation for # of >>= evaluations:  ignoreN_1 0 => 0 >>= ignoreN_1 n => 4 + ignoreN_1 (n-1) >>=   So ignoreN_1 n evaluates >>= 4*n times.  Now, ignoreN_2.  Base case is the same.  ignoreN_2 n -- evaluate ignoreN_2 ignoreN_2 (n-1) >>= \_ -> ignore -- ignoreN_2 is going to reduce in some number of >>=s to -- Read (\c -> ... (Read \c -> Pure ())...)  (n-1 copies of Read) (Read ... \c -> Pure()) >>= \_ -> ignore -- >>= is evaluated n times to give Read (\c -> ... Read (\c -> (Pure () >>= \_ -> ignore)  -- evaluate >>= 1 more time Read (\c -> ... (\c -> ((\_ -> ignore) ())) ...) -- beta Read (\c -> ... (\c -> ignore) ...) -- evaluate ignore (2 >>=s) Read (\c -> ... (\c -> Read (\c -> Pure ())) ...)   So ignoreN_2 n evaluates >>= (n+3) + # of >>= evaluated by ignoreN_2 (n-1) times.  Table:  n >>=s 0 0 1 3 2 7 3 13 4 20   This ends up as O(n2 )."
haskell,3825hc,NiftyIon,5,Mon Jun 1 19:15:18 2015 UTC,"Ah, I understand now. Thanks for writing it out so clearly! How is it possible to avoid this? (Why does using FreeT help?)  Edit: Looks like there's a lot of useful information here, which was linked to up-thread. Thanks!"
haskell,3825hc,Faucelme,4,Mon Jun 1 19:51:47 2015 UTC,See also demystifying dlist that explains a similar problem in the context of list concatenation.  The analogue of dlist for monads is Codensity.
haskell,3825hc,twistier,3,Mon Jun 1 19:56:46 2015 UTC,http://okmij.org/ftp/Haskell/Reflection.html
haskell,3825hc,dcoutts,4,Tue Jun 2 02:06:05 2015 UTC,I gave a talk at ZuriHac with an example where you really do want a deep embedding of composition for performance reasons. It felt a bit odd since I know it's not the recommended practice.
haskell,3825hc,Categoria,2,Mon Jun 1 23:45:34 2015 UTC,Do machines next!
haskell,382e4w,stingraycharles,5,Mon Jun 1 10:43:47 2015 UTC,"These are my first ""real"" contributions to the Haskell ecosystem, so I would be very glad to get feedback."
haskell,382e4w,joeyh,6,Mon Jun 1 12:30:15 2015 UTC,"Looking at the code, my impression is it could use more types.    type OnionAddress = Base32String  type Port = Integer  type TorControlServerSocket = Socket   Of course, newtype might be better for some of these; perhaps TorControlServerSocket could be an entirely opaque type."
haskell,382e4w,joeyh,3,Mon Jun 1 13:59:25 2015 UTC,"Good points. I think the fact that I'm passing around a TorControlServerSocket is kind of a hack; it actually represents the state of the session (only in this case, all state is represented by a single socket).   I think it would be best to encapsulate that in a data Context or something like that."
haskell,382tej,stmu,8,Mon Jun 1 13:18:39 2015 UTC,"Hey this is a really cool exercise!  Here are some tips from another beginner:   I don't like parseTimeLine. Why not think in terms of the things that make a TimeStamp? For example, I'd code a Time parser, then using the applicative instance, TimeStamp <$> parseTime <* string ""-->"" *> parseTime. I like Applicative :D use one of haskell time libraries, instead of writing your own. .srt can have DVD formatting options[1], which would break this parser. add an option parser, head args is too pythonic ;)"
haskell,382tej,clrnd,6,Mon Jun 1 14:03:13 2015 UTC,"Conversion time -> milliseconds : I could not wrap my head around this and finally wrote my own   Could you be more specific on this?   The code in the Left/Right result of the parsing (basically everything after the -> arrow) : How does this work?   Either is defined like this:  data Either a b = Left a                 | Right b   The pipe | essentially means ""or"", so you can read that a bit like ""The type Either has two type variables a and b. It has two data constructors, Left a and Right b"".  The value of the expression parse parseSubtitles ""(stdin)"" c is Either a b. You don't know ahead of time what value you'll get, so you need to account for getting a Left (error) and a Right (success).  When you use a case expression, you're saying ""Evaluate this expression, and I'll pattern match on the result. Then execute whatever follows the arrow in that case."" Pattern matching starts from the top, looks at the data constructor used to make the value, and tries to see if it can make a match.  So:  case parse parseThing of     Left e -> putStrLn ""Error!""     Right s -> putStrLn ""Success!""   can be read as ""Do parse parseThing, and in the case of the result being Left e, do putStrLn ""Error!"". In the case of the result being Right s, do putStrLn ""Success!""."
haskell,382tej,ephrion,1 point,Mon Jun 1 15:40:10 2015 UTC,"Thanks, awesome explanation!  I have a follow up question for the Right part.  mapM_ print (map (addDelaySubtitleBlock (read (head args) :: Integer)) r)   How can I know the type of r? I had thought this to be something like IO [SubtitleBlock], but instead it must be closer to [SubtitleBlock] as it compiled when I inserted map. I just tried different mapping functions until one worked.  With regards to the time. I was looking for a way to parse the time and construct a data type. Additionally, I was looking for a function with this type signature:  add :: Time -> Time -> Time   which I would then use in the addDelay* functions. Or I could just use an Integer to hold the milliseconds, mimicking the approach onmach toke."
haskell,382tej,ephrion,2,Tue Jun 2 11:17:12 2015 UTC,"I'm going to rewrite your expression a bit:  mapM_      print $     map          (addDelaySubtitleBlock (read (head args) :: Integer))         r   What's the type of mapM_? Hoogle saysmapM_ Monad m => (a -> m b) -> [a] -> m (). The underscore is used to indicate we don't care about the result (per Haskell convention). We can specialize m to IO and a to Subtitle Block to get the specialized type signature:  mapM_ :: (SubtitleBlock -> IO SubtitleBlock) -> [SubtitleBlock] -> IO ()   When I rewrote the expression, I tried to separate the arguments to the various functions. So mapM_ takes a function and a list. print is your function. Your list is the expression map $ addDelaySubtitleBlock ... r, and we already know the type of the list is [SubtitleBlock].  The type signature for map is (a -> b) -> [a] -> [b]. Since we know the final return type, we can specialize b to SubtitleBlock. The type signature now looks like:  map :: (a -> SubtitleBlock) -> [a] -> [SubtitleBlock]  So that first parameter to map is a function which takes an a and returns a SubtitleBlock. You partially applied addDelaySubtitleBlock to an Integer, which makes it a function of type SubtitleBlock -> SubtitleBlock. We can further specialize map's type signature now:  map :: (SubtitleBlock -> SubtitleBlock) -> [SubtitleBlock] -> [SubtitleBlock]   So r must be of type [SubtitleBlock]. Neat!  Alternatively, you could look at the return type of parse from the library you imported. Here's a link to the Hackage documentation. The return type is Either ParseError a, where a was defined by the first argument (of type Parsec s () a).  What generates a Parsec type? It must be parseSubtitles since that is passed to parse. The type of parseSubtitles is GenParser Char st [SubtitleBlock]. What's GenParser about? Back to the Hackage docs!  type GenParser tok st = Parsec [tok] st   I'm -- actually not entirely sure what's going on here. The type signature of your code indicates that GenParser takes three arguments, but here it only takes two. Perhaps Parsec is being partially applied here? Let's look at that!  Hackage link for Parsec type shows that:  type Parsec s u = ParsecT s u Identity   Another type synonym! Is ParsecT partially applied here? Is it, perhaps, expecting another argument?  data ParsecT s u m a   Ah! So it is! The docs on ParsecT say that a is the 'return type' of the Parser. So now, we can go all the way back to your code, and look at the type signature:  parseSubtitles :: GenParser Char st [SubtitleBlock]  And know that the return type of parse must be Either ErrorText [SubtitleBlock], since we have filled in the value for a.  The types in Haskell will tell you a lot, once you learn what the right questions are :)"
haskell,382tej,ephrion,1 point,Tue Jun 2 16:01:22 2015 UTC,I can't thank you enough for your amazing answers!
haskell,382tej,onmach,2,Wed Jun 3 09:42:13 2015 UTC,"As for adding time, it can get tricky since you need to account for rolling over. I would add a function normalizeTime :: Time -> Time which would mostly be the logic in the addDelayTimeminus adding a delay (eg, breaking the Time value into it's component parts in ms, then redistributing them appropriately).  From there, you can make a smart constructor for Time values that automatically does this. So you might have:  type Hour = Integer type Minute = Integer type Second = Integer type Millisecond = Integer time :: Hour -> Minute -> Second -> Millisecond -> Time time h m s ms = normalizeTime (Time h m s ms)   Now you can implement addTime like:  addTime :: Time -> Time -> Time addTime (Time h1 m1 s1 ms1) (Time h2 m2 s2 ms2) =      time (h1 + h2) (m1 + m2) (s1 + s2) (ms1 + ms2)   Or if you wanted to get crazy, you could do  instance Num Time where     (+) = addTime     -- etc... define the rest of the methods   And now you can add, multiply, subtract, etc. times with +, -, *, etc. instead of worrying about reimplementing that.  Then addDelayTime can be expressed as:  addDelayTime d t = (time 0 0 0 d) + t"
haskell,382tej,semigroup,6,Tue Jun 2 16:17:43 2015 UTC,"I wrote something that is almost exactly what you are writing, but I wrote it in attoparsec instead of parsec here.  Feel free to reuse any of that.  It is kind of lens heavy though."
haskell,382tej,sfvisser,4,Mon Jun 1 20:05:11 2015 UTC,"Hey, this is exactly the same project I took on when I first started learning Haskell!"
haskell,382ybn,jpvillaisaza,1 point,Mon Jun 1 13:58:38 2015 UTC,"Oh cool, I was using this for an example in the book too :)   We can think of the IO type as follows:  type IO a = World -> (a,World)    No. It doesn't tell the learner anything, so don't bother with (incorrect) explanations like this.   I mentioned this in my talk at LambdaConf, but if an explanation of something doesn't equip the learner with any explanatory power for their programs, it's not teaching them anything, so rather than confuse them, don't say anything. I don't understand this need to comment on everything that passes by. We cargo-cult so much of our work as programmers, why not leverage the one place where it's useful for avoiding incomplete, uninformative, or confusing explanations?"
haskell,382ybn,Mob_Of_One,4,Mon Jun 1 15:02:48 2015 UTC,"Agreed that at this level it doesn't make sense, but the way STG and the IO monad worked really helped me understand Haskell better when I was ready for that. It would likely be better to direct the reader to a correct explanation if it's a rabbit hole they're interested in: http://blog.ezyang.com/2011/05/unraveling-the-mystery-of-the-io-monad/   It's a very sloppy explanation but not that far from the truth if you squint hard enough:  -- libraries/ghc-prim/GHC/Types.hs newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)) -- libraries/base/GHC/Base.hs data RealWorld -- compiler/prelude/primops.txt.pp primtype State# s"
haskell,382ybn,etrepum,3,Mon Jun 1 19:07:43 2015 UTC,The only people that could read the truth out of that explanation are those that do not need it explained. It misleads and distracts and should be elided unless you're going to actually explain it.
haskell,381o9y,ianthehenry,14,Mon Jun 1 05:17:25 2015 UTC,"If you have an Applicative, you shouldn’t assume anything about the order of effects. If you are defining an Applicative (instance), you are free to perform effects in whatever order you want because no client can assume an order.  However, if you are planning on writing a Monad  instance for the type for which you are writing an Applicative instance, then you need to think carefully. The effects associated with Monads do have an order that a client can depend on (due to the possibility of data dependence), and making Applicative and Monad instances for the same type agree on effect ordering is customary.   This reasoning wraps back around at this point. If you have a particular Applicative for which you know there is a Monad (such as IO), custom lets you assume the effects will be evaluated left-to-right so as to be compatible with the Monad instance.  In summary, you should think of any Applicative you are given as potentially evaluating effects in parallel, but if you’re on the other side of the implementation and want effects to actually run in parallel, you should reconsider defining a Monad instance for the same type so that clients can reason about effects based on the concrete type."
haskell,381o9y,acow,2,Mon Jun 1 06:56:12 2015 UTC,"For a Real World example of this, see async bug #26 and either bug #38.  Concurrently from async is exactly an Applicative where you cannot write a Monad instance that agrees on the order of effects: because Concurrently is inherently concurrent in its arguments (and you can't see that when you just have Applicative), but Monad gives you the ability to sequence from LHS-to-RHS."
haskell,381o9y,aseipp,8,Mon Jun 1 21:13:28 2015 UTC,"The Applicative laws essentially state that any Applicative expression is ultimately equivalent to   pure f <*> x <*> y <*> z <*> ...   for appropriate values x, y, z, .... In this sense, law-abiding implementations of (<*>) have access to ordering ""by law"". A clearer way of seeing how this really works however is to explore the isomorphic Monoidal typeclass:   class Functor f => Monoidal f where    unit :: f ()    tup :: f a -> f b -> f (a, b)   If we ignore the differences between ((a, b), c) and (a, (b, c)) this helps suggest that all canonical Applicative values are like   ex :: Applicative f => f (a, b, c)   or   fmap (f :: (a, b, c) -> d) ex :: Applicative f => f d   So the heart of this is that Applicative ""effects"" all get bundled together into a single f layer and then the ""pure"" part can do anything a function from all of the pure arguments to another argument can do. In essence, Applicative has access to ordering of both effects and pure arguments, but has no compulsion to use them in any particular order.  On the other hand, Monad's bind gets us in a bind  (>>=) :: Monad m => m a -> (a -> m b) -> m b   It essentially is the only way to combine effects and values and it indicates something interesting—the value level and the effect level are dependent on one another since when computing m >>= fthe function f has the opportunity to look at the value of type a ""inside of"" mbefore it's compelled to provide the next ""step"".  Furthermore, a monad can't usually just ""ignore"" the next step because that's its only access to the type b. The only way for it to not care about the type b is to be phantom in its type parameter.  So in what way can a monad rearrange its order? Well, if it is not phantom in its parameter and in a call to m >>= fthe function f is strict in its argument then I feel reasonably confident then it cannot ignore the order—the type of f ensures that there's sufficient interleaving between the type and value layers.  But in Haskell functions are often lazy and if there isn't an actual data dependency between a and m b in the implementation of f then the actual order of operations may differ. Monads can even take advantage of this to save work."
haskell,381o9y,tel,1 point,Mon Jun 1 13:26:01 2015 UTC,I've only recently developed an intuition for why Applicatives/Monads behave the way they do.  I could not explain it in words better than you did! :)
haskell,381o9y,Fylwind,1 point,Mon Jun 1 18:55:35 2015 UTC,Thanks! :D
haskell,381o9y,tel,6,Mon Jun 1 19:32:02 2015 UTC,"Well, look at the type of <*>.  f (a -> b) -> f a -> f b   The reason it is called ""sequential application"" is not necessarily due to the effects being run sequentially. It is because the type parameters are being applied sequentially.  A composition of applicative actions is not necessarily ordered, but if they are (and many applicatives are), the convention is to make it so that (<*>) orders the left one before the right one. You can reverse the order, if there is an order, by using the Backwards applicative wrapper.  http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Applicative-Backwards.html"
haskell,381o9y,drb226,3,Mon Jun 1 06:07:11 2015 UTC,"Actually this is more than a convention, it's required (by ""law"", not enforced by the compiler) for Applicatives-that-are-also-Monads."
haskell,381o9y,drb226,3,Mon Jun 1 06:08:11 2015 UTC,"Is that really the case (which laws enforce this?), or is this just a convention created by the arbitrary choice that has been made for the Monad m => Applicative m instance of the standard library?"
haskell,381o9y,gasche,1 point,Mon Jun 1 07:48:20 2015 UTC,"The rule is that <*> should be the same as ap, which is implemented like so:  ap                :: (Monad m) => m (a -> b) -> m a -> m b ap m1 m2          = do { x1 <- m1; x2 <- m2; return (x1 x2) }   http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#ap"
haskell,381o9y,drb226,4,Mon Jun 1 07:53:56 2015 UTC,"I don't think this is a law of either Monads or Applicative (in the same sense as ""monad laws"" or ""applicative laws""). It is a convention imposed by this non-canonical definition. If you want, that is a side-effect of type-classes as a language feature (the fact that coherence issues makes it difficult to recognize, in the standard library, that there are two distinct ways to turn a Monad into an Applicative), rather than a property of those algebraic notions.  Edit: to clarify, the other way to build ap from a Monad, that I think is perfectly lawful, is  ap                :: (Monad m) => m (a -> b) -> m a -> m b ap m1 m2          = do { x2 <- m2; x1 <- m1; return (x1 x2) }"
haskell,381o9y,gasche,5,Mon Jun 1 08:10:26 2015 UTC,"The fact that <*> and ap are the same is documented in the Applicative class laws now:   If f is also a Monad, it should satisfy  pure = return  (<*>) = ap    From here."
haskell,381o9y,cameleon,2,Mon Jun 1 09:40:55 2015 UTC,"Thanks for the reference, I didn't know it had been edicted as a law. It is a wrong law, you should engage into the democratic process to abolish it! (Or at least recognize that it is arbitrary and should be taken as convention rather than law.)"
haskell,381o9y,gasche,2,Mon Jun 1 09:47:30 2015 UTC,"You can turn a monad into an applicative in two ways, but you can also turn an applicative into an applicative in two ways: by flipping the order or not flipping the order. It seems analogous to saying that we can turn a group into a monoid in two ways: by defining mappend a b = a * b or by defining mappend a b = b * a. Yet in math we still have a canonical way to  a group into a monoid, and these conventions are useful. It is technically arbitrary but at the same time it makes a lot of sense that we don't pick mappend a b = b * a. Technically arbitrary but not humanely arbitrary ;-)"
haskell,381o9y,julesjacobs,1 point,Mon Jun 1 12:43:03 2015 UTC,"I disagree with your group/monoid argument. A group is a tuple of a carrier set, a binary and a zero-ary operations, which verifies some equations. The natural way to turn a group into a monoid keeps the same carrier set, binary and zero-ary operations, and only weakens the laws. The fact that the operations are preserved is important, but not canonical.  That is, there is a canonical forgetful morphism from (G, *, 1) as a group to (G, *, 1) as a monoid, but we have specified the operations on both sides, and it is only with those fixed that the morphism is canonical (that is, uniquely defined). There is a ""natural"" (in the informal sense) morphism from ""any group on the carrier set G"" to ""some monoid on the carrier set G"" that preserves the information, but it is not stricto-sensu ""canonical"". (That said, reasonable person may disagree with this strong notion of canonicity and use weaker criterions that align with your usage.)  In the case of the Monad/Applicative morphism, ap is not part of the algebraic structure defining what a monad is. I fully agree that it is natural to take the same binary operations when moving from the group structure to the monoid structure. There is no such natural choice when turning a Monad into an Applicative -- ap is an arbitrary derived operation, there is no natural reason that it should be used and not its backward version.  In any case (whether you consider this canonical or not), my point still stand: this requirement is arbitrary while the other are not arbitrary. Only the non-arbitrary requirements should have the force of law."
haskell,381o9y,gasche,1 point,Mon Jun 1 13:32:26 2015 UTC,"A group is a (G, *, 1, inverse), inverse : G -> G, so we haven't just forgotten laws, but also operations (like we've forgotten bind when we go from a monad to an applicative). I understand your point that ap is not part of Monad, but I don't fully agree. Even before Applicative was a superclass of Monad there was a <*> combinator on monads that is/was the same as ap. It just happened to not be part of the standard definition of monad, but a monad is not its definition. A monad is a conceptual thing that can be defined in many equivalent ways. The fact that <*> has a different name than ap is a historical accident (but then again the same goes for groups: * has a different name than mappend). So I still don't see in what sense going from group to monoid is not arbitrary but going from monad to applicative is."
haskell,381o9y,julesjacobs,2,Mon Jun 1 14:24:04 2015 UTC,"I don't think it's a wrong law. Making the instances behave very differently is at best confusing to a user, and at worst will lead to horrible bugs. However, I think there's an argument to be had over what the equality means in these laws. For example, you could argue that in a case like haxl, the eventual returned values are the same, even though the Applicative can do requests in parallel where the Monad can't."
haskell,381o9y,cameleon,1 point,Mon Jun 1 18:45:19 2015 UTC,"It's not arbitrary. If we drop these laws there isn't a coherent superclass relationship any more.  For Applicative to be a superclass of Monad there needs to be a canonical way to get an Applicative from a Monad. This is where the two laws come from, and I think that if you abolish (<*>) = ap you also need to abolish pure = return for things to make sense."
haskell,381o9y,redxaxder,2,Mon Jun 1 13:24:50 2015 UTC,"Applicative being a superclass of Monad is the business of the Haskell type-class ecosystem, it is unrelated to the lawful properties of these algebraic objects that make sense outside the Haskell language. The type-class system of Coq for example has no problem with handling incoherent instances (they are incompatible at the type level and thus users can reliably work in an incoherent setting) and should have the exact same laws for Applicative and Monad -- except this odd one.   you also need to abolish pure = return for things to make sense   I don't think so: I think that you could prove that pure = return should hold even with a weaker compatibility law between bind and ap. Coming back to your group/monoid argument, this is one instance where the exact same operation is carried from one algebraic structur to another, so it is natural to keep the same one."
haskell,381o9y,gasche,3,Mon Jun 1 13:40:44 2015 UTC,"it is unrelated to the lawful properties of these algebraic objects that make sense outside the Haskell language   This is the level where our disagreement lives.   There's an idea in mathematics that is usually expressed informally. Every ring has a corresponding group. Every group has a corresponding monoid. Every R-algeba has a corresponding R-module. We can formalize this idea, and the way we do so should guide our intuition for other structures. The formalization I use is in terms of functors.  There exists a faithful functor from the category Ring to the category Group. Another one from Group to Monoid. There are two of them from Field to Group. When someone talks to me about a set with two algebraic structures that live in different categories, my default assumption is that one of them is the image of the other under a faithful functor. Otherwise I consider the two structures unrelated, and the identification of the underlying sets incidental.  So for me the question of the relationship between Applicative and Monad becomes ""For a category C, does there exist a faithful functor from Monads over C to Applicatives over C?"" And I expect that if some structure is being simultaneously interpreted as an applicative over C and a monad over C, then the applicative structure is the image of the monad structure under some faithful functor. This functor encodes how I expect these structures to be related.  I only know of one faithful functor from Monads over Ideal Hask to Applicatives over Ideal Hask. It satisfies (<*>) == ap. While I haven't gone through this in full detail, I'd be surprised if there was a another and it didn't have this property. (If you know of one, I will immediately come around to your point of view.)  Now, I normally reason informally -- I don't go track down faithful functors for everything I do. But this formalization in terms of faithful functors coincides with my vague discomfort at a structure that is both an X and a Y in a way that ""feels unrelated"".   *Edit : Regarding this:   there are two distinct ways to turn a Monad into an Applicative   Does your example construct applicatives that are not isomorphic to the usual ones? If so, that's pretty neat."
haskell,381o9y,redxaxder,3,Mon Jun 1 16:32:44 2015 UTC,"Sure it is Haskell-specific, but because Applicative is a superclass of Monad (that ship has sailed a long time ago), it should therefore behave consistently, otherwise people will get confused when they refactor a piece of code from ap to <*> and wonder why their program broke.  Not to mention, with the introduction of ApplicativeDo, if your Applicative/Monad behaves inconsistently, expect subtle breakage in the semantics of do-notation.  In principle, GHC is free to rewrite your code using the laws for optimization reasons, so this is not just a theoretical concern.   The type-class system of Coq for example has no problem with handling incoherent instances   But the whole point of type classes in Haskell is coherence!  It's what makes it unique compared to Coq/Agda and allows you to refactor code easily.  Coq/Agda makes up for that by having dependent types, which we don't. (See Edward Kmett's talk on type classes.)"
haskell,381o9y,Fylwind,1 point,Mon Jun 1 18:50:08 2015 UTC,"In fact on second reading I see that maybe the text is nuanced on this point: it says that the instances ""must"" satisfy the other laws given as equations, that they ""will"" satisfy the functor-compatibility equation (because I think it is implied by the layws), but only that it ""should"" satisfy this one. So it would be a recommendation of the law, rather than a mandate."
haskell,381o9y,gasche,1 point,Mon Jun 1 11:32:38 2015 UTC,"I'm not a native speaker, but I've looked at the text again, and I don't think the intentions were what you make of it. To me it seems like different words for the same thing: this is the class, and these are the laws all instances have to satisfy. Some are from the class itself, some are automatic from the superclass, and some are related to a subclass. Then again, since there's no type system enforcing these laws and no Haskell Class Law Police coming to your door, anyone can do what they want, although hopefully the community will come to some useful consensus."
haskell,381o9y,cameleon,3,Mon Jun 1 18:47:53 2015 UTC,"I've never met an Applicative that didn't have an order to its effects. Purity and the generality of the type signature for <*> kinda implies that a given instance must either pick left-to-right or right-to-left evaluation order and stick to it.   Look at the Ziplist applicative [a] with <*> = zipWith, the prototypic example of Applicative that is not a Monad. You have [f, g, h] <*> [a, b, c] = [f a, g b, h c], with no particular left-to-right or right-to-left ordering."
haskell,381o9y,gasche,3,Mon Jun 1 07:51:32 2015 UTC,"The way I understand it applicatives can be sequential in their evaluation, just like monads can be, but neither has to be."
haskell,381o9y,kqr,3,Mon Jun 1 05:49:33 2015 UTC,"You may want to look over this thread.  It's nominally about Monad, but most it says there applies to Applicative.  Short version:   Both Applicative and Monad allow but do not require instances to have a notion of effect ordering. The orders don't have to be the textual ones, and don't have to be total either. In Monad there is an extra thing going on, which is that some effects can only be known from the results of other effects.  Whereas in Applicative all effects are known ahead of time.  So even in types that are somewhat order-insensitive, a computation built up with Monad operations may have some order restrictions that don't exist in one built up from Applicative."
haskell,381o9y,sacundim,2,Mon Jun 1 07:15:37 2015 UTC,"Writing this all out, it feels like a dumb question. I've never met an Applicative that didn't have an order to its effects. Purity and the generality of the type signature for <*> kinda implies that a given instance must either pick left-to-right or right-to-left evaluation order and stick to it.   I recently wrote an article about an applicative that can have another order than left-to-right or right-to-left."
haskell,381o9y,jaspervdj,1 point,Mon Jun 1 11:49:48 2015 UTC,"Writing this all out, it feels like a dumb question. I've never met an Applicative that didn't have an order to its effects. Purity and the generality of the type signature for <*> kinda implies that a given instance must either pick left-to-right or right-to-left evaluation order and stick to it.   How about  newtype Op f a = Op { unOp :: f a } instance (Functor f) => Functor (Op f) where -- ... instance (Applicative f) => Applicative (Op f) where   pure = Op . pure   Op f <*> Op x = Op $ (flip ($)) <$> x <*> f newtype PProd f g a = PProd { unPProd (f a, g a) } instance (Functor f, Functor g) => Functor (PProd f g) where -- ... instance (Applicative f, Applicative g) => Applicative (PProd f g) where -- ...   and then things of type PProd IO (Op IO) a for some a?"
haskell,3809d8,Spewface,5,Sun May 31 22:04:22 2015 UTC,"So for the next step, how about a ltext-backed FUSE filesystem, where paths are rendered from templates.  So, for example cp apply foo bar ltext-fs/; cat ltext-fs/""apply foo bar"" would render the same result as ltext ""apply foo bar"". This means the templated files could be served directly to another program, rather than used to generate input files."
haskell,3809d8,rampion,2,Mon Jun 1 04:00:45 2015 UTC,Great idea!!! I'll make a github issue :)
haskell,3809d8,srenatus,3,Mon Jun 1 13:15:27 2015 UTC,"I'm very appealed by this project. A real-world example would probably help, though. Looking at examples/foo2, you get an idea of what might be possible, but it doesn't suggest whether this is something you'd like to have..."
haskell,3809d8,srenatus,3,Mon Jun 1 07:19:06 2015 UTC,"The website itself was made with ltext, but it only uses some simple substitutions. I'll try and make one where a theme itself is a higher-order template :)"
haskell,3809d8,gelisam,4,Mon Jun 1 13:12:09 2015 UTC,"oh, thanks for the pointer: src/ and build.sh indeed is real-life enough for me ;)"
haskell,3809d8,sacundim,1 point,Mon Jun 1 13:50:18 2015 UTC,:)
haskell,3809d8,sclv,3,Mon Jun 1 15:06:45 2015 UTC,"So reading the documentation, it seemed to me like there was no way to delimit a block of text in order to pass it as an argument. This prevents many of the common idioms of templating systems, in which the markers are used for if statements and for loops and introducing new variables into scope, not just substituting a piece of text for a marker. So instead of this:  {{ replicate3 }} The three most important factors when deciding to buy property are: {{ replicate3 }} * location {{ /replicate3 }}   I'd have to write two different files, one for the block:  [blank line] * location   and one for its parent:  {{ block replicate3 }} The three most important factors when deciding to buy property are: {{ replicate3 block }}   But then I realized: the documentation also says that I'm supposed to be able to partially apply those things! So what happens if I do? Will it reveal an undocumented syntax for delimiting blocks?  $ .cabal-sandbox/bin/ltext ""parent block"" --left '{{' --right '}}' ltext: Error: Result has literals in sub expression - `λreplicate3. (#parent) <> (replicate3 #block)` - cannot render soundly.   Oh well."
haskell,3809d8,Ancipital,2,Mon Jun 1 12:16:20 2015 UTC,"That's a subtle detail - In order to render a tempate, all text needs to be at the top level - otherwise, you would have a multi-line expression. I'll put more documentation on this later.  But you're right, the only way to pass text as an argument is through content in a file."
haskell,3809d8,Hrothen,2,Mon Jun 1 13:10:59 2015 UTC,"Okay, I've added a section! http://ltext.github.io/#debugging"
haskell,3809d8,Faucelme,3,Mon Jun 1 17:39:45 2015 UTC,"The project I've used that this one brings to mind is StringTemplate, which is a pure-functional template language but it's (a) untyped and (b) generally a mess and not high quality code.  (See the paper for philosophy.  Oh, and I'm not endorsing the paper.)  But it does have:   A concept of model objects that are richer than just text.   A template is a pure function from a model to text. Models are records with fields whose values may in turn be  records with fields.  Indentation support—a multi-line template that expands in an indented context in an enclosing template will inherit the enclosing template's indentation. Sequence processing: apply a template to all of the values of a list, with separators between expansions or terminators at the end.   The other problem I've encountered in the past that no generic template engine really tackles to my satisfaction is defense against injection attacks (e.g., Javascript injection into HTML templates).  In many contexts to insert text succesfully into a context you need to escape that text... but the correct way to escape the text may be sensitive to the syntactic context it appears in inside of the output document, which the template engine doesn't have any concept of.  (See the XSS Prevention Cheat Sheet for an example of the complexities of this.)  The template engines that can cope with that aren't generic—they're tied to some specific output document format like HTML.  The root problem here of course is that template engines are fundamentaly a tool for stringly-typed programming."
haskell,3809d8,onmach,3,Mon Jun 1 23:12:36 2015 UTC,"The HStringTemplate library in Haskell (http://hackage.haskell.org/package/HStringTemplate) provides all the good stuff you list, and is relatively more compact, not to mention efficient. It is of course still stringly typed, by design.  Additionally, it allows you to define per-subtemplate custom escaping functions, which are not the worst way to prevent XSS."
haskell,3809d8,Unknownloner,2,Tue Jun 2 18:58:19 2015 UTC,"I think you're right - this is an issue of text files being generally untyped. I don't think that security is the right place for this project, though - it would require too many domains of interest to be embedded in the project. I think that ltext is just a phase for processing, much like how a lexer is a phase during compilation. I will look into StringTemplate, though, maybe I can grab some ideas :) Thank you!!"
haskell,380kmq,ggchappell,9,Sun May 31 23:32:57 2015 UTC,I think this wiki page maybe helpful  Iteratee I/O
haskell,380kmq,n00bomb,4,Mon Jun 1 01:25:13 2015 UTC,I favorited this question specifically because the top answer gives such an excellent explanation of what's wrong with lazy IO.
haskell,380kmq,dmwit,4,Mon Jun 1 06:12:12 2015 UTC,"I got bit by lazy IO tons of times.  Whenever I try to do something like read a file, modify it in memory, write it back, oops!  Or maybe you think you should use withFile, nope! You mustn't!  Or maybe you try to send some IO to a different thread so you can put a timeout on it, nope! The IO is instantaneous and never times out, only you get the hang (or error) in the pure code that uses it.  Or maybe you parse a json file from byte strings, and then forget about it. Oops! Each parse stops at the end of the valid json and doesn't reach the end of the file. The byte string stays reachable, possibly because it was sliced into the json strings, and the file is leaked!  Virtually every time I use lazy IO (intentionally or as unfortunately too easy by accident) I get cryptic/annoying bugs.  Get rid of it from the standard library, please!"
haskell,380kmq,Peaker,3,Mon Jun 1 17:48:36 2015 UTC,"Get a Handle to a file with more data than you have memory to contain.  Read it into a lazy ByteString  Profile it doing something silly like summing the bytes, such that it should hypothetically only need the current byte/word/etc. and the summation so far. [1]  [1] NB. This is completely off the top of my head, but it's the sort of situation where I'd reach for pipes-bytestring just to avoid any possible grief. That doesn't mean I've established it's necessarily ""bad"".  IME, there's a lot of superstition around this topic. In some respects, that's a good thing (bear with me) because it means we're propagating folklore around how to avoid broken programs effectively. OTOH, it means people are being deprived of the opportunity to learn these lessons for themselves.  We should show people what doesn't work before we show them the fix."
haskell,380kmq,Mob_Of_One,7,Mon Jun 1 00:01:32 2015 UTC,"This is not the problem with lazy IO. I tested with the following program:  import System.IO import Data.ByteString.Lazy as L  main = do     h <- openFile ""/dev/zero"" ReadMode     bs <- L.hGetContents h     print (L.foldl' (+) 0 bs)   It pegged a CPU, but memory usage was completely flat for the five minutes I ran it.  The real problem is with compositionality: chunks of code that look nicely reusable, but have lazy IO inside, can't be combined in some of the very natural ways one might want to combine them."
haskell,380kmq,dmwit,3,Mon Jun 1 06:17:46 2015 UTC,"wait, why aren't they composable? Are you talking strictly about performance? I've also wondered about this question and can never seem to get to the core of the issue with Lazy I/O"
haskell,380kmq,rtpg,4,Mon Jun 1 07:54:32 2015 UTC,"Lazy I/O has roughly the same problems as lazy lists in general: resource management. The most often cited example is  average xs = sum xs / length xs   This does not work for large lazy lists because the entire list is forced by sum, and it can't be garbage collected because length still needs it. It is of course possible to compute the average of a list correctly:  average xs = let (s,n) = fold (\a (s,n) -> (s+a, n+1)) (0,0) xs in s/n   This computes the sum and length in one traversal of the list. If you have a giant file and load it into a lazy list you can have this problem easily. In addition to keeping the entire file in memory you may inadvertently leak file handles.  As with so many problems in functional programming the correct solution is linear types ;-) In the meantime there are various libraries that help compose incremental processing pipelines, such as the pipes and foldl libraries."
haskell,380kmq,julesjacobs,2,Mon Jun 1 12:25:06 2015 UTC,functional programming the correct solution is linear types   Sometimes I kinda wish Haskell had an extension for that…
haskell,380kmq,Fylwind,2,Mon Jun 1 23:45:12 2015 UTC,How would substructural types help here? Other than making it possible to rule out a definition such as average -- that doesn't give you an alternative solution though.
haskell,380kmq,edsko,2,Tue Jun 2 14:33:43 2015 UTC,"You are right, ruling out bad code like that is exactly what linear types do. They do allow more efficient implementation in some cases. If you have a data structure that is used linearly then updates can use mutation under the hood. If you don't have linear types then updates have to be implemented with expensive path copying even if the data structure happens to be used linearly. In most cases data structures are used linearly. This is the main reason imperative languages have a performance advantage."
haskell,380kmq,julesjacobs,3,Tue Jun 2 20:13:53 2015 UTC,"Yes, I know what linear types do :) I'm just saying, they don't really offer a solution here. You'd still end up writing average in a convoluted way."
haskell,380kmq,edsko,3,Tue Jun 2 20:18:50 2015 UTC,They offer a solution to accidental memory leaks. They don't offer a magic wand to turn leaking average into non leaking average :)
haskell,380kmq,julesjacobs,4,Tue Jun 2 20:24:34 2015 UTC,"The example that I linked elsewhere in this thread goes like this: let's take readFile and writeFile, which are very nice high-level primitives, and try to imagine composing them with a showProgress function that prints a little status output every million bytes or so. How do you do it?  Well, the answer is, you can't. You have to rewrite writeFile to do it internally; or else you have to switch from using writeFile to using something like mapM_ (appendFile `andThen` printStatus) . chunksOf 10000000 or something like that. So these two pieces of code that look perfectly reusable suddenly can't be reused -- you have to implement a new chunk of code that does substantially the same thing, but with a few minor tweaks. Nasty!  There are definitely different approaches that do allow you to write readFile and writeFile in a way that lets you stick a progress bar in the middle; so in the compositionality sense at the very least those are preferable."
haskell,380kmq,dmwit,5,Mon Jun 1 15:51:03 2015 UTC,"This isn't entirely accurate:  import System.IO import System.IO.Unsafe  showProgress :: String -> IO String showProgress []    = return [] showProgress input = unsafeInterleaveIO $ do      let (block, tail) = splitAt 1024 input     blocks <- showProgress tail     putChar '.'     return (block ++ blocks)  main :: IO () main = do     hSetBuffering stdout NoBuffering     writeFile ""b.txt"" =<< showProgress =<< readFile ""a.txt""   Not saying you should do it this way, but you can :)"
haskell,380kmq,edsko,7,Tue Jun 2 14:28:44 2015 UTC,"Get a Handle to a file with more data than you have memory to contain.  Read it into a lazy ByteString  Profile it doing something silly like summing the bytes, such that it should hypothetically only need the current byte/word/etc. and the summation so far. [1]   Actually this is a situation where lazy IO works perfectly well (I believe it was designed to handle this situation...).   For example I just wrote a sha256 checksum script last week with lazy IO and lazy ByteString exactly this way, and it works perfectly well for files larger than than the memory (and the running time was the same as the cygwin sha256sum executable)."
haskell,380kmq,fridofrido,6,Mon Jun 1 08:53:29 2015 UTC,"We should show people what doesn't work before we show them the fix.   Libraries like pipes/conduits/iteratees are not ""fixes to lazy I/O"".  They are libraries for handling streaming I/O.  The fact that there's some other technique to do similar things, that doesn't work so great in some situations, is just a side note.  The fact that all of these libraries have been compared to lazy I/O in the past is a historical artifact, and in no way implies that lazy I/O is somehow rightly considered the basis on why they build.  In fact, some would say it's a mistake that should be forgotten.  I also don't think lazy I/O is always broken.  Any time we do pure functional programming, we are drawing an arbitrary line between things that are part of the implementation detail, and things that are part of the semantics.  Sometimes, whether a file handle is open or closed, and its current file position and the timing of its reads versus other I/O actions, is important enough to model in the semantics.  Sometimes, we can leave that as an implementation detail.  In the latter case, lazy I/O is exactly the abstraction you might wish for."
haskell,380kmq,cdsmith,3,Mon Jun 1 02:34:03 2015 UTC,"Libraries like pipes/conduits/iteratees are not ""fixes to lazy I/O"".   I agree. That's why my example was specifically about something involving a dataset larger than available memory, a mode of consumption conducive to piecewise work, and the accumulated data is tiny compared to the original data. I was trying to make a strawman example of, ""streaming is better than lazy IO"".  This was, exists a . a is better in terms of streaming IO than lazy IO  This was not, forall a . a is better in terms of streaming IO than lazy IO   The fact that all of these libraries have been compared to lazy I/O in the past is a historical artifact   Yeah, but I think this is also partly because people more often want streaming IO rather than lazy IO. Many problems I've tackled and seen others tackle lend themselves better to the former operationally than the latter. That doesn't mean Lazy IO couldn't work, but it does seem like making it work seems to be harder than re-expressing what you're doing in terms of a streaming abstraction (when that is possible to begin with) to get the operational behavior you want.   I also don't think lazy I/O is always broken.   Good, I don't either! In fact, I think I said:   IME, there's a lot of superstition around this topic   OP didn't give me a lot to go on, so I tried to take a little time to give people something real to talk about and kick around. Perhaps you could come up with an example that demonstrates the opposite so OP (and others) can learn something?"
haskell,384it9,elcric_circle,4,Mon Jun 1 20:16:17 2015 UTC,"This article doesn't cover binary search trees, but binary trees. The code seems to be copied from a section of the Haskell Wikibook, although only the last variant of each function is used. The explanation is completely missing, apart from some very basic comments.  All in all, I wouldn't call that an informative article; to be honest I wouldn't even call it an article."
haskell,384it9,qZeta,3,Tue Jun 2 13:24:38 2015 UTC,"In a BST (as far as I know) each node contains a key, and the tree mantains always some kind of ordenation. This tree doesn't. Also, in this implementation a node with only one child is impossible.   Although I'm interested in the extension of fold to tree-like structures."
haskell,384it9,Wynro,1 point,Mon Jun 1 22:59:38 2015 UTC,Correct. He's described a general binary tree.  Compare chapters 9.1 & 9.3 of Introduction to Functional Programming Systems Using Haskell (which he references).
haskell,383obg,patolin_01,11,Mon Jun 1 16:59:13 2015 UTC,"I have used it, but just asking your question will probably give you a better answer than asking if somebody might be able to answer a question you have not even told us."
haskell,383obg,cocreature,1 point,Mon Jun 1 17:10:03 2015 UTC,"Im having a trouble with duplicate instance declarations for the Pretty class. There are 2 declarations in 2 different files (some files from another library im using, and its used by some portion of my code). Is there a way to override just one?"
haskell,383obg,bartavelle,3,Mon Jun 1 17:16:10 2015 UTC,The standard answer is to use newtypes and write a different instance for them.
haskell,37y1yi,beerdude26,17,Sun May 31 10:34:25 2015 UTC,Thank you for doing this!
haskell,37y1yi,Tekmo,13,Sun May 31 14:05:46 2015 UTC,"Great post! I completely agree! That's how we should be treating the wiki -- as a living place that can be edited and curated to reflect all the ideas described and articles published, not just as a repository for long-form single-author content."
haskell,37y1yi,sclv,9,Sun May 31 15:44:54 2015 UTC,Then we should perhaps make creating a HW account easier.
haskell,37y1yi,roche,5,Sun May 31 17:05:17 2015 UTC,"There's a plan underway to let you email a group rather than a single individual for an account request. That should help some. But every time we've opened up registrations, we've gotten drowned in a wave of spambots. Maybe new captcha tech will keep them at bay this time,  but it hasn't in the past."
haskell,37y1yi,sclv,4,Sun May 31 17:55:36 2015 UTC,"I know. But other wikis solve this somehow, right?  What about a Haskell captcha? E.g. ""enter the result of filter even [1..5]"""
haskell,37y1yi,roche,4,Sun May 31 19:29:30 2015 UTC,"Yeah, because computers are horrible at correctly evaluating syntactically and semantically valid code written in a well-defined programming language.  EDIT: A halting problem based Captcha system could be interesting.  I know that there are some cases where humans are just as hopeless as computers, but it's pretty easy to construct a situation which would require some kind of sophisticated proof engine to prove that an expression would or would not terminate, but which would be easy for a human to see.  Something like ""Does any even [1,3..] terminate?""  If you wanted to prevent a timeout based approximate solution, you could throw in some expressions which DO terminate, but only after a very long time: any (== 2^4000) [0..2^4000]"
haskell,37y1yi,SelectricSimian,10,Sun May 31 23:23:58 2015 UTC,"Computers are good at that, but spam bot writers probably are not going to spend time customizing bypasses for every site that invents their own custom captcha system."
haskell,37y1yi,irishsultan,2,Sun May 31 23:28:44 2015 UTC,"That's really overthinking the problem.  Also, it's going to also discourage Haskell newcomers from contributing."
haskell,37y1yi,Fylwind,10,Mon Jun 1 23:43:21 2015 UTC,"Wikis stagnate because nobody really knows who the maintainer is. Then they don't know if it is ok to edit or delete text and are only comfortable with adding new text, which bloats and confuses the content. Wikipedia does well in this regard because there are maintainers of pages.  The fundamental problem with the wiki model is that edits are performed instead of being proposed. This is why I favor just using a github repo as a wiki: pull requests propose changes. This makes people comfortable with editing and facilitates easy maintenance. The downside of this approach is only a lack of page-level notifications.  I guess what I am saying is that the best way to improve the wiki would be to switch to a wiki that facilitates proposing changes instead of just making them."
haskell,37y1yi,eegreg,5,Mon Jun 1 02:50:33 2015 UTC,"Sadly editing the wiki does not stroke one's ego. Editing wikis is a selfless act, good on you for doing so."
haskell,37y1yi,dukerutledge,15,Sun May 31 16:06:03 2015 UTC,Just advertise what you are doing on reddit. Problem solved ! :)
haskell,37y1yi,bartavelle,2,Sun May 31 17:48:40 2015 UTC,How does Wikipedia make it so compelling to contribute?
haskell,37y1yi,rdfox,9,Sun May 31 17:29:02 2015 UTC,By being one of the most highly trafficked websites on the Internet.
haskell,37y1yi,drb226,3,Sun May 31 20:22:46 2015 UTC,You're not the first to ask.
haskell,37zo5h,allonsy48,19,Sun May 31 19:30:54 2015 UTC,"I really dislike articles like this (the journalism not the paper being referenced).  Quantum mechanics is not lazy (or even particularly weird). Saying that the atom behaves sometimes like a wave and sometimes like a particle is silly and misleading. It always behaves exact how a wavefunction should because that is the most useful description. It's like saying sometimes it behaves like a duck and sometimes more like a potato. You may be right but only because ducks, potatos, particles and waves all suck as descriptions of what is going on.  Saying stuff like ""reality doesn't exist"" requires (re)defining reality as something that doesn't exist.  /rant"
haskell,37zo5h,Thomas_Henry_Rowaway,13,Sun May 31 22:31:48 2015 UTC,"With quantum-related journalism, the question is not 'is it wrong?', but instead 'in what way is it wrong?'."
haskell,37zo5h,tailcalled,10,Sun May 31 23:21:56 2015 UTC,"As a firm believer in the Clickbait Interpretation of Quantum Mechanics, I'd say the most important philosophical questions are actually related to the Revenue function (which is really just sugar on top of PlanckClicks and PlanckDollars)."
haskell,37zo5h,dnkndnts,1 point,Mon Jun 1 06:42:58 2015 UTC,STAHP! My poor ribs X'D
haskell,37zo5h,Enamex,5,Mon Jun 1 23:37:57 2015 UTC,"I had it described to me as,   Imagine a test that is set up such that if a person manages to run a 5k race below a certain time, we say, ""You must be a runner."" Then a similar test classifies people as swimmers if they swim 1000 yards faster than a certain time. These tests work well until you test a triathlete. Suddenly she is sometimes a runner and sometimes a swimmer, depending on which test you use to look at her.  If you had no prior experience with triathletes and the human nature of sports performance, you might be really confused at this."
haskell,37zo5h,kqr,2,Mon Jun 1 06:11:17 2015 UTC,"From my understanding of quantum physics, observation is basically synonymous with interaction, so this is like a really bad way to say that reality consists of all the things that interact with each other, which is unprovable (trivially, you can't observe things that don't interact with other things, so you can't prove they do or don't exist, not that it actually matters since for all purposes a thing that doesn't interact with anything might as well not exist)."
haskell,37zo5h,Hrothen,18,Mon Jun 1 01:46:24 2015 UTC,Some unobserved part of the universe is setting us up for a massive space leak.  OMGZ Maybe dark matter is unevaluated thunks!!?!!?!!1one
haskell,37zo5h,tomejaguar,3,Sun May 31 21:18:22 2015 UTC,"Maybe dark matter is bottoms  And what about black holes...you know, they disappear over time"
haskell,37zo5h,dramforever,1 point,Mon Jun 1 05:39:31 2015 UTC,You're both wrong. Dark matter is simply code that has been commented out but still shows up in the line count.
haskell,37zo5h,T_S_,5,Sat Jun 20 04:15:00 2015 UTC,Whether or not you observe a quantum phenomenon has noticeable side effects on its outcome.  The universe is not referentially transparent.
haskell,37zo5h,SelectricSimian,3,Sun May 31 22:17:35 2015 UTC,"Darn it, I had the same thought on the issue this morning.  If anything, it's a point in favour of the 'computational universe' idea. ... now if only it would help settle the eternal tug-of-war between ""the universe runs on Lisp"" and ""Haskell is theoretically cleaner"" that's been raging in my mind."
haskell,37zo5h,blind-raven,2,Sun May 31 20:27:17 2015 UTC,Obligatory XKCD
haskell,37zo5h,Tekmo,2,Sun May 31 21:46:32 2015 UTC,"Image  Title: Lisp  Title-text: We lost the documentation on quantum mechanics.  You'll have to decode the regexes yourself.  Comic Explanation  Stats: This comic has been referenced 62 times, representing 0.0944% of referenced xkcds.    xkcd.com | xkcd sub | Problems/Bugs? | Statistics | Stop Replying | Delete"
haskell,37zo5h,xkcd_transcriber,1 point,Sun May 31 21:46:39 2015 UTC,Point against really.
haskell,37zo5h,cass1o,1 point,Sun May 31 23:26:08 2015 UTC,http://www.reddit.com/r/programmerhumor
haskell,37zo5h,Agitates,1 point,Sun May 31 20:19:07 2015 UTC,Corollary: atoms only do the wave if you show them on the jumbotron
haskell,37zo5h,mcbears,0,Sun May 31 20:59:48 2015 UTC,"Yeah, we are just a simulation inside some machine, written in a lazy language."
haskell,37zo5h,tailbalance,2,Sun May 31 21:22:44 2015 UTC,sounds like a pretty strong affirmation for Haskell's choice of lazy evaluation!
haskell,37zo5h,RoboNickBot,2,Sun May 31 22:19:02 2015 UTC,"Actually, it would be the opposite: if the universe is already lazy then Haskell's laziness would be redundant."
haskell,37wsxc,khanzor,11,Sun May 31 01:32:27 2015 UTC,"One of the best parts of the clojure ecosystem is that you can just download lein and get a web site running with one command. I might be missing something, but the process to create a new cabal build is a little intensive, especially if you want to follow best practices.  Hein current accepts a single command ""new"" and the name of a project to create. You can then pass in names like ""+scotty"" and scotty will be added as a dependency to your cabal file.  The code is terrible, as I really don't know haskell all that well, so any feedback would be appreciated.  Also, if anyone knows of plugin libraries that work with ghc 7.8/7.10 I'd be grateful for some links or examples :)"
haskell,37wsxc,snoyberg,6,Sun May 31 01:35:34 2015 UTC,"I'm excited to see others working to improve the state of Haskell tooling. As /u/Mob_Of_One mentioned, there is other work going on here too, which I'm a part of. From looking at your README, I don't think there's overlap in functionality in any significant way between your project and other projects I'm aware of (see: https://github.com/commercialhaskell/commercialhaskell/blob/master/taskforce/tooling.md). Please be in touch if you'd like to collaborate on things more directly, having more people working on this is in everyone's best interest."
haskell,37wsxc,Mob_Of_One,2,Sun May 31 04:16:51 2015 UTC,"Not to take the wind out of your sails, but there's a tool which bears a lot of similarity to what made Leiningen nice that is in progress. I say this as somebody that used Clojure before Haskell and liked Leiningen a fair bit. Has a lot of well-known Haskell people behind it, I'd strongly encourage you to join forces. It should head towards a release soon.  Ping me if you'd like to know more.  There are some ideas here that don't exist in other projects yet and I bet they could use an advocate and willing implementer. Thanks for sharing Hein! :)"
haskell,37wsxc,beerdude26,9,Sun May 31 02:28:52 2015 UTC,"Sure, I built this because I was sick of doing the dance with cabal setting up projects. If people who know what they're doing are doing something about it then I have no problem deprecating this in favour of a real solution :)"
haskell,37wsxc,radix,6,Sun May 31 03:34:58 2015 UTC,You could also rewrite it as a stackage-cli plugin: https://www.fpcomplete.com/blog/2015/04/announcing-stackage-cli
haskell,37wsxc,Mob_Of_One,18,Sun May 31 09:55:00 2015 UTC,I'm flabbergasted about the secrecy here. Why not just come out and say what the project is and who's working on it? Why does it have to be a secret?
haskell,37wsxc,radix,6,Sun May 31 03:51:59 2015 UTC,"Because it's not my project and I don't know if they want to go public yet, but I'm quite sure they'd be happy to take on a contributor.  I also dislike PM'ing people I don't have prior contact with out of the blue without consent."
haskell,37wsxc,roche,7,Sun May 31 04:10:32 2015 UTC,"Okay, sorry I got onto your case. I think given that it's been mentioned in public it's fair game to just link to the related conversations and pages (like /u/snoyberg did).  I don't want to sound prescriptive or bossy, just offer observations and suggestions, so I will have to word this carefully: I think there are things happening in the Haskell community that can and have been perceived as kind of ""cabalish"", if you'll excuse the pun. It came up with the packaging/security thread, for example. And I think every time people were accused of being too closed in their development/discussion it's really come out as not such a big deal, but I think a little bit of proactive openness can readily dispel this problem.  One thing that's not perfectly clear from the page at https://github.com/commercialhaskell/commercialhaskell/blob/master/taskforce/tooling.md is where discussion about these topics should take place (I guess from its location it should be the commercialhaskell mailing list?) and also perhaps that people who are not members of the task force, and also not necessarily involved in commercial Haskell usage, are welcome to contribute to the discussion.  Anyway, I've subscribed to the commercialhaskell mailing list! This is something that's really interesting to me."
haskell,37wsxc,snoyberg,8,Sun May 31 05:38:39 2015 UTC,"I think there are things happening in the Haskell community that can and have been perceived as kind of ""cabalish"", if you'll excuse the pun. It came up with the packaging/security thread, for example. And I think every time people were accused of being too closed in their development/discussion it's really come out as not such a big deal, but I think a little bit of proactive openness can readily dispel this problem.   It's been a few times in the past when Michael came out with unconventional ideas (the security thread being a recent one), and a lot of the response has been explanations why he shouldn't do that. This arguing takes a lot of energy and kills enthusiasm."
haskell,37wsxc,radix,4,Sun May 31 08:23:13 2015 UTC,"There's no secrecy involved, just no public announcement of anything being available (because there isn't anything ready yet). However, there have been multiple public calls for people to get involved in the project, e.g.:   https://groups.google.com/d/msg/commercialhaskell/sbMs7WQ9iDc/EYzk6gWHDk4J https://groups.google.com/d/msg/commercialhaskell/bLbrLp2I11E/9xunXdm56DEJ (which references https://github.com/commercialhaskell/commercialhaskell/blob/master/taskforce/tooling.md)   The project is developed by the Commercial Haskell group. Anyone interested in collaborating is still more than welcome to join in the discussion now."
haskell,37wsxc,snoyberg,2,Sun May 31 04:11:59 2015 UTC,"Thanks for those links.  Is it fair to assume that basically Stackage is basically this tool? So maybe OP's project could become a stackage new plugin, if they were to buy in to the Stackage brand?  edit: and it would make a lot of sense for stackage new to set up the new project to use Stackage packages (either LTS or Nightly, depending on options passed?)."
haskell,37wsxc,drb226,2,Sun May 31 05:16:05 2015 UTC,"The stackage-cli work is definitely the basis for what we've been talking about, but the discussions I've been having with others is what the next evolution of that tooling should look like to have the biggest positive impact on everyone's workflow.  But broadly speaking, yes, it looks like OP's project would fit in like some kind of stackage new plugin."
haskell,37vna8,BoteboTsebo,8,Sat May 30 19:52:24 2015 UTC,Keep at it. As a dilettante computational linguist I'm always happy to see linguists getting involved in Haskell.
haskell,37vna8,timmy_tofu,1 point,Sat May 30 22:32:30 2015 UTC,"dilettante   Learned a new word today! :-D  Yeah, some of the blog posts I've been thinking about... That blog is going to become a bit more bizarre very soon. :-/  Thanks, bud. :-D"
haskell,37vna8,peargreen,10,Sun May 31 09:47:30 2015 UTC,"I like your style a lot. Also I like nitpicking so here are some nitpicks!     $(deriveJSON id ''RecordDeal)   1st, you can write just deriveJSON id ''RecordDeal when using top-level splices (this is more-or-less personal preference, tho).  2nd, you can't write deriveJSON id ''RecordDeal because your Aeson is o-old and nowadays it's deriveJSON defaultOptions ''RecordDeal. And $(deriveJSON (drop 11) ''RecordDeal) should be deriveJSON defaultOptions{fieldLabelModifier = drop 11} ''RecordDeal.  (I guess it's just a copypasting error, 'cause later you're using defaultOptions.)     it’s perfect for when we just want to use records sanely   I'd say that lens is more perfect for sane records (because it doesn't require [| |] everywhere) – see makeFields. If you don't like that lens is so huge (I don't too), there are alternatives on Hackage which have TH but are smaller (including my microlens-th which is just some lens's code ripped out into a separate package).     tsmsToUTCTime (TimestampMS ms) = timestampParse_ ms   If you had written the newtype as newtype TimestampMS = TimestampMS {getMS :: Integer}, you could've written it your function as tsmsToUTCTime = timestampParse_ . getMS, which seems nicer. And your qdToDecimal could've been entirely avoided with newtype QuotedDecimal = QuotedDecimal {qdToDecimal :: Decimal}. Just in case you didn't know the trick (again, it's a bit of a personal preference, I guess).     fromRational . toRational   That's just realToFrac. (I think hlint would've caught this.)     AesTH.deriveFromJSON   Why not just import all Aeson modules under the common Aeson umbrella? (Yeah, yeah, again preferences, whatever.)     aesToRec (Ticker_ ticker''timestamp ticker''bid ticker''ask ticker''lastTrade ticker''rolling24HourVolume ticker''pair)   That's where the RecordWildCards extension comes handy (it lets you replace that line with Ticker_{..}.     Txt.encodeUtf8 $ (view [lens| id |] auth)   (Don't need parens here. Or $.)     IO (Either SomeException (Response BL.ByteString))   If you end up writing any type signature with SomeException more than once, maybe consider tryAny instead.     bitXErrorOrPayload :: BitXAesRecordConvert rec aes => Response BL.ByteString -> IO (BitXAPIResponse rec) bitXErrorOrPayload resp = do   let respTE = Aeson.decode body -- is it a BitX error?   case respTE of       Just e  -> return . ErrorResponse . aesToRec $ e       Nothing -> do           let respTT = Aeson.decode body           case respTT of               Just t  -> return . ValidResponse . aesToRec $ t               Nothing -> return . UnparseableResponse $ resp   where       body = NetCon.responseBody resp    (There was huge indentation, but I removed it in the quote. By the way, in kinda-narrow-column blogs huge indentation level is an obstacle.)  This function doesn't seem to use IO. Why not rewrite it like this:  bitXErrorOrPayload   :: BitXAesRecordConvert rec aes    => Response BL.ByteString -> BitXAPIResponse rec bitXErrorOrPayload resp = case respTE of     Just e  -> ErrorResponse (aesToRec e)     Nothing -> case respTT of       Just t  -> ValidResponse (aesToRec t)       Nothing -> UnparseableResponse resp   where     body = NetCon.responseBody resp     respTE = Aeson.decode body :: ...     respTT = Aeson.decode body :: ...   Or maybe even like this:  bitXErrorOrPayload   :: BitXAesRecordConvert rec aes    => Response BL.ByteString -> BitXAPIResponse rec bitXErrorOrPayload resp = fromJust $ asum [     ErrorResponse . aesToRec <$> respTE,     ValidResponse . aesToRec <$> respTT,     Just (UnparseableResponse resp) ]   where     ...   (Or use 2×<|> instead of asum if you want to make it clear that you're choosing between alternatives.)     bitXAPIRoot ++ verb   When working with URLs, I usually like using </> – it conveys the intent better and also protects from forgotten trailing slashes."
haskell,37vna8,Tekmo,3,Sat May 30 22:14:17 2015 UTC,"Thanks, Bud. I need all the nitpicking I can get!!  I'm replying from a phone at the moment, and so can't see some of the code blocks clearly.    Yep, that Aeson TH was a typo. I wasn't intending for any of the code to be runnable. Maybe I should have pointed that out at the beginning.    Related to that, I wasn’t even aware that the Aeson TH magic is re-exported by the top level Aeson package! Almost none of the Aeson tutorials I looked at mentioned this splice function.    I prefer to use splices with $. The ugly syntax reminds me that I'm doing something strange. :-)  I'll go over microlens now. Yeah, I still can't wrap my head around why Lens is so big. The sandbox for this package alone is already at 119 MB,  and takes a while to build (especially due to all of the magic in nikita-volkov's record library). It doesn't feel ""right"" to produce so much code and pull in even more libraries just to bootstrap a few hundred lines of very simple Haskell.  Once again, I will look at your newtypes better when I'm not using a phone. This was one of the major problems I had to solve and I'm excited to here that there is a more elegant way of doing it! I can't get hlint to stop complaining about stupid shit like splice syntax ""errors"" while ignoring actual issues. It used to work great in Haskell-Vim-Now, but now that I'm using Leksah it seems to miss a lot. Basically, I don't know how to use hlint from the command line, especially since it gets distracted by splices and multiparameter type classes.    What's a single command to run hlint and have it take into consideration extensions which introduce new syntax?.    I'm still not sure about what the hell RecordWildcards does. It sounds magical (uses hidden info). I will go back to that code and see how to use the extension. I overlooked the fact that the ""inner"" functions could be pure. Thanks for that wonderful rewrite -- IT'S GOING IN THE NEXT PATCH!! It really makes things much clearer. Where do I find </>?    And thanks so much for the feedback, it's very encouraging. :-D  I should have probably used something like BlogLiterately to create the post, as I very quickly learned that source code and WordPress don't go well together..."
haskell,37vna8,peargreen,2,Sat May 30 22:54:19 2015 UTC,"Also, while it wouldn't help your specific use case, you can derive FromJSON and ToJSON instances using GHC generics:  {-# LANGUAGE DeriveGeneric #-}  import GHC.Generics  data Coord = Coord { x :: Double, y :: Double } deriving Generic  instance FromJSON Coord instance ToJSON Coord   It's buried in the documentation of Data.Aeson, but it's there."
haskell,37vna8,peargreen,2,Sun May 31 14:02:59 2015 UTC,"Hi, Tekmo.  I do that quite a bit in the main types module.  I was not aware that I could also use it with records while taking care of field name clashes, but peargreen made me aware that it is certainly also possible is super awesome."
haskell,37vna8,peargreen,2,Mon Jun 1 18:10:47 2015 UTC,"Maybe I should have pointed that out at the beginning.    Yep!     The ugly syntax reminds me that I'm doing something strange.   Okay, that's legit.     Almost none of the Aeson tutorials I looked at mentioned this splice function.    checks whether nir tutorial mentions it  Aha, it does, good.     the Aeson TH magic is re-exported by the top level Aeson package!   It's all in the aeson package, yep (but not exported by Data.Aeson, you need Data.Aeson.TH for that).     I'll go over microlens now.   It's good if you just need basic lens stuff or compatibility with all the lens tutorials out there (and it'll be better once I finish writing the docs and tutorial for it), but don't take it as something “recommended” yet, it's very much not. Just an option if you need a tiny lens package here and now (like I did).     I'm still not sure about what the hell RecordWildcards does.   2 things:   When used as a pattern (f X{..}), it brings all fields into scope as actual values (instead of accessor functions). When used as a value (return X{..}), it assembles a record from fields that are in scope (this proves to be useful when writing Aeson parsers, among other things).      Where do I find </>   Use the Hoogle, Luke. (It's in the filepath package, which is pretty standard so there's no harm in using it.)     And am thanks so much for the feedback, it's very encouraging.   (If you're going to write more Haskell posts, I'm totally willing to serve as a beta-reader – just PM me.)"
haskell,37vna8,tomejaguar,2,Sat May 30 23:11:26 2015 UTC,"Or maybe even like this:   Hmm... There pops up that magical applicative syntax again.  What's going on here? Are you (and the Aeson tutorials) treating the Maybe monad as an applicative? This seems like a simple idiom to get used to (""if you need to try alternatives with failure, then do it like this""), but I'm very uncomfortable not understanding just how/why the hell it works..."
haskell,37vna8,peargreen,2,Sun May 31 09:53:26 2015 UTC,"<$> treats Maybe as a Functor, not an Applicative. It's a very common idiom for delaying error handling – you do operations on Maybe (or Either) and check whether the original Maybe was Nothing only when you actually need it.  f <$> Nothing = Nothing f <$> (Just x) = Just (f x)   In that example I also exploited the fact that Maybe is an Alternative. In most parsing libraries asum is called choice, which is a much better name for it; when given a list of Maybes, asum chooses the 1st non-empty one – or returns Nothing if all of them are empty."
haskell,37vna8,AndrasKovacs,2,Sun May 31 10:38:43 2015 UTC,"This clarifies things greatly. Thanks.  I was not aware that Maybe could be treated as a Functor like this, outside of GHC 7.10. Or maybe I'm just confusing Functors and Applicatives (the topic of GHC 7.10's AMP)."
haskell,37vna8,AndrasKovacs,3,Sun May 31 10:48:49 2015 UTC,"Or maybe I'm just confusing Functors and Applicatives (the topic of GHC 7.10's AMP).   The topic of AMP was the fact that Monad wasn't guaranteed to be either Functor or Applicative, which meant that when you wanted to use <$> or other functions which require Functor or Applicative, you had to add an extra Functor/Applicative constraint, even tho morally all monads are functors and applicatives already. Also, some functions were less general than they could be, because they had Monad constraints while in reality Applicative was sufficient.  Maybe is a functor, applicative, alternative, monad, traversable, foldable, and some other things (you can see the full list in the docs for Maybe). It doesn't depend on AMP."
haskell,37vna8,rehno-lindeque,1 point,Sun May 31 11:11:00 2015 UTC,"Brilliant! This makes me appreciate the AMP even more, and goes a long way to helping me understand Parsec magic!"
haskell,37vna8,rehno-lindeque,2,Sun May 31 11:46:38 2015 UTC,"1st, you can write just deriveJSON id ''RecordDeal when using top-level splices (this is more-or-less personal preference, tho).   As a tangential derail, why is this allowed?  Seems like a gratuitous inconsistency."
haskell,37vna8,begriffs,3,Sun May 31 10:01:54 2015 UTC,"As per GHC docs,   This abbreviation makes top-level declaration slices quieter and less intimidating.   I agree that it's inconsistent, but I also don't mind it (and I like the fact that I'm allowed to not wrap top level splices in parens – they're sometimes longer than one line, and anything longer than one line becomes ugly when wrapped in parens).  And it's not even that inconsistent if you view deriveJSON ''RecordDeal as just another form of declaration, similar to deriving instance ...."
haskell,37vna8,NihilistDandy,2,Sun May 31 10:32:13 2015 UTC,"Because TemplateHaskell in general has rather weird syntax. https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/template-haskell.html  It annoyed me to no end when I discovered that when writing a QQ you can't put spaces before or after the QQ's name.  [stuff| |]   is valid, but not  [stuff | |]   Apparently this particular rule is to prevent confusion between QQ and list comprehensions? Well, I say, why didn't they choose slightly better syntax, rather?"
haskell,37vna8,sideEffffECt,3,Sun May 31 10:36:17 2015 UTC,"Small tip about newtype wrappers for Aeson (which I found useful in my own endeavors but may not be as relevant for you): if you have parametrized/nested types with newtype wrappers inserted in some places, you can freely convert the whole thing with coerce from Data.Coerce. For example: coerce :: [(Int, [Sum])] -> [(Sum, [Product])], where Sum and Product are the Data.Monoid wrappers."
haskell,37vna8,sideEffffECt,2,Sun May 31 10:26:03 2015 UTC,"I have no idea what any of that means. :-)  Are you saying I can automatically ""cast"" types without remorse? Can I please see a minimal example?"
haskell,37vna8,Blackheart,3,Sun May 31 10:44:47 2015 UTC,"Yep, you can go wild casting newtypes; here's an extended example. You can check out the paper for in-depth details."
haskell,37vna8,Blackheart,3,Sun May 31 11:01:34 2015 UTC,"Hey, fancy seeing you here Tebello. (You should demo this at Lambda Lum!)   I needed some way of dealing with financial numbers without using potentially-error-prone floating point, and eventually settled on the Decimal package   Could you use Scientific instead? It's already included as a dependency of aeson."
haskell,37vna8,hvr_,2,Sun May 31 14:59:25 2015 UTC,"Hey, Rehno!  I made sure to advertise Lambda Luminaries in my post! Yeah, I don't see why I wouldn't want to present it to the group, so why not? :-)  Er, Scientific actually looks perfect. Goddamn! It's going on the TODO list!"
haskell,37vna8,Blackheart,1 point,Sun May 31 17:17:07 2015 UTC,"Maybe you'll even manage to pick up a collaborator, there's probably one or two others there that use bitx ;)"
haskell,37vna8,hiptobecubic,3,Sun May 31 17:32:27 2015 UTC,"You mentioned that haskell-vim-now used to be your config of choice but that ghc-mod is having trouble. I know ghc-mod fails to build under GHC 7.10. If you'd like I could  precompile it for for Mac and Linux under 7.8 and then have the installer download the binary rather than attempting to build it. Would that work for you, or is there a deeper problem with ghc-mod even after it is compiled? I notice you're involved with this issue as well."
haskell,37vna8,Blackheart,3,Sun May 31 15:22:03 2015 UTC,ghc-mod works for me on 7.10 when compiled from Daniel Gröber's release branch.
haskell,37vna8,Blackheart,1 point,Sun May 31 16:56:53 2015 UTC,"I just have to take the time to figure out the Haskell tools a bit more, I'm sure you already have your hands full chasing around other bugs already. :-)  People far smarter than me are already working on it, I see."
haskell,37vna8,Faucelme,3,Sun May 31 17:20:45 2015 UTC,"since you mentioned the IDE situation, I don't think it's too bad. for example, now we even have 3 -- yes that's right, not just one or two, but three -- plugins just for Intellij IDEA:   HaskForce haskell-idea-plugin intellij-haskell   the pace of development is not earthshaking, but it's being done, and I personally have had a good experience with HaskForce."
haskell,37vna8,peargreen,2,Mon Jun 1 01:03:56 2015 UTC,"Umm... How do I set the SDK home for HaskForce on Ubuntu? Google turns up a bunch of complaints about this not working automatically, and nothing about how to do it manually."
haskell,37vna8,peargreen,2,Mon Jun 1 18:37:58 2015 UTC,"File -> Project structure -> SDKs -> green plus -> Haskell SDK  when I installed GHC I chose as PREFIX /home/myuser/.local, so thats the directory selected  does that help?  also remember to install ghc-mod, hlint and stylish-haskell before. ghc-mod can be a bitch to install because of cabal hell, that's why I use Stackage (LTS Haskell to be precise). If you are new to Haskell, you might find this install script helpful."
haskell,37uqqk,NiftyIon,6,Sat May 30 15:45:49 2015 UTC,"I really enjoyed your diagrams example (""In [20]""), I wish try.jupyter.org supported it."
haskell,37uqqk,gelisam,5,Sat May 30 17:01:40 2015 UTC,"I’m biased, but I think the things CJ East did with Frames and Chart are pretty awesome. It still amazes me that all of those pieces work so smoothly in IHaskell.  There’s currently a small hiccup getting Chart updated, and I have to push Frames to Hackage, but I think getting expressively typed data from some CSV file hosted somewhere, top notch performance processing that data, and in-line charting is a really compelling demonstration."
haskell,37uqqk,acow,2,Sat May 30 18:56:41 2015 UTC,Link?
haskell,37uqqk,rpglover64,2,Sun May 31 20:52:13 2015 UTC,Here's a link to the part of a talk I gave where I cover it.
haskell,37uqqk,acow,1 point,Mon Jun 1 02:35:06 2015 UTC,"Wow, this would deserve its own thread. I was looking for ways to substitute Pandas in Haskell, there is a big thread in this channel about libraries for matrix manipulation in Haskell, but Frames is not listed. I will definitely deepen this, thanks!"
haskell,37uqqk,liberalogica,1 point,Mon Jun 1 09:54:16 2015 UTC,"I love IHaskell. I've already started preferring it to ghci since it's so much easier to use. I'd suggest an Aeson example, and also maybe just some basic language features as documented in Learn You A Haskell."
haskell,37tp2c,maxigit,15,Sat May 30 08:31:03 2015 UTC,"Not just 2:  Also, (max,minBound), (min,maxBound)...  We use one of these to give rise to the tropical semiring, in which max is playing the role of addition and (+) plays the role of multiplication."
haskell,37tp2c,edwardkmett,2,Sat May 30 12:17:32 2015 UTC,"Fair enough. I'm just saying that (+) is (much) more natural than (*). I have another instance of Monoid for List, which I call Prefix and reduces  [""TShirt-Red"", ""TShirt-Blue""] to ""TShirt-. Does this invalidate the actual Monoid instance for List ?  I had a look at your reducers package which seems to help in that type of situation. However, AFAIU the reducers packages needs type to be pulled from the return types, which is not ideal when you work with ghci."
haskell,37tp2c,edwardkmett,4,Sat May 30 12:36:37 2015 UTC,What is your mempty? ;)
haskell,37tp2c,dave4420,1 point,Sat May 30 13:00:07 2015 UTC,"PEmpty ;-). Ok, I cheated this is not exactly an instance of List, in fact it only even works for String. As the instances are already taken I have to make a newtype which appears to be just a datatype :  data Prefix = PEmpty | Single String | Prefix String   Ok, you got a point, I can't find any other instance for List which don't break the monoid law (but that doesn't mean, they are not any )."
haskell,37tp2c,tel,3,Sat May 30 13:33:08 2015 UTC,instance Monoid a => Monoid [a] where     mempty = repeat mempty     mappend = zipWith mappend   But I think it would be bad for s <> t to mean different things depending on whether they had type String or type Text.
haskell,37tp2c,tel,1 point,Sat May 30 13:58:43 2015 UTC,"I meant, general instance for List, ie without class constraints."
haskell,37tp2c,ForTheFunctionGod,6,Sat May 30 14:12:23 2015 UTC,"There are at least two, forward and backward concatenation."
haskell,37tp2c,tactics,2,Sat May 30 16:48:53 2015 UTC,"The instance for list is also special in that (morally) it is the ""largest"" monoid in that we can naturally extend any function Monoid m => (a -> m) to [a] -> m with foldMap."
haskell,37tp2c,ForTheFunctionGod,13,Sat May 30 13:50:25 2015 UTC,"Num should be an instance of Monoid (using (+))   If we go down that route (and I'd like that), we should build up the entire hierarchy of algebraic structures with one binary operation:  class Magma a where    (<>) :: a -> a -> a class Magma a => Semigroup a -- promises associativity for <> class Magma a => NeutralElement a where    empty :: a class (Semigroup a, NeutralElement a) => Monoid a instance (Semigroup a, NeutralElement a) => Monoid a --Monoid is just an abbreviation for ""associative OP + neutral element"" class Magma a => Commutative a class Magma a => Invertible a where -- structures with a ""minus""-operation    inv :: a -> a class (Monoid a, Invertible a) => Group a class (Group a, Commutative a) => CommutativeGroup a instance (Group a, Commutative a) => CommutativeGroup a   ex.:  instance Magma Int where (<>) = (+) instance Semigroup Int instance NeutralElement Int where empty = 0 instance Invertible Int where inv = negate instance Commutative Int   The problem would be that you couldn't easily use addition and multiplication side-by-side, or construct a ring out of a group and a monoid. In that sense, Num (sans Monoid) might be mathematically iffy, but it does work well in practice.  I tried to solve this issue once by turning the typeclass instances into values that you could shove around: algebra. It's... not very good. I stopped when I couldn't figure out how to do modules (vector field thingies weaker than rings)."
haskell,37tp2c,Taladar,3,Sat May 30 10:00:09 2015 UTC,"I don't think anyone in the world has ever used the word ""magma"" except to link to it on Wikipedia.  Start with a monoid and work your way up.  It's also questionable how important the distinction of commutativity is to programmers. It's really important for theory, but there's a bunch of overhead you incur for it that might not be worthwhile unless you're attaching a theorem prover.  Lastly, floating point numbers still suck. No amount of typeclass twiddling will change that :("
haskell,37tp2c,tactics,3,Sun May 31 15:57:58 2015 UTC,"Lastly, floating point numbers still suck. No amount of typeclass twiddling will change that :(   This talk might interest you (might be a repost). The guy shows two really very clever schemes for doing arithmetic with unbounded precision."
haskell,37tp2c,Taladar,3,Sun May 31 16:56:03 2015 UTC,Start with a monoid and work your way up.   Semigroups are weaker than monoids and relatively common in Haskell.
haskell,37tp2c,tactics,2,Sun May 31 18:52:44 2015 UTC,"Yes,  but why would you use a semigroup instead of the monoid it generates?"
haskell,37tp2c,tomejaguar,3,Sun May 31 20:03:20 2015 UTC,Because there are semigroups which do not generate a monoid.
haskell,37tp2c,ForTheFunctionGod,1 point,Sun May 31 20:25:12 2015 UTC,"Ah, you get screwed over by some technicalities, don't you?  I believe it's enough that you require that semigroup morphisms preserve identities whenever they exist."
haskell,37tp2c,tomejaguar,1 point,Sun May 31 21:02:03 2015 UTC,"I like this idea as well. However, I doesn't cost anything to just add now a Monoid instance to Num. I could do it myself when needed, but it then leaks everywhere because of orphan instances problems."
haskell,37tp2c,edwardkmett,10,Sat May 30 10:17:53 2015 UTC,I doesn't cost anything to just add now a Monoid instance to Num   Yes it does; it costs everyone else the unwanted instance.
haskell,37tp2c,Denommus,5,Sat May 30 10:32:22 2015 UTC,"That is certainly true. Instances being global, you can't, in good conscience, prefer one over the other in case of real ambiguity.  Ziplists are a novelty in contrast to the natural ([a], ++, []) algebra, but (N, +, 0) isn't really preferable to (N, *, 1)."
haskell,37tp2c,alexeyr,1 point,Sat May 30 10:40:00 2015 UTC,"Except nobody is using it, that won't break any code and people who want to use Product can still use it and people who want to use Sum can still do either. So what's the problem ?"
haskell,37tp2c,tomejaguar,6,Sat May 30 10:47:30 2015 UTC,The problem is code that was previously correctly rejected as nonsense starts to typecheck.
haskell,37tp2c,bartavelle,1 point,Sat May 30 10:57:39 2015 UTC,"I can understand some case using Monoid by mistake but that's not related to the fact that there is a potential other instance alternative. For example, I can have a list of items  [(String, Int)] [(""T-Shirt"", 1), (""Jumper"", 1), (""T-Shirt"", 2)] and indeed I shouldn't be able to call mappend on it. Having an monoid instance on num would result in (""T-ShirtJumperT-Shirt"", 4) which is obvioulsy not what we want, but because of the String not the Int. Yes I had this problem a couple of time, do I think that String should not be an instance of Monoid ? No."
haskell,37tp2c,bartavelle,6,Sat May 30 11:37:04 2015 UTC,"I have Num types where the Monoid is much better served by being something other than (+).  Example:  newtype Poly a = Poly [a]   (+) is one choice of Monoid, but if we instead take 'substitution' as the Monoid, then we get some remarkable utility. We don't need to come up with a one off combinator for substitution, logically, f(g(x)) becomes (f <> g)(x) in this representation. The identity for substitution mempty = x gives me a name for the x in my polynomial."
haskell,37tp2c,Bzzt,3,Sat May 30 12:25:04 2015 UTC,"Ok, I didn't think of newtypes being a Num and having their own Monoid instance. I totally agree with that and that's the argument I was waiting for :-)  However, that still stands for pod num : ie Int, Double  etc ..."
haskell,37tp2c,wrvn,2,Sat May 30 13:47:09 2015 UTC,Why do you chose (+) instead of (*) or any other monoid operation over Num?
haskell,37tp2c,wrvn,1 point,Sat May 30 15:15:04 2015 UTC,"Why do you chose (+)    I though it was pretty obvious in my OP   (+) is the natural moniod instance for many reasons. Monoid can be seen as weak Group. Num are a group under (+) but not under ( * ). Also most of the time, Num are used to represent physical quantities (with units, as 1 metre, 2 potatoes, etc ...). Such quantities have only one possible instance for Monoid. Last, for the few people which really need the (Num,(* )), they can still use Product or better use logs.   Basically how much have you ever needed other instance than (+) ? when you use sum, you are the using the (+) instance of monoid  for Num (I mean not in Haskell, but in theory)."
haskell,37tp2c,pinealservo,2,Sat May 30 15:23:03 2015 UTC,Do you mean instance Num a => Monoid a? Doesn't it overlap with every other Monoid instance?
haskell,37tp2c,SrPeixinho,2,Sat May 30 13:40:47 2015 UTC,"You are right. In fact, reading /u/edwardkmett answer , I realized I mean, Nums id Int & Co, not user defined ones."
haskell,37tp2c,pinealservo,12,Sat May 30 13:50:35 2015 UTC,"Let's classify the inconveniences   Import: Language ""If it compiles it works"": Community Debugging: Tooling Indexes: Community Num a => Monoid a: Language or libraries.  I lean toward the former."
haskell,37tp2c,TunaOfDoom,20,Sat May 30 12:21:10 2015 UTC,"I'm shocked that the community thinks using ""id"" or ""indexes"" to represent mutable graphs is acceptable even though it's reinventing pointers with the same level of unsafety   Wow, this is not nearly as unsafe. You don't get arbitrary memory writes when inserting into a Map with a key that's under a hostile user control."
haskell,37tp2c,chrisdoner,12,Sat May 30 09:25:26 2015 UTC,"Having a vector of things, and reference to their indices  looks really like  having a heap and pointers. You don't get indeed arbitrary memory writes in the full memory but you do get them in your own local heaps. You can get an index, add 1 to it, and modified the newly refered data. You can also have indexes out of bound. You can remove an object from a vector and by that make all indexes referencing to the wrong object.  Yes all of that is manageable, but it's also manageable in C (not more, not less). The only difference is each type of data, has it's own allocated pool of memory but that doesn't really change the problem.   What is disappointing is all the solution have seen for this problem are ""unsafe"" and everybody seems to consider it  as normal: ""after all, it's Haskell, therefore it is type safe by definition"".  Am I really the only one seeing this as a problem (even though questions related to mutable graph are recurrent)?"
haskell,37tp2c,chrisdoner,9,Sat May 30 10:36:47 2015 UTC,"I just wanted to point out that in Haskell you will have a logic error, whereas in C you will have at best a runtime crash, and might end up with an exploitable vulnerability.  So I agree with you that if you mean ""less bugs in my graph algorithms"", there is not much to gain by moving from raw pointers to indexes in immutable maps. But if you mean ""less devastating bugs"", you are much better off with Haskell.  Just to answer the ""with the same level of unsafety"" part."
haskell,37tp2c,zandekar,7,Sat May 30 11:31:20 2015 UTC,"I'm not sure what you mean by logic error. Accessing something out of the bound of Vector gives you a Out of bound exception which is similar to runtime crash. Also, having wrong indices and modifying the ""wrong"" slot, is equivalent to memory corruption and as devastating. I can provide some example code if needed."
haskell,37tp2c,chrisdoner,4,Sat May 30 11:47:02 2015 UTC,"I guess I'm used to the idea of memory corruption in C, where some part of your program, if it uses a bad index, can modify anything in the memory space of your program, including code.  That, to me, is a worse class of error than writing to the wrong element in a map, or erroring out with an exception.  Your haskell program might not work right, or might terminate, but at least it doesn't keep going with compromised security and do hacker stuff on your computer."
haskell,37tp2c,sccrstud92,6,Sat May 30 17:46:31 2015 UTC,"I'm not sure what you mean by logic error. Accessing something out of the bound of Vector gives you a Out of bound exception which is similar to runtime crash.   Yes runtime crash caused by bounds checking in vector library - meaning that illegal memory access will be never be attempted.  On the other hand in C, if you are lucky, you will get only segmentation fault caused by trying to access non existent address or trying to write read only memory segment....  If you are not lucky that memory region you are accessing might contain some other data you allocated in your program...variables and such...meaning you now have silent memory corruption that might or might not manifest itself right away and in some obvious way. This, if unnoticed, can be easily turned into exploit by some 3rd party."
haskell,37tp2c,chrisdoner,2,Sat May 30 13:05:04 2015 UTC,"When I mean safety I mean 'type safe' , ie compiler detecting errors, not security issues (which I agree, Haskell is probably more secure than C)."
haskell,37tp2c,sfultong,2,Sat May 30 14:10:34 2015 UTC,It's not very pretty but that is possible too. See this and this for example.
haskell,37tp2c,Dickferret,3,Sat May 30 14:37:45 2015 UTC,"There's a significant difference between the (non-)safety of pointers in C and arbitrary indices into a Haskell Vector object.  The term 'safety' in programming language circles is generally defined to be a bit less general than how you're using it. Roughly, it means that the evaluator of the language can't get ""stuck"", i.e. it can't ever run into a situation where there's a value that isn't fully evaluated but doesn't have an evaluation rule that applies to it.  It is important to realize in this context that ""throw a runtime exception"" is a well-defined evaluation rule. In a safe language, anything that the language accepts as input has an evaluation path that's well-defined (i.e. the language definition knows how to handle it) even if the definition includes run-time errors for some situations that the programmer will need to pay attention to avoid.  This is in stark contrast to C, where there are plenty of constructs that the language implementation will accept that have no defined evaluation rules. In the C specification, these are noted as ""undefined"", and if your program contains any of these, the specification declares your entire program to be essentially meaningless. An implementation may do anything at all with such a program; quite often, pointers to one type of object will end up referencing a different type of object, which is exactly what it means in a technical sense to violate type safety.  In Haskell, getting the object at an index in a Vector (or some other indexable type class) of A will always either give you an A or a runtime error (assuming the index function doesn't return a Maybe), and will never return a value of some other type B. This is the essence of type safety."
haskell,37tp2c,yitz,3,Sat May 30 23:50:12 2015 UTC,So Scheme is type safe under your definition...
haskell,37tp2c,ninereeds314,2,Sun May 31 20:48:46 2015 UTC,"Well, yes, in a dynamically-typed sense.  Scheme's type system unifies all its data representations into variants of a single static type, but its evaluation rules ensure that you will never erroneously evaluate, for example, a symbol value where a pair value is expected. The mismatch is guaranteed to be detected and an evaluation rule exists to raise an error signal. You won't accidentally corrupt memory somewhere.  There's a continuum in the world of programming languages between static checking of properties and dynamic checking of properties, but if the safety properties of the language evaluation rules are checked, then it's a memory-safe language that guarantees that its primitive evaluation rules won't get one data representation when they expect a different one. C doesn't provide any guarantee of these properties (the programmer is expected to look out for and avoid them) but both Scheme and Haskell do.  Even Haskell has to rely on run-time checking of some properties to maintain safety (vector bounds, for example), though certainly fewer than Scheme does. You can get more static checking in a dependently-typed language, but even then you will often just have a static check to show that a run-time check must have occurred earlier. Sometimes you just have to do your checks at runtime, but this doesn't make anything inherently less memory-safe.  A final observation: Haskell's runtime error values are all semantically equivalent to the 'bottom' value. This value inhabits all Haskell types. So it's a bit misleading to suggest that 'head' is not a type-safe function. It surely is; it will never produce a value that does not inhabit its result type, although it might produce the bottom value. We sometimes call 'head' an ""unsafe"" function, but it's not really unsafe in the technical senses that that type safety and memory safety cover. It's only ""unsafe"" in the sense that it has some preconditions not distinguishable by its type, but it's not yet very practical to capture all function preconditions in any type system. And failing to meet those preconditions only results in a bottom value, not memory corruption or an unconditional abort or something."
haskell,37tp2c,Peaker,2,Tue Jun 2 07:31:57 2015 UTC,"Can you point me to an article or thread discussing using indexes as pointers to graphs?   I think it's very interesting, specially if someone finds a safer alternative"
haskell,37tp2c,ninereeds314,2,Sat May 30 13:13:16 2015 UTC,See my post there.
haskell,37tp2c,FUZxxl,6,Sat May 30 14:09:13 2015 UTC,"I think the red herring there was focusing on mutability. As you say in your post:   With an OO language, it's pretty easy. You have Boxes, which are located on a shelf, which belongs to a racking etc ... Everything has a name, a position and things are mutable. .i.e I can rename a shelf, turn a box easily.   That's how I'd model it in Haskell:  data Warehouse = Warehouse {warehouseIsles :: ![Isle]} data Isle = Isle {isleShelves :: ![Shelf]} data Shelf = Shelf {shelfBoxes :: ![Maybe Box]} data Box = Box    But without the mutability. Forget about mutating. Here's an example paste of using the data structures I defined. I can add a box to the warehouse and it will pick the first isle and shelf where it can fit from the bottom up. Hence the output:  λ> fromJust (foldM (flip addToWarehouse) warehouse (replicate 50 Box)) B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B  _ _ _ B B _ B B B B B B B B B B B B B B B B B B  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _   If I want to remove the third box from the second shelf on the second isle I can just have a function removeBox :: Int -> Int -> Int and do removeBox 3 2 2. If I was making a GUI, I wouldn't have to use numbers, I'd just build up the UI so that it knows how to produce the data structure with or without a box in a slot. If I wanted to label the boxes with a globally identifiable barcode, rather than reference them by order, I could have removeBox :: Barcode -> Warehouse -> Warehouse, which would search the Warehouse and produce a new warehouse without that box. It could also be getBox :: Barcode -> Warehouse -> (Warehouse,Box) which would produce a new warehouse and the box in question. And so on. With the pure data structure you can also trivially go back in time to trace modifications or try out scenarios speculatively (which is partly what I do in addToWarehouse with thisIsle <|> nextIsle, that tries two possibilities and picks the first one that works).  Decoupling everything into some kind of relational database with IDs mapping objects to objects kind of defeats the purpose of modeling this in Haskell."
haskell,37tp2c,tel,3,Sat May 30 16:27:06 2015 UTC,"First, I'm really impressed by your example and honored that you took the time to make a working example. However my problem is about a real warehouse and is much much more complicated. First, boxes have different sizes, and there is no slot. Boxes are just chucked wherever there is space and the ""empty slots"" are the result of the stacking of the current box in the shelf. Moreover, boxes are already there and can't be moved, boxes can be rotated (see picture in red circle) if need to fit in shelf, some are too heavy to be put on a top shelf etc ... . The fact there is no slots means you can't really predict how many boxes of a given size you can put in a shelves without looking at the exact content of the shelf (you can speed up things by keeping for each shelves a list of available rectangles but it's still dynamic and needs to be updated each time a new box is added). The only way is to try ""physically"" (but virtually ) some box arrangements. There is about 1500 boxes and 100 shelves so trying all the arrangement is not option. To be able to try those arrangement I need a mutable state (I think) because each arrangement correspond to ""place""  each box one by one. I can't have a different state for each step (placing a box) even though I need the actual ""sub state"" to know where to place the next box. I attached a picture which is an extract of whole result. White boxes are boxes already in place (and can't be moved). Boxes in green and yellow are the boxes coming in the next delivery."
haskell,37tp2c,maninalift,5,Sat May 30 17:59:02 2015 UTC,"Sure, you have a packing problem which is NP hard in the worst case, but it seems like in your case at least you only have to pack a couple objects at a time rather than re-arranging the whole container for the best packing. It is an interesting problem to work on and should be a nice test for Haskell.  But my example wasn't to demonstrate an exact implementation of your domain but to show this kind of problem can be modeled purely, despite your natural instinct to think about it imperatively. If you're interested in experimenting further, probably checking out examples of constraint satisfaction problems in Haskell could be a good way to get inspiration and confidence that it's doable. N-queens, connect-4, Sudoku and Sudoku on the HaskellWiki, things like that. Just googling or looking on hackage or lpaste there will be a bunch.  I implemented a word cloud generator back when I was more newbieish, which is essentially a restricted packing problem. Here're some of its outputs. The code is here, but it's so old and probably doesn't build anymore. At any rate the crux of it is here which uses mplus (these days aka <|>), essentially an amb operator that picks between two branches.  Also possibly of interest for motivation might be this page in which I list a number of varying (but all pure) solutions to the constraint satisfaction problem posed by Twitter. The best one is probably the fastest vector one, my loeb one is more of a nice curiosity than a serious solution.  So in the end you would just replace my function for adding a box with something that doesn't just put in the first available slot but maybe takes a list of boxes to place, and tries various configurations for the most economic fit. I'd imagine it would boil down to generating a list of solutions (e.g. [Isle]) and rating them with some rating function (giving Isle → Rating) and picking the best rated solution. That's the logic of it (of course you can optimize by having it generate-and-rate as it goes and have it stop generating a solution if at any point it exceeds the rating of previous solutions, etc.). To do this in a pure Haskelly way, it has to be thought about in terms of generating new things instead of changing existing things."
haskell,37tp2c,tel,3,Sat May 30 18:48:14 2015 UTC,"I'm probably wrong but the difference between with or without slot is immense. With slot, the problem is just to find the next free slot and the result can be stored as a list. Without slot, it becomes a 2d problem. As boxes can be of different size, to add a box to a shelf with already some box in it, you need to find if there is any existing gaps between the present box. Trying an arrangement boils down to place the first box in one corner, place the second to first available gap and so on. Finding those gaps is tricky : the boxes can have different size, you need to be able to compute from a list of occupied rectangle,  a list of available rectangles. For performance reason, you don't want to recalculate from scratch this list of a available rectangles each time you add a new box, but want to keep a cache and only compute the intersection of the new box with previous list of available rectangles.  Ok, maybe I'm doing premature optimisation but my actual program is quite slow. If you have time to waist, I strongly recommend you try this problem, it's an interesting one .  About the representation, maybe I again doing premature optimization but if I model my warehouse as you did (which by the way, seems perfectly reasonable), each time I move a box, I need to the whole structure (or at least part of it). I have 1000 boxes, which I think is a big graph, and each time I move a boxe, I have to regenerate a new graph. Trying an arrangement, generates 1000 graphes of 1000 boxes. Then I have to ""try"" billions of arrangement, so I need each try to be reasonably fast. Once again, maybe I'm wrong and maybe there is no problem.  Last but not the least, (maybe it's in fact the main reason why I think I need mutability )is I need to be able to do efficient lookup both way (ie , shelf -> box and box -> shelf), meaning I also need a box to refer to a shelf (or at least I think I need it). This is this bi-directional relation which is my main problem. I can build it by tying the know, but I don't see how you can update a graph build that way.  Having said, that I realized writing this, that there is a couple of things I probably could do in a different ways but I literally had a week to do it (the deadline being a container arriving on the monday)."
haskell,37tp2c,Gurkenglas,2,Sat May 30 23:49:06 2015 UTC,"You could use two maps. One mapping boxes to shelves and the other mapping shelves to boxes. You then hide this in a module and export an api that provides the functionality you need while maintaining the consistency between these two maps.  The shelf map could contain two values, one being the boxes on it and the other being the space available. Then you could iterate through the shelves seeing if any rotation of the box would fit into the available space.  When you find a good shelf you add the box to the list of boxes for the shelf in the Map Shelf ([Box], Space), update the available space, and add the box to the Map Box Shelf.  In principle you are producing an entirely new structures when you update these. However the implementation of Map and ghc use sharing and fusion to make updating data structures efficient. There is the idea of programs being a ""law"" and the compiler is free to use whatever means satisfies that law. So an api can actually be mutating structures internally while exporting a pure interface."
haskell,37tp2c,ReinH,2,Wed Jun 3 17:36:01 2015 UTC,"I've looked at the code of WorldCloud, and ok, the problems are really similar (so you can skip my previous answer to your post ;-)).  However, what I'm trying to acheive (and also where our problem differs and what I'm probably doing wrong ) is to keep a (virtual) map Box -> Shelf and it's reverse Shelf -> [Box]. I need those two maps because that's the way I talk to the system, i.e. move boxes from shelf1 to shelf2 or move boxes of type1 to shelf2 etc ...  So the difference with your code is: your rectangle doesn't hold which word they contains. You have two states , your list of busy rectangles and the canvas itself which is the result. My approach is to mix both of them into one with mutual references.  Looking at your code, I realize that I probably could do something similar  and indeed my current approach is probably strongly OO oriented. However, I still feel that this type of problems (how to represent a graph of mutable object with mutual references) is legitimate and I haven't find yet a satisfying solution. Maybe STRef is the solution which I haven't explored at all (I'm still a bit scared by the ST Monad ;-))."
haskell,37tp2c,pipocaQuemada,2,Sun May 31 11:11:12 2015 UTC,"If we continue with our pure approach, you construct a new warehouse whenever you make a change to it. (Of course, the GHC runtime will re-use everything that didn't change.) So moveBoxTo :: BarCode -> Int -> Int -> Warehouse -> Warehouse, i.e. move that box from wherever it is to the given isle and shelf number. You only have tens of racks and a thousand boxes, that's nothing to walk through.  Having mutable mutually referential data structures is just creating a problem you don't have, it seems to me."
haskell,37tp2c,FUZxxl,2,Sun May 31 11:29:58 2015 UTC,What's the point of the strict fields? Does evaluating one thunk really make that much of a difference?
haskell,37tp2c,pipocaQuemada,2,Sat May 30 17:03:58 2015 UTC,Strict fields are just the better default. It's rare to want a lazy field.
haskell,37tp2c,FUZxxl,2,Sat May 30 17:45:42 2015 UTC,"i have always been under the impression that the maxim ""strict your leafs"" would consider collection-y fields (such as lists) to be further branching and not a leaf itself"
haskell,37tp2c,pipocaQuemada,1 point,Sat May 30 19:56:29 2015 UTC,So what you really want is dependently-typed maps so you can get key constraints.
haskell,37tp2c,FUZxxl,2,Sat May 30 15:22:24 2015 UTC,"I think you can get the requisite safety with just ST, can't you?"
haskell,37tp2c,pipocaQuemada,2,Sun May 31 02:31:17 2015 UTC,"The problem is with mutability itself. Once you get used to avoiding mutability, you realize that you almost never really need it. But in those cases where you really do need mutability, labeling things with an ID that can be used as a Map key is a good technique."
haskell,37tp2c,FUZxxl,1 point,Sat May 30 22:28:12 2015 UTC,"It depends what you mean by ""pointer"". That word represents a whole mass of different abstractions and, while most (not all) are implemented using machine addresses, I'll do the captain obvious thing and point out that Haskell implements things with machine addresses anyway - e.g. referencing lazy-evaluation thunks. What matters is the set of rules the compiler enforces. If a hostile user can get control of machine pointers and your raw memory, you're pretty much screwed whatever.  Pointers as provided by various languages aren't just arbitrary memory writes, and aren't susceptable to C-style memory curruption bugs. For example there are languages that don't support pointer arithmetic, don't allow pointers/references to be cast to/from other types, and aren't susceptable to dangling pointers because you can't have pointers to local/stack variables (the last point was e.g. true in Ada 83).  So yes, in a sense, some uses of Map are really just re-inventing a particular class of pointer - potentially inefficiently, though of course an immutable implementation has its own advantages with its own potential efficiency savings depending on the application.  Actually, I have a module with a typeclass for references - providing overloaded versions of the usual operations for IORef and STRef, including an implementation based on Map, so you can use this to literally write newRef, readRef, writeRef and modifyRef and not know whether the underlying implementation is IORef, STRef or items allocated in a Map. Obviously you also wouldn't know which monad, as that depends on the pointers too (for Map-based pointers, usually it would be State).  Of course you get some limitations - it needs to know (for all pointers) the one type that your pointers reference, obviously items in a map won't get garbage collected etc.  However, it still e.g. guarantees no dangling pointers and no ""arbitrary memory writes"" in much the same way that ST does.  But clearly when your references can be implemented as either a Map or an IORef (or even potentially an FFI Ptr, with further no-garbage-collection caveats) using the same notation with the same type constraints, there's a very strong sense where neither is safer than the other."
haskell,37tp2c,julesjacobs,2,Sat May 30 14:18:21 2015 UTC,Can't you use weak refs so that your Map refs do get garbage collected?
haskell,37tp2c,vincentrevelations,2,Sat May 30 20:17:21 2015 UTC,"Possibly, but the keys will still be in the map anyway unless some kind of discard-dead-keys scan was included explicitly.  The kinds of use I had in mind (theoretically - this has never been used seriously) were rather like using runST - you have a single algorithm that allocates and uses some pointers then delivers a result and that's it. Although single items in the map can't be garbage collected, once it's finished with, the map as a whole certainly can be.  The real trick would be using this with the FFI Ptr type, particularly without leaking memory but there's other issues too. After all, as well as being non-garbage-collected and not having a convenient way to find all relevant pointers for explicit cleanup, Ptr does support casting, pointer arithmetic etc - after all it's designed for interop. with C. So long as those Ptr values can't leak out of the interface to that module (so references can only be used according to the IORef-style rules) that's not necessarily a problem, but it also defeats the whole point of using Ptr.  TBH it was an interesting exercise for probably an hour or so (I seem to remember fighting the types a bit), and then I forgot about it until today."
haskell,37tp2c,julesjacobs,1 point,Sat May 30 21:03:49 2015 UTC,By pointer I mean a vector or map of object somewhere and reference to keys or ids somewhere else.
haskell,37tp2c,FUZxxl,19,Sat May 30 23:09:18 2015 UTC,"I think the real problem is that Haskell got monoids backwards. Being a monoid is not the property of a type, it's the property of a type T, a function (+): T2 → T, and a value ε: T, but type classes do not allow us to express this idea."
haskell,37tp2c,cdxr,13,Sat May 30 10:26:31 2015 UTC,"All typeclasses are like this, though. They are the structures and properties that you match to some ""stuff"" to get a useful theory.   Monads are not types T, but triples (T, return, join) which follow the Monad laws Orders are not types T but tuples (T, >=)   Equality is a bit interesting since you usually do have type equality, but Haskell is a bit more restrictive in that we tend to be interested in deterministic equality   Setoids are not types T, but tuples (T, ==)   asoasf."
haskell,37tp2c,FUZxxl,3,Sat May 30 13:44:49 2015 UTC,"I like the view that, say, a monad is a triple, not a data type with some implicit operations.  However I don't think that type classes quite express these relationships in a first class fashion (for some meaning of ""first class""). In particular it is possible to express that two type classes share a particular data type but not that they share a particular operation which makes it difficult to make inferences between type classes.  Type class design is not a mistake it is a deliberate design decision, but it come with certain advantages and limitations."
haskell,37tp2c,flazz,7,Sat May 30 18:29:09 2015 UTC,"Yeah, a more direct and first class monad definition would be the following   data Monad t    = Monad     { return :: forall a . a -> t a    , bind   :: forall a b . (a -> t b) -> (t a -> t b)     }   with which you can write everything you normally can by replacing (=>) with (->)  forever :: Monad t -> t a -> t b forever d = go t where go t = bind (const $ go t) t   now it is clear that t is just a type but Monad t a monad triple.  The downside is just having to wire dictionaries around everywhere. Picking them apart, putting them together under certain implications  transformEither :: Monad t -> Monad (EitherT e t)   it's not difficult, it's just laborious. Typeclass machinery avoids this by assuming each type has either 0 or 1 unique instances for each kind of constraint."
haskell,37tp2c,kraml,3,Sat May 30 19:49:03 2015 UTC,"That seems to require one to apply the instance object to every typeclass operator. Couldn't we make something that would be used like this: (Applied to only Monoid now for less incremental steps of modification:)      (<>) :: m -> m -> Monoid m     (<>) = mappend      fold :: [m] -> Monoid m     fold = foldM mappend mempty   Yes, ""Monoid"" itself would have a monad instance. There would be a function      evaluateMonoid :: MonoidInstance m -> Monoid m -> m   to get out of the monadic context, and the bind would for all d, together with      extract := (evaluateMonoid d .) :: (a -> Monoid m) -> a -> m   obey:      extract (f >=> g) == extract f >>> extract g   The next things to think about are abstracting the word ""Monoid"" out of the last few lines to get a general instance system, then applying it to itself to get rid of the old-instance-system baggage."
haskell,37tp2c,tomejaguar,6,Sun May 31 23:05:13 2015 UTC,"How is this not what typeclasses do? Ah, because typeclasses fix the operations to the type. Yeah, there's been various discussion about this, and having  data Monoid a = Monoid   { mappend :: a -> a -> a   , mempty  :: a   }   and explicitly passing the dictionary around is possible but cumbersome. (And is, of course, exactly the thing typeclasses are meant to improve.)"
haskell,37tp2c,kraml,3,Sat May 30 17:28:43 2015 UTC,"explicitly passing the dictionary around is possible but cumbersome. (And is, of course, exactly the thing typeclasses are meant to improve   Edward Kmett actually convinced his boss that rewriting the Ermine compiler to add typeclasses was a good idea mostly because explicit dictionary passing was too painful."
haskell,37tp2c,hvr_,3,Sat May 30 18:58:45 2015 UTC,Yet it sucks that you can't explicitly specify a dictionary for the few cases where typeclass magic is insufficient.
haskell,37tp2c,Tekmo,3,Sun May 31 09:55:43 2015 UTC,"Implicits, at least in Scala, cause me many more headaches in spurious compilation errors than they prevent with the added power of multiple instances.  Manual dictionary passing becomes absolutely terrible when you want to e.g. traverse over a Compose [] Maybe, or do anything else like that where you need to specify 3+ instances for a single method.  If you can specify a dictionary  manually with typeclasses, then you can no longer rely on the coherence of instances.  This means, for example, that two sets don't necessarily have the same underlying order, so the best you can do is insert every item from the first into the second (as is done in Scala), instead of using the asymptotically faster hedge merge.  While there might be something better than typeclasses + newtypes to specify multiple instances, I haven't seen it yet."
haskell,37tp2c,Tekmo,2,Sun May 31 11:25:23 2015 UTC,"If you can specify a dictionary manually with typeclasses, then you can no longer rely on the coherence of instances. This means, for example, that two sets don't necessarily have the same underlying order, so the best you can do is insert every item from the first into the second (as is done in Scala), instead of using the asymptotically faster hedge merge.   I don't see the point of that. There is a difference between   merge :: Eq a => (Set a -> Set a -> Set a)   where both sets must have the same implementation of Eq and   merge :: (Eq a => Set a) -> (Eq a => Set a) -> (Eq a => Set a)   where the implementation of Eq may be different.  Most of these problems are solvable with proper typing."
haskell,37tp2c,henrylaxen,2,Sun May 31 11:30:58 2015 UTC,"Currently, typeclasses are these magic dictionaries that you obtain from somewhere and can then forget about and drop on the floor; they're not carefully threaded through the code.  This works because instances are canonical.  It doesn't matter how the instance was made or where you got it from; it's always going to be the same instance.    What you need to do for this is to tag types with literally every instance that you might ever want to be the same when working with values of that type.  Additionally, what happens if you call toList . fromList?  You forget about all the instances used in the first set, and replace them with random new ones?"
haskell,37tp2c,sacundim,1 point,Sun May 31 13:04:44 2015 UTC,"What you need to do for this is to tag types with literally every instance that you might ever want to be the same when working with values of that type. Additionally, what happens if you call toList . fromList? You forget about all the instances used in the first set, and replace them with random new ones?   Elements of a list have to be homogenous, thus they all have to have the same dictionary. That would be the difference between type  Something a => [a]   and  [Something a => a]"
haskell,37tp2c,gelisam,1 point,Sun May 31 13:08:13 2015 UTC,"What I meant was something like  fromList . toList $ set1   but on second thought, that's not enough to get rid of the instance.  What is enough is to say something like   Set_map fromInteger . Set.map toInteger $ intSet"
haskell,37tp2c,codygman,1 point,Sun May 31 13:53:22 2015 UTC,How so?
haskell,37tp2c,wizao,2,Sun May 31 13:55:24 2015 UTC,"Sets are a bad example because modules  (~= records) provide a much better solution than type classes. (This has been discussed many times before, e.g. here.) I am not aware of a good example for why type classes are better than modules + implicits, but I heard that some people are aware of them."
haskell,37tp2c,wizao,3,Sun May 31 20:58:19 2015 UTC,Is there a language with a more algebraic type system?
haskell,37tp2c,codygman,3,Sat May 30 14:15:03 2015 UTC,Look at implicits in Scala and canonical structures in Coq. They solve exactly this problem.
haskell,37tp2c,codygman,2,Sat May 30 23:49:00 2015 UTC,"That's a good question, I don't know any. One could however implement this for Haskell: Give programmers the ability to construct type class instances at runtime by providing a set of functions with the right signatures for a given type."
haskell,37tp2c,codygman,4,Sat May 30 14:16:22 2015 UTC,"It is possible to provide type instances at runtime using the reflection library. Here's one of the examples included with that library, which demonstrates this for Monoid.  Granted, first-class language support would be much more convenient."
haskell,37tp2c,tejon,3,Sat May 30 15:41:05 2015 UTC,"Granted, first-class language support would be much more convenient.   It's weird that Haskell has no first-class support for that because type classes are basically syntactical sugar for tuples. Instead of  sum :: Monoid m => [m] -> m   one could also write:  sum :: (m -> m -> m, m) -> [m] -> m   but that's not possible."
haskell,37tp2c,bartavelle,2,Sat May 30 15:49:19 2015 UTC,… those and the monoid laws
haskell,37tp2c,FUZxxl,6,Sat May 30 15:38:52 2015 UTC,"Every time I work with Haskell I wish I could have a Imports.hs module with a whole bunch of qualified imports that I could make available anywhere. It is one of my greatest annoyances in Haskell.  I sometimes work around it with an #include statement, but it feels dirty."
haskell,37tp2c,bartavelle,3,Sat May 30 12:36:27 2015 UTC,What do you mean?  Something like  Imports.hs:  export qualified Control.Applicative export qualified Data.Monoid  Main.hs  import Imports  ... use Control.Applicative.pure ...  ... use Data.Monoid.mempty ...
haskell,37tp2c,sambocyn,3,Sat May 30 12:52:48 2015 UTC,"I don't know what /u/kraml means but that's what I mean by ""qualified exports"", even though it would probably more like  Import.hs: export qualified Databas.MySQL.Simple as SQL  Main.hs  ... use SQL.connect ...   Instead of starting all my file with   import Database.MySQLSimple as SQL"
haskell,37tp2c,bartavelle,1 point,Sat May 30 13:54:56 2015 UTC,"Right, that's it. Just importing Imports.hs should make it available."
haskell,37tp2c,jaybee,3,Sat May 30 16:11:09 2015 UTC,"Well, if somebody came up with an implementable proposal to augment H2010's module import/export specification it'd increase the chances of getting such a language extension in the foreseeable future (after some obligatory bikeshedding of course...) :-)"
haskell,37tp2c,FUZxxl,8,Sun May 31 07:53:40 2015 UTC,"""if it compiles it works"" is mostly true when refactoring"
haskell,37tp2c,sambocyn,3,Sat May 30 17:53:50 2015 UTC,"I agree with that, but that's mainly because it already worked ;-)"
haskell,37tp2c,Faucelme,6,Sat May 30 18:19:06 2015 UTC,"The biggest benefit of a refactor-friendly language is that you can easily change course rapidly if you realize that your initial approach to a problem was incorrect.  For example, completing a project is not a binary ""working""/""not working"" proposition.  Often you will complete a project in stages, beginning with a minimally viable prototype and then iterating on that prototype until you have a fully featured solution.  If you can't easily refactor, you will often discover along the way that you made some bad choices in your initially minimally viable prototype, but you've sunk too much time and effort into it already and you can't easily change course.  In a refactor-friendly language like Haskell you can make significant and sweeping changes while still preserving functionality."
haskell,37tp2c,Lossy,6,Sat May 30 18:57:08 2015 UTC,I second this emphatically.  Haskell lets the compiler find all stupid mistakes you would have ordinarily discovered at runtime (maybe eventually.)
haskell,37tp2c,dan00,5,Sat May 30 20:17:47 2015 UTC,"""If it compiles it works"" is hyperbole, just like saying ""there was a million people at Joe's house party.""  It's not true, but if somebody tells you that you understand that the number was large."
haskell,37tp2c,kamatsu,3,Sat May 30 23:08:55 2015 UTC,"I'm shocked that the community thinks using ""id"" or ""indexes"" to represent mutable graphs is acceptable even though it's reinventing pointers with the same level of unsafety   We do have a tendency to add a veneer of purity on top of imperative solutions and be satisfied with it instead of continuing to hunt for even more functional abstractions. The most famous example of that, as explained by Conal Elliott, is how monadic IO was considered to be such a good solution that most researchers stopped investigating other functional approaches to interaction, such as FRP. (Conal Elliott is the inventor of FRP.)  So it might very well be that the way mutable graphs are normally represented in Haskell could be made more functional, and I'd be quite interested in having a conversation about alternatives. Here are all the ways of representing graphs that I can think of, and how nodes are represented in each.   As an adjacency matrix. A node is an index, corresponding both to a row and to a column in the matrix. As a set of edges. Each edge is a pair of nodes, which can be represented using whatever representation you want. You probably want at least an Eq constraint on them in order to do anything. As a function from a node to a set of neighbours. The representation of the node is whatever the function expects as an argument. Again, you probably want an Eq constraint on that. As a map from each node to a set of neighbours. Similar to the previous representation, but makes it easier to reason about resource usage. As a lazily-constructed set of nodes, whose representation includes links to neighbours. Think of an infinite tree in which nodes which should be identical share the same memory. As an imperatively-constructed set of nodes, whose representation includes a mutable reference to a set of neighbouring nodes. Using the fgl library. The part about decomposing the graph into a node, its edges into the rest of the graph, and the rest of the graph is pretty interesting. Nodes seem to be represented as integers, but in principle I don't see why we couldn't use any of the other representations and still be able to implement such a decomposition function. They're probably using a clever representation which allows their decomposition function to be fast if you use Int.   Only number 6 is a truly mutable representation, for the rest we'd simply (and perhaps inefficiently) construct a new immutable graph by examining the previous immutable graph and replicating most of its structure. Not all of those representations require nodes to be represented as indices, but of course if you are holding a node from the previous immutable graph and you want to find its corresponding node in the new immutable graph, you're going to need something to identify them. Are those the IDs you are objecting to?  From your other comments, it sounds like you're objecting to using integers as IDs, but with most of those representations, you don't need to do that. Presumably those nodes in your graph are representing something, like game states, so you can simply use that. Or if they're really abstract entities for which you need to create a separate ID, and you're worried that you'll accidentally add 1 to one of those IDs, you can use Data.Unique, which satisfies Eq but not Num.  Anyway, I'm not trying to say that using IDs is obviously the right way to go, as I said I'm eager to have a conversation about more functional alternatives. This is just me starting off the conversation by explaining why I think IDs are needed."
haskell,37tp2c,kamatsu,4,Sat May 30 16:05:20 2015 UTC,"Maybe I've been a bit quick when saying ""Mutable graph"". What I mean is representing relations between heterogeneous objects which generally occurs when you try to represent a ""real world"", or a physical environment.  I had this problem when I start working on my warehouse application. The goal of the application is to allow interactive optimisation of a (real) warehouse made of shelves with boxes in it. Ideally the application will display all the shelves and boxes, and one can with the mouse, select a block of boxes, and move them to a set of shelves, the program will then try to find an optimum way of arranging the boxes within the given shelves. At the moment, it's 'cli interactive', I have some files describing the size and position of the shelves, a list of boxes with their dimensions and name, and a command file which take instructions like 'move all boxes with name like this regexp and move them to the shelves with name like this other regexp'.  In OOP, modelizing this is quite straight forward, a box can be in only one shelf, therefore what you need is to add a reference to a shelf in each box. I also need to be able to get quickly the list of box belonging to a shelf so I also have to maintain a list Shelf -> [Box]. This is denormalizing the data, but it's not hard to keep consistent.  A static model of that would be ok in Haskell, but the whole thing is highly mutable and such model can't be achieved in Haskell without some kind of indirection which allows you to modify an object without having to effectively modifies its referee.   The FGL methods seems OK when you build a graph from the world state, do stuff on the graph and reinject the result in the world. However it doesn't seem safe , to the use the graph as a state.  The solution I used was to create a vector of shelves another of boxes, use their position in the vector as ""key"" and wrap all of that in state that I can use in state monad. All the constructors are hidden, so object can only be created within the state monad (which add any new object to it's vector, and set it's corresponding id etc ...). It seems pretty neat, but I was suprised to encoutered problems which I haven't had since I was programming in C++.  Maybe the solution is to use STRef which I admint I'm not at all familiar with, but from all the help I get from the community, the answers where: use ids (in a map or a vector) or use a database (???)... I'm happy to carry on this conversation by other mean if needed."
haskell,37tp2c,tel,2,Sat May 30 17:02:11 2015 UTC,"I had this problem when I start working on my warehouse application. The goal of the application is to allow interactive optimisation of a (real) warehouse made of shelves with boxes in it.    Wouldn't a program for a fake warehouse and a real one be the same? ;)   A static model of that would be ok in Haskell, but the whole thing is highly mutable and such model can't be achieved in Haskell without some kind of indirection which allows you to modify an object without having to effectively modifies its referee.    Your implementation doesn't have to use mutability to represent mutability. I usually see using mutability in my implementation as a performance optimization, how is that not the case here?"
haskell,37tp2c,tel,2,Sat May 30 18:41:30 2015 UTC,"The main problem with mutability is to represent bi-directional relations. You can easily build them by ""tying the knot"" like   newBox attributes shelf = let shelf' = shelf {boxes = box:boxes }                                        in box = Box attributes shelf   The problem is there is no way to update them (how do you update the attributes of box ?). So it's not a problem of performance optimization but theoritical one."
haskell,37tp2c,tel,3,Sat May 30 23:07:45 2015 UTC,"The code in your example doesn't actually tie any knots because box = Box attributes shelf is referencing the old shelf and not the new shelf'.  So if you were to access the shelf of that box, it'll give back a shelf that doesn't in fact contain the new box!  Here's working code along the ideas of how create/modify would be done:  data Shelf = Shelf             { boxes :: [Box]            } deriving Show  data Box = Box          { attr  :: Int          , shelf :: Shelf }  instance Show Box where     show = show . attr  addBox :: Int -> Shelf -> Shelf addBox attr shelf@(Shelf xs) = let shelf' = shelf { boxes = box':xs }                                    box'   = Box attr shelf'                                in  shelf'  modifyFirstBox :: Int -> Shelf -> Shelf modifyFirstBox attr' shelf@(Shelf (box:xs)) = let shelf' = shelf { boxes = box':xs }                                                   box'   = box { attr = attr', shelf = shelf'}                                               in shelf'  foo :: Shelf foo = let empty    = Shelf []           shelf1   = addBox 1 empty           shelf12  = addBox 2 shelf1           shelf123 = addBox 3 shelf12       in modifyFirstBox 99 shelf123"
haskell,37tp2c,Vektorweg,2,Sun May 31 02:04:28 2015 UTC,"Ok, I made a typo, it should have been shelf'. However, your code may compile but doesn't work.  Let's imagine we have a valid shelf with 2 boxes. If you modify the first box, the second box still refers to the previous version of the shelf with the unmodified first box.  Without going that far, even create boxes doesn't work. In your example, you expect foo  to be equal to Shelf [Box 99 foo, Box2 foo, Box 1 foo], but in fact foo equals to Shelf [Box 99 foo, Box2 shelf 12, Box1 shelf1]. In other word, box1 thinks it has no siblings, box2 thinks it has one, etc ..."
haskell,37tp2c,tomejaguar,2,Sun May 31 07:06:43 2015 UTC,"You're right, I forgot to update all the box references!  addBox :: Int -> Shelf -> Shelf addBox attr shelf@(Shelf xs) = let shelf' = shelf { boxes = boxes' }                                    boxes' = Box attr shelf' : map (\x -> x { shelf = shelf' }) xs                                in  shelf'  modifyFirstBox :: Int -> Shelf -> Shelf modifyFirstBox attr' shelf@(Shelf (x:xs)) = let shelf' = shelf { boxes = boxes' }                                                 boxes' = map (\x -> x { shelf = shelf' }) (x { attr = attr' }:xs)                                             in shelf'"
haskell,37tp2c,simonmic,1 point,Sun May 31 13:03:05 2015 UTC,"You just update the box after it is returned from new box? Please let me know of this wouldn't work, I feel like I'm missing something."
haskell,37tp2c,tomejaguar,1 point,Sun May 31 01:23:38 2015 UTC,"The problem is , to update a box, you need to recreate a new shelf, embedding the new box. This is fine, but the problem is for everything else refering to this shelf (fox example other boxes on this shelf). You need to also update the sibling to refer to the new version of the shelf containing the new version of the box."
haskell,37tp2c,Vektorweg,1 point,Sun May 31 07:38:44 2015 UTC,This sounds like something I'd use a database for when you put it like that.  I'll look again tomorrow and test some of the updated code to try and understand better.
haskell,37tp2c,Kaidelong,1 point,Sun May 31 09:51:31 2015 UTC,"Database is a way to solve the problem indeed, but it's far from elegant. There no need of persistence here , so the database will only be used here for it's mutability. This problem can easily been solved in any OOP languages without the help of a database.  Another way to see the problem is how to represent mutable data with mutual dependency in a ""functional way""  ie (without IO , files databases etc ...)."
haskell,37tp2c,yitz,1 point,Sun May 31 10:05:41 2015 UTC,"Where does boxes come from? I tried to expand your example into working code here, maybe you can help me fix it so I can understand what you are talking about:  data Box = Box { boxAttributes :: [String]                , shelf         :: Shelf                } deriving (Eq, Show)  data Shelf = Shelf {   boxes :: [Box]   } deriving (Eq, Show)  newBox :: [String] -> Shelf -> Box newBox attributes shelf = let shelf' = shelf { boxes = ([box] ++ (boxes box)) }                               box = Box attributes shelf                           in box"
haskell,37tp2c,rdfox,1 point,Sun May 31 01:39:53 2015 UTC,"That's what I mean (however I made a type it should be box = box attributes shelf'., the problem there is creating a new box should update all the boxes to reflect the shelf changes. Ok, let's do    shelf0 = Shelf []   box1 = newBox ""box1"" shelf0   First problem, s0 is different from shelf box1 but that's ok, things are immutable in Haskell. To add a new box I need to do   shelf1 = shelf box1  box2 = newBox ""box2"" shelf1  shelf2 = shelf box2   Everything is fine ... is it ? The problem is the first box in shelf2 still referst to shelf1 and not shelf2,  so if we do   box1' = (head.tail.boxes) shelf2   shelf box1' returns shelf1 (with one box) instead of shelf2 with 2 boxes."
haskell,37tp2c,Tekmo,2,Sun May 31 07:19:52 2015 UTC,"Data.Unique   mindblown.gif  No, seriously. That is so ridiculously useful. And it's in base! How did I overlook this?  Edit: holy crap, it's also Ord on creation sequence?"
haskell,37tp2c,sambocyn,4,Sat May 30 18:33:52 2015 UTC,You often end up writing more import than code itself.   Sounds like a property you crave for in most other language.
haskell,37ulqp,fatpollo,14,Sat May 30 15:06:36 2015 UTC,"Yes in fact there is. You can use the excellent data-memocombinators.  So to memoize the collatz function, you would write something like  import Data.MemoCombinators  collatz :: Integer -> Integer collatz = integral go   where go 1 = 1             go n | n `rem` 2 == 0 = 1 + collatz (quot n 2)                     | otherwise = 1 + collatz (3 * n + 1)   Viola!  You can also do something clever with laziness since Haskell's got this sort of memoizing like aspect to how it handles computation built in. We can write an expression like 1 + 1 and it gets stored a lazy ""thunk"" which is computed once and then destructively updated to avoid recomputation. This means if we create say a vector of lazy thunks we can avoid recomputation by only calculating each entry once.  For example, here's how we'd build a vector containing all the fibonnacci numbers up to a certain point.  import qualified Data.Vector as V  fib :: Int -> Integer fib n = V.last vec   where vec = V.generate n go         go 0 = 0         go 1 = 1         go n = vec V.! (n - 1) + vec V.! (n - 2)"
haskell,37ulqp,jozefg,6,Sat May 30 15:29:41 2015 UTC,"amazing. this is truly killer. I need to learn more about what exactly where is doing, but this absolutely fits the bill.  Although, using   mfib :: Int -> Int mfib = (map sfib [0 ..] !!)     where   sfib 0 = 1             sfib 1 = 1             sfib n = mfib (n-2) + mfib (n-1)  main = print $ map mfib [1..10]   it seems like I don't even need to import a package. clearly I am just plugging and playing here and need to do a bit of studying. but thank you both (you and /u/unimpaired)"
haskell,37ulqp,sccrstud92,10,Sat May 30 15:48:17 2015 UTC,The downside to using !! and a list is that !! takes linear time. That's why he used a vector.
haskell,37ulqp,Tekmo,8,Sat May 30 17:17:43 2015 UTC,"Think of where as defining a local declaration instead of a top-level declaration.  For example, instead of writing this:  positive :: Int -> Bool positive x = x > 0  keepPositives :: [Int] -> [Int] keepPositives xs = filter positive xs   ... you could instead write:  keepPositives :: [Int] -> [Int] keepPositives xs = filter positive xs   where     positive x = x > 0   These locally scoped declarations can also reuse locally bound variables.  Here's a (contrived) example:  pairs :: [a] -> [(a, a)] pairs (x1:x2:xs) = pair:(pairs xs)   where     pair = (x1, x2) pairs _ = []   Notice how the pair declaration has access to the x1 and x2 bound variables."
haskell,37ulqp,everysinglelastname,1 point,Sat May 30 19:24:12 2015 UTC,How the heck does integral work ? Its type is Memo a so how do you apply a function (go) to it ?
haskell,37ulqp,jozefg,3,Sat May 30 21:21:01 2015 UTC,"Memo a is a type synonym for forall r. (a -> r) -> a -> r, so integral :: (Integer -> r) -> Integer -> r so we apply it to go :: Integer -> Integer and get back the right type."
haskell,37ulqp,everysinglelastname,1 point,Sat May 30 21:28:42 2015 UTC,"Funny that my mind got stuck in believing Memo was a base type when of course it's just a higher level type. Thanks! The forall thing is interesting, what happens without it ? Why don't we need forall a too ?"
haskell,37ulqp,jozefg,3,Sat May 30 21:50:08 2015 UTC,"We need to ""bind"" that type variable r, the crux of the matter is that memoization only depends on the argument and has no impact on the result type. It should work for for all result types.  We could define   type Memo a r = (a -> r) -> (a -> r)   but the only valid occupants should be of the form   foo :: Memo SomeType r   so to save some typing we just use that forall it encodes in the type itself that r must be treated polymorphically."
haskell,37ulqp,alt_account10,1 point,Sat May 30 23:37:15 2015 UTC,"type Memo a = forall r. (a -> r) -> a -> r   Takes a function (a -> r), which is go in this case (type Integer -> Integer) and an a which is an Integer (the first argument to collatz) and returns an r (which is an Integer and the return type for collatz)."
haskell,37ulqp,unimpaired,4,Sat May 30 21:36:10 2015 UTC,"As for your second question, here is a wiki article on doing memoization in Haskell. There are numerous libraries on hackage available for this as well.  Good luck."
haskell,37ulqp,yitz,3,Sat May 30 15:30:03 2015 UTC,"You are joking, right? This is an area where Haskell really shines. In fact, much of the work on Project Euler itself was actually done in Haskell by Daniel Fischer, the author of the arithmoi library.  Here is Lennart Augustsson's classic quick-and-easy primes generator in Haskell. I haven't measured it, but it's hard for me to believe that the compiled version of this wouldn't beat your python code:  primes = 2 : primes'   where     isPrime (p:ps) n = p*p > n || n `rem` p /= 0 && isPrime ps n     primes' = 3 : filter (isPrime primes') [5, 7 ..]   Here's my own slight modification of that, using a ""wheel"" to make it even faster:  primes = 2 : 3 : 5 : primes'   where     isPrime (p:ps) n = p*p > n || n `rem` p /= 0 && isPrime ps n     primes' = 7 : filter (isPrime primes') (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4])   If you want to know more about prime generation in Haskell, see the wiki page.  Others have posted about collatz elsewhere in this thread."
haskell,37ulqp,yitz,2,Sat May 30 23:47:03 2015 UTC,"Your prime sieve takes about 5 seconds to generate all the primes up to ~250k.  My python example does the first million in less than a second. I went over the wiki page, and it wasn't satisfying."
haskell,37ulqp,codygman,3,Sun May 31 00:31:22 2015 UTC,"It's not mine, and it's not a sieve. But here's the result on my computer:  real    0m0.265s user    0m0.247s sys 0m0.009s   Read the O'Neil paper about sieves that is referenced on the wiki page."
haskell,37ulqp,codygman,2,Sun May 31 02:26:03 2015 UTC,Did you compile it with GHC -O2 or are you perhaps running it in ghci?
haskell,37ulqp,yitz,1 point,Sun May 31 23:36:35 2015 UTC,"primes = 2 : 3 : 5 : primes'   where     isPrime (p:ps) n = p*p > n || n `rem` p /= 0 && isPrime ps n     primes' = 7 : filter (isPrime primes') (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4])  main = print $ take 1000000 primes   The code above is running pretty slowly for me as well. I think it might be because of show instance turning those into strings... so trying to use Text instead... however it would be nice to note to new users that trying to print each of these out with Show/String will be slow."
haskell,37ulqp,codygman,1 point,Mon Jun 1 00:18:30 2015 UTC,"No this has nothing to do with String. Make sure to run it compiled, not just dynamically loaded; it depends on GHC optimizations. Then it runs quite quickly.  Just for printing things out, String really isn't much slower than Text. It rarely makes a noticeable difference. It would be silly to bother newcomers with that complexity."
haskell,37ulqp,lpsmith,1 point,Tue Jun 2 11:15:23 2015 UTC,"I did compile it with O2 but it was still slow for me, should I file a bug report?"
haskell,37t7co,christian-marie,9,Sat May 30 04:53:47 2015 UTC,"While this is definitely good, I'd like to remind that that is another case of static smart construction, which could be abstracted over using the Lift type-class."
haskell,37t7co,nikita-volkov,5,Sat May 30 11:58:29 2015 UTC,"OK, but to me it doesn't seem that much better than  UTCTime (fromGregorian 2048 12 01) 0 UTCTime (fromGregorian 2099 01 01) 0.42324   to be worth the TH dependency."
haskell,37t7co,yitz,1 point,Sat May 30 23:18:55 2015 UTC,Or you could have this:  >>> 2048-12-01 :: UTCTime 2048-12-01 00:00:00 UTC   (I'm not saying this is a good idea.)
haskell,37s2nv,joehillen,5,Fri May 29 22:55:03 2015 UTC,"My understanding is that back when the Promises A+ spec was being debated it was frequently noted that promises form a natural monadic API and that they're going to be confusing to work with if you choose any other kind of API. To every Haskeller's chagrin, the Promises A+ spec that was eventually ratified uses something significantly more complex than a Monad.  But in the mean time this Fantasy Land project attempted to extend Haskell-like typeclass-based algebraic properties to Javascript in a canonical way that could be used by other projects.  At least that's how I understand the thing."
haskell,37s2nv,tel,4,Sat May 30 13:54:32 2015 UTC,Might as well C++ also.  I'm enjoying this ongoing series that explains category theory in Haskell and C++. The guy seems to despise C++ but he sure knows a lot about it.
haskell,37s2nv,rdfox,5,Sat May 30 20:53:01 2015 UTC,The guy seems to despise C++ but he sure knows a lot about it.   These go hand in hand. The more you know about C++ the more you know how much is wrong with it. It's a terrible language but for many use cases there's not really any viable alternative.
haskell,37s2nv,anttirt,2,Sun May 31 18:43:15 2015 UTC,I'm not quite sure what this is but it sure looks interesting!
haskell,37s2nv,codygman,2,Sat May 30 08:44:03 2015 UTC,What are these for?
haskell,37s2nv,hxr,-7,Sat May 30 09:41:03 2015 UTC,"This is just a reimplementation of Haskell APIs in JavaScript, not much to see here."
haskell,37qnhq,PM_ME_UR_OBSIDIAN,30,Fri May 29 16:57:06 2015 UTC,"lens lets us unify the notion of function composition as . in functional programming with the notion of field accessor . in imperative programming.  Along the way, it lets us generalize . to handle things that have multiple targets. Further it lets us encapsulate a nice notion of smart constructors, etc. just by dualizing some of the constructions it uses internally.  Historically, lens happened because of several factors.  I was working on a little physics engine. Along the way I needed a nice form of linear algebra. I decided to encode that using a form of representable functors in terms of lenses. It made for a nice API.  Eventually /u/acow talked me into shipping the linear algebra bits out of the physics package, and this sort of forced my hand into shipping the Lens bits separately.  Since every other lens library on the planet was taking the minimalist approach, and it was complicated to figure out what to import from where to make them go, we decided to take a ""kitchen sink"" approach based on some prodding by /u/dolio.   Having everything in one place let us iterate on the design very rapidly and along the way we found a bunch of lens-like structures that hadn't been explored previously.  As it grew the motivation for it coalesced:  What I wanted was a vocabulary for manipulating data that I could reuse in wildly different situations, where the structures existed for deep fundamental reasons, not ad hoc motivations.  We have lots of tools for manipulating data structures in Haskell: Functor, Foldable, Traversable, simple functions, etc. but they each have a different ""access pattern"". lens gives a common design to access each of these concepts.  The goal of each combinator in lens is to be a name that you can learn once and then use in very different general circumstances. Each combinator should work with as many different kinds of ""optic"" as it can -- and shouldn't demand anything more of you than what is needed in that circumstance, and for that matter the overloading shouldn't be ad hoc, it should exist for a deep fundamental reason. Where possible, you should be able to reason by analogy to combinators you know. e.g. If you want to compute something like you'd get from all from Prelude over any Fold, you can use allOf. The vocabulary you know forms a large part of the vocabulary of lens.  When we need to go beyond that, lens carefully picks names that are for the most part unlikely to conflict with names from other libraries, and filling in the cracks of Haskell's namespace with useful combinators. This enables it to all be imported at once from import Control.Lens. We try to generalize the code so it works with as many optics as possible so we can minimize the space of names we need to get the level of functionality we want, but not at the expense of discoverability.  And the ""overly"" general formulation ensures that when your problem gets a little more complicated you can still fit it into the framework and don't ever have to throw out all your code and start over like you often do with simpler libraries. Type changing assignment was added because otherwise the moment the types don't line up perfectly you have to throw out all your lens code and start over.  Ultimately what I wanted was a library for ""data access"" that I'd still be using -- and finding new ways to use -- 2 years on.  2 years on, I'm still using it, and it seems to have become rather popular as it provides a good vocabulary for doing the sorts of things that many many people have to do on a day to day basis: access xml/json, work with nested structures, deal with records, etc."
haskell,37qnhq,edwardkmett,25,Sat May 30 06:14:47 2015 UTC,"Probably the simplest problem that lens solves is updating or setting a deeply nested field.  For example, let's say that you have these data types:  data Atom = Atom { _element :: Element, _position :: Point }  data Point = Point { _x :: Double, _y :: Double }   Now, you want to increase an Atom's x position by 1.  Without lens you would have to unpack and repack every constructor along the way:  example :: Atom -> Atom example (Atom e (Point x y)) = Atom e (Point (x + 1) y)   This gets really tiresome the more deeply nested the field is because you have to keep track of a lot of unrelated fields along the way as you unpack and repack these constructors.  With lens, you can just write:  makeLenses ''Atom makeLenses ''Point  example :: Atom -> Atom example = over (position . x) (+ 1)   Also, you don't need the full-blown lens library to do this.  The lens-family-core/lens-family/lens-family-th libraries are much smaller and provide most of the functionality you need.  These are acceptable alternatives to people who balk at depending on the really large lens library just for getters and setters.  Side note: pipes is a coroutine library.  You would use it in the same places that you would use coroutines in other languages."
haskell,37qnhq,Tekmo,10,Fri May 29 17:20:47 2015 UTC,"The harmonization of this and the other answers is that Tekmo's description of lens here is where the lens idea started. In fact the literal lens library that you're referencing is a relatively latecomer to the field of lens libraries, and is a 2nd or 3rd generation refinement of the idea.  It then developed that the refinement of lens led in the direction that /u/tel is describing.  I suspect that the right way for a new person to approach lens is still to recapitulate history... start using it as an abstraction of changes in nested structures, become fluent in it, and you'll naturally begin to discover the higher-level stuff. Or, you'll discover that you don't care, in which case you may want the simpler libraries. Or you may want to start simpler with the knowledge there's an upgrade path.  (In my opinion Ed's lens library wasn't really that much harder to work with than anything else, but YMMV.)"
haskell,37qnhq,jerf,8,Fri May 29 18:42:19 2015 UTC,"I didn't mean to suggest that Edward's lens library is harder to use.  I was referring more to the larger dependency graph.  For application code it's not a big deal, but for more general-purpose libraries it helps to have a smaller dependency."
haskell,37qnhq,Tekmo,5,Fri May 29 19:03:12 2015 UTC,"One of the nicest things about the lens lens formulation is that libraries can provide lenses, traversals, and other optics without depending on the lens library at all."
haskell,37qnhq,ReinH,6,Sat May 30 17:39:21 2015 UTC,"I agree about eschewing the higher level generalizations like traversals and folds and such for a long while.   I think the theory of Isos is simple and a reasonable thing to try grasping on its own (although it may appear to lack purpose). Then the theory of Lenses and Prisms together is valuable for anyone familiar enough with ADTs to recognize the duality between products and coproducts.   From there, unfortunately, the current implementation of lens gets murky since Lens and Prism appear to be far less related than they are (compare ""pure Profucntor"" implementations). However, Traversals are a clear if unmotivated jump from Lenses and after that you ought to be familiar enough with the idea to tack on the rest of the zoo one by one."
haskell,37qnhq,tel,9,Fri May 29 19:20:32 2015 UTC,"I usually make withX functions when not using lens. For a constructor Point {x :: Int, y ::Int} I would make a function withX :: (Int -> Int) -> Point -> Point. These functions are surprisingly powerful, as you can set using withX (const 4) or increment using withX (+1). Additionally they compose like (withPosition . withX) (+1). It's just the setter part of a lens, but it's very simple and easy to work with and reason about."
haskell,37qnhq,josuf107,10,Fri May 29 21:03:15 2015 UTC,Your withX function is not that much different from how the x lens is defined.  Compare the type of withX:  withX :: (Int -> Int) -> Point -> Point   ... to the type of x:  x :: Functor f => (Int -> f Int) -> Point -> f Point   withX is just a special case of the x lens where f is the Identity functor.  All that over does is wrap and unwrap the Identity:  over lens f = runIdentity . lens (Identity . f)
haskell,37qnhq,Tekmo,7,Fri May 29 21:10:24 2015 UTC,"And I think it's worth saying:  The extra functor requirement on lenses which makes them different from what /u/josuf107 is doing is there for two reasons:   It allows you to use lenses in side-effectful contexts, such as IO, and It allows you to read from a ""setter"" function, so you can use the same lens for both reading and writing."
haskell,37qnhq,kqr,2,Sat May 30 10:01:38 2015 UTC,"For 2, the functor is Constant right? I tried one time to see why you needed rankNTypes for Lens. I thought: why not just make a Lens type parametrized on the functor? You can make a function that returns a lens parametrized on any functor, but once you use it the type of the functor gets stuck on just one type, which is mostly only a problem if you want to pass your lens around or implement a getAndSet method."
haskell,37qnhq,josuf107,3,Sat May 30 18:03:42 2015 UTC,"Actually, that is what LensLike is. Optic is a generalization of this and Optical generalizes this further."
haskell,37qnhq,Roboguy2,4,Mon Jun 1 06:15:13 2015 UTC,"this is known in some circles as the ""semantic editor combinators"" approach. these really are quite nice imo"
haskell,37qnhq,massysett,7,Sat May 30 04:25:06 2015 UTC,"lens-family is even more confusing than lens in at least one respect: there is lens-family, which exports Lens.Family2, and lens-family-core, which has Lens.Family.  What does the Family mean?  What's the 2 business?  Apparently lens-family depends on lens-family-core, so is Lens.Family2 somehow ""better""?  If so, why is there still this separate Lens.Family?"
haskell,37qnhq,michaelt_,7,Fri May 29 21:05:32 2015 UTC,"I find this really irritating too. When I'm fiddling around, I just import Lens.Simple from this primitive package https://github.com/michaelt/lens-family-simple. It does nothing but re-export the Control.Lensish complement of combinators from lens-family and lens-family-th."
haskell,37qnhq,Tekmo,8,Fri May 29 23:05:16 2015 UTC,You should upload that to Hackage!
haskell,37qnhq,michaelt_,7,Fri May 29 23:50:27 2015 UTC,"I'll blame you if anything ill comes of it, but what the heck:  http://hackage.haskell.org/package/lens-simple-0.1.0.0   It imports the haddock material from lens-family together with the combinators. Maybe this could be better arranged."
haskell,37qnhq,edwardkmett,13,Sat May 30 20:58:54 2015 UTC,"To be fair, the 2 in Lens.Family2 (and the documentation headaches of having haskell98 types that aren't compatible with the rank-n ones we really want, but which collide with the names, etc.) bothered me enough that when writing a toy physics engine I embedded my own 20 line lens library rather than use lens-family.   Eventually that grew enough that I splintered it out into a little package named lens."
haskell,37qnhq,Tekmo,4,Sat May 30 03:18:10 2015 UTC,"The difference is that lens-family-core is the Haskell 98 subset of lens-family  The name ""family"" is because lenses used to be called ""lens families"", specifically because not all four type variables could independently vary (due to the lens laws).  I don't think it's a good name for the library or the modules, but that's the origin of the name.  I also don't like the 2 in the module names, but you get used to it pretty quickly."
haskell,37qnhq,jberryman,4,Fri May 29 21:17:07 2015 UTC,"Probably the simplest problem that lens solves is updating or setting a deeply nested field   I'd reframe this slightly and say that lenses are about having an abstraction for ""updating"" and accessing bits of your data. Records suck because they're not first-class (abstraction dead end); they would still suck if they could be composed but weren't first-class.  So you start from what records do, and make a proper first class abstraction:  data Record t b = Record { get :: t -> b, set :: b -> t -> b }   Now you've got something useful. You realize you can compose the above, to get nested access and update, and many other clever things suggest themselves.  I've written several shitty lens libraries mostly to support a couple different flavors of zipper libraries. We all eventually wrote so many shitty and half-assed lens libraries exploring different corners of the (vast) space of abstractions that suggested themselves, that Edward got pissed enough and decided to spend a late-night coding session and then released lens and then it was like  http://giphy.com/gifs/reaction-loop-Aff4ryYiacUO4"
haskell,37qnhq,ForTheFunctionGod,19,Sat May 30 06:53:06 2015 UTC,"You might be interested in SPJ's talk on the lens library (signup required, but it takes 5s).  At the end of the day, the cash value of lenses isn't the theory behind them, but the degree to which they expedite the handling of data. That big-ass diagram on hackage scared me too, at first, but I can't tell you how appreciative I became of the library once I had to deal with data structures like  data Game = Game {_cells :: Map CellInd CellData, _edges :: Map. (CellInd, CellInd) EdgeData} data CellData = CD {_items :: Map ItemName Double, _agent :: Maybe Entity, _temperature :: Int} type Entity = Either PC NPC data PC = {_health :: Int, _stamina :: Int, _inventory :: Map ItemName Double, _hunger :: Float, _mind :: PCMind} data PCMind = {_messageQueue :: Queue MindMessage, _memory :: Game, _components :: Component} data MindMessage = AttackedBy EntityName | HealthDecreased Int | ItemGained ItemName Int | ... makeLenses ''Game makeLenses ''CellData ...   Now imagine writing, say, a function that goes through all cells that have PCs on them, increases the amount of gold in their inventories by 10%, and decreases their hunger by 0.1. All the packing and unpacking, and the drilling down through the fields; the pattern-matching... egregious, pointless busywork. With lenses:  f :: Game -> Game f = cells . mapped . agent . _Just . _Left %~ (inventory . ix Gold *~ 1.1) . (hunger -~ 0.1)   What goes on here:   The regular fields have an underscore in front of them (_agent), while the lenses made by makeLenses lack it. The expression is split at %~. The left part is the path you wish to take through Game, the right part the thing you want to do. %~ itself is the update-operator that applies a function. mapped is a setter that is basically fmap and selects all values of the Map as targets. _Just and _Left are prisms that go down sum types, while leaving the Nothings and Rights untouched, respectively. *~ and -~ are the lens-versions of the *= and -= operators you know from C. ix is a traversal at a specific key (Gold) which does nothing if the key is not present.   This example shows how lenses can do much more than mere setting and getting, i.e.:   setting all elements of a structure (mapped), handling sum types (_Just, _Left), only changing anything if they find the right constructor, chaining assignments ((inventory . ix Gold *~ 1.1) . (hunger +~ 0.1)), selecting elements at specific indices (ix)."
haskell,37qnhq,tejon,4,Sat May 30 00:09:22 2015 UTC,"You just gave me a big push with this example, thanks! :D"
haskell,37qnhq,tejon,2,Sat May 30 03:26:54 2015 UTC,f = cells . mapped . agent . _Just . _Left %~ (inventory . ix Gold *~ 1.1) . (hunger -~ 0.1)   Is that ever readable though? o.O
haskell,37qnhq,rdfox,14,Sat May 30 00:11:39 2015 UTC,"I've been hovering nervously at the edge of Lens for months, and holy shit, yes it is readable. This example is fantastic for me.  Let's see if I can help: first, note that cells, agent, inventory and hunger aren't part of the Lens library, they're the generated accessors matching up to records in the data  definitions above. Also, by inference, Gold is a constructor for the ItemName type.  Here's a C# equivalent of that line:  // f :: Game -> Game Game f(Game game) { // the Haskell version is point-free, but ""game"" is implied   foreach ( Cell cell in game.GetCells() )   {                                                    // cells . mapped     PC pc = cell.agent;                                // . agent     if ( pc != null && pc.entityType == Entity.PC )    // . _Just . _Left     {                                                  // %~       double gold;       if ( pc.inventory.TryGetValue(ItemName.Gold, out gold) )       {                                                // (inventory . ix Gold         pc.inventory[ItemName.Gold] = gold * 1.1;      // *~ 1.1)       }       pc.hunger -= 0.1;                                // . (hunger -~ 0.1)     }   }   // ...in reality this would return void, but for the sake of the example...   return game; }"
haskell,37qnhq,Peaker,1 point,Sat May 30 03:17:01 2015 UTC,"I'm not an expert on C# but I think they have something called Linq which fights traversal code in a way similar to Lens. Advantages of Linq over Lens (again, not an expert):   Use words that are already taken in Haskell, like all No squiggles (%~, *~, ...) just english words Data access and transformation flows in one direction -- You see the lens access flows from left to right while the transformation goes right-to-left Linq is carefully designed so you don't need to worry about operator precedence which causes me lots of problems writing Lens traversals -- I usually have to start with many parentheses and see which ones hlint tells me I can omit"
haskell,37qnhq,rdfox,3,Sat May 30 21:54:01 2015 UTC,I'm pretty sure Linq can only do a small fraction of what lens can do.
haskell,37qnhq,c_wraith,1 point,Sun May 31 13:15:00 2015 UTC,"Like I said, I'm not an expert. I've played more with ReactiveX (I think it's inspired by Linq) which is pretty tight if you're missing haskell."
haskell,37qnhq,maxigit,9,Sun May 31 13:44:40 2015 UTC,It's way more readable than the alternatives.
haskell,37qnhq,Tekmo,5,Sat May 30 00:43:53 2015 UTC,"I agree, the alternatives aren't even writable ."
haskell,37qnhq,rdfox,3,Sat May 30 07:38:10 2015 UTC,Maybe it would help to use fewer operators?  over (cells . mapped . agent . _Just . _Left)      (over (inventory . ix Gold) (* 1.1) . over hunger (subtract 0.1))
haskell,37qnhq,pinealservo,-1,Sat May 30 16:19:42 2015 UTC,It helps a lot. The squiggles are unlearnable and should be humanely deprecated.
haskell,37qnhq,Tekmo,3,Sat May 30 21:57:13 2015 UTC,"It's fine if you'd rather use words than symbols. There is definitely a learning curve involved in becoming acquainted with new symbols. But I really don't like it when people state outright things like ""squiggles are unlearnable"".  That's literally a false statement, as evidenced by the people who have learned them.  The fact that a huge portion of the human population of the world uses written languages that involves way more symbols than the English language + a few math symbols suggests that it's not that big of a deal for humans to learn a few new symbols. Sometimes, putting a bit of effort into learning new symbols for things is worthwhile. Other times, maybe it isn't. But there's nothing fundamentally unlearnable or inhumane involved."
haskell,37qnhq,_AndrewC_,2,Sun May 31 02:09:37 2015 UTC,"My rule of thumb for what symbols are beginner-friendly is that associative operators are beginner-friendly  For example, that includes (.)/(+)/(*)/(<>), but excludes ($)/(<$>)/(<*>)/(^.) and most other lens operators.  This is one reason that I'm highly in favor of the ApplicativeDo extension because then we wouldn't need to use the Applicative operators."
haskell,37qnhq,pinealservo,2,Sun May 31 13:54:52 2015 UTC,I feel that $ is usually mastered before .
haskell,37qnhq,rdfox,2,Mon Jun 1 18:56:04 2015 UTC,"I think that's probably a good rule of thumb, and I think that ""beginner-friendly"" is a good way of describing what that rule-of-thumb represents. I don't have any objections to people advocating for beginner-friendly notation, though I don't think that's the only sort of notation that's worthwhile.  In other words, I welcome new syntax that makes things beginner-friendly, but time will tell whether such things are also friendly to the experienced."
haskell,37qnhq,pinealservo,-2,Tue Jun 2 06:46:31 2015 UTC,"Sorry to take a hard line but I don't just prefer not to use infix, I prefer that you don't either if there's any chance I may read your code. But there's plenty of reasons to avoid squiggles other than making me happy:  Why bother with layout when braces and semicolons could do the same job? Line noise is beautiful to parsers but hideous to humans and we've decided in favor of humans.  Type fmap ten times fast. Now type <$> ten times fast; it's not just slower, but also awkward, distracting and even painful. Stretching your pinkie to the shift key will give you RSI sooner or later.  You know what <$> does, but do you know it's fixity? It's 4 for some reason. $ is 0 and +~ is 4 again but ++ is 5. fmap and over are 10 just like all prefix functions. Sticking to prefix, you don't have to think hard about where parentheses are needed.  Ghc is very good at detecting type errors. So good that it will usually report an incomprehensible, page-long type error when what you've really done is missed a parenthesis. Even well-accepted operators like *>, <$ and even very common ++ and >>= create chaos.  Editor's syntax-highlighters choke on squiggles like they were markdown. Double-click on ++ right now. Your mouse doesn't think its a word.  It took a while to notice all the issues, but I now I am firmly against infix squiggles. We should have learned our lesson with regular expressions. Brevity /= Clarity."
haskell,37qnhq,ephrion,7,Sun May 31 03:48:31 2015 UTC,"You're welcome to your opinions about how you should code, and even your opinions about how I should code. We all have our opinions and preferences, and I don't really have any problem with people expressing them.  What I do have a problem with is people pretending that their personal preferences and experiences are somehow logically grounded in universal fact, and that things outside their preferences couldn't possibly be valid. It's the same general kind of irrational dismissal that makes people reject Haskell and functional programming out-of-hand.  Forth, Haskell, Lisp, Smalltalk and APL (as examples I'm familiar with) all have very different varieties of syntax. They've all got advocates that repeat variations on the theme you're expressing, i.e. ""This way of doing things is the best because people are like this and not like that and we have the way that works best for all people!"".  Yes, even APL was designed as a human-centric way of expressing certain kinds of programs, and although I don't know it well and most programs look pretty incomprehensible to me, I believe the people who find it to be a very effective way for them to write programs.  I'm not saying that it's all relative and subjective; just that the factors that you're harping on are largely subjective and opinion-based in nature. I see people all the time ""finding the truth"" on some matter or other, completely rejecting their previous opinions for new ones. There could be some underlying factors that make some aspects of syntax and grammar objectively better than others in some ways, but I think we're far from a solid understanding of those factors, your personal anectdotes notwithstanding."
haskell,37qnhq,tel,3,Sun May 31 05:20:11 2015 UTC,"not (equals Brevity Clarity)  sorry, couldn't help it"
haskell,37qnhq,tel,12,Mon Jun 1 18:10:25 2015 UTC,"Also, w.r.t. pipes/conduit I wrote up an SO answer a while back on that topic: What is pipes/conduit trying to solve?"
haskell,37qnhq,tel,21,Fri May 29 17:20:50 2015 UTC,"Lens is less solving a particular problem, I feel, and more a discovery of a certain kind of pattern and then an extension of that pattern to its conclusion. This induces nearly a new kind of language entirely and if you like the pattern at the core then you like lens.  So what's this pattern? It's the notion that types can be decomposed into pieces and those decompositions themselves are first class. As a simple example, it ought to be clear that the tuple (a, b) is decomposable into the a part and the b part. If we could give a name to each of these decompositions we might call them _1 and _2 and the properties of these decompositions are that of a Lens.  _1 :: (a, b) ~> a _2 :: (a, b) ~> b   The basic properties are that lenses ought to composable  compose _1 _2 :: (a, (b, c)) ~> b   that we ought to be able to use them to pull the ""focused"" pieces out  view _1 :: (a, b) -> a   and that we ought to be able to replace the focused bit  set _1 :: x -> (x, b) -> (x, b)   (These types are not accurate and a bit mythical, but are more or less the proper intuition for the Lens' and Lens types).    So this is the core of what a Lens is. There's another form, Prism, which works on sum types (like Either) in the same way that Lens works on product types (like tuples). Then the rest can be seen as extensions of these ideas more or less as far as they can go."
haskell,37qnhq,gilmi,4,Fri May 29 17:13:18 2015 UTC,So I guess Prism is dual to Lens?
haskell,37qnhq,tel,11,Fri May 29 19:50:29 2015 UTC,"Yeah, in a sense.  It's said that Lens s a is a proof that s is isomorphic to (r, a) for some r. In other words, it's a proof of a decomposition which excises a. On the other hand, Prism s a is a proof that s is isomorphic to Either r a for some r. So Lens lets you decompose along products and Prism along coproducts.  Lens  s a ====> s ~ exists r . r * a Prism s a ====> s ~ exists r . r + a"
haskell,37qnhq,_AndrewC_,3,Fri May 29 20:14:24 2015 UTC,"why do you use ~> for _1 _2 and compose, and -> for view and set? I think I know what -> means but what does ~> mean?"
haskell,37qnhq,qZeta,5,Fri May 29 20:18:09 2015 UTC,"Here's a key   s ~> a becomes Lens s s a a or Lens' s a compose l1 l2 becomes l2 . l1   then view, set, and (->) are their standard meaning."
haskell,37qnhq,tel,2,Fri May 29 20:20:34 2015 UTC,"I liked the notation a lot, pity the actual type has four parameters otherwise it'd be great notation for lenses."
haskell,37qnhq,saudade,7,Mon Jun 1 19:01:23 2015 UTC,"Since you're asking for the goal, I guess a quote of the FAQ is appropriate:   Q: What are the goals of this project? Why does this project exist?  A: The lens library exists to provide more composable versions of the abstractions you already know how to use in Haskell. Virtually every Haskell programmer already knows how to work with functors and functions or Foldable and Traversable containers — we simply provide you with a vocabulary for composing them and working with their compositions along with specializations of these ideas to monomorphic “containers” such as Text and ByteString.  One goal of lens has been to provide a consistent vocabulary that lets you access and work with pure data of any sort, while retaining the ability to be able to reason about your code with laws."
haskell,37qnhq,sgraf812,1 point,Fri May 29 17:06:06 2015 UTC,"So this is like GoF design patterns, but for Haskell?"
haskell,37qnhq,taylorfausak,15,Fri May 29 17:06:41 2015 UTC,"There's often the idea that GoF patterns in Haskell just become first-class items directly. This is kind of the case here. One could call ""first class focusers"" a pattern... but in this case, Haskell is expressive enough to just capture this pattern directly as a type and give it a name."
haskell,37qnhq,maxigit,1 point,Fri May 29 17:19:13 2015 UTC,More a higher level of category theory but similar in concept.
haskell,37qnhq,kqr,2,Fri May 29 17:22:58 2015 UTC,"Everyone keeps pushing complicated stuff into category theory. Is this really the case here? I think lenses are rather a Haskell bred, because they make practical tradeoffs (to use . as lens composition for example)."
haskell,37qnhq,tdammers,6,Sat May 30 07:15:04 2015 UTC,"Even though there are already some great answers in this thread, I want to throw mine into the ring. A while back I wrote a blog post explaining lenses. I tried to stick to one motivating example and show all the ways to solve it. The best one-sentence explanation I can give is that ""a lens is both a getter and a setter""."
haskell,37qnhq,cunningjames,5,Fri May 29 18:04:15 2015 UTC,"In short   What problem is lens trying to solve?  The update record syntax in Haskell is a pain. To take /us/Tekmo example to do something like atom.position.x = 1 in an OO language, you'll have to do    atom { position = { x = 1 } }   which, is still alright but what if you want to do atome.position.x+=1 ?  It becomes  atom { position = { x = x ( position ( atom)) + 1 }   Things get really complicated really quickly.   How does it succeed    By allowing you to write atom.position.x+=1 as atom & position.x %~ (+1). Ok it's a bit crypting but close enough to the OOP version. Apparently you get use to it.   and how does it fail? The lens library you are talking about takes ages to compile, which wouldn't be a problem on it's own, if people were not avoid cabal hell using sandboxes. Lens+cabal sanboxes means each time you start a new project, you'll have to wait for a while before doing anything.    It makes working with nested record to easy, and some people see it as cheating ;-)  What the fuss then ? It becames an abstraction (a bit like monad) which in fact occurs to be 1000 times more powerful than just simply solving the initial problem. There are lots and lots of goodies coming with lens (you can for example traverse through collection a like in JQuery but for free and with a unified syntax)."
haskell,37qnhq,mightybyte,8,Sat May 30 08:00:18 2015 UTC,"By allowing you to write atom.position.x+=1 as atom & position.x %~ (+1). Ok it's a bit crypting but close enough to the OOP version. Apparently you get use to it.   A closer match: atom & position.x +~ 1.  Generally if you use lenses for simple access, it follows one of two patterns:   You use lenses to read/get a value:  person ^. address . city . mayor . age   This has the object you're starting from on to the left, then ^. which is the ""view"" operator, and then the thing you want to read, which in this case is the age of the mayor in the city the person lives in. You use lenses to set/update a value:  car & engine . manufacturer . budget .~ 100   This also has the object you're starting from on the left, then the ""I'm-gonna-modify-something-on-this"" operator, and then the modification taking place.  The modification itself consists of the path to the thing being modified (in this case the budget of the manufacturer of the engine), the appropriate modification operator, and then the value it's being modified by.  There are a few modification operators, but they are easy to learn:    .~ means ""set value to"" %~ means ""modify value by function"" +~ means ""add with number"" *~  means ""multiply by number""   and I think you get the idea.  What I mean to say with all this is that it isn't at all cryptic, it's just a different ""syntax"" to get used to.    Edit: And I can't nest lists with markdown. Deal with it."
haskell,37qnhq,Peaker,3,Sat May 30 10:22:12 2015 UTC,"Lenses, as a general concept, solve the problem of making record field access first-class. Without lenses, ""modifying"" a record field looks like this:  foo' = foo { someField = performModification (someField foo) }   I think we all agree that this is butt-ugly. Lenses provide some sort of mechanism that gives us a first-class thing that allows us to do this instead:  foo' = over someFieldL performModification foo   someFieldL, here, is a lens, an opaque first-class value that can be used to both modify and query its target.  Now, that's all fine and dandy, and several lens libraries existed that did more or less this; and then, along came Edward Kmett, took the idea, and ran with it, and now lens is this library that gives us not just lenses, but also folds, traversals, and a dozen other somewhat related abstractions. Kind of a ""one thing led to another"" situation, I believe. Given how these abstractions all fit together in an elegant, natural way, I would say it's a huge success; one caveat is that it depends on everything and the kitchen sink, so much that people have suggested installing just lens to pull in all the popular libraries."
haskell,37qnhq,stasiana,6,Fri May 29 23:45:40 2015 UTC,"""Lens, you're a great library. Keep on trucking -- we're behind you 100%."""
haskell,37qnhq,kqr,3,Fri May 29 17:14:18 2015 UTC,"A lens is kind of like Haskell's version of a pointer in C.  It is something that allows you to both get and set.  But the great thing about lenses is that they can compose.  So I would call them composable pointers.  Tekmo's answer gives more details about exactly how this can help you, but I like this big-picture metaphor."
haskell,37qnhq,stasiana,3,Fri May 29 18:08:58 2015 UTC,"It's like a member ptr, or a relative ptr..."
haskell,37qnhq,kqr,6,Fri May 29 20:42:19 2015 UTC,"All the comments are great descriptions of lens, but perhaps not the most straightforward. At the end of the day, lens solves a problem (dare I say, deficiency) with the Haskell language that most other languages don't exhibit. How do you access and updates fields of a record.   If record access was more convenient in Haskell, I doubt lens would exist."
haskell,37qnhq,bartavelle,6,Fri May 29 19:49:45 2015 UTC,"This problem/deficiency exists in all languages I've used, including imperative ones such as Python. It's a common misunderstanding that lenses are just the old accessor you know and love from OOP. That's far from true. Lenses are much more powerful than the regular OOP accessors.  For an example, look at this comment. As you can see, lenses allow you to succinctly and clearly communicate transformations that seem very complicated in other languages because you need a ton of nested, primitive structures to express them."
haskell,37qnhq,stasiana,0,Sat May 30 10:14:16 2015 UTC,"Yep. It's great that you can do amazing things. Just look at all the people who really dive into it and do those amazing things versus just trying to access a field.  I'm being sarcastic, of course. But, really, if we could do the equivalent of myrec.field1.field2 = x, or x = myrec.field1.field2, there would be very little motivation."
haskell,37qnhq,kqr,6,Sun May 31 01:45:13 2015 UTC,"You would have very little motivation, perhaps. I would still be strongly motivated. As I've said, I miss lenses almost on a daily basis in other imperative languages that have the OO style record access built-in.  Lenses are better for several reasons:   They are first class, which means they can be passed around as arguments and returned from functions, They are composable, to a degree ""regular OO accessors"" are not because they're built into the language, There's more freedom in how you construct them, because they are simply ordinary functions – you don't have to specify them as fields in a class They can have multiple targets They can branch based on value Their default mode of operation is in their immutable form   Obviously, if you only use lenses to do simple field updates, you'll never realise all of this, and that's understandable. Just don't mistake your level of experience with all there is to something. :)"
haskell,37qnhq,shizzy0,3,Sun May 31 05:47:34 2015 UTC,"7 - They are awesome for having very useful functions to fiddle with your data while at the same time documenting the relationship between them : Lens' Foo Bar, Prism' Foo Bar and Iso Foo Bar all have distinct meanings.  I try to do that as much as I can, and I really appreciate when a library author does too."
haskell,37qnhq,rdfox,2,Sun May 31 20:52:15 2015 UTC,"I don't disagree with the capability. And absolutely, I have very little motivation. My point is that I believe there are more people like me than people like you, who are able to enumerate all the benefits and are able to make use of the advanced features in all the software that they write.  I have little hard evidence, of course. My only anecdotal evidence comes from looking at all the packages that use lens, and witnessing that almost all of them use it exclusively for ... wait for it ... simple field access.  Feel free to point out all the other packages that I haven't looked at that you use regularly that make use of all the features you've enumerated."
haskell,37qwr0,almosthaskellr,24,Fri May 29 17:58:18 2015 UTC,checkout What I Wish I Knew When Learning Haskell by Stephen Diehl  http://dev.stephendiehl.com/hask/
haskell,37qwr0,lnxsux,4,Fri May 29 18:00:48 2015 UTC,This one is great.
haskell,37qwr0,jtra,11,Fri May 29 19:10:14 2015 UTC,"Here's another one that appears to bug quite a lot of people: Lazy I/O seems really natural and powerful for doing streaming computations, at first. Unfortunately the way that resources (think file handles for example) are acquired and released can become very tricky to manage.  It seems to be some kind of pipe dream to have somehow had lazy I/O magically give you good automatic resource management under the hood in the same way that we've come to rely on garbage collectors for automatic memory management."
haskell,37qwr0,rehno-lindeque,4,Fri May 29 21:22:24 2015 UTC,"The current idea is to use pipes or conduit, but I don't even know how that works. :)"
haskell,37qwr0,PM_ME_UR_OBSIDIAN,3,Fri May 29 23:39:47 2015 UTC,machines also looks cool. Needs more packages and docs though.
haskell,37qwr0,rehno-lindeque,2,Sat May 30 00:13:26 2015 UTC,You can read the pipes tutorial
haskell,37qwr0,Tekmo,2,Sat May 30 01:01:21 2015 UTC,best tutorial (among hackage packages) I've ever read.
haskell,37qwr0,sambocyn,6,Sun May 31 21:33:22 2015 UTC,"If/when you decide to learn, focus on pipes.  It's better documented and focuses on having composable pieces; in my experience this made it much easier to learn."
haskell,37qwr0,massysett,3,Sat May 30 02:33:06 2015 UTC,I remember seeing an argument about conduit being better at freeing resources where pipes didn't... I could be totally wrong about that ever happening though. Does anyone know if this is true or false?
haskell,37qwr0,codygman,3,Sat May 30 08:01:37 2015 UTC,No this is exactly that. The focus of conduit is efficient resource finalization. I suggest this : http://www.haskellcast.com/episode/006-gabriel-gonzalez-and-michael-snoyman-on-pipes-and-conduit/
haskell,37qwr0,bartavelle,1 point,Sat May 30 09:08:18 2015 UTC,conduit is actually used in web development though :-)
haskell,37qwr0,yitz,2,Tue Jun 2 19:48:16 2015 UTC,"Lazy IO is indeed natural and powerful. But unlike the simplistic view of it often presented to beginners, you have to understand its complexities to use it for real development work.  A basic rule of thumb is: if you have a single input-to-output stream, lazy IO is often the best approach, because it integrates most easily with fusion and produces the nicest code in that case. If you have multiple IO streams, lazy IO gets ugly very quickly when done correctly, so it is usually better to use conduit or pipes."
haskell,37qwr0,rdfox,1 point,Sun May 31 00:22:45 2015 UTC,The first time you find readFile is reading from a closed filehandle.
haskell,37qwr0,rehno-lindeque,19,Sat May 30 22:13:31 2015 UTC,"There are some functions in the Prelude that can be rather dangerous.  head, tail, read, (!!), foldl1, foldr1, maximum, minimum, toEnum   can all throw exceptions at you.  zip/zipN, zipWith/zipWithN   will not throw any exceptions, but perhaps they should! If you were expecting lists to pair up (and sadly they don't), the results can be even more catastrophic. I've been found guilty of writing bad data into our database :)  Do the right thing and ban 'em in your production code, or at least make it so they have to be imported explicitly - using safe defaults is much more appealing when the unsafe ones are a little bit inaccessible. You can find some alternatives from a couple of libraries on hackage (I personally quite enjoy some of the naming conventions used by safe )."
haskell,37qwr0,sclv,10,Fri May 29 20:22:51 2015 UTC,"Well, the zip family make sense when you want that ""result is the min length of the args"" behavior.  If you don't want that behavior, then its better to see if you can massage things into a list of pairs rather than a pair of lists beforehand, and that way you've forced the ""same length"" invariant further up in your code."
haskell,37qwr0,rehno-lindeque,3,Fri May 29 22:08:07 2015 UTC,"Ah yes, I knew this would come up. I actually thought someone would mention zipWith f [1..] as a counter example.  I personally feel that in these cases an explicit import Data.List (zip) is warranted to let everyone know that you know what you're doing, it only serves as a stumbling block for beginners by being included in the prelude."
haskell,37qwr0,bartavelle,3,Fri May 29 22:13:08 2015 UTC,I actually thought someone would mention zipWith f [1..] as a counter example.   I use zip a (tail a) all the time.
haskell,37qwr0,yitz,3,Sat May 30 09:11:10 2015 UTC,"zip <*> tail  But you really meant zip <*> drop 1, didn't you? :)"
haskell,37qwr0,ReinH,5,Sun May 31 00:25:06 2015 UTC,"Ah yes, zip'ap'tail, the Aztek god of consecutive numbers."
haskell,37qwr0,dllthomas,5,Sun May 31 06:22:50 2015 UTC,"This is what I would have put.  Also, Monoid (Map k v) should have been Monod v => Monoid (Map k v), so I can supply my own Last if that's what I want."
haskell,37qwr0,saudade,3,Sat May 30 03:34:56 2015 UTC,"I thought we weren't supposed to use the safe package?   I feel so conflicted, although I normally just do as you say and try not to use partial functions."
haskell,37qwr0,rehno-lindeque,5,Fri May 29 21:12:06 2015 UTC,I tend to import things selectively from a couple of different libraries as well as our own in order to build a convenient but safe prelude.   I suppose it depends quite a bit on whether you're talking about application code or shared library code in this context. Do you have a source for the advice against safe? I'm always keen to look at what other people are doing.
haskell,37qwr0,gfixler,4,Fri May 29 21:45:21 2015 UTC,I've been thinking about making a SafePrelude.hs that imports and reexports the safe things from the Prelude.
haskell,37qwr0,tomejaguar,4,Sat May 30 04:13:44 2015 UTC,Go for it! I'm all in favour of improving the ecosystem of preludes and letting market forces do what they will.
haskell,37qwr0,codygman,2,Sat May 30 06:30:20 2015 UTC,I thought we weren't supposed to use the safe package?    Why not? Where did you hear that? Is there something wrong with it I don't know about? I always use it.
haskell,37qwr0,yitz,2,Sat May 30 07:53:03 2015 UTC,"The safe package was a great idea in its time; it was instrumental in raising awareness about partial functions and other hidden dangers. But nowadays, the base package already has so many great combinators and type classes available based on Maybe and Either that you really don't need the safe package anymore."
haskell,37qwr0,codygman,3,Sun May 31 00:33:01 2015 UTC,So what do you use in place of headMay  or readMay? I'm not familiar with the type classes you are referring to.
haskell,37qwr0,yitz,4,Sun May 31 01:21:01 2015 UTC,"Both of those functions are available in base, under different names:  readMay = Text.Read.maybeRead  headMay = Data.Maybe.listToMaybe  Examples of type classes from base that are useful with Maybe and Either: Functor, Applicative, Monad, Monoid, Alternative, Traversable  Examples of packages beyond base I would include as dependencies for safe programming: semigroups (see especially the type for non-empty lists), either (a monad transformer for Either). Both written by /u/edwardkmett."
haskell,37qwr0,Archaeanimus,2,Sun May 31 02:20:00 2015 UTC,"zip/zipN, zipWith/zipWithN will not throw any exceptions, but perhaps they should!   Is it common practice in Haskell to throw an exception in response to a precondition violation? I feel the appropriate solution is to include the length of the list in its type (i.e., use vectors instead)."
haskell,37qwr0,rehno-lindeque,1 point,Fri May 29 22:07:45 2015 UTC,"That works well for pure code, but unfortunately side-effecting code can't tell you what the expected length of the result should be."
haskell,37qwr0,Archaeanimus,2,Fri May 29 22:09:43 2015 UTC,"Dependent types would fix that. I don't know what kind of work is being done to bring dependent typing to Haskell, though."
haskell,37qwr0,PM_ME_UR_OBSIDIAN,3,Fri May 29 22:20:57 2015 UTC,"Full-fledged dependent types are a big deal, you can't just bolt them on an existing language and expect to reap the benefits. In particular, they're not all that useful if you don't observe a separation between data and codata."
haskell,37qwr0,Archaeanimus,3,Fri May 29 23:39:08 2015 UTC,"You wouldn't be able to reap all the benefits of dependent types by bolting them on to Haskell, no, but you would get some of them. In particular, you'd at least be able to reason about the sizes of your lists at compile time. Granted, you have to do additional work when you're using colists instead of lists, but it would be workable."
haskell,37qwr0,rehno-lindeque,2,Fri May 29 23:58:38 2015 UTC,"Well, I mean, I suppose you could convert from your IO [a] to a length annotated vector:  fromList xs :: Maybe (Vect 6 a)   This doesn't really get rid of the length check, but perhaps this is what you mean after all. (Not a bad idea though, I'd consider doing that)"
haskell,37qwr0,Archaeanimus,2,Fri May 29 22:36:07 2015 UTC,"This doesn't really get rid of the length check   The idea is to enforce the length check. If zipWith has a signature like  zipWith :: (A → B → C) → Vec A n → Vec B n → Vec C n   then you're obligated to prove that the two input vectors have the same length. If you're dealing with arbitrary inputs, then you're also obligated to handle mismatched lengths outside of zipWith, and zipWith doesn't need to handle precondition violations."
haskell,37qwr0,rehno-lindeque,3,Fri May 29 22:58:23 2015 UTC,"I would be pretty stoked to write code like this in Haskell:  do     ids <- readIds     records <- readRecords ids     return (zip <$> fromList ids <*> fromList records :: Maybe (Vec (Id,Record) n))   (without knowing the exact n)"
haskell,37qwr0,ephrion,1 point,Sat May 30 00:38:57 2015 UTC,In what cases would you want zip to throw exceptions?
haskell,37qwr0,rehno-lindeque,3,Fri May 29 21:23:21 2015 UTC,"Well you might not want an exception, you may prefer Maybe. I only mean to say that even an exception can be better than the alternative.  Imagine that you have a list of ids that you want to use to fetch some records from a REST service in a single batch. However, unbeknownst to you, some of the ids are incorrect and instead of 8 objects the service returns 6 (maybe they're not so great with reporting errors). When you try to merge the 6 records in the response with your own 8 records there's a mismatch. zip only gives you 6 results and unfortunately they're not paired up correctly, but you have no way of knowing except by inspecting the results. zipExact gives you some peace of mind that at least the lists were the same length so that at a minimum there shouldn't be anything missing.  So, an exception will at least tell you that your assumption about the data lining up correctly is flawed and allow you to rewrite that piece code rather than failing silently."
haskell,37qwr0,twistier,5,Fri May 29 21:38:03 2015 UTC,"zip :: [a] -> [b] -> Maybe [(a, b)] would be a strict function, which is pretty annoying."
haskell,37qwr0,sacundim,7,Fri May 29 23:34:18 2015 UTC,"The these library comes with this data type (in Data.These):  data These a b = This a | That b | These a b   And an Align class that comes with an align operation whose list method works like this:  align :: [a] -> [b] -> [These a b] align as [] = map This as align [] bs = map That bs align (a:as) (b:bs) = These a b : align as bs   Now you can consume that list lazily, and if you ever see This or That then you know one of the original lists ran out before the other."
haskell,37qwr0,maxiepoo_,2,Sat May 30 05:07:16 2015 UTC,"Seems like you lose useful information there for lists though. I would think you would want  align :: [a] -> [b] -> ([(a,b)], Either [a] [b])   or even more precisely  align :: [a] -> [b] -> ([a,b], Maybe (Either (NEList a) (NEList b)))"
haskell,37qwr0,sacundim,2,Sat May 30 17:44:51 2015 UTC,"align :: [a] -> [b] -> ([(a,b)], Either [a] [b])   Well, the context in which I brought up These is that /u/twistier complained that a zip :: [a] -> [b] -> Maybe [(a, b)] would be strict.  Your suggested signature here partially shares that property—forcing the Either forces the whole spine of the [(a, b)].  So maybe something like this then:  data Alignment a b    = BothEmpty   | FirstEmpty (NEList b)   | SecondEmpty (NEList a)   | Aligned a b (Alignment a b)  align :: [a] -> [b] -> Alignment a b align as bs = _  strictAlign :: Alignment a b -> ([(a, b)], Either (NEList a) (NEList b)) strictAlign = _"
haskell,37qwr0,maxigit,1 point,Sat May 30 23:57:38 2015 UTC,I love this package which seems totally underrated.
haskell,37qwr0,kqr,3,Sat May 30 08:02:02 2015 UTC,"Maybe something like  zip :: [a] -> [b] -> ([(a, b)], [Either a b])   is better. Still strict if you force the snd of the pair (I don't think there's any way around that), but if you ignore it you can use it like an ordinary lazy zip."
haskell,37qwr0,ephrion,4,Sat May 30 08:22:29 2015 UTC,"There are a lot of valid use cases for zipping together lists of unequal size (eg zipping with an infinite list, pairing with a list of results, the fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) construction), and truncating to the length of the shorter list is the best case in all of these IMO. It's the only one that preserves the ability to zip against an infinite list, which is really useful.  If you're relying on some aspect of the data to indicate identity, you'd probably be better off with a Map than a list."
haskell,37qwr0,ReinH,2,Sat May 30 01:39:31 2015 UTC,"The bug here isn't in zip, it's in the incorrect list of ids. Enforcing a length invariant on zip won't guarantee anything because the lengths could happen to match up because of errors in calculating both lists. This is a case where the problem should be solved at its source rather than allowed to propagate until you lack enough information to provably solve it.  zip isn't a partial function and shouldn't be lumped in with them. It's just a function with a denotation that is sometimes not what you meant."
haskell,37qwr0,rehno-lindeque,2,Sat May 30 17:46:08 2015 UTC,"zip isn't a partial function and shouldn't be lumped in with them   It wasn't my intention to lump zip in with partial functions (or to insinuate that it's buggy), only to label it as dangerous. I could have added unsafePerformIO to the list, there are many dangerous functions that aren't partial.  It has been my experience that the worst bugs (data corruption) I've encountered over the past year could have been prevented by using zipWithExact instead of zipWith. In light of that, I don't think it's too objectionable for me to want to label zipWithExact ""safer"".   This is a case where the problem should be solved at its source rather than allowed to propagate   I 100% agree, I did end up fixing each problem I've run into at its source. However, it was only because I replaced zipWith with zipWithExact that the problems revealed themselves in the first place (after all, I didn't write buggy code on purpose, I had no idea that the issue existed there).  I suspect you wouldn't find the same invariant expressed in the type system objectionable:  do     ids <- readIds     records <- readRecords ids     return (zip <$> fromList ids <*> fromList records :: Maybe (Vec (Id,Record) n))   Unfortunately I don't have access to anything like that, so I've had to settle for zipExact instead:  do     ids <- readIds     records <- readRecords ids     return (zipExactMay ids records)"
haskell,37qwr0,ReinH,2,Sat May 30 19:39:14 2015 UTC,"I don't think zip is dangerous at all. To put it bluntly, I think you are doing dangerous things where you lose information unnecessarily, attempt to recover it in an unreliable way, and then blame zip for doing its job on the unreliable inputs you gave it. That's quite unfair on the poor function!*  In your example, the list length was never the real problem, so encoding it in the type system is not the solution. The real problem is that you throw away the Id when you get the Record. Instead, don't throw it away:  getRecord :: Id -> Maybe (Id, Record) getRecord = undefined -- whatever  getRecords :: [Id] -> [(Id, Record)] getRecords = catMaybes . fmap getRecord   Keeping the Id and the Record paired in the type of getRecord is proof that they go together. Dropping the Id and attempting to recover it later is an admission that they might not.    * I shouldn't anthropomorphize functions. They hate it when I do that."
haskell,37qwr0,rehno-lindeque,2,Sun May 31 04:13:36 2015 UTC,"The point here was that there is no getRecord because it's a batch operation. There is only a getRecords :: [Id] -> IO [Record]. But I'm happy to concede that matching up to some uniquely identifying information in the record would be preferable if something like that is available.  Perhaps it would be interesting to look into some function like  zipOn :: (a -> b -> Ordering) -> [a] -> [b] -> [(a,b)]   for situations where pairing up is indeed possible but inconvenient."
haskell,37qwr0,Guvante,2,Sun May 31 15:25:31 2015 UTC,"zipWith (+) [1..5] [6..9]   Returns [6,8,10,12] and silently fails to notify you that the second list ran out."
haskell,37qwr0,carrutstick,6,Fri May 29 21:28:28 2015 UTC,"But this is pretty convenient behavior in many cases; I'll often enumerate a list of objects with something like zip [1 ..] xs, in which case I really want zip to silently stop when it gets to the end of xs."
haskell,37qwr0,Guvante,1 point,Fri May 29 22:19:30 2015 UTC,"I don't disagree and think that a partial method wouldn't be an improvement, just saying that there are cons to the approach."
haskell,37qwr0,ephrion,4,Sat May 30 07:26:00 2015 UTC,"There are really two options:   Only allow zip to zip lists of the same length Truncate to the length of the shorter list   Of the two, the second is much more useful. The docs are pretty clear about the behavior of zip, as well."
haskell,37qwr0,Tekmo,8,Sat May 30 01:41:18 2015 UTC,Haskell records don't let you specify default values for fields
haskell,37qwr0,ephrion,12,Fri May 29 20:17:18 2015 UTC,And record namespacing. Records in general are a pain point
haskell,37qwr0,absence3,3,Fri May 29 21:29:24 2015 UTC,"Including the syntax, which prevents Haskell from being a curly-brace-free language. :("
haskell,37qwr0,Taladar,2,Fri May 29 22:01:45 2015 UTC,Do notation also allows curly braces.
haskell,37qwr0,hexbienium,2,Fri May 29 22:58:00 2015 UTC,"In fact, I believe the ordinary way of writing do blocks is syntactic sugar for the curly-brace way."
haskell,37qwr0,cghio,7,Fri May 29 23:37:49 2015 UTC,"Actually, the entire indent-sensitivity is sugar for curly braces and semi-colons.  Layout Rules in the Haskell 98 report"
haskell,37qwr0,kqr,4,Sat May 30 02:01:03 2015 UTC,Lenses get you away from some of the clumsy record syntax in Haskell.
haskell,37qwr0,Crandom,5,Sat May 30 08:25:35 2015 UTC,Can't you do this with having a record of defaults and using update syntax?
haskell,37qwr0,Tekmo,7,Fri May 29 20:25:25 2015 UTC,The problem is when only some fields are defaulted but others are not
haskell,37qwr0,sclv,3,Fri May 29 20:42:28 2015 UTC,Smart constructors to the rescue :-P
haskell,37qwr0,Tekmo,3,Fri May 29 22:08:55 2015 UTC,"I tried, this, but it's not pretty"
haskell,37qwr0,massysett,6,Fri May 29 22:09:34 2015 UTC,You're the one who convinced me that defaults wouldn't necessarily be a good idea.  After reading that I try to make my types a Monoid if possible.
haskell,37qwr0,Tekmo,3,Sat May 30 02:28:36 2015 UTC,"Now that I think about it, you're probably right.  I could make the fields use the First/Last monoid and instead provide a smart constructor that lets you instantiate any fields that are required."
haskell,37qwr0,Faucelme,7,Sat May 30 03:45:24 2015 UTC,Multi-constructor data types can have named fields in each constructor. This is horribly unsafe for fields that only exist for some constructors.
haskell,37qwr0,sambocyn,1 point,Sat May 30 01:48:15 2015 UTC,"maybe a -fwarn-record-sum-types would help. or more generally, check that each variant shares the same fields."
haskell,37qwr0,stevely,12,Sun May 31 21:38:59 2015 UTC,I don't like how lambdas and do are handled by the parser.  fmap (+1) (do return 3) -- Works fmap (+1) $ do return 3 -- Works fmap (+1) do return 3 -- Does not work flip fmap (Just 3) (\n -> n + 1) -- Works flip fmap (Just 3) $ \n -> n + 1 -- Works flip fmap (Just 3) \n -> n + 1 -- Does not work
haskell,37qwr0,yitz,3,Fri May 29 23:08:00 2015 UTC,"How would you interpret this:  f do g $ h   Or this:  f \x -> g :: Foo   Now throw some let and where clauses into the mix, each with its own indentation relative to the indentation of a do block.  You can come up with answers for all of that, but they probably won't be consistent with some of the basic rules about how Haskell syntax currently works. The trade-off is that having an intuitively consistent set of syntax rules in all cases is better than adding ad hoc rules that are slightly more convenient in certain special cases.  But everyone would be thrilled if you can prove me wrong and come up with rules that work in all those cases and are intuitively consistent with existing Haskell syntax."
haskell,37qwr0,stevely,3,Sun May 31 01:04:39 2015 UTC,f do g $ h   Would be equivalent to:  f $ do g $ h   And  f \x -> g :: Foo   Would be equivalent to:  f $ \x -> g :: Foo   Since do and \ are keywords we can then consider them to be implicitly preceded by $ when they aren't the start of an expression. That would reduce the shorthand notation I want into the already existing Haskell syntax following a simple transformation.
haskell,37qwr0,yitz,1 point,Sun May 31 05:57:22 2015 UTC,"Disclaimer: In this conversation, I am not trying to say not to do this. I would love to have it. Just pointing out that a lot more work would have to be done.  So, another issue I can think of off the top of my head:  You want the rule to be ""insert $ before those keywords"". But $ itself is not a keyword, it's a function defined much later on in an imported module. During the parsing stage it's not available. Do you want to make $ a keyword? That would be a major change to the grammar whose consequences would need to be investigated. So maybe you want to insert a magical ""virtual keyword"" that gets translated to $ during desugaring, similar to the way that do blocks get translated to an expression involving the non-keyword function >>=.  There are many dark corners of Haskell syntax. To put it mildly, we are not talking about Lisp here; it's very complex. The general rule is: any change to the fundamental syntax of Haskell, even a tiny change that seems much smaller than this one, triggers a cascade of serious problems, especially when you are touching infix operators, keywords, and the maximal munch rule. I'd would like to see what one of the Haskell syntax experts has to say about this suggestion."
haskell,37qwr0,skew,1 point,Sun May 31 21:07:02 2015 UTC,"Just follow the existing rules for what stuff ends up parsed inside a do or lambda. Without the context it's  do {g $ h}   and  \x -> (x :: Int)   So, without confusing changes to the handling of a layout block in do or the extent of a lambda, your examples have to parse like  f (do {g $ h})   and  f (\x -> (g :: Foo))"
haskell,37qwr0,bitmadness,3,Mon Jun 1 01:29:52 2015 UTC,"It makes sense that your third example shouldn't work; proceeding from left to right, it looks like your applying ""fmap (+1)"" to ""do"", which makes no sense."
haskell,37qwr0,tel,9,Sat May 30 00:37:47 2015 UTC,"But do is a keyword and in a lot of ways can be thought of as introducing a new block. Purescript, for instance, enables this syntax."
haskell,37qwr0,kqr,6,Sat May 30 03:43:02 2015 UTC,"it looks like your applying ""fmap (+1)"" to ""do"", which makes no sense.   That's precisely why it should work. If there are two possible interpretations, of which one doesn't make sense, obviously it should use the one that does make sense."
haskell,37qwr0,bitmadness,1 point,Sat May 30 08:27:31 2015 UTC,"That isn't a good principle. By that reasoning, the english phrase ""muffins puppies ate"" should parse to ""puppies ate muffins"", since everyone knows muffins can't eat puppies. The parser shouldn't simply accept the most reasonable interpretation of crappy syntax; the parentheses are and should be necessary."
haskell,37qwr0,kqr,1 point,Sun May 31 22:38:33 2015 UTC,"By that reasoning, the english phrase ""muffins puppies ate"" should parse to ""puppies ate muffins"", since everyone knows muffins can't eat puppies.   That's how I read it. ""Muffins puppies ate"" I read as ""muffins that got eaten by puppies.""  How do you read it?"
haskell,37qwr0,SrPeixinho,0,Mon Jun 1 05:25:07 2015 UTC,Found the lisper...
haskell,37qwr0,rezb1t,10,Mon Jun 1 00:09:31 2015 UTC,"Well, now I find it inconvenient to program in anything else :) Haskell has ruined quite a few of my old C codebases for me."
haskell,37qwr0,kyllo,5,Fri May 29 20:59:18 2015 UTC,Some language pragmas will break your code in weird ways. I just learned that CPP breaks multi line strings.
haskell,37qwr0,Hrothen,4,Sat May 30 00:14:58 2015 UTC,"There's actually a decent chance a library already exists for what you want to do, but good luck recognizing it."
haskell,37qwr0,PM_ME_UR_OBSIDIAN,13,Sat May 30 08:08:04 2015 UTC,"Inconveniences:   Double-think in the community. Evangelist tropes are all over the place. In particular, regardless of what anyone says, laziness isn't all that fun. Among other issues, it makes memory usage hard to get right. Lazy iterators are A+ though. Not all monad tutorials are born equal. Haskellers tend to focus on what something is rather than that it is for and what it enables. The best free monad tutorial I ever saw was a presentation at Scala Days 2014, and I don't even know Scala. Haskell is bleeding-edge. Learning resources for lazy programming are relatively sparse compared to, say, assembly programming or object-oriented programming. The design patterns are still evolving, spearheaded by /u/edwardkmett, /u/Tekmo, and a bunch of other brainy folks."
haskell,37qwr0,absence3,11,Fri May 29 21:26:49 2015 UTC,"It's not very neuanced to claim that ""regardless of what anyone says"" they're wrong and you're right. :)"
haskell,37qwr0,ForTheFunctionGod,7,Fri May 29 22:19:18 2015 UTC,"laziness isn't all that fun   Strict evaluation imbues expressions with the ""evaluation"" side-effect and hence lifts the entire program into an implicit Strict-monad. As a result, you cannot write your own control structures like iterate, map, iterateWhileM, if :: Bool -> a -> a -> a, or compose functions well. These functions alone are reason enough that I couldn't go back to Java/C#. I just... I just couldn't. I have become so lazy that I can't stand to write a loop manually any more. The very attempt makes me feel like some work-a-day peasant digging hardened soil with bare, bleeding hands, when the Garden of Eden is right next door, with bacon trees and chocolate rivers.  In addition, lazy evaluation provides easy composability: things like or = foldr (||) False, min = head . sort, or runNTimes n f = take n . map f are concise, natural implementations that re-use pre-existing functions, but you will find them prohibitively expensive in a strict language. The evaluation side-effect attached to all expressions induces unneeded, potentially non-terminating computations. Even if your language provides short-circuit semantics for operators ||, they don't propagate. Even though True || undefined = True, foldr (||) False [True, undefined] = undefined.  Lazy evaluation can interact adversely with IO, true, but it gives you a great deal of power when it comes to pure functions. If you need constant memory usage and automatic initialisation/cleanup, pipes and conduit have you covered."
haskell,37qwr0,Taladar,3,Sat May 30 11:46:25 2015 UTC,"Among other issues, it makes memory usage hard to get right.   Could you name some of the other issues. So far the space leak problems are the only real argument (as opposed to arguments about lack of familiarity,..) from the practical side of things I have heard against laziness."
haskell,37qwr0,PM_ME_UR_OBSIDIAN,0,Fri May 29 23:01:38 2015 UTC,"No way to get a decent debugger.  And arguments to lack of familiarity are real arguments, whether you like it or not. Haskell doesn't exist in a vacuum, it strongly departs from tradition, and there's a cost associated with that."
haskell,37qwr0,Taladar,11,Fri May 29 23:12:58 2015 UTC,"Tradition is also what is giving us software projects failing in major ways virtually everywhere on at least one, often several of the budget, time or scope axes. Quite frankly we need a strong departure from tradition to get this industry to a more healthy and predictable state that actually deserves the term engineering.  I would even go so far as to argue that the very ease with which some languages allow people to claim that they are programmers despite only being able to do voodoo programming and only testing the happy path is partially to blame for many of the problems in our industry.  As for a debugger, the vast majority of languages does not have  debuggers and they all work just fine without them using a mixture of print debugging, REPLs, unit (and other automated) tests, type systems, profilers,..."
haskell,37qwr0,kqr,6,Fri May 29 23:29:39 2015 UTC,"As for a debugger, the vast majority of languages does not have debuggers   Really? Of all languages I've had the misfortune of using professionally (which spans from C to Python and JavaScript in the abstraction spectrum), exactly 100% have had a good debugger. (I was initially going to say PHP was the exception, but then I looked it up and PHP does have debuggers.)  Of course, the languages I've had to use professionally are far from ""all languages"", but I fail to see how that is relevant in a thread about learning Haskell, which most people do coming from languages of the kind I've used professionally."
haskell,37qwr0,Taladar,1 point,Sat May 30 08:32:20 2015 UTC,"The point is that giving up the things that make Haskell great so Haskell can be more like traditional mainstream languages to support the crutches those require to resemble something approaching productiveness at all makes very little sense.  Haskell's primary debugging tool is reasoning, not low level inspection of what the RTS is up to at any given moment. Laziness is not the only thing standing in the way of traditional debuggers, do you want to get rid of rewrite rules, inlining, concurrency,... too just to get a tool that - outside of the languages like C that do not have a runtime system at all to provide a sensible error message on a crash - is completely unnecessary even for debugging in more traditional languages?  I have written code in many other languages before as well as administered systems with code written in a variety of others. And yet, outside of the crash use-case in C and C++, a debugger has been necessary exactly zero times and much less useful than more structured debugging approaches (e.g. reasoning which values influence the part that goes wrong, logging those values, changing the code, logging the values again, comparing what changed,...).   There was the occasional Heisenbug that disappeared when changing the code but the vast majority of those were caused by failures in the build system causing code to be linked together that should never have been linked together (e.g. using different versions of the same data structure or different prototypes for the same function). In those situations, while print style debugging did not work of course, debuggers also proved unhelpful in every single case."
haskell,37qwr0,kyllo,9,Sat May 30 14:44:44 2015 UTC,"Yes! Most programming languages lie to you and give you a false sense of how difficult programming really is to get right. And then it blows up at runtime.  Most software is just not well thought out, and a lot of languages (or compilers) let you get away with that. As /u/michaelochurch put it, ""Haskell crushes imprecision of thought."""
haskell,37qwr0,hailmattyhall,2,Sat May 30 00:13:26 2015 UTC,"Most software is just not well thought out   That seems like a gross simplification, and also not true. I would say the majority of software is well thought out - that doesn't prevent all the problems a codebase will have during it's lifetime. New features, budget constraints, time constraints all factor in to how someone decides to write their program. When someone has to make a compromise due to these things it may produce code that appears to you to be low quality, or sub-optimal, but that does not mean it wasn't thought out!  GHC isn't going to protect you from annoying customers! :P"
haskell,37qwr0,Taladar,8,Sat May 30 12:47:10 2015 UTC,"When someone has to make a compromise due to these things it may produce code that appears to you to be low quality, or sub-optimal, but that does not mean it wasn't thought out!   Actually that is exactly what such a compromise is. And Haskell does protect you from some of this by refusing to compile some variants of this (e.g. code without error checking in many cases won't compile unless you deliberately circumvent those mechanisms which takes about the same time as doing it in a more useful manner).  I believe kyllo was referring to another type of badly thought out code though, one level higher up the chain from code written for specific customers. A lot of features in programming languages themselves are not well thought out.  Take OO as an example, something that, if you believe its proponents, is the most amazing thing since sliced bread.  I am going to concentrate on the most widely adopted OO variants, the way C++, Java,... implement it.  What is an object? It is several things really   a type in a subtyping hierarchy a way to share implementations via inheritance a product of one or more other types a namespace for one or more functions one (in some languages the only) form of encapsulation   I would argue that there are many concepts here that a language that was well thought out would separate.  The subtyping often conflicts with the implementation inheritance, violating the Liskov Substitution Principle, particularly when covariance and contravariance in containers and similar Functors are taken into account (which many languages implement in fundamentally broken ways as well).  The joining of code and data in a single construct often conflicts as well, e.g. in database abstraction layers which want to generate the data part of an object but the code part should be provided by the user. In languages like Java which do not offer code outside objects at all it also leads to unnecessary complexity when introducing better abstractions like higher order functions since you need to create an object where a simple function would have been adequate.  Those languages where objects are the only form of encapsulation also suffer from an inability to provide clean, extensible interfaces to libraries as the library objects really would need more than one object in many cases which all know each other's internals but should not expose those to the outside world. Something like Haskell's modules with the ability to re-export limited parts of other module's exports is a much cleaner form of encapsulation though there are many other, in some cases more sophisticated solutions for the problem available.  The encapsulation of state along with code in OO also suffers from a major problem. Since any method can potentially change its behaviour depending on any field of the object but without providing any details on the edge cases in those changes any code using the object could also potentially change every detail of its entire behaviour depending on every bit of state in the object. In that sense the state is not encapsulated at all, or rather we encapsulate the parts that would be useful to know in testing and are left with the parts that provide problems when testing. This is even true when the object does not, in reality use most of the fields in a given method at all as we can not know that fact.  In other words OO essentially behaves as if we had a large amount of global state which influenced every bit of code in the system, making reasoning about any bit of the code and the question whether or not all edge cases of that code have been tested very hard.  There is also another problem in OO which prevents code reuse very effectively, especially among application developers. Since objects are not composable in any simple way (I would not consider e.g. manually writing wrappers for every function of an inner object in a decorator pattern simple) and since code is not separated from data often OO objects implement complex combinations of primitive features instead of separating them into separate, composable pieces which might be reused.  Another data point on the 'are mainstream languages well thought out' argument is certainly the mess most of them made of equality but I don't want to repeat the many strange and unintuitive behaviours of common languages here as there are plenty of posts about that to make my point for me.  So in summary i would argue that no, most code is not well thought out, it is not even written in languages with features that are well thought out."
haskell,37qwr0,hailmattyhall,3,Sat May 30 15:14:39 2015 UTC,"When someone has to make a compromise due to these things it may produce code that appears to you to be low quality, or sub-optimal, but that does not mean it wasn't thought out!   Actually that is exactly what such a compromise is.   I'm not quite sure I follow. So any code where a compromise has been made is not well thought out? That seems demonstrably untrue.  As for your argument on OO: I'm personally not a big fan of it and I would acknowledge that it's not great for code reuse and relies to heavily on mutating state invisibly. However I do not agree that there as much of an issue as you do.   For me, OOP is not that great of a model, but that doesn't mean the code written in it is automatically rubbish, short-sighted or doomed to fail. People have written very clean, very modular C but C doesn't have typeclasses or a HM type system or purity. C or Java or C# or any language may have features which lend themselves to code that is more difficult to understand but that doesn't automatically make the majority of the code written in those languages badly thought out.   You're going to need a much stronger argument than software is written in OOP languages to convince me the majority of software has not been thought out and has been written in a short-sighted way. The claim was very specific to software not being well thought out, not language features."
haskell,37qwr0,Taladar,2,Sat May 30 15:36:08 2015 UTC,"I'm not quite sure I follow. So any code where a compromise has been made is not well thought out? That seems demonstrably untrue.   Any  compromise made due to budget or time constraints is what I meant. Sorry, I should have included that part in the quote perhaps. If you had the budget or time to think it through and implement it properly you wouldn't have a compromise on your hands.  As for the stronger argument, that would be the current percentage of projects that fail, go over budget, under scope, over deadlines,... I mentioned in my earlier post. As well as the fact that we essentially write the same kinds of code over and over again in many projects. If it was well thought out many things (e.g. user login systems or CRUD form generators) would be reusable and written once or twice per language, not once or twice per project."
haskell,37qwr0,kyllo,1 point,Sat May 30 15:47:25 2015 UTC,"I think as a profession, software developers have not done a good enough job of selling quality. And accordingly most languages do not have good enough support for building modular, robust, refactorable systems with strong compile-time correctness guarantees, which are important for high-quality software. That is where GHC will protect you--when your annoying customer wants tons of ""minor"" changes you can be pretty confident that when implementing them you won't subtly break everything else in the process because the compiler won't let you. Meanwhile the language is also high level enough that you can deliver features timely if you know it well."
haskell,37qwr0,PM_ME_UR_OBSIDIAN,2,Sat May 30 20:27:33 2015 UTC,"I think it's interesting that most languages do not have debuggers, but most developpers use debuggers in their day-to-day work... It kind of tells you what kind of language gets used and what kind doesn't :)"
haskell,37qwr0,dllthomas,3,Fri May 29 23:35:04 2015 UTC,"I don't think it tells you much of anything - those languages that are used the most are also likely to have the most tooling targetted at them, and I think to a degree that is likely to overwhelm most other effects."
haskell,37qwr0,PM_ME_UR_OBSIDIAN,-8,Sat May 30 03:31:54 2015 UTC,"I agree to a point, but:   Weird or novel languages don't get adopted in large part because they don't work with existing tooling paradigms; /u/Talladar is full of himself and generally displeasant, I never pass an occasion to put him down a peg."
haskell,37qwr0,sambocyn,1 point,Sat May 30 03:39:24 2015 UTC,you misspelled his/her(/their) name.
haskell,37qwr0,PM_ME_UR_OBSIDIAN,2,Sun May 31 21:31:17 2015 UTC,Maybe it's better this way so he doesn't get a notification that I've mentioned him >_>
haskell,37qwr0,Taladar,-2,Mon Jun 1 05:56:07 2015 UTC,It tells you which kinds of languages are so low level and/or badly designed that you can not have a simple mental model but need to step through the execution because every little detail might potentially break and the amount of state that influences how exactly an operation occurs is so large that it is non-obvious which part of it causes the error even once you know how to reproduce the problem reliably (or often enough for testing anyway...and it is not as if debuggers are much help with the kinds of problems that occur only on every 10th run anyway).
haskell,37qwr0,PM_ME_UR_OBSIDIAN,-4,Fri May 29 23:43:21 2015 UTC,"...---,,,!!!???  Here, you dropped those."
haskell,37qwr0,yitz,-1,Fri May 29 23:46:15 2015 UTC,No way to get a decent debugger   What features do you feel are missing from Haskell debuggers?
haskell,37qwr0,maxigit,3,Sun May 31 00:48:08 2015 UTC,"I would like to be able when I set a breakpoint, to see  what are the argument of the current function.  Example   maxigit > cat deb.hs f x = let y = x+1       in y  maxigit > ghci deb.hs GHCi, version 7.8.3: http://www.haskell.org/ghc/  :? for help Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. [1 of 1] Compiling Main             ( deb.hs, interpreted ) Ok, modules loaded: Main. *Main > :break f Breakpoint 0 activated at deb.hs:(1,1)-(2,10) *Main > f (5::Int) Stopped at deb.hs:(1,1)-(2,10) _result :: a = _ [deb.hs:(1,1)-(2,10)] *Main > :list    vv 1  f x = let y = x+1 2        in y              ^^ 3 [deb.hs:(1,1)-(2,10)] *Main > y  <interactive>:5:1: Not in scope: ‘y’ [deb.hs:(1,1)-(2,10)] *Main > x  <interactive>:6:1: Not in scope: ‘x’ [deb.hs:(1,1)-(2,10)] *Main >   I would like to see what x is without having to :step twice. I'm happy to force the argument if needed."
haskell,37qwr0,everysinglelastname,1 point,Sun May 31 12:50:26 2015 UTC,Is the Scala Days presentation listed on this page ?
haskell,37qwr0,PM_ME_UR_OBSIDIAN,3,Fri May 29 22:23:34 2015 UTC,Composable application architecture with reasonably priced monads
haskell,37qwr0,yitz,1 point,Fri May 29 22:27:06 2015 UTC,"...laziness isn't all that fun. Among other issues, it makes memory usage hard to get right.   Memory usage can be hard to get right in any language. Overall, it's not harder - or easier - in Haskell. Just different. As you correctly point out elsewhere, that itself is an issue. But as Haskell becomes more widely known and techniques improve, that is becoming less of an issue. A lot of progress has been made over the past few years. I think we have definitely reached the point where the semantic expressiveness provided by laziness is worth it."
haskell,37qwr0,ben7005,3,Sun May 31 00:47:00 2015 UTC,Noob here: I have not yet come across an inconsistency in Haskell. Do they exist? What are some examples?
haskell,37qwr0,gfixler,8,Fri May 29 19:27:35 2015 UTC,"Evan Czaplicki (of Elm fame) - in a blog post or elm-lang site page I can't find now - mentioned the frustrating inconsistency of bindings in Haskell, which includes case x of foo -> bar, do ... x <- foo, let x = foo in bar, do ... let x = foo, [ x | x <- foo], patterns, guards, and probably others. He worked to reduce everything down to a single, consistent notation."
haskell,37qwr0,yitz,3,Sat May 30 04:42:03 2015 UTC,"The one you list are fine in my opinion; I'm not sure what you are saying is inconsistent. It would be great if you could come up with that link.  One thing that is inconsistent in my opinion is ""pattern guards""; it uses <- in a way which is similar to but just different enough from every other use of that symbol to make it confusing.  So I just avoid the PatternGuards extension entirely. Every Haskell program can be written just as simply and clearly without them, despite the claims in the original pattern guards paper.  EDIT: Fixed direction of '<-'"
haskell,37qwr0,heisenbug,1 point,Sun May 31 01:30:52 2015 UTC,"""pattern guards""; it uses -> in   pattern guards use <-, do you mean -XViewPatterns?"
haskell,37qwr0,yitz,1 point,Mon Jun 1 10:35:44 2015 UTC,"Thanks, fixed."
haskell,37qwr0,sambocyn,1 point,Tue Jun 2 11:09:33 2015 UTC,"link?  I prefer Haskell syntax to elm. where increases readability, pattern matching is nice, though I've been using lambdacase for concision and refactorability lately.  what's the alternative to do notation?"
haskell,37qwr0,gfixler,10,Sun May 31 21:41:06 2015 UTC,"If you really want to talk about inconsistency in Haskell, have a look at Cabal, which is a kind of inconsistency generator, mostly used for stochastic reasoning and dependency resolution through simulated annealing. It's sort of a middle-ground between the Monty Hall and Monte Carlo methods. It helps us come up with higher-order questions about our code, such as ""Why even code, when there are so many other things?"""
haskell,37qwr0,yitz,4,Sat May 30 05:03:34 2015 UTC,"With modern cabal features, and when used with modern best practices (such as always use a sandbox), ""cabal hell"" is a thing of the past. Cabal is a fantastic tool, but like anything powerful, you need to learn how to use it correctly.  Part of the problem is that documentation, and general blogs and buzz, are a bit behind the times. And part of it is people constantly trotting out old long-gone problems, sometimes even reproducing them using out-of-date and incorrect techniques, and then using them to criticize the current tool."
haskell,37qwr0,gfixler,3,Sun May 31 01:24:53 2015 UTC,"I've failed utterly over the course of days, and with help from #haskell to install vty-ui in a sandbox, and no one has yet been able to figure out why. I think Cabal Hell is still a place."
haskell,37qwr0,kfound,3,Sun May 31 03:27:46 2015 UTC,"Good grief, yes. It burns so bad that I've started to use the length of the dependency list of a package as one of its main fitness criteria. And this is with sandboxing."
haskell,37qwr0,gfixler,4,Mon Jun 1 07:17:53 2015 UTC,"I mentioned Functor -> Applicative -> Monad in another comment. At the end of [section 4.1] of Typeclassopedia, you'll find that originally there was a Pointed typeclass that sat between Functor and Applicative, and was the home to Applicative's pure. I kind of liked the consistency of each thing adding only one thing - Functor has fmap, Pointed has pure, Applicative has (<*>), and if Monad had the Applicative constraint, then return - which is exactly the same as pure - wouldn't be necessary, so Monad would really just have (>>=). The Applicative debacle also meant that we needed liftM, which for monads is just fmap, but the break in dependencies at Applicative meant we couldn't trust that fmap was implemented, so liftM was thrown in to pick up the slack, I guess. I might also say that it's an odd inconsistency to have words for some things - pure and return - but only infix operators for others - (<*>) and (>>=).  There's also the oddness of having map for lists, when fmap for the list functor is literally the same thing (defined as fmap = map). map has only been kept around for new users, so they see error messages about map, instead of about functor. It's a kind of inconsistency-from-newb-friendliness argument. It's odd to have a map just for lists, when all the other maps out there are defined via Functor's fmap.  Oh, and as for the fate of Pointed, Typeclassopedia links to this."
haskell,37qwr0,theonlycosmonaut,3,Sat May 30 04:52:02 2015 UTC,"No idea why the downvote(s). I'd also like to know. I can think of plenty of things that are imperfect (records, head) but nothing I'd really call an 'inconsistency'."
haskell,37qwr0,gfixler,2,Fri May 29 23:44:50 2015 UTC,"Until very recently, while Applicatives needed to be instances of Functors, Monads didn't need to be instance of Applicatives, even though they should have been. This inconsistency came from Applicative being brought to the language much later than Monads, after it was ""too late"" to go back and retrofit the Applicative constraint. The AMP has been accepted at last, however."
haskell,37qwr0,TheCriticalSkeptic,2,Sat May 30 04:28:32 2015 UTC,"A bunch of things spring to mind.  That there are a complete lack of tutorials. Solving new problems / learning new libraries tends to be an academic exercise. The learning curve for every new thing I implement in Haskell is much higher than the same learning curve in other languages. On the other hand, once I've learned something I like being able to reason about the code easier. Makes the pain worth it - but no less painful.  Lazy evaluation means that reasoning about logic errors is really difficult. Stepping through code with the debugger was something I gave up on after a handful of attempts. Even using trace is problematic because it's behaviour can be inconsistent. Unfortunately I found that fixing bugs is usually best done by starting over. Fortunately Haskell code is really easy to compartmentalise and hence triage.  There are performance costs to a lot of abstractions and also reasoning about performance is an entirely different exercise to an imperative language.  Unfortunately there isn't a library for absolutely everything like in say Python or Java (or even JS).  Lastly - writing imperative code can become a frustrating affair... like occasionally forgetting about mutability by default, thinking what do you mean X x' = x.set(y); is an error? How am I suppose to get a new value if set returns null? And what's with all the { ; } everywhere? Or working in a Duck Typed language and getting super annoyed that you have no idea what type anything is.  Though I have been thinking about giving Rust a go lately. I feel like it could be a good imperative language for a Haskeller to learn. Still not a fan of all the { ; } though."
haskell,37qwr0,codygman,3,Sat May 30 05:40:26 2015 UTC,"Lazy evaluation means that reasoning about logic errors is really difficult. Stepping through code with the debugger was something I gave up on after a handful of attempts.   When I get logic errors I break everything down into smaller and smaller pure functions until things are trivial and then I compose them together after verifying the pieces work.   Unfortunately there isn't a library for absolutely everything like in say Python or Java (or even JS).   I don't necessarily disagree, but can you give example of a few big ones missing for your use cases?"
haskell,37qwr0,SrPeixinho,2,Sat May 30 08:04:50 2015 UTC,When I get logic errors I break everything down into smaller and smaller pure functions until things are trivial and then I compose them together after verifying the pieces work.   Which is what we should be doing from the beginning IMO!
haskell,37qwr0,yitz,1 point,Mon Jun 1 00:15:21 2015 UTC,"Lazy evaluation means that reasoning about logic errors is really difficult. Stepping through code with the debugger was something I gave up on after a handful of attempts. Even using trace is problematic because it's behaviour can be inconsistent. Unfortunately I found that fixing bugs is usually best done by starting over.   I think that these are all just part of the fact that getting used to Haskell takes time when your brain has been trained to think imperatively.  In my opinion, reasoning about logic errors is actually easier in Haskell once you get used to it. Also, debugging logic errors in your own code gets much easier after you learn to express complex login in ways that are more natural in Haskell when you write the code.  Use more breakpoints when you ""step through code"" in the debugger. You don't really care about the exact order of all the steps; what care about is what values the function was called with, and where it was called from with those values.  To avoid inconsistent behavior with trace, make sure to trace values at a place where they would already be completely eveluated even without the trace."
haskell,37ptqx,jberryman,4,Fri May 29 13:22:08 2015 UTC,"Thanks for creating this issue! I think it's great to have more discussions on how we can improve hackage with relatively (technically) small ""look-and-feel"" changes."
haskell,37ptqx,sclv,1 point,Fri May 29 15:53:20 2015 UTC,"It'd be nice if we could have latest haddock. Just today tested new release of a package on my system, and pushed to Hackage, only to see it rendered differently. (apparently markdown syntax is not supported in the version used in Hackage)"
haskell,37q0wr,davidhq,11,Fri May 29 14:18:43 2015 UTC,"When I saw this post, I assumed it was going to be a link to the slack community I created for FP! I created functionalprogramming.slack.com. You can get an invite here: fpchat.com There are about 600 registered users with a few very active channels including Haskell, FSharp, etc. Not sure how far functionalslack is, but perhaps we should be combining these communities?"
haskell,37q0wr,FofG,5,Fri May 29 16:25:11 2015 UTC,"Yeah, this is already a thing :) You should just join fpchat"
haskell,37q0wr,tianan,1 point,Fri May 29 16:30:58 2015 UTC,"Hmm we were actually looking and this is first time I see fpchat existing... We created ours mostly for members of Elixir meetups we are organizing but then included other languages (channels)... now it's growing, it's not nearly as big as fpchat appears to be though.. not sure how to merge :/ Is there a lot of Elixir+Erlang activity in your Slack Team?"
haskell,37q0wr,FofG,1 point,Fri May 29 16:43:25 2015 UTC,"Yes, there are Elixir and Erlang channels. They're not very active."
haskell,37q0wr,FofG,-1,Fri May 29 16:59:14 2015 UTC,"We are discussing now, have some ideas... Will come back soon-ish."
haskell,37q0wr,drb226,0,Fri May 29 17:17:39 2015 UTC,"The discussion went like this: member Matt wrote to me why there are JavaScript and Scala on the list... I said because they are partly functional but he wasn't satisfied. It all went fast from there. Those two were removed and 3 new ones added. Also Matt is an Elixir developer and I showed him this thread and neither to him or other was it obvious we should stop the team in particular because you say you don't have too many Elixir developers. For now the state is that we are going to focus only on real functional languages with special focus on Elixir. Check the updated http://functionalslack.com/ page. What is you philosophy ? If for example we did finish up deleting our team and inviting the members over, would you remove Scala and JS (if you have it)? Not sure about F#, don't know yet enough about it but it probably also won't be included in our team. It's possible that we put a pointer to your group from our page (would have to be discussed) for people that want those missing languages."
haskell,37q0wr,mgwidmann,8,Fri May 29 17:31:06 2015 UTC,"Sounds like we're doing different things. My intention was just to set up a place where people could talk about whatever functional languages they wanted to. Any user can create a channel so I'm not deciding that. All I did was set the place up and the community decided the rest. I don't see the point in shutting down channels..if people don't like them, then they just mute them and that's it.  I just wanted to see if the two communities were aiming for the same thing so that it might be efficient to combine them (whatever that means), but it sounds like you guys are doing something different. Good luck with it!"
haskell,37q0wr,runT1ME,1 point,Fri May 29 18:03:19 2015 UTC,"OK :) Good luck with yours too! We think there is space for both... So to clarify we decided to only have purely functional languages to really study the core principles. JavaScript for example is not such language and is probably best discussed in http://fedsonslack.com/ or even your community .. at Becoming Functional (http://functionalslack.com) it is still welcome but not emphasized and there is no special channel... as there isn't for Scala for example... and we want to build strong Elixir presence (that's going well), there has been quite a lot of new members recently and esp. Elixir part is active.. Haskell as well, Clojure not yet so much. Elm hopefully also soon... To learn is to live, keep the λ flying! :)"
haskell,37q0wr,mgwidmann,1 point,Sat May 30 08:03:19 2015 UTC,"What criteria do you use to determine if a language is ""purely functional""?"
haskell,37q0wr,m0rphism,1 point,Sat May 30 15:25:31 2015 UTC,No state... so no methods on objects at all
haskell,37q0wr,saudade,2,Sat May 30 19:52:08 2015 UTC,"+1 This is what flips the developer's way of thinking into a completely different mindset. Once data and behavior are separate, its a whole different ballgame.  Elixir, Clojure as well as many other functional languages are not ""pure"" as they don't abide by some of the more academic definitions such as always having the same inputs always producing the same outputs (reading state or IO is typically where this rule is violated). Haskell by an academic definition is pure. So even within functional languages some are more pure than others."
haskell,37q0wr,codygman,1 point,Mon Jun 1 14:00:51 2015 UTC,"Is haskell purely functional?  It's not total, so can you even say a method is a true function?  You say no state, but what about using ST to manipulate an array for instance?  Sounds like mutation to me.  Please delete the haskell channel too."
haskell,37q0wr,Harkins,1 point,Tue Jun 2 00:50:20 2015 UTC,"The point he is trying to make, and maybe ""pure"" was the wrong word to have chosen, was to only have languages which clearly fit the functional paradigm. The purpose is not to focus on languages which have made false claims to the FP paradigm purely for buzzword or media reasons. Some FP languages fit better into the ""pure"" definition than others, and it can be debated that almost none are ""pure"". This is not the purpose.  As he stated above, examples of languages like this that I believe have attempted to make this false claim are languages like Scala (which is OO with FP tools), Javascript (a prototype langauge, OO), Swift (clearly OO, uses FP tools), ect. All of these languages have made functional claims when they clearly do not separate state from behavior, a clear dividing line between these languages and the ones at Becoming Functional.   A better rule may be to say that Becoming Functional only focuses on Functional Languages which have a clear separation of state and behavior, because this is the distinction that influences the developer's mindset the most."
haskell,37q0wr,Harkins,6,Tue Jun 2 14:10:51 2015 UTC,"Is there any information what this site provides? The second page says that it is about functional programming, but it doesn't get more specific.  edit: If anyone else wasn't familiar with Slack before: here's the feature list from the corresponding wikipedia article:   Slack offers persistent chat rooms organized by topic, as well as private groups and direct messaging.[13] All content inside Slack is searchable from one search box. Slack integrates with a large number of third-party services and supports community-built integrations. [20] Major integrations include services such as Google Drive, Dropbox, Heroku, Crashlytics, GitHub and Zendesk.[21][22]"
haskell,37q0wr,m0rphism,1 point,Fri May 29 15:14:27 2015 UTC,"It's actually a Slack community! If you haven't yet used Slack, this is a great way to start... You will see, it's special... so it kind of provides whatever the members provide... links, opinions, advice etc. So far this Slack Team is quite new, but it's growing and there are already interesting discussions... for example I'm now listening to Phoenix+Elixir podcast that one of the members posted yesterday. Someone just posted https://github.com/bitemyapp/learnhaskell in Haskell channel... it's fun(ctional) and we expect to learn faster because of this amazing Slack product and our cross-lang FP community. Come and see."
haskell,37q0wr,radix,5,Fri May 29 15:19:04 2015 UTC,I'm curious how this is/isn't better than freenode irc? Not judging but there seems a bit of overlap and i'm becoming reminded of the early 2000's again with all the chat apps everyone wants to use.  Note: never used slack so I honestly don't know what I don't know. Also at work and doing a status report so should get back to that /sigh.
haskell,37q0wr,radix,2,Fri May 29 21:17:27 2015 UTC,"Slack is just so very well thought out and it can do things IRC cannot... Works great on mobile inside dedicated app, sends you emails with missed chats etc etc. Their thought process: https://medium.com/@stewart/we-dont-sell-saddles-here-4c59524d650d"
haskell,37q0wr,thecity2,3,Fri May 29 21:21:09 2015 UTC,Slack is just so very well thought out and it can do things IRC cannot   Can you expand on both what makes Slack very well thought out and what things it can do that IRC cannot? Maybe you can get some of the IRC folk to join instead of just lurking on IRC forever ;)
haskell,37q0wr,roche,2,Sat May 30 07:44:11 2015 UTC,"Two points I said above plus: link expansion, file attachments, history, search.... there is more but these are obvious :) IRC is also useful but I think for these type of things Slack will shine in the future... of course some will always prefer to stick with IRC, some will use both (like myself) until there is still activity on IRC channels"
haskell,37q0wr,mgwidmann,1 point,Sat May 30 07:50:06 2015 UTC,"I think your signup form is broken. I filled it in, submitted, and the form reappeared, empty with no message to indicate sucesss or failure."
haskell,37p6sv,precalc,3,Fri May 29 08:40:30 2015 UTC,"At 12:18, in the definition of negate, what's happening there? Is it recursive or is that supposed to be a different negate function being applied in the body? It'd be the one on integers right, wouldn't that be a type error unless it was Prelude.negate?"
haskell,37p6sv,otherwun,4,Fri May 29 10:38:02 2015 UTC,"CReal is a synonym for Natural -> Integer. Thus, x :: Natural -> Integer and so p :: Natural.  Therefore, x p :: Integer, so negate is from the Num instance for Integer.  The types work out cause then negate (x p) :: Integer, so the lambda expression takes a Natural and gives an Integer. In other words, (\p -> negate (x p)) :: CReal, which is exactly what we want."
haskell,37p6sv,ben7005,2,Fri May 29 14:49:05 2015 UTC,"Imagine the negate definition is a part of the Num instance for CReal sequences, then it is Prelude.negate."
haskell,37p6sv,adamse,1 point,Fri May 29 12:08:13 2015 UTC,"The negate is actually from the Num instance for Integer, because CReal is a synonym for Natural -> Integer, so x p is an Integer."
haskell,37p6sv,ben7005,3,Fri May 29 14:52:16 2015 UTC,You might be interested in https://github.com/andrejbauer/marshall/tree/master/etc/haskell
haskell,37p6sv,andrejbauer,2,Fri May 29 20:27:00 2015 UTC,"In the continued fraction portion, the hom function is implemented assuming there will always be additional terms, but, in cases with a finite number of terms, you reach the end of the list before emitting anything (trivial example hom (2, 0, 0, 1) [3]). Is there a way to handle such cases?"
haskell,37p6sv,indorri,5,Fri May 29 23:28:30 2015 UTC,"You can apply a homographic transformation directly to an (extended) rational where you put the numerator and determinant in a vector. In the case of the continued fraction [3], this represents 3 / 1.  hom (2, 0, 0, 1) [3] = hom (2, 0, 0, 1) (V 3 1) = V 6 1   in general you can take a continued fraction digit and turn it into a hom (a 1 1 0) -- and then just multiply it into the hom, and there is a quick trick used at the very end to 'seal off' the hom matrix when you have no more inputs.  The 'empty list' is considered infinity.  a + 1 / (b + 1 / (c + ...)))   the way i truncate that after b is to replace c with infinity and get  a + 1 / (b + 1 / infinity) = a + 1 / b   So when you reach the end of the list you can think of this as a the 'digit' for infinity. Normally a digit matrix is (a 1 1 0) -- where the left column a/1  represents the digit, so we replace that with (1/0) to represent infinity and get the homographic transformation (1 1 0 0). this ends the chain.  Another way to see it is that  f(x) = (ax+b)/(cx+d)   is formally extended so that  f(infinity) = a / c   so you can just read off the left column when you run out of list."
haskell,37p6sv,edwardkmett,1 point,Sat May 30 03:10:19 2015 UTC,I really enjoyed your presentation. Well done! Great content too.  Thank you especially for introducing me to the term homographic.
haskell,37p6sv,nifr,1 point,Sat May 30 03:19:41 2015 UTC,"The example at 1:12 of the video is really enlightening regarding how tricky it could be to deal with IEEE float/double values. It is indeed well-known that the rounding errors can cause huge discrepancies. What's less appreciated, however, is that a given set of equations with a unique ""mathematical"" solution might have multiple ""answers"" in the IEEE-float domains. That is, not only the result will be ""off,"" each of the answers will be justifiably ""correct"" according to the IEEE-arithmetic rules.  For instance, consider the equations that arise from the equation given in the talk:       64919121  * x1 - 159018721 * x2 == 1     41869520.5 * x1 - 102558961 * x2 == 0   All of the following vector of doubles satisfy this set of equations:    [ (1.1581392894750983e8, 4.728083850472418e7)   , (1.2562087301819216e8, 5.128450665625496e7)   , (7.393760013829726e7 , 3.018489885746054e7)   , (1.0446243456263283e8, 4.264661032788801e7)   , (5.41916533986978e7  , 2.2123649857428566e7)   , (1.2538823257918504e8, 5.1189531594737545e7)   ]   And these are by no means the only double-values that do so, there's plenty more!  Treating IEEE-float/double values as mathematical numbers is a fallacy; one that is widely known yet remains surprising even one is aware of the fallacy. One advantage of them, of course, is that they are extremely fast to work with as most CPUs provide custom hardware to compute with them."
haskell,37mvux,drb226,23,Thu May 28 20:13:14 2015 UTC,"You are working with an overlapping instance. Expect pain in that direction and don't do it.   instance (FromJSON a, FromJSON b) => FromJSON (a,b)   overlaps your   data Foo = Foo String  data Bar = Bar String  instance FromJSON (Foo, Bar)   When GHC tries to resolve an instance it ONLY looks at their heads, it doesn't try to see if the classes in the body are satisfied, so it sees that it needs FromJSON (x,y) and it can break it apart using the first instance into (FromJSON x, FromJSON y) which are simpler instance constraints and proceeds by induction. Now it gets stuck you don't have FromJSON Foo or FromJSON Bar.  Without OverlappingInstances on, this would be the end of the story. Your instance would be disallowed by the existing instance and the process would be unambiguous.  However, with OverlappingInstances on, you force GHC to do a more painful check, it has to look for ""the most specific match"", in which case the (Foo, Bar) instance can be found if both x ~ Foo and y ~ Bar are found, but then it can't refine any product (x,y) using the former instance ever unless they are both known, so OverlappingInstances lets this proceed at the expense of screwing over every other use of the class in your code.  Sadly, you aren't responsible for OverlappingInstances here, Aeson is. https://hackage.haskell.org/package/aeson-0.9.0.1/docs/src/Data-Aeson-Types-Instances.html turns it on for the instance you overlap.  He may have good reason, but it rather damages inference for Aeson.  It'd be better for you to define your own wrapper type and put it on and take it off:  data FooBar = FooBar Foo Bar instance FromJSON FooBar where ...   Now you have no overlap and life is good."
haskell,37mvux,edwardkmett,6,Fri May 29 03:59:11 2015 UTC,"Indeed, defining my own wrapper type is exactly what I did to fix the issue."
haskell,37mvux,bos,3,Fri May 29 04:06:40 2015 UTC,"If you've got a good suggestion of how to work around the need for OverlappingInstances, I'm all ears.  The main cases I know of are:   ToJSON a => [a] [Char] Foldable t => t a IntSet"
haskell,37mvux,edwardkmett,3,Fri May 29 17:06:42 2015 UTC,"The Foldable t => t a is the only one of those you can't redeem, but it could be turned into a default signature or something.  The others are fixable with tricks like we use with Show."
haskell,37mvux,sambocyn,1 point,Fri May 29 21:51:46 2015 UTC,"btw, where is IncoherentInstances used? (in https://hackage.haskell.org/package/aeson-0.9.0.1/src/Data/Aeson/Types/Instances.hs)"
haskell,37mvux,michaelt_,6,Sun May 31 00:18:10 2015 UTC,"It compiles with a signature  let (foo,bar) = case eitherDecode sampleJson of        Right fb -> fb  :: (Foo,Bar)        Left e -> error e   I take it you noticed that   instance [incoherent] (FromJSON a, FromJSON b) => FromJSON (a, b)   is already present. This is the instance it is thinking of in the error message."
haskell,37mvux,chrisdoner,3,Fri May 29 00:52:09 2015 UTC,"Yes, I did notice that. I don't know why it selected that instance, though, nor did I realize that instance was [incoherent].  I still don't understand why that instance is [incoherent]. I see that the source file is marked with the IncoherentInstances pragma, among others, but... why?"
haskell,37m7q7,redneb8888,11,Thu May 28 17:23:27 2015 UTC,"So how do you use this? You need a complete musl based environment. There a few musl based distros, albeit most of them are geared towards embedded applications. I personally use the experimental musl based gentoo image which feels more like a regular distro. You can use it with chroot, lxc, or systemd-nspawn. Here are some quick and dirty instructions on how to do this:  CHROOT_PATH=/var/tmp/gentoo-musl cd /var/tmp wget http://distfiles.gentoo.org/experimental/amd64/musl/stage3-amd64-musl-vanilla-20150405.tar.bz2 mkdir ""$CHROOT_PATH"" tar xjf stage3-amd64-musl-vanilla-20150405.tar.bz2 -C ""$CHROOT_PATH"" for x in dev proc sys; do mount --bind /$x ""$CHROOT_PATH/$x""; done cp -L /etc/resolv.conf ""$CHROOT_PATH/etc"" chroot ""$CHROOT_PATH"" /bin/bash -l PS1=""(chroot) $PS1"" # fetch the gentoo package db for the first time (slow): emerge-webrsync # enable static libraries (*.a), which are disabled by default: sed -ie 's/USE=""/USE=""static-libs /' /etc/portage/make.conf # reinstall/recompile gmp so that we have its static libs: emerge --oneshot dev-libs/gmp # install ghc: tar xJf /path/to/ghc-7.10.1-x86_64-unknown-linux-musl.tar.xz -C /tmp cd /tmp/ghc-7.10.1; ./configure --prefix=/opt/ghc-7.10.1; make install # compile a hello world: cd /tmp echo 'main = putStrLn ""Hello world""' > test.hs /opt/ghc-7.10.1/bin/ghc --make -O -optl-static test.hs ./test file ./test   Of course, using chroot this way is insecure, don't use to install packages from hackage."
haskell,37m7q7,saudade,3,Thu May 28 17:25:32 2015 UTC,"Awesome work, any chance you can post your steps to build? I want to get myself an alpine linux install with a musl libc ghc but its... not fun sadly.  Also shouldn't the binaries run on glibc systems as well as long as the kernel is 2.6.19ish+? If there are no shared libraries in the executable I would presume the binaries should be able to run fine no?"
haskell,37m7q7,saudade,3,Thu May 28 18:51:01 2015 UTC,"To produce these binaries, I followed the GHC cross-compiling guide all the way to stage 2. I did this in a glibc system. Then I took the resulting binaries and installed them in a musl based system and I recompiled GHC there (i.e. regular compilation, no cross-compiling) which went exceptionally smoothly. What I got from that step is what I posted here.  If you want GHC on alpine, my binaries should just work. If you want to compile it yourself, just use my binaries to bootstrap it, it should be as easy as ./compile && make && make install. If on the other hand you try to cross-compile it from scratch, it will be much more work.  As for running these binaries on a glibc based system, they won't run out of the box as they depend on the musl dynamic linker (namely /lib/ld-musl-x86_64.so.1). You might try to install the musl package that some mainstream glibc distros offer (e.g. debian), but I don't think that makes much sense; if you would then compile even a trivial program, ghc would try to link it against your system's libgmp.so, which in turn would depend on /lib64/ld-linux-x86-64.so.2 and glibc's libc.so.6. If fact, the ghc binary itself would have the same problem, as it depends on libgmp.so.10."
haskell,37m7q7,frolvlad,2,Thu May 28 19:16:12 2015 UTC,"Woo, well it does work in alpine, and also, no ld linking needed. I thought something is up because I've built static binaries from ghc before.  And to prove my work, my Dockerfile I used, you'll need to update the curl bit, its to an internal http server.  To be certain I copied it to an ubuntu 12.04 vagrant image and ran it there.  https://gist.github.com/mitchty/b6dcc2b919249637b365  BOOM, time to build ghc for alpine linux. That same trick should work for your gentoo stuff. I haven't tested it much, caveat emptor etc...  Sizes: 2.8M unstripped, 988.0K stripped."
haskell,37m7q7,saudade,1 point,Fri May 29 02:22:57 2015 UTC,"Hey, could you consider creating Alpine package for it? https://bugs.alpinelinux.org/issues/4257"
haskell,37m7q7,saudade,2,Thu Jun 4 08:59:41 2015 UTC,I started down that path but trying to build cabal with this release ran into issues with dynamic linking and building cabal and ghc ffi not being built with -fPIC. I hadn't looked into it much further than that but I did start down the path of cross compiling. I have a vagrant file I am testing with to get to that point but hit a few issues and got sidetracked.  Its definitely on my list though! Never submitted a alpine package so not sure how they handle a build such as this where it will require itself to build (or a temporary build of it somehow).  At work atm but will look again tonight and post a repo of my vagrantfile/dockerfiles if anyone wants to help out. I'm new at cross compiling ghc.
haskell,37m7q7,frolvlad,2,Thu Jun 4 17:52:39 2015 UTC,"Ok, I think i've got this working finally. Going to run through all my docker files and make 100% sure.  But I now have at least a ghc apk and am working on a cabal, happy, and alex apk as well.  I'm going to note, this is not a perfect port, for some reason the linker wants to treat executables as libraries which requires a few settings file edits. I'm going to look into if thats just a bug in ghc or whatever later but it does work and seems to compile ghc itself, as well as everything i've thrown at it so far. Which admittedly isn't much, but its a start.  Turns out the binaries here exhibit the same behavior so I'm thinking it might be a musl libc bit but I've no real proof of that.  Not getting a lot of traction on irc or on the bug tracker for this though, guess I'll try the mailing lists.  But here's the ghc compiled with llvm 3.5 on alpine linux 3.1 (3.2 has llvm 3.6 which 7.10.1 can't work with, not sure how to handle that bit yet tbh).  https://gist.github.com/mitchty/e6348c540e9861a9cc74"
haskell,37m7q7,saudade,1 point,Fri Jun 12 03:57:26 2015 UTC,"I'm sorry, I didn't get any notification from reddit, so I missed your replies.  This is awesome progress!  I've talked to ahills (the guy from IRC, who was willing to start working on the packaging), but he was travelling, may be you could try to rich him directly. I'm a bit busy with my several projects and ghc was just a look into a future, so I cannot really dedicate time to it at this point.  Thank you for your great work!"
haskell,37m7q7,eegreg,1 point,Wed Jun 24 12:19:42 2015 UTC,"No worries, so I talked to ahills a bit and part of the reason I just stuck my nose to the grindstone is I wanted apk packages enough.  So the apks I posted work, though they're all built without aslr aka with -nopie.  I might have a fix for the pie bits, ghc is compiling now. I'll test it later today and if its fine I'll go push up a new release version without the settings file hack. But if that works too then the last hitch that was brought up to getting ghc in should be gone.  I also need to file a bug about PIC support in ghc if so. :)"
haskell,37m7q7,semanticistZombie,7,Wed Jun 24 17:23:05 2015 UTC,"Thanks, this would be very useful for distributing Haskell programs! A good way to distribute this with a build environment that it is known to work in would be to distribute the musl environment as a docker container: this probably already exists actually. You could have an image on top of that specialized for building GHC itself."
haskell,37m7q7,aseipp,7,Thu May 28 18:59:29 2015 UTC,"in many cases the resulting binary will require to be executed in a system that has the exact same version of glibc as the one that was used to compiled it. In essence, static binaries linked with glibc are oftentimes less portable than dynamic ones.   I don't understand how is this possible. The whole point of static linking is to remove dynamic dependency, right? Why would you still need glibc at all if you're statically linking it?"
haskell,37m7q7,codygman,13,Thu May 28 21:10:10 2015 UTC,"It's a little more complicated than that. glibc has certain function calls which cause dynamic libraries to be loaded, for things like iconv or NSS - glibc NSS includes getpwuid for example, which needs to load pam_unix.so at runtime for account information.  Your application is built with glibc X.Y, statically. You give it to a customer. It calls getpwuid, which causes your (statically linked) copy of glibc to issue a dlopen of pam_unix.so, bringing it into the executable address space. But their distro is different, and the pam_unix.so that is found by dlopen() on their system was built dynamically against glibc X.Y-1. And your application goes boom."
haskell,37m7q7,codygman,10,Thu May 28 22:02:53 2015 UTC,Because glibc doesn't actually support static linking.  They declared it isn't important so they won't bother.  That's one of the reasons alternative libc's like musl have become so popular.
haskell,37m7q7,aseipp,5,Fri May 29 02:14:48 2015 UTC,"This is a well known issue. For example, many times ld gives warnings like this:  warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking   IIRC this also happens with other system calls, not just dlopen(e.g. I think getpwuid has the same issue)."
haskell,37m7q7,Taladar,3,Thu May 28 21:51:48 2015 UTC,"Thanks! I was trying to make binaries portable between nix and Ubuntu a while back, should using musl work?"
haskell,37m7q7,tomberek,3,Fri May 29 00:30:25 2015 UTC,"In theory, statically (i.e. with -optl-static) linked binaries generated by this compiler should be portable. In practice I don't know how well this would work, I have only done some minimal testing."
haskell,37lqxf,edwardkmett,52,Thu May 28 15:26:21 2015 UTC,what the fuck am I reading
haskell,37lqxf,PM_ME_UR_OBSIDIAN,28,Thu May 28 15:57:30 2015 UTC,"I took the definition of a machine that provides one output for every input, then I applied a bit of theory to allow it to memoize intermediate results, showed that this lets it exploit smarter folds, and that if we tweak the machinery used it inspires a way to find machines that return multiple outputs given an input, but which get crippled by their lack of state, then show that these are just a poor man's approximation of a Fold.  In practical terms such machines arise a lot in code and this lets me make them faster."
haskell,37lqxf,imz,5,Thu May 28 23:10:29 2015 UTC,"And what are the advantages of the Machines over Folds? Any reason to prefer not to program Folds, but such machines?"
haskell,37lqxf,tailcalled,3,Fri May 29 08:20:44 2015 UTC,"They are isomorphic, but the post implements a caching trick that under some circumstances might give you a speedup."
haskell,37lqxf,imz,4,Fri May 29 11:10:10 2015 UTC,"May I ask about a clarification about the ""circumstances""? (The post is still difficult for me to read and understand the essence.)  Am I correct assuming that caching in folds (let's imagine it as fold xs) can be useful only if there are repetitions of s <> x (for some s and x) during the fold, i.e., repetitions of the states during the fold? So, if <> is ""monotonic"" (not possible that x0 == x0 <> x1 <> ... <> xn, where x1 /= mempty and so on), then this technique is not useful.  Or it has some other uses?  Another thing I can imagine is doing a fold of a slightly modified (or parameterized) data, so that the computations from the previous fold of the initial data could be re-used."
haskell,37lqxf,tailcalled,3,Fri May 29 12:39:54 2015 UTC,"So, if <> is ""monotonic"" (not possible that x0 == x0 <> x1 <> ... <> xn, where x1 /= mempty and so on), then this technique is not useful.   Correct.  The main usecase here is for something like a DFA that you want to recognize in parallel, which was the idea in Piponi's original post as well, but now we can handle infinite automata as well, and the notion of a Moore machine more closely gets tied back to the classic definition this way."
haskell,37lqxf,tailcalled,2,Fri May 29 22:29:14 2015 UTC,"I don't know the exact requirements, as it's kinda tricky to keep all of these abstraction in my head at the same time.  However, there is an example in the article: you can use this to (sometimes) read compressed data in time proportional to the compressed size, rather than the uncompressed size."
haskell,37lqxf,gfixler,3,Fri May 29 17:50:21 2015 UTC,"Technically I show that a transducer is like a fold, and that a transducer is 'inspired' by the notion of a Moore machine where we've switched the internals to use an adjunction. When we switch to the one contravariant adjunction we have on Hask then we get a transducer. This is ""different"" than the Moore machine.   A Moore machine takes one input and gives one output at a time, but can ""remember"" something.  A transducer takes one input and gives several outputs, but is effectively memoryless."
haskell,37lqxf,tel,1 point,Fri May 29 22:27:08 2015 UTC,"Technically I show that a transducer is like a fold   You also showed the caching stuff, though, right? Or am I completely confused?   Due to the Representable ((->) x) instance no power is lost, but now some choices of k might be suitable for memoization, acting as a trie to hold onto the results rather than recomputing them each time they are asked."
haskell,37lqxf,Crandom,1 point,Sat May 30 17:59:11 2015 UTC,Yeah that was in there too. =)
haskell,37lqxf,tel,9,Sat May 30 23:05:10 2015 UTC,Stay on the road. Keep clear of the Moores.
haskell,37lqxf,vincentrevelations,8,Thu May 28 16:30:18 2015 UTC,"Through a series of categorically inspired abstractions and specializations Ed demonstrates how Moore machines, Clojure's ""transducers"", lists, and lens Folds all capture a similar structure."
haskell,37lqxf,Tekmo,1 point,Thu May 28 22:39:12 2015 UTC,So we can actually represent transducers in haskell? The claim that it was untypable by that clojure guy always seemed odd to me.
haskell,37lqxf,vincentrevelations,6,Fri May 29 02:14:21 2015 UTC,"Kind of depends. That's why I left them in quotes. It always felt like transducers were some kind of special blend of stream transformers, a weird core of mutability inherited from Clojure, and state machines. Replicating them exactly might be hard merely in finding the exactly blend that is entailed. Especially given the implied typing design which is supposedly essential to include and the desire to have early termination ""without either"", both of which feel a little less than completely solid."
haskell,37lqxf,beerdude26,5,Fri May 29 02:22:31 2015 UTC,"In Haskell we'd basically build different types for the different ""untypeable"" cases they describe as one thing.  The common case is the one I described there in the post."
haskell,37lqxf,tailcalled,2,Fri May 29 05:41:00 2015 UTC,"You can't have transducers in Haskell because the definition Clojure Guy gives builds on Clojure's syntax, and not on its functionality. I suppose it's kind of like how Haskell doesn't have C-style switch-case because case-of doesn't have breaks."
haskell,37lqxf,tailcalled,2,Fri May 29 17:50:48 2015 UTC,"We do have breaks, but they are implemented within the language by just using EitherT/ExceptT"
haskell,37lqxf,tailcalled,5,Fri May 29 19:18:01 2015 UTC,"I mean something like   switch foo {   case 1:      print(""hello "");   case 2:     print(""world"");     break;   which will print ""hello world"" when foo == 1. Silly example, I know."
haskell,37lqxf,tailcalled,3,Fri May 29 19:37:30 2015 UTC,The great thing is that you'll always find something like this. I find it inspiring.
haskell,37lqxf,tailcalled,5,Thu May 28 21:51:47 2015 UTC,"Moore :: (f -| g) => f (g b) -> (a -> g (f ())) -> Moore a b    Actually, that makes me wonder, suppose we have an adjunction f -| g with f : Hask -> C. This generates a monad m = g . f and a comonad w = f . g. Is there some natural structure that relates m and w, if ""you don't know"" f and g?"
haskell,37lqxf,sccrstud92,7,Thu May 28 17:09:26 2015 UTC,Yep.   newtype Co w a = Co { runCo :: forall r. w (a -> r) -> r }   lets you take such a comonad and twist it into a monad.  Co (Store s) ~ State s Co (Coreader e) ~ Reader e Co (Cowriter e) ~ Writer e   etc.  This is the (right) Kan lift of Identity along w.  You can also build a monad transformer from any comonad.   newtype CoT w m a = Co { runCo :: forall r. w (a -> m r) -> m r }   I use this tool to try to quickly figure out what monad is related to a comonad quite a bit. =)  I wrote up a couple of posts on this topic a few years back.
haskell,37lqxf,tailcalled,2,Thu May 28 23:31:56 2015 UTC,"Yes, I know, but is there one that works when C != Hask?"
haskell,37lqxf,PM_ME_UR_OBSIDIAN,6,Thu May 28 23:39:07 2015 UTC,"Technically that above construction didn't care where your adjunction went through. The adjunctions that give rise to Reader and Writer go through the Kleisli or Eilenberg-Moore categories, not Hask, but it builds a ""related"" monad in Hask."
haskell,37lqxf,tailcalled,1 point,Thu May 28 23:44:26 2015 UTC,"Suppose we take the diagonal functor and the product functor. You need to do some rejiggering to make it work in Haskell, but let's pretend Haskell had product kinds. Can a structure similar to Co still help?"
haskell,37lqxf,tailcalled,3,Thu May 28 23:57:56 2015 UTC,"but let's pretend Haskell had product kinds   It does though.  kind (*,*) works just fine. It doesn't give you the eta-rules needed to work with it nicely, but meh.  You can round trip out to (Hask,Hask) with   Diag :: Hask -> Hask*Hask (,) :: Hask*Hask -> Hask   (,) is usually presented with a curried kind. We'll 'uncurry' it for discussion here. We could make this more exact by using Bi (,) from semigroupoid-extras, but it gets messier.   Diag a -> b*c = (a -> b, a -> c)   a  ->  (b,c)   so this adjunction says (a -> b, a -> c) is isomorphic to a -> (b,c), which is the definition of the product.  So now let's compose them, as (,) . Diag should be a monad after all.  data Pair a = Pair a a   the arrows are the expected diagonalization monad.  Pair is a right adjoint. Pair is representable. It is represented by Bool.  Why?  Because on the other side of the diagonal functor you get  Either -| Diag  and we just compose two right adjoints, and we can compose to the two left adjoints to get its left adjoint.  and by a similar argument to how we get the right adjoint in the Hask code, we get that Either () () represents Pair.  Co Pair a = forall r. Pair (a -> r) -> r   can when applied to get Co Pair () can choose either  false (Pair a _) = a () true (Pair _ a) = b ()   and if it isn't wrapped around (), it can manipulate 'a' with knowledge of this boolean. It is effectively the pair (Bool, a) that we'd expect of a left adjoint in Hask It has to hold one 'a', and something else.  The pair of continuations implicitly represents that boolean. If you curry out the definition by breaking up the type constructor then you get precisely a Church-encoded boolean."
haskell,37lqxf,dogodel,1 point,Fri May 29 03:42:04 2015 UTC,"This isn't quite what I wanted. See, the adjunction generates a monad Pair :: Hask -> Hask, but it also generates a comonad PairW :: (Hask, Hask) -> (Hask, Hask), and what I'm asking is whether there is a natural structure that relates Pair to PairW."
haskell,37lqxf,tailcalled,1 point,Fri May 29 09:00:54 2015 UTC,"There I don't know of a general construction. The problem is ultimately that the adjunction isn't unique. I don't know what category the adjunction you ""intended"" went through. Lots of adjunctions give the same monad / comonad."
haskell,37lqxf,PM_ME_UR_OBSIDIAN,1 point,Sat May 30 05:14:11 2015 UTC,"The thing is that we could have a multi-parameter typeclass relating the monad and the comonad. In that case, the category the adjunction went through is uniquely determined by the kinds of the monad and the comonad."
haskell,37lqxf,tailcalled,5,Sat May 30 17:54:43 2015 UTC,"I have read a lot of the definitions of what adjointness means when talking about functors, but I still don't have an intuition for it. Based on the fact that they map between categories in opposite directions, my natural guess is that they have some type of inverse relationship, but idk if that's right (maybe inverse when composed in one order, but not in the other order? like the free functor and the forgetful functor)."
haskell,37lqxf,tel,8,Thu May 28 16:06:46 2015 UTC,"I tend to think of it as ""almost inverse"". For instance, consider function types (->) a. Apply it to some type b and you get a -> b. Using that type, how can you get something as close to b as possible? Well, you can attach an a so people can just apply the function to the argument and get a b. In that way, (,) a is almost the inverse of (->) a. This is formalized in adjunctions, which require these two functions:  return :: (Adjoint l r) => a -> r (l a) extract :: (Adjoint l r) => l (r a) -> a   (substitute the correct categories for adjunctions in non-Hask categories)  As you can see, these functions witness that l and r are ""almost inverse"". This is, essentially, what adjunctions are about.  More examples:   Free functors are adjoint to forgetful functors. My intuition: this means that generating structure freely is almost the inverse of forgetting structure. Colimits and limits are the two different adjoints of the diagonal functor which sends an object A of some category C to the constant functor always returning A in some functor category D -> C. This means that the almost-opposite of making a bunch of connected copies is taking their colimit/limit. Since colimits and limits can be a bit confusing, it might help to fix D = 2, the discrete category with two objects and only identity arrows. In this case, D -> C is the category of pairs of objects of C, whose morphisms are pairs of morphisms. The diagonal functor sends an object A to the pair (A, A) (note: this is not a product type! it is a pair of two types, not a type of pairs). The two adjoints are sums and products. This means that the ""almost inverse"" of sending an object to a pair containing that object is to take either the product or the sum of two elements in a pair.  Note that whenever a functor has an inverse, its inverse is in fact its adjoint.   Edit:   (-> r) is self-adjoint. Why? Because if you have the type (a -> r), the closest thing you can get to a is the type where the user gets to observe an a, and you give them the result of their observation: (a -> r) -> r."
haskell,37lqxf,PM_ME_UR_OBSIDIAN,2,Thu May 28 16:26:18 2015 UTC,"I'm still wondering why Haskell ""buys"" such an ""expensive"" theory as category theory if it's to use only one category."
haskell,37lqxf,tel,5,Thu May 28 16:55:01 2015 UTC,"I'd say the mistake is the 'only using one category' part, not the 'using category theory' part. I'm lazily thinking about how to do better, and I do have quite a few ideas, but it's pretty tricky. One problem is that proper support for category theory gets you a lot of complexity that's similar to OO subtyping."
haskell,37lqxf,srhb,2,Thu May 28 17:13:17 2015 UTC,I find that I get a lot of mileage out of trying to broaden the applicability of category theory to Haskell. The moment I find any new category I can express in Haskell all of a sudden my bag of tricks comes out and I simultaneously find a way to make code work better and learn something.
haskell,37lqxf,PM_ME_UR_OBSIDIAN,1 point,Thu May 28 23:05:58 2015 UTC,"I've noticed that, which is why I'm trying to see if I can design a language where you can just throw in the category theory directly."
haskell,37lqxf,srhb,1 point,Thu May 28 23:41:50 2015 UTC,Could you elaborate? how is it similar to subtyping?
haskell,37lqxf,Sonarpulse,3,Thu May 28 17:56:42 2015 UTC,"An obvious method of adding proper support for CT is by using some variant of Directed Type Theory. Directed Type Theory is a variant of Homotopy Type Theory where the path type is not necessarily symmetric, allowing you to have types that represent (infinity-)categories instead of (infinity-)groupoids.  Under Directed Type Theory, every function is a functor. If you don't want your function to be a functor, you can change the domain to either the opposite type (and by type I mean infinity-category) or the type of isomorphisms. Functions from C, Cop and Ciso mirror OOP variances co-, contra- and invariant.  In addition to the complexity of OOP, you have to remember that while OOP subtyping is just a partial order (or lattice-like structure), DTT works with category-like structures, so you've got ""proof-relevance"" (since you don't want all morphisms to be interchangable), which might be confusing.  You might want to ask whether we really want everything to be functorial-by-default, but I've been trying a few other variations and this seems to be the closest to working.  You might also ask if we really need dependent typing and infinity-categories, and I'm thinking that it might not be necessary. I would probably have the usual type : kind, but maybe extend it a bit more to proposition : order : category : 2-category or something. This gives you (-1) to 2-categories, which is probably plenty for everyday stuff. I haven't made it work yet, though."
haskell,37lqxf,Gurkenglas,1 point,Thu May 28 18:32:24 2015 UTC,"What's a good background for learning HoTT and Directed TT? I already have MLTT locked down, I know a bit of set theory, model theory and category theory, but my math-fu is otherwise non-existent. I tried reading the HoTT book, but not only do I not get it, I don't get what it's for."
haskell,37lqxf,tomejaguar,2,Thu May 28 20:15:52 2015 UTC,"My usual method is to force myself through material on the subject until it starts to make sense. Last I checked, though, DTT was still in the beginning stages. I think I was told that they don't even have the syntax pinned down."
haskell,37lqxf,sccrstud92,5,Thu May 28 22:38:53 2015 UTC,"Haskell doesn't ""buy"" it, but people using Haskell sometimes do. There are multiple categories and the payout is actually quite high. But it's not obvious."
haskell,37mif6,thecity2,59,Thu May 28 18:39:17 2015 UTC,"I'm not big on the attitude of almost every reply to this submission so far, which are typical replies: ""all you need to remember is this pointless difference to regular code, this is just the way things are"". The real answer is that, yes, this is annoying and not necessary.  Currently GHCi only tries to parse do-statements (expressions (print 1), generators (x <- getLine) and let binders (let x = 1)), and a few declarations (import declarations and data declarations and instances etc).  It could easily be updated to support function or pattern bindings, and avoid this source of confusion for newbies. There's no good reason for doing so other than ""it's not there yet"". I can add this to ghci-ng to demonstrate."
haskell,37mif6,chrisdoner,24,Thu May 28 21:45:57 2015 UTC,"Thank you, Chris. When we see countless learners going through identical, easily identified problems, sometimes we as a welcoming community should just fix them. (Error messages too? And example-driven documentation, perhaps?) I don't think anyone in this community believes in hazing rituals, in which we would say ""I had to go through this needless pain, so you do too."" Let's help out the new people who've heard Haskell is wonderful and want to get started.  Way back in ancient times when I was a university student, I took a class called Human Factors Engineering. One thing I learned there is that you cannot realistically expect all people to adapt to a non-intuitive technical design, even if it's in the manual. Sometimes the technical oddity should adapt to built-in human expectations -- especially for non-expert users (and also for users who may be busy, distracted, or in a safety-critical situation).  Today I got an email from a company that was one approval away from adopting Haskell, and didn't, because they couldn't convince their staff to bother learning it. Let's change their mind."
haskell,37mif6,FPguy,6,Fri May 29 01:55:28 2015 UTC,Love the idea of functional hazing rituals - purify the OO out of people!
haskell,37mif6,Sportanova,5,Fri May 29 07:55:00 2015 UTC,http://i.imgur.com/4mTG3Jv.png
haskell,37mif6,minipump,5,Fri May 29 11:26:29 2015 UTC,I can add this to ghci-ng[1] to demonstrate.   Please do!
haskell,37mif6,codygman,3,Fri May 29 07:25:31 2015 UTC,"By the way, I never really understood why the let keyword was even necessary in a do block. If really needed maybe something like := would have been better."
haskell,37mif6,maxigit,3,Fri May 29 07:39:25 2015 UTC,"Strictly speaking, for most uses, it's not. You can translate almost all let-bindings  x <- return pure_expression   assuming return has been defined to be proper and law abiding. But you couldn't translate this into an operator as follows:  x := pure_expression   Because user defined operators cannot new names. You need the compiler's help for that. Another thing is that you cannot translate this:  let x = y      y = x   As  y <- return x x <- return y   Won't compile unless you're in a mdo block and working with a monadFix. So let bindings in a do block are very much primitives rather that syntactic sugar over other do-notation constructs."
haskell,37mif6,multivector,2,Fri May 29 09:05:59 2015 UTC,You could just as easily do the let style translation on a different syntax as long as it used a unique and reserved operator that is built-in as well.
haskell,37mif6,Taladar,1 point,Fri May 29 10:29:41 2015 UTC,True. This only shows that some kind of special syntax is needed. The rest is just opinion about what that syntax should be.
haskell,37mif6,multivector,3,Fri May 29 17:00:39 2015 UTC,But it's not a pointless difference.   Maybe we just shouldn't call it a repl.
haskell,37mif6,nolrai,2,Fri May 29 20:53:39 2015 UTC,Any idea how to salvage :set +m entry support for let-less binders?
haskell,37mif6,hvr_,1 point,Fri May 29 20:55:43 2015 UTC,"I'm not big on the attitude of almost every reply to this submission so far, which are typical replies: ""all you need to remember is this pointless difference to regular code, this is just the way things are"". The real answer is that, yes, this is annoying and not necessary.   I think it's the title of the post which leads to that type of answers. Yes, it is ""annoying and necessary"", that doesn't make ""awfully complex"". It's awfull at best, but not complex."
haskell,37mif6,maxigit,8,Sat May 30 07:35:52 2015 UTC,"You can give IHaskell a try. It's a haskell backend for IPython, and uses the GHC API to provide a similar experience. This means that you can write free-flowing code as you'd write in any other repl.  There's a online demo available too, take a look: https://try.jupyter.org (Choose: New -> Haskell)  To use it in console, install it following instructions here: https://github.com/gibiansky/IHaskell/"
haskell,37mif6,sumitsahrawat,3,Thu May 28 19:17:26 2015 UTC,"As someone who uses iPython regularly, this was something I looked into first. Unfortunately, I couldn't figure out how to get it to work. Maybe I'm in cabal hell as you folks say?"
haskell,37mif6,sumitsahrawat,3,Thu May 28 22:09:28 2015 UTC,"first, you need zeroMQ from your package manager (libzmq, libzmq-dev etc)  then do this in bash  mkdir sandbox cd sandbox cabal sandbox init cabal install alex happy cabal install cpphs cabal install gtk2hs-buildtools cabal install ihaskell --reorder-goals ihaskell install # Adds ihaskell as a kernel for ipython"
haskell,37mif6,sumitsahrawat,1 point,Fri May 29 01:15:07 2015 UTC,"first, you need zeroMQ from your package manager (libzmq, libzmq-dev etc)   What package manager? PIP?"
haskell,37mif6,sumitsahrawat,3,Fri May 29 01:36:55 2015 UTC,"The package manager provided by the distribution (apt-get, yum, pacman etc)  IHaskell doesn't support windows yet."
haskell,37mif6,miguelnegrao,2,Fri May 29 02:01:35 2015 UTC,"Ok, I used Brew to install zeromq. But where is ihaskell located? I get ""command not found"" when I run that last line."
haskell,37mif6,sumitsahrawat,1 point,Fri May 29 02:45:26 2015 UTC,"In the sandbox directory.  /path/to/sandbox/.cabal-sandbox/bin/ihaskell  For macs & ubuntu, there are install scripts available :)  https://github.com/gibiansky/IHaskell/blob/master/macos-install.sh  https://github.com/gibiansky/IHaskell/blob/master/ubuntu-install.sh  Clone the repo, and execute that script."
haskell,37mif6,pipocaQuemada,3,Fri May 29 03:00:10 2015 UTC,Voila! The devil truly is in the details.
haskell,37mif6,pipocaQuemada,1 point,Fri May 29 03:29:46 2015 UTC,"If you don't mind installing nix, it's relatively easy to install with the nix (I only managed to get version 0.5 working so far)."
haskell,37mif6,Kludgy,2,Fri May 29 10:13:00 2015 UTC,"A new version will be out soon. IHaskell used an old version of classy-prelude, which causes trouble in nix.  Take a look here: https://github.com/gibiansky/IHaskell/issues/495 It's nearly fixed."
haskell,37mif6,Ashandalar,15,Fri May 29 19:52:00 2015 UTC,"FWIW, the first experience I had with Haskell was downloading ghc, opening up a tutorial, firing up ghci, typing in  ghci> square x = x * x   and getting really confused why the tutorial didn't work."
haskell,37mif6,m0rphism,5,Thu May 28 21:03:06 2015 UTC,I knew I wasn't alone. :)
haskell,37mif6,_AndrewC_,2,Thu May 28 21:07:33 2015 UTC,"I had come to Haskell after teaching myself Common Lisp, so it was something I had expected to just work.  I'm not sure I would change the syntax ghci expects, but improved error messages (pointing beginners to the right syntax) would be useful."
haskell,37mif6,Faucelme,3,Thu May 28 21:55:17 2015 UTC,"I like that. A gentle reminder should be easy to add, unobtrusive and directly addressing a common misunderstanding."
haskell,37mif6,Platz,12,Thu May 28 23:09:34 2015 UTC,"To define functions inside the REPL, you will indeed need to use a let as the response you found unhelpfully states. For example, defining a function which increments a number:  > let f n = n + 1 > f 2 3   To define functions with multiple cases, you'll need to surround the definition with braces, and separate the cases with semicolons:  > let { fact 0 = 1 ; fact n = n * fact (n-1) } > fact 5 120   What I'd recommend, however, is storing such function definitions in a .hs file, and loading them into the REPL with the :load (or simply :l) command.  > :load file.hs   When this command is run, the REPL will attempt to compile the definitions in the file, loading them, ready to be used. If compilation is unsuccessful, you'll get back any static error messages also."
haskell,37mif6,Ashandalar,9,Thu May 28 19:13:45 2015 UTC,"I'd also recommend using the REPL in combination with a .hs file. In this case the ghci command :r (short for :reload) might also be helpful, which reloads the currently :loaded module. This way you can change your definitions in your favorite text editor, then quickly :reload, and evaluate some expressions using those definitions."
haskell,37mif6,Ashandalar,2,Thu May 28 19:46:05 2015 UTC,I'm currently doing that as a workaround.
haskell,37mif6,emarshall85,5,Thu May 28 20:26:19 2015 UTC,"This is in fact how ghci is designed to be used: define functions in a .hs file, load them in ghci and mess with them."
haskell,37mif6,emarshall85,3,Fri May 29 09:14:23 2015 UTC,You can also use :e to open an editor for the most recently loaded file.
haskell,37mif6,emarshall85,7,Thu May 28 20:48:12 2015 UTC,I wasn't aware surrounding the definition with braces was necessary. not surrounding seems to work also  > let fact 0 = 1 ; fact n = n * fact (n-1) > fact 5 120
haskell,37mif6,Peaker,2,Thu May 28 21:02:02 2015 UTC,You're right. It seems that I was the one unaware.
haskell,37mif6,clumsyfeet,2,Thu May 28 21:05:19 2015 UTC,zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] zipWith' _ [] _ = [] zipWith' _ _ [] = [] zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys   How would the above code (from LYAH) be entered into the REPL?
haskell,37mif6,Tekmo,3,Thu May 28 20:27:30 2015 UTC,"> let { zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] ; zipWith' _ [] _ = [] ; zipWith' _ _ [] = [] ; zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys }   Not elegant, I grant you. You could just paste the definition (as you wrote it, spanning multiple lines, and without let) into a .hs file, and load that file."
haskell,37mif6,Tekmo,9,Thu May 28 20:38:46 2015 UTC,"Prelude> :set +m Prelude> let zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] Prelude|     zipWith' _ [] _ = [] Prelude|     zipWith' _ _ [] = [] Prelude|     zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys Prelude|  Prelude> zipWith' (+) [1..3] [4..6] [5,7,9]"
haskell,37mif6,Vektorweg,6,Thu May 28 20:54:26 2015 UTC,"What am I doing wrong here? Throws an error and doesn't let me finish entering the code.     λ :set +m    λ let zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] *Main| zipWith' _ [] _ = []  <interactive>:16:1:     parse error in let binding: missing required 'in'   EDIT: Figured out the error. I actually need to indent each line, because of course, the REPL doesn't auto-indent. Well, at least, it's something. Hope this helps someone else."
haskell,37mif6,pja,3,Thu May 28 20:57:47 2015 UTC,"Yeah, sorry for not mentioning it. I was hoping that the indentation would be apparent in my snippet. I'll remember not to take such things for granted next time I post something. Glad you figured it out.  Cheers."
haskell,37mif6,Tekmo,3,Thu May 28 22:47:33 2015 UTC,Yet one more thing that makes the REPL difficult for n00bs.
haskell,37mif6,spicenozzle,1 point,Thu May 28 22:59:55 2015 UTC,"Python's repl doesn't autoindent either. While the error message is probably less cryptic, I don't think a lack of auto indentation is a fair argument in the scope of this conversation. Indeed, my earlier posts weren't meant to argue that the repl situation was ideal, but rather to show how to have multi line equations in ghci."
haskell,37mif6,gfixler,1 point,Fri May 29 13:55:38 2015 UTC,Python lets you use whatever indent you want (e.g 1 space).  Here you need to indent exactly to the column after let.
haskell,37mif6,beerdude26,1 point,Fri May 29 20:51:10 2015 UTC,"This illustrates one more reason to eschew the usual aligned-indent practice. Instead, always start a new line after a layout herald and use your typical indent (2 space, 4 space, even tab, as long as you are consistent)."
haskell,37mif6,bradley_hardy,-7,Sat May 30 01:03:05 2015 UTC,"If it bothers you so much, then contribute a patch to ghci to automatically indent"
haskell,37mif6,mbruder,5,Thu May 28 23:03:56 2015 UTC,"You expect a ""beginner"" to patch ghci? I can't imagine what you would ask an expert."
haskell,37mif6,spicenozzle,-4,Thu May 28 23:15:17 2015 UTC,"You don't have to do it now, but consider doing it later as a way of contributing back to the community"
haskell,37mif6,LGFish,5,Thu May 28 23:20:47 2015 UTC,"You can also write :{ and :} to start and stop a multiline input.  Prelude> :{ Prelude| let zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c] Prelude|     zipWith' _ [] _ = [] Prelude|     zipWith' _ _ [] = [] Prelude|     zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys Prelude| :} Prelude> zipWith' (+) [1..3] [4..6] [5,7,9]"
haskell,37mif6,nolrai,3,Fri May 29 02:04:18 2015 UTC,"No, you’re not the only person aggravated by this. I have occasionally considered writing a new repl that understood the same real Haskell code that you would have written for ghc to compile.  I’m of the opinion that it’s a rough spot where Haskell is wilfully obtuse for no real good reason apart from a misguided appeal to some abstract idea of mathematical unity: I’d personally rather have a repl that understood the same code that the compiler / interpreters do."
haskell,37mif6,nolrai,6,Fri May 29 12:38:54 2015 UTC,"All you need to know is that you use ""let"" to define a value or function, as in:  let f x = x + x   The whole IO monad thing is totally unnecessary (and a little wrong)"
haskell,37ne48,thecity2,34,Thu May 28 22:28:07 2015 UTC,"I'm getting into Haskell because of the abstraction. That's what I intend to get out of it. All the ""x"", ""y"", ""xs"", ""ys"", etc are kind of the point, right? Abstract as much as you can about problems until they are so general, that ""x"" is as meaningful as anything else you could use as a name.  But much shorter. :)"
haskell,37ne48,tomejaguar,3,Thu May 28 23:11:50 2015 UTC,I guess that makes sense.
haskell,37ne48,Platz,4,Thu May 28 23:14:35 2015 UTC,"It's always easier to discuss with concrete examples!  Can you link to some source on Hackage, for example?"
haskell,37ne48,tomejaguar,4,Fri May 29 07:37:34 2015 UTC,"Fully agree examples are needed.    Haskellers jump to point out short variable names in functions with high parametricity and short scopes, but I've noticed this is starting to feel like a ""default answer"" that is used to avoid discussing any nuance on the topic whatsoever, because without an example one will simply insert the example that is most convenient to argue their position.   Here is an example posted yesterday:  https://github.com/bitonic/binary/commit/e46b7b61111579befcc99954be8a0f48738f8ef7  examples of variable names include inp, ks, mbBs, bss0. Actually I don't think this example is all that bad (I can figure out their meaning with some thought), but I'm not sure that this point one can invoke parametricity with a straight face as to why these variable names are so short."
haskell,37ne48,yitz,5,Fri May 29 16:09:27 2015 UTC,Great example!  If you're going to go so far as to use three or four letter variable names you may as well go all the way and just write out what they are!
haskell,37ne48,autowikibot,1 point,Fri May 29 16:22:22 2015 UTC,"The truth is somewhere in the middle. You definitely want readers to be able to see at a glance what the variables mean. But parameter names tend to be repeated multiple times in a function implementations, so every extra character makes the code a bit harder to read - more verbose, increasingly awkward line wraps, etc. It's an art, and a personal style of every experienced developer, to find the happy medium. One thing is for sure - the days of Hungarian notation and veryLongVariableNamesThatTellYouEverythingIncludingYourGrandmothersBirthday are long gone."
haskell,37ne48,chreekat,1 point,Sun May 31 02:35:53 2015 UTC,"Hungarian notation:       Hungarian notation is an identifier naming convention in computer programming, in which the name of a variable or function indicates its type or intended use. There are two types of Hungarian notation: Systems Hungarian notation and Apps Hungarian notation.  Hungarian notation was designed to be language-independent, and found its first major use with the BCPL programming language. Because BCPL has no data types other than the machine word, nothing in the language itself helps a programmer remember variables' types. Hungarian notation aims to remedy this by providing the programmer with explicit knowledge of each variable's data type.  In Hungarian notation, a variable name starts with a group of lower-case letters which are mnemonics for the type or purpose of that variable, followed by whatever name the programmer has chosen; this last part is sometimes distinguished as the given name. The first character of the given name can be capitalized to separate it from the type indicators (see also CamelCase). Otherwise the case of this character denotes scope.     Interesting: Sigil (computer programming) | Naming convention (programming) | Charles Simonyi   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
haskell,37ne48,chreekat,13,Sun May 31 02:36:13 2015 UTC,"I understand your frustration, but I don't think it's going to change. Here's why:  Type variables  Take map, whose type definition is usually:  :: (a -> b) -> [a] -> [b]   The fact that those variables are all single letters starting at 'a' immediately tells me very useful information: namely, that map doesn't care a whit what those types actually are! In other words, the names are meaningless because the variables are meaningless. The types are completely general, and that in turn tells me a lot about what map does (and does not) do.  The only real alternative to a and b in the above case would be:  :: (foo -> bar) -> [foo] -> [bar]   If Haskell had been designed by dyed-in-the-wool C programmers, it probably would use such names. But, it wasn't, and it doesn't.  That's not to say that some libraries don't go overboard, but I think you'll find most examples you run across have short type variables for the reason just mentioned.  There's one other common pattern, where particular variables stand for well-known types. Now, this is jargon, so I don't support it 100%, but for the record:   m = monad t = traversable f = functor (sometimes applicative) s = state r = read-only data   Having said all that, I still can't make heads or tails of the lens chart. What is s, t, a, and b? I'm sure someone could tell me in ten seconds if I asked, but couldn't that be listed somewhere on the chart? Or, you know, couldn't there be better names than ""s, t, a, b""?  Data variables  Sometimes, I think a one-letter variable is absolutely the best name. If a function is four lines long and pattern matches on the head/tail of a list, I think [x:xs] are  the best names.  Anyway, I agree with you: names are important, and should be named with a lot of thought. Sometimes Haskell code does use too many short names. But sometimes, short names are called for."
haskell,37ne48,Tekmo,16,Thu May 28 23:33:33 2015 UTC,"Oh my god, it just dawned on me that 's, t, a, b' are meaningless for exactly the reason I described. I have to go lie down for a while."
haskell,37ne48,m0rphism,24,Thu May 28 23:41:07 2015 UTC,"At one point we had a type in lens where one of its arguments started taking parameters of the form i m a s t a b u. Upon reflection, we let it win the argument and decided not to implement the function.  /u/edwardkmett - Link"
haskell,37ne48,chrisdoner,7,Fri May 29 02:11:50 2015 UTC,"The nature of the stab abbreviation was discussed in the Haskell Cast episode 1 with Edward Kmett. If I remember correctly, there was no special meaning to it, and it is just two pairs of types, which is signalized by consequent letters.  Personally, I read s and t as source and target. Also I often see functions of type a -> b, so I think of a and b also as some sort of inner source and inner target."
haskell,37ne48,tel,4,Thu May 28 23:52:45 2015 UTC,"s can also be read as ""structure"", which is what the lens documentation uses (copied here, I can't find where in lens the Lens type is defined anymore); and then t is just the next alphabetical letter indicating ""s is to t as a to b""."
haskell,37ne48,tomejaguar,5,Fri May 29 01:23:01 2015 UTC,"There's a little bit of structure to s t a b, though. In particular s and t and related to one another and a and b are related to one another—thus why they're next to one another in the alphabet. Further, the relationship between s and t is similar to that of the relationship between a and b  s : t :: a : b   But this is only one axis as t and a are similar to one another in the same way that s and b are, so maybe we should draw a box  s === t |     | |     |  a === b   This was discussed a bit in ""Mirrored Lenses"" and also is highlighted a bit by thinking about which parameters are positive and negative in Lens  type Lens s t a b = forall f . Functor f => (a -> f b) -> (s -> f t)      Lens - + + -"
haskell,37ne48,Tekmo,9,Fri May 29 13:18:53 2015 UTC,"For things like functors and monads with typically only one type variable I can cope.  When the number of type variables increases I get more confused, especially with things I don't use that often.  Pipes and lens are particular examples of this.  Instead of Lens s t a b I would prefer at least something like Lens sa sb ta tb to indicate initial structure sa, final structure sb, initial target ta, final target tb.  Instead of Proxy a' a b' b m r I would prefer Proxy uo ui di do m r indicating upstream out, downstream in etc.."
haskell,37ne48,chreekat,3,Fri May 29 07:57:17 2015 UTC,"Using ""i"" for input and ""o"" for output does not work for type signatures of binary operators like >->.  At the interface between two pipes, one pipe's input becomes another output, so you can't use ""i"" or ""o"" for the interfacial type variables.  Same problem for ""u"" and ""d"": at the interface one pipe's upstream is another pipe's downstream so you can't use ""u"" or ""d"" for interfacial type variables.  It gets even worse when you consider other connectives like ~> and ""for"" which thread flow in other ways.   Then terms like ""upstream"" and downstream become downright incorrect because they can be connected to things which are not really upstream or downstream in a traditional sense."
haskell,37ne48,symmetry81,1 point,Fri May 29 15:26:17 2015 UTC,"I think I've seen your(?) example of Proxy before, and I totally agree in this case. uo ui di do m ris much nicer."
haskell,37ne48,hastor,3,Fri May 29 14:43:01 2015 UTC,Generally I'm a fan of the idea that the length of your variable names should be proportional to the size of the scope they're being used in.  If your scope has 4 or fewer variables then certainly feel free to use a single letter but at 8 you really need to be using real names.
haskell,37ne48,chreekat,1 point,Fri May 29 11:53:20 2015 UTC,"I'm sorry, but an example with 2 variables in scope is missing the point of the question.  Downvoting, and I'm sorry to see so many haskellers not understanding the question."
haskell,37ne48,kqr,3,Sat May 30 10:57:40 2015 UTC,"Sure, post examples of many one-letter variables in scope and let's talk about it."
haskell,37ne48,chreekat,1 point,Sat May 30 13:23:00 2015 UTC,Or how about this:   :: (apple -> applejuice) -> [apple] -> [applejuice]
haskell,37ne48,kqr,9,Thu May 28 23:39:03 2015 UTC,"It makes it sound like it can only deal with apples, which is untrue. You could have something like  :: (oneType -> anotherType) -> [oneType] -> [anotherType]   which is just as general as the a -> b stuff, but also much more tedious to read once you get used to the a -> b convention."
haskell,37ne48,dskippy,1 point,Fri May 29 07:07:11 2015 UTC,"MrCatholic has a point, though — apple -> applejuice is a built-in example that would help (some? most?) people grasp the concept quicker.  But to address that point, I think examples-for-learning are best left in media designed for instruction, and left out of standard libraries. (fmap vs map comes to mind...)"
haskell,37ne48,yitz,3,Fri May 29 14:54:57 2015 UTC,"Yes, I think you're absolutely correct. apple -> applejuice makes it much easier that fmap is great for turning a list of apples to applejuices, but helps little with other kinds of transformations.  Many similar examples would be great! But not in the standard library signatures. Perhaps in its documentation."
haskell,37ne48,dskippy,1 point,Fri May 29 15:01:18 2015 UTC,How about:  map :: (old_type -> new_type) -> [old_type] -> [new_type]
haskell,37ne48,co_dan,1 point,Fri May 29 12:42:58 2015 UTC,"The words old and new add zero information if you know what the symbol -> means. The word type adds zero information if you know what the symbol :: means. The character '_' is useless if you don't have two words anymore.  So that may be helpful if your intended audiences is mainly beginners who aren't comfortable yet with the meanings of those symbols. But if this is real life application or library code whose audience is Haskell programmers who are already at least somewhat comfortable with the syntax of the language, that verbosity is only an annoyance that makes the code harder to read."
haskell,37ne48,m0rphism,1 point,Sun May 31 02:44:52 2015 UTC,Yes exactly. My audience is beginners. Normally I write a and b for this. But the OP is seeking alternatives.
haskell,37ne48,Tekmo,1 point,Mon Jun 1 13:41:14 2015 UTC,"Exactly. That's like adding ""_variable"" to every variable name in C or Python. It just duplicates information, doesn't add anything new."
haskell,37ne48,dbpatterson,4,Tue Jun 2 10:54:25 2015 UTC,"Yeah, I found that confusing as well when starting with Haskell. Now that I've got used to it, I think it depends to some degree on the context whether this naming scheme is a good choice.  I think it is ok, when the scope is fairly small, the letters unambigously describe the initial letter of the corresponding word, and there are some visible type signatures containing the full name. For example consider  data Expr = Add Expr Expr | Num Int  eval :: Expr -> Int eval (Add e1 e2) = eval e1 + eval e2 eval (Num i)     = i   I read the type signature of eval, see there is Expr and Int involved, so the e is probably an Expr and i probably an Int. In this case I can also assert this assumption by observing that e1 and e2 are arguments to eval, hence they must be of Expr, and i is returned, hence it must be an Int.  It is a bit smaller, but a bit more implicit as the following version:  data Expression = Add Expression Expression | Number Integer  evaluate :: Expression -> Integer evaluate (Add expression1 expression2) = evaluate expression1 + evaluate expression2 evaluate (Number integer)              = integer   I'm still undecided, but in such simple cases as above I got into the habit of using the abbreviated form. Not sure if this is the best choice for potential readers, though. ;)"
haskell,37ne48,apfelmus,3,Thu May 28 23:07:19 2015 UTC,"I'm not talking about shorthanding ""expression"" into ""e"". That's perfectly fine.  I'm talking about stuff more like applyLog :: (a,[c]) -> (a -> (b,[c])) -> (b,[c]) which I see often. I get that the types and order of the params are supposed to speak for themselves, but they don't. Not to me anyway."
haskell,37ne48,gfixler,5,Thu May 28 23:14:13 2015 UTC,"Actually, the real problem is the function name.  That applyLog function has nothing to do with logs; the type is much more general than that."
haskell,37ne48,m0rphism,2,Fri May 29 02:08:13 2015 UTC,Tbh I still have no idea why tuples are even needed in this function.
haskell,37ne48,sambocyn,2,Fri May 29 02:42:40 2015 UTC,"I'm not sure if having longer names is going to help. To try: does this make more sense?  applyLog :: (source, [log]) -> (source -> (target, [log])) -> (target, [log])   Essentially, this is function application (takes source, source -> target, and returns target) that carries a 'log' along with it (in particular, the source has a log, and the function can produce more log), where a log is some list of values. But I don't think the names are how you figure that out, but rather the structure. When used well, terse variable or type names are hints that it is the structure that matters, as they will lead you to an understanding of all the ways this could be used.   Though often the short names are chosed to give some hint as to a common use (in your example, a and b feel idiomatic - c does not - I'd prefer l or something else, as it hints that it is a different class of things)."
haskell,37ne48,Denommus,4,Fri May 29 03:06:24 2015 UTC,"I think the following variant is best:  applyLog :: (a,[log]) -> (a -> (b,[log])) -> (b,[log])   This indicates that the types a and b are completely generic, while the function does something ""more specialized"" with the log type."
haskell,37ne48,heisenbug,2,Fri May 29 12:48:18 2015 UTC,"I'm talking about stuff more like applyLog :: (a,[c]) -> (a -> (b,[c])) -> (b,[c])   I often work backwards, then use the name to clarify. Here I'd say ""Okay, this gives me back a pair with a b and a list of cs. Where can I get those from? It looks like the function right before it gives me that. Where does it get that pair? It looks like it uses the a to create it. Okay, so where does that function get its input a from? Oh, the a is provided in the first argument. Hmm, there's also a list of cs there. I wonder if the list of cs is the same in the two inputs and the output... If I forget the lists of cs for a moment, then this just looks like a -> (a -> b) -> b, which just looks like some form of apply - i.e. 'give me an a, and a function from a to b, and I can give you a b.' Alright, what's the name of this function? Hmm, applyLog... Okay, so maybe the incoming list of cs is the log so far, and in the act of generating the b from the a, we add more to the log, and then we get back the b and more log.""  I don't even know if that's right, but it's just to give you a sense of how I use the types - and the name, ultimately - to get a first impression of a function. I've been wrong (and may be here), but I've been right a lot more often. If the name isn't bad, then it and the type together usually tell me the general idea of what the function does."
haskell,37ne48,Vektorweg,1 point,Fri May 29 08:53:57 2015 UTC,"Well, I think for variables on the type level apply about the same rules. But I also noticed that people are using much more abbreviations there, up to the point that you almost nowhere find type variables with more than 1 letter. Maybe this is just a social convention. Maybe their kind (type of type) is mostly *, and hence they could  assume any first-order type, so it doesn't make sense to name them. But I guess that's not completely true, as the type variable could be named after it's intention, e.g. state for the state of the State Monad, which is not otherwise restricted (e.g. through a type class constraint)."
haskell,37ne48,vincentrevelations,1 point,Thu May 28 23:23:11 2015 UTC,"I find the more verbosely named one harder to read. i like functions to have long names and locals to have short names. makes it easier to see the dataflow at a glance.  (unless the function is long, either split it into multiple, or provide longer names, because the intermediate computations don't often have type annotations, and in forced to lookup the types of random callees).   of course, a nice IDE that drew arrows between references and declarations like DrScheme (DrRacket?), and/or gave the type of any subexpression on hover (with selection by dragging or by expansion/contraction), would make both verbose and concise locals easier to read."
haskell,37ne48,enolan,3,Sun May 31 00:36:13 2015 UTC,I concentrate on the type signatures. They are much more meaningful than any variable name.
haskell,37ne48,ninereeds314,5,Thu May 28 23:13:09 2015 UTC,"The good thing with one-letter binding names is that there are only 23 of them. Since Haskell functions are pretty short, this is usually enough. The following little dictionary can help making sense of them.   f: some function (when value) or functor (when at type level) a: some argument (value), or type of the function domain i, j: indices m: some monadic type constructor   Since the mathematics that is being implemented by many Haskell constructs is pretty abstract, using too descriptive names guides the imagination to the unnecessarily concrete. E.g. do you prefer this Functor class definition to the usual one?  class Functor sack where   fmap :: (coffee -> theorem) -> sack coffee -> sack theorem"
haskell,37ne48,kqr,8,Thu May 28 23:15:33 2015 UTC,"The good thing with one-letter binding names is that there are only 23 of them.   Wait, where did the other 3 go?"
haskell,37ne48,IronhandedLayman,5,Thu May 28 23:22:39 2015 UTC,"Actually, you can use the full range of lower unicode letters. 1759 letters, to be exact.   Prelude Data.Char> length $ filter isLower $ [minBound .. maxBound]"
haskell,37ne48,ninereeds314,2,Fri May 29 00:10:49 2015 UTC,"q, z, and h are reserved keywords."
haskell,37ne48,gfixler,1 point,Fri May 29 17:37:27 2015 UTC,Am I missing a joke? No they're not.
haskell,37ne48,twistier,3,Wed Jun 3 12:11:26 2015 UTC,"Short scope - yes. It's no different than i and j as common loop induction variables in other languages. Longer, more explicit names help readability - but not when the code is perfectly readable without them.  Of course any style damages readability when you're still getting used to it."
haskell,37ne48,chrisdoner,7,Fri May 29 07:40:59 2015 UTC,"Actually, I rather like your idea:   class Functor carton where   fmap :: (apples -> juiceboxes) -> carton apples -> carton juiceboxes    Now Functor makes a heck of a lot more sense to me!"
haskell,37ne48,beerdude26,9,Thu May 28 23:25:19 2015 UTC,Can functors only deal with cartons of apples? What if I Have a list of strings?
haskell,37ne48,gfixler,4,Fri May 29 07:04:48 2015 UTC,Or a stream of bits? Or an optional value (like Maybe)? Or an undo-able field? The moment you start naming the variables in fmap is the point when you miss all of the other applications of Functor.
haskell,37ne48,hastor,2,Fri May 29 13:33:17 2015 UTC,"Well, if you place your list of strings in a carton of apples..."
haskell,37ne48,mightybyte,3,Fri May 29 07:43:37 2015 UTC,"Ew, there's a string in my apple juice."
haskell,37ne48,mightybyte,6,Fri May 29 09:05:19 2015 UTC,"This is much more difficult for me to read, actually."
haskell,37ne48,eegreg,2,Fri May 29 03:26:00 2015 UTC,Just putting this here too: http://chrisdone.com/fmap/
haskell,37ne48,beerdude26,2,Fri May 29 01:18:55 2015 UTC,"My short ""oh so that's what this is"" definitions.   Functor = Container. You can put stuff in it. (Among other things). I also like Mappable. return = inject. We can inject a value into a monadic context. monad = computational context. We take a type, and we construct a completely arbitrary computational context for it (well, they have to obey the monad laws)."
haskell,37ne48,SkoomaMudcrab,1 point,Fri May 29 15:03:41 2015 UTC,"Thanks, super helpful!"
haskell,37ne48,chrox,4,Fri May 29 15:31:34 2015 UTC,"Don't get too closed off with Functor = Container. That's one way they show up, but, e.g., functions are also Functors, so you can fmap (+2) (*3). With functions, fmap is composition, so this creates the function ((+2) . (*3)), which takes a value, multiplies it by 3, then adds 2. There are other ""computational contexts"" out there that don't quite fit the ""container"" metaphor, though containers are a good first approximation, e.g. you could think of the (*3) as ""containing"" a future result value that will be 3 times whatever it's eventually given."
haskell,37ne48,Kludgy,2,Sat May 30 05:26:41 2015 UTC,"This only works when there is one function and one argument etc.  Clearly functions like map are not problematic.  It is when the number of variables in scope is large descriptive names are needed.  Haskell functions are meaningfully short compared to other languages anymore.  Only when comparing to C or C++ is this true, not compared to JS or Scala for example."
haskell,37ne48,chreekat,2,Sat May 30 11:02:24 2015 UTC,You're not the only person to feel this way.  The question comes up fairly regularly around here.  I wrote a blog post about it awhile back.  Are there plenty of places where Haskell code uses one-letter names inappropriately?  Absolutely.  But I think there also plenty of places where a one-letter name is superior some longer name that a number of newcomers seem to want.
haskell,37ne48,Kludgy,0,Fri May 29 00:24:54 2015 UTC,It's the first set I'd like to see changed. The second set is fine.
haskell,37ne48,ilmmad,7,Fri May 29 00:50:23 2015 UTC,"Sure.  The problem is distinguishing the two.  The difference is probably subjective.  And if that is true, then ""I'd like to see that changed"" starts to sound a lot more like ""You should use my preferred coding style""."
haskell,37ne48,gfixler,2,Fri May 29 01:22:00 2015 UTC,I have written how variable naming is context dependent. Any time there subtly it ends up being lost much of the time. Unfortunately many Haskellers have forgot that they are not always writing completely generic code and have made your life a lot harder. Sorry! You do get used to it though.
haskell,37ne48,sacundim,2,Fri May 29 00:55:10 2015 UTC,"Haskell is tough to learn for most imperative programmers. I was always told to just write everything out to understand a function, or to understand type unification. Writing out a type unification on paper would become very tiresome indeed if the types were named ""oldtype"", ""newtype"", ""oldtypetonewtype"", etc. Unrolling a recursive function o' paper would also be very tiresome for the same reason. Proofs too."
haskell,37ne48,chrox,2,Fri May 29 14:18:19 2015 UTC,"I got the same feeling as you when I tried to understand code like  m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)   ""OK"", thought I to myself, ""these ContT and runContT things don't actually do anything, so if I strip them away, this will become easier to understand"".  m >>= k  =  \c ->  m (\a ->  (k a) c)   D'OH!  But you'll get used to it. Everyone does. Pretty soon you'll be churning out stuff like k a g = g (k a) (k a (g a k))"
haskell,37ne48,Kludgy,3,Fri May 29 22:04:50 2015 UTC,Worse yet is when the same single letter is used to refer to different items within different namespaces but within the same expression. I'm not joking. Some people seem deliberately obscure.
haskell,37ne48,yitz,3,Thu May 28 22:38:44 2015 UTC,"Do you mean different scopes? Even in Haskell it's considered to be bad form to shadow names in nested scope.  GHC should yield warnings about this. In fact, it's often not a bad idea to turn the warnings into errors with the -Werror option."
haskell,37ne48,tomejaguar,8,Thu May 28 22:58:13 2015 UTC,I think OP is talking about when there is an 'a' type variable and an 'a' data variable in the same function. I agree that's a pain.  Imagine  map :: (a -> b) -> [a] -> [b] map _ [] = [] map b (a:as) = b a : map b as
haskell,37ne48,mavvam,3,Thu May 28 23:36:11 2015 UTC,"Ah I see. Yea that has caught me as well. Personally prefer (x :: a), (y :: b) to (a :: a) where possible.  Dovetails nicely back into the general problem where a lot of time learning Haskell for those of us without a mentor can be spent rediscovering and jettisoning bad assumptions in a very roundabout way."
haskell,37ne48,tomejaguar,3,Fri May 29 00:11:17 2015 UTC,"Ah I'm totally guilty of this. In my defense, I think the example you gave is a pain too, because the ""b"" has type ""a -> b"". But I would write  map :: (a -> b) -> [a] -> [b] map _ [] = [] map f (a:as) = f a : map f as   and be happy with myself."
haskell,37ne48,hastor,9,Fri May 29 01:28:21 2015 UTC,"I prefer a and b for types, and x and y for values.  map :: (a -> b) -> [a] -> [b] map _ [] = [] map f (x:xs) = f x : map f xs   I'm used to phrases like ""for some type a,"" and ""for all a,"" and ""a implies b,"" but also phrases like ""f of x,"" and ""the value of f at x is."""
haskell,37njld,crb002,1 point,Thu May 28 23:09:23 2015 UTC,Link http://www.lambdajam.com/program-2/
haskell,37njld,Mob_Of_One,1 point,Thu May 28 23:11:02 2015 UTC,"Speakers and program appear to be the same content, so I can't find the schedule.  http://imgur.com/NdtqNia,VhP7oJc#0 speakers  http://imgur.com/NdtqNia,VhP7oJc#1 program"
haskell,37njld,artiegold,1 point,Thu May 28 23:54:08 2015 UTC,http://www.lambdajam.com/program is the URL.
haskell,37n0lz,rdfox,4,Thu May 28 20:47:06 2015 UTC,"There's also nhc98: https://www.haskell.org/nhc98/  Also, it appears the darwinports hugs for mac is now on macports: https://www.macports.org/ports.php?by=name&substr=hugs  I'll go repoint the link from the hugs page (https://www.haskell.org/hugs/pages/downloading.htm)  If anyone else has any patches to any of the hugs pages to point to other, better sources, please let me know!  (Edit: it appears the Mac Ports version has rotted a bit. If someone who knows what they're doing wants to fix it up, that would be awesome.)"
haskell,37n0lz,gbaz1,2,Fri May 29 02:15:41 2015 UTC,Looks like nhc98 is about the same deal. I can kick it into gear on an old redhat VM. OSX is a no-go due to clang's persnikityness. I guess with enough motivation one could try with a backported gcc toolchain.  That's probably also the right strategy for hugs. It seems to also want bug-for-bug compatibility to build.
haskell,37n0lz,ethelward,3,Fri May 29 18:26:17 2015 UTC,"I think that hugs is now totally outdated, you should install ghc in place.  Personally, I installed it with homebrew and it works nicely."
haskell,37n0lz,merijnv,8,Thu May 28 22:21:25 2015 UTC,"Oh Hugs outdated alright. I'm interested in using it anyway. Ghc has some drawbacks:   Huge Hard to port Takes forever to build itself Generates massive executables   Hugs is the opposite. It's portable C (despite my mac woes) so it's easy to port. The interpreter is instant on. Hugs itself is tiny at 1.4 MB. There's some areas I would like to use Haskell, and ghc is holding me back:   Embedded scripting language like lua or guile (for Haskell or C programs) Shell scripting On tiny mobile and embedded systems   Ghc sucks for that. Despite ostensibly providing an embeddable interpreter you basically have to ship all of Ghc in order to get any functionality. We're talking 150 MB compressed."
haskell,37n0lz,phile314,3,Thu May 28 23:16:00 2015 UTC,"Have you looked at UHC? I don't know whether that's any easier to port (being written in Haskell and all), but it's considerably more maintained than Hugs."
haskell,37km1l,jaspervdj,14,Thu May 28 09:01:00 2015 UTC,"if remaining <= 0   then ks (B.concat $ reverse bss) ()   I'm a bit surprised to see the trusty old ""accumulate list backwards, then reverse at the end"" technique used for a performance improvement.  Wouldn't a difference list be faster?"
haskell,37km1l,drb226,11,Thu May 28 09:59:52 2015 UTC,Last time I played with the two side by side they performed the same.
haskell,37km1l,jberryman,13,Thu May 28 10:14:21 2015 UTC,"Wouldn't a difference list be faster?   Not inherently.   Using a difference list in the same fashion is basically a reverse-at-the-end as well,  except that you are dealing with a bunch of closures instead of cons cells.   They are both linear overall,  and accessing the head of a difference list constructed from n appends to the right is still O(n).  Any difference in speed in this case has everything to do with the details of the underlying compiler."
haskell,37km1l,lpsmith,2,Thu May 28 13:12:14 2015 UTC,"Well, I tend to prefer difference lists can be better also because they compose more, and they're less error prone.  But you're right, in this self-contained case there should not be a difference."
haskell,37km1l,rostayob,1 point,Thu May 28 15:56:44 2015 UTC,"TBH I don't really get all the fuss about whether things compose or not. Sure, if it's a function abstraction it should compose. If not, there are other operators, binary and otherwise, and other functions. Why should something that doesn't represent a function support function composition?  Sure difference lists compose - they're functions. But that's an implementation detail. When you compose difference lists the intent is to concatentate lists.  Fortunately, Data.DList doesn't overload the dot operator - the standard difference list knows that it's a specialised form of list, not a function. Though apply is a bit of an abstraction-leaky name IMO.  EDIT  Because I'm long-winded, bad at setting the right tone and generally a bit of an idiot, I've turned this into a big deal. I know it's not really. Sorry everyone."
haskell,37km1l,ninereeds314,8,Thu May 28 17:40:59 2015 UTC,People don't mean just function composition when they talk about how abstractions compose.
haskell,37km1l,chrisdoner,1 point,Thu May 28 17:45:49 2015 UTC,"I used to believe that, but found it rather odd the way people talk about monads not composing even though there certainly are ways to combine operations from different monads (and it's a good job since main is in the IO monad right from the start - every use of any other monad combines multiple monads in the same program). The only way I could make sense of that was that actually they really did mean composing like a function.  In any case, what other sense is there where difference lists ""compose more"" than ordinary lists? They're a specialized representation which supports fewer operations overall."
haskell,37km1l,ninereeds314,8,Thu May 28 17:51:25 2015 UTC,"When people say that monads don't compose, they mean something very specific.  Start with a type like:  newtype Compose f g a = Compose { getCompose :: f (g a)) }   The type Compose has the kind (* -> *) -> (* -> *) -> (* -> *).  Compare that to the type of (.), (b -> c) -> (a -> b) -> (a -> c).  The similarity isn't accidental.  The Compose type... composes type constructors together.  When you do that with two functors, you can create a Functor instance.  When you do that with two applicative functors, you can create an Applicative instance.  But when you do that with two monads, you can't create a uniform Monad instance that will work for all such compositions.  That is what people are talking about when they say monads don't compose.  For the sake of completeness, look at Data.Functor.Compose.  Note that the type already exists in a pretty standard library, and that while it has a bunch of instances, including Functor and Applicative, it doesn't have a Monad instance."
haskell,37km1l,c_wraith,3,Fri May 29 04:22:47 2015 UTC,"Well, no, monads don't compose like functions. They compose like arrows in a category — just like functions do.  I apologize for uttering perhaps the most pedantic thing I've ever said. But, it's valuable to keep in mind. Other things compose like arrows in a category, too. Yes, 'to compose' and 'to combine' are often treated as synonyms, but when you're talking about arrows in a category you get more goodies with composition. It is basically a principled way to combine things.  One of the greatest benefits is that two arrows that have been composed are indistinguishable from a single arrow (or any other collection of composed arrows) that connect the same objects. This is nice for programming because it creates lots of code sharing and abstraction. For functions, it means you can have a bunch of reusable ""subfunctions"" that you can slap in wherever. Categorical composition is the nice thing underlying that nice behavior.  But, like I said, other things can be arrows.  Example:  Website A is a description of a web server. It describes certain routes, and the GET/POST/whatev responses to queries at those routes.  Website B is another description of a web server with its own routes and responses.  Given a description of a Website, you have a function runSite :: Website -> IO () that uses the description to actually fire up a web server.  Now you want to run both A and B at once. What do you do?  Well... you could build a function ""combineWebsites :: Website -> Website -> Website"". It would work, probably. Think about what it would take with a naive description of a Website. Then, what if you wanted to add more websites? I'm starting to sense spaghetti code. Sorry, I'm waving my hands a lot here.  What if you could compose websites? composeWebsites :: Website -> Website -> Website. For two sites, maybe it's the same as combineWebsites. But if it's a true composition, where the end Webiset is indistinguishable from the composition of two (or more) Websites, suddenly it's a piece of cake to add as many Websites as you want. Just keep composing. Going the other way, it's easy to split up a Website into as many subsites as you want.  The hard part... the fun part... is figuring out how to structure a Website such that it can be an arrow.  Any feedback on that example is appreciated. I just made it up."
haskell,37km1l,chreekat,1 point,Fri May 29 00:54:58 2015 UTC,"What worries me here is that you don't seem to be choosing the abstraction appropriate to the problem - more like choosing the abstraction first and forcing the problem to fit.  One of the few things I know about category theory (I keep dipping my toe in, but then forgetting most of what I learned) is that there's an obvious reason why functions compose like arrows in a category - the original intent of categories was basically to abstract the functions out of function composition. Once you abstract away from functions and composition your objects can be some not-obviously-functionish things and your arrows can be some not-obviously-function-composition things, but the abstraction still reflects that original intent.  So where it's appropriate that's really just my earlier ""Sure, if it's a function abstraction it should compose."". And of course the point of abstracting away from functions is exactly that, but still, to me that doesn't mean I'd start out looking for ways to treat websites as categories.  I've never been a web developer but, if I were looking for generalizations and ways to abstract away from that, I'd probably start with intent-related concepts like ""document"" - depending, of course, on why I want to be more abstract. Abstraction for its own sake just makes code less readable and less maintainable.   But if it's a true composition, where the end Webiset is indistinguishable from the composition of two (or more) Websites, suddenly it's a piece of cake to add as many Websites as you want.   Yes, but that's just closure - the idea of an operation being closed for a set isn't unique to function composition. Addition and multiplication are closed for integers so it's trivial to add and multiply as many integers as you want - you don't need to model addition as function composition.  An example I'm thinking a lot about at the moment - Bezier curves are closed for translation, rotation, scaling but for perspective projections may yield rational Bezier curves. Rational Bezier curves are closed for all of those operations, but not for some interesting CAD operations such as offsetting. I didn't even know what implicit curves and surfaces are last week, but apparently there's some multivariate-rational-polynomial-implicit concept that's closed over just about everything interesting. The point being that there's often many different ways to combine values - not just one - depending on the intent and the abstraction. Also, in practice it's often necessary to force closure, e.g. by using approximations in the simple model rather than allowing generalization to a model that's more difficult/less efficient/impossible to work with.  TL;DR - I know the benefits of closed sets without needing to think about categories and arrows."
haskell,37km1l,ninereeds314,1 point,Fri May 29 05:49:42 2015 UTC,"Thanks for engaging my comment! I like your point about having different closed operations. I've only done thought experiments with composing websites (well, UIs in general) but it would indeed be wise to fit the solution to the problem, rather than the other way around."
haskell,37km1l,chreekat,-2,Fri May 29 14:50:32 2015 UTC,S to the P to the aghetti SPAGHETTI!
haskell,37km1l,I_Like_Spaghetti,1 point,Fri May 29 00:56:04 2015 UTC,"I have been thinking about the contrasts between these two things a bit recently, because I needed to optimize my program.  Consider the case when we need to generate incrementally the prefixes of a list. (Like inits.)  If we implement this with reverse lists, it seems obvious that the reverse list gets reused between the increments, and not re-computed each time we add an element.  If we think about a ""diff list"" implementation (which means it's a function which has the beginning of the list and a placeholder for the tail), then for each prefix, the whole structure of the beginning of the list must be passed through before we have a complete prefix.  Well, I haven't mentioned that the direction of the lists was not essential for me, so I was fine with using the reversed prefixes, which seems to save work when compared to the implementation with ""diff lists"", doesn't it?  Well, now I thought that when the resulting list (a prefix) is used, then it is also traversed completely, so the traversing of the structure which happens when we evaluate the diff-list seems not add much additional costs.  But it doesn't seem to be more efficient then doing concat to generate each prefix, is it?"
haskell,37km1l,imz,4,Fri May 29 08:05:24 2015 UTC,"Now that GHC's stack is unbounded, just killing the tail recursion might be fastest. I haven't tried changing a bunch of tail recursive code this way, but I'm curious to."
haskell,37km1l,twistier,1 point,Thu May 28 11:58:07 2015 UTC,What exactly is an unbounded stack? Does that mean it keeps growing until you run out of memory? Wouldn't that only be faster if the input is less than your memory?
haskell,37km1l,codygman,1 point,Fri May 29 05:14:05 2015 UTC,"The heap takes up memory too, but has more bookkeeping overhead associated with it."
haskell,37km1l,twistier,2,Fri May 29 11:44:35 2015 UTC,"Yes, probably.  In the pull request https://github.com/kolmodin/binary/pull/76 I say something along those lines, I'm currently a bit swamped and wanted to make sure to submit this bug."
haskell,37km1l,rostayob,6,Thu May 28 10:08:16 2015 UTC,I'm fearful for a /r/lolhaskell now.
haskell,37km1l,beerdude26,2,Thu May 28 12:39:15 2015 UTC,That's a vile subreddit and I heartily endorse staying far away from it.
haskell,37km1l,h3st,1 point,Thu May 28 17:25:10 2015 UTC,"Are there many of those apart from /r/lolphp and /r/loljs? (And there's sort of one for go, but it's /r/gobashing rather than /r/lolgo.)"
haskell,37km1l,h3st,2,Fri May 29 17:28:30 2015 UTC,Note that the interesting bit is in the B.append in prompt:  prompt :: B.ByteString -> Decoder a -> (B.ByteString -> Decoder a) -> Decoder a rompt inp kf ks =    let loop =         Partial $ \sm ->           case sm of             Just s | B.null s -> loop                    | otherwise -> ks (inp `B.append` s)             Nothing -> kf    in loop   Which ensureN repeatedly calls via demandInput.  We stumbled upon this when transferring binary files with cloudhaskell took minutes.
haskell,37km1l,rostayob,1 point,Fri May 29 17:27:30 2015 UTC,I'm confused by the example program. It seems unrelated. Does that mean you should never use Data.ByteString.Lazy.readFile?
haskell,37km1l,joehillen,1 point,Thu May 28 09:39:25 2015 UTC,I think it means they are fixing readFile...
haskell,37km1l,chreekat,1 point,Thu May 28 19:17:20 2015 UTC,That can't be right. binary depends on the bytestring library.
haskell,37km1l,joehillen,1 point,Fri May 29 00:55:28 2015 UTC,"Nice! I think maybe I was bitten by this, trying to use binary to transfer vectors of multiple gigabytes with vector-binary-instances. Performance on the receiving end was abysmal. Ended up with a hack that I'm not too pleased with. Perhaps this means I could delete some code. Will have to check."
haskell,37km1l,otulp,3,Fri May 29 01:05:36 2015 UTC,Could be worth trying an older version to identify when the regression was introduced. Original binary was specifically faster at loading such types. You could also just mmap bytestrings rather than parsing them...
haskell,37l9mz,gallais,5,Thu May 28 13:19:33 2015 UTC,"Very cool! I wanted to write something like this for λ-calculus but couldn't make an excuse for it. I'll probably also use this for demonstration purposes.  An equational reasoning assistant is on my wish list for Haskell. HERMIT is capable of doing what lambda prover does on Haskell Core via the GHC API. E.g. check out the rewrites available (also case, let, etc.) and reasoning functions. What remains is for somebody to make a handy UI for it and present it in an approachable way, like in Roman's post (most of the reading materials are about how we implemented it and less about using it). I'll end up doing that eventually, but I'd love it if someone were to step up and do it before me. In any case I will make Emacs bindings."
haskell,37l9mz,chrisdoner,3,Thu May 28 21:23:04 2015 UTC,An equational reasoning assistant is on my wish list for Haskell.   What about Agda?
haskell,37l9mz,chrisdoner,10,Thu May 28 21:33:25 2015 UTC,"If I wanted an equational reasoning assistant for Agda, then Agda would be an excellent solution, yes. ;-)"
haskell,37l9mz,kgadek,2,Thu May 28 21:46:53 2015 UTC,Liquid Haskell? (though I've never tried it… yet)
haskell,37l9mz,beerdude26,4,Fri May 29 14:38:26 2015 UTC,"Liquid haskell provides compile-time contracts, but it's not a full-blown reasoner (it uses one, though, I think)"
haskell,37l9mz,bgeron,2,Fri May 29 15:08:21 2015 UTC,"I've looked into similar stuff recently too, and nominal rewriting and contextual rewriting seemed relevant too; there's the Haskell Nominal Toolkit and CLRX. Couldn't get the latter to work; would love to try hnt sometime.   Would love to hear when you get something going."
haskell,37l9mz,Apterygiformes,2,Thu May 28 23:25:54 2015 UTC,"It looks really useful, but I find the format of your solutions kind of confusing :/"
haskell,37l9mz,aseipp,9,Thu May 28 14:56:15 2015 UTC,"It's a common and traditional way of manually showing equational reasoning steps for functional programs. It's the one I use :P The first time I saw this was in the Algebra of Programming. The basic form (for the casual readers) is:    before = {- name of rule -}   after   To state that 'before' can be turned into 'after' via the application of rule. And these can be chained, as in the examples. The version used by the prover tool is close but slightly different. It gets a lot easier to read if you practice it a little."
haskell,37l9mz,Apterygiformes,3,Thu May 28 15:51:25 2015 UTC,"Yeah sorry, i'm quite new to all this :) I've seen that form used before, it was more about the lambda expressions within the before and after stages. I'm looking through your Maybe Monad identity proofs and trying to understand the basic format. For instance, for the return function you have:  return x = λj.λn.jx   but I thought that return for Maybe could just be defined as the following:  return x = Just x   I'm not sure where the λn is coming from as you are already taking the argument from the left hand side in your example. Sorry for hijacking this post with my dumb questions :P"
haskell,37l9mz,jozefg,9,Thu May 28 16:25:01 2015 UTC,"In the lambda calculus there aren't data types, just functions. So Just has to be represented as a function. In the case of Maybe we just define the following thing  Nothing = λn. λj. n Just    = λx. λn. λj. j x maybe   = λx. λdefault. λuseVal. x default useVal   It turns out that you can represent all sorts of things (including algebraic types like maybe) quite slickly in the lambda calculus with church encodings.  So in fact return = Just is still the case, but since Just is itself a lambda term we ""unfold"" the definition so we can actually manipulate it. This is a little strange to read but that's how a lot of these proofs will work, unfold all the definitions and then repeatedly beta and eta reduce."
haskell,37l9mz,musicmatze,1 point,Thu May 28 16:35:46 2015 UTC,Can someone please ELI5 for a Haskell beginner?
haskell,37ky62,tailbalance,6,Thu May 28 11:35:31 2015 UTC,"IMHO that post should contain some references to deepseq (or directly to rnf). Those who know deepseq probably already know how to force a list, but those who don't won't know rnf.  Still, a nice application of foldr."
haskell,37km7e,drb226,14,Thu May 28 09:03:16 2015 UTC,yes  SPJ said:   I think the idea of allowing undefined variables to turn into holes is a good one; so I'll leave the ticket open for that too. link
haskell,37km7e,hamishmack,6,Thu May 28 12:40:01 2015 UTC,Is this an extraordinary coincidence?  https://mail.haskell.org/pipermail/haskell-cafe/2015-May/119818.html
haskell,37km7e,tomejaguar,3,Thu May 28 09:08:34 2015 UTC,"I just saw that as well; didn't realize someone mailed the cafe about literally the exact same thing.  I was chatting with a couple coworkers about it earlier. Not sure if it's entirely a coincidence, or if there is some indirect connection."
haskell,37km7e,tomejaguar,6,Thu May 28 09:34:53 2015 UTC,I came up with this idea randomly yesterday afternoon.  I can't remember what triggered it.  Maybe we both read something that set the spark of an idea.  How strange!
haskell,37km7e,tomejaguar,3,Thu May 28 09:37:47 2015 UTC,Actually maybe it was reading FP Complete's reports of people's difficulties using Haskell that made me think of it.
haskell,37km7e,xnyhps,2,Thu May 28 09:42:40 2015 UTC,"I got the idea from /u/mgsloan; I'm pretty sure it was yesterday or the day before when we were chatting about it. Today I hit a situation where I wished that I had this feature, so I started looking into it to see if it is something that is happening."
haskell,37km7e,gbaz1,6,Thu May 28 09:44:04 2015 UTC,"This would already work if all out of scope things start with an _: they are treated as typed holes and you can defer those with -fdefer-typed-holes. An extension that converts all unbound identifiers, not just those starting with _, into typed holes would therefore not be a large change."
haskell,37km7e,_AndrewC_,4,Thu May 28 12:16:40 2015 UTC,"This was proposed last year, in early april: https://mail.haskell.org/pipermail/haskell-cafe/2014-April/113373.html"
haskell,37l7pd,guaraqe,6,Thu May 28 13:04:13 2015 UTC,"Snap's web server is very robust and has excellent test coverage (here are reports for the upcoming release).  At my work we've been using it for more than two years to serve mission critical applications that handle more than two million hits per day.  We use two servers for redundancy, but a single server can handle that load without breaking a sweat.  There is a ""cabal freeze"" feature that creates a file that locks your project down to a specific version of every package dependency.  This is a great way to get build reproducibility.  Nix is also a great option in that department if you're willing to spend some time getting up to speed with it.  We are gradually making progress towards the goal of making Cabal more nix-like, but even though we're not quite to that point yet I very rarely have problems with the existing tools in my day-to-day work."
haskell,37l7pd,mightybyte,5,Thu May 28 14:07:48 2015 UTC,It seems that the Haskell community is very close to the Nix one. Do you think there is any technical limitation besides getting used to it?  Is there something that makes Snap more attractive than Happstack or Yesod?
haskell,37l7pd,stepcut251,5,Thu May 28 15:47:51 2015 UTC,I am working on a tutorial for deploying Happstack servers via nixops that you should find interesting. It will be posted here.
haskell,37l7pd,Tehnix,4,Thu May 28 13:16:18 2015 UTC,"When I read for the first time I tought nixops was a typo, but I decided to search, and it seems really close to what I was looking for.   For anybody reading: https://nixos.org/nixops/"
haskell,37j7v1,tonyday567,2,Thu May 28 00:49:27 2015 UTC,Porting scikit-learn is no small feat!
haskell,37j7v1,hiptobecubic,2,Thu May 28 01:41:34 2015 UTC,"I thing subhask is the start of a foundation for that sort of effort, and now would be the time to do it.  It could lead to stuff that was way out to the left of what is in the current toolkit."
haskell,37j7v1,ocramz,1 point,Thu May 28 03:48:31 2015 UTC,"So subhask tries to enforce algebraic relations through typeclasses, as far as I can tell. What are the foreseeable limitations of this approach? I.e. can we expect that one day hlint will warn us, in constant time, that e.g. a singular matrix cannot be inverted without significant loss of precision?"
haskell,37j7v1,IBMISHAL,3,Thu May 28 04:47:44 2015 UTC,I would be happy to join. My haskell skills are weak but machine learning skills are pretty good.
haskell,37j7v1,PokerPirate,13,Fri May 29 10:18:50 2015 UTC,"I'm the author of HLearn, and I would not recommend haskell for kaggle use.  There's basically 0 chance of a Haskell team being successful at these sorts of competitions.  The existing libraries simply do not support the kinds of models these competitions require."
haskell,37j7v1,bgamari,11,Thu May 28 01:53:38 2015 UTC,"Sounds like a challenge!  I'm less concerned about actually winning, then learning about haskell and it's limitations.  Exactly how, why and where haskell isn't the right tool for the job is an interesting enough question.    At the very least, haskeller know how to fail gracefully ;-P"
haskell,37j7v1,ocramz,4,Thu May 28 04:48:04 2015 UTC,"I don't think the problems you would encounter are limitations of the language itself but rather of its ecosystem. In particular, Haskell needs a better story for numerics, especially linear algebra. While linear and vector-space cover the low-dimensional case  pretty nicely, these really don't scale to high-dimensional problems where representational matters (boxing, for instance) become important. hmatrixprovides some tools but I've found that code written in the style that it tends to push you towards is more concisely written in Python with little lost in terms of robustness (YMMV, of course).  There are efforts to improve this situation: /u/cartazio has been steadily working on various aspects of this problem in numerical, /u/acow has his lovely Frames, etc. That being said, even once the foundations of high-dimensional linear algebra are in place the Haskell community has a lot of work to do before it can compete with libraries like scikit-learn and the variety of R code floating around the web. While I haven't yet participated in a Kaggle challenge myself, I can imagine that having easy access to the breadth of tools offered by these ecosystems would be an incredible advantage."
haskell,37j7v1,Tekmo,3,Thu May 28 05:25:19 2015 UTC,"/u/PokerPirate , don't be so negative! We should try to break down the requirements instead; many continuous-valued inference problems rely on either sampling or variational approximations (I mean, the Bayesian marginalization integrals can be solved in either way). I've seen a few interesting Hs examples so far, e.g. /u/jaredtobin ' s Hasty Hamiltonian sampler and idontgetoutmuch 's work. The variational approximations instead require large-scale optimization codes, and could perhaps benefit from binding legacy codes (I'm thinking e.g. about something from the Coin-OR or NLopt suites). The Hs layer could definitely shine in coordinating control and isolating effects. Let's get this conversation going!"
haskell,37j7v1,PokerPirate,5,Thu May 28 11:48:36 2015 UTC,"Okay, so what can we do to fix it?"
haskell,37j7v1,Tekmo,1 point,Thu May 28 17:15:14 2015 UTC,"The biggest pain point for me is the existing linear algebra libraries.  There's some good raw bindings, but there's nothing that's fun to use in the same way that matlab's fun to use.  Part of the reason for my subhask library is to make linear algebra more haskelly, and hence more fun to use.  But like I said in another post, I spend less than 5 hours per week on this.  So progress is much slower than other libraries that have full time developers and already have a low-level infrastructure in place."
haskell,37j7v1,PokerPirate,2,Thu May 28 15:01:28 2015 UTC,I'm really surprised nobody has just wrapped vector in a matrix API
haskell,37j7v1,Tekmo,2,Thu May 28 17:30:37 2015 UTC,How is that not what hmatrix is?
haskell,37j7v1,PokerPirate,2,Thu May 28 18:15:03 2015 UTC,I thought hmatrix was backed by blas/lapack
haskell,37j7v1,Tekmo,1 point,Thu May 28 18:44:04 2015 UTC,Pretty sure it is. I guess I don't understand what you meant in the gp.
haskell,37j7v1,wrvn,1 point,Thu May 28 18:55:00 2015 UTC,"Sometimes I just want to treat a vector like a matrix without bringing in BLAS/LAPACK.  Also, hmatrix uses libgsl, which is GPL licensed.  I don't care about the GPL license but I know that others do"
haskell,37j7v1,sseveran,2,Thu May 28 18:59:15 2015 UTC,As of version 0.16 hmatrix is split onto 2 packages: hmatrix and hmatrix-gsl. Hmatrix itself only depends on blas and lapack now. Also licence changed from GPL to BSD3 so its more friendly to commercial usage i guess.
haskell,37j7v1,mishach,3,Thu May 28 19:01:45 2015 UTC,"We typically use C libraries to build the actual models, but our ML pipeline is mostly haskell otherwise. For large datasets we use spark to preprocess the data into something manageable. I see no reason for a haskell team would have to use nothing but pure haskell. FFI to the rescue."
haskell,37j7v1,PokerPirate,2,Fri May 29 09:55:15 2015 UTC,Are there any machine learning algorithms that could be implemented in Haskell better than any other language? (Ie Lazy machine learning maybe?)
haskell,37j7v1,ocramz,1 point,Thu May 28 19:59:58 2015 UTC,"Lots of machine learning researchers think probabalistic programming languages are the future, and I think Haskell has a strong chance to shine in this area.  That's the main direction that I'm hoping to take HLearn in the future."
haskell,37j7v1,jaredtobin,1 point,Thu May 28 07:12:16 2015 UTC,Have you seen Hakaru and PFP ?
haskell,37j7v1,PokerPirate,1 point,Thu May 28 14:28:31 2015 UTC,"One could imagine a Bayesian model doing alright.  The main challenge would really be coding up the inference algorithm, which for a one-off thing isn't necessarily too demanding.  Iain Murray did quite well in 2012 using a Bayesian model and slice sampling, though I'm not sure how intense the competition has since become."
haskell,37j7v1,jaredtobin,1 point,Fri May 29 10:11:56 2015 UTC,My experience is that coding inference engines are incredibly difficult to do well.  That's the whole motivation behind probabilistic programming.
haskell,37j7v1,ocramz,1 point,Thu May 28 07:40:15 2015 UTC,Yeah but I mean we're not talking about a general sampling backend for a PP language here.  Just code up a working implementation of MH/slice sampling/HMC/whatever and run it on a posterior for awhile.  Same thing statistics students have been doing for decades. :)
haskell,37j7v1,bartavelle,1 point,Thu May 28 14:30:01 2015 UTC,"Though I.Murray's code is all Matlab and R, as far as I can see."
haskell,37j7v1,PokerPirate,1 point,Thu May 28 19:41:21 2015 UTC,"The existing libraries simply do not support the kinds of models these competitions require.   Why aren't they implemented ? Because of lack of time, or because the library authors use cases is fundamentally different from the competition ?"
haskell,37j7v1,ocramz,5,Thu May 28 17:16:40 2015 UTC,"There's actually quite a few models implemented in HLearn, they just don't have an interface/documentation yet that's user friendly enough that I'd recommend other people use them.  Maybe one day.  Scikit has about 10 full time developers plus hundreds more part time contributors.  HLearn has me working less than 5 hours/week on it :)"
haskell,37j7v1,PokerPirate,3,Thu May 28 09:30:43 2015 UTC,"Mike, I've seen your work on HLearn, very inspiring, but the documentation is quite inaccessible to anybody not having quite some category theory background! E.g. I really don't get why training with data should be invertible, or statements such as ""Functor <-> fast simple preprocessing of data;  Monad <-> fast complex preprocessing of data"". It sounds incredibly interesting but I really can't see the connection."
haskell,37j7v1,PokerPirate,1 point,Thu May 28 14:27:22 2015 UTC,"I've intentionally stopped producing documention over the past year or so to discourage people from using the library :)  At this point, it's just meant to be a playground for me to discover what the ""right"" interface is for learning algorithms.  That means breaking changes everytime I touch the code.  Which means lots of frustration for anyone who tries to use it (and lots of frustration for me trying to help them).  That said, I have a paper at this year's ICML that uses some of the library code.  Basically, the paper shows a faster way to do nearest neighbor queries, and my proof of concept implementation is in haskell.  So sometime over the next month or two you can expect better documentation on at least this aspect of the library."
haskell,37j7v1,Platz,2,Thu May 28 17:24:58 2015 UTC,"I'm sorry Mike, but your efforts at discouraging usage hasn't been successful :-)  HLearn is one of the most starred and forked haskell libraries out there, only beaten by the giants like pandoc, haykll & lens.  There's a lot of pent up demand and, however scrappy, it's has a high quality kernel of what's needed. Who knows what the right interface is yet, but I'm sure that practical usage by others will help to discover that."
haskell,37j7v1,PokerPirate,1 point,Thu May 28 18:07:48 2015 UTC,The beauty of open source :)  I do wish I had more time to document and polish things though...
haskell,37j7v1,ocramz,1 point,Thu May 28 22:36:53 2015 UTC,"My understanding is that HLearn's philosophy is such that it will only ever target a small subset of the kinds algorithms used in machine learning  ""This interpretation of machine learning is somewhat limiting in that not all models have obvious algebraic structure"" [https://github.com/mikeizbicki/HLearn]"
haskell,37j7v1,JustFinishedBSG,1 point,Fri May 29 00:37:54 2015 UTC,"The scope has grown quite a bit, and my longterm goal is to support any machine learning model."
haskell,37j7v1,PokerPirate,1 point,Thu May 28 20:49:54 2015 UTC,"It would be already cool if one could e.g. derive KNN from expectation maximization, rather than re-building ALL THE ALGEBRA from first principles."
haskell,37jwip,begriffs,2,Thu May 28 04:02:24 2015 UTC,"Seems useful. Can it connect to hive? I'm typically extremely uncomfortable storing any data on an analyst's local computer, so I'd prefer having the computation module be detached from the UI."
haskell,37jwip,hastor,3,Thu May 28 11:36:12 2015 UTC,"Thanks! Wagon currently connects to Postgres, Redshift, and some other similarly flavored PG databases.  We're likely adding MySQL next then possibly Hive (so many fun ones to choose from!).  Today, the data is local between the cluster and the desktop tool for analysis-- many of our users asked have the tool work without a 3rd party hosting the data or to host it internally.  For sharing, we use our backend web services (or can later deploy our service behind firewall).  In the hosted case, we could have the data never touch the user's local machine.  For us, that's a bit down the road.  Good idea though.  Would love for you to try out the tool and get your feedback.  We have a hosted test database for you to play with."
haskell,37iwlj,FPguy,8,Wed May 27 23:27:54 2015 UTC,"Wow. I've never had this problem. If my program ever segfaults I'll be done for the day, but it hasn't happened. I use trace a lot and -- maybe it's a failure of imagination -- I can't imagine what would be more helpful."
haskell,37iwlj,rdfox,4,Thu May 28 02:53:51 2015 UTC,"Where do you trace? In a simple program you might have 5 different places to check, in a large on you may have 100. It's just messier and slower imo."
haskell,37iwlj,vnjksd,2,Thu May 28 04:16:26 2015 UTC,How do you repeat a single step debugging run? It is just a giant waste of time to tell the debugger over and over again which bits are interesting to you IMO as you change parts of the code to see which differences they make.
haskell,37iwlj,Taladar,1 point,Thu May 28 13:48:40 2015 UTC,http://en.wikipedia.org/wiki/Breakpoint
haskell,37iwlj,y000001,1 point,Fri Jun 12 06:50:26 2015 UTC,"Breakpoint:       In software development, a breakpoint is an intentional stopping or pausing place in a program, put in place for debugging purposes. It is also sometimes simply referred to as a pause.  More generally, a breakpoint is a means of acquiring knowledge about a program during its execution. During the interruption, the programmer inspects the test environment (general purpose registers, memory, logs, files, etc.) to find out whether the program is functioning as expected. In practice, a breakpoint consists of one or more conditions that determine when a program's execution should be interrupted.    Image i - The debugging interface of Eclipse with a program suspended at a breakpoint. Panels with stack trace (upper left) and watched variables (upper right) can be seen.     Interesting: BreakPoint | Breakpoint (demo party) | Synovial sarcoma, X breakpoint | Breakpoint (novel)   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
haskell,37iwlj,autowikibot,1 point,Fri Jun 12 06:50:41 2015 UTC,"Ah, yes, the poor substitute for a print (which has the full power of the language after all and is simpler) one has to use when dealing with bugs that are no longer reproducible when changing the program in minor ways."
haskell,37iwlj,Taladar,1 point,Fri Jun 12 21:53:12 2015 UTC,"What a bleak imagination.  :)  Consider getting an internship, you could definitely gain some great experience and learn a lot too.  It's usually interns that I see using print statements to debug professional software, or bad hires...  https://plugins.jetbrains.com/oldimg/screenshots/org.intellij.clojure_2566.png"
haskell,37iwlj,y000001,5,Fri Jun 12 07:05:40 2015 UTC,I do remember seeing and playing with a tool that represented code at runtime as a graph of values and thunks that could be forced by clicking on the appropriate node. It was killer and it sounds like what a lot if people are looking for. What happened to it?
haskell,37iwlj,hiptobecubic,6,Thu May 28 03:41:24 2015 UTC,"Are you thinking of ghc-vis, by any chance?"
haskell,37iwlj,adamgundry,3,Thu May 28 07:09:18 2015 UTC,Would such a thing scale to large systems though?
haskell,37iwlj,Fylwind,3,Thu May 28 03:56:38 2015 UTC,I don't see why not. It has to have a web UI to work on the data center though.
haskell,37iwlj,hastor,7,Thu May 28 11:19:23 2015 UTC,The biggest travesty about the issues with reasoning about laziness is that it could be fairly easily addressed. GHC knows how lazy each piece of code is. All we would have to do is export that and import it into something like ghc-mod in vim. We could then visualize how strict  any piece of code is. With background compilation this could be updated as we type.
haskell,37iwlj,sseveran,2,Thu May 28 17:05:09 2015 UTC,"Laziness usually isn't a problem in 90% of the code though, it only becomes a problem in those few long-lived spots of our programs. How would you visualize something of low importance that needs annotations on almost every bit of code (since the compiler does not know which parts are long-lived in general)."
haskell,37iwlj,Taladar,1 point,Thu May 28 19:16:09 2015 UTC,The issues we have troubleshot tell me that the long livedness isn't the issue. Its that small changes in code can drastically alter the laziness of pieces of code. The compiler knows how lazy the code is and it would be great if it would share that information.  For issues with longevity a profile guided optimization like system could dump out thunk lifetimes.
haskell,37iwlj,sseveran,1 point,Tue Jun 2 21:41:11 2015 UTC,"Well, as I see it there are three common cases.  The thunk is not evaluated at all. This is usually not a problem since it only happens when the result is not needed (except possibly in benchmarking).   The thunk is evaluated only after accumulation of a large number of thunks. These are the long lived places I was talking about which lead to many space leaks. In a short lived place it can not accumulate anything for a time long enough to produce lots of thunks.  The thunk is evaluated in the wrong place. This often happens when worker threads do not properly force thunks to be evaluated before handing them back to a thread doing some sort of operation on all the results. It usually kills parallelism since all results are evaluated in the one thread handling the results."
haskell,37iwlj,Taladar,3,Wed Jun 3 06:22:37 2015 UTC,"Haskell needs what is often called a side car, a set of monitoring, profiling, and debugging tools that can be bolted on to any production system. The EKG package, profiling, thunk visualization, a repl, performance counters etc."
haskell,37iwlj,hastor,1 point,Thu May 28 11:24:09 2015 UTC,"what's monitoring mean here (for a language runtime), that profiling/debugging doesn't cover?"
haskell,37iwlj,sambocyn,2,Sun May 31 01:11:24 2015 UTC,Use in a production environment where you can not recompile with different annotations and rerun the program worth different options or stop it unless absolutely necessary in general.
haskell,37iwlj,Taladar,2,Wed Jun 3 06:12:33 2015 UTC,"Can I, using a web interface, connect to a haskell process and get a CPU profile, a heap profile or anything at all?"
haskell,37lqld,shellraptor,1 point,Thu May 28 15:24:05 2015 UTC,I have a vague feeling that this book is similar to Haskell Financial Data Modeling and Predictive Analytics or  Haskell Data Analysis Cookbook.
haskell,37lqld,mishach,1 point,Fri Jun 12 06:54:09 2015 UTC,Hi. I can promise you that this book is completely different from Haskell Data Analysis Cookbook. I reviewed the cookbook. I wrote this book.
haskell,37legw,cuberoo,5,Thu May 28 13:57:06 2015 UTC,What part of the world?
haskell,37legw,jmite,0,Thu May 28 13:59:29 2015 UTC,University of West Of England United Kingdom
haskell,37legw,jaybee,2,Thu May 28 17:08:41 2015 UTC,"You should say who will be supervising it too and name the research group, link to their work and so on..."
haskell,37iqw9,rdfox,13,Wed May 27 22:48:05 2015 UTC,"That doesn't sound like such a high cost, since you'll have to recompile all your packages with your new version of ghc anyway.  That being said, I frequently use brew switch to switch between ghc 7.8 and 7.10, and I can't say I have had much trouble with ghc. Cabal is a bit confused when it finds a sandbox from a future version though."
haskell,37iqw9,gelisam,3,Wed May 27 22:58:18 2015 UTC,Did you encounter a problem where ghc piles all of your packages in the same directory and then gets confused when linking?
haskell,37iqw9,gelisam,2,Wed May 27 23:05:08 2015 UTC,"No, doesn't ring a bell."
haskell,37iqw9,kqr,2,Thu May 28 00:15:08 2015 UTC,Are you not using sandboxes?
haskell,37iqw9,Crandom,3,Thu May 28 07:19:06 2015 UTC,I would recommend looking at nix if you have to switch versions a lot. There some up to date documentation for nix Haskell stuff with a tutorial by /u/ocharles.
haskell,37iqw9,ocharles,1 point,Thu May 28 01:43:34 2015 UTC,"If you find yourself regularly switching compiler versions, cabal2nix now automatically adds a compiler attribute, so you can change compiler on the command line."
haskell,37iqw9,Crandom,2,Thu May 28 06:47:58 2015 UTC,"Awesome. My one quibble is that binary caching doesn't seem to be enabled on OS X for the new haskell-ng framework, so installing cabal2nix/anything takes forever to install. Do you know if this is a known problem?"
haskell,37iqw9,gelisam,1 point,Thu May 28 12:13:38 2015 UTC,"My understanding is that nix allows deterministic installs by remembering the hash of all the dependencies. From your comment, I can infer that it also allows multiple versions of everything to be installed. However, my usecase is to make sure that a library or a program compiles with both ghc 7.8 and ghc 7.10, which means that I want a different set of dependencies for the same target. Would nix still be useful for that purpose?"
haskell,37iqw9,Crandom,2,Thu May 28 12:22:26 2015 UTC,"Yes, you would just need two different .nix files which target different versions of GHC (or have one and switch the ghc version). Both versions of GHC and all the dependencies built for you library by each ghc would live side-by-side and not interfere with each other.   Edit: In fact, reading http://lists.science.uu.nl/pipermail/nix-dev/2015-May/017271.html, you can now just pass on the ghc version to use as an argument to nix-shell/nix-build for the nix expressions generated by cabal2nix."
haskell,37iqw9,stepcut251,1 point,Thu May 28 12:31:22 2015 UTC,nix would be stellar for that. You could even use hydra as a continuous integration server to test again multilpe GHC versions automatically.
haskell,37iqw9,tonyday567,10,Thu May 28 12:59:14 2015 UTC,"I did a clean install with brew a few weeks ago and it's great with a few extra workflow steps.  Commit to always using sandboxes. cabal sandbox init is your friend.  To speed up adhoc builds, start a common sandbox and use this together with the stackage nightly constraints.  eg  cd junk-box cabal sandbox init cd ../new-project cabal sandbox init --sandbox=../junk-box/.cabal-sandbox/ wget https://www.stackage.org/nightly/cabal.config   Cabal hell is a fading memory."
haskell,37iqw9,k-bx,3,Thu May 28 00:04:16 2015 UTC,"Usually, you can just remove ~/.ghc, but not ~/.cabal."
haskell,37iqw9,cartazio,3,Thu May 28 06:34:18 2015 UTC,"Just don't use brew for Haskell tooling.  Maybe it's gotten better in the past few months, but that said, historical experience says just don't use brew for Haskell."
haskell,37iqw9,maxigit,2,Thu May 28 17:24:29 2015 UTC,"No, I don't dare. I've done it once as well and it was a disaster. To upgrade I'll probably try docker or Nix (except I can't manage to install Nix on my mac)."
haskell,37iqw9,datalligator,2,Thu May 28 12:57:06 2015 UTC,"I use cabal sandboxes for everything including binaries (Haskell utilities),  (I can spare a few gigs for peace of mind) and brew update ghc  from 7.8-7.10 has been no problem at all."
haskell,37iqw9,ReinH,2,Thu May 28 13:07:07 2015 UTC,Did it. Removed all the things. Reinstalled all the things. Was worth it.
haskell,37iys0,mightybyte,1 point,Wed May 27 23:43:23 2015 UTC,The resolution is too low to see the codes on screen. I'm enjoying it anyway. This guy is a good lecturer.
haskell,37ggb0,jleitgeb,9,Wed May 27 13:18:44 2015 UTC,"Yes, typed holes are GOLD! Use them all the time.  However, the reason people like to run their incorrect program is often because they want to step through or get a stack trace. And yes, you could step through in GHCi as well (I've never done it though). What is really the main benefit of running an incorrect Haskell program? Maybe you can run your test suites and see how much still works?"
haskell,37ggb0,mallai,21,Wed May 27 15:49:28 2015 UTC,Typically the purpose of running code with type errors deferred is to test the refactoring you just did on a small component of the system before refactoring the rest of the system.
haskell,37ggb0,c_wraith,14,Wed May 27 16:23:30 2015 UTC,"Yes, this is the usage that I was thinking about in the post. Based on tweets and recent articles I've read, it seems like many people think this is a benefit of dynamically-typed languages, when it's something that can be done just as easily in a statically-typed language like Haskell."
haskell,37ggb0,Kaidelong,1 point,Wed May 27 17:41:03 2015 UTC,"If you are planning to fix all warnings anyway, you can just keep it enabled. That might have been a better default."
haskell,37ggb0,mallai,1 point,Wed May 27 18:24:24 2015 UTC,"Not necessarily because people usually fix errors first and then warnings. With this option, it's harder to prioritize."
haskell,37ggb0,Tekmo,10,Thu May 28 01:53:34 2015 UTC,"Note that the purpose of types is to provide a compile-time projection of your program's run-time behavior.  The more powerful a type system, the less you need to run the program to debug what's wrong.  You can instead use the types to teach the compiler what the program should do and the compiler can inform you where your program deviates from your expectations."
haskell,37ggb0,mallai,6,Wed May 27 16:06:01 2015 UTC,"Absolutely.   What I am asking about is like @c_wraith's comment below - the typical usages of deferred type errors.   In dynamically-typed languages, running the program is the main means of debugging - you inspect the state of the system, step through, etc. In Haskell, the need for doing this is greatly diminished thanks to the types. But still there are cases when you might quickly check something, run a test case, etc. before you make the rest of the program consistent with the breaking change."
haskell,37ggb0,Sawady,2,Wed May 27 16:28:41 2015 UTC,"What a very good answer. But I think it depends on how do you like to think about your programs. Many people want to see the exact behavior of some part of their programs.  I prefer better type systems though, because too much time is spent in the discovery of runtime errors."
haskell,37j1tr,Spewface,8,Thu May 28 00:05:57 2015 UTC,"Sure, now one will have to count the number of $s and =s to understand what the code is supposed to do.   mx >>=== (return .:: func4)   How many will spot the typo?"
haskell,37j1tr,mmaruseacph2,2,Thu May 28 01:12:46 2015 UTC,How about >>=3 then?
haskell,37j1tr,gallais,3,Thu May 28 13:23:58 2015 UTC,I was hoping this would work for evil reasons:  >>=²
haskell,37j1tr,codygman,2,Fri May 29 07:10:40 2015 UTC,I'll add it :)  EDIT: I actually can't :. It's not an infix symbol.
haskell,37j1tr,mmaruseacph2,2,Thu May 28 13:51:06 2015 UTC,Not a valid operator.
haskell,37j1tr,bss03,1 point,Thu May 28 16:54:46 2015 UTC,"That might work in Agda, but here in Haskell we require our operators to be entirely composed of symbols -- no alphanumerics allowed."
haskell,37j1tr,rdfox,2,Thu May 28 19:31:41 2015 UTC,"Well, if you count the number of ='s to be the depth at which mx :: m a's a is applied, you can see that >>==== applies a to the fourth argument of the RHS. You could also do:  mx >>= \d -> return $ \a b c -> func4 a b c d   For the same purpose."
haskell,37j1tr,Crandom,7,Thu May 28 01:21:28 2015 UTC,This made me think. I guess your solution is good but avoiding functions with four parameters would be better.
haskell,37j1tr,PM_ME_UR_MONADS,5,Thu May 28 03:04:23 2015 UTC,This looks super confusing.
haskell,37j1tr,emarshall85,-1,Thu May 28 12:39:10 2015 UTC,"well, at least it's not Lisp! :v  /me dodges the tomatoes"
haskell,37emp2,hamishmack,26,Wed May 27 01:48:36 2015 UTC,"New in this release:   Support for GHC 7.10.1. Uses Gtk+ 3.16 on Windows and OS X. GtkInspector works on all platforms (Ctrl+Shift+I). Updated build instructions (OS X and Windows builds are fairly easy now). Underlining of doctest failures. Lots of bug fixes.   Things that are new since 0.14.0:   Support for using GHCJS. GtkInspector. Web Inspector pane (right click on output pane to bring it up). Uses the WebKit Web Inspector. Cabal commands executed by Leksah show up in the log pane.   I remain optimistic about the future of Leksah.  GTK+ has improved hugely in the last couple of years.  Also WebKitGTK+ and GHCJS mean integrating tools into Leksah will be easier than ever.  A great many people contribute (mostly indirectly) to Leksah, it is much appreciated and I hope that number will grow.  As always, please help!  Hop on #leksah or file and issue, even if it is just  to vent your displeasure with Leksah (every bug report helps).  Here are some fun ideas you might like to try working on if you are looking for a way to contribute to Leksah:   Try using Leksah and fix the thing that annoys you most about it. Figure out if/how ide-backend can be used in Leksah. Create an XMonad like manager for <div> based panes. Ideally it would work for both GTK+ and GHCJS. Migrate existing UI components from Gtk+ to GHCJS. Anything GHCJS based and then add support in Leksah for it. GHCJS based scripting (make it work for Leksah like ELisp for Emacs). Improve Yi integration.  What we have is unusably incomplete. Add GHCJS backend for Yi (replacing the Pango one). Improve JavaScript based editor support (currently only CodeMirror is supported and not very well). Add support for using SoH and/or FPView within Leksah.   If you are interested in any of these please let me know and I will do what I can to help you get started.  Hamish  PS. I am kind of sad Eclipse FP has stalled for now and I hope it restarts soon.  Integrating Haskell into existing IDEs (especially those with large user bases) will help sell Haskell to the world.  I wish JP well and I am sure he will find something interesting and challenging to work on next."
haskell,37emp2,SeriousJope,4,Wed May 27 01:55:17 2015 UTC,Thanks!  I have tried leksah in past with not very good success. This seems to have changed! It is not far from being a serious ide for haskell.
haskell,37emp2,co_dan,2,Wed May 27 06:28:06 2015 UTC,"Wow, nicely done!"
haskell,37emp2,Enamex,1 point,Mon Jun 1 17:08:48 2015 UTC,Looks great!  How's performance? Any perf.-critical bug fixes?
haskell,37emp2,paf31,8,Thu May 28 16:03:37 2015 UTC,"Very exciting, especially GHCJS support :) But for me on MacOS, the main window loads (after the setup dialog) and then immediately closes without any error message."
haskell,37emp2,RedLambda,6,Wed May 27 04:24:33 2015 UTC,I suspect this may happen if Leksah can't find GHC in your PATH.  Please open a terminal and run:  /Applications/Leksah.app/Contents/MacOS/Leksah   If that works then please try adding something to set your PATH in your ~/.profile file.
haskell,37emp2,Categoria,8,Wed May 27 04:36:16 2015 UTC,(Animated) screenshots or some screencast would be nice to have (unless I missed them)!
haskell,37emp2,AshleyYakeley,6,Wed May 27 08:06:51 2015 UTC,"There is only this for now, but it would be nice to have more."
haskell,37emp2,AshleyYakeley,5,Wed May 27 08:09:23 2015 UTC,"I'm really glad about the improved build instructions for OSX. Anytime I managed to make $ cabal install leksah succeed before left me in a mixed state emotionally. On one hand, I'm glad it finally worked. On the other, I should have spent my luck at vegas instead. However, it's a pity the instructions are macports based rather than homebrew based.  Also, how feasible would it be to have leksah on stackage?"
haskell,37emp2,bgamari,3,Wed May 27 04:37:14 2015 UTC,"Sadly Homebrew does not have a recent WebKitGTK+ yet (correct me if I am wrong).  I would be happy to have leksah in stackage.  I imagine the first step is to get the other Gtk2Hs packages added (I think cario is already in).  I don't use stackage myself, but only because it might hide breaking changes in hackage that I should know about and fix in Leksah.  We should really be relying more on travis-ci for that."
haskell,37dv8y,sjflanders,14,Tue May 26 22:24:09 2015 UTC,"I've done a bunch of things, but the one I get the most use out of by far is a little database to keep track of my books (read-only demo, source).  It's actually gone through a few iterations. It was the first non-trivial thing I wrote in Haskell when I was first starting out, although it used Yesod back then. After a little while I wanted to extend it, but had no idea how to change things, so I gave up and rewrote it in Python. After becoming significantly better at Haskell over a few years, I rewrote it using a little web framework I'd written to produce something else. Most recently, I have dropped that framework as an explicit dependency, and now it's just running on top of wai and web-routes."
haskell,37dv8y,Barrucadu,4,Tue May 26 22:36:23 2015 UTC,"This is awesome! Actually, I'm currently learning Haskell and something like this is my first project I just started:  I want to develop a web app where I can categorize things and rate them. My motivation is that I started watching animes but I cant either remember their names nor whether I liked them or not. So I want to write something where I can write down notes on them and add a simple rating for them. And I want to make it a bit more generic, so I can have several categories, so also books, movies, series, recipes and so on can be rated with the app.  And, of course, it will be running locally only, because I'm not a huge fan of putting such stuff online.  So thanks again, I guess your codebase will be kind of a reference implementation for my idea!"
haskell,37dv8y,musicmatze,2,Wed May 27 15:55:18 2015 UTC,Oh wow that is great. Thanks for sharing!
haskell,37dv8y,shishkabeb,3,Tue May 26 23:26:01 2015 UTC,This is very cool. I'm definitely going to examine your source code as soon as i have a free minute.
haskell,37dv8y,onmach,12,Wed May 27 00:30:17 2015 UTC,"I wrote a weight lifting app that kept track of and determined what weights I should do and at how many reps and when to deload due to lack of progress.  It also determined how I should place the plates on the bar so that I do the minimal amount of plate switching as my workout progressed.  Not user friendly at all, but after using it for four months I was lifting more than I ever had before."
haskell,37dv8y,ephrion,2,Wed May 27 15:40:13 2015 UTC,I had a very similar idea for a project I'm working on! Would you mind sharing your code?
haskell,37dv8y,onmach,1 point,Sat May 30 17:18:40 2015 UTC,"It is very user unfriendly and relies on yaml files not in the repository, and was highly tailored to the workout I was doing at the time, but you might be able to salvage some of it.  https://github.com/mindreader/iron-tracker"
haskell,37dv8y,Hrothen,9,Sun May 31 00:45:58 2015 UTC,"It's pretty ugly, but I wrote a little utility for dwarf fortress players a while ago. It turns images into quickfort blueprints."
haskell,37dv8y,jaseemabid,8,Wed May 27 01:23:39 2015 UTC,I'm working on a little lisp interpreter and a torrent client
haskell,37dv8y,pigworker,7,Wed May 27 10:58:57 2015 UTC,"I implemented a custom markdown dialect that I could use to write lecture notes with embedded exercises for my first-year hardware class. Assessing the exercises usually involves parsing and interpreting some sort of formal syntax while we're about it. I mainly used Network.CGI. It's a lot clunkier than it should be, but hey, I wrote it in no time flat and it stays up."
haskell,37dv8y,rdfox,2,Wed May 27 20:50:38 2015 UTC,Cool. I would love to learn from your hardware class. Did you put some lecture notes online?
haskell,37dv8y,pigworker,3,Wed May 27 23:48:38 2015 UTC,I'm afraid that (exactly because visiting those pages can induce significant computation) my material is restricted to users from my own department. I'd love to figure out how to make it available just as cleanly to single-session or cookie-accepting visitors.
haskell,37dv8y,rdfox,3,Thu May 28 00:07:02 2015 UTC,I would be grateful just to read your lecture notes (statically without any code) to know what kinds of things freshmen know about functional hardware design that I don't. I got involved with haskell hoping to do hardware design but things like Clash and Kansas Lava take wizard levels of type-level programming knowledge which I wasn't prepared for. I'd like to get back to it now with a little more experience under my belt.
haskell,37dv8y,pigworker,4,Thu May 28 00:19:00 2015 UTC,"Don't get your hopes up. I'm teaching hardware in a degree programme which won't do functional programming seriously until third year. It's very basic stuff.  Having said that, I'm not sure what is the easiest way to facilitate your wishes. The url where the material lives will demand departmental authentication. However, this repo gives a flavour of what I get up to."
haskell,37dv8y,bananu7,5,Thu May 28 00:40:07 2015 UTC,"I created a multimedia/game framework which (surprise surprise!) isn't based on FRP. Planning to get back to it as soon as I have some time. Contributions, patches and feature requests welcome.  https://github.com/bananu7/Hate"
haskell,37dv8y,rdfox,3,Wed May 27 11:24:22 2015 UTC,"Cool. I dream about such things and have looked at a lot of game engines. I wonder what's your master plan? Lots of frameworks bind various C++ libraries to get sound, 3d, physics and scripting. But binding C++ in Haskell is not as fun as it sounds. For scripting there's HsLua. But it seems like your project is something of a statement against Lua. I'd like to use a Haskell interpreter for scripting. For that there's two bad options:   The ancient and unmaintained (but still serviceable) Hugs interpreter. Hint. However it seems no one knows how to actually ship a Hint interpreter. You basically have to also ship Ghc with your game."
haskell,37dv8y,bananu7,3,Wed May 27 23:42:17 2015 UTC,"But it seems like your project is something of a statement against Lua.    Certainly not. I really, really like Lua and Love2D; the language's flexibility can be both its strength and a weakness though.    I wonder what's your master plan?   It's all in my GitHub milestones really. I'd like 0.2 release to represent something in development, but actually usable. That means features, niceties, the like. If it catches on, if people will want to use it, then it's the incentive to push towards 1.0 - better docs, better tests, more stability.   Lots of frameworks bind various C++ libraries to get sound, 3d, physics and scripting.   I don't need any C++ library. I use GLFW for windowing (has a nice high-level haskell binding). We have plenty of usable sound libraries for haskell. I don't need any help with the 3D part because I actually use OpenGL directly (though my main focus is on 2D right now) - that's more flexible and performant if needed, which can be a strong selling point. If I ever need physics, I'm sure I could use something with a C API like Box 2D. Even libraries like SFML present ready-to-use C wrappers which can be adapted via Haskell's FFI  Scripting is something I'd like to respond to separately. Shipping GHC is one option (which, sans the bigger binary, isn't really that unrealistic). I have a half-abandoned project of a pure Lua VM that could also be used, but... to be honest, now that I started using Haskell, I'm less of a fan of a dual-language design. Haskell is flexible enough to cover both the internals of the framework as well as the game logic. Surely, you lose the ability to load code dynamically, but at least for debugging purposes this can be circumvented by dynamic module loading, and you can just ship a ready-made version of your app. One goal of the scripts is to make sure additional logic changes won't crash the game, but this can be guaranteed with Safe Haskell as well if you structure your code properly.  If you have any additional questions, let me know. This is just my personal opinion on the topic :)"
haskell,37dv8y,dmytrish,7,Thu May 28 12:11:38 2015 UTC,"I tried to reimplement git in haskell: https://github.com/EarlGray/omit  Currently it can commit, diff, log, status itself (and a few more complicated repositories) and do some other ""plumbing"" commands like ls-files, verify-pack, config. It took ~415 sloc to reimplement this functionality."
haskell,37dv8y,Fylwind,2,Thu May 28 10:16:35 2015 UTC,Those are some very dense 415 lines of code though!
haskell,37dv8y,davecompton7,5,Thu May 28 19:53:08 2015 UTC,I wrote a browser based solitaire game ( compiled using haste ).  Follow this link to play it and for more information:  http://dc25.github.io/myBlog/haskell/haste/2015/05/08/a-solitaire-game-written-in-haskell.html  Here's a link to the github repository:  https://github.com/dc25/solitaire
haskell,37dv8y,hdgarrood,5,Wed May 27 00:40:20 2015 UTC,"I tried to play this but I wasn't able to; I think it's failing to load on my machine because github appears to be forcing https now, and Chrome is therefore refusing to load d3 over plain http."
haskell,37dv8y,davecompton7,2,Wed May 27 12:10:15 2015 UTC,"This is fixed now.  As hdgarrood correctly surmised, the problem was due to https.  More specifically, with the ""HTTPS Everywhere"" extension installed, d3 would not load over plain http.  Fixed by using a local copy of d3 and using https to embed the game as an iframe."
haskell,37dv8y,bobbito-stretch,7,Thu May 28 12:25:56 2015 UTC,"i scraped every rick ross lyric off rap genius and combined it with the stanford wordnet library on hackage to make a website called wwrrd (as in, what would rick ross do) that took a string in, words'd it, looked at all related phrases (as given by wordnet), then compared it with pre-generated phrase sets for rick ross lyrics stored in a redis database and returned a line from a rick ross track weighted by similarity (and some inverse document frequency etc.) in an attempt to rephrase every comment i make in a code review as though rick ross was saying it  turns out semantic similarity is actually a really hard problem, but was a fun intro to a website with snap, and the wordnet and redis modules."
haskell,37dv8y,andrewthad,1 point,Thu May 28 06:30:57 2015 UTC,This is absolutely hilarious (by that I mean the fact that you choose Rick Ross for the corpus). Thank you for sharing because reading it made my day.
haskell,37dv8y,Aoi32,5,Thu May 28 12:06:41 2015 UTC,"Not as impressive as some here. I wanted a tool I could use for my logic class to verify my prepositional logic proofs. I wrote a little executable to read proofs from a file and tell me exactly what is wrong with them (source). I want to rewrite it so it includes quantifiers and lets you define you're own rules. I know there is already an interactive web-based tableaux prover, but it doesn't let you create your own non-classical logics.  In our break I am going to try and put it online (learning Yesod will be fun XD)."
haskell,37dv8y,iouwt,6,Wed May 27 15:08:26 2015 UTC,An implementation of the Shen programming language.  https://github.com/mthom/shentong
haskell,37dv8y,shangas,4,Wed May 27 17:02:54 2015 UTC,I'm currently working on Tila which is a SaaS project management tool. The back-end is Haskell (scotty + postgresql-simple) and the front-end is written in CoffeeScript (but I'm thinking about re-writing it in PureScript at some point).
haskell,37dv8y,heisenbug,4,Wed May 27 12:24:09 2015 UTC,"For a ""research"" project I have mildly abused the gdiff library to generate effectful actions as a result of patch. This allows us to configure transmission gear in a painless fashion by comparing (essentially) pure configuration trees."
haskell,37dv8y,hiptobecubic,4,Wed May 27 13:09:36 2015 UTC,"Implementation of SENNA - a unified architecture for natural language processing.  It's 3000 lines of C (original implementation), a lot less in Haskell, I'm improving the performance currently, I'll publish the repository (with whole history) when I'm done."
haskell,37dv8y,ben7005,3,Wed May 27 14:21:10 2015 UTC,I'll publish the repository (with whole history) when I'm done.   Why do people do this? Embarrassment?
haskell,37dv8y,hiptobecubic,3,Wed May 27 22:52:09 2015 UTC,I dislike the repositories where the first commit looks like magic.
haskell,37dv8y,fegu,1 point,Thu May 28 09:20:18 2015 UTC,"Yes, at least for me :/"
haskell,37dv8y,davecompton7,3,Thu May 28 05:44:57 2015 UTC,"No one is going to judge you. Most people don't have anything at all. If you share early, people can help you with design, finding bugs, etc. It's worth it!"
haskell,37dv8y,gergoerdi,4,Thu May 28 13:11:16 2015 UTC,"Fron-end javascript (want to convert it to Fay or GHCJS), webservice Scotty + postgresql-simple, back-end long-running Haskell-processes fed by RabbitMQ. oh, the url is http://boardword.com/"
haskell,37dv8y,ttfh,1 point,Wed May 27 15:03:09 2015 UTC,very impressive
haskell,37dv8y,gilmi,5,Wed May 27 15:40:05 2015 UTC,"For the last five or six years, almost all of them... including   Hardware that runs Brainfuck natively, implements a virtual machine straight from the mid-'70's and one of the first 8-bit home computers Stupid toy transpilers from Haskell to C++, from Brainfuck to a one-instruction machine, from register machines to Brianfuck, ..."
haskell,37dv8y,gilmi,5,Thu May 28 01:40:27 2015 UTC,"I did a small library for calculating kindergarten fees. Might seem wierd that you'd need software for this, but were I live, the rules for how much you pay each month are really complicated.  Also, I'm working on a library to help me generate menus for my homepage. This project suffers from extreme feature creep and it will never be finished."
haskell,37dv8y,hugo_dc,3,Thu May 28 06:15:17 2015 UTC,"I've made a very simple console file reader like less, a simple searchable movie catalog with tags, my blog software, a parallel evaluated lisp interpreter and repl (almost done) and a few other small things :)"
haskell,37dv8y,Kah0ona,2,Thu May 28 10:08:23 2015 UTC,I've made a very simple console file reader like less   Would you mind sharing that code? I'm not advanced enough to understand some of these complicated projects but this looks like it could be understandable.
haskell,37dv8y,bartavelle,3,Thu May 28 15:42:11 2015 UTC,sure
haskell,37dv8y,tdees40,3,Thu May 28 16:07:14 2015 UTC,"I reimplemented Steve Losh's command line ToDo list manager, it was originally written in Python, It's a very useful tool, now I'm using my Haskell implementation.  t web page: http://stevelosh.com/projects/t/ my repo: https://github.com/hugo-dc/t  I'm a Haskell beginner, so, any comment on how to improve my code is very welcome."
haskell,37dv8y,sumitsahrawat,4,Thu May 28 19:31:33 2015 UTC,"I goofed around with trying to model musical notes in haskell ( blogpost ) I built something to easily calculate group expenses from an input file. Afterwards it reports on who should pay what amount in order to get even. Used this for a skiing holiday with friends. I thought using Excel for this would be too boring :-) I dabbled with Parsec and wrote a few small parsers. One time I wrote a small DSL where I could specify roles/authorities/groups , and it would generate SQL rows out of this model. This way i could model access rights in one of my (Java) web apps, in a very clear way. The DSL looked like CSS where you could 'select' parts of the applications (ie. views) and apply Create Read Update Delete rights on it for certain users."
haskell,37d5xh,FPguy,17,Tue May 26 19:33:24 2015 UTC,In what ways do their responses differ from not-Windows users?
haskell,37d5xh,bos,5,Wed May 27 03:09:32 2015 UTC,"Summary  Regarding users not into Windows and not into .Net:   Only 52% are worried about debugging & profiling, vs 71% of Windows users Only 42% are worried about IDE, vs 65% of Windows users Only 39% are worried about deployment, vs 54% of Windows users Only 33% are worried about installation, vs 46% of Windows users 34% of nonstudents are at a workplace that uses Haskell, vs 17% of Windows users   Details  To get a clear answer to your question I'm omitting the moderate users -- those who rated Windows or .Net improvements as only helpful (the middle of the rating scale) or don't know. Without them, leaving 379 v1.0 respondents who said both Windows and .Net improvements are no impact or sight help, here are their answers to the same questions (biggest changes boldfaced):   Package management & cabal. 34% crucial + 27% important Debugging & profiling. 23% crucial + 29% important Documentation & learning resources. 27% crucial + 32% important Colleagues' perception of Haskell. 30% crucial + 26% important IDE improvement. 19% crucial + 23% important Ease of writing high-performance programs. 21% crucial + 28% important Availability of skilled personnel. 22% crucial + 27% important Deployment features. 12% crucial + 27% important Installation. 13% crucial + 22% important Application templates, frameworks, design patterns, reusable samples, etc. 16% crucial + 25% important Scalability to large datasets. 19% crucial + 24% important Server-side web application support. 19% crucial + 23% important Thorough support for math or data analysis (as you might see in Matlab, R, or NumPy). 16% crucial + 17% important   Especially notable are the reduced importance of improvements in debugging & profiling, IDE, deployment, and installation and the much higher percentage currently using Haskell at work: of the 300 non-students, 34% of them said their current organization uses Haskell, and only 24% said agree or strongly agree to ""My organization would soon use a lot more Haskell in our work, if realistic improvements are made to it."" Even so, 64% would recommend Haskell for a project at their workplace."
haskell,37d5xh,rdfox,10,Wed May 27 17:26:55 2015 UTC,"Interesting. Haskell gets a little corporate sponsorship here and there. Microsoft has off-and-on, mostly through Microsoft research, supported some Haskell projects. Still, I'm not surprised that Windows is the least supported. Windows is a very strange platform and therefore hard to support."
haskell,37d5xh,Taladar,11,Wed May 27 01:28:57 2015 UTC,"Not only is it very strange in many ways (sometimes to the point where it seems like they are going out of their way just to be incompatible with everyone else), it also seems to have a culture that often leads to many people demanding improvements with few people contributing them compared to other platforms. I have heard of differences in user/contributor factors as high as 1 to 10 compared to the same factor on other platforms."
haskell,37d5xh,rdfox,19,Wed May 27 08:09:56 2015 UTC,"I just read this awesome paper where these guys go on an adventure to fix multicore IO performance in GHC. Along the way they happen to find a Linux kernel bug and they report it and it gets fixed. After some good success they port their work to BSD and OSX without much incident. Finally they look at Windows and they're like, yeah, that's a whole other thing we might get to at some point.  The punchline is at the end they acknowledge one corporate sponsor: Microsoft Research."
haskell,37d5xh,Crandom,4,Wed May 27 11:00:48 2015 UTC,"As is the case with most large companies, Microsoft Research is effectively a whole separate company to the other parts of Microsoft."
haskell,37d5xh,pythonista_barista,2,Wed May 27 21:55:45 2015 UTC,I recently read through the MIO paper as well! It's really well done and impressive work.
haskell,37d5xh,protestor,2,Wed May 27 19:10:40 2015 UTC,"sometimes to the point where it seems like they are going out of their way just to be incompatible with everyone else   It's well documented that 90's Microsoft had this goal (see for eg. the Halloween documents), but I think they changed enough in recent times."
haskell,37d5xh,_AndrewC_,1 point,Thu May 28 14:55:31 2015 UTC,"These other platforms being ones with a significant dependency on Linux, the open source community-maintained OS. There's a significant cultural difference there before you get started. What if OSs were airlines?"
haskell,37d5xh,Taladar,1 point,Wed May 27 08:42:40 2015 UTC,There is also a significant cultural difference between OS X and Linux. It does not seem to have the same problem with contributors though.
haskell,37d5xh,_AndrewC_,1 point,Wed May 27 09:04:03 2015 UTC,"Both OS X and Linux are in different ways based on Unix. Windows isn't. Criticising it for being different is like criticising your cat for being so unlike the other pet dogs you have.  If your computer comes with standard screws in the casing, you see things differently to when it comes with warranty-void-if-removed stickers.   You'll see large cultural differences between Windows users who stick with Internet Explorer and those who use Firefox or Chrome.   Programmers who use Linux or OS X are probably more independently minded than Windows programmers, and more eager to edit something they feel needs change.  My point is that Windows users are more likely to see tools as things someone else provides."
haskell,37d5xh,Taladar,3,Wed May 27 13:35:12 2015 UTC,OS X users are more likely to see tools as something to purchase for money than as something to contribute to as well. That was the reason I chose that platform.  I think the reason OS X still has decent support for most things open source is the relative ease of use of porting things from other Unix systems though. The small numbers of contributors can achieve things more easily there than on a strange platform like Windows that needs a larger amount of work to produce results.
haskell,37d5xh,Taladar,8,Wed May 27 17:09:36 2015 UTC,"I have a bias because I worked on the Windows team >15 years ago. Rather than thinking of Windows as ""strange,"" I think the other platforms we support are oddly uniform -- they're all directly based on Unix lineage, whereas Windows is based on a blend of VMS lineage (the NT operating system) and Microsoft desktop lineage (the older Windows operating systems).  Windows is the only very popular OS not based on Unix. But if we were to look at other less-popular OS's some of them would seem strange too. :-)  Also, however different it might be, I find it hard to call anything ""strange"" that constitutes the majority of deployed units in the world (among desktops and laptops)."
haskell,37d5xh,Taladar,3,Wed May 27 16:37:50 2015 UTC,The majority of one niche market (desktop PCs) perhaps. Certainly nowhere close to the majority in the vast majority of the markets for computing devices with operating systems.
haskell,37d5xh,mjmrotek,5,Wed May 27 17:00:08 2015 UTC,"Corrected.  Except that's not a niche market, it's hundreds of millions of units, including those on which most people do software development.   Since very little current Haskell development targets mobile devices or embedded systems, that leaves servers, which indeed are majority Linux/Unix."
haskell,37d5xh,fridofrido,3,Wed May 27 17:33:26 2015 UTC,"I would argue servers (not just but often webservers and related backend services) are indeed the main target platform not just for Haskell but for about 90% of all programming languages.  Desktops aren't just hard to target on Windows but due to their heterogeneous nature in general, particularly if you want to support GUIs and support them with native look&feel on all major platforms."
haskell,37d5xh,chrisdoner,5,Wed May 27 18:42:40 2015 UTC,"While I did use to avoid writing Haskell on Windows like plague, since I started to use MinGHC I really don't have any problems except for cutting edge stuff like compiler plugins. I, for one, welcome our new FP Complete overlords ;)"
haskell,37d5xh,fridofrido,8,Wed May 27 16:10:36 2015 UTC,"My primary issue with Haskell on Windows, by far, is that packages using any third party C/C++/etc libraries are often extremely hard to build, if not impossible (btw if you make a binding to a moderately sized C library, consider including the C sources in the package; then a simple cabal install works on Windows too)  Also generated haddocks on Windows are most of time broken (individual packages are ok, but the links to them are broken)."
haskell,37d5xh,chrisdoner,11,Wed May 27 08:51:38 2015 UTC,"My primary issue with Haskell on Windows, by far, is that packages using any third party C/C++/etc libraries are often extremely hard to build, if not impossible   This is pretty much why I stopped using Windows a decade ago. It's hostile to developers."
haskell,37d5xh,lpsmith,6,Wed May 27 10:13:48 2015 UTC,"Using a given operating system is not always a choice, so please (in general, not necessarily just you) stop advising that everybody should use Linux for Haskell development. Windows is a very important target.  I use all 3 major operating systems, and even more importantly, people I write software for also use all kind of different OS-es, and I want to be able to continue to do so.  Furthermore, exactly the same way Windows is hostile to developers, Linux is very hostile to users (yes, you hear me, it's not that much better today in 2015 than it was 10 or even 15 years ago). Now, I'm both a user and a developer, as I guess most of us are (and thus personally I prefer OSX, at the moment at least; but again, it's not always a free choice)."
haskell,37d5xh,dat_unixbeard,7,Wed May 27 11:58:23 2015 UTC,"Using a given operating system is not always a choice, so please (in general, not necessarily just you) stop advising that everybody should use Linux for Haskell development. Windows is a very important target.   I'm not advising anyone. Windows speaks for itself. It's awful and as a result nobody wants to touch it. I stopped using Windows a couple years before I started with Haskell."
haskell,37d5xh,fridofrido,3,Wed May 27 13:20:09 2015 UTC,"GHC is the reason I switched,  as a user, from Windows to Linux.    I ended up buying a second desktop to do it."
haskell,37d5xh,chrisdoner,2,Wed May 27 23:15:21 2015 UTC,"I beg to differ, obviously Haskell was started in the Unix community and as such most of the original people behind it were Unix users. You often hear people say they ""switched"" because of Python or Haskell or whatever and yes, it's true all those languages enjoy far better Unix support because that's where the community is.  .NET stuff however was developed by MS and so writing .NET stuff is a veritable pain on Unix. Consider that OCaml and F# come really close in what type of language they are, but developing OCaml on Windows is difficut whereas the reverse is true for F#.  The major difference though is that I used the word ""community"" in one and 'Microsoft' in the other. The ""Windows community"" seldom comes with anything on their own and relies on a higher corporate agent to kickstart it. A lot of Unix projects start as small hobby things that eventually grow to something big. Linux and the original AT&T Unix in fact started as projects people undertook in their spare time."
haskell,37d5xh,fridofrido,0,Thu May 28 03:17:54 2015 UTC,"It doesn't matter if Windows is awful or not, if you are writing software for other people and other people use Windows."
haskell,37d5xh,bss03,9,Wed May 27 14:57:17 2015 UTC,"Of course it does. It matters a lot. The question is whether you want to spend time going out of your way to support Windows or not. Some do, some don't. It depends on the project. We're talking almost exclusively about open source projects here, things that people do in their spare time for fun.  What doesn't matter is how much you tell people how ""important"" Windows is as a ""target"", they will make their own decisions about their personal projects based on their circumstance, time, interests and temperament."
haskell,37d5xh,fridofrido,1 point,Wed May 27 15:18:04 2015 UTC,"I just find it a very unhealthy to decide that one makes software for other people voluntarily, and then simply ignores a very significant portion (possibly the majority) of people just because it is more convenient.  Yes, maybe developing for Windows painful, still I believe we should everything in our power to support software on Windows (and other OS-es) too. I myself use Windows on my company desk, and feel the pains of this type of thinking on my skin first hand rather often, and it feels really bad."
haskell,37d5xh,bss03,2,Thu May 28 11:19:54 2015 UTC,"That's because volunteers always write for the themselves first.  Other users can benefit, but incidentally.  Paid open source developers are generally pretty amenable to doing whatever (development) work the person paying wants.  I was a developer first, then MS Windows drove me away, and only later did I contribute anything but noise to open source software."
haskell,37d5xh,StallmanBot,1 point,Thu May 28 20:56:39 2015 UTC,"Of course (good) software comes from an itch to scratch. But as I said, I am (as I guess most people here are) both a user and a programmer. With my user hat on, I really really feel the pain, so on the programmer side I try to aim for the best possible compatibility reasonably (and this is the key word) achievable. And I don't think ""use linux, because windows sucks"" is the best compromise here. Especially as probably the majority of computer users today use Windows."
haskell,37d5xh,TheJonManley,2,Thu May 28 21:48:12 2015 UTC,"If you want me to develop for MS Windows, best get your wallet out.  That's my compromise.  I'm not the only one that feels this way."
haskell,37d5xh,chrisdoner,-1,Thu May 28 22:40:22 2015 UTC,"Actually, it's GNU/Linux, not Linux!"
haskell,37d5xh,conklech,2,Thu May 28 21:48:40 2015 UTC,"I don't agree that Linux is hostile to users. We have to separate users from powerusers.  To me, the trade-off between Linux and Windows is similar to the trade-off between typing with two fingers and touch typing. The former is more intuitive to use and does not require any habits to be developed. The latter has a steep learning curve, but gives you the level of productivity and control that is not achievable otherwise (not just for work, but for everyday tasks as well).   I use Linux for pretty much everything I can for this reason. Using other OSes for me feels like typing with two fingers and it's not because I'm not used to them. I used Windows for many years, but just after one year of using ArchLinux, I was much more productive in it.  In my mind, the reason to support Windows is because this is what most people use. It's like QWERTY layout. We can argue all day whether this layout is shitty or not, but the unfortunate reality is that this this is what most people use, so if we build a keyboard, then we either have to support that layout or be fine with loosing a large market share."
haskell,37d5xh,Taladar,3,Wed May 27 13:50:20 2015 UTC,"The way that Linux is bad for users is when device drivers don't work properly. Sound issues, Flash issues, wifi, things like that. Bugs aren't part of Linux's design philosophy. Nor can Windows's design philosophy be blamed for its virus-ridden, slows-down-over-time, comes-with-bloatware, BSOD issues. Those aren't part of the Windows philosophy.  Otherwise my non-technical dad uses Ubuntu happily and all I did was install it as dual boot, didn't explain anything about it."
haskell,37d5xh,conklech,5,Wed May 27 15:38:21 2015 UTC,"I think your typing analogy glosses over a huge issue that's (historically) plagued Linux. (I use both systems regularly; I'm painting with broad strokes here and not intending to bash either.)  Windows is generally designed on the assumption that it presents a consistent and complete interface to the user: you should be able to successfully go about a full and independent life with little knowledge of the underlying hardware or software infrastructure. This applies to a lot of programmers, too; you can install Visual Studio and write pretty sophisticated .NET stuff using only high-level libraries.  Linux systems have generally presumed that the user is either a programmer or has a reasonably subtle understanding of a variety of subsytems. As a result, the interface presented to the user is either a command line, a limited GUI that requires frequent resort to the command line, or something otherwise very complicated. And debugging is a pain. (And--this is really off-topic--a lot of people are utter assholes, or at least systematically unhelpful, to ""lusers"" who don't understand what's going on.)  So there's a huge alignment between ""contributors"" and the Linux environment. People who aren't interested or equipped to contribute just won't use the system. Of course the contributor ratios are wildly different!  I'm getting at a certain class divide that the whole (Linux+Windows) environment fosters: the elite Linux crowd gets support, while the Windows underclass has to deal with even greater hurdles (like the C library nightmares upthread) despite being relatively ill-equipped, both in tooling and training, to deal with them.  Not anybody's fault, of course. But since we're supposedly talking about adoption here, it's important. I've deployed one Haskell program in a corporate (i.e. Windows) environment, and that's just because it needed zero user interface and zero library support. Me and my users (i.e. lawyers) use Word and Excel. Period. Anything on the front end needs to deal with that environment. (It took ten or fifteen years for the industry to move from WordPerfect to Word, and there's just not a better environment for lawyers yet. Linux on the desktop isn't happening in this world for a long time.)"
haskell,37d5xh,fridofrido,5,Wed May 27 15:22:56 2015 UTC,"Your post betrays a strong bias against commandlines. It is a superior interface for some tasks (e.g. automation, telling people what to do over the phone or email without dozens of screenshots,...) just as GUIs are superior for others. Unlike advertising from the 90s and early 2000s would have you believe there is no natural progression where CLIs are the outdated precursors of GUIs.   And debugging is a pain.   My experience is just the opposite. When I first moved to Linux after years spent on Windows I finally realized that computers actually exhibited deterministic behavior and software did not just break randomly. Things happened for a reason and no matter what it was, it was always possible to find that reason because there were no artificial barriers to debugging efforts.   (And--this is really off-topic--a lot of people are utter assholes, or at least systematically unhelpful, to ""lusers"" who don't understand what's going on.)   My experience is the opposite here again. There are literally tens and hundreds of thousands of people patiently answering questions in their free time as long as people just ask in the right tone (e.g. not ""I need this now, every minute is costing my $xxxx,..."" style entitlement or similar toxic attitudes) and are willing to provide details of their problem after being shown how to do so.  People fix bugs that have been reported, sometimes within hours of the report while having an independent dayjob.  On the other hand on Windows not even Microsoft provides support or fixes for their own OS, not even if you are willing to pay for it. And forums and similar places found via Google are much less of a help too, partially caused by Microsoft's rather retarded naming conventions which makes using a search engine to find anything about a specific version of their software close to impossible.  I think the more likely reason for the lack of Windows contributors is not that people equipped to do so aren't among the Windows user base at all, it is that working on the kinds of problems that have to be overcome on Windows in your free time just isn't much fun.   Me and my users (i.e. lawyers) use Word and Excel. Period. Anything on the front end needs to deal with that environment. (It took ten or fifteen years for the industry to move from WordPerfect to Word, and there's just not a better environment for lawyers yet.   I would argue that there are plenty of better environments than those forcing highly paid lawyers to deal not just with content but also with layout, distribution of content (as opposed to e.g. most VCS or other distributed systems which just handle that part for you), versioning, printing and many other tasks that would be more suitable for specialists doing the work separately.  The difficulty in changing environments is more likely caused by network effects (advantages of using the same thing as everybody else) and not by any inherent advantage of the currently used system."
haskell,37d5xh,Taladar,4,Wed May 27 17:24:55 2015 UTC,"a strong bias against commandlines   Yep! I use the command line frequently and have no personal problem with it, but there's a massive learning and memory burden involved in idiomatic, productive command-line use. In particular, you have to remember names quite precisely. There's a huge surface area, which is good for many people but bad for occasional use or for newcomers.  When I get questions about dealing with situations in Word, for instance, my response is generally along the lines of: look in the option menu, there's something about turning indentation off. I rarely try to tell people keyboard shortcuts, because they're just not memorable unless you're motivated to spend some time practicing and memorizing them.  (Don't confuse my argument with bias. I'm in the process of making emacs my daily editor. Nobody else I know is.)  As to your other responses: my views range from ""don't disagree"" to ""strongly agree"" to ""I'm vaguely tempted to start a company to address this"" to ""when I'm managing partner, things are going to be different.""  ""Network effects"" is exactly correct; an alternative being better by some metric doesn't really address that. There's also a huge investment in training and experience, and enormous barriers to entry. Isn't that what we're really talking about here? There are unfortunate barriers to using Haskell at all in my environment."
haskell,37d5xh,wrvn,3,Wed May 27 17:41:22 2015 UTC,"I don't agree that Linux is hostile to users. We have to separate users from powerusers.   I consider myself a power user, and personally I find Linux extremely hostile to users. The typical user experience is that basically nothing works properly out-of-the-box, and often several days of googling and browsing forums is not enough to fix the problems. Your experience or pain tolerance may be different, good for you, but that doesn't eliminate the issues.  In any case it doesn't matter: Even if you as a developer prefer Linux, if the users of your software use Windows, you must produce working Windows software. My experience with Haskell on Windows is that it is making 3rd party libraries working is the painful part, not using Windows itself.  (pure Haskell without external dependencies usually work fine, if you have the basics like network and OpenGL covered by a binary install)"
haskell,37d5xh,Crandom,5,Wed May 27 15:04:35 2015 UTC,"The typical user experience is that basically nothing works properly out-of-the-box, and often several days of googling and browsing forums is not enough to fix the problems.   My general experience is that in recent years the typical Linux install works out of the box for at least 90% of the functionality (meaning a few exotic hardware devices rarely used might not work). On Windows on the other hand my experience has been that nothing works at all, I even had to use 800x600 resolution for an hour after the last Windows install on my current desktop while downloading drivers, something I thought I had left behind in the 90s. Windows also has an incredibly poor set of default tools available after an installation while Linux comes essentially batteries included or as close to it as license issues permit (some proprietary vendors prevent their drivers or software from being distributed on the Linux distro's install media).   My experience with Haskell on Windows is that it is making 3rd party libraries working is the painful part, not using Windows itself.   My experience with C++ on Windows was the same. Using any libraries at all on Windows is a pain, I blame their lack of a standardized filesystem layout and library naming scheme for most of the issues."
haskell,37d5xh,fridofrido,1 point,Wed May 27 17:29:56 2015 UTC,I even had to use 800x600 resolution for an hour after the last Windows install on my current desktop while downloading drivers   I don't know what windows version you have been using but as of Windows 8 windows provides software emulation if GPU drivers are not present meaning you get any resolution you want with full desktop composition....although some more advanced stuff like multi monitor support and full DirectX acceleration wont work without proper drivers.
haskell,37d5xh,Peaker,3,Thu May 28 07:10:44 2015 UTC,"Have you tried Linux recently? Your experience sounds like the what it was like 5-10 years ago. Nowadays everything mostly works out of the box. I haven't had to touch an xorg.conf, install fglrx, do some crazy WiFi driver firmware cutting or even touch a grub.cfg in years."
haskell,37d5xh,fridofrido,1 point,Wed May 27 22:02:25 2015 UTC,"Yes, I tried recently too, though not very deeply. If any, my experiences are even worse with the recent distros than 10 years ago..."
haskell,37d5xh,Peaker,1 point,Thu May 28 11:11:50 2015 UTC,Usually apt-get (or the GUI equivalent) of some package foo adds it to my menu and it just works. What doesn't work for you?
haskell,37d5xh,fridofrido,2,Thu May 28 16:18:01 2015 UTC,"I think there is minor confusion here: on one hand, third party libraries are painful on Windows; on the other hand, I have all kind of issues with Linux, but installing (precompiled) third-party libraries using the distro package manager is not one of them."
haskell,37d5xh,Peaker,2,Thu May 28 17:11:31 2015 UTC,"I install Linux Mint, and I get a working web browser, with all my laptop devices, internet, etc, Just Working.  Do you have anything specific that doesn't work?"
haskell,37d5xh,StallmanBot,2,Thu May 28 20:28:56 2015 UTC,"Last time I tried to upgrade GHC on a Linux (virtual-)box at work, I ended up to simply install a fresh Linux instead because it was simpler (that is, at least it not impossible). Then I ended up installing and immediately discarding 3 different distros because they were that painful (big name standards like Debian, Ubuntu, Fedora, whatever, I cannot recall and frankly I don't care). I think the one which remained at last was actually Mint, but only because I had to choose between the somewhat less pain of Mint than the other three, and the pain of searching for something a tiny bit better.   I don't have too much concrete examples, because I don't feel I have to count those uncountable number of issues, but to have a very concrete example, maybe ~2 years ago I tried to install a VPN client (that's client, not server!) on my boss' computer, which had the then latest Ubuntu. Let's make it short: It. does. not. work. at. all.  And that summarizes my general experience with Linux. Maybe other people are more tolerant, or maybe I'm too old(*) to be patient enough to deal with this stuff, but for god's sake, it's fucking year 2015 here, and the fucking commodore 64 was, 32+ years ago, way more user friendly than Linux is in 2015 (and that's with 20 years of on/off, though mostly off, Linux experience, so it's not just that I cannot type apt-get into a terminal)  (* actually I'm not that old, which makes it even more serious)"
haskell,37d5xh,yitz,2,Thu May 28 22:02:21 2015 UTC,"Weird, I feel that way about using Windows. Stuff either doesn't work for me, or I get tons of nag-screens asking me to pay them.  I think Ubuntu's Unity interface is total crap, so perhaps that is part of the problem.  With Mint, VPN has a built-in GUI which works for me (with OpenVPN).  Weird!"
haskell,37d5xh,fridofrido,-1,Thu May 28 22:56:09 2015 UTC,"Actually, it's GNU/Linux, not Linux!"
haskell,37d5xh,b00thead,4,Thu May 28 22:02:43 2015 UTC,"If you are using the 64-bit GHC, FFI is pretty broken right now when used with random vanilla DLLs floating around out there. But it works fine with DLLs produced by mingw-w64 builds.  So the solution is:   Install MSYS2. Use pacman to install the third party library you need (use the ming64 flavor of the package).   Now your cabal install works just like on any other platform.  If you want to limit yourself to 32-bits, it could be MinGHC would help. I never got it to work, but I never tried too hard, and some people have reported being successful."
haskell,37d5xh,borsboom,2,Wed May 27 09:28:32 2015 UTC,The bad experience was all on 32 bit. I haven't even dreamed about trying 64 bit (which didn't even exists until recently).  Btw I believe supporting 32 bit in the 64 bit era of today is still important - two reasons are:   existing 32 bit third party libraries without a 64 bit version potential memory bottleneck situations with lots of 64 bit pointers
haskell,37d5xh,RedLambda,17,Wed May 27 12:05:36 2015 UTC,286... Are you sure this is a recent survey Aaron?! ;-)
haskell,37d5xh,dagit,10,Tue May 26 20:17:15 2015 UTC,We need Windows 3.1 support for these people!
haskell,37d5xh,rdfox,10,Tue May 26 21:38:05 2015 UTC,"Segmented memory FTW. :-)  Alas, while Windows has moved forward, it seems we have some catching up to do. I hope people find these high quality data points interesting and motivating."
haskell,37d5xh,conklech,8,Tue May 26 22:29:14 2015 UTC,"I wonder if those who request improvements in the package management and cabal could be helped a bit, if there was more documentation aimed to describe common workflows.  I.e. whether those ppl aren't to some degree complaining about lack of good documentation which would bring more awareness of all the facilities that Cabal/cabal-install already provides (even if its UI has quite a few rough edges if you start naively or with wrong assumptions using it w/o proper understanding -- reminds me of Git where it's easy drive yourself into a ""Git Hell"" corner if you don't take the time to acquire a mental model of how Git works). I consider Cabal as revolutionary as Git was for SCMs in describing package dependencies (and Backpack goes even further), and we're still trying to figure out how to make it work w/o dumbing it down to what everyone else does."
haskell,37d5xh,rdfox,5,Wed May 27 07:42:41 2015 UTC,"At the risk of repeating like a broken record: the entire raw (anonymized) data set is available for download at the linked blog article. It is substantial. Every question I mention here comes with extensive answers & comments from numerous users. In addition, the v0.1 and v0.2 versions ask some questions differently, plus a few extra questions. Please dig in if you like serious data.  In the past we have had to decide a lot of priorities based on personal opinions or guesses, and a frequest post in /r/haskell is ""where can I contribute?"" This data set contains a lot of recommendations."
haskell,37d5xh,yitz,0,Tue May 26 23:20:41 2015 UTC,https://www.reddit.com/wiki/selfpromotion
haskell,37cqo1,timmy_tofu,11,Tue May 26 17:51:23 2015 UTC,"Haha, the thought of some dorky Haskeller at an A$AP Rocky concert... do you guys also throw sweet private Edward Kmett seminars?"
haskell,37cqo1,MitchellSalad,1 point,Wed May 27 06:06:11 2015 UTC,Ha.. Haskellers come in all flavors these days
haskell,37bvh0,cocreature,10,Tue May 26 14:11:24 2015 UTC,What are some of the examples which motivated injective type families?
haskell,37bvh0,Lossy,5,Tue May 26 20:54:45 2015 UTC,One example that can come up is e.g. in DB-Libraries a type family mapping an entity type to its key type or to the sum type of unique constraints. Given a key it would be useful if the compiler could in turn infer the matching entity type but currently that is not possible since it can not assume the Key type family is injective.
haskell,37bvh0,Taladar,10,Wed May 27 08:05:41 2015 UTC,"The first example has nothing to do with injectivity.  Consider this  type family F a where   F Bool = Char   F a = Bool   Now, if we know F x ~ Char we know that x ~ Bool even though F is clearly not injective.  It's a pity that ghc doesn't do these simplifications."
haskell,37bvh0,augustss,4,Wed May 27 13:13:47 2015 UTC,"Idle thought: would a surjective type family make sense / be useful? One that targeted each type of a kind created with DataKinds, for example."
haskell,37bvh0,Faucelme,1 point,Tue May 26 18:43:34 2015 UTC,I'd say the concept of surjectivity is much less useful if you restrict the set of possible codomains.
haskell,37bvh0,_deepfire,7,Tue May 26 19:13:28 2015 UTC,The lack of this is what annoys me the most in my day-to-day type level haskell.  Edit: Autocomplete
haskell,37bvh0,Crandom,5,Tue May 26 17:19:59 2015 UTC,"(pedantic) it's ""day-to-day"""
haskell,37bvh0,ignorantone,1 point,Tue May 26 23:26:06 2015 UTC,Autocomplete :/
haskell,37bvh0,Crandom,1 point,Wed May 27 07:18:42 2015 UTC,Haha I see. I wouldn't have said anything except it took me a few seconds to figure out the intent.
haskell,37bvh0,ignorantone,-2,Wed May 27 08:44:14 2015 UTC,"(pedantic) it's ""goddamn-motherfucking-type-level haskell"""
haskell,37bvh0,rdfox,3,Thu May 28 00:29:47 2015 UTC,"Ooh, nice."
haskell,37dp2m,tikhonjelvis,3,Tue May 26 21:42:15 2015 UTC,"Not very relevant to the discussion, but writing a breadth-first traversal of a binary tree is a fun exercise.  data Tree a     = Leaf a     | Node (Leaf a) a (Leaf a)  val :: Tree a -> a val (Leaf x) = x val (Node _ x _) = x  toListBF :: Tree a -> [a] toListBF tree = val <$> fix (\trees -> tree : gen trees)   where     gen :: [Tree a] -> [Tree a]     gen (Leaf _ : _) = []     gen (Node x _ y : zs) = x : y : gen zs    > toListBF (Node (Leaf 1) 2 (Leaf 3)) [2,1,3]"
haskell,37cr8k,FPguy,10,Tue May 26 17:55:26 2015 UTC,"""Documentation in Haddock is NOT example-driven. This needs to change. Too many crucial libraries are too esoteric at the moment.""  Yes. Even the lens library, which has quite good documentation in comparison to other libraries, could benefit from more examples.  Yesterday I was trying to figure out how to use Wrapped with newtypes. I spent 30m-1h realizing that I needed to do  (aNewtypedValue ^. _Wrapped')   to get the interior of the newtype. I was trying to use _Unwrapped' because that name made more sense to me. I.e. if you want to view what's inside the newtype, you should ""unwrap"" it. But my intuition, name wise, led me wrong. I was doing all kinds of googling, and looking at code on github, before I finally figured out the answer through experimentation :("
haskell,37cr8k,ignorantone,7,Tue May 26 23:22:13 2015 UTC,"All of the _Foo combinators follow the logic that they act like 'constructors'.   foo^._Left  -- extracts what is in the Left constructor, and works as a legal traversal of just that one constructor.  _Left # 3 constructs a Left 3  _Wrapped is an Iso and so follows this constructor-like scheme.  _Wrapping Sum = _Wrapped is a replacement for what would be _Sum which would be a constructor and hence match on the Sum constructor and extract the value.  All isomorphisms and prisms are done this way because ""prisms"" have to be done this way and it is the most consistent style we can offer. Whenever we really want to follow the other convention where its acting like a Lens that happens to be an isomorphism (and wire things up to follow your intuition here) we use a lowercased name.  That said, I'm happy to take documentation patches that improve the state of documentation in lens or any of my other libraries."
haskell,37cr8k,edwardkmett,2,Wed May 27 01:34:14 2015 UTC,"I can hardly write anything in Haskell unless I know how to write it. This is very different from how I do C++ which is search the API docs, copy some example, change it until it does what I want. Often I can finish the job with no idea how it could possibly work. With Haskell, I know exactly how it works. Learning is fun but I doubt if it's practical or scalable for industry."
haskell,37cr8k,rdfox,4,Thu May 28 00:08:19 2015 UTC,"I strongly believe that it's not the correct workflow.  Maybe you can just imagine how, for example, cars are produced without the engineers knowing how cars work.  I guess it would be really fragile."
haskell,37cr8k,dramforever,8,Thu May 28 10:23:29 2015 UTC,"/u/hrothen said:  I'd like to see more material on properly using tricky libraries like vector. Whenever I'm writing anything nontrivial (and even trivial code sometimes) I always end up worrying about whether it's going to properly fuse or blow up the stack, and about what does and doesn't affect performance.  For instance, say I'm using JuicyPixels and I want to extract the underlying vector of PixelRGBA8 from an Image. The pixels are actually stored as a Vector Word8, so the two simplest ways to get them would be map (\i-&gt;PixelRGBA8 (v! i) (v! i+1) (v! i+2) (v! i+3)) (enumFromStepN 0 4 ((length v) / 4)) or the much shorter pixelFold (\a _ _ p-&gt; snoc a p) mempty img.  Do these two functions have the same performance? I suspect so, but without  manually inspecting the generated Core it's hard to tell. Is there a better third way? I don't know, I could cast the underlying ForeignPtr to Word32 and map unpackPixel across that, but is it faster?  And this is for a fairly trivial case."
haskell,37cr8k,cocreature,6,Tue May 26 17:56:28 2015 UTC,"Side question: Are you doing your analysis with haskell? Sadly there doesn't seem to be a lot of material out there on it and a quick look at your survey shows that there is interest for such things. So if you do use haskell, it would be awesome if you could make a blogpost or just publish the code you are using."
haskell,37cr8k,drwebb,7,Tue May 26 18:49:19 2015 UTC,"Hi, I'm doing the data analysis in Haskell as part of my job. I am currently experimenting using the Frames library to do the data munging, and also the R interop H to do more fancy analysis and plotting. H is currently scheduled for release in the near future, along with an Jupiter notebook walking through the survey analysis.  It would be nice if the Haskell ecosystem had more support for data analysis, but I believe H can really start to provide the best of both worlds with a huge ecosystem already there."
haskell,37cr8k,cocreature,3,Tue May 26 20:16:23 2015 UTC,"Thanks, I already looked a bit at Frames. Imho it's very promising."
haskell,37c4d7,chrisdoner,15,Tue May 26 15:17:32 2015 UTC,"FWIW, this is a GHC-ism:   type → (a number of things, but no contexts)  gendecl   → vars :: [context =>] type (etc)   (Not that many people use a compiler other than GHC, of course.)"
haskell,37c4d7,anders_,5,Tue May 26 16:26:43 2015 UTC,HSE too (though that should be obvious to anyone who knows HSE is derived from GHC's parser).
haskell,37c4d7,evincarofautumn,5,Tue May 26 16:31:17 2015 UTC,So you mean to say that this is a happy accident in GHC’s parser?
haskell,37c4d7,anders_,7,Tue May 26 17:13:06 2015 UTC,"Yes, basically. I bet it's because rank-n types need contexts in all sorts of places so it was simpler to just put the context => production into types, or some reasoning like that."
haskell,37c4d7,edwardkmett,8,Tue May 26 17:18:15 2015 UTC,"Moreover, once we added constraint kinds you actually need it. (Although, there were forms where you needed it before and it didn't work as well.)"
haskell,37c4d7,anders_,1 point,Tue May 26 19:06:16 2015 UTC,"Right, of course."
haskell,37c4d7,sgraf812,6,Tue May 26 19:06:47 2015 UTC,happy accident   I bet someone would've already filed a bug report then :)
haskell,37c4d7,evincarofautumn,2,Tue May 26 22:39:35 2015 UTC,"The Haskell community is so clever with puns. I’m unreasonably glad that someone got it. :)  Hints:  Hackers know that happy is a Haskell parser generator—used in a certain compiler. Painters know that “There are no mistakes, only happy accidents”."
haskell,37c4d7,Crandom,12,Wed May 27 07:55:37 2015 UTC,/r/haskelltil is another good place to post stuff like this to
haskell,37c4d7,pkmxtw,4,Tue May 26 17:59:14 2015 UTC,"This could come in handy as a nice way to separate out class constraints vs equality constraints, or to generally group constraints together in big type signatures.   I personally would just use ConstraintKinds since I'm a GHC extension whore:  type ReadShow a = (Read a, Show a)  f :: ReadShow a => a -> a f = read . show"
haskell,37c4d7,peterjoel,1 point,Tue May 26 23:57:28 2015 UTC,Another extension I didn't know about! :)
haskell,37c4d7,jberryman,2,Wed May 27 00:14:11 2015 UTC,I think you can interleave the constraints with the types too right? (Or does that require an extension?) I've only seen this once in real life and was confused as hell
haskell,37c4d7,anders_,8,Tue May 26 17:15:02 2015 UTC,"You need RankNTypes to write String -> Read a => a, if that's what you mean (and I don't really know why anyone would do it, but whatever). It's technically rank-2 as written, even though it's equivalent to the rank-1 type of read—and normalised to it by GHC afterward:  λ» :set -XRankNTypes  λ» let f :: String -> Read a => a; f = read f :: String -> Read a => a λ» :t f f :: Read a => String -> a   btw, I'm still on GHC 7.8 so I can't check, but the changes to 7.10's forall rules probably mean that's deprecated or disallowed now anyway: it probably only worked for the same reason that b -> (Ord a => a) -> c was equivalent to b -> (forall a. Ord a => a) -> c."
haskell,37d9d1,wolftune,3,Tue May 26 19:55:23 2015 UTC,"I'll be at BayHac as well. See you and David there, again!"
haskell,37d9d1,MitchellSalad,1 point,Thu May 28 06:34:50 2015 UTC,"Great! I wasn't sure I'd make it myself (although Bryan, who wrote the blog post, had committed to it already), but I went and booked my flights last night. So that'll make at least four of us from the real Snowdrift.coop community (maybe more). Looking forward to it!"
haskell,37bf7l,jaspervdj,8,Tue May 26 11:40:43 2015 UTC,"Interesting stuff! Have you looked at using a free applicative? I ask as I'm curious if it does help save you writing code, or if it's fairly inconsequential. One area it might be nice is the ability to change the functor that you're working under with hoistAp - which means unsafeEvaluate could go away, if you were able to ""evaluate down"" to Identity. At that point, your unsafeEvaluate would just be runIdentity . retractAp"
haskell,37bf7l,ocharles,6,Tue May 26 12:27:42 2015 UTC,"Thanks! With free applicative, the code gets a bit nicer but a little harder to understand for people unfamilar with free applicative, which is why I decided against it."
haskell,37bf7l,ocharles,6,Tue May 26 12:50:50 2015 UTC,"It seems daunting at first, but I actually find it makes things easier - at least that has been my experience in the long run! Ever since I read the Essence of the Iterator pattern, my appreciation for building functionality incrementally has only grown. I understand it requires a little bit more of a base knowledge, but the agility you get from working with free structures, or building things generically (e.g., out of polynomial/strictly positive functors) is rather remarkable.  The real benefit in this case is the ability to strip out all the non-Prio noise - so you can focus on just the interesting stuff.  If Prio is code you're using at work, I'd encourage you to help train the rest of your team to be able to work with free structures - in this case the free applicative - you'll be amazed at the knowledge and flexibility that comes with it :)"
haskell,37bf7l,ocharles,5,Tue May 26 16:29:27 2015 UTC,"Yes, it is implemented like that in my ""production"" code (although this is more of a personal side project). I was mostly talking about the blogpost when I said ""as simple as possible"".  I find it really hard to estimate what (potential) readers are familiar with and hence want to make the posts as accessible as possible, without of course explaining too much stuff from scratch - it's a difficult tradeoff."
haskell,37bf7l,sjoerd_visscher,3,Tue May 26 22:52:26 2015 UTC,Got it - thanks for the explanation :) Definitely with you on keeping it simple for blog purposes.
haskell,37bf7l,paf31,4,Tue May 26 23:27:35 2015 UTC,"Ah, I commented below your blogpost before I saw the discussion here. I can understand your decision, but I think you should at least mention the free applicative, for people who want to dive a bit deeper."
haskell,37bf7l,twistier,5,Tue May 26 13:59:48 2015 UTC,"Thanks, yes, I've added a footnote. :-)"
haskell,37bf7l,paf31,9,Tue May 26 14:30:50 2015 UTC,"This reminds me of a slightly different construction which we were discussing a little at LambdaConf this weekend. You can generalize the probability monad [(a, p)] to an arbitrary Semiring p. Choosing p to be the tropical (min, +) semiring gives an interesting ""priority queue monad"" in which tasks and their priorities can depend on parent tasks. I wrote it up here."
haskell,37bf7l,mbruder,5,Tue May 26 17:03:40 2015 UTC,My recent stable-heap library has this instance. I put it up long before it was in a state resembling completion. I intend to flesh it out later.
haskell,37bf7l,mbruder,2,Tue May 26 21:46:25 2015 UTC,Neat!
haskell,37bf7l,vincentrevelations,4,Tue May 26 21:49:31 2015 UTC,"Correct me if I'm wrong, but isn't the runtime really bad for many distinct priorities? Because it has to traverse the structure once for the minimum and once for the monadic sequencing, for each distinct priority value."
haskell,37bf7l,vincentrevelations,4,Tue May 26 12:47:26 2015 UTC,"Yes, it's awful! There are ways to speed it up, as I mentioned in the footnotes, but I wanted to keep the blogpost as clean and simple to understand as possible."
haskell,37bf7l,tomejaguar,5,Tue May 26 12:49:28 2015 UTC,It's an interesting article and a technique I've never seen. I'm interested in your more efficient implementation.
haskell,37bf7l,gasche,5,Tue May 26 13:01:49 2015 UTC,I've added an appendix which does just that.
haskell,37bf7l,edwardkmett,4,Tue May 26 14:31:39 2015 UTC,"Does the inside have to be a Monad?   If the inside is a MonadPlus, can Prio be an Alternative?"
haskell,37bf7l,gasche,3,Tue May 26 16:00:02 2015 UTC,"Yes, I think so. I can't seem to write runPrio when m is only Applicative, but I didn't delve in it to deep, so there might be a smart trick which I'm not seeing. Yes. In that case you could use another Alt constructor. The question is though, how do you interpret it in runPrio. I guess if you have x <|> y, it only executes either x or y, depending which one has the lowest priority. This makes the interpreter quite complicated though."
haskell,37bf7l,gasche,2,Wed May 27 09:24:44 2015 UTC,"Yes, I think so. I can't seem to write runPrio when m is only Applicative, but I didn't delve in it to deep, so there might be a smart trick which I'm not seeing.   Tried it myself, I looked over a part when asking the question. I think you're right.   Yes. In that case you could use another Alt constructor. The question is though, how do you interpret it in runPrio. I guess if you have x <|> y, it only executes either x or y, depending which one has the lowest priority. This makes the interpreter quite complicated though.    I think it should only depend on the underlying MonadPlus instance. So it wouldn't be any different from mplus (runPrio x) (runPrio y), just cleaner. Maybe sorted by priority, dunno."
haskell,37bf7l,kraml,2,Wed May 27 09:54:03 2015 UTC,"You can indeed have Applicative m without much difference.  /u/gasche seems to have another implementation below.  fastRunPrio :: forall p m a. (Applicative m, Ord p) => Prio p m a -> m a fastRunPrio prio0 =   let (queue, _) = buildQueue 0 prio0 PSQ.empty   in fmap (\m -> (fst (evalPrio m 0 prio0))) (evaluateQueue queue (pure M.empty))   where ....         evaluateQueue         :: PSQ.OrdPSQ Int p (m Any)         -> m (M.Map Int Any)         -> m (M.Map Int Any)     evaluateQueue q acc = case PSQ.minView q of         Nothing             -> acc         Just (k, _, mx, q') -> evaluateQueue q' (flip (M.insert k) <$> acc <*> mx)"
haskell,37bf7l,kraml,3,Wed May 27 22:33:03 2015 UTC,"The implementation seems rather inefficient, as it is in O(p * n) where p is the number of different priorities and n the size of the whole structure -- in short, quadratic. Implementing it efficiently would be an interesting challenge; basically, one would like to be able to fetch all Prio nodes, sort them, process them in order, and then plug them back into the structure in their original places. But: - because the different nodes have different types, putting them in a single collection and sorting them is tricky - removing them from a specific part of the structure and pluggin them back in place afterwards is also tricky to do in a purely functional way  Perhaps a solution to this problem would be to turn a Prio structure in a stream of priotized requests. You would have something like:  data Request p m a =   Done :: Ap Id a -> Request p m a   Request :: forall b . p -> m b -> (b -> Request p m a) -> Request p m a   where Ap is the free applicative (and thus Ap Id a pure applicative structure), and then a function  schedule :: Prio p m a -> Request p m a   that would order the requests coming from the two branches of App by priority, and  resolve :: Request p m a -> m (Ap Id a)   that would run all requests in order, and return the pure applicative structure."
haskell,37cy1w,haskellrocks,8,Tue May 26 18:41:46 2015 UTC,"However, am I justified in using unsafePerformIO in this case?   No, and if you aren't really careful, the optimizer will ""break"" the code written with unsafePerformIO -- like getting ""stale"" results."
haskell,37cy1w,bss03,5,Tue May 26 19:29:35 2015 UTC,"I realize that I should've put this in my original question, but I intend the key-value store to be immutable, so results can never be stale."
haskell,37cy1w,Faucelme,8,Tue May 26 21:04:21 2015 UTC,You may find this blog post interesting: Is network I/O always an effect worth tracking?
haskell,37cy1w,bss03,3,Tue May 26 21:23:31 2015 UTC,"Aaah.  Really immutable?  Or just this program can't change it?  If the former, then careful use of unsafePerformIO should work.  If the later, I'd still avoid it."
haskell,37cy1w,sordina,2,Wed May 27 04:40:11 2015 UTC,"Do you mean immutable, or idempotent? It would be odd if the key-value store was read-only, but even if it isn't you should absolutely use an IO type."
haskell,37cy1w,Oremorj,7,Wed May 27 00:50:18 2015 UTC,"This is one of those things... if you have to ask, then you aren't justified in using unsafePerformIO."
haskell,37cy1w,Faucelme,4,Tue May 26 23:33:25 2015 UTC,"computations would need to be wrapped in an IO monad. However, this feels somewhat problematic to me, since Monadic IO is used to sequence operations, and the order of accesses to the key-value store is irrelevant.   Using the Concurrently applicative from the async package, it's easy to run IO actions concurrently. See this Stack Overflow answer for an example."
haskell,37cy1w,mstksg,4,Tue May 26 19:16:23 2015 UTC,"monadic IO is used to sequence actions, but the IO type is used in general to represent IO actions and doesn't have much inherently to do with sequencing :)"
haskell,37cy1w,maxigit,3,Tue May 26 19:25:49 2015 UTC,"You are exactly in the case where you need to use IO and the use of unsafePerformIO is bad.  Without IO, your break referential transparency, i.e. a function called with the same arguments, returns the same result. Accessing the key value store with the same key might get different result if the value has been updated in between.   This leads to the sequence of operations, let's say you do something like   do   old <- read key   store key (old+1)   new <- read key   print new -- old +1   Do you still think the order doesn't matter ?"
haskell,37cy1w,pchiusano,2,Tue May 26 19:38:34 2015 UTC,"For my specific use case, I intend the data store to be immutable, so order wouldn't matter."
haskell,37cy1w,maxigit,5,Tue May 26 20:49:42 2015 UTC,"Even if you intend the data to be immutable, you'd also have to ensure that your program can never observe values being populated. And even if you somehow manage to satisfy that constraint, most people would argue it is still worth tracking the effect in the types, since accessing a remote (even immutable) data store is the sort of thing one usually wants reflected in the types. As others have mentioned, using IO doesn't force you to completely sequentialize your computations, you're free to do things with as much concurrency as you think makes sense for what you're doing.  That said, you may find this article interesting: https://pchiusano.github.io/2014-05-21/what-effects-are-worth-tracking.html That article should not be taken as an endorsement of using unsafePerformIO for your use case. :)"
haskell,37cy1w,codygman,2,Tue May 26 21:43:07 2015 UTC,"Even if your store is immutable within a run, I guess it won't be between to runs, or to between my machine and your machine.  So you can't write tests checking that get ""hello"" returns let's say 5 all the time. That's breaking referential transparency. That might no be a problem for function obviously calling your store, but what for function like   f :: Int -> Int f x = (get ""hello"") + x   How do you know that this function return a different results depending on the environment and it's not testable ?  You need to mark this function as not pure. IO is a way of doing it. If what's bothering you with IO is the fact that any function accessing the store can do anything (like launching nuclear missiles) you can build your own  monad (using MonadIO) which only allows to access the store. This way all functions accessing the store directly AND indirectly will be tagged as ""accessing the store"" and won't be seen as full IO.  Alternatively, if the number of keys is relatively small, you can read all of them upfront, store them in a map, and just pass the map around."
haskell,37cy1w,the_abyss,2,Wed May 27 06:29:57 2015 UTC,"When I hear ""order wouldn't matter"" I think of applicative and the Haxl paper."
haskell,37cy1w,tomberek,3,Fri May 29 07:31:55 2015 UTC,http://michaelxavier.net/posts/2014-04-27-Cool-Idea-Free-Monads-for-Testing-Redis-Calls.html
haskell,37cy1w,bss03,3,Tue May 26 19:01:48 2015 UTC,Sounds like Haxl: https://github.com/facebook/Haxl
haskell,37cy1w,dagit,3,Tue May 26 19:21:31 2015 UTC,"Monadic IO is used to sequence operations   Not really.  (>>=) / (>=>) are ordered in the same way that flip ($) / flip (.) are -- via data dependency.  join and (<*>) are not really ordered, at least not always ordered left-to-right and top-to-bottom.  For example, the reverse state monad is ""backwards"" and the tardis monad goes both directions."
haskell,37cy1w,beerdude26,3,Tue May 26 19:34:55 2015 UTC,"If the values in the key value store really are read-only and persistent, then using unsafePerformIO shouldn't change the computation. It should always produce the same result. But...  Something that may still be observable are the errors and exceptions.  The middle ground here is unsafeInterleaveIO. You'd still be saddled with an IO type but you'd remove the sequencing of IO."
haskell,37bez4,beerdude26,3,Tue May 26 11:37:48 2015 UTC,"Thrift is easy to work with once you see the implementation generated from the interface (easy to understand code, even if autogenerated). However I've posted this before on this subreddit the Haskell implementation is slow. Someone from the Haskell community with necessary knowledge could be nicely asked to optimize the implementation."
haskell,37bez4,alt_account10,3,Tue May 26 12:03:39 2015 UTC,"Just few days ago I hacked a bit on riak library, which uses protocol buffers to talk to riak, so I think you can read it as an example.  I will send a request to take over on maintainership of protocol-buffers package, since it's author seems to not maintain it anymore, and if this will happen I will try to then add few examples and make a nice README and all that, but this will take at least 4-6 weeks."
haskell,37bez4,k-bx,2,Tue May 26 13:17:00 2015 UTC,"One great thing to add to protocol-buffers would be some way to generate lenses for fields, which greatly simplifies manipulating heavily-nested protobufs (which are fairly common in practice).    I hacked up a script to add lenses after the fact (example usage at 1), but it would be great to have something like that generated automatically."
haskell,37bez4,ajtulloch,3,Tue May 26 15:03:45 2015 UTC,We use both protocol buffers and thrift. Thrift is used for its RPC capabilities. We store a large amount of data in protocol buffers. We also built the protobuf library (https://hackage.haskell.org/package/protobuf). Some samples are included to get you going.  I have not found thrift to be slow enough to warrant fixing it. Our bottlenecks are around database calls not serialization.   Do you have more specific questions?
haskell,37bez4,sseveran,1 point,Tue May 26 17:59:16 2015 UTC,your package has awesome documentation
haskell,37bez4,sambocyn,1 point,Fri May 29 20:26:55 2015 UTC,Thanks. Let me know if you see anything missing.
haskell,37acql,Rufflewind,10,Tue May 26 03:53:55 2015 UTC,"Screenshot example: http://i.imgur.com/phjXeA0.png  What it does (or tries to, at least):   adds colors to the errors and warnings from GHC, counts the number of errors and warnings, and pastes the offending line and points out the offending token.   I find it quite useful: aside from being pleasant on the eyes, it does also improve readability IMO.  Sadly this is mostly a hack :)  It tries to parse the output from GHC, which can be a bit tricky due to the pretty-printing.  Furthermore, I've not added all the possible messages that GHC produces, so for the rarer messages you might not see it properly colored; however it's generally very easy to modify the script to fix that.  (The Unicode/color detection is also quite sketchy.)  Ideally though, it would be nice to bake this into GHC directly, but that's a long term project :)"
haskell,37acql,Mob_Of_One,6,Tue May 26 03:58:28 2015 UTC,"Ideally though, it would be nice to bake this into GHC directly, but that's a long term project :)   Indeed, that would be really nice. Are you thinking you might look to translate the Python program to Haskell, then figure out GHC integration after that?"
haskell,37acql,rdfox,9,Tue May 26 04:19:29 2015 UTC,"There isn't much point in translating this script into a Haskell one.  If anything, it would probably end up being more complicated.  Ultimately, it would be better to add it directly to GHC as a compiler feature, similar to how GCC/Clang have it nowadays.  In fact, there's even a ticket on Trac from over a year ago."
haskell,37acql,Mob_Of_One,2,Tue May 26 04:33:51 2015 UTC,"Unlike most GHC projects, this one would be easy and could be done incrementally and without too much debate. All the printing in GHC is done using pretty-printing combinators. There's already a library for ANSI combinators which is more-or-less backwards compatible. This could be a fun weekend project attaching colors to various outputs.  The only drawback is it adds a dependency and GHC already has plenty."
haskell,37acql,twanvl,3,Thu May 28 23:47:33 2015 UTC,"From what I saw in Clang's source code, one simply needs to call like 2-3 functions in terminfo to determine whether color is supported.  After that, the ANSI color codes can be just done manually using escape codes if one doesn't want to incur a dependency on that lirbary.  Personally, I don't really see a reason to bring in a full-fledged library for this."
haskell,37acql,k-bx,1 point,Fri May 29 04:01:47 2015 UTC,"Gotcha, thanks for linking the ticket!"
haskell,37acql,creichert,6,Tue May 26 04:56:30 2015 UTC,"Color is good. Your hack sounds similar to what grc does.  But IMO you highlighted the most useless part of the error message. During the renaming phase most errors will be 'not in scope' errors, so that tells me nothing interesting. I instead want to know where the error is and the name in which I made a typo/that I forgot to import."
haskell,37acql,RedLambda,8,Tue May 26 12:16:28 2015 UTC,"Just for information of those who doesn't know, if you compile your project inside emacs via M-x compile, it will also colorize output, and will also let you navigate up/down by M-p/n and go to error-file by just hitting Enter when on it."
haskell,37acql,rdfox,5,Tue May 26 13:21:35 2015 UTC,I use this feature heavily. There are also the command for haskell-interactive-mode which support error jumping (haskell-interactactive-mode-error-forward and haskell-interactive-mode-error-backward).
haskell,37acql,k-bx,2,Tue May 26 15:37:10 2015 UTC,I currently use M-x haskell-compile which supports more of GHC's message syntax including -ferror-spans
haskell,37acql,jberryman,2,Tue May 26 17:36:19 2015 UTC,Man we vimers suffer for our preference.
haskell,37acql,joehillen,3,Thu May 28 23:50:29 2015 UTC,"Hehe. I've heard spacemacs is very-very nice (it default to evil-mode, which has vim keybindings)."
haskell,37acql,RedLambda,3,Fri May 29 12:39:21 2015 UTC,Some other things you might do (that I would personally like) are    bold the line number (usually I don't even read type checker errors and just look for the line) add whitespace around the filename so I can double click to select the text for middle-click pasting (maybe I'm the only person who does this a lot)
haskell,37acql,RedLambda,3,Tue May 26 12:00:56 2015 UTC,so I can double click to select the text for middle-click pasting (maybe I'm the only person who does this a lot)   You're definitely not.
haskell,37acql,RedLambda,1 point,Tue May 26 17:15:38 2015 UTC,Thanks for the suggestions!   (maybe I'm the only person who does this a lot)   I usually have the file already open in the editor when I compile :)
haskell,37acql,augustss,1 point,Tue May 26 17:28:37 2015 UTC,Which editor btw?
haskell,37acql,k-bx,2,Tue May 26 17:47:06 2015 UTC,"Emacs.  When switching between files that I already have open, the autocompletion allows me to type only a few characters."
haskell,37acql,EsperSpirit,2,Tue May 26 18:01:21 2015 UTC,Interesting... but then I wonder why you didn't try to implement your wrapper script in terms of Emacs compile buffer... doesn't its ansi coloring conflict w/ Emacs' compile buffer facility (assuming you don't have it running in a separate terminal outside Emacs which would be... un-Emacsy :) )?
haskell,37acql,RedLambda,2,Wed May 27 07:49:48 2015 UTC,"Funny you say that.  I guess I got used to doing only text editing to Emacs.  I never compile stuff in Emacs, except TeX but even for that I'm moving away from it.  I tend to have unconventional workflows for things and it would be difficult to set it up the way I like within Emacs and I enjoy the flexibility of doing stuff manually in the terminal.  As for the question of whether it's compatible, I've not tried at all (until now).  It seems the -ferror-spans breaks the script, so nothing gets highlighted at all – which I guess is fine? :P"
haskell,37acql,Taladar,3,Thu May 28 01:03:34 2015 UTC,"Yeah, you definitely lose some degree of flexibility... but I wouldn't want to miss triggering a haskell-compile by a shortcut and then with another shortcut jump directly to errors/warnings w/ error-underlining the specific sub-expression in a line pointed to by the error message... and I do still have a terminal open for doing stuff outside of that workflow..."
haskell,37acql,RedLambda,5,Thu May 28 06:58:14 2015 UTC,It's in Python. :(
haskell,37acql,Taladar,3,Tue May 26 11:06:56 2015 UTC,GHC's test-suite is in Python :P
haskell,37acql,augustss,1 point,Tue May 26 17:52:36 2015 UTC,"It's in Python. :D   fix'd :P  edit: On a more serious note, Python is a great language for scripting. Haskell's power really comes through when doing larger projects or abstractions."
haskell,37acql,RedLambda,1 point,Tue May 26 22:06:29 2015 UTC,"Yeah, Python is still more concise than Haskell for the more everyday basic stuff  Stuff like  sum(map(int, open(""numbers.lst"")))   or  for line in open(""foo.txt""):     # ...do something with ""line""   is still more concise than the equivalent (while avoiding lazy I/O where you lose control over resource deallocation) in Haskell, and don't get me started with simple things like e.g. splitting strings into at most N parts based on a separator-string or a regexp, or generally performing a regexp substitution on a string (such as e.g. transforming all CamelCase words into snake_case words in a string) ... this is all stuff I get laughed at by my Python colleagues :-/"
haskell,37acql,augustss,5,Wed May 27 08:00:09 2015 UTC,And then there was that day wasted on using regexps for something that I did in Haskell with parsec the next day in an hour...
haskell,37acql,RedLambda,1 point,Wed May 27 08:36:36 2015 UTC,How can you use parsec for doing e.g. regexp-based string replace?
haskell,37acql,augustss,3,Wed May 27 08:46:28 2015 UTC,"Basically by attempting a parse in every position in the text, the performance is improved if you limit yourself to e.g. all positions after whitespace or some similar criterion you can easily determine in the raw string.  The actual use case was some form of replacing the output of templating language (a PHP function call with surrounding PHP tags with a variable number of arguments, some of which could be other calls) with the construct which produced that output to recover the template source which had been lost in a migration. Regular expressions dealt particularly badly with the nested case while it was no problem at all for Parsec."
haskell,37acql,RedLambda,3,Wed May 27 09:01:58 2015 UTC,For most simple stuff I don't see why lazy reading is a problem.  I use it all the time.
haskell,37acql,augustss,2,Wed May 27 10:19:31 2015 UTC,"Maybe I did something wrong, but I wrote a tool that traversed a directory operating on each file and got burned as it ran out of filedescriptors... :("
haskell,37apee,goliatskipson,3,Tue May 26 05:58:11 2015 UTC,"The cereal vs attoparsec results are interesting and worth bearing in mind. The code looks so similar, but the performance difference is dramatic."
haskell,37apee,acow,6,Tue May 26 15:34:11 2015 UTC,That's probably because attoparsec is an actual parser while binary/cereal is a serializer?
haskell,37apee,Tekmo,4,Tue May 26 16:00:06 2015 UTC,"nom was never really a parser either (no backtracking), so binary/cereal were a much more appropriate comparison"
haskell,37apee,acow,2,Tue May 26 17:51:15 2015 UTC,"Sure, but clearly their domains overlap, and attoparsec has a reputation for being fast. I'm really just drawing attention to the fact that jumping straight to a parsing library may buy you something should you need to complicate the parsing logic in the future, but it's not a trade off without downsides. I'm sure I've made this mistake before.  Viewing this example from a the-world-is-more-than-Haskell perspective, it's a nice reminder that our low level serialization options are actually pretty sweet."
haskell,37apee,emmanueltouzery,2,Tue May 26 16:34:41 2015 UTC,i wonder where binary stacks compared to cereal and the others.
haskell,37apee,emmanueltouzery,5,Tue May 26 06:10:10 2015 UTC,"Not sure what you mean by ""binary stacks"" but if it is ""parsers written in C without libraries"" I can tell it is probably not worth the effort. Parsing is quite complex once you get over CSV files and most of the time your hand rolled parser will do worse than the parser combinator ones.  Now ... if you are an expert C parser developer ... you might fair better than that. But my bet is that writing a hand tuned parser will still take too long to write and be a convoluted mess. In the end it won't be economical to do it."
haskell,37apee,merijnv,3,Tue May 26 06:27:21 2015 UTC,i was asking about the binary package. should have put a link in my post :-)
haskell,37apee,merijnv,3,Tue May 26 06:36:05 2015 UTC,Oh... :-)   I think the main difference is that binary only takes lazy ByteStrings as input. AFAIK this makes binary slightly slower than cereal. But don't take my word on that.
haskell,37apee,vincenthz,8,Tue May 26 06:42:35 2015 UTC,"binary has had support for incremental parsing of strict ByteString for some time now, rendering cereal mostly obsolete, AFAIK, since performance is comparable between the two. The only thing cereal does which binary can't is building strict ByteString, but I was told that building lazy and then converting toStrict is usually faster, although I forgot why.  edit: forgot a word."
haskell,37apee,rstd,2,Tue May 26 07:30:56 2015 UTC,That makes sense. I always wondered why there are two competing libraries in this case with one of them not included in the Haskell Platform.
haskell,37apee,dcoutts,5,Tue May 26 10:03:36 2015 UTC,"Because in the past binary only did lazy ByteString and no incremental parsing of strict ByteString, there was some discussion about merging cereal and binary, but now that binary supports incremental parsing I've not heard anything about this anymore. Personally I'm just defaulting to binary for everything until I run into evidence that cereal is better for some specific use case."
haskell,37apee,mstksg,4,Tue May 26 10:48:21 2015 UTC,"In most of my benchmarks binary was much faster than cereal, despite the lazy bytestring.  edit: some of those benchmarks can be found in packer's benchs directory; I've got some other benchs which are not part of this, but they all show roughly the same thing anyway."
haskell,377zyc,FPguy,42,Mon May 25 17:03:33 2015 UTC,"I think I can help with a few of these. I've been trying to find the time to do a write up but here are a few details. We are by no means at the scale of Facebook or some others, but we are growing and our current problem set matches a few of the bullets outlined.  I co-founded a company which builds a web service and API to aggregate real estate data sources (https://simplyrets.com). These data sources are similar to local governments and are notoriously fragmented and hindered by a fairly complex data protocol and specification (RETS).  Real Estate data sources are locale unique and normalizing them is difficult due to regulations and minor differences in location specific details (e.g. Miami real estate is often described and sold differently than real estate in New York City, in very pedantic ways)  Developers interested in working with real-estate data have a hard time dealing with these sources as-is due to several complications (time-consuming, expensive, too many gotcha's). On top of that,  the tools available to real estate brokers and agents is very poor for for the same set of reasons.  Each unique data source's models are large and flat, 250-500 fields in a single record. There are over 900 sources in the U.S. and several in Canada. We haven't aggregated them all yet but are continually adding new sources to our backend.  Each source potentiall has ~50,000-100,000 active listings at any given time with a few million in historical data. The listings receive hourly updates which means we pretty much have sources aggregating our data at all times. Each listing has 10-50 associate images (which we distribute as well). With the exception of each having their own set of quirks and gotcha's, they look something like this: https://github.com/NationalAssociationOfRealtors/reso-data-dictionary/blob/master/index.js#L2  Our code base is about 1 year old. Needless to say, the abstraction power of Haskell has helped us deal with the fragmented data sources seamlessly. I am constantly /removing/ source lines from first iterations in favor of higher level abstraction and it has been extremely robust. We deal with very few bugs on a regular basis, which is awesome. We have found the Haskell tooling quite good for our small team. The only problem we face (which we have found techniques to mitigate) are long compile times.  Benefits of using Haskell  Haskell is an extremely nice option for a few reasons:   Express invariants across our distributed system using types. This is a major advantage. We can move on to new exciting features without as much baggage and technical debt. Reduced complexity in our code. Like I mentioned before,  we are removing LOC in spite of changing requirements and unexpectedly introduced complexity. Rapid deployment. We push to production several times a day. If a bug is introduced, we describe the problem in our test, try to introduce the invariant at the type-level, and almost never see a bug twice. Extremely high code reusability. It's insane, actually. Functor, Applicative, Alternative, Monad are the tip of the iceberg and it becomes second nature to start developing .Extra module for high level combinators specific to our problem. For example, we reuse many of the same functions for XML and CSV parsing for describing possible flaws in the input data. They are very terse and easy to understand. Rapid Prototyping : One of the best ways I have seen Haskell introduced in a corporate environment is simply for developers to hack on something small like a web service or command-line app in their flex time (or free time if you have it). This is low-pressure and often speaks for itself to management who will then jump at it because it's already built (prototypes become products). Added points if it saves time or money.   Some Haskell tools we use:   Yesod/Keter Scotty WAI Persistent postgresql-simple csv-conduit,xml-conduit Shake attoparsec Clay / Blaze HSpec (HUnit and QuickCheck, of course)   Some Non-Haskell Tools:   Postgresql PostGIS AWS Stripe React PHP (some wordpress) We also used Swagger (and the Haskell DSL) to define our API specification. We were able to generate API clients for Python and Ruby (with many more possibilities). Stackage LTS   We honestly don't have a ton of issues with Cabal and Hackage proper but when we do we use Stackage cabal.config's. We do use Stackage LTS, though, as a target for tested/stable production builds.  Responses   Python and Haskell side-by-side - Transitions from Python to Haskell - GeoSpatial examples   One neat service we wrote was our own Geocoder using PostGIS and TIGER data which falls back to Nominatim when the TIGER data is insufficient. We used Docker to encapsulate the entire database build process and wrapped it in a WAI/postgresql-simple web API. I talked about it a bit at the Houston Haskell Users Group and plan to open source it very soon.   Specially stories reflecting how easy is to adapt an existing system to new requirements and changes in agile development and TDD.   Each new data source we integrate introduces something unexpected. The systems we connect to have been maintained long-term and are slow to adopt new changes in technology.   Again, our technique is to write a test, attempt to introduce the invariant at the type level, and move on from it. It's not that fixing the bugs is not possible in another language, it's that we don't see it escape compile-time again if we have described it properly.   Haskell touts performance/concurrency, so any success stories regarding Haskell project working at very large scales would be valuable.   I can't speak on concurrency at an extremely large scale. What I can say is that multi-threading and concurrency is very cheap to reason about, compose, and build upon in Haskell. We rarely have to consider minor technical details regarding our use of concurrency.  I come from a C++ and Python background where concurrency was somewhat expensive time-wise and I almost always experienced issues in team settings.   I'd like to see a success story with the tooling, in particular with IDEs :) It is just impossible to sell a ""serious"" language without it.   The tooling is actually quite good. We have no dominant IDE yet, I suppose. But here are some solid options we have used:   EMacs (haskell-mode) Haskforce IDE plugin : https://github.com/carymrobbins/intellij-haskforce Codex (using Hasktags) : Generate CTAGS/ETAGS for an entire cabal project and it's dependencies, and your sandbox add-source dependencies. I use this exensively GHC-Mod Stylish-Haskell Of course HLint, Hoogle, Haddock, DocTest, and HPC to some extent. See Haskeleton for introducing all of these tools into your testing suite.    Fast adoption by company personnel without background using haskell that become productive in a short time   This has become the toughest part about introducing Haskell to new teams which were only moderately interested, in my experience. More importantly, the prerequisite's seem to be that, developers are highly interested in improving their craft, have some functional programming experience, and are convinced that static/strong typing will help them reduce bugs in their code, saving time and effort. Otherwise, the learning curve is currently steep for many developers with no FP experience to come up to speed quickly.  This might become a bit easier as FP and Haskell-like features are continually added to familiar languages.  I'm hoping to find the time to due a more detailed writeup soon. I will be happy to provide more details to FPComplete if this would help."
haskell,377zyc,creichert,6,Mon May 25 18:23:24 2015 UTC,"https://wiki.haskell.org/Haskell_in_industry   Awesome, thanks a ton for the thoughtful writeup. I've been spending a lot of time on Haskell lately, and have been turning a lot of these questions around in my mind - and flip-flopping quite often, at that!   At first I was a full Haskell convert - there is nothing like writing a small module such as tic-tac-toe or a CSS parser in Haskell. The reduction in bugs (even in a small code base like those) is astounding.  But as I've gotten into larger things, mainly web apps, I've started to get more reluctant about the feasibility of production level Haskell. One turnoff for me is that I still have to think about Applicatives and Monads when I'm defining server routes and making my application. I kind of assumed at some point those lower level concepts would be abstracted away, but that hasn't seemed to have happened yet.  The other, and more broad complaint, is just the resources available. There is actually a pretty large pool of beginner material, but then it jumps right to the more academic and advanced use of Haskell. Basically I haven't had much luck finding good answers when I get stuck making a larger project (again, web apps).  Are these hurdles you've had to overcome? And/or do you have any advice in regards to any of this? I guess the larger issue I might be facing is that Haskell has a steep and long learning curve, but is that an issue you had to consider as well (hiring new people, etc.?).  Thanks again for the great post and any guidance would be awesome.  BTW - the two cents I can actually add to this post is that I've found the IDE tooling to be generally very nice. I use Atom, which is a new Sublime-like editor, and it already has really nice Haskell support (due to the robust package environment). There is the standard syntax highlighting and autocomplete, plus an 'hlint' plugin for live linting, and a live ghc-mod plugin for general errors and type definitions."
haskell,377zyc,TdotGdot,8,Mon May 25 21:18:31 2015 UTC,"It's interesting to see you describe Applicative and Monad as ""low level concepts"" that should be abstracted away."
haskell,377zyc,hiptobecubic,1 point,Mon May 25 21:45:38 2015 UTC,"Well, it may just be my naive-ity, but aren't they? I know they are general concepts as well, but having to keep a mental map from abstract calculus to the actual code you want to write when making a web app doesn't seem very user friendly."
haskell,377zyc,TdotGdot,10,Mon May 25 23:10:37 2015 UTC,"The intended purpose of type classes like Applicative and Monad is to provide a uniform interface to a wide variety of disparate libraries and application domains.  If you abstract them away it defeats their purpose.  Also, even if you were to abstract them away, it's not clear what interface you would want to replace them with.  Maybe if you suggested a specific interface or syntax that you would prefer when writing a web app it would help clear things up."
haskell,377zyc,Tekmo,6,Mon May 25 23:54:56 2015 UTC,"Anything you abstracted them away with would require you to hold even weirder category theory in your head. Are you really sure that's what you actually want?  Now, you could ""specialize"" (not exactly the right term, but it's close-ish) them away and make it less weird, but you also lose code reuse and extensibility that way, so it's a trade-off."
haskell,377zyc,WarDaft,24,Tue May 26 00:24:09 2015 UTC,"It doesn't seemed to get cited as much as it should, but Ryan Trinkle's CUFP presentation in 2013 is a great success story.  The executive summary is that they rewrote a 43K line Groovy app in Haskell.  It resulted in an 80% code reduction, ~64x performance improvement, and completely eliminated a number of major bugs with the Groovy system.  Here's a link directly to the results portion of the talk:  https://www.youtube.com/watch?v=BveDrw9CwEg&feature=youtu.be&t=1208"
haskell,377zyc,mightybyte,7,Mon May 25 18:29:49 2015 UTC,"I'd like to see a success story with the tooling, in particular with IDEs :) It is just impossible to sell a ""serious"" language without it.   Yes!  My own experiences with Haskell tooling has been quite negative. Even when compared to an even less popular language - OCaml. In Haskell, if you want auto completion and getting the types of identifiers and/or selections you are spoiled for choice. This list is probably incomplete:   hsdev ghc-mod ghci-ng fpco's ide backend hdevtools   The sum of those tools roughly provide the same functionality as merlin in OCaml. However, merlin supports at least 2 editors very well (emacs + vim), does not require your code to always typecheck or compile, and is blazing fast.  This situation is very unfortunate. It's clear that there's a lot of effort being put in to improve tooling but due to fragmentation, the end result ends up looking rather unpolished."
haskell,377zyc,Categoria,4,Tue May 26 04:27:59 2015 UTC,"does not require your code to always typecheck or compile   That's the main issue I have with the current tooling. When I need to ask my tools for something, chances are that my code is currently not in a working state. For instance I can't infer types with hdevtools while I'm actually writing the code, but that's when I need the feature the most. I've resorted to abusing typed holes and ghci for this but it's nowhere near optimal as a workflow."
haskell,377zyc,tsahyt,7,Tue May 26 08:51:44 2015 UTC,"If you are looking for Haskell use in the enterprise: At Suite Solutions, we provide intelligent content delivery products and solutions for the enterprise. See the customer logos banner on our home page for a small sampling of our customer base. Other examples not listed there: VMware, Avaya, Teradata, and more.  Our three flagship products are (roughly): a large web app, a large static site generator, and a Jive API client for publishing content. All three are based on an underlying engine that parses and analyzes large publication sets written in rich semantic markup languages such as DITA. The first two are written entirely in Haskell, except for a small amount of integration wrapper code. The Jive API client interface is Java, but the semantic publishing engine driving it is Haskell. We have also written quite a bit of solutions code in Haskell, e.g., for processing SGML aerospace documentation.  Haskell allows us to express rich semantic structures faithfully in the type system, and laziness/purity then allows us express our algorithms directly in terms of the types. That gives us high reliability while retaining high performance. And as market demands quickly change, that semantic preciseness gives us maximum refactoring speed with minimum bugs. We are also able to provide security and privacy guarantees more easily. All of those features are critical for enterprise software development, so Haskell gives us a definite leg up over our competitors.  We don't find the toolset to be an issue. We use Haskell Platform and cabal. Now that ""cabal hell"" is a thing of the past, this works great for us. Most of our Haskell developers use generic Windows editors, such as Notepad++ and Oxygen, and are happy with them. I use Emacs.  Most of our Haskell devs learned Haskell in-house starting with no previous knowledge. I didn't tell them that there is a ""big learning curve"", so they just jumped in and became productive quickly. Other devs who have not done Haskell programming yet are a bit jealous, so they are learning Haskell on the side and hope to join in soon. Our devs are not academics; they are hands-on down-in-the-trenches engineers, highly focused on getting good results out the door quickly. But they are talented creative thinkers. If your office is full of boring semi-robotic code grinders, this approach may not work as well for you."
haskell,377zyc,yitz,3,Tue May 26 09:47:12 2015 UTC,This is super interesting. Would you be willing to write up a more detailed version? I'd love for us to post (or link to) more such success stories.
haskell,377zyc,yitz,3,Tue May 26 15:43:47 2015 UTC,I'd love to try. Let's be in touch.
haskell,377zyc,radix,4,Wed May 27 09:54:29 2015 UTC,"Just for reference in this discussion, here's where I've found Haskell success stories / case studies with some quick searching:   https://www.fpcomplete.com/business/resources/case-studies/ -- generally pretty ""polished"" case studies, but it varies https://wiki.haskell.org/Haskell_in_industry -- very big list of companies using Haskell, low on details in general   Actually those are the only two significant lists I could find -- though the wiki page is quite long. Any others I missed?"
haskell,377zyc,Pikachut,2,Mon May 25 17:33:34 2015 UTC,The first link is OP's company. :)
haskell,377zyc,agocorona,1 point,Mon May 25 18:49:11 2015 UTC,No details but lots of names: https://github.com/commercialhaskell/commercialhaskell#companies
haskell,377zyc,dagit,3,Mon May 25 23:08:32 2015 UTC,"IMHO the success of Ruby and Scala is due to some products and services: rails and twitter. rails for perceived ease of use, twitter for confidence.  In the case of Haskell, the key for success could be some outstanding EDSL for easing some general IT problem and a well known site that  may use it.   The need of IDEs, toolkits, advertising how fine the language is etc sounds to me like following the marketing of all these products with visual aesthetics and dozens of screenshots and features on paper that we see in advertising and nobody uses.   Nobody switch to another language for having a nice IDE or for abstract computer science.  Ruby had no IDE and no theory. The kind of people that are prescriptors in the companies do not consider these details. They are seduced by a single  practical feature that no other language has. Something that let them say at first glance: ""Wow this changes everithing. Makes my work easier!!"""
haskell,377zyc,mcandre,2,Tue May 26 15:02:57 2015 UTC,"Have you looked at the survey data? Over 1240 people share their opinions on similar matters. These points do come up, though not as the top priorities."
haskell,377zyc,pbvas,2,Tue May 26 15:42:50 2015 UTC,"A very common theme in these responses could be summed up by saying ""We want assurances about risk."" Specifically, the risk of adopting a technology that they don't currently use, Haskell."
haskell,377zyc,SrPeixinho,0,Wed May 27 03:12:14 2015 UTC,"order of magnitude performance gain in program execution adoption by major software companies (Facebook's a start) shelf space. kill java, .NET, and ruby textbooks university adoption, from cs 101 through graduate level courses well-supported jvm and .NET backends. people just won't leave those stupid environments. increased desire for more formal software verification, or at least statically typed programming"
haskell,377zyc,Denommus,2,Mon May 25 23:39:35 2015 UTC,"While these are interesting and understandable desires, this study is based on the results of a survey of over 1240 people expressing their desires in response to a structured questionnaire."
haskell,37a1cq,begriffs,2,Tue May 26 02:17:07 2015 UTC,"Added a link to this on the Haskell wiki. Also cleaned up that page a little, 'cause jesus it was badly formatted."
haskell,376aqh,NiftyIon,15,Mon May 25 06:05:34 2015 UTC,"IHaskell is now available as a kernel on try.jupyter.org. This means that you can go to try.jupyter.org, wait for tmpnb to create you a new notebook server, click ""New"", and select ""Haskell"", and create a new Haskell notebook that you can play around in! (It's all running in a docker container, so certain things like some file IO are restricted, and there's only 1 or 2 gb of memory available.)  This may be the easiest way to play with close-to-complete Haskell.   Thanks to Sumit Sahrawat for pushing this through and getting this done! He's working with me on IHaskell this summer for Google Summer of Code and has been working on various tasks across the board as part of the ""community bonding"", and he's already been incredibly productive and helpful."
haskell,376aqh,astynahs,7,Mon May 25 06:09:32 2015 UTC,"NBViewer doesn't highlight the Haskell properly for now, but it still great if I want to share some of my experiments :)"
haskell,376aqh,quchen,7,Mon May 25 07:30:36 2015 UTC,"From the initial looks of it, this is an awesome step up from the tryhaskell window."
haskell,376aqh,madjestic13,3,Mon May 25 08:29:24 2015 UTC,right here
haskell,376aqh,captain-sandwich,1 point,Mon May 25 12:35:29 2015 UTC,There are installation steps on the github repo Readme
haskell,376aqh,rdfox,1 point,Mon May 25 16:01:59 2015 UTC,I've tried and failed. Let me know if you can do it.
haskell,376aqh,guiraldelli,4,Mon May 25 13:16:47 2015 UTC,"If you haven't already, file an issue on the IHaskell bug tracker. IHaskell can be somewhat tricky to install but I'm pretty happy to help when people run into trouble.  The reason it tends to be hard to install is that it interfaces with a lot of libraries. It has to play nice with GHC, zeromq, ipython, and any display packages you want to install, which can include diagrams, charts, parsec, rlangqq, magic, hatex, plot, blaze, aeson, juicypixels, and some others. Installing it without the display packages tends to be somewhat easier, but many people immediately jump to installing it with all the display packages, which is somewhat unnecessary for most people and I should probably try to change the docs to encourage just installing what you need. Either way, I'm gradually working on the install process; it's gotten a lot better but has a ways to go. (Right now I'm working on whittling away the dependencies by simplifying the codebase; soon, no more classy-prelude, MissingH, cmdargs, shelly, system-filepath, or haskeline.)  In addition, I have Kronos Haskell which is at this point a little bit outdated (I haven't maintained it in a few months) but it still works if you're on a Mac. (It should get a major upgrade sometime this summer.)"
haskell,3773pn,baramoglo,3,Mon May 25 12:32:35 2015 UTC,The associated code is here: https://github.com/emilaxelsson/ho-rewriting  I plan to put it on Hackage at some point.
haskell,3773pn,seriousreddit,2,Tue May 26 07:17:19 2015 UTC,"I only skimmed the paper, but is there a function for getting all possible rewrites rather than just one? E.g., a function  matchAll   :: (Functor f, Foldable f, EqF f)   ⇒ LHS f a → Term f → [Subst f]"
haskell,3773pn,seriousreddit,2,Mon May 25 15:51:54 2015 UTC,"I assume you mean in situations where there is no most general solution (see section 3.3)?  There is no such function right now, but it wouldn't be too hard to add if there's a need."
haskell,377gy2,jleitgeb,3,Mon May 25 14:38:16 2015 UTC,Probably no one commenting because of the day. I wish this was around last year. This kind of accessible learning material really helps. Thanks!
haskell,377gy2,rdfox,2,Tue May 26 01:41:24 2015 UTC,Thanks!
haskell,377gy2,jpvillaisaza,4,Tue May 26 14:10:10 2015 UTC,"Minor correction: use ""bottom"" instead of ""undefined"", because undefined is not a set of values, but an ""alias"" for error ""Prelude.undefined"". ""Bottom"", however, is what pattern matching is defined with (IIRC).  (I know ""set"" sucks, but type, kind, sort, class are all taken)"
haskell,375xd3,uncountableB,16,Mon May 25 03:53:02 2015 UTC,"I surely sound like a broken record by now, but it's good that you've recognized the need to do something in order to learn something.  To that end, I'd suggest looking at my guide where course recommendations are laid and should provide the exercises that will satisfy you.  Particularly the second course (the one you do after cis194) involves rewriting much of the standard library so you grok it properly.  Hope this helps. Whatever you decide, please post an update on your progress and how it goes!"
haskell,375xd3,Mob_Of_One,2,Mon May 25 03:57:03 2015 UTC,"I haven't been on here in a while, so you're not a broken record for me! XD  Thanks! I'll check it out, and sure, I would love to hear feedback as I continue learning."
haskell,375xd3,rdfox,1 point,Mon May 25 03:59:24 2015 UTC,"Hmm, interesting. Even if I try and mess around with everything he gives me? Its been helpful so far, but maybe going through a course might expedite the process a bit."
haskell,375xd3,Mob_Of_One,1 point,Mon May 25 14:54:00 2015 UTC,"I just looked at the credit card and towers of hanoi exercises. Those look fun, haha."
haskell,375xd3,paulsamways,2,Mon May 25 22:35:35 2015 UTC,You give good advice. But what about attaining intermediate knowledge? I've done all of those courses. I'm still baffled by half the discussions around here with the type families and such. GHC documentation (chapter 7) is the best resource I've found but it's not tutorial at all.
haskell,375xd3,Mob_Of_One,2,Tue May 26 00:23:04 2015 UTC,"This is going to sound really weird, but one of my favorite ways to learn about how things like GADTs and type families work is to read what they wrote about it back when they were implementing it. Read old trac tickets and ancient GHC manuals. There might be some errata, but I found that more illuminating than the blog-diaspora for GHC extensions specifically. This applies particularly with GADTs where it was a convergence of disparate faculties and use-cases.  For intermediate content the following are indispensable (I will invariably forget some people, if I did, sorry!):   http://ezyang.com/ http://comonad.com/ http://haskellforall.com/ https://ro-che.info/articles/ Pretty much anything this gent writes. If you want to go hunting Nice thematic collections of content here: https://ocharles.org.uk/blog/ - apropos to GHC extensions, there are some good introductions but I wasn't finding grokhood because of the time->length constraints on the content. (Needs exercises too)   And then there's the specific topic listing in the guide:   https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md   There's very little about GADTs because I've not decided what material to recommend. I liked Eisenberg's workshop at LambdaConf though, so you look at glambda for code to kick around.  I'm not aware of good tutorials in general for intermediate topics. glambda is one of the few that bother with exercises at all.  Edit: I almost forgot, the ""intermediate"" course recommended in my guide is O'Sullivan's Stanford course covers some nice things like phantom types v. well. Some slides are missing, caveat lector.  Another suggestion: use Github search and if you find a non-trivial project or library[1] that uses the extension you're curious about, backtrack the Git repo history to see what caused them to use the extension!  [1]: My Haskell fiefdom for a Github ""No one-off repos"" filtering option.  If you know about the haskell book, I regret to inform you we probably won't have time to cover that. What we will cover is (mostly) listed here and the length/scope has already gotten out of control because of how thorough we're trying to be about the basics. I don't think we'll have time to cover any non-trivial GHC extensions or other intermediate topics beyond monad transformers, IO, non-strictness, and what datatypes to use in different situations. If I talk about extensions, it'll be so I can pay down the knowledge-debt created by wanting to explain mtl so people stop being afear'd of it.  If you have specific topics you'd like recs for, please do ask, but I don't really have compelling options for GHC extensions specifically beyond what I've suggested.   You give good advice.   You're very kind :)"
haskell,375xd3,elcric_circle,3,Tue May 26 05:12:07 2015 UTC,"I'd read quick then move on to the NICTA course,  https://github.com/NICTA/course."
haskell,37464x,Darwin226,2,Sun May 24 18:39:05 2015 UTC,"Why is the this argument passed to event callbacks? If you need it, you can always just put it in the closure yourself."
haskell,37464x,gergoerdi,3,Mon May 25 01:38:11 2015 UTC,"I guess it's because you can use the same handler for multiple events. It's how it is in .NET, not my invention."
haskell,37464x,gergoerdi,7,Mon May 25 05:14:19 2015 UTC,"But that's exactly my point. Suppose you have (I'm making up the types here but should be obvious enough what I mean)  myHandler :: Button -> ClickDetails -> UI () myHandler b cd = case someControlSpecificID b of   ""foo"" -> ...   ""bar"" -> ...   then instead of using it as  b1 <- button click b1 >>= handle myHandler b2 <- button click b2 >>= handle myHandler   you can do the, IMO, much cleaner  b1 <- button click b1 >>= handle (myHandler b1) b2 <- button click b2 >>= handle (myHandler b2)   since connecting to events should be completely orthogonal to the fact that your particular handler happens to depend on the particular control emitting the event.  I know the WinForms API is like this, but it was originally geared towards an ecosystem where creating throwaway closures to record extra data like that was not really easy."
haskell,37464x,codygman,3,Mon May 25 06:18:08 2015 UTC,You're right. That's a good idea.
haskell,37464x,dhomhsa,2,Mon May 25 06:21:02 2015 UTC,I'll have to try this out when I get home. Not a windows user but happy to support haskell/windows development.
haskell,374c3o,spopejoy,13,Sun May 24 19:28:15 2015 UTC,"() is the unit type, inhabited by just one value, namely (). You could argue that its value does not confer any particular meaning (since you'd need more than one value for that) which is exactly why we use it, but it quite clearly has one, unlike, say, data Void."
haskell,374c3o,srhb,6,Sun May 24 21:10:26 2015 UTC,"Thanks, corrected/updated"
haskell,374c3o,srhb,3,Sun May 24 21:29:10 2015 UTC,"You missed a spot under ""It all starts with IO""   () is the empty type, meaning the function returns nothing: side-effects only."
haskell,374c3o,massysett,5,Sun May 24 22:34:57 2015 UTC,Got it.
haskell,374c3o,tel,2,Mon May 25 03:58:10 2015 UTC,"Since _|_ is an inhabitant of every type, is it proper to say that data Void has one inhabitant? Or does _|_ not count as a ""value""?"
haskell,374c3o,ghibe,2,Tue May 26 13:14:57 2015 UTC,It's perfectly valid to say that but people often like to ignore partiality.
haskell,374c3o,spicenozzle,6,Tue May 26 13:54:44 2015 UTC,really clear and entertaining explanation of monads. beginners won't really mind the incorrect terminlogy noted by others here. thank you
haskell,374c3o,mstksg,6,Sun May 24 20:52:56 2015 UTC,"Thanks. The comments are helpful as I don't wish to mislead or misrepresent, so I'm updating as we speak"
haskell,374c3o,ReinH,4,Sun May 24 21:29:47 2015 UTC,"I'm a total beginner and I would day this is probably the most helpful explanation I've read on monads. I like that you don't go very deep into theory.  Would I be somewhat correct to say that monads are basically wrappers that contain ""impure"" data and actions with some common functions?"
haskell,374c3o,ReinH,2,Mon May 25 20:18:25 2015 UTC,"Thanks, glad to hear it!   There's nothing impure about a Monad (or Applicative or Functor). The list monad example at the end of the article is there basically to unseat the notion that Monad has anything to do with IO or impurity.   A Monad isn't necessarily a ""container"" either. IO certainly isn't. What Monad and Applicative  share is their ability to ""encode"" functions having these types into a larger context; their two-kinded--ness is often there so that we can do other things in these functions while still maintaining the monadic context which might have nothing to do with the second type.  This is certainly true of IO. The monadic context allows GHC to maintain a stable construct of the ""world of IO"" from one call to the next. (Getting IO to work in a lazy language is no joke. Check out http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf for a surprisingly approachable treatment on what's going on with IO.)  Don't worry too much about what a monad is or isn't, worry about how to code with them, which is hard enough :)"
haskell,374c3o,dllthomas,5,Tue May 26 01:59:03 2015 UTC,"love it :) great job. small technical issues here and there as has been mentioned, but I like your explanative style and approach :)"
haskell,374c3o,SkoomaMudcrab,2,Sun May 24 23:48:13 2015 UTC,"Functions with the famous type signature IO ().   Inhabitants of IO () are not functions, and the idea that ""functions"" are ""run"" to produce ""effects"" is also a bit suspect as it implies a lack of purity or a failure of referential transparency where there is none. If you want a name for values of type IO a for some a, you might use ""IO actions"", which seems to be relatively well accepted."
haskell,374c3o,pelotom,0,Mon May 25 19:20:24 2015 UTC,"Inhabitants of IO () are not functions   I'm not referring to just things of type IO () but also String -> IO () etc. It's admittedly imprecise to characterize functions by their result type. But also pretty common, and useful ...   implies a lack of purity   I'm impressed that you want to quibble with calling IO actions ""impure"".  I am using a decidedly stylized and informal notion of ""effects"" but I think it's warranted for the context."
haskell,374c3o,Gurkenglas,2,Tue May 26 02:18:07 2015 UTC,"I'm not referring to just things of type IO () but also String -> IO () etc.   From context, it is clear that you when you say ""function"", are talking about things of type IO (). The only thing the term ""IO function"" does in this context is mislead.   I'm impressed that you want to quibble with calling IO actions ""impure"".   That was not the quibble I was trying to quabble, but sure: IO actions are not impure.   I am using a decidedly stylized and informal notion of ""effects"" but I think it's warranted for the context.   Well, as far as I can tell, you are using a notion of ""effect"" that is indistinguishable from ""is a monad"", which rather robs it of its expressive power. Instead, shoehorning every monad into this ""effect"" model requires gymnastics like ""Non-local control flow (Maybe, Either)."" This sort of thinking is characteristic of having succumbed to the monad tutorial fallacy."
haskell,374c3o,_AndrewC_,3,Tue May 26 14:04:04 2015 UTC,"As implemented in GHC, IO () is a function.  Or more specifically, a newtype wrapper around a function of type (State# RealWorld -> (# State# RealWorld, a #))."
haskell,3743uq,jarlg,6,Sun May 24 18:19:45 2015 UTC,"I think you are looking for Generics, which cassava has support for. Here is an example: https://github.com/tibbe/cassava/blob/master/examples/NamedBasedGeneric.hs  Specifically, this is using GHC.Generics module and the DeriveGeneric extension."
haskell,3743uq,creichert,3,Sun May 24 18:49:32 2015 UTC,"Thank you, that looks very useful! I'm not familiar with generics, so that example must have escaped me earlier."
haskell,372uzp,Alyte,51,Sun May 24 10:12:31 2015 UTC,"My experience is that Cabal is way way way way way indescribably better than what came before.  We do have finer grained dependencies than most any other language, so we run into diamond dependency problems with a bit more regularity than other communities, though.  Would I like cabal to support keeping multiple builds of the same packages with different options in the store? Sure. But, really, the sandbox system has done a lot to ameliorate that particular problem for most users."
haskell,372uzp,edwardkmett,9,Sun May 24 12:50:24 2015 UTC,"Sandboxes, yes, but also a number of other really important cabal features: project-local cabal.config files, --allow-newer, --constraint, installed and source constraints, shared sandboxes. And a solver that is constantly improving.  So not only is cabal indescribably better than what came before, modern cabal is indescribably better than cabal of two or three years ago."
haskell,372uzp,yitz,3,Mon May 25 07:18:37 2015 UTC,Very true.
haskell,372uzp,edwardkmett,6,Mon May 25 07:47:12 2015 UTC,"That, and there's a soft paradox that type systems give you:  More static guarantees means it's easier to reason about code. This also makes it easier to change, which means people are more able (and so, sometimes more willing) to implement breaking changes.  Despite the apparent rigidity of types, it ends up affording you a lot of flexibility with your design."
haskell,372uzp,tactics,1 point,Mon May 25 03:04:19 2015 UTC,"Out of historical curiousity, what came before cabal?"
haskell,372uzp,emarshall85,5,Mon May 25 16:35:39 2015 UTC,"Well, Makefiles, basically. But there was a time before cabal-install was ever around, many many moons ago, when developers had to manually install dependency chains for their Cabal packages by hand after wget'ing the packages from Hackage. And we lived with this!  I remember doing this very often back then - it's been quite a while since those times, though. :)"
haskell,372uzp,aseipp,29,Mon May 25 21:04:03 2015 UTC,Many of the shortcomings of cabal could be fixed if more people contributed to it. The reason why this does not happen much is that improving tooling is a surprisingly difficult and not very rewarding job (everyone would rather be solving the hard problem of their favourite problem domain). Just deciding to start developing another tool would probably not solve that problem.
haskell,372uzp,gasche,43,Sun May 24 10:18:03 2015 UTC,"I should add that Thomas Tuegel have been tagging easy label to easy tasks for anybody looking to contribute to it. I just started working on the code base for the last two days and have been able to submit two pull requests and currently working on the third one. So don't feel intimidated by the code size, most of the time you just follow the types and can figure out almost everything."
haskell,372uzp,sibip,5,Sun May 24 11:23:51 2015 UTC,"this is good to hear. as a noob, you've convinced me to at least take a look at the issue tracker"
haskell,372uzp,sambocyn,1 point,Sun May 24 18:19:59 2015 UTC,"Also as a noob, I'm curious what the easiest of the easy is on there, just to look at for perspective"
haskell,372uzp,sleepystudy,2,Mon May 25 07:02:35 2015 UTC,"Cabal sucks but it's not Cabal's fault. It's GHC's fault. The way linking works is inferior to the already sad way linking works in C. The upshot is that you can't upgrade a library with a backwards-compatible newer version. And if two versions of the same library meet in the same dependency tree they fight. Linking also sucks in other ways.  What we need is to do is rethink and liberalize the linker.  I've imagined making a system-wide database that indexes a hash of unique-up-to-renaming (core) functions to their bytecode. This way, two equivalent functions are recorded only once and you can dispense with modules referencing each other after compiling. They just keep track of the hashes they need from any outside module.  I'm sure there's some problems with that idea, but let me dream!"
haskell,372uzp,rdfox,24,Fri May 29 00:13:55 2015 UTC,"That's a loaded question though... surely not ""everybody"" ""hates"" Cabal. I for one don't hate it, even though there's definitely things I would like to see improved (and it's already been improved significantly lately with e.g. cabal sandboxes, unit-test/benchmark support, cabal exec, cabal run, cabal repl), but I wouldn't be so drastic and throw out the bathwater with the baby like Cabal was beyond hope..."
haskell,372uzp,RedLambda,4,Sun May 24 10:43:14 2015 UTC,"Eh, of course not everybody hates it. The title wasn't meant to be taken literally.  I put it that way because usually when somebody (who knows what they're talking about, not ""hurrr Haskell's useless"") criticizes Haskell they bring up Cabal.  Also, Cabal came up on FPComplete's Haskell survey:   Package management with cabal is the single worst aspect of using Haskell. Asked if improvements to package management would make a difference to their future choice of Haskell for a project, 38% said it would be ""crucial"" and a further 29% said it would be ""important"". Comments connected cabal with words like hell, pain, awful, sucks, frustrating, and hideous. Only this topic showed such grave dissatisfaction."
haskell,372uzp,sepred,0,Sun May 24 10:52:39 2015 UTC,"Cabal is not a package manager.  Use nix.  With their new haskell package infrastructure it should satisfy all packaging needs.  I don't feel in the mood explaining nix, so if you are interested then you should check it out.  There is also a nice article about using nix from one of the developers."
haskell,372uzp,_AndrewC_,6,Sun May 24 17:00:49 2015 UTC,... still waiting for a windows port of nix.
haskell,372uzp,codygman,6,Sun May 24 18:15:00 2015 UTC,Cabal is not a package manager.  Use nix.  With their new haskell package infrastructure it should satisfy all packaging needs.   What about using older dependencies than nix has? Last time I tried this I had to use cabbage. I agree nix is great for new projects but you have to do some work for older projects or use cabbage.
haskell,372uzp,dhjdhj,7,Sun May 24 17:17:54 2015 UTC,Lemme know when someone builds a decent GUI wrapper around nix so I don't have to learn stuff too early.   Note: I'm quite serious.  Did the same thing for Git. Found SourceTree and was able to be immediately productive in Git without having to learn all the commands or understand deeply the Git architecture. Was able to stay focused on the problems at hand and Git knowledge just grew as needed.
haskell,372uzp,darkgold,2,Sun May 24 18:01:28 2015 UTC,"Nix is great for installing haskell programs as an end user. Sometimes during development though you have to match the exact versions of dependencies your coworkers are using. This leaves you packaging up every single dep you want to use manually, because Nixpkgs only keeps one version of everything, usually the latest or close to it."
haskell,372uzp,sepred,1 point,Sun May 24 20:50:49 2015 UTC,You might want to look into this: https://www.youtube.com/watch?v=BsBhi_r-OeE
haskell,372uzp,miguelnegrao,1 point,Sun May 24 21:49:29 2015 UTC,Is there a simple solution in the video for problem pointed out by darkgold ?
haskell,372uzp,sepred,1 point,Mon May 25 15:25:32 2015 UTC,"Kind of:  In the video there is a section about using cabal2nix.  It is really easy write a fully automatic script that fetches a specific version of a hackage-package and make it a nix-package via cabal get.  That way don't event have to recompile the package for every sandbox you have.  I'd say that if you get used to that workflow it is as easy as typing  cabal sandbox init cabal install ${PACKAGE}   You could do something like  cabal get ${PACKAGE} --dest-dir ${MYSOURCETREE}/${PACKAGE} cabal2nix ${MYSOURCETREE}/${PACKAGE}/. > ${MYSOURCETREE}/${PACKAGE}/default.nix # some awk or sed script that adds the appropriate entry to the override part of your ~/.nixpkgs/config.nix   Should not be to hard for a programmer.  This approach only makes sense if you WANT to use nix and work with a reasonably large amount of different compilers versions and package dependencies I guess.  Otherwise just don't use a package manager and just stick to cabal sandboxes, should be totally fine for small/tiny projects."
haskell,372uzp,miguelnegrao,1 point,Mon May 25 17:14:08 2015 UTC,"Unless I'm missing something or misunderstood cabal2nix, when you run cabal2nix on the package from cabal get it will just set the dependencies by name, it will ignore the constraints on the package. The issue arises when the package only builds with versions of packages different then the ones in nix, in that case you can't just use cabal2nix directly and ignore the constraints, you need to first figure out a set of versions of all dependencies that works, then get one by one with cabal2nix, import them all to the ~/.nixpkgs/config.nix and finally make the default.nix file of the initial package depend on the manually created versions of the packages. This is a long and boring process.  Perhaps this process could be automated by creating a cabal sandbox, running cabal configure and then use the versions determined by cabal to have cabal2nix automatically create default.nix files for all those versions and then finally create a default.nix for the initial package depending on those specific versions.  I know I can just use sandboxes, but sandboxes use a lot of space as they don't share their results (by default), and once you get used to the nix workflow it's very hard to go back... it's that good."
haskell,372uzp,kgadek,2,Wed May 27 11:13:27 2015 UTC,"As far as I'm aware, nix does not support/work well on Windows. And recently, as I tried to use it on OS X, I was met with some issues.  As long as nix is not portable, nix will not be a solution for the company I work for.  The most promising alternative is halcyon by /u/myetech, will probably save my/our lives here, though after a quick dive yesterday I was met with… some issues (will dive deeper and explore it very soon)."
haskell,372uzp,stepcut251,18,Wed May 27 12:03:49 2015 UTC,"I remember before cabal when you would try to install a package and it would import modules from some other library. Except there was nothing to tell you what that library was or where to find it. You just had to hope google you could figure it out via an alta vista search. And ever package seemed to use a different build system. And often the makefiles had hardcoded paths to user's home directory.  It was absolutely terrible. Cabal is a massive improvement. There are still problems to be solved, but there are also good ideas on how to solve these problems. And people working on the issues.  There also seem to be people who seem intent on detracting from the good work that has been done to shine focus on their own personal projects."
haskell,372uzp,mightybyte,35,Sun May 24 19:59:24 2015 UTC,"Cabal works great for me the vast majority of the time.  I believe that when people talk about problems with Cabal what they are really having problems with is that the Haskell ecosystem has rather fine grained package granularity with a very fast moving pace of development.  This makes the problem that Cabal is trying to solve a very difficult one.  This is a rather abstract argument so let's look at a concrete example.  According to rubygems.org Ruby on Rails has 10 direct dependencies and 91 transitive dependencies.  By comparison, Haskell's Yesod web framework has 28 direct dependencies and 133 transitive dependencies.  If we use transitive dependencies as the more stable metric, this example would suggest that Haskell packages are around 50% more complex/granular.  That's a big difference.  On top of the number of dependencies, I think there are at least two other factors contributing to the problem.  The first is that the Haskell ecosystem is less mature, so you can expect that things would be changing more rapidly.  And second, I think Haskell's background in academia makes it more concerned about finding the right abstractions and less concerned about backwards compatibility than many other development communities.  So you'll find that many packages make backwards-incompatible changes regularly.  When that happens, if packages that depend on it specified an upper version bound for that package (the right thing to do), then you'll get a dependency resolution problem if you try to use that version.  If no upper version bound was specified, then there's a chance that the build will fail.  Both of these situations look bad to newcomers.  When one of these bad outcomes happens, the newcomer most likely doesn't understand the real issues involved, so they just say, ""I got Cabal Hell!""  Now there are situations where Cabal has made this problem worse by not finding build solutions that existed or by giving a misleading error messages.  But I can assure you Cabal is MUCH better with these things now than it used to be.  Do we still have work to do?  Yes.  But we're making great progress at solving a really hard problem.  We have some very smart people who have been working on this problem for a long time.  There is a lot more to it than meets the eye."
haskell,372uzp,Taladar,3,Sun May 24 14:41:47 2015 UTC,"I believe Haskell also does more aggressive inlining than most languages, up to the point where inlinable functions become part of package's interfaces. This seems to be a large part of the reason why package builds need to be repeated not just when direct but also when transitive dependencies change."
haskell,372uzp,dllthomas,2,Mon May 25 00:54:30 2015 UTC,"Also, I think the fact that so many of those dependencies are so fundamental means we get a lot more diamonds in our dependency graph.  Things in text, bytestring, and containers are provided by the language or standard library in most other languages."
haskell,372uzp,erikd,22,Mon May 25 08:00:54 2015 UTC,"Cabal, with all its flaws, is better than all of the current alternatives.  That leaves a number of options:   Live with cabal as it is. Help improve Cabal. Develop an alternative."
haskell,372uzp,mjmrotek,14,Sun May 24 10:17:42 2015 UTC,"Cabal + Stackage is good enough in my opinion, I don't get the complaints."
haskell,372uzp,RedLambda,2,Sun May 24 10:16:55 2015 UTC,"I'm not sure what any fixes are but if Cabal sees 2 dependencies of the same library, but different versions, it doesn't handle it very well.  This would probably be the biggest problem IMO. I've had problems caused by this and it took a while to figure out."
haskell,372uzp,Crandom,8,Sun May 24 10:33:22 2015 UTC,There's somebody already working on this it seems: https://gist.github.com/fugyk/37510958b52589737274
haskell,372uzp,itkovian,3,Sun May 24 10:45:57 2015 UTC,This work is so incredibly important. I was about to make a post asking what's happening around it.
haskell,372uzp,Crandom,1 point,Sun May 24 12:15:27 2015 UTC,"Any particular reason we need to reimplement what nixpkgs already provides? From the gist, this should work in a similar way."
haskell,372uzp,RedLambda,8,Sun May 24 20:18:37 2015 UTC,"nix is even harder to use than cabal (it's UI is pretty non-begginner-friendly). You have to have an extra dependency on nix, which is also unsupported on Windows. Nixpkgs only provides the most recent versions of packages. Implementing nix's ideas in cabal makes the most sense for haskell."
haskell,372uzp,itkovian,4,Mon May 25 00:28:30 2015 UTC,"I assume it's because requiring Nix as a prerequisite for Haskell development would be a heavy dependency (despite it being awesome cool), and just stealing  ideas from nixpkgs is within reach..."
haskell,372uzp,mjmrotek,1 point,Sun May 24 20:27:13 2015 UTC,"Well, the store takes some place and it'll get the full toolchain and its dependencies, but depending on your system, you'll need those anyway. On OSX, you'll have two compiler toolchains, the system one and the nix one, but on Linux, I think you could do with only the nix one.   OTOH, if you reimplement it, it is another piece of software that needs to be maintained, whereas if it stays in nixpkgs, it will be maintained by the nixpkgs maintainers."
haskell,372uzp,bgamari,1 point,Sun May 24 20:56:01 2015 UTC,"I think that's as much of a Haskell problem as a Cabal problem. I mean, if you have 2 conflicting dependencies, it MIGHT be okay in the end (if these two don't actually share variables created as if they were of types defined in the conflicting library) but as Haskell doesn't really provide a truly ""isolating"" module system, this kind of a dependency might break in some unexpected place anyway. So I guess it MIGHT not be that bad of a policy to disallow duplicate packages entirely.  And as for Nix, and especially NixOS, the only thing I can say... I've spent hours trying to install the latest. 7.10 GHC, getting type errors in some deep innards of the standard library (What. I mean, why would anyone in their sane mind create a dynamically-typed configuration language?) because I misspellt a module name, and in the end I gave up because I couldn't figure out the way to enable the rolling-release packages, and went back to Arch."
haskell,372uzp,maxigit,11,Fri Jun 5 23:43:28 2015 UTC,"Frankly, I have found Cabal to be far better than most other language-specific build/package management systems. Yes, tracking dependencies is a hard problem and that is reflected in what people often call ""Cabal-hell"".  Unfortunately there is no easy answer here. Either...   we freeze our entire ecosystem, ensuring library compatibility by definition, we expend effort maintaining proper versioning and dependency bounds and ensure compatibility through shear force, or we give up on versioning and accept that a given build may fail at compile-, or worse, run-time.   Most users would be quite displeased with #1 and, as a community that values correctness, #3 isn't (in my opinion) a good fit for Haskell.  The PVP tries to push us towards #2 although it does come at a cost. However, restrictive bounds often mean that users will occasionally experience problems with package breakage and impossible build plans. This is exacerbated by Cabal's inability to manage more than one installed instance of a given package, a limitation which, with luck, will soon be lifted.  In the meantime, the problem is substantially eased if package dependency bounds are kept compatible with the current state of Hackage. In my experience, this requires relatively little effort but offers substantial rewards. Towards this end, I make an effort to review Cabal's installation plan before committing to running cabal install.  If I see that a plan builds an out-of-date dependency then I take a minute to track down the culpable package, bump the bound, and try the build again. I have a cabal-try script which makes this check pain-free. If the build succeeds I open a pull request upstream where possible. This whole process is surprisingly quick and by fixing the bounds I have ensured that I (and other users) will never see the issue again and avoid painful rebuilds later on.  This exercise is admittedly a bit mechanical and could benefit from automation. There have been a few attempts to contribute to this space (e.g. Scoutess) although I've yet to see a service which offers low enough friction to enter wide-spread use. Stackage is another approach which has gained quite some traction and for good reason."
haskell,372uzp,jvoigtlaender,3,Sun May 24 12:32:51 2015 UTC,"The problem of Cabal Hell is not the cause of it, i.e. dependency diamons or whatever. The Hell comes from the fact, that when it happen, it f*cks everything up, and you need a week to rollback and be in a state where you can try to maybe not use (or update) the library causing the problem."
haskell,372uzp,maxigit,3,Sun May 24 13:34:27 2015 UTC,Why is sandboxing not solving this specific perceived problem of yours?
haskell,372uzp,jvoigtlaender,1 point,Sun May 24 13:54:17 2015 UTC,"I'm not having a specific problem, I'm just describing what Cabal Hell is. There is indeed not real Cabal Hell using sandboxes, there are just diamond dependency problems. However, sandboxes only prevent to go to Hell but they don't help in escaping from it. I mean everythign is fine if you create your sandboxes before corrupting your entire system."
haskell,372uzp,bgamari,1 point,Sun May 24 14:05:48 2015 UTC,"Okay, I see. One repeat suggestion is to make sandboxing the default in Cabal. I wonder how many complaints about Cabal Hell come from people not using sandboxes (for whatever reason, including discoverability of the feature)."
haskell,372uzp,sambocyn,3,Sun May 24 14:15:31 2015 UTC,This is why I try to avoid ever entering this state of Cabal Hell but ensuring that the install plan is reasonable before ever committing CPU cycles to it. This often requires little more than a glance to check that highlight-versions renders all of the packages to be installed as green. Cabal Hell may be a terrible place to be (and it would be nice if the pain were reduced) but it's also fairly straightforward to avoid.
haskell,372uzp,bgamari,1 point,Sun May 24 14:51:08 2015 UTC,"is highlight-versions, some script?"
haskell,372uzp,drb226,2,Sun May 24 18:25:55 2015 UTC,highlight-versions is a useful tool for making Cabal's output more readable and can be found on Hackage.
haskell,372uzp,SeriousJope,6,Sun May 24 22:45:26 2015 UTC,"The mantra I've heard is that ""cabal is not a package manager."" So that's what we need. A package manager. Build it on top of or alongside or in place of cabal, whatever works. But as long as we keep relying on cabal to do most of the job of a package manager, without it actually being a full blown package manager... we will keep running into the same pain points."
haskell,372uzp,dnkndnts,3,Sun May 24 18:49:48 2015 UTC,"I have always thought the  ""cabal is not a package manager."" argument is weak. Cabal does not only build, it also download and install packages in a global repo. If a program have a install command it really should have a uninstall command as well."
haskell,372uzp,mallai,5,Mon May 25 10:33:17 2015 UTC,"Two things that should be easy and would make cabal significantly more ergonomic than it currently is: first, sandbox by default; second, build in sandbox, install binaries to normal directory.  Make those two changes (and make them default) and I bet 90% of cabal complaints would vanish."
haskell,372uzp,RedLambda,3,Sun May 24 10:53:02 2015 UTC,"Have you tried Stackage shared sandboxes? Absolutely great. All your projects can just use a single sandbox, so you don't have to rebuild all deps for each project separately. Haskell LTS is great!"
haskell,372uzp,mallai,2,Sun May 24 19:46:26 2015 UTC,If you use a big single sandbox for all your projects... isn't that like....  you know... using no sandbox at all? =)
haskell,372uzp,bgamari,2,Sun May 24 20:09:58 2015 UTC,"You can still have as many sandboxes as you like; however, if you have a group of related projects and you pin them to the same version of Stackage (e.g., Haskell LTS), then these projects can share the sandbox. Since Stackage fixes the version numbers, all projects will use exactly the same versions of dependencies and therefore you only need to install them once.   Note that it's significantly different than the standard global and user package DBs. @RedLambda, I encourage you to read up a bit more about how Stackage works and give the stackage cli tools a try. You can do like this  cabal install stackage   This will give you the cmd line tools. Then in your project:  stk sandbox init nightly   This will create the shared sandbox with the current stackage nightly. For me it created  ~/.stackage/sandboxes/ghc-7.10.1/nightly-2015-05-22   That's it! Then just work as with a normal sandbox. All deps you need will be installed there once for projects pinned to stackage nightly and if the deps are part of stackage, they will build :-) Note that you can still use deps outside of stackage but then it's back to usual as they might be outdated.  The next step would be to publicly provide binaries of Haskell LTS for different platforms - it would be like a shared sandbox for all projects pinned to Haskell LTS, and you wouldn't have to build anything - just download. Since FP Complete builds whole of Stackage anyway, they could also host the binaries for everybody to download."
haskell,372uzp,yogsototh,1 point,Mon May 25 00:04:33 2015 UTC,I'm not sure but I suspect they meant that executables produced by sandbox installations end up in a shared directory. I can certainly see how this would use useful; I generally end up creating symlinks to my sandboxed executables to achieve this same end.
haskell,372uzp,drb226,15,Sun May 24 22:49:03 2015 UTC,"The problem is not the tool. Cabal is great.  The problem is to synchronize the community to make ""stable"" packages version that compile all together.  Stackage resolve exactly this problem. Since I use stackage and Haskell LTS. Everything is fine.  The only things I miss is the ability to download directly binaries for Linux and Mac to save compilation time."
haskell,372uzp,tdammers,6,Sun May 24 11:06:03 2015 UTC,FP Complete internally uses docker-based tooling to do exactly that. We are working on open sourcing it.
haskell,372uzp,ReinH,8,Sun May 24 18:44:08 2015 UTC,"Because cabal is the best we have. And frankly, the problem isn't even cabal itself, but that it tries to do things with the assumption of ""perfect"" input data while in reality we have imperfect input. Particularly version bounds - I believe the single most notorious problem with cabal is ""cabal hell"", where resolving dependency issues is a matter of semi-randomly kicking cabal in various ways until it finds a way to meet your perfectly reasonable dependency requirements. The cause is usually that a package somewhere specifies version bounds that are either too strict or too loose. Providing perfect version bounds, however, is a problem that requires superhuman code auditing skills and a bit of clairvoyance, or at least unreasonable amounts of testing. In practice, it does sometimes mean that I won't use a certain package because it would take too much time convincing cabal that it can resolve the resulting project's dependencies, and that is a shame. Developing yet another tool however wouldn't solve anything here, because the choice would be between ""do exactly what cabal does"" and ""give up"".  If anything, we would need better tooling to validate version numbers and code against the PVP (that is, a tool that we could run against two given versions of a package, and have it verify that the version number change is correct as per PVP). Recent additions to the Haskell ecosystem, such as cabal sandboxes, the ability to fix versions, and stackage, already do a lot to ease the pain, and improving those would IMO be a better use of precious developer time than rewriting cabal from scratch.  That said, I hear people have been using nix as a proper package manager for haskell development instead of relying on cabal to install dependencies from source, so maybe that would be a viable route, but I don't know enough about this stuff to have a noteworthy opinion."
haskell,372uzp,bartavelle,3,Sun May 24 10:52:32 2015 UTC,"Why do people use cabal? Simple: despite its shortcomings, it has one killer feature: it exists.  As I see it, there are a few options moving forward:   Improve Cabal, which very few people actually seem to want to spend the time to do. Replace Cabal, which very few people actually seem to want to spend the time to do. Complain about Cabal, which many people seem to want to spend the time to do."
haskell,372uzp,Ramin_HAL9001,3,Mon May 25 19:52:22 2015 UTC,There are only two kinds of tools that you can use to manage your packages but are not package managers: those people always bitch about and those nobody uses.
haskell,372uzp,hagda,2,Sun May 24 16:43:40 2015 UTC,"I have found the best way to use cabal is to keep a list of packages I need in a file called user-goals-list.txt, and every time I want to add a new package, I add it to my list, then do:  cabal install $(cat ""user-goals-list.txt"")   If I want to update my GHC installation, I just run the above command without modifying the user goals list. This is the best way I know to prevent Cabal Hell, and I have always wondered why I have to use this hack. Why doesn't cabal just keep it's own list of user goals?  Also, I don't know if cabal has a feature to automatically clean-up older versions of packages after updating if it can prove that nothing else old depends on it. If it cannot do that, it would be a feature that I think Cabal should have. But so far I haven't been able to figure out how to make Cabal do ""auto cleanup,"" I don't think it has this feature in any way.  If it could do those two things, I think Cabal would be very pleasant to use. But as it is now, Cabal is very painful to use. Unfortunately, I do not know any better alternatives, so I am stuck with it."
haskell,372uzp,Ramin_HAL9001,4,Sun May 24 11:52:04 2015 UTC,"fwiw, cabal maintains a ""world"" file of all manually installed goals"
haskell,372uzp,hagda,3,Sun May 24 11:59:04 2015 UTC,"I have heard of this, but I don't really understand what practical use it serves, apart from providing hints to the dependency graph search algorithm.  Perhaps if there were a cabal goal --add and cabal goal --remove commands intended to update this ""world"" file, which would automatically perform dependency resolution before committing changes to the ""world"" file, I think that would be a very handy feature.  This may also be a step towards providing an ""auto clean"" feature as well."
haskell,372uzp,_AndrewC_,4,Sun May 24 12:10:06 2015 UTC,It doesn't have anything to do with providing hints to the algorithm...  Please look at this SO answer which explains one possible use of the world file
haskell,372uzp,RedLambda,2,Sun May 24 13:19:44 2015 UTC,"Essentially we have a directed tree whose leaves my coincide at different versions of the same package. This is only a problem if there's no way to have multiple versions installed and/or no way to resolve which code is used.   If packages bar and baz depend on different versions of foo, they should be compiled against their own version. If they both re-export a function or module, that would be a problem, but you'd reduce the failed dependency resolution to packages that depend on different versions and also both re-export. As far as I'm aware, there are moves in that direction, which would be great.   (Cabal-install is indeed ugly, slow and frustratingly error prone. I don't see why in 2015 something that includes downloading stuff from the internet can be so slow at doing so and also so lacking in a pleasant web interface. Why can't I just click install on a package on hackage or indeed a version on stackage? I shouldn't have to learn from the community to use sandboxes and stackage to stop stuff breaking, it should all just work. It's haskell, after all.)   Many thanks to those at FPcomplete for working so fast to reduce this pain, and to those elsewhere also working on different parts of the problem. I don't mean to be critical of the hard work done on a problem I'm clearly over-simplifying, but I disagree with people who say there's no problem and I just need to install a better OS and learn the great way round the problem that's only 5 lines of bash and a few tweaks every other fortnight."
haskell,372uzp,_AndrewC_,2,Sun May 24 19:48:27 2015 UTC,"Why can't I just click install on a package on hackage or indeed a version on stackage?   If you mean something like you can have for .debs and .rpms, then we'd just need some custom established MIME-type set as Content-Type on the src-tarballs URLs to bind URL download handlers to. However, since we don't use a custom file extension for the src-tarballs there's an overlap with the generic .tar.gz extension and it can only work for http(s):// storage where one can override the default MIME-type inferred..."
haskell,372uzp,Taladar,1 point,Sun May 24 20:18:46 2015 UTC,"You could just call it tar.gz.hs or something. There would still need to be some discussion between the local package store and the server for which dependencies, but essentially with our own MIME type, we can  run arbitrary code locally. The downloader could have a nice interface and install leaves of the dependency tree on separate cores rather than flattening it to a list."
haskell,372uzp,_AndrewC_,2,Sun May 24 20:34:43 2015 UTC,"Why can't I just click install on a package on hackage or indeed a version on stackage?   I see you do not have a lot of experience with Windows users. Trust me, you do not want to get people into the habit of installing software via clicking things on a website ever again."
haskell,372uzp,Taladar,2,Mon May 25 01:17:15 2015 UTC,"If not, then by clicking install on the cabal / stackage gui. We all download and install software anyway, so I feel it's a little patronising to suggest that haskell users will go straight from hackage to dodgysoftware.com and click to their heart's content with their antivirus off.   Setup.hs can already include arbitrary code, and I don't see anything in the current text interface protecting me more than a web frontend would.   If you feel it's safe because it's text based that's because you're not old enough to remember DOS-based viruses."
haskell,372uzp,_AndrewC_,2,Mon May 25 08:25:06 2015 UTC,"It is not safe because it is text based, it is safe because of checksums and cryptographic signatures (well, not quite yet with cabal but people are working on those) and trusted sources.  I am not against graphical package managers but it should be the package manager which does the download from a trusted source and verifies it, people should not just be able to download and install any package from any website that has the right file extension or URL scheme.  I am against a web based solution because trusted and untrusted web based sources are hard to distinguish for the less security conscious. We do have many of those in the Haskell community too or cabal would have had checksums and signatures long ago."
haskell,372uzp,Taladar,2,Mon May 25 11:51:52 2015 UTC,You are very right. Apologies for not understanding your point.
haskell,372uzp,akurilin,2,Mon May 25 12:11:19 2015 UTC,I could have explained it better and in a less confrontational manner as well. Sorry about that.
haskell,372uzp,Vektorweg,2,Mon May 25 12:40:05 2015 UTC,"I actually find cabal sandboxes + stackage LTS + cabal's add-source to work pretty well, minus the part where it takes an hour or two to build all of our repos. Almost all of them rely on either persistent or yesod. If that could be sped up sanely through caching of already built object code, that'd be pretty great."
haskell,372uzp,Ramin_HAL9001,4,Mon May 25 02:10:46 2015 UTC,"Except for Cabal Hell, Cabal is great."
haskell,372uzp,maxigit,1 point,Sun May 24 11:26:53 2015 UTC,"But that is a bit like saying, ""I love being a software engineer, except for the part about working with computers."""
haskell,372uzp,rehno-lindeque,5,Sun May 24 11:40:47 2015 UTC,"Not really. A software engineer would have to work with a computer everyday. How often are you confronted to cabal hell ? I think I had a real ""Hell"" problem only once. I mean when I couldn't work for 2 or 3 days, and it was mainly because I tried to upgrade GHC. Since I use sandbox and I have to rebuild sandboxes a few time but I won't qualify this as hell. I probably could do with a vim shortuct, to automatically add the current file in the exposed modules and a bit more transparency on what configure is doing and lots of magic I don't understand but apart from that cabal is great . I prefer it by far to Ruby bundler."
haskell,372uzp,Ramin_HAL9001,2,Sun May 24 12:39:04 2015 UTC,I feel as though this describes me beautifully - @#$% computers... (they only get in the way!)
haskell,372uzp,rehno-lindeque,1 point,Sun May 24 16:09:30 2015 UTC,"So you're more of a computer scientist or a software architect than a software engineer? I don't think you can engineer computers without actually using them.  I wish someone would pay me to be a software architect. Engineering is a little tedious, although often a pleasant and profitable challenge."
haskell,372uzp,rehno-lindeque,1 point,Sun May 24 17:48:47 2015 UTC,I just want to build everything from scratch (and then maybe get some work done in a hundred or so years from now :P)
haskell,372uzp,m0rphism,1 point,Sun May 24 18:29:02 2015 UTC,Unfortunately I want to do something that actually matters even more!
haskell,372uzp,hvr_,2,Sun May 24 18:47:14 2015 UTC,"I think most of the complaints about cabal come from people using it both as a build tool and a package manager. Personally, I had no serious problems with it since I switched to using nix for installing my project environment and using cabal only as a build tool. Maybe we should aim at getting rid of cabal install in the future."
haskell,372uzp,m0rphism,2,Sun May 24 11:58:07 2015 UTC,"Unless nix has replicated cabal's install-plan solver I don't think nix can replace cabal install... and btw, if you're using cabal merely as build-tool, you can stop using it altogether, and just call Setup.hs directly, which does the actual work of building your code, as cabal (to some degree) is mostly a frontend around Setup.hs"
haskell,372uzp,hvr_,3,Mon May 25 12:27:41 2015 UTC,"Unless nix has replicated cabal's install-plan solver I don't think nix can replace cabal install...   I've just asked in the #nixos irc channel and it appears that the following process is involved in generating nix-expressions from hackage:   Take the latest version of any package from hackage. For each package, use cabal to check whether the version constraints are met. If they are not met: remove upper bounds and try again. Maybe the developer forgot bumping the upper bounds. If it still does not work: manually intervene to figure out which dependency is causing the problem and adding this dependency additionally with a different version (nix supports multiple versions of the same package, they just can't be active at the same time). If after these steps there is not much breakage: make changes available to the public by pushing the new expressions to the nixpkgs git repository.   Steps 1-3 are done completely automatically, and especially step 3 seems to make a lot of otherwise broken packages work.  While being best effort and involving human interaction, this seems to work reasonably well in practice.  I'm not sure how those issues are addressed with cabal, but I guess the choice of versions of dependencies is more sophisticated and based on solving the actual version bound constraints. So the good experiences I have with nix regarding package breakage might be heavily influenced by point 3 and 4.  But I agree: it is not an exclusive replacement. Aiming for an automatically and guaranteed dependency resolution seems indeed like a good thing. :)"
haskell,372uzp,m0rphism,2,Mon May 25 17:55:33 2015 UTC,"Well, for Hackage there's now the Hackage Trustees effort whose task it is to try to keep cabal install from running into compile errors.  This involves mostly doing the complete opposite of removing (upper) bounds: we add (upper) bounds retroactively when they were forgotten/missing! :-)"
haskell,372uzp,Sonarpulse,1 point,Fri May 29 21:04:51 2015 UTC,"Fascinating. It's the opposite, yet it seems to cause the same effect: more successfully built packages. Thanks for the effort! :-)"
haskell,372uzp,maxigit,1 point,Fri May 29 22:31:29 2015 UTC,It would be super nice if https://github.com/jwiegley/hnix we're resurrected and Cabal could use it—giving Cabal users the benefits of Nix without a bunch of non-Haskell deps.
haskell,372uzp,hvr_,1 point,Mon May 25 05:54:23 2015 UTC,Nobodies mentioned cabal install --global which seems to be the solution to reduce sandbox initialization time.  Shared sandboxes sucks : if B depends on A (and they share a sandbox) you have to manually unregister B to be able to recompile A. With separate sandboxes (and A as a source) you have to build A twice but at least you can work on A without worrying on  B.
haskell,372uzp,alt_account10,2,Mon May 25 07:50:57 2015 UTC,"Fwiw, there's also the concept of a nested/lattice sandbox cache. I've got working shake-based code for that to massively reduce time and space needed for materialising the dependency sandboxes in a massive Hackage buildbot (which has been running for weeks already). The algorithm maximally reuses already compiled packages (if their configuration is compatible) required by an install-plan, and the nested sandbox cache is a persistent data-structure.  The code (or the idea -- it's quite simple actually, it's just tricky to make sure all degree of freedoms are considered) could easily be extracted and either put into a cabal companion tool or a variant of it even being integrated into cabal-install (however, I expect the new multi-instance work being done for Cabal to achieve effectively the same, so I don't think it's worth the effort to merge it into cabal-install proper)"
haskell,372uzp,rehno-lindeque,-6,Mon May 25 12:11:22 2015 UTC,"Posts like this give the impression, outside the Haskell community, that everyone has issues with cabal. Which as replied by others is not true.  @Mods please ban all future users that make sweeping generalizations in their post title, and update the titles to remove any such generalizations. I guess this should be a global reddiquette."
haskell,372uzp,alt_account10,4,Sun May 24 17:00:03 2015 UTC,"The title might be slightly inflammatory but the OP is asking an honest, constructive question. No need to censor.  PS If you believe the post is not relevant then that's what the voting mechanism is for."
haskell,372uzp,rehno-lindeque,1 point,Sun May 24 19:05:01 2015 UTC,"There are a million different ways to state the question without starting with an assertion. That's why I mentioned that mods should ban such users, remove the assertion and let the discussion take place.  I hate nothing more than people making broad statements; guess it's the same reason I hate politicians as much as cancer."
haskell,372uzp,Taladar,3,Sun May 24 19:11:02 2015 UTC,"I prefer to give people the benefit of the doubt, perhaps the OP really believed that ""(almost) everybody hates cabal"". Instead of ostracizing people who have misconceptions about Haskell let's help clear up the misunderstanding."
haskell,372uzp,rehno-lindeque,1 point,Sun May 24 19:14:17 2015 UTC,To be fair there is a certain increase of these inflammatory titles in the last week or two. There were plenty of users who don't know about Haskell before. This is starting to look like a deliberate effort (though a bit early to tell either way).
haskell,372uzp,rehno-lindeque,1 point,Mon May 25 01:20:42 2015 UTC,"I don't think there's anything ominous going on here, it's just a sign of increasing popularity. Haskell has been losing its niche status for better or worse. I like being in an inclusive community, even if it means dealing with more noise.  We should take the context of the thread into account (the recent threads on cabal), the objective of the post (constructive questions about what to do to improve the state of affairs) and the history of the user. An overly aggressive response only invites more antagonistic behavior from everyone. We could instead simply suggest renaming the title. Btw, /u/Alyte, that might be a good idea if it's possible to do after you posted (I'm not sure).  Lambda-the-ultimate is reasonably successful at keeping things civil and objective by politely correcting behavior. We would do well to emulate them."
haskell,372uzp,Taladar,2,Mon May 25 14:41:18 2015 UTC,"Can't rename - sorry! Again, the reason I named this thread that way was because I had heard only people complain about Cabal, and not much of the other side. But I can see why everybody else might be offended if they felt I just stamped ""Cabal-hater"" status on them or something. Anyways, if a mod could rename it, that'd be great, but I don't know if they can either."
haskell,372uzp,_AndrewC_,2,Mon May 25 15:45:56 2015 UTC,"Just for the record, I was not personally offended - I can't speak for others, but I suspect it was generally understood that the hyperbole was simply a manner of speaking. (But perhaps try less attention-grabbing and more matter-of-fact titles in future :-))"
haskell,372uzp,alt_account10,1 point,Mon May 25 22:29:36 2015 UTC,"that might be a good idea if it's possible to do after you posted (I'm not sure).   Not possible as far as I know. You can change the body but not the title of an existing post, at least not as a regular user (admins are probably able to do so)."
haskell,372uzp,_AndrewC_,5,Mon May 25 14:45:02 2015 UTC,"""please ban all future users that make sweeping generalizations""...""I hate nothing more than people making broad statements""    Irony alert?"
haskell,372uzp,alt_account10,1 point,Sun May 24 20:40:03 2015 UTC,"Maybe there is one, but I don't see it. I would think it would be ironic if I'd said something like ""all people making broad statements are X"""
haskell,36z17n,enolan,21,Sat May 23 09:17:08 2015 UTC,"Actually, my biggest pain point is long compile times.  Cabal issues I can usually work past - it burns a few minutes every so often, and a few hours much more rarely.  Compile times burn minutes constantly.  I still find it very much worthwhile to work in the language, but if I was going to change one thing..."
haskell,36z17n,dllthomas,18,Sat May 23 15:39:52 2015 UTC,"This would be mine, too. The talk of cabal hell and sandboxes being a hack sounds more like outsider commentary based on what people have heard over the years. If cabal just used sandboxes by default, the complaint would simply be that builds are slow. We know how to avoid rebuilds, but can't agree on how to fix it, and GHC itself is slow, but efforts at improving it are underway. While I am no fan of cabal, it is soaking up a long history of issues here caused by, e.g., the fine-grained package division the community tends towards, and a dominating desire for runtime performance.  The survey just reminds us that there is pain."
haskell,36z17n,acow,6,Sat May 23 17:58:38 2015 UTC,"Did you read the actual survey results yet? My blog post was just the tiniest summary; the actual data is very rich, and is not consistent with your implications that these respondents aren't personally familiar with the experience of struggling through cabal.  However, I concur that the responses also suggest that many respondents are not familiar with the latest best techniques, notably sandboxes and Stackage, and that those who are, are a lot happier. This seems related to respondents' strong demand for better learning resources."
haskell,36z17n,FPguy,3,Sat May 23 18:41:56 2015 UTC,"I was more responding to the blog post and the comments here. The learning resources issue is really what I'm referring to. Not in the sense of an official book, but in what guidance the community puts out there in a grass roots sense. I don't meant to belittle the survey respondents, but take myself and the active members of the community to task for not nipping this in the bud sooner."
haskell,36z17n,acow,5,Sat May 23 19:08:40 2015 UTC,"Interesting. This did not seem to show up in the survey data, yet it seems a bit obvious when you mention it. Does anyone else see something frequent in the survey data that suggests a lot of people would put this on their priority-to-fix list?"
haskell,36z17n,FPguy,15,Sat May 23 16:08:46 2015 UTC,"I work on Haskell projects in the neighborhood of 20k - 50k lines (50k - 120k lines including non-hackage dependencies) and compile times have become a pretty big development slowdown.  This issue is very high on my list of pain points and getting higher all the time.  Like dllthomas, I also don't find Cabal to be a significant problem.  It might be more of an issue to newcomers who don't know the best practices, but it's not much of an issue for me.  Compile times are a MUCH bigger problem IMO."
haskell,36z17n,mightybyte,6,Sat May 23 17:55:42 2015 UTC,"Do you find the small ""make a change, check if compiles"" iterations the most painful, or the bigger ones that require a full ""cabal install""?"
haskell,36z17n,Faucelme,10,Sat May 23 18:30:06 2015 UTC,"For me, the latter. I've gotten iteration down to a matter of a second or two even on 20k projects, via GHCi. It's building new projects in a sandbox that kills me. Although with Stackage more recently I have one package database on an LTS snapshot that I re-use among 20 projects and then upgrade, so that pain point is mitigated."
haskell,36z17n,chrisdoner,4,Sat May 23 19:25:03 2015 UTC,"I'm looking for FPComplete's docker image with all of stackage pre-built, but it doesn't seem to be published yet."
haskell,36z17n,hastor,2,Sun May 24 15:21:43 2015 UTC,"I'm starting to try out this strategy: I use the same versions of libraries for all of my projects by appending the Stackage LTS cabal.config to my global cabal config file.  I don't use a sandbox.  This seems to work OK for me, at least for now.  (It would be nice to not have to manually append those constraints to the config file.  Instead, I'd like to see  a remote-contraints option in the cabal config file that I could set to the Stackage LTS cabal.config url.)"
haskell,36z17n,tdox,2,Sat May 23 22:47:00 2015 UTC,That's how I've started too. This works right until the moment where you need to upgrade something. You'd better be checking out stackage-sandbox and the others in the stk family.
haskell,36z17n,dpwiz,1 point,Sun May 24 06:40:33 2015 UTC,"I rarely need the latest version of a library. When I will, I thought that I would get the Stackage LTS config file that contains the version I need. I know that then I will have to compile many packages, and I'm wondering why is that worse than doing the same with a sandbox?"
haskell,36z17n,tdox,3,Sun May 24 15:32:19 2015 UTC,"I started using -O0 not too long ago and that has helped significantly with the former.  But IMO they're still all too painful though.  The -O0 solution was not at all obvious and could stand to be made easier.  I tried to go even further than that and make something that would just do type checking with no code generation, but I was unable to get that working."
haskell,36z17n,mightybyte,1 point,Sat May 23 23:53:10 2015 UTC,"I'll second this - incremental compilation using ghci is not a problem but sandbox compiles are annoying. There are many (too many) tricks to speed things up, but the ideal situation would be if it were just blazingly fast."
haskell,36z17n,rehno-lindeque,1 point,Sat May 23 23:29:44 2015 UTC,"It seems like compile times can be significantly reduced by defaulting to watching for changes, as most IDEs, grunt etc does.    A more advanced approach would be to have ghci direct which files to compile, but here a global view if code is required, not cabal's narrow project based view."
haskell,36z17n,hastor,18,Sun May 24 15:19:10 2015 UTC,"Thanks, FPCo, for doing this!  Cabal issues are particularly frustrating as they are massively exacerbated by the community's lack of consensus on improving things. If cabal simply used sandboxes by default, we wouldn't hear about ""cabal hell"" other than that people felt that the time it took to start a new project was hellish. All this drama is due to a vocal few who denied that sandboxes were needed. That's it. The much maligned cabal developers added this desperately needed feature, and there was a chorus of single-project developers who didn't think it necessary, and so argued against it for the sake of I know not what beyond a desire to not disrupt the status quo.  In a world where we have a working cabal-install tool, the remaining problems are still significant, but crystal clear: we need a build caching system (I use a Nix-based tool for this on OS X, and it works great; stable version sets like Stackage mean fewer instances of the same package need be built); we need better documentation tools (haddock is slow, memory heavy, and goes its own way regarding syntax); hackage is hard to explore, not very pretty, has lots of missing documentation due to a flaky builder, and has downtime issues; and GHC itself is slow.  Not coincidentally, all of this is changing. A shift to commodity hosting and auditable tooling means we will see a new face for package browsing and installation, and GHCHQ is aware of their speed issues. Soon we can focus on code again, and sort out language meta-pragmas and alternate preludes.  There are people in these comments saying we need plotting tools, numeric tools, and GUI frameworks. We have all these things, but it gets lost in the hellish cabal noise because, hilariously (eh), nobody can install them."
haskell,36z17n,acow,6,Sat May 23 18:37:32 2015 UTC,"I think that's right on point. Summarizing this thread:  - compiling is too slow (perhaps both a ghc and cabal issue)  - people still having problems with cabal because they're not using it in the nice new way (sandboxes, `--allow-newer` when necessary, maybe dependency freezing). This is partly a documentation issue, and partly that opinion is divided on the ""best"" workflow and cabal in 2015 permits several (and it's UI has gotten even stranger and less intuitive)   The latter constellation of issues is not difficult to solve; even a haskell newbie could make a great contribution by taking an hour to understand the sandbox workflw and try re-imagining a better UI.  In any case it doesn't help to continue crying ""cabal hell"", and about how ""we "" must do something (certainly if I had helped implement sandboxes, or version freezing, or -j I'd be upset to see the goal posts moved and my hard work go unacknowledged). Clarity please."
haskell,36z17n,jberryman,1 point,Sun May 24 11:21:45 2015 UTC,"I'd be very interested to hear about your Nix-based OS X tool. Is it Cabbage, or do you have a different tool for OS X?"
haskell,36z17n,NihilistDandy,2,Sun May 24 16:42:17 2015 UTC,"Cabbage is the one. It still has the idiosyncrasies of a single-developer program, but it does what it says on the tin. The big missing piece right now is that while it can work with Stackage LTS and Nightly, it doesn't do anything smart to reuse build plans computed by the Stackage server, so per-package build plans are still computed locally. It's not 100% trivial to reuse build plans, as one has to take care when non-Stackage packages are involved."
haskell,36z17n,acow,1 point,Sun May 24 19:00:53 2015 UTC,"hackage is hard to explore, not very pretty, has lots of missing documentation due to a flaky builder, and has downtime issues   Honestly, now that we've moved to rackspace, we've had some scheduled updates requiring reboots that could be better communicated, but unanticipated downtime/crashes haven't been an issue.   There has also been tremendous work done on the builder, though there are still issues. The distributed build reports really need a ""last mile"" of work from anyone willing to devote a chunk of time and brainpower, and they'll then do a world of good.  Other than that, though, I think your remarks are on point :-)"
haskell,36z17n,sclv,18,Tue May 26 17:11:17 2015 UTC,"Of a group of people interested in Haskell, 58% would recommend Haskell for a project at their workplace.  Is it just me, or is that a damningly low number?"
haskell,36z17n,tomejaguar,23,Sat May 23 10:20:54 2015 UTC,"Assuming it’s an honest assessment, that seems like a very healthy number to me. Using Haskell for a professional project requires far more from the surrounding ecosystem than using it in academia or for personal projects.  For example, there are a few decent beginner books around these days, but there is still very little in the way of intermediate-level training material. If you’re arguing for using a relatively obscure language in a commercial environment with issues like staff turnover and long-term maintenance to consider, that’s already going to be one deal-breaker for a lot of smaller projects.  For larger projects, where there is already enough in-house expertise to overcome that barrier in principle, you have a different problem: there simply aren’t that many people around who can already program Haskell well compared to mainstream industrial languages like C or Java or Python or JavaScript. That means your existing skilled/knowledgeable staff are regularly going to be diverting to train up new starters to the level where they can operate autonomously.  If 58% of respondents — albeit obviously from a heavily biased population — think they have a real world commercial project where Haskell is a viable choice despite these kinds of barriers, it suggests that critical mass exists to build a larger group of skilled/knowledgeable industrial Haskell programmers despite the language’s relative weakness in these kinds of practical matters."
haskell,36z17n,Chris_Newton,17,Sat May 23 15:15:24 2015 UTC,"I think it's high, personally. There's a lot of practical concerns that work against Haskell in the workplace that go beyond technical issues.  Take me, for example. I love Haskell, but I wouldn't recommend it for a project at my job. Why? Because I'm the only person at the office who actually uses it. Unless I'm the only person who will ever work the project there will have to be training to get others up to speed, and nobody is going to want to foot the bill for that.  Haskell is also not a language where we can take a dev with no experience in it and go ""It's like Java, you'll figure it out"" like we can with every mainstream language out there. I have enough trouble getting my friends with a passing interest in Haskell to actually sit down with it long enough to get past the initial hurdle of ""This isn't programming the way I've been programming for the last X years"". I've had to answer ""What's a monad?"" so many times it's infuriating.  And then there's the nature of our work. We very often do work for clients with the understanding that after the contract ends they'll be taking the code and doing continuing development with an internal team. It's a hard sell to say ""I know you're mostly a Java shop, but what if we wrote this in a language that likely no one in your company knows?""  None of this even touches on the qualities of Haskell the language or the state of the libraries and tools, but it's still important to consider as a business. There's zero technical reasons why my current project couldn't be written in Haskell. I still would have been crazy to suggest it."
haskell,36z17n,stevely,8,Sat May 23 17:17:17 2015 UTC,"Your comments seem very representative of the textual comments received from large numbers of survey respondents.   If we want Haskell to move forward, we need to address this team learning issue and this future staffing issue, both of which appeared as prominent concerns in the survey results."
haskell,36z17n,FPguy,14,Sat May 23 18:35:48 2015 UTC,New startups is the way forward; it's usually not practical for an established software company to shift gears in such a dramatic fashion. I suspect that the responses would change dramatically if the question asked whether you'd employ Haskell to tackle a new venture.
haskell,36z17n,rehno-lindeque,21,Sat May 23 12:41:52 2015 UTC,"I have particular reasoning for answering that way. My company mostly deals in scientific software, and haskell just can't compete with python on that front. There are more flexible and mature libraries like numpy, scipy, pandas, matplotlib, and a host of others. Python also has a superior ability to interop with other libraries, not just C DLLs but COM, CLI, .NET, and even Matlab. In particular I looked into writing haskell bindings for a library we use and got stuck when I needed a variable number of arguments, which currently isn't possible with the FFI (although the inline-c library could help with this). In order to switch from python to haskell we would have to rewrite thousands of lines of our code, and thousands of lines of libraries and bindings that already exist for python. GUI development is very important for us too, and I can't say I've had much success getting that to work well on Windows with haskell. My coworkers also aren't programmers by trade, they're electrical engineers. Coding come second to them, and it was hard enough selling them on python over c and TCL. Maybe in a few years when my team morphs into more of a software team than an engineering one (we're headed that direction), but for now the combination of the community support, legacy code, technical requirements, and barrier of entry prevents me from even trying to convince my coworkers to learn haskell."
haskell,36z17n,bheklilr,11,Sat May 23 14:16:49 2015 UTC,I'm in almost the exact same boat. It's pretty frustrating. We could get pretty far if there was cheap and smooth Python interop then I could at least try using Haskell for some backend processing. Forget the GUI though. Haskell is miles and miles behind on that front.
haskell,36z17n,hiptobecubic,7,Sat May 23 15:15:40 2015 UTC,Between HaPy and MissingPy it doesn't seem like there should be any problems.  Could you expand on the difficulties you've faced interoperating between Haskell and Python?
haskell,36z17n,bss03,3,Sat May 23 16:25:49 2015 UTC,"yeah doesn't Hackage have several Python interim libraries? I think one let's you call Python, another let's Python call into Haskell."
haskell,36z17n,sambocyn,11,Sat May 23 19:48:06 2015 UTC,"GUI development on windows has been horrible. hsqml and fltkhs has actually made it somewhat workable now. I have spent many hours trying to install gtk and wx before giving up.  I even tried the win32 lib, unfortunately some of the controls I wanted were not implemented for some reason."
haskell,36z17n,SeriousJope,9,Sat May 23 14:37:55 2015 UTC,"Allow me to peddle my wares: What do you think of Threepenny-GUI? It's as cheap as the name says, but at least it works on every machine out of the box."
haskell,36z17n,apfelmus,6,Sat May 23 15:57:32 2015 UTC,"I have been interested in learning your banana library some day.   The thing with web based desktop gui is that it feels like a cop out. Both Brackets and Atom is somewhat sluggish compared to other editors.   During work we use wpf and .NET and would probably be able to whip a working prototype of most of my project in a day. When using haskell I would be happy if I had a gui library installed.  I am thinking about building a simple file manager that supports tagging of files, lots of them. So the gui need to have a table capable of handling thousands of them. On most cases this means some kind of virtual table."
haskell,36z17n,SeriousJope,2,Sat May 23 18:27:47 2015 UTC,"The thing with web based desktop gui is that it feels like a cop out.   Oh certainly; I did say ""cheap"". :-) I have found that it works very well for one-off projects, though. Thanks to Haskell, the GUI always feels very stable to me, and it takes very little code to get one up and running.   During work we use wpf and .NET and would probably be able to whip a working prototype of most of my project in a day.   Then again, it is probably not fair to compare a native platform developed by a multi-billion dollar company to a volunteer effort in a small community. In the former case, somebody has spent a lot of money to make it easily installable on Windows systems...   I am thinking about building a simple file manager that supports tagging of files, lots of them. So the gui need to have a table capable of handling thousands of them. On most cases this means some kind of virtual table.   This may indeed be tricky in HTML, because the browser needs to keep track of thousands of entries, unless you draw everything yourself in a Canvas. It might be worth a try, though. How would WPF solve this?"
haskell,36z17n,apfelmus,2,Sun May 24 12:07:38 2015 UTC,Well the same company is paying SPJ ;)  I would probably try a naive solution with the built-in grid component. If that didn't work I could enable virtualization on the grid and make sure only a few item are loaded at a time.  A coworker wrote a logviewer that could supper 10M+ rows. He only loaded the rows that were visible. This were in WinForms though.
haskell,36z17n,SeriousJope,6,Sun May 24 15:42:45 2015 UTC,I'm working on WinForms bindings at the moment that should work with Mono everywhere. Hopefully this makes the situation better (if I do end up finishing them).
haskell,36z17n,Darwin226,3,Sat May 23 18:11:37 2015 UTC,"Even if we got one of those frameworks working, I'm not sure if there's even a good plotting library that would be supported. We throw a lot of graphs up on our interfaces, without that one feature we can't make the switch."
haskell,36z17n,bheklilr,3,Sat May 23 14:57:11 2015 UTC,"I only have a small amount of experience with d3, could it handle quickly graphing about 16000 points spread across 8 or so graphs at once? And then repeat that 8-16 times? I'd say my upper bound is a total of 320,000 points graphed at once. I'm not sure SVG was really meant for that sort of thing."
haskell,36z17n,bheklilr,1 point,Sat May 23 16:41:59 2015 UTC,"SVG's not an option with that many points (the browser will choke hilariously), but you could do it in a canvas. You'd lose click handlers on each element, but I don't know how important that is to your use case."
haskell,36z17n,NihilistDandy,1 point,Sat May 23 17:53:32 2015 UTC,"Possibly, but it still ends up being that everyone on my team needs to be familiar with Haskell, HTML5/JS/CSS, and that we deploy a lot of our software (not all, but the most important ones) on machines that will ever only have IE on it, and usually it's an older version of IE.  It wasn't too long ago (within the last year) that our IT upgraded from IE 8 to IE 10."
haskell,36z17n,bheklilr,4,Sun May 24 00:06:50 2015 UTC,If there's any issues with fltkhs on Windows please let me know here or open an issue. Having a GUI toolkit that works well on Windows was one of the reasons I wrote the bindings.
haskell,36z17n,deech,3,Sun May 24 01:42:10 2015 UTC,Will do :)  Thank you for the hard work!
haskell,36z17n,SeriousJope,7,Sat May 23 19:35:48 2015 UTC,"Out of curiosity, do you carry out GUI development in Python as well?"
haskell,36z17n,Faucelme,4,Sat May 23 20:10:25 2015 UTC,"Yeah, we use wxpython mostly, but we're starting to hit its limitations and might be considering other frameworks soon."
haskell,36z17n,bheklilr,4,Sat May 23 15:37:08 2015 UTC,"Just for your info, I too do commercial scientific GUI development, and I absolutely love PyQt. I also use vispy and pyqtgraph for OpenGL-based plotting (2D and 3D). I would love to use Haskell for my work, but it would be very hard to make a compelling argument as to why I should drop my current Python GUI stack and the general Python scientific stack."
haskell,36z17n,HoboBob1,2,Sat May 23 15:41:29 2015 UTC,"Same here on switching, it just doesn't make good business sense. As for Qt, we've looked at it before but the licensing is a bit restrictive for us. We may take a look at it again and see what we can work out with legal. Wx is perfectly fine for simple interfaces, even with some graphs thrown up there, but we've found that it has sub-par performance and the more complex the gui the harder it is to do things that seem like they should be easy.   Out of curiosity, what industry are you in? It's always nice to come across others doing similar work, everyone seems to be in web or enterprise these days."
haskell,36z17n,bheklilr,2,Sat May 23 19:35:23 2015 UTC,I feel the same way about seeing non-web programmers haha. I'm in the oil and gas industry.
haskell,36z17n,HoboBob1,2,Sat May 23 20:30:07 2015 UTC,"Nice, I hear there's a lot of good work on that sector. Since a lot of it is in the midwest of the US, I'm going to guess that you might be in that area too. It may not be too far for you to travel to SciPy Con in Austin TX this July. I'm trying to go myself this year, there looks to be a lot of good talks on subjects that would be pretty applicable to your work."
haskell,36z17n,bheklilr,5,Sat May 23 21:01:01 2015 UTC,another option for variadic c functions is libffi (see for example http://stackoverflow.com/a/5993358/1940209)
haskell,36z17n,aavogt,5,Sat May 23 21:30:38 2015 UTC,"I would certainly use Haskell in my workplace. I certainly would not want to work with my current coworkers on a Haskell project. The issue is they are at the start of the curve of actually understanding FP, and we have real deadlines to meet in a short amount of time. On another note, I would love to move to a group where my coworkers actually understand and want to use FP."
haskell,36z17n,boxfire,7,Sat May 23 16:14:05 2015 UTC,"It's certainly cause for concern.   The responses -- both numeric and textual -- suggest that major improvements in package management, in documentation, and perhaps in samples/templates, would make a big difference.   It makes one feel that projects like Stackage and School of Haskell and the CH-SIG documentation project all need to go farther.  That said, the survey data does not confirm that these projects (or others) as currently understood are sufficient. The widespread needs suggest there's room for both extensive work and creativity.  Of course, just moving the 58% forward could double commercial Haskell usage in the short term."
haskell,36z17n,FPguy,2,Sat May 23 17:16:58 2015 UTC,I repeatedly made comments of this nature in my survey response.
haskell,36z17n,panda_sauce,7,Sat May 23 11:52:19 2015 UTC,"I think it reflects Haskell's roots in academia. It takes a while before things move into practical use.  It probably also reflects the state of Haskell tools, especially cabal. Laziness too.  I'd say 58% isn't bad, considering."
haskell,36z17n,garethrowlands,4,Sun May 24 02:35:18 2015 UTC,"The survey did not ask specifically about laziness, which would be interesting, but on first inspection of the open comments I didn't see much mention of it in the data. On what are you basing that hypothesis, please?"
haskell,36z17n,FPguy,2,Sat May 23 10:50:39 2015 UTC,"I wonder what this number would be for other languages. Maybe also there are two types of fanboyism: theoretical fanboyism (prevalent in the Haskell community) and practical fanboyism (prevalent in the less academically supported language communities).  A question ""would you recommend Haskell in an academic setting"" could help to understand this better."
haskell,36z17n,cies010,1 point,Sat May 23 15:58:47 2015 UTC,"It's hard to recommend Haskell at the workplace when you know that it will take your colleagues unfamiliar with it a lot of time and effort to start being productive with it. It is super hard to learn, unfortunately.  Compare it to Python or Go where everyone can become productive in a very short time."
haskell,36z17n,kraml,1 point,Sat May 23 12:04:30 2015 UTC,"I have seen claims that Haskell is quite easy to learn as a first programming language, but harder to learn if you've already come to believe that all programming languages should work more-or-less the same as the traditional imperative modular (and OO) languages."
haskell,36z17n,FPguy,1 point,Sat May 23 20:21:32 2015 UTC,"I am somewhat skeptical of these claims. A first programming language can be especially difficult to learn for someone who also has to learn command-line tools, as well as programmatic thinking and abstractions. I think these things together are perhaps easier to throw at students altogether in an academic setting, and so I think that when people say Haskell is easier as a first language, I would bet they mean ""as a first language in an academic setting where there are labs, TAs and academic resources."" I would also wager that significant numbers of people are not learning their first language in an academic setting, and that these people are instead learning Python, Ruby, and JavaScript due to the huge communities and gobsof free, approachable information available to them.  I have no computer science or mathematics background, and I learned Python on my own over the course of a year and then eventually became a professional developer shortly after that (in a career move the surprised me).  After being a web developer for a bit, eventually I became interested in Haskell and really intrigued by it, but I find it to be a brutal and unforgiving language. What I can say anecdotally (and I certainly can't claim to be representative) is that when I was first learning Python there were ample resources with good examples demonstrating close to what I wanted to accomplish. Most of the time, I could find a dozen good examples, blog posts, and explanations of a concept or technique. The Haskell community is smaller, so fewer resources are present here."
haskell,36z17n,erewok,1 point,Sat May 23 23:48:56 2015 UTC,"Maybe, bit if you've never programmed before, it will take you even longer to get productive. Probably never, even. It takes years to become a decent software engineer."
haskell,36z17n,kraml,1 point,Sun May 24 05:23:29 2015 UTC,"It is super hard to learn, unfortunately   I would replace ""hard to learn"" with ""a lot to learn"". As with design patterns in OO languages, it's one thing to read on the topic; and another to use them in practice."
haskell,36z17n,alt_account10,1 point,Sun May 24 09:06:12 2015 UTC,I would assume some % of those who would not use it are tied to the JVM and beyond reach. Out of thin air I'm going with 10%. If we don't take them into account the % of those who can switch and would want to goes up to ~ 70%.
haskell,36z17n,deech,1 point,Sun May 24 19:19:03 2015 UTC,You don't need to assume -- you can actually see something similar to this in the data! I haven't measured the number yet (Tristan probably will soon) but it's definitely an issue.
haskell,36z17n,FPguy,1 point,Sat May 23 20:46:05 2015 UTC,"I don't think so, because there are relatively few fluent haskellers.  Part of recommending a language is being able to maintain it, and for many projects/companies whatever perceived superiority of the language itself can be eclipsed by the learning curve/lack of devs.  Fwiw, I answered the survey and would (and have) recommended.  But I'm a decision maker directly, if I were in a shop as the only haskeller I would be far less likely to ""recommend"" ""we"" use haskell."
haskell,36z17n,eof,16,Sun May 24 15:57:01 2015 UTC,"I hope the results do not shed new light for anyone here. We know that package management is abysmal. We know that the documentation is abysmal. This is all very well documented.  It does't help that, often, reactions to calls for help in these areas are along the lines of ""well then why don't you fix it for us"". Many people use the tools but don't know how to modify them (like me).   I wonder what the goals of the Haskell community are with respective to the development effort spent. I saw a lot of work in abstracting type signatures recently. The polarization of this work aside, I'm sure it served as an improvement to the language for a number of Haskell users. A lot of work of great complexity went (and goes) into improving the language for those users who already know a lot about it.   And yet, I see relatively little work go into the tooling that empowers new entrants to the language. For example, Haskell's ""package manager"" probably takes last place compared to those for other languages. Cabal Hell is just a sad state of affairs. Sandboxing is not so much a solution as a sidestepping of the issue.   Why this difference in attention? Could it be because playing with the language is so much more interesting than trying to fix the plumbing? Possibly. Who knows.  This all shows as (dare I say it) lack of robustness, maturity and user friendliness of the language. Which is especially sad because Haskell and GHC is such an incredible piece of technology."
haskell,36z17n,stasiana,12,Sun May 24 02:33:21 2015 UTC,"scary error messages are also a problem. It should not be necessary to be an expert Haskell programer for using DSLs or even EDSLs. However the errors refer to haskell language, not to the EDSL language. This is IMHO one of the biggest problems.    https://ghc.haskell.org/trac/ghc/ticket/7870  It should be prioritary if we truly want to see Haskell used in industry."
haskell,36z17n,agocorona,7,Sat May 23 13:18:39 2015 UTC,"I found GHC error messages scary at first, until I grokked the type system. Now, I find the error messages incredibly precise (sometimes, I over-read them and cause myself problems...). I wish every compiler was so informative.  Plus, once I could read GHC errors, C++ template errors stopped being pure gibberish..."
haskell,36z17n,panda_sauce,4,Sat May 23 15:52:11 2015 UTC,"Personally I always thought this was a huge issue. I was surprised how little it seems to show up in the data. We didn't ask specifically about it, but we did have questions designed to catch ""other"" problems -- and that certainly had an effect especially in version 0.1 of the survey where there were several things we hadn't asked about.  Perhaps if we drilled deeper into the debugging question it would show up more. Or perhaps not. I'm intrigued."
haskell,36z17n,FPguy,7,Sun May 24 02:39:54 2015 UTC,"I was surprised how little it seems to show up in the data.   This could just be sample bias. Presumably you weren’t getting a lot of responses from people who tried Haskell, found the current tools inadequate, and went back to whatever they were using instead."
haskell,36z17n,Chris_Newton,2,Sat May 23 16:05:37 2015 UTC,I filled out the form and forgot to mention the error messages. Just didn't cross my mind at that time...
haskell,36z17n,cies010,1 point,Sat May 23 16:38:32 2015 UTC,"My impression is that a lot of inexperienced programmers don't actually read error messages, so that might be less of an issue than it would've been :P  (But having better error messages would be really neat IMO)"
haskell,36z17n,Fylwind,2,Sun May 24 07:58:31 2015 UTC,"Can confirm. I usually just look for the first line number I can find and sniff around there. If nothing is obviously wrong, it's back for a detailed read of the error."
haskell,36z17n,theonlycosmonaut,1 point,Sat May 23 16:36:40 2015 UTC,So you do read m :)
haskell,36z17n,cies010,1 point,Sun May 24 03:22:11 2015 UTC,I guess. Eventually. :p
haskell,36z17n,theonlycosmonaut,6,Sun May 24 08:02:23 2015 UTC,Maybe the results are not surprising but with data showing where problems are it could be easier to allocate resources.
haskell,36z17n,quiteamess,4,Mon May 25 03:15:39 2015 UTC,"I am fairly new to Haskell and I don't think the documentation is that bad. I haven't had a hard time understanding what a package or function does after looking at the haddocks on Hackage. I have heard that there are a large number of low quality libraries people threw up on hackage, but plenty of other language ecosystems suffer this too, it's not unique to Haskell.  Cabal hell is annoying if you want to have any globally installed packages, but at least it fails at compile time instead of runtime. I think that is the tradeoff with Haskell, there is more pain upfront to satisfy the compiler, but at runtime you can be pretty damn sure your shit will work."
haskell,36z17n,kyllo,3,Sat May 23 13:53:47 2015 UTC,"And yet, I see relatively little work go into the tooling that empowers new entrants to the language. For example, Haskell's ""package manager"" probably takes last place compared to those for other languages.   If you're saying (if I misunderstood, apologies) that Cabal is not getting the attention it deserves, just take a look at how much is going on over at https://github.com/haskell/cabal/pulse and https://github.com/haskell/cabal/graphs/contributors  I'd rather say that Cabal is trying (i.e. it's not there yet) to solve a much harder problem than other languages are trying to address (and Stackage to some degree represents the traditional pragmatic solution to this kind of problem)"
haskell,36z17n,RedLambda,5,Sun May 24 04:17:32 2015 UTC,"This is our first blog post on these survey results, looking only at the biggest widespread needs, and just scratching the surface of the large set of textual comments.  One thing we expect to blog about shortly: there are specific clusters of survey respondents who want other things -- those interested in numerical analysis and machine learning, those interested in Windows or JVM, and so on. We'll keep digging into the data.   Please, if you're interested, take time to view the detailed summary reports on the survey data; and if you have the skills, go ahead and start analyzing the raw survey data and share your observations. There's a lot to take in."
haskell,36z17n,FPguy,11,Sun May 24 21:54:27 2015 UTC,"Who is still suffering cabal hell? Now that we have sandboxes and --allow-newer, I haven't really ever struggled.  What problems are people having?"
haskell,36z17n,jeremyjh,12,Sat May 23 11:59:52 2015 UTC,"Anyone brand new to the language. I struggled mightily with cabal hell trying to install yesod until I realized I had two different GHCs on my Mac and the older version's global packages (alex, happy) were symlinked into my PATH. Once I fixed that issue, then of course it took two hours to compile yesod.  I got through it and now I'm happily building a web app with yesod (which is a freaking amazingly well thought-out framework) but man, those first couple of days were rough. I almost gave up and went crawling back to ruby on rails... Glad I didn't though."
haskell,36z17n,kyllo,8,Sat May 23 12:17:13 2015 UTC,"Another newbie here. Twice I've had to delete all the packages I installed to start anew with cabal. I don't remember what I did, and there may have been a way out that didn't involve deleting everything but it seemed like the easiest way out.  I've also run into packages that didn't fully list their dependencies, so I had to install them manually."
haskell,36z17n,baconated,1 point,Sat May 23 17:05:19 2015 UTC,I have been coding in haskell for about 6 years now. When I accidentally install something not in a sandbox which breaks the global package db then I have to wipe it too.   Most stuff is fine when you use sandbox (except recompiling everything) but it's so easy to forget.
haskell,36z17n,Crandom,1 point,Sat May 23 19:09:38 2015 UTC,"My strategy has been to do ""cabal install foo --dry-run"" to see which versions of libs will be installed. If I see something that  could be ""problematic"",  I try lower version numbers (cabal install foo-0.x.x --dry-run) until the situation looks ""cleaner"". Now I've just started trying to use Stackage LTS."
haskell,36z17n,tdox,1 point,Sun May 24 10:17:07 2015 UTC,"I may write a wrapper script around cabal that errors out unless a cabal.sandbox.config exists in the current working directory, thinking about this."
haskell,36z17n,Crandom,2,Sun May 24 15:44:01 2015 UTC,"echo ""require-sandbox: True"" >> ${HOME}/.cabal/config"
haskell,36z17n,RedLambda,5,Sun May 24 16:24:12 2015 UTC,"I've spent days over the last few months trying to resolve cabal hell type issues.   2 days ago, I realised that the solution is to use ""cabal get"" to get the source code and change version bounds myself.   Now you've mentioned --allow-newer, which I haven't seen mentioned anywhere else.  If I'd known that that was the solution from the start it would have saved me a lot of struggle."
haskell,36z17n,slgard,5,Sun May 24 22:10:13 2015 UTC,"I'm not claiming it's obvious in the heat of dependency issues but I always try the command line --help flag:  $ cabal install --help | grep bounds     --allow-newer[=DEPS]            Ignore upper bounds in all dependencies or   However, be careful with --allow-newer as it can cause other subtle issues.   If you had luck modifying version bounds you should definitely try to submit patches or bugs upstream on the bounds you modified. Even a quick mention might make package authors aware an issue exists."
haskell,36z17n,creichert,3,Sat May 23 15:17:55 2015 UTC,"I think the problem for beginners (ie me) is information overload, not to mention not knowing that there's a solution to be looked for.   you should definitely try to submit patches or bugs upstream    hmm, ok then :)"
haskell,36z17n,slgard,3,Sat May 23 15:59:59 2015 UTC,"I feel as though cabal (actually, many command line tools) could take some cues from darcs on being interactive.  Being prompted with a potential fix could really assist with discoverability.  Instead of:  Dependency tree exhaustively searched.   Something like:  Couldn't resolve dependencies. You might want to try one of these:     --allow-newer=parsec,yesod     --allow-newer=attoparsec   I don't mean to make light of the amount of work required to make all of these commands friendly in this way though. Also, there needs to be a way to roll back (perhaps automatically) if/when playing with these flags breaks everything."
haskell,36z17n,rehno-lindeque,1 point,Sat May 23 17:16:37 2015 UTC,"If it wasn't mentioned in the error message from cabal, that's an obvious bug."
haskell,36z17n,hastor,12,Sat May 23 23:50:32 2015 UTC,"It still takes > 10 minutes to install scotty in a sandbox, and a lot more for a complex stack like yesod. Sandboxes are a band aid on more fundamental problems that needs to be fixed - binary downloads, and multiple concurrently installed package versions.   I also strongly believe that package management and build tools should be separate concerns, not a single monolithic app."
haskell,36z17n,zoomzoom83,5,Sun May 24 18:15:41 2015 UTC,"That isn't a cabal problem though, it is a ghc problem. Ghc just takes ages and tons of RAM to compile code.   It's a cabal problem, because cabal effectively requires things to be compiled that don't logically need to be compiled.  That's why sandboxes are a ""band aid."""
haskell,36z17n,reaganveg,1 point,Sat May 23 13:10:52 2015 UTC,"Most packages can't be reused, if they could we wouldn't need sandboxes   Huh?  If I install the same version of the same package in two sandboxes, my computer is doing something twice that only needs to be done once.  Right?  That's what I was talking about.    The compilation would be done only once if it were in the global package database (or if the same sandbox were used for two codebases), but the only way to enjoy that efficiency is to tolerate cabal hell proper.  I literally don't understand what you're saying here.  Please do explain.   And that still isn't anything remotely like cabal hell   No, it's a workaround that eliminates ""cabal hell"" but at the expense of redundant recompilation."
haskell,36z17n,reaganveg,1 point,Sat May 23 14:17:01 2015 UTC,"But if that were the case, you wouldn't need the sandboxes.    But you always need the sandboxes because you never know if you'll want to depend on something else in one of the projects that will introduce the need for sandboxes.  If you choose to say, ""OK, they use the same dependencies, I don't need a sandbox!"" you are taking a risk, namely that you will end up in cabal hell some time in the future when you add more dependencies to your projects."
haskell,36z17n,reaganveg,1 point,Sat May 23 15:08:07 2015 UTC,"I didn't take you to be arguing against sandboxes.  What I'm saying is that sandboxes, while they do serve as a workaround for traditional cabal hell, have the downside of doing what the person above said: increasing compile times by a potentially extreme (and in principle unnecessary) amount."
haskell,36z17n,reaganveg,6,Sun May 24 00:16:11 2015 UTC,"It really does seem like that is best left to the OS package manager.   Sadly, if we’re talking about real world applications in commercial environments, that policy alone is probably enough to lose much of the Windows developer community.  The standard for developers working on Windows is set by Microsoft’s development tools. These are well-designed, well-documented, comprehensive, reliable, fast, and ubiquitous.  If the equivalent for writing a new project in Haskell starts with figuring out how to install a year-old version of a compiler so an unfamiliar set of build tools can compile a simple binding to a not-very-good GUI library from source in less than an hour on a quad-Xeon workstation, then of course most development teams working in commercial environments aren’t going to consider that a serious proposition. And this is all too often the kind of first impression that developers used to working on Windows will form of the Haskell ecosystem today. (Edit: Haskell Platform does help with this to an extent, of course, but the issues with things like tools and documentation widely discussed elsewhere are still very relevant here.)  None of those issues really have much to do with Haskell-the-language, but the gap between academic/personal use and widespread industrial use is much more about tools, libraries, and non-technical issues like training materials and ready availability of skilled developers than it is about the specific language chosen."
haskell,36z17n,Chris_Newton,3,Sun May 24 01:25:07 2015 UTC,fltkhs is meant to be easy to install on Windows. It's certainly not as slick looking as Qt but it's pretty capable and fast. Please let me know if you're having issues.
haskell,36z17n,deech,8,Sun May 24 01:29:26 2015 UTC,"That isn't a cabal problem though, it is a ghc problem. Ghc just takes ages and tons of RAM to compile code.   It's a cabal problem, because it can't cache the results globally. I should be able to compile a library once and reuse it on all projects without version conflicts.    There's an assload of platforms you would need to cover. It really does seem like that is best left to the OS package manager.   I'd wager Intel Linux and MacOS would cover 99% of users. For remaining platforms, or libraries not already precompiled, you can still compile the same way you do now."
haskell,36z17n,zoomzoom83,8,Sun May 24 01:34:11 2015 UTC,"Even if you do consider build times a Cabal problem, I don't think that is what is commonly meant by the term ""cabal hell"".  The way I've seen it used, ""cabal hell"" refers to dependency resolution problems, which is a completely different thing from long build times."
haskell,36z17n,mightybyte,1 point,Sun May 24 01:38:16 2015 UTC,"But that would buy you very little, since almost none of it would be reusable so you would constantly have to be compiling new packages still.   That seems rather counter intuitive, especially considering this is exactly what Haskell Platform does.   Why would binary packages not be reusable?   You'd wager wrong. You're already losing i386 Linux, arm platforms are becoming increasingly important, windows users are the ones that already can't compile anything and are in most desperate need of binary downloads   So because a small percentage of users wouldn't benefit from cached binaries, we should throw the whole idea out the window?  I'll go out on a limb and say the vast majority of developers are running x64. The few that aren't can still compile, without being any worse off than they are today."
haskell,36z17n,zoomzoom83,0,Sun May 24 02:45:37 2015 UTC,"And everyone explicitly says ""don't use platform"".   Because it's very out of date. A binary distribution based on Stackage would be fine.   Because they don't have the same dependencies.    Wouldn't Stackage resolve this?   If they had the same dependencies, then you wouldn't need a sandbox.   There is still no reason I shouldn't be able to compile multiple versions of the same package into a global cache. Sandboxes shouldn't be needed for this.   I did not suggest anything of the sort. I said it is a big job, and then responded to the misconception that two platforms account for 99% of Haskell users.   I'd be extremely surprised if more than 1% of developers are using non x64 workstations. I'm not even sure you can buy a non x64 workstation at this point."
haskell,36z17n,zoomzoom83,0,Sat May 23 15:40:36 2015 UTC,"Just because it is there, doesn't mean you can use it. That's what I am saying. You can't just assume that because you have a Foo-3.0 that anything else needing a Foo-3.0 can use it.   Absolutely correct. The way GHC compiles things, libA 1.0 compiled against libB 1.0 cannot be used on a project requiring libA 1.0 compiled against libB 1.1.  But let's say you and I are both using the same version of Stackage. We both create a fresh sandbox, and we both type 'cabal install yesod'  We are both very likely going to get the same version of Yesod, with all dependencies, all the way down the entire tree.   I could compile this on my machine, tar it up, and send it to you, and it would work correctly for your project.  The point is not that binary dependencies will alway work for everything in all cases. The point is that in practice we'd likely end up with the same set of dependencies, and could therefore both use the same cached version.  Certainly if I started a project and pinned one of my dependencies to something that didn't line up then I'd need to recompile. But I could cache the results, and my colleague compiling the same project could use my cached binaries. And in fact this workflow is something we do on a regular basis with a bunch of custom scripts.   This also means I don't need a sandbox. LibA can be compiled against both versions of LibB and stored with a separate hash.  There are an effectively infinite number of possible package version combinations and we can't cache them all. But in practice, the same set of package dependencies tend to resolve, and we and simply skip recompilation in those scenarios.  Just because something doesn't solve 100% of cases doesn't mean that we should throw the baby out with the bathwater and just never do it. There are improvements we can make to the ecosystem, so we should stop making excuses and start fixing things."
haskell,36z17n,zoomzoom83,2,Sat May 23 19:41:50 2015 UTC,"Slowness is annoying, but I think calling it""hell"" is a bit much. I hope people know about cabal install -j. Even with that I agree that a Yesod application can take an extraordinary amount of time. There are some solutions to this. I've used Nix which will provide binary installs. Halcyon is supposed to re-use and share sandbox but I haven't tried it. I think another alternative may be system-wide installs using a stackage config."
haskell,36z17n,jeremyjh,3,Sat May 23 15:13:40 2015 UTC,"Slowness is annoying, but I think calling it""hell"" is a bit much.    The terminology is irrelevant. The reality is Cabal, while it does the job, is a relatively poor package manager and build tool. It can be downright painful and major impediment to productivity, and we should be aiming to improve it, not defend it and apologise for its limitations just because there's half baked workarounds that kind-of-work.  Cabal could be better, therefore we should make it better, not waste effort defending its limitations."
haskell,36z17n,zoomzoom83,12,Sat May 23 18:14:14 2015 UTC,"The terminology is relevant here. ""cabal hell"" was used to refer to a specific limitation of cabal/GHC. People using that phrasing now are, I guess, just using it in a way to reflect the pain the tool's deficiencies cause, but it causes confusion for those who might help because, to them, it refers to a specific issue."
haskell,36z17n,acow,1 point,Sun May 24 00:13:10 2015 UTC,compiling yesod on my banana pi takes 4 hours.
haskell,36z17n,Bzzt,1 point,Sun May 24 01:17:36 2015 UTC,"I just want love, and a little respect and medium amount of money."
haskell,36z17n,jberryman,1 point,Sun May 24 01:32:10 2015 UTC,"It's great to have something like this to clearly motivate work on less glamorous areas of Haskell infrastructure however... I'm a bit concerned at the idea that this data needs to be ""analysed"". If the statistical measures that are too be taken depends on examining the data then then the measures are no longer valid in isolation. Looking for patterns in data without a very large data set is a very dodgy business."
haskell,36z17n,maninalift,-3,Sun May 24 02:06:06 2015 UTC,Summary: Fire the Industrial Haskell Group
haskell,36z17n,ksteinberg,2,Sun May 24 02:20:10 2015 UTC,An alternate approach - pay them more so they can afford to devote more time to our tooling.
haskell,36z17n,sclv,-1,Sun May 24 03:32:41 2015 UTC,"Um, No. Present history has proven that they can't even operate what should be a fairly trivial package server correctly, both in uptime, and in functionality- let alone a non-profit. Not another penny."
haskell,36z17n,ksteinberg,1 point,Sat May 23 17:14:34 2015 UTC,"The IHG doesn't run core haskell infrastructure. A team of volunteers does. And since the migration from hetzner to rackspace, uptime has been fine, although certainly there are many other issues to tackle."
haskell,36z17n,sclv,1 point,Sat May 23 17:36:34 2015 UTC,How is it the IHG's fault?
haskell,36zo7p,edsko,14,Sat May 23 14:27:28 2015 UTC,"This post lost me with the statement of the main theorem of parametricity. I don't understand what ℛ is, and I don't know how to convert the later examples into English (I did read the entire thing, but I traced my lack of understanding back to that point, and I actually tried to understand it). I don't know why it apparently takes or is associated with a type. I found the later box on ""the type of ℛ"" extremely confusingly written as well. Then, shortly thereafter, the @ syntax is introduced without explanation. I think as a tutorial for the Haskell practitioner, this needs a lot more explanation of the syntax or something, but since I don't understand it at all, and am thus not sure what I'm supposed to get out of it, that may not be the only issue.  Edit: I read the first three sections of the Wadler paper, and I did understand that, so I feel this is a problem of the explanation and syntax rather than not having prerequisite knowledge."
haskell,36zo7p,xanados,12,Sat May 23 22:37:56 2015 UTC,"The phrasing of the post is indeed lacking. FWIW, the standard presentation of parametricity goes more like:  First, consider: what does it mean for a term to have a particular type? We'll answer this by defining a mapping, ℛ, from (the syntactic expressions naming) types to sets of terms with that type. Then we will prove various properties about that mapping; e.g., if we can prove ∅ ⊢ e : t, then if follows that e ∈ ℛ(t). That is, if we can syntactically prove that a closed term e has type t, then we can prove that e behaves like something of type t should.  The above approach is called ""logical predicates"" and gives a way of relating the syntax (Γ ⊢ e : t) to the semantics (e ∈ ℛ(t)). For parametricity we will generalize this approach to ""logical relations"". That is, rather than having ℛ map types to sets of terms, we will instead have ℛ map types to relations on terms (viz., sets of pairs of terms). Thus, the abstraction theorem (aka parametricity theorem) would be more standardly stated as ""if ∅ ⊢ e : t, then (e,e) ∈ ℛ(t)"". Note that this is just the 'obvious' generalization of the usual theorem for logical predicates.  Does that help?"
haskell,36zo7p,winterkoninkje,6,Sun May 24 00:41:51 2015 UTC,"So ℛ is a type-indexed relation. That's rather technical though, so perhaps an analogous example helps. Consider (<=) (less-than) in Haskell; <= too is a type-indexed relation. We have, for example:   False <= True 1 <= 2 ""a"" <= ""ab""   But in each of those examples we are using a different <= relation; in this case, a different instance of the Ord type class (the one for Bool, Int, or String, respectively). In Haskell we rely on the type checker to automatically use the right instance of (<=), but if we wanted to be more explicit we could use the syntax of the blog post to write instead:   False <=(Bool) True 1 <=(Int) 2, ""a"" <=(String) ""ab""   So, <=(t) is a relation between two terms of type t. The situation with ℛ is similar: given a closed type t, ℛ(t) also is a relation between two terms of type t. For constant types it relates only equal terms, so we have    False ℛ(Bool) False 1 ℛ(Int) 1 ""a"" ℛ(String) ""a""   It's slightly more complicated than that though because ℛ is also defined over open types. For example, if a is a relation between terms of type Float and Double (in the syntax of the blog post: a :: Float  ⇔ Double) then, for example,   ℛ(a) is a relation between terms of type Float and terms of type Double ℛ(a -> a) is a relation between terms of type Float -> Float and terms of type Double -> Double ℛ(a -> Int) is a relation between terms of type Float -> Int and Double -> Int.   Of course, the precise definition of ℛ (that is, which terms are related at every type) is precisely the point of the blog post.   As for the @ syntax, I did try to explain this in the blog post but perhaps not very clearly. Suppose you have a polymorphic function, say, f :: ∀a. a -> a. Then in Haskell we can write f True, f 1 or f ""a"", and again the type checker implicitly instantiates that type variable a to Bool, Int or String, respectively. In the blog post I wanted to be a bit more explicit about types, so I write f@Bool to mean ""f where a is instantiated to Bool"".   Please let me know if the above makes it any clearer."
haskell,36zo7p,xanados,1 point,Sun May 24 09:11:23 2015 UTC,"That is definitely helpful. So ℛ is used to denote type-indexed relations between values, and ⇔ is used to denote relations between types?"
haskell,36zo7p,gasche,1 point,Sun May 24 16:14:57 2015 UTC,"Both are relations between values:   ℛ is single (albeit type-indexed) relation, whose definition is given by the theory of parametricity. For closed types ℛ(t) is a relation between terms of type t; for open types the precise types of those terms is a bit more complicated.  I use ⇔ to indicate arbitrary other (not type-indexed) relations between terms of two types; for instance, if a:: Float ⇔  Double then a is a relation between terms of type Float and terms of type Double.   Note that if a is a type variable, and we have a corresponding relation a :: A ⇔ B, then ℛ(a) is defined to be the same relation as a; so they must be relations between the same things."
haskell,36zo7p,neelk,9,Mon May 25 08:44:38 2015 UTC,"I think that many results that are traditionally explained through parametricity can be much more easily derived by doing a complete syntactic search among cut-free terms. For example, proving that forall a . a -> a -> a always returns one of its arguments is a graduate-level puzzle when it has to be derived from parametricity, and immediate by proof/term search:   without loss of generality¹, we can consider that all terms of type a -> a -> a start with abstracting over their two arguments: all terms at this type are equivalent (as programs) to a term of the form \ x y -> ... to fill the ... above, we have to provide a value of the abstract type a, and the only thing we have in context are two formal variables x : a and y : a. The only possible choice² is to use either x or y, and this concludes all possible proofs.   This demonstration of course conveniently relies on meta-theoretic results that have to be established for the programming language under consideration (and are in fact wrong in practical languages, as for example undefined is always a valid choice for the second  step). But then so does parametricity; the style of meta-theoretical results to establish is different (parametricity is the construction of a relational model; syntactic search requires a cut-elimination result, and if possible a complete-focusing result, with in particular a good inversion principle on well-typed terms), but I am not sure one is fundamentally harder than the other.  ¹: this ""without loss of generality"" reasoning is based on the observation (which has to be formally proven) that using the lambda-abstraction rule to form a function type is an ""inversible step"" that loses no computational content.  ²: the ""no other possible choice"" reasoning relies on proving that certain constructions can always be eliminated from terms. For example, one could argue that it would be possible to write a program of the form t u, with t : U -> a for some type U and u : U, but we can formally prove that it is unnecessary to consider that case."
haskell,36zo7p,gasche,10,Sat May 23 19:47:18 2015 UTC,"I dearly love focusing, but it doesn't scale up to the arguments that parametricity can handle. Basically, the kinds of arguments you sketch above rely upon the subformula property, which doesn't hold once you have induction (or impredicative f-style quantification). A nice example is to prove that every type X is isomorphic to forall a. (X -> a) -> a. This isn't even grammatical for focusing, since if X is positive then it asks you to equate a positive and negative type.  In general my heuristic is to try focusing first, and if that doesn't work try parametricity. (I've never needed a step three.)"
haskell,36zo7p,julesjacobs,3,Sat May 23 21:26:51 2015 UTC,"I have been thinking about this recently, trying to extend my work on ""which types have a single inhabitant"" to a system with parametric polymorphism. I think this problem may be solved. I had an idea for an algorithm/criterion based on focused search that justified the isomorphism between X and forall a . (X -> a) -> a, only it also happens to justify (X -> 0) -> 0 so I'm back to the drawing board. (The idea is that a type corresponds to the sum of products of the subgoals of its partial focused proofs. Justifying (X -> 0) -> 0 happens if you only take the conclusion of the judgment of these subgoals.)"
haskell,36zo7p,gasche,3,Sat May 23 21:35:55 2015 UTC,"The nice thing about parametricity is that it in some sense works ""observationally"". You could imagine a language where f : forall a. a -> a -> a was literally a function that takes a type as its first argument, and it is allowed to analyze the structure of that type, just any function is allowed to analyze the structure of a cons list. You could say that those functions are not parametric because parametric functions can't look at their type arguments, but I don't think that is the best perspective on it. Whether a function is parametric only depends on the observational behaviour of the function, not on what it's doing internally. It can analyze the type structure all it wants, and it may even compute the result differently based on that analysis, as long as in the end the result doesn't vary based on the type argument. The same goes for univalence."
haskell,36zo7p,julesjacobs,1 point,Mon May 25 12:42:18 2015 UTC,"I am unconvinced. If the function inspects its type but behaves uniformly over it, then it is equivalent (observationally) to a function that doesn't inspect its type. The proof search approach would then still work: you could have a meta-theoretical result saying that any uniform/parametric term is equivalent to a function of a smaller syntactic class of correct-by-construction terms, and do the proof search in that restricted space. (In fact proving that your edgy function is equivalent to a function in a smaller parametric-by-construction subset would probably be a good way to prove, in the first place, that it is parametric.)"
haskell,36zo7p,gasche,2,Mon May 25 13:35:40 2015 UTC,"Well, the nice thing about parametricity is that there's no need for the concept ""a function that does not inspect its type"". A function is just a mathematical function, it isn't doing anything inside itself, it's just mapping inputs to outputs. On the other hand you are thinking about functions as programs in some language, and within that there is a notion of not inspecting an argument. Parametricity gives a purely mathematical view, not inspecting an argument is an operational view that depends on the language you're in.  Proof search is essentially enumerating all programs of a given type in a more intelligent way, but this doesn't work for many type systems since it's even undecidable whether a type has an inhabitant at all, and precisely characterizing the entire set of values in a given type is even more impossible. For types for which you don't know if there is an inhabitant you can still get a parametricity theorem.  There's also the question if you really want to equate the concept of function with functions expressible in your language. If you're doing math in a total language then you don't necessarily want to assume that all functions are expressible in the language, you might not even want to assume that all functions are computable, but you may still want to assume that functions are parametric.  Proof search is a very nice topic, and it can do some things that parametricity can do and vice versa, but neither is a replacement for the other."
haskell,36zo7p,julesjacobs,2,Mon May 25 14:25:38 2015 UTC,"Proof search is essentially enumerating all programs of a given type in a more intelligent way, but this doesn't work for many type systems since it's even undecidable whether a type has an inhabitant at all, and precisely characterizing the entire set of values in a given type is even more impossible.   That is correct, but often we don't study the parametricity theorem for arbitrary types of our system, but for specific types -- the fact that inhabitation is undecidable in the general case then does not matter. For the example of forall a . a -> a -> a above, I was able to easily derive an interesting result, despite the fact that inhabitation is undecidable for System F.  (For example, in Canonicity of groupoid laws using parametricity theory, 2014, Marc Lasson profitably studies the parametricity theorem of a very constrained family of types that, in particular, are known to be inhabited. Note that I don't know (yet?) whether a similar result could have been obtained by proof search.)    For types for which you don't know if there is an inhabitant you can still get a parametricity theorem.   That is also correct, but you may not be able to tell much interesting things from this theorem.  In fact, one could argue that the situation is not well-posed. We are able to say that inhabitation is undecidable because we formally consider algorithms that given any type will mechanically answer a given question (is this type inhabited?). Are there mechanical algorithms that derive a property of interest from any type's parametricity theorem? It could be the case that, for your property of interest, the question of ""does this parametricity theorem imply the property"" is undecidable as well."
haskell,36zo7p,julesjacobs,2,Mon May 25 14:45:04 2015 UTC,"p.s. also you may not get the theorem you want for those groupoid laws. If you prove it using parametricity you get a theorem ""IF functions are parametric, THEN the groupoid laws are canonical"". With proof search you would get at best ""IF functions are generated by terms in such and such language, THEN groupoid laws are canonical"". The latter is a weaker theorem than the former."
haskell,36zo7p,gasche,1 point,Mon May 25 16:15:38 2015 UTC,"Are there mechanical algorithms that derive a property of interest from any type's parametricity theorem? It could be the case that, for your property of interest, the question of ""does this parametricity theorem imply the property"" is undecidable as well.   Well, as a trivial example, if the property of interest is the type's parametricity theorem itself, then there exists a mechanical algorithm to derive that from the parametricity theorem (the identity function). Yet one would not be able to derive it using proof search unless it can fully characterize the type. Deriving parametricity results from a full characterization of a type is a bit like proving 13 + 13 != 13 in the following way: first, prove Fermat's last theorem, then, get the result using a=b=c=1, n=3."
haskell,36zo7p,julesjacobs,1 point,Mon May 25 16:11:20 2015 UTC,"I was thinking of something a bit different. In the case of inhabitation, the property being proven does not depend on the type. Formally, it is a predicate P on any set of programs, and I am asking for an algorithm that takes a judgment Γ ⊢ τ, and decides P { t | Γ ⊢ t : τ }.  Your example is different because the property to be proven (the parametricity theorem) depends on the type being considered. You cannot phrase your example as a procedure that, for any binary relation R, decides a predicate P on the set { t | t R t } (the diagonal of R).  (Let me rephase. Saying different things about different types is interesting, but mostly as a reasoning step to eventually answer a question we might have about those types and their inhabitants. The question is the same for any type. Examples of questions are: Does there exist an inhabitant? Does there exist at most one inhabitant? Do all inhabitants strongly normalize to a value? Does the execution of the inhabitants respect the following security policy? (Concurrent) Memory access policy?)  For example, I think that deciding for any parametricity theorem R (or its underlying judgment Γ ⊢ τ) whether the set of elements satisfying this theorem is empty (or is non-empty) is undecidable."
haskell,36zo7p,gasche,1 point,Tue May 26 10:17:08 2015 UTC,"I think that your predicate P does depend on the type. Take the forall a. a -> a example. Now your predicate P is P(S) = for all p in S. eval(p) is the identity function. This implicitly depends on the type. One could even argue that a question like ""is 1+1 the identity function"" is not well formed, because ""is x the identity function"" means ""forall z. x(z) = z"". I feel like we are having a Church vs Curry disconnect here.  What parametricity is doing is taking a type and producing a theorem that all elements of that type have to satisfy. So any given theorem that you get out of parametricity you can formulate as P { t | Γ ⊢ t : τ }, but you can not get all possible P's out of parametricity. So proof search is strictly harder. You can ask whether proof search can prove all parametricity theorems. In theory if your proof search is good enough it can, but I don't think it's easy to make one that good. For example the class of proof search procedures that enumerate terms in some intelligent way won't work: because it's undecidable whether a type has inhabitants there are types which are inhabited but proof search won't be able to find an inhabitant. Parametricity is still able to give you a theorem about those inhabitants. So if you want to be able to prove all parametricity theorems automatically then your proof search would need to work in such a way that it can establish a theorem about the set of terms of a given type without ever finding an element of that set. Also it needs to be able to establish theorems about infinite sets of terms. For example the type forall a. a -> (a -> a) -> a has infinitely many terms. Parametricity is able to give a theorem: for all n : forall a. a -> (a -> a) -> a we have n = n (\x f -> x) (\k -> \x f -> f (k x f)). How do you intend to get this from proof search?"
haskell,36zo7p,julesjacobs,2,Tue May 26 13:13:03 2015 UTC,"I made two different remarks that I think you are mixing up in your first paragraph. The first case is the case of specific types, there the question is whether syntactic search or using the parametricity theorem is easier to get a property of interest of the inhabitants of a given (fixed) type. That is the setting of your example of the identity function, and I argue that it is trivial to check that only the identity function has type forall a . a -> a (in, say, System F) by searching, easier than from parametricity. The second case is about answering questions about the inhabitants of any type, and there I argued that the undecidability problems that plague proof search may also prevent you from deducing answers (of questions that do not depend on the type) from the parametricity theorems.   Also it needs to be able to establish theorems about infinite sets of terms. For example the type forall a. a -> (a -> a) -> a has infinitely many terms. Parametricity is able to give a theorem: for all n : forall a. a -> (a -> a) -> a we have n = n (\x f -> x) (\k -> \x f -> f (k x f)). How do you intend to get this from proof search?   I'm thinking of proof search performed by a human trying to prove a specific theorem, not a generic proof-search algorithm working for any type. In your case, I would argue that:   The real theorem I want to prove for forall a . a -> (a -> a) -> a is not yours, but ""the inhabitants are exactly the Church integers"" (the canonicity of natural numbers in System F, as proved by Girard fourty years ago). This is trivially established by proof search: first by inversible steps you add z : a, s : a -> a into your context, and then you notice by exhaustive search that all proofs are of the form z or s ?, where ? is a proof in the same context, that is all proofs are in the grammar N(z,s) ::= z | s N(z,s). (The idea of recognizing a subgoal in the same context is a form of cycle detection which is very easy to do by hand.) Once you have that result (established by proof search) you can prove the result you propose by induction (on the grammar of proofs). Let us write Z := (\z s -> z) and S := (\n z s -> s (n z s)) for the church encodings of zero and successor and, if n(z, s) is an element of the grammar N(z,s), write n(Z,S) for the substitution n(z,s)[Z/z,S/S], then you can easily prove by two successive inductions that (\z s -> n(z,s)) Z S = n(Z,S) = (\z s -> n(z,s))."
haskell,36zo7p,gasche,1 point,Tue May 26 14:33:21 2015 UTC,"Ah, I understand now. For some reason I kept thinking that proof search had to be done automatically."
haskell,36zo7p,JeanPhilippeBernardy,1 point,Tue May 26 20:04:28 2015 UTC,"For simple examples, yes. But if you have something like   type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t   for some constant types S, T, A and B, but polymorphic in f, then I'm not sure how your ""search"" approach would work? (Admittedly this isn't yet covered in part 1; part 2 will.)"
haskell,36zo7p,JeanPhilippeBernardy,1 point,Mon May 25 13:48:11 2015 UTC,"I'm not sure either. Basically you would have to enumerate all proofs that treat f abstractly, and are normal for the theory of functor laws seen as a rewriting system.  Note that my point is an opinion/intuition rather than an established claim. There is excellent literature on how to derive parametricity results for many type systems (because building models is interesting to get meta-theoretical results, so there is strong incentive to build models, relational or not, for type systems of interest), while I don't think there has been a lot of discussion on how far we could go with syntactic search alone -- farther than we currently do, I think.  Interestingly, Edward Kmett gives in the Lens documentation an equivalence table between highly-polymorphic type definitions such as the one you gave above and much simpler definitions (the ""Equivalent to"" column). You can get interesting result with syntactic search in the simply-typed lambda-calculus with atoms by working with the simple equivalent types (in a recent draft I show (page 9) that, taking those simple types as definition, one can show that some operators provided by the library are in fact uniquely determined by their type). Of course, showing the equivalence between the simple and the complex type is another matter -- but I think it might be doable by syntactic search with strong enough inversion principles."
haskell,36ysso,nikita-volkov,16,Sat May 23 07:01:02 2015 UTC,Very nice explanation.  See here for the dual of this construction:  http://h2.jaguarpaw.co.uk/posts/strictness-in-types/
haskell,36ysso,tomejaguar,4,Sat May 23 11:40:11 2015 UTC,Amusing read! Thank you. The past week has shown that the camp of people who are frustrated with the laziness is actually huge in numbers. We might want to do a poll.
haskell,36ysso,andrewcooke,9,Sat May 23 13:08:30 2015 UTC,I would love to see that in an actual language   http://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec24-streams/streams.htm
haskell,36ysso,andrewcooke,3,Sat May 23 11:18:18 2015 UTC,"http://www.cs.cornell.edu/courses/cs3110/2011sp/lectures/lec24-streams/streams.htm   Wow! It's amusing to know that people can come up with concepts so similar independently. I've honestly never read that paper, nor anything much concerning OCaml, yet the concepts presented there are so similar even down to a term ""deferring"". Thank you for the link!"
haskell,36ysso,wheatBread,4,Sat May 23 11:37:36 2015 UTC,"it's a fairly common example in strict functional languages.  i'm pretty sure it's covered in SICP for example.  but with ML you get explicit types, too (another place with ML code for this is Cousineau & Mauny)."
haskell,36ysso,jberryman,20,Sat May 23 11:41:09 2015 UTC,"Say what you will, but I would love to see that in an actual language.   Elm is strict and does laziness with the lazy package, pretty much exactly how your Thunk type works. That library got used heavily in this course which goes through Okasaki's Purely Functional Data Structures book.  Between working on FRP and concurrency and a compiler in Haskell, I have run into very serious problems with laziness quite a few times on code that is otherwise correct (sort of described here). With concurrency it was an ""oh, I guess this project is over"" level problem when I realized what was going on. So I have definitely had some serious bad experiences, but I have never felt a corresponding benefit. It's just cute tricks like (zip [1..] xs) that save ~10 characters in my experience.  In any case, strictness-by-default is very nice in a pure language! I get to write programs like this and never worry about sneaky memory leaks :)"
haskell,36ysso,wheatBread,9,Sat May 23 12:06:56 2015 UTC,"""oh, I guess this project is over"" level problem when I realized what was going on.   Can you elaborate on any of these? Your ""pitfalls"" section of the README only seemed to describe the issue of storing thinks in mutable references which is easy to spot, well-documented, and simple to deal with IMHO."
haskell,36ysso,edwardkmett,6,Sat May 23 15:57:52 2015 UTC,"I was using Control.Concurrent.Chan to implement section 4.4 of my thesis in Haskell. With the basic library, everything goes through, no computations occur, everything synchronizes at the end. This means putting computations on different threads did not actually say anything about when those computations happen, which was the whole point. This was not a viable path for me.  I then looked into Control.Concurrent.Chan.Strict but that relies on on deepseq which does a full crawl over a data structure. Say you are passing a large record around and it goes through a couple channels. It has a bunch of fields, holding long lists or large dictionaries. With deepseq you are crawling the entire data structure on every channel for no reason. This turns send from O(1) to O(N) in the size of the value being sent across.  Neither option here was viable as far as I could tell. Maybe I could have tried harder and figured out some other tricks, but I could also use a strict language and not have these problems."
haskell,36ysso,rpglover64,15,Sat May 23 16:18:37 2015 UTC,You can make a data type like  data Once a = Once a ()  once :: NFData a => a -> Once a once a = Once a (rnf a)  instance NFData (Once a) where   rnf (Once _ r) = r `seq` ()   and use it judiciously to avoid multiply-deepseq'ing the same value from causing an asymptotic hit.
haskell,36ysso,jberryman,4,Sun May 24 03:33:44 2015 UTC,"In addition to /u/edwardkmett's suggestion of the Once data type, there's the recent nf package."
haskell,36ysso,wheatBread,1 point,Sun May 24 13:39:33 2015 UTC,"Right, so edwardkmett's solution is very nice; I probably wouldn't have thought of it and just would have defined my own class that let me do as much or as little evaluation as I liked. I would think the real challenge here would be how to maintain the control over evaluation these computations when you're using unbounded queues with a thread scheduler you don't really have control over."
haskell,36ysso,wheatBread,3,Sun May 24 09:58:25 2015 UTC,"This is great! I've read about Elm and watched a few presentations. I find a lot of concepts in the language very well thought thru. It's all the more satisfying to find out that I'm sharing the views on the laziness problem with the authors!  If you're Evan, the author, then a high-five to you, and thanks for the excellent research you're doing there!"
haskell,36ysso,kyllo,5,Sat May 23 12:43:50 2015 UTC,"Yep, I'm the author, and thank you! :D Though Elm has academic roots and we do stuff like this, Elm is not a research project: the goal is to make something so useful and accessible that typed FP can finally go mainstream. I'm hoping projects like elm-html will help make it clear that we can do real stuff and do it real fast!"
haskell,36ysso,wheatBread,4,Sat May 23 13:10:24 2015 UTC,"Elm is not a research project: the goal is to make something so useful and accessible that typed FP can finally go mainstream   I mean this constructively: but I think the focus needs to be more on docs and community then.  I gave up on my attempts at playing with elm because I couldn't figure out how to do basic stuff I do in Haskell just fine, and I idled in IRC for a week without seeing a single question answered."
haskell,36ysso,kyllo,5,Sat May 23 14:23:10 2015 UTC,"Working on it! I'm sorry IRC wasn't a good way to get answers, we are very responsive on the mailing list. I tend to lose whole days of productivity if I go in IRC, so thanks for letting me know that it's quiet in there. I'll see if I can get it going again.  I'd be curious to hear what you ran into... Please share on the mailing list if you get the chance!"
haskell,36ysso,wheatBread,1 point,Sat May 23 15:18:59 2015 UTC,"Hi, I'm wondering if you have you seen Paul Chiusano's feedback about Elm? It sounds like he tried to build a pretty ambitious IDE project in Elm but got frustrated when he ran into some of its limitations: http://pchiusano.github.io/2015-04-23/unison-update7.html"
haskell,36ysso,kqr,3,Sun May 24 04:07:51 2015 UTC,"Yeah, he emailed the list about this here, and that spawned this thread. If you look through at the specific thing he is trying to do, it is quite a specialist case for web programming. For 99% of websites or other online things, I don't think you will be in that position. That's not to say it's not important, but I have to make prioritization decisions to make any real progress and part of that is deciding how broad the impact of certain changes will be when budgeting time."
haskell,36ysso,kqr,1 point,Sun May 24 11:20:42 2015 UTC,"Interesting... that thread was a good read. I can see how his use case (basically implementing a client-side compiler and other IDE support for his new language) is non-typical, and I can certainly relate to the argument about priorities, but on the other hand I'm not sure if Elm's target audience really should be the JS+ruby/python web developers as opposed to functional programmers who need to do client-side development. That philosophy of accessibility over power in the type system seems like it could be limiting in the long run. Like avoiding monads because they sound scary to the average web dev seems like it would defeat the purpose of having an advanced type system. It's an amazing project as it stands, but anyone coming from Haskell is going to feel pain when they try Elm and find out it lacks typeclasses for example. I'm not an Elm user myself currently, so maybe I'm unqualified to have an opinion on it... but I am a former JS/ruby/python person who switched to Haskell, and I've been reading posts about Elm with interest."
haskell,36ysso,ninereeds314,2,Sun May 24 17:44:14 2015 UTC,"I'd say try it before you form an opinion! I think many of your concerns do not play out in practice / are false choices, and the point I'm trying to make in this mailing list thread is that I specifically planned things so we can extend them. Languages live for 20+ years, so I am optimizing to solve these problems at strategic times.  In any case, the best argument I can make is the language itself. If you use it and run into issues along these lines, I'd be very curious to hear the concrete cases. If you use it and you don't miss anything, I'd be very curious to hear that story too :)"
haskell,36ysso,Taneb,5,Sun May 24 19:20:58 2015 UTC,bool' a b c = bool a b c ()    I can just imagine the layers of Deferred for when you don't want your result to be forced by bool...
haskell,36ysso,tomejaguar,10,Sat May 23 07:40:46 2015 UTC,"Well, in that particular case you'd simply use the standard bool, which you can consider as having the following signature, when you use it on Deferred a:  bool :: Deferred a -> Deferred a -> Bool -> Deferred a   Generally though, yes, there'll be cases where you'll have to wrap things in deferred manually. But it's not boilerplate, but an explicit control over evaluation. Also don't forget about the power of abstraction! Both Thunk and Deferred are monads, which means that you can compose, while keeping abstracted away from the fuss of wrapping/unwrapping."
haskell,36ysso,andrewcooke,2,Sat May 23 07:52:05 2015 UTC,"Ah, that's a good point. I didn't think of that. :)"
haskell,36ysso,Taladar,4,Sat May 23 07:54:15 2015 UTC,"Isn't that very similar to the strict and imperative argument against keeping effects separate with the IO-like monads?  I keep running into cases just recently where it would be convenient if those read-only accesses (via the FFI) weren't in IO, but they have to be because (1) they're sensitive to effects so ordering relative to effects is important, and (2) they're based on FFI actions which are in IO anyway.  Forgive the IO-Monad 101, but in an imperative/strict language I wouldn't care because the effect ordering is the execution what-you-see ordering anyway, which is e.g. how an imperative while loop can have a condition that reacts to mutations of variables in the body of the loop. The while condition is an action, but in an imperative language doesn't need to say so. For example, the Haskell while loop here...  while test action = do     val <- test     if val then do {action;while test action}         else return ()   The test is an ""action"", not a simple boolean value. That isn't as convenient as in imperative languages. Small price to pay etc, but the point is that it's not as if choosing lazy-and-pure over strict-and-impure has no downside.  Then again, as SPJ often says, lazy evaluation kept Haskell honest. If it didn't have non-strict evaluation, it probably wouldn't have stuck to its pure functional principles through the tough times anyway. So if it wasn't for non-strict evaluation, we wouldn't have the rest of Haskell.  EDIT  Of course efforts to be non-strict are also why we have the impure evil of lazy IO."
haskell,36ysso,Taladar,7,Sat May 23 08:30:27 2015 UTC,I am not sure that this gets you sharing nicely...
haskell,36ysso,chrisdoner,5,Sat May 23 08:31:17 2015 UTC,"Deferred doesn't, Thunk does."
haskell,36ysso,edwardkmett,3,Sat May 23 12:21:29 2015 UTC,yeah for that you need mutable state.  here's an example in ocaml - https://realworldocaml.org/v1/en/html/imperative-programming-1.html#idm181616515952
haskell,36ysso,tomejaguar,6,Sat May 23 12:15:08 2015 UTC,How would you implement e.g. Monad's >> or any other control construct with sequencing where evaluation order matters? You would have to turn almost everything into these dummy functions for those things to keep working.
haskell,36ysso,edwardkmett,4,Sat May 23 10:50:58 2015 UTC,"You would have to turn almost everything into these dummy functions for those things to keep working.   Not everything, but, yes, where required, I'd have to. However for that price I'll get an explicit reflection of the evaluation order in types, thus knowing for certain (or declaring) where and when things get evaluated, instead of deducing (often incorrectly) the way I have to do now.  From what I've seen, the absolute majority of leaks, stem from incorrect assumptions about evaluation order. Just take a look at any post concerning leaks in Haskell. And leaks are a major pain, often taking days to resolve.  We, Haskellers, of all people should know what a difference a type-checker makes in terms of safety. That's why I'd gladly pay the price for reflecting the evaluation order in type-system, because it would make the mentioned category of bugs perish."
haskell,36ysso,tomejaguar,5,Sat May 23 12:07:54 2015 UTC,From what I have seen most leaks stem from leaving something unevaluated that is a lot larger in unevaluated form than it would be when fully evaluated. This particular kind of bugs could be more easily vanquished by simply applying the existing bang patterns to any long lived variable or record field.  I also don't quite see how they take days to resolve given the excellent memory profiling tools the GHC RTS includes.
haskell,36ysso,edwardkmett,2,Sat May 23 21:03:24 2015 UTC,"From what I have seen most leaks stem from leaving something unevaluated that is a lot larger in unevaluated form than it would be when fully evaluated.   Which is a case of incorrect assumptions about the evaluation order.   This particular kind of bugs could be more easily vanquished by simply applying the existing bang patterns to any long lived variable or record field.   Which means forcing Haskell to be strict anyway, but with user's hands and no type-checking on the matter. I want to stress again on what a major difference type-checking makes.   I also don't quite see how they take days to resolve given the excellent memory profiling tools the GHC RTS includes.   It's, of course, subjective. But the first times I had to deal with such bugs I had to go thru an absolute frustration. Having an experience now, I'd of course deal with such issues much faster. But if you wish the language to evolve, you always must think about newcomers, and for a newcomer that kind of a problem is absolutely daunting, because it requires quite an amount of googling, reading and learning about new tools, such as profiling, with all that unexpectedly falling on the user's head, when he thinks that he's almost finished with his program."
haskell,36ysso,drb226,2,Sun May 24 07:03:35 2015 UTC,"Perhaps you simply don't have >> and just use do, where:  do x; y desugars to x >>= \_ -> y  That avoids situations like do x; error "":("" throwing an exception before x or >>= has been evaluated."
haskell,36ysso,chrisdoner,3,Sat May 23 15:05:02 2015 UTC,"Note that this comes at a large asymptotic cost for some operations, ensuring the asymptotics of an action written with (>>) can never benefit from sharing -- sharing the functions is useless -- taking a number of operations from O(log n) to O(n)."
haskell,36ysso,tomejaguar,1 point,Sun May 24 03:36:06 2015 UTC,I don't see why it can't benefit from sharing.  Can you explain?
haskell,36ysso,tomejaguar,2,Sun May 24 06:21:50 2015 UTC,"Build  instance Num a => Num (b -> a)   then compute x^1001201023 in that Num instance to that of the basic Num instance on a.   f * g = \x -> f x * g x   when you ""share"" it only shares the functions, not their results, because it doesn't know you'll only be applying them to the same inputs.  This actually is one of the reasons why reflection can win asymptotically over the naive solution. Given the uniqueness of the inhabitants of the instances.  In Chris' proposal (>>) is now chaining functions in a similar manner with similar costs."
haskell,36ysso,gelisam,1 point,Sun May 24 11:45:53 2015 UTC,Do you mean if you have a long chain of  x >> (\_ -> x) >> (\_ -> x) >> (\_ -> x) >> (\_ -> x) >> ...   then you have to apply the dummy argument each time?
haskell,36ysso,gelisam,1 point,Mon May 25 10:03:42 2015 UTC,"er..  x >>= \_ -> x >>= \_ -> ...   or   (x >>= \_ -> x) >>= \_ -> ...   and my thought above was that this may affect the asymptotics involved.  Contemplate  x^8 = x4*x4 where   x4 = x2*x2   x2 = x*x   which gets away with computing x^n in O(log n) multiplications, which gets to exploit the sharing of the intermediate values.  But if that is in the Num instance above, you get  f^8 = \x -> f4 x * f4 x where   f4 x = f2 x * f2 x   f2 x = f x * f x   Then we get sharing of functions, not values. The compiler isn't able to see through the loop and do common sub-expression elimination.  My initial suspicion above was that that sharing the intermediate x >> \_ -> x  's runs into same sort of issue, but here the result is still an m a, so it may just be fine sharing the intermediate results."
haskell,36ysso,tomejaguar,2,Mon May 25 12:04:44 2015 UTC,a >> b could also be a syntax macro that desugars to a >>= \_ -> b.
haskell,36ysso,gelisam,1 point,Sat May 23 21:01:46 2015 UTC,"Introducing such complications just for the sake of having do x; error "":("" mean the same thing as in Haskell seems like a waste. In the uncontrived cases the strict (>>) would behave the same way anyway."
haskell,36ysso,tomejaguar,4,Sun May 24 06:49:42 2015 UTC,"The obvious example that springs to mind is that with my desugaring I can write forever x = do x; forever x and it actually finishes evaluating and can be executed as a tail recursive loop, no laziness necessary."
haskell,36ysso,gelisam,1 point,Sun May 24 08:25:37 2015 UTC,"I don't find any need for the lazy evaluation of do x; error "":("", because it seems like a senseless use case above all. In all other cases (which don't involve the bottom value) the execution order of the arguments of (>>) preserves, since it operates on monads, i.e. the wrapped values.   As for (>>), I've seen people using it as a counterargument before, but I believe it's contrived and stems from a misunderstanding. The misunderstanding is: strictly evaluating a value of the type IO Int is not the same thing as execution of that action. It merely provides you an ""unthunked"" action, but it's still not executed.  So I don't see any problem with strict (>>). (Pinging /u/Taladar)"
haskell,36ysso,chrisdoner,1 point,Sun May 24 05:09:20 2015 UTC,"it'd be trivial to solve, if Haskell were strict:   do x; return (error "":("")   That doesn't solve the problem!"
haskell,36ysso,tibbe,1 point,Sun May 24 06:22:30 2015 UTC,Thanks! My mistake. I've removed that so that it won't spoil my general argument.
haskell,36ysso,Oremorj,4,Sun May 24 06:33:33 2015 UTC,I would love to see that in an actual language   Ocaml has a Lazy type constructor but they don't have monads so it's probably rather hard to work with.  http://caml.inria.fr/pub/docs/manual-ocaml/libref/Lazy.html
haskell,36ysso,tomejaguar,7,Sat May 23 11:37:48 2015 UTC,"While the idea of strictness-polymorphic datatypes is not new, it's the first time I see it expressed with such a nice API, as a monad transformer.  I believe it should be possible to obtain the same nice API in ordinary Haskell:  -- Note that this cannot be a newtype or the !(m a) below will collapse to !a -- and we will be strict instead of lazy. data Lazy a = Lazy { runLazy :: a } data Strict a = Strict { runStrict :: !a }  data ListT m a   = Cons !(m a) !(m (ListT m a))   | Nil  type Stream a = ListT Lazy a type List a = ListT Strict a   Full implementation here. It's much easier to reason about implementing laziness in a strict language than the other way around, so it's quite possible that I made a fatal mistake somewhere in there. At the very least, for my test computation (the monadic equivalent of fmap (+1) [1..4]), traces show that the strict version evaluates the entire list before mapping any of its elements, while the lazy version alternates between creating the next element of the input list and mapping one of its elements."
haskell,36ysso,Oremorj,2,Sat May 23 13:46:24 2015 UTC,"Tom has actually already referred here to the post you mention. And I thought about the same thing as you, but then I read the ""Wadler’s “strictness monad”"" section of his post."
haskell,36ysso,ZachSully,2,Sat May 23 14:09:50 2015 UTC,"Re-reading Tom's article after reading yours, that section caught my attention as well. I don't know which combinations Tom tried at the time (my contribution to his article was limited to the datatypes part), but here's one combination which seems to work just fine:  foldlM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a foldlM _ x [] = return x foldlM f x (y:ys) = do     x' <- f x y     foldlM f x' ys  f x y = return (x + y)   Tracing runLazy (foldlM f 0 [1..4]) and runStrict (foldlM f 0 [1..4]) in ghci, I can see that x' is still a thunk during the recursive call in the lazy case, but is already evaluated to 1 in the strict case."
haskell,36ysso,sgraf812,2,Sat May 23 15:10:24 2015 UTC,"What we're after is a way of indicating, in the type of a function like a -> b -> c -> r, which of a, b and c are evaluated strictly and which lazily.  How do you do that with Strict and Lazy?  I agree that ListT Strict and ListT Lazy are strict and lazy lists respectively, but I think that's a red herring.  It may well be that the type signature of the foldM above forces strict or lazy behaviour depending on m but that seems like a coincidence, not a general principle.  After all, the a parameter is the one that we want to ensure is taken strictly, but that parameter has no direct mention of Strict or m at all!"
haskell,36ysso,NNOTM,2,Sun May 24 09:34:27 2015 UTC,"What we're after is a way of indicating, in the type of a function like a -> b -> c -> r, which of a, b and c are evaluated strictly and which lazily.   I see! I thought the goal was to have a single implementation whose behaviour could be switched from that of foldl to that of foldl' only by changing the type signature.  So, just to make sure I really understand what you want this time, let's me rephrase it in my own words:   You already know which argument you want to seqor add a bang pattern on, you just want to advertise which ones at the type level. And it would be even better if the types made sure you did not forget to add the seq. And it would be even better if changing the type signature decided whether the seq would happen or not.   The solution you gave in your article already solves all three: (1) the arguments which will be forced are the ones immediately before a :->, (2) it's not possible to construct a value of type a :-> b which doesn't force its argument, and (3) using the FunctionLike typeclass, it's possible to write functions which can be instantiated to either -> or :->.  Since the goals of a strictness monad are very different (mx >>= f will force mx before evaluating the rest of the computation even if f ignores its argument), no wonder you found it inadequate. If you want the arguments to be forced before the recursive call, then there should be a >>= between those two:  -- behaves like foldl' when m ~ Strict and like foldl when m ~ Lazy foldlM :: Monad m => (a -> b -> a) -> m a -> [b] -> m a foldlM f mx [] = mx foldlM f mx (y:ys) = do     x <- mx     foldlM f (return (f x y)) ys   But nothing in the type system is forcing you to do so, which is why you were able to construct your counter-example in which you lazily build a bigger mx instead of evaluating the one you received as an argument first.  Come to think of it, even :-> relies on such a convention: strictly (\x -> ...) will force x before evaluating the body, so if we want the arguments to be forced before the recursive call, that recursive call better be inside this body. Let's see if I can construct a counter-example:  instance Functor ((:->) a) where     fmap f g = strictly (\x -> f (g ! x))  foldl' :: (a -> b -> a) -> [b] -> a :-> a foldl' f [] = strictly id foldl' f (y:ys) = fmap (\z -> f z y) (foldl' f ys)   I had to swap the order of the a and [b] arguments, but I did manage to break the contract which :-> was supposed to offer: even though the a is to the left of a :->, stepping into ghci indicates that z is still a thunk.  In conclusion, it seems less and less likely that any technique would be able to enforce (2), so we'll have to ask our users to follow some coding convention such as ""always put the recursive call inside strictly"" or ""always execute the monadic computations of the arguments before executing the recursive call"". And if we're going to allow such coding conventions, then we might as well say ""always use a bang pattern on arguments of type Strict a"":  foldl' :: (a -> b -> a) -> Strict a -> [b] -> a foldl' f !z [] = runStrict z foldl' f !z (y:ys) = foldl' f (fmap f' z) ys   where     f' z' = f z' y   Or, since pattern-matching on Strict z will have the same effect, we might say ""always pattern-match on the Strict constructor, no pointfree style allowed"":  foldl' :: (a -> b -> a) -> Strict a -> [b] -> a foldl' f (Strict z) [] = z foldl' f (Strict z) (y:ys) = foldl' f (Strict (f z y)) ys   I like how readable this solution is."
haskell,36ysso,sgraf812,1 point,Sun May 24 15:13:43 2015 UTC,"It seems to me that in your counter-example, z remains a thunk until all of the [b] has been consumed and a large function of type a :-> b has been constructed in its place.  At that point the z is forced.  Do you agree with the reasoning?  This is an interesting observation about currying.  In a function of the form a -> b :-> r the b is indeed taken strictly but the b :-> r can itself be arbitrarily large."
haskell,36ysso,so_just,1 point,Mon May 25 05:46:14 2015 UTC,"It seems to me that in your counter-example, z remains a thunk until all of the [b] has been consumed and a large function of type a :-> b has been constructed in its place. At that point the z is forced. Do you agree with the reasoning?   Yes, that's what I was going for. Although now that I'm taking a closer look, I can see that it's not what actually happens! I made several mistakes.  First, there is a bug in my implementation: I'm applying the function to the elements of the list in reverse order. For this reason, when I reach f z y in ghci, it's normal that z is a thunk because it represents the result for the part of the list which hasn't been processed yet, not the partial result we have accumulated so far. Here is a fixed implementation.  wrap :: ((a -> b) -> (a' -> b'))      -> (a :-> b) -> (a' :-> b') wrap f g = strictly (\x -> f (g !) x)  foldl' :: (a -> b -> a) -> [b] -> a :-> a foldl' f [] = strictly id foldl' f (y:ys) = wrap (\cc z -> cc (f z y)) (foldl' f ys)   Second, using ghci to step until f z y is reached and checking whether z is a thunk or not is not a good way to verify whether the implementation is accumulating thunks or not. It is not in z which the thunks will be accumulating, but in the a :-> a result! A proper counter-example would first accumulate a bunch of thunks describing an a :-> a value, then the thunks would be forced in order to yield a large function of type a :-> a, and finally this function would be applied to the original z. This would of course force z, and then proceed with the large body of the function, in which f z y would eventually be reached. At that point, z is clearly not a thunk anymore, but we still had a space leak.  Third, neither my buggy nor my fixed implementation even succeeds at being a proper counter-example, because in both cases, the original z argument gets forced at the very beginning, before the tail of the list gets examined. Here's what happens with the buggy implementation for example:  foldl' (+) [1..4] !(trace ""z is evaluated"" 0) ==> fmap (\z -> f z y) (foldl' f ys) !(trace ""z is evaluated"" 0)   where     f = (+)     y = 1     ys = [2..4] ==> strictly (\x -> f (g ! x)) !(trace ""z is evaluated"" 0)   where     f z = f1 z y1     g = foldl' f1 ys1     f1 = (+)     y1 = 1     ys1 = [2..4] ==> Strict (\a -> a `seq` f a) !(trace ""z is evaluated"" 0)   where     f x = f1 (g1 ! x)     f1 z = f2 z y2     g1 = foldl' f2 ys2     f2 = (+)     y2 = 1     ys2 = [2..4] ==> f (trace ""z is evaluated"" 0)   where     f a = a `seq` f1 a     f1 x = f2 (g2 ! x)     f2 z = f3 z y3     g2 = foldl' f3 ys3     f3 = (+)     y3 = 1     ys3 = [2..4] ==> z is evaluated ==> f 0   where     ...   In order to produce a proper counter-example, I must explicitly request the recursive call to be forced before fmap or wrap can return a computation of a form which (!) can understand.  foldl' :: (a -> b -> a) -> [b] -> a :-> a foldl' f [] = strictly id foldl' f (y:ys) = r `seq` wrap (\cc z -> cc (f z y)) r   where     r = foldl' f ys   All right, now that we have a proper counter-example, we can talk about it :) Let's try again:   It seems to me that in your counter-example, z remains a thunk until all of the [b] has been consumed and a large function of type a :-> b has been constructed in its place. At that point the z is forced. Do you agree with the reasoning?   Yes, that's what my new counter-example is achieving. It's similar to your own counter-example about Wadler’s strictness monad, in which z remains a thunk of type Str a until all of the [b] has been consumed and a large computation of type Str a has been constructed in its place. At that point the computation is executed, forcing z. Of course, your counter-example is expressed in a natural style, while mine is hopelessly contrived, so :-> seems much better than the strictness monad at enforcing correct implementations."
haskell,36ysso,MarkZander0,4,Mon May 25 11:57:46 2015 UTC,Here's how laziness works in Idris: http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html?highlight=laziness#laziness
haskell,36ysso,Kaidelong,3,Sat May 23 18:55:53 2015 UTC,"We could have ~ to mark things as lazy, just like ! works today."
haskell,374nlf,srbufi,7,Sun May 24 21:04:23 2015 UTC,I think Haskell sounds cool.
haskell,374nlf,kohji,3,Sun May 24 21:45:17 2015 UTC,"Yeah, I like it. Also you can joke 'join Haskell Church'"
haskell,374nlf,deadmaya,7,Mon May 25 09:55:07 2015 UTC,"According to Ancestry.com:   English: from the Norman personal name Aschetil, from Old Norse Ásketill, Áskell, a compound áss ‘god’ + ketill ‘kettle’, ‘helmet’.   Well, there you go. Let's rename the language to ""godhelmet."""
haskell,374nlf,tejon,5,Sun May 24 23:55:36 2015 UTC,That even sound like Haskell characteristics.
haskell,374nlf,Vektorweg,6,Mon May 25 02:31:25 2015 UTC,Should have called it Curry instead.  Everyone loves curry!
haskell,374nlf,briennetarth,2,Sun May 24 21:38:23 2015 UTC,Curry didn't even invent currying. We should go for Schönfinkel.
haskell,374nlf,vincentrevelations,6,Wed May 27 13:24:17 2015 UTC,"I keep getting....  ""Pascal?  Why would you want to program that in Pascal?"""
haskell,374nlf,jamshidh,3,Sun May 24 21:51:20 2015 UTC,"I used to get that response a lot 7 years ago, but I get it a lot less now."
haskell,374nlf,edwardkmett,5,Sun May 24 23:39:29 2015 UTC,"From the History of Haskell:   Hudak and Wise were asked to write to Curry’s widow, Virginia Curry, to ask if she would mind our naming the language after her husband. Hudak later visited Mrs. Curry at her home and listened to stories about people who had stayed there (such as Church and Kleene). Mrs. Curry came to his talk (which was about Haskell, of course) at Penn State, and although she didn’t understand a word of what he was saying, she was very gracious. Her parting remark was “You know, Haskell actually never liked the name Haskell.”"
haskell,374nlf,Regimardyl,6,Sun May 24 23:24:05 2015 UTC,"I think what negatively affects its popularity is the lack of a compelling, widely acclaimed useful project written in it. You know, like xmonad but bigger and more compelling. Instead, people are using Haskell to write web apps, which sets the bar at the level of ""like Ruby on Rails or Node.js but you have to learn all those preprozygohistomorphisms to use it""."
haskell,374nlf,SkoomaMudcrab,2,Mon May 25 19:28:59 2015 UTC,More than likely this is the real reason.
haskell,36y9jc,tonyday567,6,Sat May 23 03:12:24 2015 UTC,"Search for sum types in wikipedia and you’re actually redirected to tagged union! Why the blind spot?   Blind spot? Sum types in Haskell are tagged unions. The constructor is the tag. For types with more than one constructor, there is an actual runtime tag so that if you have an Either Int Int you can tell the difference between Left 3 and Right 3."
haskell,36y9jc,drb226,4,Sat May 23 10:07:30 2015 UTC,"Aren't tagged unions just an implementation detail of sum types, though? They don't have to be implemented as tagged unions."
haskell,36y9jc,twistier,3,Sat May 23 15:04:33 2015 UTC,"Proof by lack of imagination: no other way of implementing them comes to mind.  It doesn't have to be the particular memory layout that the Wikipedia article describes to be a ""tagged union"" in my mind... but it usually is just because it's the sensible and obvious thing to do."
haskell,36y9jc,drb226,7,Sat May 23 19:59:34 2015 UTC,A couple alternatives:   Church/Scott encoding struct of nullable fields (only one is non-null)
haskell,36y9jc,twistier,2,Sat May 23 21:25:06 2015 UTC,"type Either a b = forall r. (a -> r) -> (b -> r) -> r  either :: (a -> r) -> (b -> r) -> Either a b -> r either f g e = e f g  left :: a -> Either a b left a f _ = f a  right :: b -> Either a b right b _ g = g b   Okay, I can see how this isn't necessarily a ""tagged union"". I could also try to argue that it is a tagged union where the ""tag"" can be calculated via:  eitherTag :: Either a b -> String eitherTag = either (const ""left"") (const ""right"")   I have to adopt some rather abstract definitions for ""tag"" and ""union"" to have that view make sense, though. Note that eitherTag works regardless of implementation, as long as the either combinator does the right thing.  -- imaginary Nullable syntax data Either a b = Either (Nullable a) (Nullable b)  either f g (Either a b) = if isNull b   then f a   else g b"
haskell,36y9jc,drb226,2,Sat May 23 21:47:07 2015 UTC,"Perhaps the poster is thinking of union types, which I have seen used to refer to untagged unions: e.g. Int :+: Bool ≠ Bool :+: Int, but Int :∪: Bool = Bool :∪: Int; and Int :+: Int ≠ Int, but Int :∪: Int = Int."
haskell,36y9jc,rpglover64,3,Sat May 23 11:55:37 2015 UTC,Tangent:  (A :+: B) <=> (B :+: A)   They may not be equal but they are equivalent; it's trivial to write the isomorphism:  swap :: Either l r -> Either r l
haskell,36y9jc,drb226,4,Sat May 23 20:26:30 2015 UTC,"It gets even better when you add the fact that pipes-concurrency and the mvc package itself are available. There my take on it:  https://github.com/boothead/ohm-examples/tree/master/todo-mvc  Using oHm (some explanation in the readme) https://github.com/boothead/oHm  edit clearly I didn't look long enough, as I see you're also using mvc :-)"
haskell,36y9jc,b00thead,3,Sat May 23 07:35:20 2015 UTC,I hadn't seen your take on this b. Very nice! I'm glad I didn't cause I wouldn't have gone through the exercise.  Have you proceeded with trying to get it into the bigger todoMVC repo?
haskell,36y9jc,b00thead,1 point,Sat May 23 08:25:57 2015 UTC,"Not yet, if I get time to implement the latest version I will though :-)"
haskell,36y9jc,agocorona,5,Sat May 23 08:38:57 2015 UTC,"With less literature but more concise and understandable, is this implementation using the Haste compiler and the hplayground EDSL, that is the shortest implementation of the full todo app probably in any language. It is in a single haskell file (except the CSS)  http://tryplayg.herokuapp.com/try/todo.hs/edit  And it is more concise and arguably more understandable because it it does NOT use an MVC model."
haskell,36y9jc,b00thead,3,Sat May 23 14:29:17 2015 UTC,"Also meant to ask, what part of this do you call the algebra?"
haskell,36y9jc,pigworker,3,Sat May 23 08:39:52 2015 UTC,Good question and the short answer is I'm confused about the term right now.  Action is an ADT and Todo is an ADT - they're both algebraic.  And apply is a mapping between these (algebras) rather than an algebra itself.  Though it sure felt like I was doing algebra when I wrote it - working out which functions from lens to apply. I'm probably the wrong person to ask.
haskell,36y9jc,hiptobecubic,19,Sat May 23 09:17:23 2015 UTC,"You get away with the useless acronym ""ADT"" as you've clearly stated you mean ""algebraic"" rather than ""abstract"".  Meanwhile, an algebra is a collection of operations which combine values to produce other values. Algebra is a posh way of saying ""construction kit"". The type of values an algebra combines and produces is called the carrier of the algebra. The collection of operations and specification of their arities is called the signature of the algebra. An algebraic datatype is a type whose values are generated by an algebra (the constructors): the datatype itself is the carrier. When we're being formal about it, we specify the signature of an algebra by some Functor sig, usually with a sum type at its outside, and the algebra itself as a function of type sig carrier -> carrier. The generic algebraic datatype is given by such a functor's fixpoint.  newtype Fix sig = In (sig (Fix sig))   so that the constructor  In :: sig (Fix sig) -> Fix sig   is a sig-algebra with carrier Fix sig.  The standard method of (recursively) processing data in algebraic datatypes is to give an algebra with the same signature as the data, but the stuff you want to compute as carrier. Hence the type of foldr:  foldr :: (a -> c -> c)  -- how to do cons for c       -> c              -- how to do nil for c       -> [a] -> c   So, when you write apply, you very probably are giving an algebra, with the same signature as Action a but the carrier Todos a -> Todos a, signifying some sort of update. You explain how to make updates which correspond to each way of making an action, and that allows the interpretation of actions as updates."
haskell,36y9jc,wbaig,5,Sat May 23 11:06:29 2015 UTC,What a great post. Thanks for concretizing these terms for those of us who are not studying type theory day to day
haskell,36y9jc,jP_wanN,4,Sat May 23 15:59:43 2015 UTC,Can you please write a blogpost about this?
haskell,36xau0,Categoria,5,Fri May 22 21:56:22 2015 UTC,I can't wait to try it out tomorrow when OpenGL is done building.
haskell,36usu8,sibip,3,Fri May 22 08:17:15 2015 UTC,"Amazing to me how much some people get done. Damn, snoyberg showed up for work on May 14th."
haskell,36usu8,rdfox,7,Fri May 22 23:01:08 2015 UTC,"on beta.stackage.org one thing caught my eye   A tested package set is the best solution to dependency resolution issues (a.k.a. Cabal Hell).    This sounds like a bold proposition to me, or can we actually prove there is no better solution possible (and that all other solutions are worse)?"
haskell,36usu8,RedLambda,7,Fri May 22 13:19:25 2015 UTC,"Well, the Stackage process obligates the package authors to fix build errors as quickly as possible. It provides a forum for curating the stackage set of packages and if you pin your dependencies to a Stackage LTS, for example, it mostly does solve the Cabal Hell problem. In my view, it currently is the best solution to the problem there is. Nobody claims it's the best solution ever and nothing better is possible in the future.   Also, when you have to choose between two alternative packages, you'll probably choose the one that is on Stackage because it comes with some declared commitment of the maintainers over the one that is not there."
haskell,36usu8,mallai,-2,Fri May 22 14:41:01 2015 UTC,"the Stackage process obligates the package authors to fix build errors as quickly as possible.   Do you really mean build errors or rather cabal failures?   if you pin your dependencies to a Stackage LTS, for example, it mostly does solve the Cabal Hell problem   Why does it only ""mostly"" solve the problem, what's missing? Moreover (unless you develop a package not intended for public release) you'd still need to maintain proper version bounds on your build-deps despite locally freezing to stackage versions, as otherwise your package would only be usable for stackage users and effectively sidestep the PVP, wouldn't it? Otoh, if you have proper upper bounds, you don't really need Stackage anymore (except if you want the additional testing that stackage-approved versions come with -- but that's besides addressing the cabal-hell problem), as Hackage is being curated as well by trustees. But I'm still wondering about  the relative merits of  stackage curation vs hackage curation...   Nobody claims it's the best solution ever and nothing better is possible in the future.    I beg to differ, as the current wording on beta.stackage.org does indeed make that very claim..."
haskell,36usu8,RedLambda,6,Fri May 22 19:41:18 2015 UTC,"The right wording might have been: ""the best solution so far"""
haskell,36usu8,yogsototh,6,Fri May 22 20:00:31 2015 UTC,"Specifying cabal bounds is just a poor man's substitute for proper API compatibility checking. Tibbe already proposed a GSoC project about that. It would certainly help enforcing the PVP. There's work on Backpack, which looks promising. So, yes these things, in combination with Stackage will help even more with the problem. There's no single solution, just a combination of things."
haskell,36usu8,mallai,3,Fri May 22 23:37:46 2015 UTC,"Stuff like Backpack/proper API compatibility checking sounds exciting, but wouldn't that make Stackage superfluous? What would Stackage be needed for if we had the tooling to find compatible packages based on their APIs rather than error-prone manually written version bounds? IMO, Stackage is the poor man's substitute for something like Backpack..."
haskell,36usu8,RedLambda,-1,Sat May 23 17:04:43 2015 UTC,Long Live Stackage!
haskell,36v572,ocramz,7,Fri May 22 11:12:06 2015 UTC,To start with. If you would like to hide memory management you should be using ForeignPtrs instead of raw pointers. When it comes to making sure that the library is initialised before using it you could have the initialisation function return a value of a token datatype that needs to be passed to the other functions. E.g  init :: IO MyToken  doStuff :: MyToken -> IO ()   that way you can make it impossible to call those functions without initialising the library
haskell,36v572,dnaq,4,Fri May 22 16:23:35 2015 UTC,*almost impossible  doStuff undefined
haskell,36v572,procllort,5,Fri May 22 19:54:57 2015 UTC,Probably a good idea to force evaluation of the MyToken argument so that the worst that happens is you get an exception (instead of segfaulting or whatever).
haskell,36v572,Fylwind,3,Fri May 22 20:07:43 2015 UTC,"That's a good refinement of the idea.  I actually wrote bindings to a c-library a while ago where the library (as many other c-libraries) was designed so that some functions had to be called before other functions (or it would crash).  e.g.  to call do_stuff1(ctx *c) you had to make sure to call set_stuff1(ctx *c, stuff) and set_stuff2(ctx *c, stuff) beforehand, but to call do_stuff2(ctx *c) you had to call set_stuff1(ctx *c, stuff) and set_stuff3(ctx *c).  I solved that by having a token type that contained a type-level list with tokens for the different ""capabilities"" so that we had:  setStuff1 :: Ctx caps -> IO (Ctx (CapStuff1 .: caps)) setStuff2 :: Ctx caps -> IO (Ctx (CapStuff2 .: caps)) doStuff1 :: (In CapStuff1 caps) => Ctx caps -> IO () doStuff2 :: (In CapStuff2 caps) => Ctx caps -> IO () doStuff3 :: (In CapStuff1 caps, In CapStuff2 caps) => Ctx caps -> IO ()   where In was the type-level list membership type function."
haskell,36v572,dnaq,1 point,Fri May 22 20:42:39 2015 UTC,"Thank you for the reply /u/dnaq/ ; this sounds quite interesting, any chance (part of) this project is available somewhere?"
haskell,36v572,bss03,4,Mon May 25 07:47:28 2015 UTC,"please, wizards from far away lands, help me in my quest for enlightenment. Do I need MVars? TMVars? STM? And why? My concern is not to introduce multithreading at the Haskell layer, but to preserve precedence, hide memory management details and composing control."
haskell,36tjca,agumonkey,8,Fri May 22 00:19:18 2015 UTC,Sounds like a good use case for the enclosed-exceptions package.
haskell,36tjca,Faucelme,6,Fri May 22 06:35:16 2015 UTC,"There are reports that if the user hits Ctrl-C twice the runtime will abort the program. In my tests, that seems to be a feature of the shell rather than GHC itself - in the Windows Command Prompt no amount of Ctrl-C stops an errant program, in Cygwin a single Ctrl-C works.   Check out this thread on Haskell-Cafe, and this commentary on GHC Trac:   If a second interrupt signal is received, then we terminate the process immediately; this is just in case the normal shutdown procedure failed or hung for some reason, the user is always able to stop the process with two control-C keystrokes."
haskell,36tjca,alexvieth,5,Fri May 22 04:42:29 2015 UTC,"Just as a rule, I use enclosed-exception's catchAny to catch exceptions.  I also recommend using slave-thread's fork to fork instead of forkIO as a rule."
haskell,36tjca,k-bx,3,Fri May 22 07:16:30 2015 UTC,I am a big fan of the slave-thread stuff - it seems a much better default than forkIO.
haskell,36tjca,ndmitchell,3,Fri May 22 08:17:56 2015 UTC,"Did you use it in production? At the first glance the implementation doesn't look exception-safe. E.g. the parent thread can be interrupted if registration (atomically $ Multimap.insert ...) blocks, then the child will wait for registrationGate forever. Though I may miss something."
haskell,36tjca,Yuras,1 point,Fri May 22 12:50:04 2015 UTC,"I have never used it in production or in fact anything beyond a quick test. I am a fan of the design, but have no opinion on the implementation."
haskell,36tjca,ndmitchell,3,Fri May 22 13:16:54 2015 UTC,"I like its semantics too. Also there is other interesting approach: https://github.com/adinapoli/threads-supervisor  Unfortunately correct implementation is hard, so I'm still looking for better alternatives. I tried async, but is has drawbacks too. Right now I have my own set of primitives (based on io-region package), but I'd like to replace them in production with something widely used."
haskell,36tjca,Yuras,2,Fri May 22 13:32:56 2015 UTC,What would you say are the drawbacks of async?
haskell,36tjca,Faucelme,3,Fri May 22 15:10:59 2015 UTC,"The main one is that cancel and wait are interruptible, so withAsync, race and other combinators doesn't guarantee that the child thread will be killed.  If child thread will exit eventually on itself, then it is probably not an issue, but I don't recomend async package for managing long living threads.  It is interesting that cancel can throw even under uninterruptibleMask if a thread tries to cancel itself, that makes a lot of functions in the package not exception-safe. Though it is not an issue in practice, just don't try to cancel a thread from itself."
haskell,36tjca,Yuras,2,Fri May 22 16:19:37 2015 UTC,"Yes, I should really fix that."
haskell,36tjca,simonmar,2,Fri May 22 19:08:12 2015 UTC,"That would be really good. Note that there is an issue already about that on github.  But what do you think about the ""double throw"" issue discussed in other thread? ( http://www.reddit.com/r/haskell/comments/36tjca/neil_mitchells_haskell_blog_handling_controlc_in/crhc9pu ) Do you consider it as a bug in asyn exceptions semantics? Can we fix it?"
haskell,36tjca,Yuras,2,Fri May 22 21:23:32 2015 UTC,"Yes, I saw the github issue.  Double-throw is an instance of ""there was an error in the error handler, what do we do?"".  It's a hard problem in general.  It's no worse for async exceptions, provided you stay within the automatic mask that you get in an exception handler and don't use any interruptible operations (or use uninterruptibleMask).  So we can handle async exceptions without losing them provided we're careful.  For sync exceptions you have to program carefully in the handler and don't throw any exceptions.  Sometimes that's easier said than done."
haskell,36tjca,simonmar,1 point,Sat May 23 06:25:56 2015 UTC,I use it in production a lot. Works great. But didn't thought on the case you're describing here.
haskell,36tjca,k-bx,1 point,Sat May 23 08:35:46 2015 UTC,"I wish Happstack used something like this. As it is, it seems like the whole server persists as a ghost thread in GHCi and you have to :quit and relaunch instead of just :reload to try a new version. It's mostly just a minor annoyance for me at this point, but I could see it becoming quite a hindrance in the future."
haskell,36tjca,WarDaft,7,Mon May 25 20:37:39 2015 UTC,"doesn't document its exceptions   This is horrible.   Finally, we can catch only the relevant exceptions   I think this is the ""correct solution."" In an ideal world, everything is documented with the sorts of exceptions it might throw. If this could be tracked by the type system, even better."
haskell,36tjca,drb226,5,Fri May 22 09:23:48 2015 UTC,"There are more ways to incidentally lose exception. For example, if release action in bracket throws an exception (sync or async) while handling UserInterrupt, then the later will be swallowed.  Also if the release action can block, then the computation may hang for unlimited amount of time. It will unblock eventually, but from user's point of view it is the same as losing UserInterrupt if it takes more then a second.  That makes async exceptions not composible. Try to nest two timeout of combine timeout with Ctrl-C, and you are vulnerable to exception swallowing. Fixing that is possible, but requires support from RTS."
haskell,36tjca,Yuras,3,Fri May 22 11:52:18 2015 UTC,"Wow, didn't think of that. Yeah, that seems very tricky!"
haskell,36tjca,ndmitchell,2,Fri May 22 15:17:43 2015 UTC,"I don't think it's limited to async exceptions per se. Normal exceptions have the same problem -- you can experience exactly the same problems when a ""release"" fails during nested exception handling.  Exceptions (as done currently, at least) are just generally a bad idea. I'm of the opinion that they should only be used in the ""cannot go on doing anything meaningful"" scenario. (And even then it might be simpler to just abort the program completely.) This would be the sort of ""fail-fast"" approach."
haskell,36tjca,Oremorj,3,Fri May 22 15:46:22 2015 UTC,"I don't think it's limited to async exceptions per se.   Right. I call it ""double throw issue"" -- you have two exceptions thrown, but you can rethrow only one of them.  It is easy to produce double throw issue without async exceptions, I even think that handling async exceptions is not so different from handling sync exceptions. But the solution for double throw issue is trivial in case of sync exceptions -- swallow the last one (bracket does the opposite). In case of async exceptions it doesn't work. More details here: http://blog.haskell-exists.com/yuras/posts/handling-async-exceptions-in-haskell-pushing-bracket-to-the-limits.html   Exceptions (as done currently, at least) are just generally a bad idea.   I don't believe there is an alternative to exceptions. It is possible to fix exceptions in Haskell, though I'm not sure the community is interested in that."
haskell,36tjca,Yuras,1 point,Fri May 22 16:32:29 2015 UTC,"Oh, right, sorry, I was too caught up with the whole async thing that I missed the fact that you explicitly mentioned both! :)  Btw, do you recall/know if the non-masking behavior of bracket's release was fixed? (As I think was the consensus on the mailing list at the time.)"
haskell,36tjca,Oremorj,1 point,Fri May 22 21:32:42 2015 UTC,"No, AFAIK it was not implemented. (I was against it btw.)"
haskell,36tjca,Yuras,1 point,Fri May 22 21:39:23 2015 UTC,"Shame. (But this is not ""the time to bicker and argue about who killed who"".)"
haskell,36tjca,Oremorj,2,Fri May 22 21:45:13 2015 UTC,"(Posting a new reply thread because it might be a tangent...)  Java has an interesting answer to the ""raising-an-exception-during-exception-handling"" issue: Every exception (which must be derived from java.lang.Exception) has a list of suppressed exceptions which is initially empty. If an exception is thrown in a ""finally"" clause[1], that exception is added to the ""suppressed exceptions"" list and the original exception is re-thrown.  In practice this seems sufficient and relatively sane given the non-composability of exceptions+cleanup in general.  [1] EDIT: Actually, that's not true. It's ""in the cleanup phase of a try-with-resources"", but that's getting a bit too Java-centric. Still, I hope the point gets across."
haskell,36tjca,Oremorj,5,Fri May 22 21:39:20 2015 UTC,"A few comments:  This is exactly why we recommend not catching SomeException.  Maybe the documentation needs to be extended to explain more about what can go wrong in the context of async exceptions.  We've explored various ways to separate sync and async exceptions, it's unfortunately not easy. see e.g. https://ghc.haskell.org/trac/ghc/ticket/5902  The reason that a second ^C kills the process on Linux only is because the SIGINT handler is one-shot; the second ^C causes an unhandled SIGINT, which kills the process.  This is so that we can still ^C processes that get wedged (which does happen from time to time).  On Windows we're using the console handlers and not signals, so everything works differently.  The async package can be used to run something on a separate thread:  ctrlC io = withAsync io wait   should do what you want.  StackOverflow exceptions are disabled inside mask, because otherwise it would violate the assumption that async exceptions don't occur inside mask, which could break your stateful code and leave things in a mess.  So we have no alternative but to let the stack grow."
haskell,36tjca,simonmar,3,Fri May 22 18:49:43 2015 UTC,I have a utility (originally from Tekmo's errors package) http://hackage.haskell.org/package/unexceptionalio-0.2.0/docs/UnexceptionalIO.html#g:2 that will rethrow exceptions that should not be caught.
haskell,36tjca,singpolyma,2,Fri May 22 11:41:34 2015 UTC,"Does it works for timeout? IIRC it doesn't expose the exception type used to abort a computation, so you can't handle it specifically."
haskell,36tjca,Yuras,1 point,Fri May 22 12:04:23 2015 UTC,"throwTo is a bad idea, and should be excised from GHC, both for ThreadKilled and UserInterrupt.  On UNIX-like platforms, you can install your own SIGINT handler if you want.  I don't know how you are supposed to deal with Ctrl+C on MS Windows.  That leaves StackOverflow...  Can we not trade stack space for heap space and never run out of either until we are out of both?  Then, have any expression that allocates memory live in the a Mem monad -- which is basically Maybe, but if done in IO throws a non-aysnc OutOfMemory exception?  Then we could get rid of async exceptions in GHC / Haskell for good?  I can dream can't I? :)"
haskell,36tjca,bss03,5,Fri May 22 01:42:40 2015 UTC,"How would one kill a thread, then? This is critical for e.g. async's ""race"" function.  (I actually would like to get rid of async exceptions too for normal code, but if we're going to, then we need an answer for all the use cases.)"
haskell,36tjca,Oremorj,2,Fri May 22 06:12:42 2015 UTC,"You don't at least not asynchronously.  Instead, you arrange a communication method with the thread and that thread checks the communication channel frequently."
haskell,36tjca,bss03,2,Fri May 22 15:04:57 2015 UTC,"Given how pervasive shared mutable state is in Java and C/C++ (the examples you provided), it's certainly not a bad idea to avoid killing threads there.  However, that doesn't mean that people don't want to do it and that it might, in fact, be perfectly safe to do so under many circumstances. (Esp. in Haskell.)  So some sort of generic/composable mechanism must be provided (and coded up once in a library, preferably).   Instead, you arrange a communication method with the thread and that thread checks the communication channel frequently.   Let me try a different tack to see if that gets my point across better: How would do you this such that e.g. ""race"" can be implemented in a completely generic way?"
haskell,36tjca,Oremorj,1 point,Fri May 22 15:40:53 2015 UTC,"How would do you this such that e.g. ""race"" can be implemented in a completely generic way?   I don't believe that can be made safe, nor do I think it is a good goal.  With little loss of generality, you can use a Step/Done monad for your process and check for an early termination signal between Steps."
haskell,36tjca,bss03,1 point,Fri May 22 19:26:30 2015 UTC,"It seems to me that that just amounts to saying ""don't do that"" in the face of a lot evidence that people want to ""do that"". It's not going to work.  For example, STM can make thread-canceling completly safe, so there's at least some subset of valuable computation that should support cancel-thread like functionality."
haskell,36tjca,Oremorj,2,Fri May 22 21:29:27 2015 UTC,"""don't do that"" in the face of a lot evidence that people want to ""do that""   You mean like ""that"" = ""use dynamic or weak types""?  There's plenty of good reasons to say ""don't do that"" even when the masses or industry leaders are saying they want ""do that"".  Safety is one of them.  Asynchronous exceptions are massively unsafe, much more so than recursive mutexes.  As the very least, async exceptions should be masked by default and you should have to explicitly unmask them.  But, that's roughly equivalent to using a communication protocol to poll for them."
haskell,36tjca,bss03,3,Fri May 22 22:14:56 2015 UTC,"You mean like ""that"" = ""use dynamic or weak types""?   No, I mean ""have a reliable and sane way to stop threads that are not actively malicious"".  ... in a generic and composable way. I don't have any answers, I just think we should try to think extra-hard about these things.   As the very least, async exceptions should be masked by default and you should have to explicitly unmask them. But, that's roughly equivalent to using a communication protocol to poll for them.   I think I agree, but it'd mostly be by changing the regular ""catch"" to only catch non-asynchronously-thrown[1] exceptions and having a special function if you really really want all of the exceptions (sync and async included).  [1] Asynchrony is not a property of the type of the exception, contrary to popular opinion, but a runtime property. As such this flagging must be supported by the runtime."
haskell,36tjca,Oremorj,3,Fri May 22 23:11:37 2015 UTC,"any expression that allocates memory live in the a Mem monad   This change would break pretty much every piece of Haskell code ever written to date. I'm not saying it's a bad choice for some arbitrary new language, it's just hugely unlikely to land in Haskell due to backwards compatibility concerns."
haskell,36tjca,drb226,2,Fri May 22 09:19:20 2015 UTC,"Yeah, I know. :(  I am open to other solutions, including simply not being able to recover from stack / heap / memory exhaustion.  (I'm comfortable restarting daemons automatically.)  I think async exceptions are a wart.  That said, if you want programmable recovery but you don't want to document that you allocate memory (which can fail) in the type (i.e. pure code can allocate), I think you basically have to have something very close to async exceptions."
haskell,36tjca,bss03,3,Fri May 22 15:15:07 2015 UTC,You don't have to be able to catch StackOverflow or OutOfMemory - you can just say they kill the process. That's what OutOfMemory does now anyway.
haskell,36tjca,ndmitchell,3,Fri May 22 09:36:36 2015 UTC,"The new allocation limit feature in GHC 7.10 causes an async exception to be thrown when a thread has allocated too much memory (not the same as a memory limit, it's more like a time limit).  This really must be an exception, so that you can catch it and report it and not kill the entire process.  The system I work on hits these on a regular basis.  We did have a couple of bugs caused by async exceptions occurring in unexpected places, but over a codebase of hundreds of thousands of lines where almost none of it needs to think about async exceptions, I think that's not bad."
haskell,36tjca,simonmar,1 point,Fri May 22 19:01:46 2015 UTC,"This is also acceptable, to me."
haskell,36tjca,bss03,2,Fri May 22 15:15:38 2015 UTC,"async exceptions are crucial for things like timeouts and (in the system I work on) resource limits.  There's just nothing else that works.  Dealing with async exceptions can be a pain, but the alternative - no async exceptions - is much worse."
haskell,36tjca,simonmar,2,Fri May 22 18:54:07 2015 UTC,"The system I work in has no async exceptions, but does have trivial level process spawning and inter-process communication. Basically, instead of any thread expecting to be killed by anything at any time (and having to code defensively around it), you shove anything that might need killing into a separate process and just kill the whole thing if it becomes necessary. Certainly not always better, but it works quite nicely.  Of course, another way of saying that is that some of our threads are really OS processes, and we then have async exceptions that way."
haskell,36tjca,ndmitchell,1 point,Fri May 22 20:12:21 2015 UTC,"async exceptions are crucial for things like timeouts and (in the system I work on) resource limits.   [citation needed] -- Specifically, I've heard the same claim bandied around about Thread.stop() in Java several times, and it has never been true, so I've got a lot of doubt and frustration around your claim.  Both of these can be handled via a principled communication protocol or two, without the mess of async exceptions.  Okay, I need to step away from this for a second, your message had me mentally spitting expletives, and that's really not called for."
haskell,36tjca,bss03,3,Fri May 22 19:24:18 2015 UTC,"Ok, but you started this thread with an assertion that something I've spent a lot of time thinking about is wrong and should be removed from GHC.  I was also mentally spitting expletives :)  The alternative to async exceptions is some kind of polling.  That requires your code to be in the IO monad often enough, which is incomplete (we need to interrupt pure code), fragile (we might forget to add polling somewhere), and inconvenient (I want async exceptions to be thrown in third-party library code without having to go into the library and add polling checks).  I have a large system where it would be very inconvenient, error-prone, and probably slow, to add polling, and async exceptions just work."
haskell,36tjca,simonmar,1 point,Sat May 23 06:37:21 2015 UTC,"/u/ndmitchell, how did you manage to track down the source of the problem? I'm afraid more tracking down might be necessary: I have the github version of ghcid, which contains your Ctrl+C fix, but when I let ghcid run for too long, it still ignores Ctrl+C and I have to send it a SIGTERM to kill it."
haskell,36tjca,gelisam,1 point,Tue May 26 00:22:26 2015 UTC,"Hmm, that's unfortunate. I was never able to reproduce it reliably, and the fixes seemed to make it go away for me, but without reliable reproduction before I can't be sure. I guess I learnt a lot, but didn't actually solve anything :(. If you have any ideas, or can reproduce it reliably, please let me know."
haskell,36s0ii,chrisdoner,61,Thu May 21 17:35:24 2015 UTC,"Okay, the guy is perhaps coming off a bit strong, but it certainly got me thinking about this topic again. I'm asking the Haskellers who've invested a couple years into Haskell and are already sold.  I've never been completely sold on laziness. I've explained its virtues to other people; certainly laziness beats macros. But sitting back to think and look through my own code, I find it difficult to immediately notice areas where I'm truly taking advantage of laziness. Some points that occur to me:   Lazy data structures other than [a] (which is nice for looping/as a control structure) appear to me mostly to be a novelty. Self-recursive or otherwise infinite data structures are also a novelty to me. I don't really take advantage of lazy bindings as much as I think I did. It's not clear to me that fusion applies to much of my code and how much of that could be inlined nicely because the code is known to be pure. I don't like that a can contain _|_. It really bugs me that exceptions are sitting in any value like implicit null, and the interaction between exceptions and laziness is scary. At least in ML only ""a -> a"" can contain _|_. When you have an Int, it's really an Int. Monads don't need laziness in their construction. The way newbies have always been and continue to be confused as hell about foldl and foldl' when writing trying to code still irks me. Lazy IO is a novelty that I never take advantage of. Conduits/pipes seem a much better model with reasonable behaviour and performance. When I start to care about performance I start inserting bangs to make sure I know when something is evaluated at the right time. It bothers me that record types and data structures in general are lazy by default, when almost 90% of the time I don't want any lazy slots. Lazy and strict versions of Text/ByteString and converting between them ad nauseum bugs me. I prefer conduit/pipe streams. Having implemented a couple Haskell runtimes and dealing with GHC and reading through Hugs's, there's definitely a cost paid to implementing it efficiently and a disconnect for the programmer when reasoning about it. Despite what others say—I acknowledge their view—I would like a debugger and a reasonable stack trace.    I feel like I can have a go at this part of Haskell because I love it so much, and these feelings are just a trade-off that I accepted years ago and still do. I wonder, do we all feel like this, or is pretty much everyone fully satisfied, etc.? Does Idris or strict-Haskell look more attractive? Today I don't worry about laziness because I've been trained on it for years, but what cost do newbies pay?  Also I would, and judging from discussions I've seen in the past, love to see a nice collection of ""this is regular everyday code I couldn't have written without laziness by default."""
haskell,36s0ii,simonmar,69,Thu May 21 17:47:59 2015 UTC,"After a while laziness becomes second nature and we forget how deep it goes.  e.g.   Do you ever write a where clause with a set of bindings without worrying about which ones are actually going to be needed? Do you ever use a top-level definition of type Map k v, or something else that needs to be computed when it is first used? Ever use zip [1..] xs? Ever use a list where you would use an iterator in a strict language?   I'm sure there are more.  I think in these discussions we tend to focus too much on the idioms and cool tricks that require laziness, like the examples from Why FP Matters, or passing a function's result back in as an argument.  In the vast majority of code, lazy evaluation is not a killer feature that you can't do without, but it just makes everything a bit easier.  It's about things that just work without you having to think about them.  Lazy evaluation gives the compiler more leverage in the optimiser than in a strict language.  There are more equalities that apply (e.g. beta reduction, and let x = E in y ==> y, if y /= x) and therefore the compiler can do more code transformations.  GHC uses this to great effect."
haskell,36s0ii,acow,14,Thu May 21 19:26:44 2015 UTC,"Pulling bindings into where clauses is a great feature. It keeps the branching structure concise and readable, while also not confusing the binding definitions with the branching context."
haskell,36s0ii,ndmitchell,14,Thu May 21 19:37:57 2015 UTC,You can have that in a strict language if you change the semantics of desugaring. Mu does that.
haskell,36s0ii,acow,6,Thu May 21 19:54:53 2015 UTC,"Oh, wow, that's neat! So you float bindings in through the conditional guarding their use?"
haskell,36s0ii,augustss,4,Thu May 21 20:06:36 2015 UTC,Yes.
haskell,36s0ii,simonmar,14,Thu May 21 20:11:40 2015 UTC,"I think it's misleading to say you can get the benefits of laziness by desugaring.  You can push bindings closer to their uses, but that's not the same, and it's easy to construct examples where it doesn't get you enough laziness."
haskell,36s0ii,ndmitchell,6,Thu May 21 20:11:16 2015 UTC,"You certainly don't get the benefits of laziness, you can just be a little more lax with the ordering if you have a better desugarer. It's easy to construct examples where you don't get enough laziness, typically with sharing to prevent floating, but it's enough to switch from caring about it 90% of the time to caring about it 5% of the time."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,11,Thu May 21 20:23:25 2015 UTC,"Some strict languages have lazy list, the result is often a best-of-both-worlds thing. See F#'s 'a seq type."
haskell,36s0ii,Kaidelong,6,Thu May 21 19:44:34 2015 UTC,"The real win from laziness is that it lets higher order functions ""discover"" optimal implementations where in strict languages they generate naive ones. The canonical example is head . sort, which is asymptotically better than the equivalent List.sort >> List.head would be in something like F#. I'm not sure you can get this without pervasive laziness. Also, seq is not actually a lazy list as it is strict in its head, but F# did have a proper lazy list in the power pack way back when, I'm not sure where it might be now. This doesn't really matter too much as the head strict version is almost always what you actually want anyway."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,2,Fri May 22 05:56:32 2015 UTC,You could just do Seq.sort >> Seq.head :)
haskell,36s0ii,maxigit,2,Fri May 22 06:42:00 2015 UTC,But is Seq.sort in F# lazzy and only sort what is need to find head ?
haskell,36s0ii,PM_ME_UR_OBSIDIAN,3,Fri May 22 16:48:57 2015 UTC,"So I looked and it is lazy, however it does process the entire sequence at once. I figure it would be easy to implement Seq.lazierSort or something though."
haskell,36s0ii,yawaramin,2,Fri May 22 17:05:25 2015 UTC,There is Nessos Streams.
haskell,36s0ii,maxigit,1 point,Sat May 23 02:41:08 2015 UTC,I figure it would be easy to implement Seq.lazierSort or something though   Or maybe not ;-)
haskell,36s0ii,PM_ME_UR_OBSIDIAN,1 point,Fri May 22 18:42:54 2015 UTC,?
haskell,36s0ii,Peaker,4,Fri May 22 20:57:49 2015 UTC,"If that's the real win then laziness is nearly worthless, given that such examples in use are few and far between.  I think laziness has much bigger wins."
haskell,36s0ii,ndmitchell,10,Fri May 22 12:51:10 2015 UTC,"zip [1..] is nasty. At work we have zipFrom 1, which is the strict equivalent of zip [1..]. I find it much more pleasant even in a lazy language. The fact zip can zip lists of different lists is somewhat ugly.  I'll also add one to your list:   Do you ever write an exception of type IO () and not worry about whether you are defining bottom, or an IO action that when evaluated raises bottom. In a lazy language they are basically the same. In a strict language, they are totally different."
haskell,36s0ii,simonmar,11,Thu May 21 19:53:29 2015 UTC,I don't understand your IO () point.  Are you talking about error vs. throwIO?  Because those are very different in Haskell.  Can you given an example?
haskell,36s0ii,augustss,14,Thu May 21 20:03:58 2015 UTC,"Imagine this in a strict language  do    print 42   error ""boooo""   You'll never get 42 printed.  In a lazy language you don't have to pay as close attention to evaluation vs execution as you do in a strict language."
haskell,36s0ii,simonmar,5,Thu May 21 20:15:59 2015 UTC,"Yes, I can see how that would be surprising."
haskell,36s0ii,Kaidelong,2,Thu May 21 20:30:50 2015 UTC,"I can't really see how to improve zip on [] without breaking something. If it tested lengths, it would no longer by total. If it were strict, you lose laziness which you might well want (particularly if the list is using itself zipped to something else in its own definition).  This more seems to be about the fact that in situations where zip is used, Haskell lists may not be appropriate and we should work with infinite streams or length-typed vectors instead."
haskell,36s0ii,kyllo,2,Fri May 22 06:08:20 2015 UTC,"In other words, over time Haskellers come to take the conveniences of laziness for granted because it lets the compiler do a lot of optimization work for you.   Here's a great example, some code to copy a file. Instead of eagerly/naively reading the whole file's contents into memory first before writing it to the second file, because Haskell is lazy it automatically optimizes the program by chunking/buffering the read/write operations, which is an optimization you'd have to do manually in a strict language: http://stackoverflow.com/a/1576057/1834892"
haskell,36s0ii,stevely,33,Fri May 22 18:18:57 2015 UTC,"In my experience laziness needs to be the default in order to actually get the real value of laziness. There's plenty of people who talk about ""we have lazy X!"" in strict languages, but in practice it's hampered by the fact that since everything else is strict it becomes difficult to actually keep everything from being forced. You have to stay on the rails of what the developers intended you to do with it, and the second you veer off everything gets forced.  The other problem with opt-in laziness is that your syntax is doomed to penalize it. Oh, I have to explicitly wrap something in a thunk and/or explicitly force it? Or I have to explicitly specify that something's lazy? Well that's annoying, so I won't. And even if I did, enough people won't that the benefits of laziness will be hampered because everything will try to force all your thunks anyway. Syntactic baggage will drive developers away from it. And again, laziness is more useful the more things are lazy. Otherwise you just build thunks and then immediately force them anyway.  As for everyday code, I can tell you about some of the uses of laziness I've had recently. I wrote an Alternative instance for a data type that built up computations that could potentially fail or produce a value. String along a bunch of them in series with (<|>) and it'd go through each one at a time until one successfully produced a value. This was a case where I actually had to do a bit of work to ensure that the code was sufficiently lazy, because the natural way to implement (<|>) was to pattern match on both sides, but pattern matching on the right side would result in forcing the full computation. With laziness I can ensure that only one computation is forced at a time, and in the best case none of the alternatives are ever run.  A less necessary but still convenient example of laziness was a data type I made for unifying queries across a number of different sources. To make querying more efficient I had a pre-processing step (converting them from lists to maps). But what if we don't end up using any values from a particular source? Our pre-processing step would be a waste of time. Oh wait, the pre-processing won't actually happen in that case because of laziness.  A more esoteric but good example of the power of laziness, I'm writing a library that's an EDSL for generating a binary IR. This is essentially an EDSL for a form of assembly language, so I need to support forward references (references to values that get declared later) to support branches. With regular do notation you obviously can't have forward references, but with MonadFix and a bit of magic you suddenly can. MonadFix relies on value recursion, and that requires laziness. The best part is that because laziness is the default, the actual implementation is super simple."
haskell,36s0ii,MonadTran,9,Thu May 21 21:21:44 2015 UTC,"Does Idris or strict-Haskell look more attractive?   Idris is looking ""right"" to me. Explicit laziness, exposed at the type level, with implicit conversions back to the strict world, a totality checker, a more expressive type system without the need to write the code in the type system separately from the rest of the code. Looks like the perfect Haskell... Haven't written anything in it, though, so not sure how much of an extra burden dependent types are, in practice."
haskell,36s0ii,bss03,9,Thu May 21 22:49:23 2015 UTC,"If you don't use the additional features of dependent types, you generally won't have to deal with their additional complexity.  Now, you might have a library author that saddles their users with complexity, but I think that can generally be avoided when writing a dependently typed library and should be when possible."
haskell,36s0ii,gonzaw308,6,Thu May 21 23:45:56 2015 UTC,"If you want to create any kind of EDSL, dependent types are your friends. Here is a cool example from the main docs of Idris:  http://docs.idris-lang.org/en/latest/effects/hangman.html  I think the main advantage of dependent types for general purpose programming hasn't been found yet.  For instance, imagine if we could have web libraries written with a similar language like this one:  https://github.com/edwinb/Protocols  We are already seeing some ""dependently typed web libraries"" in Haskell, with servant for instance (http://haskell-servant.github.io/tutorial/api-type.html). Using dependent types for this kind of EDSL can become pretty popular. And that is just with web libraries, you could apply the same reasoning for any other domain. There may be a ""perfect dependently typed library"" for any domain you choose"
haskell,36s0ii,skew,7,Fri May 22 01:28:49 2015 UTC,"It's not clear to me that fusion applies to much of my code and how much of that could be inlined nicely because the code is known to be pure.   You could get an easy overestimate of the importance of fusion with some compiler flags like -fno-enable-rewrite-rules or -ddump-simpl-stats (or -ddump-rule-firings), documented here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html  That's an overestimate because some rules would probably be safe in a strict language too.  Remember exceptions from pure code complicate things - even map f . map g ==> map (f . g) is only equivalent because of the ""imprecise""(nonstrict) semantics of exceptions - though perhaps a strict/total language could pull a similar trick when defining the semantics of exception."
haskell,36s0ii,ibotty,7,Thu May 21 18:36:16 2015 UTC,Have a look at Joachim Breitner's mail from today.
haskell,36s0ii,tibbe,5,Fri May 22 07:38:32 2015 UTC,"I agree with everything you said here. As an empirical point, I'd like to point out that many of our popular libraries (e.g. bytestring, text, containers, attoparsec, aeson) are entirely strict in their data types (except one case I found in text, which was a bug).  The only data type I use in practice that is lazy is lists, because we also use them as streams. Using the same type for both is a pain, because you can easily evaluate the stream too much without noticing and destroy the streaming behavior. Also having the same type means that functions are not self-documenting in what way lists are supposed to be used in the particular API."
haskell,36s0ii,Taladar,2,Fri May 22 07:05:48 2015 UTC,You don't use tuples or custom records at all? Both of those are lazy by default too.
haskell,36s0ii,tibbe,3,Fri May 22 08:25:41 2015 UTC,I do. Records I add bangs to. Roles require lots of care.
haskell,36s0ii,tibbe,1 point,Fri May 22 22:04:36 2015 UTC,Tuples require care I meant.
haskell,36s0ii,acow,13,Fri May 22 22:05:19 2015 UTC,"I think calling them lazy and strict Text/ByteString may have been a mistake. Having rope-like structures where chunks of data can be worked with as though the chunk divisions weren't there is a distinctly different data structure design than a dense array. There is some niftyness in being able to switch between the variants just by changing the import, but the clumsiness of working with both looms far too large over too much code."
haskell,36s0ii,theonlycosmonaut,3,Thu May 21 19:43:25 2015 UTC,"I agree; I've never actually felt the benefit of being able to switch interfaces with an import, because so often the interface I am forced to use is dictated by the libraries I am working with, which don't usually export an equivalent interface for using strict/lazy types underneath."
haskell,36s0ii,kamatsu,18,Fri May 22 02:22:23 2015 UTC,"Laziness lets you decompose your program more easily, and gives you a nicer (in my view) reasoning principle, because you can always substitute equals for equals (but it makes induction dodgy)."
haskell,36s0ii,Kaidelong,1 point,Thu May 21 18:42:21 2015 UTC,Equals for equals is so much better than what I used (easier to think about because you only have to do one step at a time).
haskell,36s0ii,stevechy,4,Fri May 22 06:09:37 2015 UTC,"My guess is that most of the hairy parts of laziness could be eliminated and the benefits retained if there were easy to use abstractions and libraries that would explicitly ensure that space invariants were held by construction   http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html    I'm not sure how this would look or if it is possible but it feels like some patterns already informally exist in how seq and ! are used that could be enforced by a library.  So a library where ""spine-strict"" and ""value-strict"" were native concepts.  Seq and ! are like laziness assembly language.  Another example is that with a plain list there is at least laziness on the whole list value, laziness on the list elements and laziness on the ""rest of the list"".  It would be great if those could be controlled at a higher level, for example by restricting access to only functions from a certain package.  The containers package already does this internally but it doesn't seem to be easy to spread this across an application.  For records it seems like a useful balance would be if record accessors and constructors had strict and non-strict variants, maybe this exists already?"
haskell,36s0ii,merijnv,14,Fri May 22 02:36:12 2015 UTC,"I feel that laziness is a better default than strict. Personally I disagree with your points 1-3, as I use lazy data structures, self-recursion and lazy binding to great effect, but that might be personal style.  The reason I believe that lazy is the better default is that it's easier to make lazy code selectively strict than it is to make strict code selectively lazy.  The only reason we EVER want strictness is to avoid thunk buildup, because besides that laziness will never end up doing more work than strict. To avoid building up thunks it's sufficient to enforce strictness in exactly the one point where thunks would be build up and it will ""Just Work"",for example, forcing the thunk inside foldl' (note: I believe foldl has no reason for existing and would support renaming foldl' to foldl).  The reverse does not hold for strictness, when we want to make something lazy we want to avoid unnecessary intermediate work, but this cannot be done by selectively marking an application as lazy. Why not? Suppose we have some strict function ""foo"" which, internally, maps a function on a list and we only care about, say, the first few elements of the list. Making the application of ""foo"" lazy will merely change WHEN foo is applied, it will NOT affect whether the entire list is mapped or not. To achieve this we need to put laziness annotations all throughout the internals of foo.  This is what has eventually convinced me that laziness is the right default, because making my lazy code strict can be done as a single local change, whereas making strict code lazy would require me to spread laziness all throughout the entire call graph I'm invoking."
haskell,36s0ii,drb226,13,Fri May 22 07:52:07 2015 UTC,"At least in ML only ""a -> a"" can contain _|_. When you have an Int, it's really an Int.   I don't quite follow.  Suppose I have  spin :: Int -> Int spin x = spin x  spin 3 :: Int   Is spin 3 accurately typed as Int? Isn't that expression _|_? Doesn't this mean that expressions with type Int can be _|_, and therefore ML's Int type is inhabited by _|_?  The difference is that in ML, when you've got your hands on a value of type Int, it's really an Int, because otherwise you would have been forced to propagate the _|_ by now."
haskell,36s0ii,augustss,1 point,Thu May 21 18:33:48 2015 UTC,You'll have to be more explicit.  Exactly where does spin 3 occur in the program?
haskell,36s0ii,drb226,4,Thu May 21 20:17:35 2015 UTC,Anywhere with an Int-shaped hole.  main = print (spin 3)
haskell,36s0ii,augustss,2,Thu May 21 20:36:24 2015 UTC,But then you can blame the problem on the partial spin function.  But it's true that every subexpression of type Int does not necessarily have a value of type Int.
haskell,36s0ii,bss03,5,Thu May 21 20:41:13 2015 UTC,"How is that in any meaningful way different from the lazy case where, effectively ""spin 3 = _|_"".  I think analysis for calling a partial function is isomorphic to analysing for a potentially _|_ ""value""."
haskell,36s0ii,julesjacobs,6,Thu May 21 22:30:47 2015 UTC,"The difference is that in a lazy language this also occurs in variables and inside data structures. In a strict language a variable n:Int and the 3rd element of a List Int are both really an Int.  Additionally the rules for propagating bottom are simpler in a strict language. If you have print (f (spin 3)) then in a lazy language it depends on f whether that's bottom, in a strict language it doesn't. The value of that is most apparent if you look at a type like List Int -> List Int. In a strict language that's a mathematical function that takes a list and returns a list plain and simple. In a lazy language the semantics of this type are extremely complicated. Can you feed it an infinite list? Maybe. Maybe if you only look at the first 3 elements of the output you can feed it an infinite list. In general you need to think about ""what portions of the input will be forced if I force a given portion of the output""."
haskell,36s0ii,Kaidelong,6,Thu May 21 23:07:35 2015 UTC,"I don't ever really think about these things. It seems like when you write idiomatic Haskell, you generally get a lazy function when you need one. If anything you have to worry more about getting one when you don't need one. After all, the partially defined structures aren't really there. take 3 . map (flip asTypeOf ()) . repeat undefined never, at any point, involves [undefined, undefined, undefined .. ]. This is an abstraction, a figment of the imagination. The expression is actually equivalent to [(),(),()], the bottoms are no more real than they are in a strict language, you're just changing what expressions mean. Rather than bottom, that expression represents the fully defined list [(),(),()].  Perhaps the real thing to think about isn't about how your input is consumed so much as how your output is produced. If you're building a list in an accumulator in classical tail recursive fashion, you're not pausing to produce something, and you're probably not being lazy enough. We write things in the style of take n (x:xs) = x : take (n-1) xs not to be cute but because that's really all take n does; return a single element and the continuation to the next. In a strict language you have to consider the entire input being evaluated this way, which is simple in the case of lists but may not be in the case of other data structures.  I can only really see this getting in the way if you want to prove something about the structure of all states the program can get into, but you're generally wanting to think in terms of equivalences to data. You don't have to simulate the entire execution of your function to get an understanding of what it produces, it produces exactly the thing on the right side."
haskell,36s0ii,aseipp,5,Fri May 22 06:25:05 2015 UTC,"I know it's a minor technical point (and doesn't detract from the rest of your post, some of which I very much agree with!), but we can have stack traces with no overhead! It's all pretty rough at this point though, but Real Soon we can hopefully have the runtime throw a stack trace on error using DWARF (it also enables other magical things, like symbol servers for apps with crash reporting, etc).  A debugger is something I really want. GHCi has one, but I feel like based on the number of reports, bugs, and uses we get from it, it's either A) damn near perfect, thus requiring few bug reports or B) not stressed and used nearly as much as other things by users. My money is on B here. GDB may work in the future, but I feel like it's really not geared towards our programming model, so there's some impedance mismatch.  It would be interesting to sit down and think about what we really want out of modern a Haskell debugging/performance interface. There are some interesting challenges there, like what a debugger for multithreaded things even looks like when you're regularly dealing with 100,000+ threads..."
haskell,36s0ii,augustss,3,Fri May 22 15:32:19 2015 UTC,"Until I've been shown how, I don't believe a lazy language can have a good stack trace without overhead.  Sure, you can dump what's on the stack when you get an error, but due to laziness this might have very little to do with what the corresponding strict stack trace would be (and I'd argue that's the one you want)."
haskell,36s0ii,Taladar,1 point,Fri May 22 20:08:55 2015 UTC,It might be interesting to step back one more step and consider what people actually use stack traces for and how one might be able to fulfil their needs with something else.
haskell,36s0ii,PM_ME_UR_OBSIDIAN,2,Fri May 22 22:48:50 2015 UTC,Thanks for your thorough synthesis of the issue. It's really shaping my thinking on the subject.
haskell,36s0ii,yogsototh,2,Thu May 21 19:56:21 2015 UTC,"I share most of your feelings. One thing I didn't saw in this thread. lazyness by default can discard (or make hard) some framework. In particular FRP. For example you could take a look at the thesis in the origin of elm.   Also using clojure everyday, choosing strict by default except for sequences which are lazy by default feels a good compromise."
haskell,36s0ii,joeyh,2,Fri May 22 05:35:19 2015 UTC,"https://ghc.haskell.org/trac/ghc/ticket/10370#comment:13 is amusingly relevant, as a case where strictness caused a large space leak in ghc!"
haskell,36s0ii,evincarofautumn,2,Fri May 22 15:50:44 2015 UTC,"I’m with you on all these points.  Being able to refer to the result of a computation while building it is the single most compelling feature of laziness that I miss in other languages.  When writing compilers, I often want to rewrite a tree, with side effects, in a single pass, without mutation, while referring to the final tree. This comes up for example in type inference: simply annotate each AST node with substitute finalTypeEnv inferredType and you’re done. I couldn’t do this nearly as cleanly without laziness (+ RecursiveDo).  Beyond that, laziness is nice for factoring—pulling out let x = foo bar baz always works regardless of the types involved; you don’t have to do the OCaml thing of writing let x () = foo bar baz if foo happens to be fully applied. But not all strict languages suffer from that problem."
haskell,36s0ii,dukerutledge,4,Fri May 22 22:12:22 2015 UTC,The existential quantification fallacy could not exist without lazyness. That is a use case where lazyness creates simplicity.
haskell,36s0ii,dukerutledge,5,Thu May 21 18:02:16 2015 UTC,"I've not heard of that, can you explain it?"
haskell,36s0ii,detrinoh,8,Thu May 21 18:15:20 2015 UTC,"Put simply:  There are many situations where you might be tempted to use existential quantification to unify types, however often your existential wrapper can be avoided by leveraging laziness. This often crops up when you have a collection that you'll only be using some of the values from. Instead of wrapping them in an existential you can just transform them to their end state and use lazyness to avoid work while unifying.  There is an example here: http://www.reddit.com/r/programming/comments/301p9y/thinking_in_types/cposrrk"
haskell,36s0ii,julesjacobs,10,Thu May 21 18:37:17 2015 UTC,"That's only because thunks, like Haskell closures, encode an existential already, and every computation becomes a thunk. This is obfuscation that the compiler has a lot of trouble to undo (and probably can't undo in the general case without whole-program compilation). I would rather use explicit type erasure where I need it only. See: C++ lambda and std::function."
haskell,36s0ii,TaroKong,5,Thu May 21 19:35:04 2015 UTC,Works fine with an explicit lazy type.
haskell,36s0ii,mgsloan,2,Thu May 21 23:15:52 2015 UTC,"Concerning laziness and exceptions. Is Snoyman's ""catch all exceptions"" (https://www.fpcomplete.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions) considered acceptable solution to this problem?"
haskell,36s0ii,peargreen,3,Thu May 21 18:29:43 2015 UTC,"I don't think so.  That article is about catching all exceptions while handling asynchronous exceptions properly.  While I'm a fan of the enclosed-exceptions package, I think it's unfortunate that we need to fork off a thread (even if they're really cheap) just to accurately reify one bit of information about the exception.  Control.Exception now has the ""AsyncException"" type, but this does not actually provide concrete info about whether an exception is thrown asynchronously...  Instead, I think what Chris is referring to is the general yuckiness of having exceptions hidden in pure values.  For example, older versions of GHC's AST had exceptions for some of the node fields, particularly when taken from an earlier stage of the compiler (such as the parser).  Due to work by Alan Zimmerman, I believe this is fixed in newer versions.  This meant that it was tricky / impossible to use SYB to fold or transform on these ASTs, because there are exceptions in some fields.  Even more egregious examples of exceptions in pure values are uses of unsafePerformIO / unsafeInterleaveIO.  This means that if I use hGetContents, it will later throw exceptions if I close the handle early."
haskell,36s0ii,mgsloan,1 point,Thu May 21 21:24:48 2015 UTC,because .   Could you fix formatting here (if this was a formatting problem)?
haskell,36s0ii,mjmrotek,1 point,Thu May 21 21:53:28 2015 UTC,"Ah, good point, sorry.  The continuation is ""there are exceptions in some fields"".  Since information about the AST node isn't available yet, GHC used to put errors in those fields."
haskell,36s0ii,sccrstud92,2,Fri May 22 04:16:33 2015 UTC,Monads don't need laziness in their construction.   I don't quite follow. Would something like  main = loop   where loop = do                  foo <- doSomeIO                  if predicate foo                      then return ()                      else loop   still work without laziness? Wouldn't it run into an infinite loop trying to construct the IO () value?
haskell,36s0ii,augustss,9,Thu May 21 20:11:58 2015 UTC,"I think the if/then/else would still be lazy, as it is in strict language."
haskell,36s0ii,mjmrotek,6,Thu May 21 20:20:43 2015 UTC,It works in a strict language.
haskell,36s0ii,augustss,1 point,Thu May 21 20:45:09 2015 UTC,"But how? I mean, in a strict and pure language too? I can imagine something like this working in a strict language with mutable state:  IO* loop; loop = new IO (bind (doSomeIO, \foo -> if p foo then return () else *loop ())); *loop ();"
haskell,36s0ii,mjmrotek,2,Fri May 22 08:57:20 2015 UTC,"Some strict languages (OCaml, Scheme) allow you to do recursive bindings of non-functions.  Under the hood it will basically do what you suggest with a mutable cell.  Of course, this only works if the recursive use is suitably guarded (like under a lambda).  If your language does not support this, then you have to turn loop into a function, loop () = ... loop () ...."
haskell,36s0ii,augustss,1 point,Wed May 27 10:14:12 2015 UTC,"Okay, thanks, I didn't think of turning loop into a function. Though I have to say that implicit insertion of mutable cells or unit-argument functions seem like cheating to me, but nevermind ;)"
haskell,36s0ii,mjmrotek,1 point,Wed May 27 15:47:00 2015 UTC,I don't see why automatic inserting of a mutable cell in a strict language is any more cheating than for a lazy language.  That's exactly what happens in a lazy language as well.
haskell,36s0ii,SkoomaMudcrab,1 point,Wed May 27 22:31:32 2015 UTC,"As I see it, laziness can be used wherever one wants, instead of some places predefined in the language."
haskell,36s0ii,kamatsu,27,Tue Jun 2 14:36:53 2015 UTC,"Seeing arguments from both sides, it's obvious to me that laziness-by-default is not better or worse than strictness-by-default; it's just a matter of taste and thinking habits. You can't please everyone: some people like looking at code more equationally and mathy, while some like it more down-to-earthy and predictable. In reality, there are lots of seqs in Haskell code, and lots of ""generators"", ""streams"" and the like in imperative code.  The bottom line, however, is that, as SPJ said, laziness was good for Haskell because it helped them keep it pure. There are lots of strict-by-default languages and far fewer lazy ones; lots of impure languages and far fewer pure ones; so for this reason if none other, Haskell should always remain lazy."
haskell,36s0ii,skew,24,Thu May 21 19:07:27 2015 UTC,"If you take away my laziness, your language better bloody well be total and have a good accounting of codata."
haskell,36s0ii,bss03,6,Thu May 21 18:44:32 2015 UTC,"That might actually work out very nicely - a pure and total language would allow any optimization valid in Haskell, and then finishing up with a simple strict code generation strategy."
haskell,36s0ii,edwinb,4,Thu May 21 21:11:52 2015 UTC,"In Idris, part of the defense of the choice of struct-by-default is that the language is total-by-default so the strictness is just an optimization.  But, IIRC /u/edwinb has stated the real reason that it is strict is that it was just the more practical choice.  The Lazy type constructor and good decoration of the standard library with it might be fine, but I think that's yet to be seen."
haskell,36s0ii,pigworker,19,Thu May 21 22:38:52 2015 UTC,"There's no defence of strictness by default for Idris because it's not a choice that I feel needs defending - neither is laziness by default. Both choices have their merits, both have their problems, and which one you pick for a language (at least assuming you have a reasonable understanding of both) probably depends to some extent on the kind of applications you have in mind for the language and the style of coding you want to encourage.  This comes up so often that it's in the FAQ: http://docs.idris-lang.org/en/latest/faq/faq.html#why-does-idris-use-eager-evaluation-rather-than-lazy  The original reason is not even anything to do with practical choice. It was just the way I wanted to do it at the time, having already implemented a lazy VM for an earlier project. Nobody says you have to pick sides for everything. Sometimes I even write code in dynamically typed languages...   Idris turns out to be pretty easy to retarget so it's not even out of the question to write a new lazy back end for it, though you might struggle to reuse a lot of library code."
haskell,36s0ii,jonsterling,11,Thu May 21 23:26:34 2015 UTC,"People used to ask me whether Epigram was strict or lazy. I used to answer ""No.""."
haskell,36s0ii,Taladar,9,Fri May 22 01:08:22 2015 UTC,"Really? Pervasive laziness is only acceptable (from my point of view) in a total language; type theory has a lazy operational semantics by default, and this makes the meaning explanations more elegant.  But laziness combined with partiality is pretty much a recipe for trouble. Strictness, on the other hand, makes dealing with partiality (and effects!) totally tractable.  Of course, my preference is to mix laziness and strictness in the style of polarized type theory, or Levy's CBPV. But if I have to choose discretely, then to me there are only two choices: lazy + total, or strict + partial.  EDIT: I want to stress one point about laziness + totality. I learnt from Conor McBride the following point, which is that if you have totality, then there a tons of things (including proofs) that you never need to actually normalize, so long as you make sure that other results do not depend on their particular value."
haskell,36s0ii,pigworker,1 point,Thu May 21 22:24:28 2015 UTC,How does it matter if a program is total in practise? The case of a program that never terminates and the case of a program that merely terminates 3000 years from now are indistinguishable in all practical situations.
haskell,36s0ii,Taladar,13,Fri May 22 08:28:57 2015 UTC,"I'm always depressed when this particular line of unreason comes up. ""That's only half a loaf so let's nobody have any bread."" Remember that you are arguing to impose expressive weakness.  Totality is just the beginning of the journey. Of course, those of us who currently want to make promises such as ""it terminates eventually"" have the ambition to make even stronger promises such as ""it terminates in a nanosecond"". At least we're working towards increasing the kinds of trust which are possible.  Meanwhile, in a Curry-Howard setting, the mere knowledge that a proof object would normalize if you wanted it to means you can trust it without computing it at all. That is, the value of the strong promise is that it eliminates work. Contrast that with the situation in Haskell today, where type safety for GADT programs depends on evaluating terms not for their value as data but just to check they're not bottom."
haskell,36s0ii,pigworker,1 point,Fri May 22 10:23:25 2015 UTC,"Remember that you are arguing to impose expressive weakness.   Isn't it you who are arguing for a less expressive language. As far as I understand it a total language is strictly less expressive than one which might not terminate.  I completely agree that we should have as many static guarantees as possible, I just don't see the benefit we gain for giving up intentional non-termination (e.g. in a main loop of a daemon program) considering we still have all those cases left that do not terminate on a practical level but would on a theoretical one. I also do not see a large number of bugs caused by non-termination.  Your last paragraph sounds like you are talking about the type checker, perhaps it would be possible to have strict evaluation on the type level while keeping laziness on the value level?"
haskell,36s0ii,danharaj,10,Fri May 22 13:26:32 2015 UTC,"Remember that you are arguing to impose expressive weakness. Isn't it you who are arguing for a less expressive language.    No. It is time you understood that.  There are total languages which allow all the programs. Some of those programs have types which indicate the possibility that computation may diverge. Total languages forbid false negatives -- dangerous programs being typed as safe -- but they can allow dangerous programs typed as dangerous. It is inevitable that a total language will type as dangerous some programs which are in fact safe (false positives), but the usual non-total situation is that all programs are considered dangerous. Allowing any positive safety promise is a win.  Please also learn that totality includes the productivity of coinductive processes (e.g. the main loop of a daemon program) as well as the termination of inductive ones. Total programmers make strong liveness promises, too. We try to tell the difference between ""while true do skip"" and ""while true do something useful"".  Meanwhile, in my last paragraph I am talking about run time. Haskell programs today generate run time code which must be executed and executed strictly, solely to ensure that type unsound behaviour is guarded by more gracefully undefined behaviour. The type system is not strong enough to establish trust, so soundness requires a test with a run time cost. That's why you can't make a GADT pattern match irrefutable."
haskell,36s0ii,StudentRadical,5,Fri May 22 14:00:52 2015 UTC,That's why you can't make a GADT pattern match irrefutable.   Thanks for clearing that up. I always wondered about GHC's cryptic message when you try to do an irrefutable let binding of a GADT.
haskell,36s0ii,EvilTerran,4,Fri May 22 14:19:05 2015 UTC,So what makes a language total? I'm new to functional programming.
haskell,36s0ii,jozefg,16,Thu May 21 19:47:27 2015 UTC,"Just that, in a total language, you can't write a program that doesn't terminate. The standard example would be simply-typed lambda calculus - every well-typed expression in STLC can be reduced to normal form in a finite number of evaluation steps.  Of course, a language where your programs can't run forever isn't very useful in the real world, and that's where the idea of codata that /u/kamatsu mentioned comes in. Informally, the idea is that you have two flavours of type, ""data"" and ""codata"": the ""must terminate"" rule only applies to ""data"" expressions; for ""codata"" expressions, the rule is instead that they must be ""productive"" - that is, always produce at least a partial result in a finite amount of time.  For example, the Fibonacci sequence as an infinite list couldn't be ""data"", because it would take an infinite amount of time to evaluate it in full - but it can be ""codata"", because you can write a function that computes the next value every time it recurses, ie always in a finite number of steps (f x y = x : f y (x+y)).  The type systems of total languages with codata are structured in such a way that you can never mix ""data"" with ""codata"" unsafely - your code will either always terminate or always be productive."
haskell,36s0ii,pigworker,4,Thu May 21 20:39:24 2015 UTC,All programs terminate. So no Turing completeness but you recover the useful case of nontermination with conduction/codata.
haskell,36s0ii,philipjf,22,Thu May 21 20:22:11 2015 UTC,Turing completeness is entirely compatible with totality. It is only bullshit completeness that totality excludes.
haskell,36s0ii,pigworker,3,Thu May 21 20:30:07 2015 UTC,"""all computable functions on the natural number can be written with the type Nat -> Nat"" doesn't seem like bullshit to me.  An excessively strong condition perhaps, but not bullshit."
haskell,36s0ii,leperLlama,4,Fri May 22 07:56:53 2015 UTC,"But then not everything with type Nat -> Nat is a computable function, which means you can't use that type to promise computability."
haskell,36s0ii,bss03,5,Fri May 22 08:17:42 2015 UTC,I'd love an XCodata language extension that made all data strict and provided a codata keyword. Backwards compatibility would be easy because you could find and replace all data to codata then incrementally add data in where you wanted it. Prelude would need to be rewritten to take advantage of it but given that we'd be able to prevent length from being called on infinite lists I think the added type safety might be worth it.   Would you be able to replace XBangPatterns and seq with data/codata?
haskell,36s0ii,dougmcclean,9,Thu May 21 22:06:39 2015 UTC,I thought there was already a proposal out there for a Strict language pragma.  Which basically thows ! decorators everywhere and makes you write ~ explicitly on (e.g.) record fields that you want to be lazy.
haskell,36s0ii,philipjf,3,Thu May 21 22:40:34 2015 UTC,"Compatibility is only easy if you do a global search and replace on the entire world, including all your dependencies. Otherwise wacky things happen when you cross module boundaries."
haskell,36s0ii,dogodel,3,Thu May 21 22:27:23 2015 UTC,"defining ""codata"" by constructors is sketchy business."
haskell,36s0ii,Taladar,9,Fri May 22 10:32:09 2015 UTC,"The major design constraints I see are:   Laziness lets us encode infinite structures without directly encoding them as a seed and unfold, and let us switch between concrete and thunked data without worrying However, it makes evaluation unpredictable (or cumbersome to force) - a particular problem for IO effects or sane stack traces. Bottom is lurking, unseen and immortal. Laziness allows easy sharing. But it's impossible to properly control sharing. It is a side effect, just like evaluation.   In most cases, simply separating data from codata will solve the problem, but we really need a full linear type system to have it all. i.e. to be linear in the size of structures (a la combinatorial species) to have fine-grained control over sharing"
haskell,36s0ii,kqr,8,Thu May 21 18:07:14 2015 UTC,"Bottom is lurking, unseen and immortal.   How is that different with strict languages? They have non-termination to deal with as well, only there you encounter it a bit more often if you write the same code with the same parameters."
haskell,36s0ii,Taladar,3,Thu May 21 19:37:08 2015 UTC,"Values don't have non-termination as a result, only computations do. In lazy languages all values are (or can be) computations.  In a strict language, you know that if you managed to get your hands on a value it is definitely a value, and not a non-terminating computation. In a lazy language, it's not so clear."
haskell,36s0ii,kqr,5,Thu May 21 21:18:20 2015 UTC,True...but on the other hand you hit all the same potential sources of non-termination along the way to getting that value in a strict language while in a lazy one you only hit them if you actually use the value. There is no situation where the strict language terminates and the lazy one does not given the same expressions.
haskell,36s0ii,Taladar,3,Thu May 21 21:35:50 2015 UTC,That is correct.  I think what people like /u/dogodel are talking about is that errors should be flagged for as close to the source as possible.
haskell,36s0ii,dogodel,3,Thu May 21 21:46:49 2015 UTC,"I fully support showing error source locations, you don't need stack traces for that though. The main reason you need stack traces in many other languages is that you need to know how a call differs from a call of the same function with identical parameters.  I would argue that this only matters for two situations, one is where the function producing the error behaves differently depending on when or where it is called and the other is where the source position points to some general error reporting function and you need the function calling that one.  The first case is best avoided in as many places as possible by making most complex code pure, the second can be solved by giving the call to the error function enough information in its parameters about the cause of the error which is good style anyway (e.g. not ""File not found"" but ""File /foo/bar/baz not found when doing bla"")."
haskell,36s0ii,kamatsu,4,Fri May 22 08:34:14 2015 UTC,"One difference is that a good implementation of proper codata can do ""productivity checking"", to make sure your recursive definitions have a base case and don't just loop (for example, x=x is rejected at compilation, but ones=1:ones doesn't). In totally strict languages, these errors don't exist at all, at the cost of expressiveness.  (Technically, the ""right"" way to write ones is more like  head ones = 1 tail ones = ones   and then it has a clear computational and memory intepretation, instead of ""magic lazy knot tying""  )"
haskell,36s0ii,PM_ME_UR_OBSIDIAN,4,Thu May 21 22:04:37 2015 UTC,"If the language is total, it can just as easily be lazy or strict."
haskell,36s0ii,dogodel,2,Fri May 22 03:55:08 2015 UTC,"a la combinatorial species   I have that paper lying around, but I've never gotten around to reading it. How useful is it?"
haskell,36s0ii,PM_ME_UR_OBSIDIAN,6,Thu May 21 19:46:10 2015 UTC,"Do you mean https://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf ? There are many papers, but that one's probably the best intro for haskellers. The most useful application for the working programmer is giving an economical language for equational reasoning about the shape of datatypes (think generic haskell).  Beyond that, Species are deeply fundamental to programming, but in the same way cartesian closed categories are - you probably won't run into them directly. There's exciting research going on based in species, and I'd argue the next big programming revolutions (practical linear types, ornaments, etc) will come from them.  If you like that paper, I also highly recommend Brent Yorgey's recent phd thesis, it's surprisingly readable. The citations in his thesis will keep you busy after that ;)"
haskell,36s0ii,Tekmo,2,Thu May 21 21:56:52 2015 UTC,"Species are deeply fundamental to programming, but in the same way cartesian closed categories are   To be honest, I still don't get what's the big deal with cartesian closed categories. We have yet another construct that's equivalent to intuitionistic logic, what now?   ornaments   That one is also pretty elusive, though that's 100% on me for not doing the legwork and reading papers."
haskell,36s0ii,glaebhoerl,5,Thu May 21 22:07:17 2015 UTC,"The big deal of Cartesian closed categories is that you could overload lambas and function application to work for anything that implements a CCC type class.  In essence, it would let you overload functional programming to work in a much wider variety of contexts.  Imagine if you could print your program as a diagram or generate a circuit diagram from it without having to extend the compiler."
haskell,36s0ii,dogodel,2,Fri May 22 17:35:41 2015 UTC,"(I read Brent Yorgey's blog posts about them many years ago, but haven't kept up much since.) What's the connection between species and linear types?"
haskell,36s0ii,mishach,3,Fri May 22 19:25:22 2015 UTC,"The moral connection is that species are indexed by their size, and you can do useful calculations on it with the generating functions - so you can talk about functions that preserve it.  At a deeper level, the operations for combining species correspond to the operators of linear logic operators ""with"", "" par"", ""tensor"" etc. The full implications of this for programming aren't clear yet but it should be pretty big"
haskell,36s0ii,dogodel,2,Fri May 22 21:37:21 2015 UTC,"data from codata will solve the problem, but we really need a full linear type system to have it all. i.e. to be linear in the size of structures (a la combinatorial species) to have fine-grained control over sharing   Do you happen to know good resources where begginner can learn hot to separate data vs codata?"
haskell,36s0ii,mishach,3,Thu May 21 21:47:54 2015 UTC,"This, and the slides linked in the post, is a good start http://blog.sigfpe.com/2007/07/data-and-codata.html  You can also look for ""copattern matching"" - there's a lot of papers but I'm not sure which is best.  Agda/Idris/(Coq?) are the only languages I know of that actually implements codata, so you could look at their specification too"
haskell,36s0ii,Yuras,1 point,Thu May 21 22:14:10 2015 UTC,Thank You.
haskell,36s0ii,Drupyog,18,Thu May 21 23:04:13 2015 UTC,"I'm writing in Haskell for food for the last few years. I use laziness every day in my work, and I don't remember the last time I had any nontrivial issue because of space leaks. I hate a lot of things in Haskell, but laziness by default is a big + for me.  For performance critical code you have to keep computational model in the mind all the time, regardless of lazy vs strict semantics. Lazy semantics is not harder than the strict one. It is different. Though it makes a big difference for newbies, because they usually have a background in strict languages.  There is nothing I can do using laziness that I can't do without it, but it makes my day to day work easer because it enables more composible interfaces, so I like to have it by default. Though I agree that the default is mostly a question of taste.  Lack of stack traces and better debugger is kind of an issue, but it is definitely not a show stopper for me. I guess we can have (something like) stack traces and laziness at the same time."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,14,Thu May 21 19:53:49 2015 UTC,"To all people in this thread: Do not forget that having a strict language, like OCaml or Idris) doesn't prevent the occasional (explicit) use of laziness.  It's a question of what is the good default. We all know laziness is well suited for some tasks.   I also think people grossly underestimate the ability to use lazy iterators in strict languages."
haskell,36s0ii,beerdude26,5,Thu May 21 19:16:20 2015 UTC,"IMHO, the best of both worlds would be a strict, pure language with a good lazy list story. We don't quite have that right now, the closest thing would be Haskell-with-bangs or the pure subset of Ocaml."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,7,Thu May 21 19:50:02 2015 UTC,Someone proposed a Strict pragma.
haskell,36s0ii,augustss,3,Thu May 21 21:31:42 2015 UTC,Give me StrictExceptLists :0
haskell,36s0ii,leperLlama,3,Thu May 21 22:02:33 2015 UTC,"Depends who you think ""we"" are. :)"
haskell,36s0ii,beerdude26,2,Thu May 21 21:45:05 2015 UTC,Would not having a default be possible? I.e. you need ! to be strict and you need ? to be lazy and function arguments are syntactically invalid without them?
haskell,36s0ii,MonadTran,2,Thu May 21 22:08:57 2015 UTC,"I always felt the use of lazy iterators in strict languages was really cumbersome. Refactoring code to be lazy is quite annoying, too."
haskell,36s0ii,_AndrewC_,7,Thu May 21 21:30:01 2015 UTC,"I'm writing C# daily, and I wouldn't say lazy iterators are too cumbersome or annoying. Lack of purity is, as well as the lack of type system expressiveness."
haskell,36s0ii,Taladar,1 point,Thu May 21 22:40:11 2015 UTC,Lazy evaluation is one of the big drivers behind keeping Haskell pure. Side effects have to be restricted to the magic main =.
haskell,36s0ii,Guvante,2,Sat May 23 08:08:53 2015 UTC,How do you use that explicit laziness to implement control structures though? Haskell makes building new functions using conditional execution of their arguments very easy.
haskell,36s0ii,Dickferret,2,Thu May 21 19:57:28 2015 UTC,"You could go with a variation on bang syntax.  ifThenElse condition ~one ~two = if condition then !one else !two   There is an interesting question of how you distinguish between forcing one and two and passing along one and two, I used ! above but there may be other ways."
haskell,36s0ii,Guvante,2,Thu May 21 22:03:21 2015 UTC,"Have you heard of Kernel? It took this about as far as it can be taken, all evaluation is explicit. I found actually programming in it frustrating unfortunately."
haskell,36s0ii,pigworker,2,Fri May 22 13:53:21 2015 UTC,"You could use the type to avoid forcing, similarly for avoiding the delay operation. I just don't know how to get implicit typing in those cases."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,2,Fri May 22 14:35:59 2015 UTC,"In (the old but existing version of) Frank, you write  if Bool then {[]X} else {[]X} [] X if tt then t else e = t! if ff then t else e = e!   The type signature indicates the mixfix syntax (by putting types in the holes where the values will go). The braces syntax indicates a type of suspended computations, so we know the ""then"" and ""else"" branches are things we can choose to do or not do. So t and e stand not for X-values but for thunked X-computations, with the !-notation forcing them. The boxes tell you, relatively speaking, which effects are permitted: here, the emptiness of all three boxes tells you that whatever effects are enabled at the usage site will also be available in the two branches.  The notation is likely to change next time I work on Frank, but the general message stays the same: keep the value/computation distinction clear."
haskell,36s0ii,Taladar,1 point,Fri May 22 08:52:54 2015 UTC,Which control structures do you need that aren't covered by what already exists + monadic DSLs?
haskell,36s0ii,rezb1t,4,Thu May 21 20:05:08 2015 UTC,Anything abstracting away some combination of what already exists mostly.
haskell,36s0ii,PM_ME_UR_OBSIDIAN,18,Thu May 21 21:08:49 2015 UTC,"My favorite aspect of laziness is the fact that it makes our language more combinator-centric. I.e. using foldr, foldl' instead of explicit recursion. I'm sure there are better examples too. :)  I think most of us Haskellers agree that laziness is no silver bullet, but in my opinion it fits like a glove on Haskell.  However, give me totality, a separation of data/codata and then strictness starts to look very appealing"
haskell,36s0ii,gnzlbg,10,Thu May 21 19:33:27 2015 UTC,"My favorite aspect of laziness is the fact that it makes our language more combinator-centric. I.e. using foldr, foldl' instead of explicit recursion. I'm sure there are better examples too. :)   I guess you're saying that lazy combinators stop when they need to, while strict combinators always process the entirety of the output. I think that's a solid point."
haskell,36s0ii,beerdude26,3,Thu May 21 19:50:43 2015 UTC,"But you need both, and can have both in a strict language, see for example C++ range-v3. It has composable views (lazy) and actions (eager). Each action forces a ""data traversal""."
haskell,36s0ii,drb226,3,Sat May 23 11:07:56 2015 UTC,"However, give me totality, a separation of data/codata and then strictness starts to look very appealing   This, to me, illustrates a good point why Haskell should remain lazy by default: most programmers have no idea what totality or codata even is. Being exposed to Haskell makes you think, learn and reason about these kinds of things, after which one could make the step to a language that loosens the laziness leash and allows you to explicitly define what is data and what is codata. Perhaps that language could still be Haskell, just with some pragmas :)  EDIT: I'm reading the documentation for idris right now, and it reinforces my feelings. Laziness is introduced through the type Lazy, which is really nice to be able to to say we want to defer a particular computation. However, programmers from imperative, strict backgrounds would usually not have the reasoning skills to be able to differentiate between what computations or values should be strict and which should be lazy."
haskell,36s0ii,ziman,4,Fri May 22 05:54:55 2015 UTC,"I wish for strict-by-default, with easy notation for lazy things.  -- (~) :: * -> * data List a = Nil | Cons a ~(List a)  -- You can refer to a recursive binding lazily via ~ ones :: List Int ones = Cons 1 ~ones  fix :: (~a -> a) -> a fix f = let x = f ~x in x  ones' :: List Int ones' = fix (Cons 1)  force :: ~a -> a force = #compilerMagic  -- non-lazy recursive references are implicitly forced factorial :: Int -> Int factorial 0 = 0 factorial n = n * factorial (n - 1) -- factorial n = n * force ~factorial (n - 1)  newtype LStateT s m a = LStateT { runLStateT :: ~s -> m ~(s, a) }  instance (Monad m) => Monad (LStateT s m) where   -- pattern matching on lazy value with ~,   -- bindings can only be used in a lazy expression ~{...}   -- encourages a sort of ""hungarian notation"" to visually mark lazy vaues   return a = LStateT $ \~s -> return ~{ (s, a) }   m >>= k = LStateT $ \ ~s -> do     ~(a, s') <- runLStateT m ~s     runLStateT (k $ force ~a) ~s'"
haskell,36s0ii,drb226,6,Thu May 21 19:23:20 2015 UTC,"Idris has exactly that, Lazy : Type -> Type, with the elaborator inserting Delay and Force in the appropriate places automagically so there's even less noise than in your snippet above: http://docs.idris-lang.org/en/latest/faq/faq.html#how-can-i-make-lazy-control-structures"
haskell,36s0ii,anon_c,3,Fri May 22 05:44:05 2015 UTC,Idris is looking nicer and nicer. I'm pretty sure it will win me over one of these days.
haskell,36s0ii,drb226,6,Fri May 22 06:00:43 2015 UTC,Something like this? [https://ghc.haskell.org/trac/ghc/wiki/StrictPragma]
haskell,36s0ii,anon_c,3,Thu May 21 20:33:36 2015 UTC,"Something like that. My flavor would be a little more explicit about marking lazy values throughout code, would leverage the type system to track laziness, and would work for TLDs."
haskell,36s0ii,drb226,3,Thu May 21 20:40:02 2015 UTC,"Interesting. It seems clear to me that laziness and strictness are both very important, and languages should try to support both as well as possible.  How fleshed out are your ideas about encoding laziness in the type system? Are there any good papers on this topic?  How well do language backends support mixed lazy/strict programming? I think I remember reading a paper that showed this to be difficult. Maybe it was Bridging the gulf: a common intermediate language for ML and Haskell?  Would this lead to an explosion of different lazy/strict data structures?  data List a = Nil | Cons a ~(List a) data List a = Nil | Cons ~a ~(List a) data List a = Nil | Cons a (List a) data List a = Nil | Cons ~a (List a)"
haskell,36s0ii,augustss,2,Thu May 21 20:56:18 2015 UTC,"How fleshed out are your ideas about encoding laziness in the type system?   Not very. It's stuff I've had on my mind but have never rigorously fleshed it out.   Are there any good papers on this topic?   Presumably there are. I'm not particularly aware of any such paper. I'd love to read up on it, too.   Would this lead to an explosion of different lazy/strict data structures?   Not necessarily. Notice how data List a = Nil | Cons a ~(List a) follows the ""lazy recursion"" rule of thumb.  In my imaginary formulation, ~Foo would be a distinct type, just like Foo or any other type. So if you want a list of lazy Foos, you just have List ~Foo rather than needing Cons to be lazy in its first argument."
haskell,36s0ii,pigworker,7,Thu May 21 21:21:27 2015 UTC,Explicit laziness gets messy.  I've not seen a good proposal for that yet.
haskell,36s0ii,Kaidelong,8,Thu May 21 20:22:19 2015 UTC,"Let's not just compare lazy with strict. Let's compare direct style effectful programming in ML-like languages with do-notation etc in Haskell. It's great to know what we're not doing, but we're not doing what we are doing very well.  I certainly want codata to work sensibly. I also want to distinguish computations I might run from the values of computations which have been run already. We need to be able to write control operators (aka higher order functions), but is it so bad if their types make the value/computation distinction clear?"
haskell,36s0ii,radix,5,Thu May 21 23:56:10 2015 UTC,"It lets you express programs independent of the control flow you're actually going to use to evaluate them. When working with eta-expanded functions you still have to invoke them at particular points and how they are invoked is determined by the evaluation strategy employed by the language. In Haskell you can be polymorphic in your evaluation strategy, you can choose a particular model that's strict or one that isn't, or write your code to be agnostic about the choice, generally by being polymorphic on a monad.  I also like that laziness makes it really easy to think about what code does. Do you want to evaluate a function? Run it exactly one step, and no more, and you get an idea what happens. With a strict language you have to follow the expression tree all the way down to the bottom on your first go.  I haven't actually run into any problems with lazy I/O or other old bogeymen. Once you know the basic tricks for writing lazy programs like co-recursion and you use strict libraries and evaluation systems where you need them (like ST or unboxed vectors) the pervasive lazy evaluation doesn't seem to get in your way much, and it helps a lot.  Laziness seems to be Haskell's killer feature at this point. If you were willing to dispose of it, you could easily jump ship to something like Purescript or Elm if you wanted. If Haskell were not lazy, I might have done so."
haskell,36s0ii,conklech,3,Fri May 22 05:48:39 2015 UTC,"I think there are some practical problems with the whole ""polymorphic to evaluation strategy"" idea, given how much mental effort I spend on conversions between e.g. strict and lazy bytestrings/texts in my programs -- how I have to be specific about the types. maybe it's just because so much other code forces me to be specific (like how Aeson specifically uses strict or lazy types in various places). I'm still relatively new to Haskell, so maybe I'm just missing some things."
haskell,36s0ii,arianvp,11,Fri May 22 20:53:36 2015 UTC,"In the future, when crosslinking, please use the np subdomain. I think the /r/haskell community knows better than to vote brigade, but it's generally considered good practice to np anyway."
haskell,36s0ii,hagda,12,Thu May 21 19:42:03 2015 UTC,"Not everyone here is active enough in the broader reddit ""community"" to be aware of its peculiar mores regarding ""brigading."" np links are a good idea; maybe even a good rule?  I'm always more afraid that I'll be mechanically shadowbanned if comment after following a cross-subreddit link like this. I've never seen any clear disclosure of when that's prohibited. In particular, I don't trust that the system recognizes when you're actually a subscriber and bona fide participant in both subs.  As a result, my personal policy is never to comment or vote on a thread I didn't reach directly from the reddit front page."
haskell,36s0ii,leperLlama,3,Thu May 21 20:56:31 2015 UTC,I'm now sure what you mean by this. Could you elaborate?
haskell,36s0ii,Tekmo,3,Fri May 22 19:34:29 2015 UTC,"When linking to another page on reddit, you can replace the www with np (for 'no participation'). This is preferred because it minimizes the amount of brigadiering / vote manipulation that can happen. Generally this is a problem in bigger subreddits / subreddits which deal with controversial topics; not so much in a smaller sub like /r/haskell, but even so, it's considered good practice to link to other reddit pages with the np."
haskell,36s0ii,bss03,1 point,Sat May 23 00:40:52 2015 UTC,"Interesting, good to know."
haskell,36s0ii,pigworker,15,Sat May 23 15:12:00 2015 UTC,"Afaik, Haskell was created to serve as the canonical standardised pure/lazy functional language. I wouldn't use Haskell if I felt bad about laziness. It'd be like eating an apple pie while complaining that it contains apples..."
haskell,36s0ii,bss03,8,Thu May 21 18:48:24 2015 UTC,"I think it's also important to remember that the developers matter more than the language. If Haskell is the only language which is lazy be default, and new knowledge or experience can be gained for the developer by operating in a lazy language, then it would be a loss for developers if the only lazy language we have went strict. I'd rather Haskell never went mainstream but was still viable for  education which I could apply to other languages, than lose an easy test bed for laziness."
haskell,36s0ii,pigworker,11,Thu May 21 22:16:06 2015 UTC,The deeper issue is the one that /u/dmpk2k mentioned: I don't know what assembly I'm getting.  Even if Haskell were strict I'm not sure it would solve that problem.
haskell,36s0ii,bss03,5,Thu May 21 19:26:27 2015 UTC,"I suspect that's down to implementation. In SBCL, for example, I can, in the REPL, request the assembly for any piece of code:  * (disassemble '(lambda (x) (+ x x x))) ; disassembly for (LAMBDA (X)) ; Size: 53 bytes ; 02BAF009:       488B55F8         MOV RDX, [RBP-8]           ; no-arg-parsing entry point ;       0D:       488B7DF8         MOV RDI, [RBP-8] ;       11:       4C8D1C25F0010020 LEA R11, [#x200001F0]      ; GENERIC-+ ;       19:       41FFD3           CALL R11 ;       1C:       480F42E3         CMOVB RSP, RBX ;       20:       488B7DF8         MOV RDI, [RBP-8] ;       24:       4C8D1C25F0010020 LEA R11, [#x200001F0]      ; GENERIC-+ ;       2C:       41FFD3           CALL R11 ;       2F:       480F42E3         CMOVB RSP, RBX ;       33:       488BE5           MOV RSP, RBP ;       36:       F8               CLC ;       37:       5D               POP RBP ;       38:       C3               RET ;       39:       CC0A             BREAK 10                   ; error trap ;       3B:       02               BYTE #X02 ;       3C:       18               BYTE #X18                  ; INVALID-ARG-COUNT-ERROR ;       3D:       9A               BYTE #X9A                  ; RCX   The Lispers I've worked with have had a surprisingly good ability to predict the kind of assembly that's going to be generated from their code. SBCL itself has no interpreter, it always compiles down to ASM immediately and then runs it. It achieves this by having very safe assembly. But you can turn that off and set the optimization level to high and safety to low and get, e.g.  * (disassemble '(lambda (x) (declare (type (signed-byte 32) x)) (+ x x x)))  ; disassembly for (LAMBDA (X)) ; Size: 17 bytes ; 02C4E4BF:       488D0412         LEA RAX, [RDX+RDX]         ; no-arg-parsing entry point ;       C3:       488D0C10         LEA RCX, [RAX+RDX] ;       C7:       488BD1           MOV RDX, RCX ;       CA:       488BE5           MOV RSP, RBP ;       CD:       F8               CLC ;       CE:       5D               POP RBP ;       CF:       C3               RET"
haskell,36s0ii,Watley,10,Fri May 22 08:05:16 2015 UTC,"I feel it is essential.  Though, I'd probably still use Haskell if it weren't lazy.  I came for the purity.  Lazy-by-default helps keep the purity honest."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,15,Thu May 21 19:38:56 2015 UTC,"I came for higher kinds. I'd give up laziness tomorrow. I rather like purity, but Haskell is as pure as Haskell is."
haskell,36s0ii,mishach,4,Thu May 21 23:41:27 2015 UTC,"Haskell is as pure as Haskell is.   The first rule of tautology club is the first rule of tautology club.  Or, is this a typo?   I came for higher kinds. I'd give up laziness tomorrow.   Idris?  Scala?"
haskell,36s0ii,beerdude26,9,Thu May 21 23:53:30 2015 UTC,"It's not a typo. If you're still wondering in what way Haskell is pure, I'll tell you tomorrow."
haskell,36s0ii,Guvante,3,Thu May 21 23:58:36 2015 UTC,"It's not a typo.   Okay, I had ∃ you. Clever you; I just wanted a witness."
haskell,36s0ii,beerdude26,12,Fri May 22 00:14:10 2015 UTC,I absolutely love laziness. It allows me to do away with the unecessary distinction between functions that produce values on demand and functions that produce collections of values. I can't imagine maintaining a compositional style nearly as clean as in Haskell in a strict language.
haskell,36s0ii,mishach,6,Thu May 21 18:00:46 2015 UTC,Strict languages can have lazy lists :)
haskell,36s0ii,jmite,3,Thu May 21 19:46:54 2015 UTC,aziness. It allows me to do away with the unecessary distinction between functions that produce values on demand a   and lazy if statements.
haskell,36s0ii,bss03,3,Thu May 21 21:50:04 2015 UTC,Generators/Streams are painful to combine with the rest of (usually nearly completely) strict ecosystem. I haven't encountered a single language that makes it easy to use or read.
haskell,36s0ii,Taladar,7,Thu May 21 21:35:36 2015 UTC,Sequences in F# are pretty easy to work with.
haskell,36s0ii,Mob_Of_One,1 point,Thu May 21 21:55:22 2015 UTC,True.
haskell,36s0ii,maxigit,4,Thu May 21 22:24:35 2015 UTC,Laziness makes it difficult to reason linearly about the performance of the program.  Is the intrinsic problem with the lazy evaluation or people just need to learn how to reason and structure programs differently?
haskell,36s0ii,radix,4,Thu May 21 18:20:38 2015 UTC,"In my Masters projects, laziness makes debugging with print statements hell. I'd be all for it if we had a proper, eclipse or gdb (or better!)  level debugger. In the meantime it's making my life quite difficult."
haskell,36s0ii,seriousreddit,3,Fri May 22 02:32:14 2015 UTC,"ghci has a simple debugger -- if you are an expert in gdb, it's not as good, but for relatively simple tracing and printing, it works."
haskell,36s0ii,Tekmo,1 point,Fri May 22 03:16:02 2015 UTC,Can you give an example of code like that where (I assume) laziness either reorders or does not show some of your debugging output at all but you care about intermediate results that can not be checked by calling the relevant function on the REPL directly?  Just wondering since I am a strong proponent of print debugging in other languages but hardly ever use it in Haskell.
haskell,36s0ii,k-bx,1 point,Fri May 22 22:41:51 2015 UTC,"Not that I suppose it is everything, but:  https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/release-7-10-1.html Ctrl-f DWARF  More in 7.12 I am told."
haskell,36s0ii,bss03,4,Mon May 25 10:19:32 2015 UTC,"What I love about lazzines, is it unifies unary functions and variables (ome people argue that unary functions doesn't exist in haskell but i'm speakinp of things of type a).  I can write things like   maybe default id x   or  r = MyRecord {a=default} ... r { a = 1 }   Without having to worry about the fact that default is a value or a function to call. In imperative, to not have default called unnecessarily, I would have to pass it as a function, and call it when needed. This is usuall fine, but for each function I write, I have to decide if it should take an a or an () -> a.  This problem is similar to accessors which needs to be evaluated, you have to do r.getX(). Ruby tries to solve this problem by desugarising r.getX or (f) to r.getX() or f but the (huge) drawback is you then have no way to talk about f (You need to use either Proc.new { f } which is heavy or  ""f"" as string but then you have no garanty when you are evaluating it that you call function you intended too.  Lazzy evaluation solves this problem in a really neat way. In fact, I don't really see the benefit of lazzyness until I need a sort of pointer to function until I  realize that I don't  need it. For example, I had this caching problem when I needed something a bit similar to a make file where I need to compute a value IO a depending on a file, and cache the result. I start creating a cache datatype until I realized I just needed IO a. All the dependency tracking could be done in the value itself.  cache :: name -> IO a  -> IO Bool -> IO a cache name build needRebuild = do            rebuild <- needRebuild            if rebuild             then do                  value <- build                  save name value                  return value             else                  value <- load name                  return value   I can then created a cachable value   x = cache ""x"" my_function (check_stale ""x"")   and use it with any function expecting an IO a value  main = print =<< x   Ok, some people will say it's a bad example because I'm not using a but IO a therefore it's not really a unary function, but it is, in a strict language I would have to use () -> IO a or something to make the distinction between something evaluated and something to evaluate.  Then, indeed lazzynes as a huge cost, writting a program which works in test, but doesn't work in production because inputs are too big and not being able to do anything about it is a big problem. But that's what Haskell is about, it's pure and lazzy. If you don't want pure and lazzy there are plenty of alternative out there (OCaml F# etc ...)"
haskell,36s0ii,akurilin,1 point,Fri May 22 17:55:14 2015 UTC,"Yeah, I think the IO argument is a bit weak. In my Python Effect library, I can (re-)use Effect objects in exactly the same way, even though Python is strict. Values of type IO (or Effect) are just data describing actions; that's a different issue entirely from laziness."
haskell,36s0ii,bss03,7,Fri May 22 20:49:41 2015 UTC,"I would happily do away with laziness in exchange for stack traces. I have to resort to putting calls to Debug.trace with line numbers when debugging, which is insane."
haskell,36s0ii,k-bx,10,Thu May 21 18:31:35 2015 UTC,Haskell has stack traces: Instructions here
haskell,36s0ii,Taladar,5,Thu May 21 20:03:21 2015 UTC,"Does it still mean you have to compile executable for profiling? Because when I tried to run such program on production it was too slow to be usable, unfortunately."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,4,Thu May 21 22:58:06 2015 UTC,"For now, I think so.  GHC 7.12 is supposed to give us profiler-free stack-traces, I think."
haskell,36s0ii,Taladar,4,Thu May 21 23:49:15 2015 UTC,"Oooh, that's excellent."
haskell,36s0ii,Faucelme,5,Fri May 22 03:14:30 2015 UTC,"Here's the ticket.  I'd say things are close, but they could still slip."
haskell,36s0ii,theonlycosmonaut,4,Fri May 22 03:29:17 2015 UTC,This is really the one thing that holds haskell from being recommended to novices. I remember how hard it was for me to debug without it.
haskell,36s0ii,drb226,6,Fri May 22 07:12:21 2015 UTC,"Are you also willing to sacrifice tail call optimizations for it?  I honestly can't say that I ever needed to know the exact stack trace while writing Haskell, at most I would have liked the location of the error/undefined I encountered before I stopped using partial functions."
haskell,36s0ii,nikita-volkov,2,Thu May 21 19:38:47 2015 UTC,TCO exists in strict languages too.
haskell,36s0ii,nikita-volkov,6,Thu May 21 19:47:54 2015 UTC,"It is another way to produce confusing stack traces though, quite independently of the strictness/laziness issue."
haskell,36s0ii,nikita-volkov,3,Thu May 21 20:02:32 2015 UTC,"Actual problem: I'm thinking of decorating each node of a tree with a pointer to its parent (the ""decorated"" parent, I mean). I think laziness would help here. How would I do this in a pure, strict language?"
haskell,36s0ii,pdobsan,3,Thu May 21 21:18:39 2015 UTC,Probably by using some sort of opt-in mutability like ST?
haskell,36s0ii,twistier,3,Fri May 22 03:00:48 2015 UTC,"Spoilers for lazy language:  data Tree a = Tree a [Tree a]   deriving Show  newtype DecoratedTree a = Decorated   { runDecorated :: Tree (Decoration a) }  data Decoration a = Decoration   { parent :: DecoratedTree a   , value :: a   }  decorate :: Tree a -> DecoratedTree a decorate fa = root where   root = decorateWithParent root fa  decorateWithParent :: DecoratedTree a -> Tree a -> DecoratedTree a decorateWithParent parent (Tree a children) = t where   t = Decorated $ Tree (Decoration parent a) children'   children' = map (runDecorated . decorateWithParent t) children   For a pure/strict language, you still need some way to tie the knot."
haskell,36s0ii,pigworker,3,Fri May 22 04:17:23 2015 UTC,"On top of a pile of commonly known practical issues of laziness, I can't help but find that it could be presented as an abstraction, which itself forms a perfect monad. E.g.,  newtype Lazy a = Lazy (() -> a)   With evident instances for the following:  instance Functor Lazy instance Applicative Lazy instance Monad Lazy    Just imagine how cool it would be to have yet another essential functionality be implemented in a library with those perfect universal abstractions!  As a teaser, here's how the lazy Stream, which we call List, could be implemented:  data Stream a =   Cons a (Lazy (Stream a)) |   Nil   Having some auto-memoization optimization in the compiler would result in () -> a being computed just once, thus making this abstraction essentially completely reproduce the behaviour of thunks."
haskell,36s0ii,ocharles,3,Fri May 22 19:52:06 2015 UTC,"An even cooler observation is that this pure stream actually makes just a special case of a strict list monad transformer in that case:  newtype ListT m a = ListT (Maybe (a, m (ListT m a))) type Stream a = ListT Lazy a   while a strict pure list is over Identity:  type List a = ListT Identity a"
haskell,36s0ii,pigworker,1 point,Fri May 22 20:08:10 2015 UTC,"Having some auto-memoization optimization in the compiler would result in () -> a being computed just once, thus making this abstraction essentially completely reproduce the behaviour of thunks.   And if that's not an option, we can have an explicit implementation of a thunk:  newtype Thunk a = Thunk (IORef (Either (() -> a) a))  thunk :: (() -> a) -> Thunk a thunk f =   Thunk $ unsafePerformIO $ newIORef (Left f)  unthunk :: Thunk a -> a unthunk (Thunk ref) =   -- Synchronisation is not an issue here,   -- since there's nothing dangerous in two threads occasionally computing the same result.   -- That would be the price of not having to pay for locks-keeping overhead.   unsafePerformIO $ readIORef ref >>= \case     Left f -> do       let a = f ()       writeIORef ref (Right a)       return a     Right evaluated -> return evaluated"
haskell,36s0ii,_AndrewC_,4,Sat May 23 04:31:31 2015 UTC,"There is nothing new under the sun, the arguments around laziness have been going on for ever. Here are two blog posts worth reading including the long comments threads they generated:   The Point of Laziness More Points for Lazy Evaluation   Kind of point and counterpoint."
haskell,36s0ii,PM_ME_UR_OBSIDIAN,2,Thu May 21 20:46:50 2015 UTC,"Applicative, for example, is super annoying with opt-in laziness. Imagine what that is like... Now, think about how much like Applicative most Haskell code is (in this way). I can't imagine writing such high level code that I do with Haskell without it being a non-strict language."
haskell,36s0ii,alt_account10,6,Fri May 22 00:21:21 2015 UTC,Hilarious. Applicative is super-annoying because it requires any notation beyond the blank space of application.
haskell,36s0ii,PM_ME_UR_OBSIDIAN,2,Fri May 22 00:51:54 2015 UTC,"I would love to solve that in Haskell one day, but the mere suggestion that you can drop syntax and still have applicative effects seems to terrify some people."
haskell,36s0ii,augustss,4,Fri May 22 08:37:27 2015 UTC,"You can do it if you're willing to be a little clearer in the structure of types about which parts characterize effects and which parts values. Once the effect/value separation is explicit, you can typecheck values by unification (I've got this, I want that, so this must be that), as usual, and typecheck effects by inclusion (program wants to footle; is footling one of the things we can handle?).  Haskell only forces funny extra syntactic noise for monadic and applicative programming upon us to disambiguate the effect information in types. The syntax tells us in which positions the type should be interpreted as effecty value and in which the whole type is the value type. The upshot is that control structures are slick and boring ordinary programs that do stuff are clunky."
haskell,36s0ii,chreekat,1 point,Fri May 22 09:02:36 2015 UTC,I think twistier may have meant that Applicative would be super annoying without laziness by default.
haskell,36s0ii,augustss,3,Sat May 23 09:19:40 2015 UTC,"From my reading of this thread, 90% of the advantages of laziness have to do with lazy lists, and those also exist in strict languages."
haskell,36s0ii,leimy,10,Thu May 21 19:54:12 2015 UTC,"Since I started reading Purely Functional Data Structures this week, I'll leave this here:   Most (sequential) functional programming languages can be classified as either strict or lazy , according to their order of evaluation. Which is superior is a topic debated with religious fervor by functional programmers. The difference between the two evaluation orders is most apparent in their treatment of arguments to functions.  In strict languages, the arguments to a function are  evaluated  before the  body  of the  function.   In lazy  languages,  arguments are  evaluated in a demand-driven fashion; they are initially passed in unevaluated form and are evaluated only when (and if!) the computation needs the results to continue.  Furthermore, once a given argument is evaluated, the value of that argument is cached so that if it is ever needed again, it can be looked up rather than recomputed. This caching is known as memoization [Mic68].  Each evaluation order has its advantages and disadvantages, but strict evaluation is clearly superior in at least one area:  ease  of reasoning about asymptotic complexity.   In strict lan- guages, exactly which subexpressions will be evaluated, and when, is for the most part syn- tactically apparent.  Thus,  reasoning about the running time of a given program is relatively straightforward. However, in lazy languages, even experts frequently have difficulty predicting when,  or even if,  a given subexpression will be evaluated.  Programmers in such languages are often reduced to pretending the language is actually strict to make even gross estimates of running time!  Both evaluation orders have implications for the design and analysis of data structures. As we will see in Chapters 3 and 4, strict languages can describe worst-case data structures, but not amortized ones, and lazy languages can describe amortized data structures, but not worst-case ones."
haskell,36s0ii,mjmrotek,1 point,Thu May 21 23:37:28 2015 UTC,Excellent stuff!
haskell,36ugz6,peterlew,11,Fri May 22 05:45:55 2015 UTC,"You can do State (p,q) a. You could also use a StateT transformer but if you just need two of the same thing that seems unnecessary."
haskell,36ugz6,Dickferret,7,Fri May 22 06:00:46 2015 UTC,"I'd say make the state a record containing the two maps, with descriptive names.  data Foo = Foo {   bar :: Map a b,   baz :: Map c d }  type MyState a = State Foo a"
haskell,36ugz6,Tayacan,2,Fri May 22 21:27:59 2015 UTC,"The latter StateT p (StateT q Identity) a also prevents you from using the MonadState type class (i.e. get / set / put) for the inner state.  The best way is to use tuples or records, on more complex state."
haskell,36ugz6,mbruder,11,Fri May 22 17:22:14 2015 UTC,"Another option is using the ST monad, which lets you create as many STRefs as you want to get/put from. ST is very fast as well.  A more ambitious option is going for the vector library and trying to avoid having any intermediate data structure at all."
haskell,36ugz6,WarDaft,7,Fri May 22 07:06:10 2015 UTC,"You can also use the at lens:  ins = do     sMapX . at 5 .= Just ""five""     sMapY . at 7 .= Just ""seven""     sMapY . at 5 .= Nothing  -- Delete a key"
haskell,36ugz6,Tekmo,4,Fri May 22 22:34:43 2015 UTC,"IIRC, there's a way to do this using lens, but I don't know what it is (something about zoom, maybe):  Suppose I have a computation that uses State Int and another that uses State Bool (or also, a different State Int). I would like to run them both in an overarching computation with with State (Int,Bool). How do I do this conveniently?"
haskell,36ugz6,rpglover64,3,Fri May 22 23:53:34 2015 UTC,That's exactly what I was looking for. Thank you!
haskell,36ugz6,rpglover64,1 point,Sat May 23 01:10:06 2015 UTC,"The advice people gave below is great, but I'm more curious which eulers you are solving where you need this? I've solved a decent amount myself. Could you say one of the problems you are solving?  I'm betting there are other ways to accomplish this without introducing State into it."
haskell,36ugz6,pridefulpropensity,1 point,Sat May 23 01:35:25 2015 UTC,"Yes, the advice I got here is really helpful and exactly what I was looking for! Thanks /r/haskell :)  I'm working on #155, Counting Capacitor Circuits. For some reason this one's really stopped me in my tracks. I've since moved on from this approach, but my attempt was to store in a stateful map the number of circuits that could be formed using a certain number of capacitors in each of two essentially different ways: those that are fundamentally parallel and those that are fundamentally in series. So I needed a stateful Map Int [Values] for series and and a stateful Map Int [Values] for parallel. The computation of one depends on the other, so they needed to be in state at the same time.   I've actually used State in a pretty good portion of the problems since around #100. I might not be being creative enough but I intuitively see maps as the way to reduce duplicate computation, maybe you have advice on asking Haskell to remember certain values?"
haskell,36ugz6,pridefulpropensity,1 point,Sat May 23 11:40:03 2015 UTC,If you are solving the later problems then that is completely understandable. I guess I just misread your post. I usually see people solving the earlier problems and just assumed you were as well.
haskell,36uxym,sammecs,15,Fri May 22 09:31:37 2015 UTC,"There is a growing number of companies using Haskell, FWIW. I'm not saying this is or isn't a big deal, but it's true."
haskell,36uxym,AlpMestan,6,Fri May 22 10:40:58 2015 UTC,I sardonically mentioned Haskell as an option and my coworkers jumped at it.  I was very surprised and I am now very happy.
haskell,36uxym,codygman,9,Sun May 24 17:30:47 2015 UTC,What will happen to Haskell in the future?   Same thing that happens to it now: gradual progress.
haskell,36uxym,vagif,3,Fri May 22 18:08:40 2015 UTC,"I feel like the progress is actually speeding up. If it can continue to accelerate, it'll be a testament to the inherent value of the paradigm. Most OO Systems collapse eventually under their own weight of the spaghetti they inevitably become. Haskell, on the other hand, continues to show more and more potential."
haskell,36uxym,mallai,3,Fri May 22 23:47:03 2015 UTC,Yum!
haskell,36uxym,I_Like_Spaghetti,4,Fri May 22 23:48:08 2015 UTC,"Most OO Systems collapse eventually under their own weight of the spaghetti they inevitably become. Haskell, on the other hand, continues to show more and more potential.   I hope so.  I feel like Haskell is starting to sag under the weight of its complexity, too.  It's a race between the variety and scope of the challenges placed on the language, and the discovery of simpler and more elegant ways to work with those challenges.  For a long time, IMO, Haskell thrived because the growth of those challenges was steady, but slow; and the pressure for change came from the academic world and was felt in the language and compiler, where pace of change is necessarily limited and consensus-building is a fact of life.  As the pace picks up, the Haskell community is feeling pressure to produce answers to more problems faster; and the pressure is directed at libraries, where anyone in a weekend can upload something to hackage, and exercise exclusive one-person control over where it goes from there.  The results are predictable: a lot of great ideas, but also a lot of incidental complexity.  To the inventor, every idea seems important enough to make sacrifices for it.  After all, how difficult can it be to learn the complicated nuances of my one library?  Until, of course, it's not just one, but many such libraries.  And now we have libraries that are considered by many to be almost ""core"", that introduce hundreds of cryptic binary operators, and intimidating monad stacks taken for granted as being necessary to real-world Haskell programming.  That inventor's myopia isn't new... but in the past, it led to the publication of a paper in some journal or conference proceedings, and that was the start to a long, long journey to general acceptance.  That journey has been criticized as too long, but it allowed time for reality to set in, and for the real cost to be seen.  Haskell hasn't collapsed under its own complexity... but I'm afraid it's rather obviously sagging in places. :("
haskell,36uxym,cdsmith,5,Sat May 23 03:48:30 2015 UTC,How is this any different from the myriad of disposable Javascript libraries that pop up every week?
haskell,36uxym,Tekmo,1 point,Sat May 23 06:07:54 2015 UTC,"It's not!  I just think we should be a little cautious about bragging that Haskell doesn't share this problem because it's inherently immune.  The truth is, Haskell has postponed this fate because people have worked very hard at it, but it remains a distinct threat."
haskell,36uxym,cdsmith,3,Tue May 26 14:03:51 2015 UTC,The reason I made the comparison to Javascript is because I believe we shouldn't worry about improving library quality and we should instead focus on building killer apps and platforms that drive Haskell adoption.
haskell,36uxym,Tekmo,7,Tue May 26 17:09:32 2015 UTC,"This question doesn't make much sense. What does ""popular"" mean ? Reddit's Haskell sub has roughly half as many subscribers as the Java sub, and about 70% of that of C++. Does that mean that it is hugely popular, or that Haskell ""won"" ? Which metric would ? Why ? Would it even matter ?"
haskell,36uxym,bartavelle,6,Fri May 22 09:58:30 2015 UTC,And the #haskell IRC channel is one of the bigger programming language IRC channels there is!
haskell,36uxym,kqr,5,Fri May 22 10:38:43 2015 UTC,"I guess he’s refering to the fact that currently, the industry’s adopted OO and imperative programming almost everywhere. And I think Haskell won’t be the next big hit in the industry. Because people are used to OO and imperative programming, and switching to a FPL is, well, hard. Yes, adopting Haskell would have a huge impact on processes in companies – trainings, recruitment, and so on.  That being said, I try to convert people around me to Haskell, and I spread its ideas at work. :)"
haskell,36uxym,_skp,4,Fri May 22 10:13:40 2015 UTC,"One could also argue this from the other point of view, not necessarily about Haskell in particular but that a lot of things are very wrong with the current programming mainstream and that some big changes will be required anyway to bring the huge numbers of failed or delayed or over budget projects down to a more manageable level.  The fact that many projects today suffer from the same bugs over and over again is certainly an indication that there is room for revolutionary improvement though when or where this improvement will actually happen (or even if it will if one is a pessimist) is hard to say."
haskell,36uxym,Taladar,2,Fri May 22 13:31:36 2015 UTC,"even though big changes might be required, It is probably very hard to change. Just as it is hard to take a popular language such as Java or C++ and re-vamp it. which is why you hardly see this things happen."
haskell,36uxym,gilmi,4,Fri May 22 13:52:44 2015 UTC,Some language changes are impossible to apply to existing languages (for less than the same effort required as doing so in an entirely new language and getting the exact same libraries written in the new language I mean).  Take for example the Haskell separation of effects into the IO monad. Or the efforts to add static type checking to dynamically or even weakly typed languages.
haskell,36uxym,Taladar,2,Fri May 22 14:23:29 2015 UTC,"Or the efforts to add static type checking to dynamically or even weakly typed languages.   Gradual / incremental typing is a real thing.  Parts of the program that can not be statically type-checked continue to carry around type tags and be type-checked at run time.  Parts that can be statically type-checked can elide run-time checks and (if they are large enough) drop the type tags from values produced and consumed inside them.  The boundary expressions are where compiler warnings or other diagnostics / reports are generated.  There's still plenty of work to be done to make it all seemless without sacrificing any type-system power.  (Many unityped or type-tagged languages existing internal calculi don't really deal well with higher kinds, dependent types, existentials, etc.)  Arguably though, it's easier to start from something with a really nice static type system and then add a ""dynamic dialect"", but if done well it will still allow you do quickly whip up a program that works on your sample data without ever seeing a type error, and then gradually type parts of it rather than re-write in something other than bash. ;)"
haskell,36uxym,bss03,5,Fri May 22 19:17:43 2015 UTC,The point was that to do so for an entire library ecosystem would be about as much work as to rewrite the entire set of libraries in a new language.  Some of the choices made in programming idioms in the absence of a static type system don't lend themselves well to adding types later.
haskell,36uxym,Taladar,2,Fri May 22 19:30:47 2015 UTC,"The point was that to do so for an entire library ecosystem would be about as much work as to rewrite the entire set of libraries in a new language.   Agreed, but gradual typing allows a smooth transition, instead of having to do all the work (at least for a single module) before getting any of the advantages of static typing.   Some of the choices made in programming idioms in the absence of a static type system don't lend themselves well to adding types later.   True enough.  Usually throwing enough sum types at the problem can give you something that works even if it is calling out for deprecation and rewriting, but not always."
haskell,36uxym,bss03,1 point,Fri May 22 19:34:36 2015 UTC,"You don’t take in account the fact that there’re a lot of services companies that don’t actually give a brezel about whether we could replace languages with better alternative. They have a lot of people who happily write shit, why would they want to change that, as long as they do profits?"
haskell,36uxym,_skp,6,Fri May 22 14:48:28 2015 UTC,"Well, if I was a believer in market forces I would say that they will be out competed by those who do change and adopt better languages but since I have long ago lost faith in that particular mechanism I wrote that last paragraph in my previous post."
haskell,36uxym,Taladar,2,Fri May 22 14:56:14 2015 UTC,Market forces work just fine! It's just that the market exerting said forces might not be the one you're looking at.
haskell,36uxym,tejon,2,Fri May 22 20:10:49 2015 UTC,"Actually market forces depend on that perfect being, the one that can judge quality of a product and will decide on quality per price. Decisions on programming languages and similar things seem to be much more hype and risk aversion driven than based on merit."
haskell,36uxym,Taladar,3,Fri May 22 20:34:33 2015 UTC,"Disclaimer: the following pedantic mini-rant should be understood as aimed toward the wider cosmos; not at the individual to whom I am replying, who has done nothing to deserve a bunch of hot air blown in his face.  You're using the politician's definition, which I agree is based on fantasy and wishful thinking. But scrape off a few layers of misdirection and willful ignorance, and the concept of market forces is identical to that of natural selection, which boils down to tautology: that which is not eliminated, continues.  The easy and common fallacy when looking at any selective system is to classify things as either ""agent"" or ""environment,"" when in the total analysis nearly everything acts as both in countless systems at once. Supposed agents can apply pressure to an environment which acts upon them, creating a completely different dynamic than naive prediction would suggest. Mankind pumps carbon into the atmosphere; corporations buy the loyalty of congressmen; the environment changes, invalidating assumptions based on the previous environment, but the underlying mechanism still applies.  That's what I was getting at above. Market forces are as absolute as 1 + 1 = 2, and writing them off is simply wrong. If they're not working the way you expect, it's because you're looking at the wrong market."
haskell,36uxym,tejon,3,Fri May 22 21:33:41 2015 UTC,"Well, there is certainly some selection pressure going on, I completely agree with you there. However I think the economists definition of the term is simplistic and mostly wrong in taking only the financial pressures into account when there are a myriad other inter-locking effects at work here, not the least of which are deception (making it hard to judge a product accurately) and both irrational rejection of old/new things just because they are old/new."
haskell,36uxym,Taladar,1 point,Fri May 22 21:57:37 2015 UTC,"I think the economists definition of the term is simplistic and mostly wrong   I think it depends on the economist, but yeah, no real argument on this point."
haskell,36uxym,tejon,2,Fri May 22 22:20:43 2015 UTC,Why not add some OO features to haskell? Purescript has row types and that's enough apparently. What would it cost to add row types to haskell? I don't know. Ghc is a scary place. Would probably need a gsoc to get it done.
haskell,36uxym,rdfox,3,Fri May 22 22:17:00 2015 UTC,I know I'd definitely love it if I could have Elm/PureScript-like records instead of Haskell records.
haskell,36uxym,gilmi,1 point,Sat May 23 10:13:10 2015 UTC,"What do you mean OO features? OO is the wrong word to use to talk specific. Please add some details.  If you’re refering to things like gluing methods with data, I’m strongly against that. If you’re refering to inheritance, I’m strongly against that. If you’re refering to scoping, like in a.x.y = 3, well, that doesn’t suit functional programming because that implies mutability. However, the correct way to do that in a FPL is by using the concept of lensing, and we already have several libraries to work with lenses in Haskell."
haskell,36uxym,_skp,1 point,Sat May 23 12:52:59 2015 UTC,"The benefit I (not an expert) see from row types is straightforward FFI with OO libraries in a language like JavaScript or C++. It is practical to enable interoperability with classes, methods and inheritance for the purpose of FFI while in the same breath discouraging the practice in FP code. The reason I still use Python, C and C++ a lot is plenty of awesome libraries that I can't avoid. Something to learn from Microsoft is embrace, extend, extinguish."
haskell,36uxym,rdfox,7,Sat May 23 13:57:53 2015 UTC,"Do you think Haskell can be a big deal in the future or not?   Haskell has not reached it's peak; it will be even bigger in the future.  But, on a longer timescale it will likely die out.  I don't think it has crossed the threshold of immortality and I tend to doubt it will.  (Despite my love for coherent type classes, it's a stumbling block for modularity and I think that may end up being what prevents Haskell from passing the threshold.)   Does OOP offer more possibilities?   OOP does not offer more possibilies.  But, objects and messages are not an abstraction that will go away.  Luckily, you can do OOP in Haskell (and most other lanaugages).  Scala blends the two styles fairly well, though I do miss purity and parametricity guarantees.   Or will they both coexist just as they do now?   Yes, and things like Scala, F#, and OCaml illustrate how well that can work.  Pure functional objects are a pattern that can be leveraged in Adga, Idris, Haskell, etc. today.  Monadic / stateful objects may also arise in the future in languages that have ""better"" core calculi than Scala / F# / OCaml, though that is yet to be seen.  (Dealing with some of the rough edges around monadic lenses may help here.)   I just wonder if there clearly is a ""winner"" between OOP and FP.   ""Winner"" is really quite vague.  First-class function-like objects and a compact syntax for them will be a factor in most future languages.  (Oddly enough, I think you can thank Javascript for that more than you can thank Haskell or Lisp.)  But, I also don't think the core abstraction of OOP -- objects and messages -- will go away either.  Some of the work in Idris around verifiable communication protocols might feed back into OOP; it's design-by-contract on a level Eiffel wishes it had.  In effect, we'll all be winners if we can use any or all of the abstraction and techniques to more quickly produce better code that really improves quality of life."
haskell,36uxym,bss03,5,Fri May 22 19:07:40 2015 UTC,"This question can be read in multiple ways: as an oversimplification (""do you love mommy or daddy best?"") or as an exercise in forecasting tech trends. The problem I see with broad Hs adoption is the lack of education; most of the CS taught outside of CS schools is Java or C based (I'm not counting all that ""learn <Rails/JS framework du jour> in half an hour"" line noise as CS). So essentially as a Hs community we have to generate 1. meaningful use cases 2. excellent documentation for all levels, insisting on how the language encourages best programming practices without all the object-factory-factory clutter.  Periodically, hype chasers ask this same question, in an attempt to stay abreast of innovation but without committing any real time to understand it. What's a ""winner"", for programming languages? adoption? programmer efficiency/satisfaction? how do we measure these things? Or some efficiency figure, idk like balanced use of threads ? I've recently introduced Hs to a group of colleagues who had never been exposed to FP. Partial application was a huge hit, static typing was brushed off as a ""feature"", with the claim that ""there are tools for static analysis in other languages too"", type inference made people curious but since we're not PL theorists it looks a bit like magic.  In my mind the winner is clear; Haskell makes you think more about the problem at hand and catch modeling errors early. Cognitive advantages perhaps are not easy to sell to management, but speed and ease of maintainance are."
haskell,36uxym,ocramz,15,Fri May 22 10:31:39 2015 UTC,I think there is no direct competition between the two considering there are languages which attempt to combine both.  I also consider OO to be a clear loser even without any competition because it has been clear for a while now that its whole abstraction model (attempting to hide state) is fundamentally flawed and leads to an explosion in complexity.  The problem with OO is that you can not abstract away the effect state has on the behaviour of a program very well as long as you expose any hint of the fact that the state changed. Any bit of different behaviour depending on that state (e.g. a class behaving in one of four ways would be 2bit of that) contributes to the number of cases you would have to take into account and test. And you can't properly classify which of those cases can or can't occur because your state is abstracted away and not visible.
haskell,36uxym,Taladar,2,Fri May 22 13:39:28 2015 UTC,"you can not abstract away the effect state has on the behaviour of a program very well as long as you expose any hint of the fact that the state changed.   You can hide the details of how you maintain that state, but yes hiding the fact that the state exists (and what operations cause or are sensitive to chages in it) does seem to have become a rather rotten failure."
haskell,36uxym,bss03,2,Sat May 23 16:11:24 2015 UTC,"Exactly...this is a particular problem when testing and you can't tell which test cases behave in identical ways anyway and which might differ. This means you can not easily get full branch coverage.  The same problem also occurs when debugging of course, when you have to determine which exact state matters to reproducing the problem.  And of course in a similar way in reverse, when writing code, you can't easily see which branch you didn't write at all because that particular combination of state didn't occur to you and it was not obvious that it could even occur."
haskell,36uxym,Taladar,1 point,Sat May 23 20:58:17 2015 UTC,I also consider OO to be a clear loser even without any competition because it has been clear for a while now that its whole abstraction model (attempting to hide state) is fundamentally flawed and leads to an explosion in complexity.   Well said.
haskell,36uxym,cies010,4,Fri May 22 21:34:00 2015 UTC,Yes. I really just like that first part.   I also consider OO to be a clear loser even without any competition   Amen.
haskell,36uxym,hiptobecubic,5,Sat May 23 06:29:51 2015 UTC,"Purely anecdotal evidence so I may be completely wrong, but from what I've seen more companies are beginning to get their feet wet with functional programming. However, not necessarily with Haskell. I think for many places, Haskell is too drastic of a switch from their traditional OOP. Instead, languages like Scala, Clojure and Erlang are gaining ground. That's not to say that Haskell use isn't growing, but I think from a company's perspective, a language like Scala is something that they can ease into because they have the option of programming in either paradiigm."
haskell,36uxym,semi225599,4,Fri May 22 12:08:01 2015 UTC,"Haskell is not very popular yet   As others pointed out: never it has been more popular. And in language geek communities it is even quite a well established name nowadays.   Do you think Haskell can be a big deal in the future or not?   I think it is already. See for instance this graph, it's a very influential language. It might that not Haskell, but one of the languages influenced by Haskell becomes the ""big deal"" (or at least a bigger deal then Haskell ever gets to be).  In the cast a post-Haskell language becomes the must-bigger-then-Haskell-deal (which is quite likely), that community will most likely use Haskell as an important starting point for looking at reasonably mature libraries in a similar paradigm.  This all stems from the fact that not many languages are in the same prog. lang. paradigm intersection as Haskell. In contrast look at OOP/imperative -- a very well explored design space with very little recent innovations.   Does OOP offer more possibilities?   Possibilities for what?    Or will they both coexist just as they do now?   Sure... Look at COBOL and C; still happily coexisting along with the others.   I just wonder if there clearly is a ""winner"" between OOP and FP.   For a winner you need to define a game. When you get to choose a technology for a project you work on, then after some time you can get the impression that X-paradigm or Y-language was a winning choice.  By what criteria you want to define the winner? You only mention ""popularity""...."
haskell,36uxym,cies010,3,Fri May 22 22:04:05 2015 UTC,"Let me be the kool-aid drinker here and say that OOP could easily be subsumed entirely by FP. Think about it for a moment... what, exactly, would an immutable class declaration look like? The answer is a data declaration. Consider:  module Yarr where  data SomeIntObj      = IntObj      { op :: SomeIntObj -> SomeIntObj     , otherOp :: SomeIntObj -> SomeIntObj -> SomeIntObj     , self :: Int     }  instance Show SomeIntObj where show = show . self  (.:) o m = m o o  increment c i = i {self = self i + c} multOther i1 i2 = i1 {self = self i1 * self i2} newCounter c = IntObj (increment c) multOther  counter1 = newCounter 1 0 counter2 = newCounter 3 0  *Yarr> counter1 .: op 1 *Yarr> counter1 .: op .: op 2 *Yarr> counter1 .: op .: op .: otherOp $ counter2 .: op 6   This is some syntactic sugar and mutability away from actual OO code. And well, you know, the elephant in the room of record namespacing.  If you think about it, a data declaration actually describes a category of OOP classes that can be specialized via method declaration and used in place of each other it some form of crazy mutual subtype polymorphism.  </kool aid>"
haskell,36uxym,WarDaft,2,Fri May 22 13:33:34 2015 UTC,"We actually used to have OO-Haskell, but it seems to have gone the way of the dodo."
haskell,36uxym,bss03,2,Fri May 22 19:20:23 2015 UTC,http://haskell.1045720.n5.nabble.com/NoOO-languages-tp5809663p5809705.html
haskell,36uxym,agocorona,1 point,Fri May 22 18:52:40 2015 UTC,"Yes Haskell and all other functional programming languages can be a ""big deal"" in the future the reason is discussed in the following article: http://www.sciencedaily.com/releases/2015/01/150123081725.htm which describes massive savings in chip design."
haskell,36ticq,alexvieth,9,Fri May 22 00:11:00 2015 UTC,I'm about to give a talk (in an hour or two)  on using cofree comonads to do this kind of interpretation.   The nice thing is that you can use the product of the functors on the cofree side to factor out the different bits of the interpreter.   I'll be writing about this after I give my talk (and catch up on sleep).
haskell,36ticq,dalaing,2,Fri May 22 00:25:04 2015 UTC,please do ;)  I'd been thinking about this recently.
haskell,36ticq,sambocyn,3,Fri May 22 04:20:19 2015 UTC,"I've posted a link to the slides here, along with some code.    Some of it is still a work in progress and needs quite a bit of cleaning up, but it might do for communicating the basics of the idea.  I'll clean up / expand on the code as I start to blog about this and various related things that I've been playing around with and getting excited about."
haskell,36ticq,dalaing,1 point,Sat May 23 03:27:53 2015 UTC,Thanks!
haskell,36ticq,sambocyn,4,Sat May 23 04:28:44 2015 UTC,Thanks for this. I've been thinking about how to make injection easy like that via the data types ala carte method for a while but wasn't sure it would work.  This is looking like a pretty refined way forward.
haskell,36ticq,christian-marie,3,Fri May 22 09:19:18 2015 UTC,Can someone compare an approach like this to a generalized Effect system like extensible-effects? Does extensible-effects (or any of the implementations on hackage) have all the same properties as this approach?
haskell,36ticq,radix,1 point,Fri May 22 21:16:12 2015 UTC,"I read some of the paper and it looks like this demonstration uses the same ideas.  The r in Eff r t is a list of functors, values of which may appear in the Eff r t term itself. These are suggestively-named functors like  data Reader r t = Read (r -> t) data Trace t = Trace String (() -> t)   or even the familiar  data PlusF t = Plus Int Int (Int -> t)   The functors are summed into the type Union r, and the free monad over this sum is used (by another name) in the definition of Eff:  -- This is another way to say Free (Union r) --   Free (Union r) t = Pure t | Join (Union r (Free (Union r) t)) data VE r t = V t | E (Union r (VE r t))  -- This is Codensity (Free (Union r)) t -- I only recently heard of codensity, so I don't know whether that's remarkable :) data Eff r t = Eff {     runEff :: forall w . (t -> VE r w) -> VE r w   }   Running an Eff r t amounts to interpreting every functor which appears in that list of types r, but instead of producing a term of some monad transformer stack like we do here, the handlers of extensible-effects stay in Eff, reducing the Eff r t to an Eff Void t or Eff (Lift m) t, which then yield a value and in the latter case an effect in m.  I can't say whether this direct free monad approach can do anything that extensible-effects cannot, or vice versa. It's cool to find the same ideas under the hood."
haskell,36ticq,radix,1 point,Mon May 25 04:11:19 2015 UTC,Thanks very much for the informative reply! I was particularly interested in that type union technique in both approaches. Very cool :)
haskell,36ticq,gtllama,2,Mon May 25 07:11:13 2015 UTC,"I spent some time today playing with this using my favorite example: a brainfuck interpreter.  The free monad for a bf interpreter can be neatly separated into data array operations and IO, so I think it makes an interesting example for this kind of modular approach. I knew this kind of thing was possible, but I hadn't got around to trying it (my free monadic brainfuck project).  Notes:   I changed FTrans to something totally different. When I wrote the instance for StateT, I found it somewhat unsatisfying, so I came up with this alternative. One interesting thing about it is that it allowed me to reuse the instance for StateT when implementing the instance for BFTapeInterpreter, in contrast with your instance for ModularPlusInterpreter which seems to require you to reimplement the instance for ReaderT. Did you know your injectF is just hoistFree inject?"
haskell,36u6z4,analphabetic,3,Fri May 22 03:47:52 2015 UTC,"ParsecT as implemented by the parsec package is a continuation-based monad, so you are unlikely to come up with a MonadFix instance for it.  However, there is an equivalent non-CPSed monad (IIRC, parsec v2 was based on it), and that one should admit a MonadFix instance."
haskell,36u6z4,roche,2,Fri May 22 13:36:16 2015 UTC,"Well, how it would work should follow in many ways from thinking about a ""list of successes parser"" as  newtype Parser a = Parser { runParser :: String -> [(a, String)] }   being   StateT String []   and the way that  instance (MonadFix m) => MonadFix (StateT s m) where     mfix f = StateT $ \ s -> mfix $ \ ~(a, _) -> runStateT (f a) s   indicates your fixed point of a parser wouldn't consume input and   instance MonadFix [] where     mfix f = case fix (f . head) of                []    -> []                (x:_) -> x : mfix (tail . f)   indicates how we take the fixed point of a list.  You can modify the code for lookAhead to make it work.  The trick is it gets a bit more complicated in the presence of monadic streams and I'm not sure how you're going to get that."
haskell,36u4xo,precalc,5,Fri May 22 03:28:38 2015 UTC,"Sure. Repa is (I think) slightly more expressive still than Accelerate, and a lot of optimisation work is being done on it here  and here that are not available (yet) in Accelerate (it's not fully integrated into the Repa library either, but work continues), although they may be ported over eventually. Right now Accelerate's main priority is to support streaming data, so that GPU memory isn't so easily exhausted.  Also, Repa is just a Haskell program, not an embedded language. This means you don't have the overhead of requiring, e.g, LLC on the users' computer, and the program isn't compiled on-the-fly at run-time. This is a pretty big advantage."
haskell,36u4xo,kamatsu,1 point,Fri May 22 05:37:01 2015 UTC,"This is basically right. Repa and Accelerate share a friendly rivalry, and there are advantages and disadvantages to each.  Saying that, one of the goals was to beat Repa (;"
haskell,36u4xo,tmcdonell,4,Sun May 24 04:59:27 2015 UTC,"Repa is a playground for the developers of Data Parallel Haskell, so there's that. I'd love to see DPH develop into something useful."
haskell,36u4xo,int_index,3,Fri May 22 04:50:49 2015 UTC,Repa and DPH and Accelerate are all made by the same research group.
haskell,36s6y1,thecity2,42,Thu May 21 18:19:59 2015 UTC,"well, the type of foldr changed."
haskell,36s6y1,simonmar,12,Thu May 21 18:51:29 2015 UTC,But that was a mistake. :)
haskell,36s6y1,augustss,5,Thu May 21 20:27:30 2015 UTC,Elaborate?
haskell,36s6y1,benediktkr,1 point,Fri May 22 01:04:31 2015 UTC,"Wait, how? Did a and b just get switched around?"
haskell,36s6y1,nosewings,17,Mon May 25 03:34:03 2015 UTC,"I think I've been a Haskeller for less than 15 years.  I don't know that much has changed as far as initial learning, although you might spend more time learning about Applicative, Traversable, and Foldable.  You know, since Applicative is now a superclass of Monad, Applicative and Traversable have a strong relationship, and Foldable is a superclass of Traversable.  GADTs, Associated type aliases / data types, Type / data families, Constraint kinds, Data kinds, etc. are ""advanced topics"" that I think either got an overhaul or have been added to GHC in the last 15 years.  Oh, most of us switched from Hugs to GHC, BTW.  Platform came and went.  I still like it, but most of the people that get to use more Haskell than I seem to tend toward just installing GHC and Cabal, even on MS Windows.  Stackage (STable Hackage) is a good alternative to hackage, and it also inspired LTS Haskell and a few neat CLI tools.  You should learn lens.  Most people encourage an avoidance of Lazy IO, but the original streaming library as fallen by the wayside.  Both pipes and conduit provide good streaming interfaces and both have a descent number of convenience libraries built around them.  There's more, too, but I'm out of time."
haskell,36s6y1,bss03,6,Thu May 21 19:55:39 2015 UTC,"15 years ago Applicative didn't exist, so before he worries about the implication of Applicative being a superclass of Monad he may wanna figure out what Applicative is :p"
haskell,36s6y1,merijnv,9,Fri May 22 16:43:08 2015 UTC,Modules can be in a hierarchy now.
haskell,36s6y1,stepcut251,5,Fri May 22 00:04:25 2015 UTC,It got an ecosystem with Hackage and Cabal and lots of packages.
haskell,36s6y1,Vektorweg,3,Thu May 21 18:27:34 2015 UTC,"The biggest change for me (though this could just be recency effects) is discovering ghcid, which will automatically reload your project into a ghci-like (I believe people have already covered how 'things GHC can compile' is basically the working definition of Haskell now) interpreter as soon as any file in it changes, giving you virtually instant type error feedback no matter what editor you use. It's also trivial to set up.  This isn't a change to the language, but I think it is the biggest change to the experience of using Haskell that I'm aware of. Right behind ghcid is cabal sandbox, though I suppose both of these are dwarfed by cabal-install itself."
haskell,36s6y1,WarDaft,7,Fri May 22 12:42:06 2015 UTC,"Holy hell is this a big ask.   There's a second language standard now... Haskell2010. It supports a crazy number of language suggestions, and you'll probably get a lot by just learning about those.  Also, were Monad Transformers a thing back then? I'd look into those as they can unify pure and impure functions"
haskell,36s6y1,cghio,6,Thu May 21 18:23:24 2015 UTC,"Also, were Monad Transformers a thing back then?   ...were Applicatives even a thing back then?"
haskell,36s6y1,kqr,7,Thu May 21 20:00:06 2015 UTC,"There's a second language standard now... Haskell2010.   ...and ironically, for better or worse, the latest GHC release is already way beyond Haskell2010..."
haskell,36s6y1,hagda,1 point,Thu May 21 18:53:25 2015 UTC,second language standard   Second?  What was the Haskell 1.4 report?
haskell,36s6y1,bss03,2,Thu May 21 20:00:10 2015 UTC,"Weren't the specs before '98 kind of in flux all the time? If memory serves me correctly, '98 was meant to give the language a stable base so that portable code could be written.  Also, I can correct myself a bit because even so, Revised '98 came out between '98 and 2010"
haskell,36s6y1,cghio,3,Thu May 21 20:56:34 2015 UTC,Was Applicative around back then?
haskell,36s6y1,absence3,15,Thu May 21 19:38:00 2015 UTC,"Yes, but not in Haskell."
haskell,36s6y1,pigworker,-12,Thu May 21 22:24:24 2015 UTC,The Brogrammers have discovered it ...
haskell,36s6y1,agambrahma,3,Thu May 21 19:55:46 2015 UTC,"Dunno why you're getting downvoted, the biggest non-technical thing to have changed in 15 years is the public profile and the nature of the community. These might be secondary issues but I don't think they are irrelevant to someone who wants to know what changed. A typical reaction from my colleagues when I mentioned Haskell back then was ""Pascal? Whew, old school..."" And the culture of programmers in general has changed quite a lot as I think most would agree. (I came across Haskell round about 15 years ago, haskell-cafe hadn't been going long and discussion there had an academic focus and even seemed a bit too polite compared to the all-flaming lisp community I was more used to.)"
haskell,36s6y1,jaybee,1 point,Fri May 22 13:26:15 2015 UTC,True .... thought I should have phrased it more like you just did right now :)  Appreciate the reply!
haskell,36pyb8,Categoria,5,Thu May 21 04:42:18 2015 UTC,"The basic tenet of programming with algebraic effects is that performing an effectful computation is separate from its interpretation.   I am having some difficulty understanding this statement. In what respect is performing the effectful computation separate than the interpreting of the computation? What is meant by ""context"" in the lines following the above quoted text?"
haskell,36pyb8,ExternalReality,7,Thu May 21 15:57:52 2015 UTC,"I think ""performing"" is perhaps a clumsy wording. Programs are written to an interface of the abilities they expect to be offered by their environment. Those programs can be run in any environment which implements the interface. The mere ability to issue a command chosen from the interface is indeed separate from the business of handling that command."
haskell,36pyb8,pigworker,2,Thu May 21 16:02:58 2015 UTC,Understood.
haskell,36mhfh,cocreature,23,Wed May 20 13:48:16 2015 UTC,How does this compare to language-c-inline?
haskell,36mhfh,kamatsu,17,Wed May 20 13:58:01 2015 UTC,"In inline-c we have a very simple core library which is easily extensible with additional anti quoters.  I wanted the core functionality to be very predictable, and leave fancier marshalling up to specific use cases.  In language-c-inline the marshalling works with a mix of hard-coded rules and user-supplied Template Haskell functions. We wanted to make the language to include the C code as simple as possible.  The inline C is spliced with a quasi quoter and no Template Haskell functions.  The inline C code specifies the Haskell variables to capture using anti-quoters, and the target types are all specified using C syntax.  As I say in the blog post I cared quite a bit that this is the case, to have confidence that what you're getting in C is what you expect.  Relatedly, only the anti-quoters are examined: the rest of the C code is not parsed and left verbatim, so we don't have to worry about eventual incompatibilities between the C compiler the user is using and the Haskell C parser that language-c-inline uses. We're also making sure that the infrastructure and build process is smooth.  The addTopDecl function is used to avoid having to populate tables at runtime like language-c-inline does, and I also employ various tricks to make sure that everything will work smoothly across builds.  For example, the names of the generated C functions is based on the hash of the contents of the function itself.  This is quite important to guarantee that repeated builds of the same file by cabal -- for example when compiling with profiling support -- result in the same C symbols being generated, while making sure that the the symbols are the same only if the C snippets in the module are the same.   This is what I can think for now :).  In short, the two libraries are very similar in spirit, but we coded inline-c to be better suited to our needs taking different design choices.  Some of the advantages above could be easily ported to language-c-inline, especially the ones in the last point."
haskell,36mhfh,rostayob,3,Wed May 20 15:03:54 2015 UTC,"I wanted the core functionality to be very predictable, and leave fancier marshalling up to specific use cases.   I think this is a good decision.  It makes for a little bit more pain, but C is always a pain.  I think this may be a win for flexibility and make this more usable than language-c-inline for those weird C corner cases."
haskell,36mhfh,bss03,11,Thu May 21 01:55:11 2015 UTC,This is amazing. Could one now write inline assembly using inline-c? That would blow my mind...
haskell,36mhfh,bitmadness,9,Wed May 20 18:44:48 2015 UTC,"Shouldn't be a problem, given that the inline C code is fed as-is (apart from the anti-quoted bits) to the C compiler :)."
haskell,36mhfh,rostayob,10,Wed May 20 19:44:15 2015 UTC,"This looks great! It’s smart to avoid parsing the embedded code as that is a fatal maintenance burden for other approaches.  I don’t think the intro is really on point, though. Traditional FFI approaches are often used in a “pay as you go” manner, too. You’re right that binding packages tend to rot, but the point, I think, is just to make it easier to write FFI bindings. If an extensive set of bindings is written with your approach, it will rot, too.   A minor issue with the article: the Haskell type of funIO doesn’t look right; and grep for “translated translated”."
haskell,36mhfh,acow,3,Wed May 20 15:26:51 2015 UTC,"I don’t think the intro is really on point, though. Traditional FFI approaches are often used in a “pay as you go” manner, too. You’re right that binding packages tend to rot, but the point, I think, is just to make it easier to write FFI bindings. If an extensive set of bindings is written with your approach, it will rot, too.    Well, we talked about what we wanted (and do) to use inline-c for: rapid prototyping using a mix of Haskell and C libraries.  In that context the possibility of quickly using a part of a large C interface in a specific manner exactly as we need was the intended goal and biggest advantage.  I suppose this is also a ""psychological"" issue: people often tend to think as bindings as a binary thing: either you have them or you don't.  inline-c tries to remove that barrier by facilitating the ""pay as you go"" approach, as you say.   A minor issue with the article: the Haskell type of funIO doesn’t look right; and grep for ""translated translated"".   Thanks!"
haskell,36mhfh,rostayob,6,Wed May 20 15:36:44 2015 UTC,"This looks like a wonderful library to me. For new low-level code I would almost certainty reach for Galois' Ivory yet, as the article describes, I really like this for quick and dirty integration with C. Nice!"
haskell,36mhfh,ExternalReality,3,Wed May 20 16:00:38 2015 UTC,"Has this gotten any better about handling out-pointer-arguments (e.g.)?  Last I looked at this (well, last time it was language-c-inline), I raised a few issues around all the different ways to marshal things in C and no one could answer them.  My own investigations into the source code seemed to indicate those types of marshalling where effectively impossible.  Personally, I find this way of talking to C code a bit of a hack that could make for some very brittle Haskell code, but I've not tried using it so maybe it ""just works"" in practice."
haskell,36mhfh,bss03,9,Wed May 20 19:17:28 2015 UTC,"I'm assuming that with ""handling out-pointer-arguments"" you mean C functions returning multiple values using pointer arguments.  We have facilities that make using such functions nice, specifically the withPtrs_ function.  If you have function  void c_function(int n, double x[], double *y, double *z);   where double *y and double *z are exit arguments, you can use withPtrs_ to allocate and peek the right pointers automatically:  (y, z) <- withPtrs_ $ \(y, z) -> [C.block| void {     ... complicated C code ...     c_function(n, x, $(double *y), $(double *z));   } |]   withPtrs_ will automatically allocate the pointers and peek them when the provided action terminates.  It works with tuples up to... 8 elements, I think.  There's also withPtr_, for a single pointer."
haskell,36mhfh,rostayob,6,Wed May 20 19:43:15 2015 UTC,"Not necessarily multiple values.  Many POSIX functions return an int status, and write a ""return value"" to the area pointed to by an argument.  What about the humble snprintf where it isn't a single char that needs allocating but rather a bunch of them?  Things like getdelim / getline where the pointer specifically has to be allocated with malloc? (So that it could be passed to free.)  So, thing like regcomp/regfree where some function must be run before / instead of free?  I think I has another off-the-wall ""calling convention"" that I saw too, where one argument was used to return an array of things.  I wish I could remember that example...  Could I call writev/readv ? iocntl / fnctl ? execle ?  What if I want to use functions like ftw / tsearch -- can I get a function pointer to a top-level Haskell function? A locally bound function? A lambda?"
haskell,36mhfh,bss03,3,Thu May 21 01:52:09 2015 UTC,"Thanks for the very relevant questions.  The code following is slightly fictional and not type checked -- specifically you might have to add a context to handle some of the types (specifically ssize_t and FILE).   Not necessarily multiple values. Many POSIX functions return an int status, and write a ""return value"" to the area pointed to by an argument. What about the humble snprintf where it isn't a single char that needs allocating but rather a bunch of them?   Let's take snprintf as an example:  import qualified Data.Vector.Storable.Mutable as VM  do buf <- VM.new _BUF_LEN    n <- [C.exp| int { snprintf($(char *buf), $(int _BUF_LEN), ""The half of %d is %d"", 60, 60/2) } |]    if n < 0      then error ""informative error message""      else do        buf' <- VM.take n buf        if n >= _BUF_LEN          then <do something if the output was truncated>          else <do something if everything went well>    I think I has another off-the-wall ""calling convention"" that I saw too, where one argument was used to return an array of things. I wish I could remember that example... Could I call writev/readv ? iocntl / fnctl ? execle ?   I don't see why not.  Do you have any specific issues in mind?   Things like getdelim / getline where the pointer specifically has to be allocated with malloc? (So that it could be passed to free.) So, thing like regcomp/regfree where some function must be run before / instead of free?   Well, getline can allocate the buffer itself.  But less pretend it can't.  foreign import ccall ""&free"" freePtr :: FunPtr (Ptr CChar -> IO ())  getline :: CFile -> IO ByteString getline cfile = do   ptr <- [C.exp| char* { malloc($(int _BUF_LEN)) } |]   size <- [C.exp| ssize_t { getline(&$(char *ptr), $(int _BUF_LEN), $(FILE cfile)) }   fptr <- newForeignPtr freePtr ptr   return $ BS.fromForeignPtr fptr 0 size    What if I want to use functions like ftw / tsearch -- can I get a function pointer to a top-level Haskell function? A locally bound function? A lambda?   Yes, yes, and no, but simply because anti-quoters only work with variables.  With the fun context you can easily marshal any kind of Haskell function.  See for example the GSL example https://github.com/fpco/inline-c/blob/master/examples/gsl-ode.hs#L32 ."
haskell,36mhfh,rostayob,3,Thu May 21 08:42:10 2015 UTC,Thanks for the very relevant questions.   Thanks for the answers.  They are very much appreciated.  I think I'm coming around to this approach; I am going to have to put some time in and experiment with it.  I find the mostly positive answers very encouraging.
haskell,36mhfh,bss03,2,Thu May 21 12:23:31 2015 UTC,"Let's say I have a pair of C functions that allocate and deallocate respectively, but they're not std.lib. The signatures are:  int CreateA(A *a);  int DestroyA(A *a);  The type I'd like to wrap the As in should restrict the scope to between these two calls. In the intervening lines I'd like to operate on the 'variable' obtained after allocation in other ways (e.g. after making it an instance of some algebraic typeclass). I think the idea is similar to a foreign pointer? How may I achieve this in inline-c ? The problem, AFAIU, is that C pointers declared within functions go out of scope upon return, and all the [C.block| rtype{} |] bits are rendered to individual functions. Don't tell me I have to write a monolithic C function for this case.."
haskell,36mhfh,ocramz,2,Tue Jun 9 22:54:39 2015 UTC,"withA :: (A -> A) -> IO () would be the simplest approach.  It would Create, call the closure, and Destroy.  But, it has remarkably limited utility.  withA :: (A -> IO a) -> IO a is not what you want, due to the ability to return the A -- which could cause use-after-free bugs. withA :: (A -> IO ()) -> IO () is no help either, because while you can't return the A directly, it can be stashed in a IORef and again expose you to use-after-free issues.  Other methods include tying the life time of an A to be associated with a particular state thread (the parameter of ST that is eliminated with runST) and using finalizers to call DestoryA (which is ""guaranteed"", but not prompt)."
haskell,36mhfh,bss03,2,Wed Jun 10 18:44:46 2015 UTC,"How are foreign pointers represented in inline-c ? In particular, I think there should be a 'toggle switch' in the type wrapping the pointers, such that after  deallocation of the foreign pointer the Haskell-side variable becomes effectively unusable. How may I achieve this? Thanks again"
haskell,36mhfh,ocramz,1 point,Thu Jun 11 09:20:31 2015 UTC,"That would require some sort of region or linear types, which AFAIK aren't implemented as part of inline-c.  In general, because Haskell is garbage-collected, ""destructors"" / ""finalizers"" are generally called by a finalizier attached to a ForeignPtr, IIRC.  My practical experience linking C and Haskell is quite limited."
haskell,36mhfh,bss03,2,Mon Jun 15 06:30:25 2015 UTC,Great! - Calling c-functions as easily as in julia-lang or www.torch.ch.
haskell,36pk84,herbadah,17,Thu May 21 02:39:07 2015 UTC,"In dependently typed languages, types are first class objects. You can pass them around, store them in data structures, etc.   So what then is the type of say, Nat or String or List Person?  We simply create a new type. In Idris, this is called Type. In Agda, it's called Set. When you talk about a type, you might say Nat : Type to mean ""Nat is a type"".  So if an object is a type, then its own type is called Type.   If you know a little about logic, you may have heard of Russell's paradox. This is a danger in type theory as well. Since Type is a type, it is an object, and so it, too, needs a type. The way this is usually handled is to have a hierarchy of types, sometimes called Type_0, Type_1, Type_2, ... and so on. In Idris, these aren't actual keywords, though. You just write Type and the compiler will figure things out for you. (I believe this is called typical ambiguity). So Type : Type, but it is understood that the second one is a ""bigger"" version of Type."
haskell,36pk84,tactics,2,Thu May 21 03:02:42 2015 UTC,"Ok thanks. I will continue the tutorial now with my belief suspended.    edit - I think maybe someone misinterpreted my meaning here, my fault.  I was sincerely thanking tactics for the information provided. I understand it, and will continue with that understanding, but not all that confident about the consequences of it and how it applies to programming in general.  Sheesh."
haskell,36pk84,dnkndnts,10,Thu May 21 04:05:09 2015 UTC,"Don't feel bad about having difficulty understanding this -- you're not the first to stumble over it. The Grandfather of modern type theory, Per Martin-Löf, even messed this up in his original theory. He originally had Type be a type of Type (i.e., both a type and an object of that type). It was soon discovered that, as tactics mentions, this has a Russell's Paradox problem (in this case, called Girard's Paradox).  Martin-Löf subsequently revised his original theory by introducing a cumulative hierarchy of type universes, and it's on this revised type theory that languages like Idris are based.  Anyway, if you get stumped by this issue, don't feel bad, because even the world's leading type theorists were stumped by it for a while. If you actually want to understand exactly what's going on, read ""An Intuitionistic Theory of Types: Predicative Part"", but be warned it is fairly esoteric."
haskell,36pk84,davidchristiansen,3,Thu May 21 07:05:47 2015 UTC,"It's common to be a bit overwhelmed when first learning about dependent types - it's really quite different from working with non-dependent systems, even when the syntax looks like something familiar. Understanding of the consequences will come along with confidence as you work through examples and ask good questions, like this one :)  One question you asked in your post was ""Why not use a type variable for the type of types?"". The reason why not is that we don't want the second argument of Vect to be an element of any type at all - it wouldn't work if we put, say, a String or a List Nat there. It needs to be an actual type, because that's where the type of the elements of the Vect will go.  You can think of Type in Idris as being a bit like the kind * in Haskell. There's some differences, like /u/tactics mentioned, but it's a good first approximation."
haskell,36pk84,phazer,2,Thu May 21 06:58:57 2015 UTC,"Hmm, what about singleton types? Let's say we are allowed to pass a String or Nat as second argument, the list elements would be restricted to being only exactly that value. But that's not how the type system in Idris works?"
haskell,36pk84,pigworker,5,Thu May 21 08:33:39 2015 UTC,"Indeed it is not. The only things T which may stand to the right of : and classify other things are those things which are classified T : Type. Values in types other than Type are not ""singleton types"". It is not the case that 3 : 3. Correspondingly, if the second argument to Vect is to classify the vector's elements, it must be a type and thus have type Type.  One might well write  data Foo : Nat -> String -> Type where   and it is perfectly reasonable to define a type constructor with arguments of type Nat and of type String. This would be ok...      Nil  : Foo Z a   but the following would be in error      (::) : a{-XXX-} -> Foo k a -> Foo (S k) a{-YYY-}   because the use of a at {-XXX-} requires a to be in Type, while the use of a at {-YYY-} requires a to be in String.  It is possible to define singleton types which wrap up copies of a given value.  data Single : a -> Type where  -- implicitly, a : Type   Only : (x : a) -> Single x   You could then construct the type Vect 2 (Single ""foo"") : Type which would be inhabited by and only by  Only ""foo"" :: Only ""foo"" :: Nil   All types are values. Not all values are types. The values which are types are exactly the values of type Type."
haskell,36pk84,phazer,2,Thu May 21 11:13:35 2015 UTC,"Thanks, that clarifies things.  I'm interested to know if there is a type system that combines subtyping, singleton types, union types and dependent types, i.e. where 1 : 1, 1 : Nat, 1 : (1 | 2), 2 : (1 + 1) etc. all are true? What would be the complications of such a type system (except type inference)?"
haskell,36pk84,pigworker,3,Thu May 21 12:14:54 2015 UTC,"If everything is its own singleton type, then everything which is a type already is also its own singleton type. E.g., Nat : Nat, which means there are things of type Nat which are neither zero nor a successor, thus invalidating induction.  Subtyping (a source of slack constraints) and union types (which are hardly syntax-directed) make it rather more difficult to manage type checking (let alone type inference) mechanically. I wouldn't be surprised if there were sound ways in which humans could construct valid typing derivations, but persuading machines to find them looks like it might involve quite a bit of search.  Such a situation would not be to my taste.I prefer types to be the means by which I impose order, rather than the means by which I observe chaos. But mine is not the only taste."
haskell,36pk84,phazer,1 point,Thu May 21 12:53:51 2015 UTC,"If everything is its own singleton type, then everything which is a type already is also its own singleton type. E.g., Nat : Nat, which means there are things of type Nat which are neither zero nor a successor, thus invalidating induction.   There should still be a hierarchy of types (or sets), like in Idris, so Nat : Nat would not be true (but for example Nat : (Nat | String) would be true). If <: is the subtype (or subset) operator, (1 | 2) <: Nat and Nat <: Nat would be true.  I think I see your point though, 1 : 1 should probably be written 1 : {1} or similar."
haskell,36pk84,dnkndnts,2,Thu May 21 13:52:36 2015 UTC,"Let's say we are allowed to pass a String or Nat as second argument, the list elements would be restricted to being only exactly that value.   No. Defining Vect : Nat -> String -> Type is extremely misleading because the English label ""Vect"" is now completely wrong. This is not a Vect at all. What exactly it is depends on how you define your constructors, but a meaningful example with that signature is this:  data LimitedString : Nat -> String -> Type where   MkLimitedString : {y:Nat} -> (x:Nat) -> (s:String) -> (sizeProof:(DecEq (length s + y = x))) -> LimitedString x s   This takes a number x, a string s, and a proof that that the length of s is less than x. So an str of type LimitedString is a string with a max length. So yes, Nat -> String -> Type definitely can have meaning."
haskell,36pk84,phazer,3,Thu May 21 09:54:32 2015 UTC,"No. Defining Vect : Nat -> String -> Type is extremely misleading because the English label ""Vect"" is now completely wrong. This is not a Vect at all.   I don't follow this reasoning. Why isn't it a vector? For example, let's say you want to be able to define vector of a specific length containing only a specific number (for whatever reason), wouldn't it be defined as:  Vect : Nat -> Nat -> Type   So, my question is how do you combine this with:  Vect : Nat -> Type -> Type   I.e. how do values (numbers etc.) relate to (singleton) types?"
haskell,36pk84,dnkndnts,2,Thu May 21 10:24:42 2015 UTC,"Ok, you're right, you could create a vector with only a single repeated value like that, but that's just... super weird and doesn't really make sense from a practical/usefulness standpoint, as without any dependency between the two types it's just isomorphic to (Nat,String) except much less efficient. While technically yes, I suppose you could say (Nat,String) is a vector of the same string over and over, that's a very unorthodox interpretation of a pair of Nat and String.   I.e. how do values (numbers etc.) relate to (singleton) types?   By singleton you mean a type like T(a) where T : (n:Nat) -> Type? In type theory this is the big pi type and corresponds to the logical ""for all"" statement. ""For any natural number n, I can construct a type T(n)."" If that T(n) is the same for all n, then this corresponds to logical implication -- ""For any natural number n, I can construct (prove) the type (statement) T; therefore, n implies T."""
haskell,36pk84,BartAdv,1 point,Thu May 21 11:13:41 2015 UTC,"Hm, now I am confused. I thought what he meant by type variable is essentialy what type of types means, that is, any concrete type, and not a value of some type.  That's indeed good question, I'd like to learn something out of it as well:)"
haskell,36pk84,Dickferret,2,Thu May 21 08:01:23 2015 UTC,This small piece of information may help you out eventually: Idris doesn't put in the numbers because there's a proof that you can insert  numbers that will be coherent into a raw syntax tree.
haskell,36pk84,beerdude26,1 point,Thu May 21 16:15:47 2015 UTC,"So Idris' Type is Haskell's * ? (Well,  zip [Type_0...] (iterate (->) *) to be more precise)"
haskell,36pk84,tactics,3,Thu May 21 07:45:52 2015 UTC,"It is like *.   I don't think your comment in parentheses really makes sense, though. It looks like you are looking at an ""infinite"" function type, since you wrote out the -> arrow. But talking about Type, there is no need to bring up function types at all."
haskell,36pk84,beerdude26,1 point,Thu May 21 16:47:27 2015 UTC,"It was a fast attempt at writing a mapping from Type_0 to *, Type_1 to * -> *, etc."
haskell,36pk84,bss03,3,Thu May 21 18:02:32 2015 UTC,"Yes, * ~= Type_0.  But no, Type_1 ~/= * -> *.  Instead, Type_0 -> Type_0 ~= * -> * and ☐ ~= Type_1.  Even in GHC there's no symbols for the ""type of"" *.  But, in general the ""type of"" kinds are called ""sorts"" and the one ""sort"" that Haskell has is sometime written as ☐ and sometimes as BOX."
haskell,36pk84,beerdude26,1 point,Thu May 21 21:17:04 2015 UTC,"Ah, thanks for the clarification :)"
haskell,36pk84,pigworker,2,Thu May 21 21:18:45 2015 UTC,"That's not what's going on, though.  Type_0 : Type_1 Type_0 -> Type_0 : Type_1 List Type_0 : Type_1  Meanwhile, if T : Type_1, it makes sense to hypothesize x : T. But if B : Type_0 -> Type_0, then it makes no sense to hypothesize x : B.  Arrow is not what is being iterated."
haskell,36pk84,BlackBrane,2,Thu May 21 20:36:41 2015 UTC,"I too ran into some of these confusions about the type of Type in Idris at first. I think this is particularly natural and healthy for a newcomer to be leery about, given Russell's paradox, but it's handled in a sensible way.  Formally, the problem is tackled by declaring an infinite hierarchy of type universes:  Type_0, Type_1, _Type_2 ...  What Idris does amounts to the same thing, but the numerical levels are never made explicit. It simply checks to make sure the type hierarchy has no cycles.  I was particularly confused about this because if you try to investigate it at the REPL you see:  Idris> :t Type Type : Type 1   But later I noticed Edwin had answered a question about this, stating that this is simply a display hack he put in because he was tired of people pointing out the would-be inconsistencies caused by Russell's paradox!  You can clearly see that this is the case if you just enter Type at the REPL.  Idris> Type Type : Type"
haskell,36pk84,dnkndnts,3,Thu May 21 12:31:03 2015 UTC,That's really funny to me that anyone could imagine that Edwin Brady could possibly be unaware of that. That's like telling Neil Armstrong to be sure to put a lid on his drinks since gravity in space won't hold it in the cup.
haskell,36mnf7,Mattiemus,9,Wed May 20 14:33:15 2015 UTC,As a League of Legends fan I find this really cool! This is probably one of the biggest Haskell game projects out there - at least that I've heard of. What was the biggest challenge for you terms of the game's architecture?
haskell,36mnf7,Rogerthesiamesefish,6,Wed May 20 16:15:14 2015 UTC,"As a league player myself I jumped at the opportunity when I selected my dissertation project. However I come from a c++ background, so translating the game development techniques I already knew from an object oriented mindset into a functional one was difficult. While frustrating though, it has been interesting seeing how the language affects the design of a game so dramatically.  The biggest problems I had was trying to squeeze techniques such as component based design into the design, which in hindsight was not the way to go. In future I think a redesign of the core objects is required, however I am very pleased with the result, and the game loop structure will almost certainly remain intact for the next iteration."
haskell,36mnf7,0v3rk1ll,1 point,Wed May 20 16:32:58 2015 UTC,Wayward Tide is a pretty large game currently being developed in Haskell.
haskell,36mnf7,qZeta,1 point,Thu May 21 07:29:28 2015 UTC,"… currently being developed in Haskell.   However, there hasn't been any progress report, tutorial or anything WT related since last September. The whole development (and /u/palf_) went silent after the last blog post :(."
haskell,36mnf7,tejon,1 point,Thu May 21 11:04:39 2015 UTC,"Chucklefish is a fairly well-established studio, though, and they've got other projects showing activity. And from what I've been told (by his boss iirc) palf was never a redditor to begin with; he just got assigned some thread-watching duty while they were expecting active questions.  No news isn't great, but in this case I don't think it's a sign of abandonment."
haskell,36mnf7,gasche,6,Sat May 23 02:12:17 2015 UTC,You should try to record a video of the gameplay; the screenshot doesn't quite cut it to get a feel of the game.
haskell,36mnf7,gilmi,1 point,Thu May 21 10:09:25 2015 UTC,"great job! I've yet played it but I will soon. It is always good to see more game built with Haskell!  I glossed over the code and it looks fairly clean and well documented. nice!  I wanted to ask, how did you decide on which libraries to use? for example, why SDL and not sdl2, why Yampa over the alternative frp libraries?"
haskell,36mnf7,gilmi,1 point,Thu May 21 08:28:48 2015 UTC,"SDL was used over SDL2 as I was already familiar with it (I was already in new territory with Haskell and Yampa, so some amount of familiarity was nice!).  Yampa was chosen because it was easier to use for a beginner like me, however something like netwire would have probably served just as well.  Any comments or problems with the code that you see/are worth point out?"
haskell,36mnf7,taylorfausak,1 point,Thu May 21 10:40:52 2015 UTC,Just from a quick glance your Haskell-foo already seems much better than mine so I don't think I have much to contribute.
haskell,36meqr,Frosticus,7,Wed May 20 13:26:01 2015 UTC,"Cabal could use more hands!  You could also check us out at https://snowdrift.coop! One thing we actually really want is charts n' graphs n' stuff for helping patrons (well, mostly us, right now) get a feel for how our funding mechanism actually works. It won't be tons of hardcore stats, but it's mathy and database-y. I think it would be cool to build a set of modules for generating said charts on the fly as svgs or something.  Anyway, there's lots to do out there. Good luck!"
haskell,36meqr,chreekat,6,Thu May 21 05:08:59 2015 UTC,The hmatrix library is Haskell's wrapper around BLAS and LAPACK.  Right now the documentation does not seem to be building correctly so you could try fixing that.
haskell,36meqr,Tekmo,5,Wed May 20 22:06:36 2015 UTC,"I think that's actually a common problem in open source and one that I often have faced in the past. I really wanted to do something, but just couldn't find the right thing, or couldn't get in touch with it."
haskell,36meqr,mbruder,3,Wed May 20 23:54:04 2015 UTC,"It'd be useful if there was a way for open source projects to ""call for help"". A kind of marketplace/search-engine for things-to-do. A ratings system for projects would be good too (but stars on GitHub works)."
haskell,36meqr,steshaw,11,Sat May 23 21:42:55 2015 UTC,"It's hard to direct you anywhere without a bit more on what your interests are. If you like programming tools, I'd work on programming tools, if you like games, I'd write a game, and if you like Web stuff, I'd work on one of those.  That said: Idris is fairly approachable as far as compilers go, and it's written in Haskell. We have a category on our issue tracker that we believe are good introductory projects. Various useful tools, like the HTML documentation generator, have been developed by fairly new Haskell programmers."
haskell,36meqr,davidchristiansen,5,Wed May 20 14:37:58 2015 UTC,"Something that would be fun to figure out would be to have a look at servant's jQuery generation code and how you could add it to a HTML templating library of your choice, the goal being to be able to say ""I want this data here, represented in this manner"". Perhaps querying a servant API from React is also a good place to start."
haskell,36meqr,beerdude26,4,Wed May 20 13:33:43 2015 UTC,The diagrams project has lots of potential places to contribute and is a lot of fun to work on. We're happy to help newcomers get up to speed and find ways to contribute.
haskell,36meqr,byorgey,3,Thu May 21 02:12:03 2015 UTC,the quality of libraries on hackage is high enough that scrolling through them until one catches your eye would not be a waste of time.  https://hackage.haskell.org/packages/#cat:Statistics
haskell,36meqr,sambocyn,3,Thu May 21 00:23:03 2015 UTC,"Also see the answers from 2 months ago, when I asked the same question: http://www.reddit.com/r/haskell/comments/2y1i4x/haskell_projects_looking_for_contributors/"
haskell,36meqr,JPMoresmau,3,Thu May 21 07:37:24 2015 UTC,"I wrote a little personal wishlist for improvements to criterion, which could be some combination of Haskell, and JS/HTML/CSS  http://www.reddit.com/r/haskell/comments/2wii6n/haskell_google_summer_of_code_proposal/cov11xo"
haskell,36meqr,jberryman,2,Thu May 21 10:21:26 2015 UTC,pandoc?
haskell,36meqr,johnbokma,2,Wed May 20 20:35:53 2015 UTC,"Unfortunately, jgm is a bit slow on managing PRs  https://github.com/jgm/pandoc/pulls"
haskell,36meqr,joehillen,2,Thu May 21 16:25:30 2015 UTC,"Jquery like selector library (alternative to CsQuery [c#] and pyquery [python]), which uses quasi quotes for syntax [$| table.list > tr |] porting YI editor to web or giving YI editor an HTML front end"
haskell,36meqr,TheJonManley,1 point,Thu May 21 22:01:17 2015 UTC,A sage math like library but use quasi quotes for equations?
haskell,36meqr,ddlk,1 point,Thu May 21 01:11:54 2015 UTC,"I wonder if @cartazio is looking for contributors? https://github.com/wellposed  There's https://github.com/ekmett/succinct which has/had some kind of relationship to analytics.  Also, try this query on GitHub  A suite of examples would be a nice contribution to almost any project. Also tutorials. You could publish at the School of Haskell."
haskell,36md4t,klaxion,6,Wed May 20 13:12:11 2015 UTC,"I think you can often get quite a long way without any of these frameworks - my usual approach is to start with just vanilla JS, and to get a good feel for what is needed in the UI, and then start looking at libraries/frameworks later only if it's clear that there's a problem with the initial approach, and if those libraries look like they could solve that problem.  Also, purescript. :)"
haskell,36md4t,hdgarrood,6,Wed May 20 14:51:00 2015 UTC,Check out Elm.
haskell,36md4t,bulldog_in_the_dream,3,Wed May 20 15:37:29 2015 UTC,"The recently released stackage-view tool by FPComplete (employer of the Yesod founder Michael), uses GHCJS and React for its UI. It is open source so the code can be studied.  I think client/server-isomorphism and VirtualDOM are the way to go for browser UIs. Both are facilitated well by React, so it seems a natural choice. For my experiences with React it is quite small and understandable. But combined with GHCJS I see some overlapping functionality, and thus I believe a better solution is possible.  I think an Haskell based FRP lib and an HTML templating lib combined with a VirtualDOM lib in JS should give most of what is React in a more Haskellish way.  Anyway. My take on it: not much consensus on a browser UI strategy for Yesod at the moment. Mainstream availability of GHCJS will certainly change that when it comes true."
haskell,36md4t,cies010,4,Wed May 20 15:13:56 2015 UTC,";) I use Angular + RouterUI + Angular-Materials, js is managed via bower, I closure compile all static libraries and serve them via CDN, and generate all JS on the fly (possibly different js for every user), demo is still a work in progress.  https://video.kio.sx/demos/about"
haskell,36md4t,tolysz,4,Wed May 20 13:17:24 2015 UTC,"Unless you're going ghcjs/PureScript or similar, then I can heartily recommend React."
haskell,36md4t,Oremorj,4,Wed May 20 16:17:56 2015 UTC,You might try reflex and ghcjs.
haskell,36md4t,codygman,1 point,Wed May 20 20:10:24 2015 UTC,"If you are new to javascript and front-end development I would recommend just using plain html, jquery and jquery-ui to build a single page application.  Then you can build a simple json backend with yesod to get your feet wet. jquery is more of an utility lib which helps with ajax calls and such. jquery-ui gives you an basic understanding of the DOM and how html works. The more complicated frameworks like angular and react does more but is also harder to learn."
haskell,36j3au,chrisdoner,18,Tue May 19 19:31:10 2015 UTC,"I wouldn't be too hopeful. Despite the fact that I'm one of the most practical, pragmatic members of one little social group I belong to (and this is clearly obvious quite often when others get into arguments over insignificant things) I'm still seen as a puristic, impractical hipster because I like Haskell. :(  They don't seem to understand that a desire for good type systems and immutability come from a practical perspective. They equate things like Node.js with productivity and practicality. It's hard to change that image as long as that is the case."
haskell,36j3au,kqr,11,Tue May 19 22:40:35 2015 UTC,"My impression is that haskellers tend to be seen as head-in-the-clouds-impractical, purists to the point of fanaticism, and annoyingly prone to proselytizing.   Here's my take on this - the software technology landscape consists of a bunch of disparate technologies (Javascript, C#, Ruby...) which are more or less equivalent in terms of productivity. Still, their users evangelize them regardless. Why? Because if you become proficient at using a certain technology, it's advantageous for you if that technology gets used by your peers.  Haskell adopters recognize that, and they make very sure to say ""but we're not like that! Our technology is actually better!"" Outsiders hear that and get curious. They stop by and check out Haskell, and what they see is a language with little tooling, unusual syntax, few jobs, and a bunch of weirdo mathematicians speaking a language foreign to mere mortals. Above all, they see the batshit crazy learning curve. To them, this doesn't look like a superior language, it looks like a bunch of people who have invested themselves way too much in a technology and now really really want people to use it so they can benefit.  I can't think of a quick and easy solution. Haskell is a nice language, but it sure did manage to ""avoid success at all cost"". Technical managers don't see Haskell as a potential tool, they see it as a source of competent (if academically oriented) developers for projects in other languages. For those who see software development primarily as a job, that's a show-stopper right there, Haskell is not something they'll try to learn.  Side-note: on the orders of my manager, I am currently ramping up my team on the use of F#. Initial reactions are wary at best, people don't necessarily want to learn a new way to do things when their current way has been enough until now. And that's for a language with massive corporate support, tooling, imperative programming, object orientation, the works. I can't imagine bringing up Haskell."
haskell,36j3au,PM_ME_UR_OBSIDIAN,13,Wed May 20 05:06:44 2015 UTC,"That's pretty much how it was three or four years ago. The solution is not quick and easy, but we're doing it: building companies, building products, and building out the tooling, step by step. It's happening."
haskell,36j3au,yitz,8,Wed May 20 07:36:12 2015 UTC,people don't necessarily want to learn a new way to do things   That's the real probem
haskell,36j3au,Tekmo,4,Wed May 20 07:57:16 2015 UTC,"Even the most passionate developers I know suffer from learning fatigue when it comes to technologies. The only reason I'm sticking it out with Haskell is that it tends to subsume other technologies, so whatever I learn here I can also apply elsewhere.  Since I've started programming, I've picked up about one language every six months. At this point that shit all looks the same. We're good at coming up with new tech, but we suck at evolving the old tech into something relevant, hence fragmentation."
haskell,36j3au,PM_ME_UR_OBSIDIAN,6,Wed May 20 16:34:24 2015 UTC,"Even the most passionate developers I know suffer from learning fatigue when it comes to technologies.   I had a little of this for a while just before learning about Haskell, because too much of what I was expected to ""learn"" was yet another way to do what I was already doing.  Oh, occasionally there was an actual gem, but mostly it was mostly just trade out the syntax for the same mass of problems.  Haskell was actually novel, and reinvigorated my passion for learning.  But, then again, the ""weirdo math"" was always something I liked, and Haskell / HoTT / Idris / Agda just keep pressing that particular joy button of mine."
haskell,36j3au,bss03,2,Wed May 20 17:01:10 2015 UTC,"But to this day I still don't fully know how to use or write a brand new monad. I almost get it, but something just isn't fully clicking.   I feel you. Monads are kind of trippy, you have to use them and abuse them before you get a good feel for what they're good for.  I think I'm getting there, but it took years of study. :c"
haskell,36j3au,PM_ME_UR_OBSIDIAN,1 point,Wed May 20 19:03:54 2015 UTC,"IMHO the obvious solution is to teach that stuff in undergrad, but we're not quite at that level of acceptance yet.  I could definitely see a Monads 101 course in mid-to-late CS undergrad. They're useful as hell for decoupling processes/aspects, so even if you don't use them in your day job they can help you think about code better."
haskell,36j3au,PM_ME_UR_OBSIDIAN,1 point,Thu May 21 02:07:56 2015 UTC,I'm sure I could teach most people to replace some part of their system with Haskell code in an afternoon if they already know a few languages.  The problem is almost always that everyone seems to think they must know everything about Haskell to get started.
haskell,36j3au,codygman,1 point,Thu May 21 06:03:58 2015 UTC,I would hazard a guess that where you are currently after years of study isn't necessary for writing reliable real world Haskell code.
haskell,36j3au,codygman,1 point,Thu May 21 15:42:45 2015 UTC,"Reliable, no. Idiomatic and maintainable, definitely.  I still haven't learned how to use iterated IO (pipes, conduit) or lenses yet."
haskell,36j3au,PM_ME_UR_OBSIDIAN,1 point,Thu May 21 16:46:07 2015 UTC,"You don't have to use iterated IO or lenses to make reliable Haskell code.  For instance if your doing web development, it might be nice if your code fetching stock data from an xml feed is using pipes/conduit but not using those won't make it unreliable.  If you are just munging some text files you'll do fine with Data.Text.Lazy.IO.interact.  I can kind of understand your pipes or conduit prerequisite for reliable code but I can't understand lenses being a prerequisite for reliable code."
haskell,36j3au,codygman,1 point,Fri May 22 18:50:32 2015 UTC,"I meant that you don't need that much stuff for reliable code, just to make it idiomatic and maintainable and to be able to work on other people's code :)"
haskell,36j3au,PM_ME_UR_OBSIDIAN,1 point,Fri May 22 17:38:22 2015 UTC,"In my opinion Haskell code without lens is more idiomatic but more verbose.  Even so my main point is: for many pipes/conduit (especially lens) aren't necessary for idiomatic, reliable, and maintainable Haskell.  If you take what I say as fact it is disingenuous to imply lens and pipes/conduit are necessary for idiomatic, reliable, and maintainable Haskell code."
haskell,36j3au,codygman,2,Fri May 22 18:12:39 2015 UTC,"Haskell's learning curve is a legitimate blocker, even for someone of my experience. If it's hard for me to feel comfortable that I've learned it well enough, how can I sell our CFO on me teaching it to my team?   I believe you are putting too high of a bar on ""learned enough Haskell to write production code"".   I'm not young anymore, I don't have lots of spare time to throw away mastering new languages by writing toy projects like I did 5 years ago. Now I learn by reading books, which at this point mostly have nothing new to say. But even after reading at length about Haskell, I still don't feel comfortable with it.   You have to write code in Haskell (for me any other language) to feel comfortable with it. My own opinion is that no one can really learn a language of a different paradigm without writing (to throw out a random number) 1000 lines of code spanning over multiple (at least more than just pure computations) subjects.   But to this day I still don't fully know how to use or write a brand new monad. I almost get it, but something just isn't fully clicking.   Hopefully this will help, I will warn you my reply is fairly long. It's mostly long because I want to err on the side of being too verbose.  Do you know what this does:  Just 1 >>= (+ 1)   Kind of a trick question, it returns a:  Maybe b   That has no show instance. Ever used return? Here is what return for the Maybe monad does:  return              = Just   So that means that as long as you are in a function that expects to return Maybe a:  return 1 == Just 1   Back to the first example, our function needs to be lifted/injected/whatever into the Maybe monad using return:  Just 1 >>= (\ d -> return (d + 1))    What does >>= do? Well our type is Maybe so we can look for the typeclass instance that looks like ""instance Monad Maybe"" and then see how it defines the >>= function. It looks like:  (Just x) >>= k      = k x Nothing  >>= _      = Nothing   You can see in the case of a Just value (specifically ""Just 1"") it pattern matches on the Just, storing the 1 into the variable x and storing the function "" (\ d -> return (d + 1))"" in k. Below I'll write the original statement and then below it translate >>= and return into their function definitions:   Just 1 >>= (\ d -> return (d + 1))   1 (\d -> return (d + 1)) -- manually apply >>=  1 (\d -> Just (d + 1)) -- manually apply return within the context of the Maybe Monad (or more simply a function of type Maybe that's using a function defined by the Monad Maybe typeclass)  Just 2 -- answer   As for creating a Monad:   Define a new data type Define >>=, >>, and return for your new data type You have a monad. Ensure your monad is well behaved and follows the monad laws.   When I made my first Monad I didn't even really understand the laws. As a reminder here are the laws:  return a >>= k  =  k a  m >>= return  =  m  m >>= (x -> k x >>= h)  =  (m >>= k) >>= h   Let's pretend you made the Maybe monad. Let's copy paste that first law into ghci and replace the values with the right Maybe values.  Prelude> -- return a >>= k  =  k a -- law Prelude> -- we'll `let a = 1` since return usually takes some value and injects it into the Monad context. Prelude> -- k must = `Just a` or `Nothing` Prelude> -- first the left side (return a >>= k) Prelude> return 1 >>= Just Just 1 Prelude> -- now the right side (k a) Prelude> Just 1 Just 1 Prelude> -- and we can see both are equal, but just to be thorough... Prelude> (return 1 >>= Just) == Just 1 True Prelude> -- parenthesis around the left side were necessary   Now the second law, I'll be a bit more brief since I feel the format was established well above:  m >>= return  =  m  Prelude> -- m >>= return  =  m Prelude> let m = Just Prelude> :t m m :: a -> Maybe a Prelude> :t m >>= return m >>= return :: a -> Maybe a Prelude> -- I'm not sure how to show an example of this better than showing the types are the same. There is no typeclass instances for `instance Eq (a -> Maybe a)` and I don't know what that would look like or if it could exist.   The third and final law:  (m >>= f) >>= g == m >>= (\x -> f x >>= g) -- law   Prelude> let m = Just 1 Prelude> let f = (\x -> return (x + 1)) Prelude> let g = (\y -> return (y + 3)) Prelude> (m >>= f) >>= g Just 5 Prelude> m >>= (\x -> f x >>= g) Just 5 Prelude> ((m >>= f) >>= g) == m >>= (\x -> f x >>= g) -- law  <interactive>:111:1:     Couldn't match expected type ‘m b’ with actual type ‘Bool’     Relevant bindings include it :: m b (bound at <interactive>:111:1)     In the first argument of ‘(>>=)’, namely ‘((m >>= f) >>= g) == m’     In the expression: ((m >>= f) >>= g) == m >>= (\ x -> f x >>= g)     In an equation for ‘it’:         it = ((m >>= f) >>= g) == m >>= (\ x -> f x >>= g) Prelude> ((m >>= f) >>= g) == (m >>= (\x -> f x >>= g)) -- law True Prelude> --oops whenever you get errors like that just use more parenthesis on each side of the infix operator   There, now you know how to implement a Monad! The hard (well kind of... it was trivial for Maybe I think) part is defining the >>=, return, and >> instances.  The point of this is just that you can treat a Monad as ""simple user defined datatype that implements the required Monad typeclass functions (>>=, return, >>)"". However you really want to make sure your instances follow the Monad laws as well. Functor, Monoid, Semigroup, etc all seem to be the same though I haven't made data types implementing all of those.   Maybe it's just that I'm old. Maybe 29 is the age where you stop being able to learn crazy new concepts. Or maybe monads just haven't been explained properly with decent real-world examples yet.   A good real world example isn't so useful since it's so abstract that you'll get a wrong intuition from one use case. Taken from typeclassopedia:   This document can only be a starting point, since good intuition comes from hard work, not from learning the right metaphor. Anyone who reads and understands all of it will still have an arduous journey ahead—but sometimes a good starting point makes a big difference.    About Functor, but you can replace it with Monad or any of the others (emphasis below is mine):   a Functor [or Monad - codygman] is simply what it is defined to be; doubtless there are many examples of Functor instances that don’t exactly fit either of the above intuitions. The wise student will focus their attention on definitions and examples, without leaning too heavily on any particular metaphor. Intuition will come, in time, on its own.    I would advise checking out /u/bitemyapp's free learn haskell repo as well as his new Haskell book in beta."
haskell,36j3au,codygman,2,Fri May 22 18:55:32 2015 UTC,"I'm in the same boat with F#, so I'm using it for non essential tooling, simple unit tests, and every now and then I write some non essential lib in it.  But the biggest showstopper for me, is that C# and F# cannot coexist in the same project. If that was possible it would be significantly easier for me to use F# in our products."
haskell,36j3au,hvidgaard,6,Fri May 22 20:55:58 2015 UTC,"But the biggest showstopper for me, is that C# and F# cannot coexist in the same project. If that was possible it would be significantly easier for me to use F# in our products.   Why it is so a big deal to have another assembly in the product?"
haskell,36j3au,pjmlp,1 point,Sat May 23 02:40:55 2015 UTC,"I couldn't care less for the number of assemblies. I just want them to co exist in the same project so I can use F# where it makes sense. It rarely makes sense to have 8 utility projects because some of the functionality is in F#.  Basically for any of the assemblies I have to convert everything to F# (which is infeasible for UI related code) or spread related functionality in 2 projects. The former is not an option because not everyone on the team knows F# and I risk introducing new bugs. The latter is bad from a maintainability point of view. All in all, it means I cannot use F# much."
haskell,36j3au,hvidgaard,3,Fri May 22 18:47:56 2015 UTC,"I see. I am on the same boat in regard to JVM and .NET alternative languages.   Teams at customer sites only grok Java and C#, occasionally C++.  So any alternative language never leaves my PC.  As consequence F# gets used for my own scripts and not much else."
haskell,36j3au,pjmlp,4,Wed May 20 09:19:13 2015 UTC,"IMHO the problem is that OOP APIs really destroy the point of using F# because they force that style on you. Any F# assembly that directly interacts with .NET libraries or with C# is going to be more or less shit, so now you need SO MANY WRAPPERS to build an application.  Because of that, I can hardly write a toy F# application to demo to my team - I need something large enough that the engine/core stuff can be segregated from the API, and that just doesn't make sense under a certain size."
haskell,36j3au,PM_ME_UR_OBSIDIAN,2,Wed May 20 13:28:30 2015 UTC,"C# and F# cannot coexist in the same project   Eh? Really? Wow, that's pretty terrible. Is there any chance of that being fixed some day?"
haskell,36j3au,eriksensei,7,Wed May 20 14:47:12 2015 UTC,"In the .NET world, a ""project"" is (essentially) a set of files used as a compilation unit, and projects in general have one source language.  A ""solution"" is a set of projects; the projects contained by a solution do not have to use the same language.  So you can use C# and F# together in a solution.  In any case, C# allows circular references between files, and F# does not.  It's unclear how allowing them in the same compilation unit would or should work."
haskell,36j3au,jpfed,2,Wed May 20 15:27:31 2015 UTC,"I doubt it. It's two different toolchains to compile them, and would require significant changes to the .Net and  F# compilers and intellisense as well.  But it would be awesome."
haskell,36j3au,hvidgaard,1 point,Wed May 20 15:46:54 2015 UTC,"Wow, that's incredibly disappointing, and I'm not even a .Net guy. Thanks for the info though!"
haskell,36j3au,eriksensei,4,Wed May 20 10:17:26 2015 UTC,"Though, note that you can mix different project types in the same solution. So its not entirely impossible."
haskell,36j3au,hvidgaard,2,Wed May 20 14:13:47 2015 UTC,"what they see is a language with little tooling   While I agree with the general sentiment of your post I have to disagree on that. Haskell is so far ahead of everything else out there in terms of available tools it surpasses many mainstream languages. And most of those tools are not exactly hidden either (e.g. profiling, editor support, hlint, hoogle, hayoo,...)."
haskell,36j3au,Taladar,2,Wed May 20 11:49:31 2015 UTC,"No Visual Studio or JetBrains offering. I don't think there's any option for a graphical debugger either.  You might think ""but that doesn't matter!"" and it very well may not from a UX standpoint, but I'm thinking about the sales pitch here."
haskell,36j3au,PM_ME_UR_OBSIDIAN,1 point,Wed May 20 13:57:16 2015 UTC,"When you start using Haskell you will find that you do not need an IDE as a crutch in it (or in 50% of the other modern languages for that matter) nearly as much as you do in C++, Java or similar boilerplate-heavy languages.  That said there is IDE integration, editor integration and even a full Haskell IDE (Leksah) which is much more than most languages offer, even languages with communities much larger than Haskell's."
haskell,36j3au,Taladar,0,Wed May 20 14:40:19 2015 UTC,"When you start using Haskell you will find that you do not need an IDE as a crutch in it (or in 50% of the other modern languages for that matter) nearly as much as you do in C++, Java or similar boilerplate-heavy languages.   I'm not sure I agree with that line of thinking. Just because you can make do without an IDE doesn't mean you should. Either way, this is a moot point when discussing the sales pitch; you can't just hand-wave away people asking for first class $FAVORITE_IDE support. Even trying makes you look religious.  If the people are asking for $FAVORITE_IDE, your job is to give it to them, or at least an equivalent alternative. Your job is not to convince them that they don't need it. Programming languages are a buyer's market, people can just go elsewhere.   That said there is IDE integration, editor integration and even a full Haskell IDE (Leksah) which is much more than most languages offer, even languages with communities much larger than Haskell's.   Think back to when Mono only had MonoDevelop and a few editor plugins. That wasn't a compelling tooling story for tooling back then. We should apply the same standard to Haskell; having a ""full Haskell IDE"" is not anywhere near as good as having Haskell integration in mainstream IDEs."
haskell,36j3au,PM_ME_UR_OBSIDIAN,0,Thu May 21 10:22:31 2015 UTC,"What is a mainstream IDE? Is there any IDE that supports more than about half a dozen languages? Any IDE with a market share (among all developers, not just those in a given language or on a given OS) of more than 1 or 2 percent?  At the same time there are so many IDEs that supporting all of them would waste huge amounts of resources which is why IDE-, much like editor-integration is very much a 'scratch your own itch' kind of affair where developers who want to use a given IDE or editor write their own support and if nobody does use a given IDE or editor with a given language then there will be no support.  IDEs are the true buyer's market, they fulfil a role in languages like Java where you have to use large code-bases comprised mostly of boilerplate but many modern languages cut out the middleman and just don't force you to write the boilerplate in the first place.  People can program without an IDE (and many do, in any language), nobody can program without a programming language itself. It is quite clear which of the two is the more important tool and the one where improvement yields better results."
haskell,36j3au,Taladar,1 point,Thu May 21 14:02:04 2015 UTC,"This reeks of bad faith. Programming languages are by and large fungible, IDEs are not. Most programmers use IDEs, and the combined market share of IntelliJ, Visual Studio and Eclipse is probably above half of all professional programmers. They all support 8+ languages.  E: and before you reply that ""programming languages are not fungible, look at Haskell!"" True, Haskell is an exception - but guess what, when it comes to adoption, that's a black mark against it."
haskell,36j3au,PM_ME_UR_OBSIDIAN,1 point,Thu May 21 14:43:53 2015 UTC,"IDEs are largely irrelevant outside of those 8-10 languages with support among the major IDEs (and it is always the same few languages).  Your second point doesn't even make sense. To adopt a language that does exactly the same things with roughly the same strengths or weaknesses as a language you already know makes very little sense. To adopt a language that is truly different in its trade-offs (even if you are not convinced it is better across the board or in most fields) makes much more sense because it gives you another tool in your toolbox that works where the language you already know might be a bad match for a job.  I disagree that languages are fungible though, certain languages within their respective groups, sure, e.g. Perl, Python and Ruby are very similar in their feature set and flaws alike but we do certainly already have languages that have very different trade-offs. Erlang is much better than most mainstream languages to write distributed systems. Languages with manual memory management like C and C++ are more prone to errors when used for highly concurrent tasks, C is much better suited to write code to be used from other languages than C++, Forth is well suited for high level, portable code to be interpreted by a minimal interpreter (e.g. used in Firmware), Fortran excels at certain computational tasks,..."
haskell,36j3au,Taladar,2,Thu May 21 15:02:42 2015 UTC,"The main benefits that I get from an IDE are (roughly in order of importance to me):   Removal of the edit-save-compile cycle: errors are highlighted along the way Instant API discoverability: listing all functions that operate on a given value, with documentation Instant navigation: jump to implementation of function, declaration of variable, etc. Refactoring tools: moving and renaming functional units, extracting interfaces, etc. Finding all usages of a function or type Running/debugging/profiling code without changing context   As far as boilerplate, I occasionally use my IDE's project templates, such as standard folder layouts for web applications, but that's about it.  I used to think a web browser on one screen, vim in another, and a couple of terminals was a good enough solution. You can do lots of work that way.  But you can understand and manipulate a project much faster with an IDE than without, and now that I've used one for 40+ hours a week over 4+ years, I'd much rather have one."
haskell,36j3au,BMintern,6,Thu May 21 15:22:33 2015 UTC,Don't forget graduate student or other academic slant.
haskell,36j3au,asampson,2,Thu May 21 16:54:56 2015 UTC,"I'd like to change that and honestly I haven't met anyone who fits that   All of that fits me exactly. I'm not proud of it, but it's true."
haskell,36j3au,gfixler,2,Thu May 21 18:30:25 2015 UTC,"I proselytize less these days, but purity is why I learned and use Haskell.  The fact that it's practical at all is just glaze on the doughnut."
haskell,36j3au,bss03,10,Sat May 23 05:49:49 2015 UTC,The iron man ironing nails it. Hilarious. Thanks for the laugh.
haskell,36j3au,LukeHoersten,8,Tue May 19 23:12:14 2015 UTC,"Good one!  This one is old but still worth linking.  (And, holy crap, discussion link...)"
haskell,36j3au,sacundim,5,Wed May 20 15:41:49 2015 UTC,True. Everyone knows that the awesome Iron Man suit is actually dependent types.
haskell,36j3au,psygnisfive,7,Wed May 20 19:07:22 2015 UTC,I think the reality section should be a little different and there should be one more section after it.  Reality  Haskeller building software  Non-haskeller building software  Five years later  Haskell project  Non-haskell project  ...or something along those lines
haskell,36j3au,mightybyte,3,Tue May 19 23:13:41 2015 UTC,Ironing one tshirt == one Fibonacci function?
haskell,36j3au,Pat55word,27,Wed May 20 07:33:00 2015 UTC,"Yeah, but you might want to fold it."
haskell,36j3au,zz_h,6,Tue May 19 23:34:19 2015 UTC,"If you actually want to know how other programmers see Haskell, just check out /r/programmingcirclejerk/ - it's kind of become the mascot language."
haskell,36j3au,c3534l,10,Wed May 20 16:22:59 2015 UTC,"Haskal is the most advanced, practical Fibonacci generator ever brought to Earth by the Twin Simons. Hail Simon. Hail Simon."
haskell,36j3au,NihilistDandy,2,Tue May 19 22:05:18 2015 UTC,Go is also the mascot language..
haskell,36j3au,jeandem,2,Wed May 20 02:47:10 2015 UTC,and rust... this is smelling very reactionary :)
haskell,36j3au,tobiasgw,9,Wed May 20 05:32:36 2015 UTC,"You have to add a license to this, 'cause I want to use it in every presentation from now on!"
haskell,36j3au,eigengrau82,3,Wed May 20 07:24:34 2015 UTC,I have a feeling MGM or Universal might not be willing to grant a public license. :)
haskell,36j3au,TheJonManley,1 point,Wed May 20 11:10:24 2015 UTC,http://www.wtfpl.net/
haskell,36j3au,Oremorj,7,Wed May 20 15:20:09 2015 UTC,"One appreciates the sentiment, but I think CC-0 is probably more lawyer-proof. (I hate to be a party-pooper, but y'know...)"
haskell,36j3au,qZeta,8,Tue May 19 20:21:17 2015 UTC,"Given that Chris doesn't own any of the pictures, I doubt that he can actually put that post under any open license."
haskell,36j3au,nsa_shill,2,Wed May 20 05:51:46 2015 UTC,"Is wtfpl not legally rigorous, somehow?"
haskell,36j3au,SrPeixinho,1 point,Tue May 19 21:15:18 2015 UTC,Doesn't this grant anyone the right to register it himself and thus make you unable to use your own work?
haskell,36j3au,qZeta,2,Tue May 19 22:07:44 2015 UTC,"I'm not a lawyer, but no. It depends on your legislation, but usually you retain all rights to your work, regardless of the licence you've used. A licence dictates the rules for others (unless you want to reimplement their changes back to your work, but that's a whole other beast)."
haskell,36j3au,FPguy,4,Wed May 20 04:00:50 2015 UTC,Extreme ironing has a new contender.
haskell,36j3au,bss03,3,Wed May 20 02:06:37 2015 UTC,/r/ProgrammerHumor
haskell,36j3au,G01denW01f11,1 point,Wed May 20 04:53:59 2015 UTC,You should Xpost to /r/programmerreactions.
haskell,36j3au,_skp,1 point,Wed May 20 09:15:23 2015 UTC,So true ahah :)
haskell,36j3au,Oremorj,1 point,Tue May 19 22:10:15 2015 UTC,It's funny 'cause it's true.  EDIT: I still want to be Iron(ing) man! :)
haskell,36j3au,elcric_circle,1 point,Tue May 19 23:27:05 2015 UTC,"A reflection of creativity, very interesting! You obviously put some time and work into this, thanks, I needed a smile!"
haskell,36j3au,sherdogger,1 point,Tue May 19 21:22:00 2015 UTC,"Yah...I dunno. I've been feeling more like http://imgur.com/nLIMpsf lately. Very safe, a little cumbersome and unwieldy. Been trying to pick up Prolog lately, looking for something expressive and intellectual without all the cruft. Haskell has been my hobby language...use it for programming puzzles, toy things, so my needs are not everyone's for sure. Talk me back from the ledge, bros!"
haskell,36j3au,PM_ME_UR_OBSIDIAN,3,Tue May 19 21:47:24 2015 UTC,"You can implement a logic programming monad in Haskell :o) I definitely won't stop you from getting into LP, for some problem spaces it's an excellent paradigm.  See also: Propositions as Filenames, Builds as Proofs: The Essence of Make"
haskell,36j3au,tsahyt,3,Tue May 19 22:00:52 2015 UTC,Implement a small Prolog interpreter in Haskell. This language really shines at this sort of task and it's a fun little project too!
haskell,36j3au,sherdogger,2,Thu May 21 09:28:04 2015 UTC,"That does sound fun, actually :) I'll put in the queue."
haskell,36j3au,Crandom,1 point,Wed May 20 00:23:42 2015 UTC,That's how I feel in javascript and java...
haskell,36j3au,sherdogger,1 point,Wed May 20 07:39:04 2015 UTC,"Me, too. I'll take Haskell over those any day, if we are going for fun. But I'm just that darn lazy I guess. When I think about the the times I've reached for backtracking or Maybe, or had to slosh my logic in and out of the IO monad...an option that takes away the need for those without losing expressiveness is a hell of a carrot. But again, we are talking about a guy who is using this stuff for play things and doesn't have to own up to technical debt, or lose sleep over errors rearing their head which a stronger type system would have caught."
haskell,36j3au,mjmrotek,1 point,Wed May 20 09:14:18 2015 UTC,Perhaps have a look at Curry?
haskell,36j3au,sherdogger,2,Wed May 20 10:01:29 2015 UTC,"Wow. So what you're telling me, this without a doubt, is destined to be the greatest programming language of all time? Seriously, that's cool stuff. Thanks."
haskell,36j3au,mjmrotek,1 point,Wed May 20 11:12:23 2015 UTC,"Yeah, but it would be better if it had type classes. It's hard for me to part with those."
haskell,36j3au,nrlb,1 point,Wed May 20 22:00:37 2015 UTC,"I enjoy haskell, but don't write anything professionally.  My one wish is for haskellers to use fewer single letter type variables.  If allowed, afurther wish would be more practical context to abstract generalizations which really exhibit why they are useful rather than just powerful."
haskell,36j3au,cameleon,4,Thu May 21 07:33:24 2015 UTC,"This is a common complaint, and the common answer is: if it's abstract (say, map) then x is as informative as element: a thing you know nothing further about. In places where there is more domain knowledge (say, Cabal) the variables tend to be more descriptive (e.g. compilerName)."
haskell,36j3au,nrlb,1 point,Thu May 21 08:23:18 2015 UTC,"I guess one should not complain about too much abstraction.  It just makes it harder to conceptualize for beginners or those of an intermediate skill level.  I don't know if I'll ever count myself in the second of the two camps when I read or work with some of the haskell articles I read.  Examples:  Send even more money  I haven't finished reading this article.  I read some of the others in the series, which were interesting.  An excerpt:  -- CS = Counting Selections type CS a b = StateT [a] (ListT (Writer (Sum Int))) b   This is my thoughts when I read this line: So it takes a list of type a in the list monad transformer context which writes the length of the remaining number of selections, and the b is... ah... well, if it's a StateT it should be the passed along state.  Which is... ah... hmm.  Lenses, Stores, and Yoneda  Where almost every type level variable single letter.  Ollie Charle's asteroids  asteroidsRound nAsteroids c d e f initialScore = proc keysDown -> do [...]   I look around to find out what the c d e f are from context.  Lenses:  type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b   I use them, but I don't ever know I'll be proficient in their black magic.  Don't get me wrong, I enjoy reading / extending / learning, and this is exemplary work by people much smarter than I am.  I really should sit down and put more time into it.  But I have more patience than most of the people I know who scoff at this writing style.  Maybe I don't know the right people.  :)  When you have a list of arguments that goes on for a bit, or if you assume that the information is self-explanatory then the consequence is that you will lose people more quickly or at the very least the content becomes slightly less accessible."
haskell,36j3au,cameleon,1 point,Thu May 21 12:44:22 2015 UTC,"To be honest, lenses, Yoneda and other such examples are pretty advanced. Which is not to say that you should avoid them, but I don't think choosing longer (type) variable names will make them more understandable.  In the other examples, I think you are right that longer names could have helped. The fact that CS has a comment, which could have just been its name, is indicative of that. The c d e f in asteroids also have a more specific, non-abstract meaning I think (for a quick scan)."
haskell,36j3au,nrlb,1 point,Wed May 20 09:21:33 2015 UTC,"I don't feel very strongly about it.  But it almost the opposite problem of verbosity and boilerplate in imperative languages.  The cases and locations where being succinct is reasonable leaks into places where it is not or just a little more characterization would be appreciated.  Again, I consider myself more a spectator when it comes to haskell so maybe just uninformed opinion."
haskell,36j3au,TobyGoodwin,1 point,Wed May 20 12:07:03 2015 UTC,"Yes! I started writing something on this, looking again at the hoary quicksort example: http://tobold.org/chapter/hadvocacy/04  (I then got distracted by my own cleverness and went off at a tangent; this piece really needs editing!)"
haskell,36j3au,vagif,1 point,Thu May 21 18:32:10 2015 UTC,"Here's how haskellers are REALLY seen by others:  ""Oh, of course i know pascel.""  Guys, i hate to break it for you, but outside of our small circle, no one is aware that such language exists :)"
haskell,36jnj8,mjnet,5,Tue May 19 21:42:31 2015 UTC,"If the .prof files become to big to read easily, there are different tools to help with that."
haskell,36jnj8,jaspervdj,8,Wed May 20 10:49:06 2015 UTC,"Jasper, you're too modest! Your profiteur visualisation tool is easily my favourite. I was visiting a client recently and showed them profiling with profiteur which easily let us drill down to identify the culprit in their code. They were very impressed.  I'm not sure everyone knows about it, you should publicise it more. It's a great tool.  For those of you here who've not seen it before, see Jasper's original blog post."
haskell,36jnj8,dcoutts,3,Wed May 20 13:34:49 2015 UTC,"Nice article. A few notes:   -caf-all and -auto-all are deprecrated afaik. The new name for these flags is -fprof-auto and -fprof-cafs (see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html#idp15279008).  you should not need to set -prof or -fforce-recomp by yourself: cabal will do this for you if you configure with --enable-library-profiling and --enable-executable-profiling. In particular, I believe that this helps to correctly deal with applications using TH. Setting executable-profiling: True is not such a good idea, IMO. It will mean that all executables installed by cabal will have profiling by default. I think profiling should be set on a per-project basis (especially since it can hurt performance). library-profiling: True though does not change performance (since the library is now compiled both in profiled and in non-profiled mode)."
haskell,36jnj8,pycube,1 point,Wed May 20 13:42:32 2015 UTC,"fwiw, ghcjs failed to build aeson after like 2h of successfully building everything else (template haskell related), because I had a global enable-profiling set."
haskell,36jnj8,sambocyn,3,Thu May 21 00:38:13 2015 UTC,"One can usually use the ghc-prof-options field to specify which options to use when specifying -p/--enable-library-profiling/--enable-executable-profiling. See here for an example. These options are picked when you issue cabal configure --enable-library-profiling && cabal build, for example."
haskell,36jnj8,AlpMestan,2,Wed May 20 08:15:50 2015 UTC,"Did you mean to put ""library-profiling:"" twice?  I think it still works if you only list it once, and I think you might want ""executable-profiling"".  EDIT: Though, normally executable profiling would only be if you want to profile executables produced by a cabal package, and the Haskell source already contains all the cost-center annotations that you want.  If you need to specify -auto-all or -caf-all or both, you'll probably need to rebuild the executable anyway, so executable-profiling isn't nearly as useful as library-profiling."
haskell,36jnj8,bss03,2,Tue May 19 23:35:14 2015 UTC,"I think if you are going to rebuild with all those GHC options, you probably don't need to cabal configure --enable-library-profiling --enable-executable-profiling or cabal install -p."
haskell,36jnj8,bss03,2,Tue May 19 23:38:20 2015 UTC,"I think you should have library-profiling from very beginning in ~/.cabal/config turned on, but only enable executable profiling for your project in any way you like."
haskell,36jeiu,hellerve,20,Tue May 19 20:43:50 2015 UTC,"I like how head, tail, and friends are safer than their Prelude counterparts."
haskell,36jeiu,drb226,13,Wed May 20 05:57:34 2015 UTC,"https://github.com/hellerve/hog/blob/master/index.js <-- would be a better link, if you didn't get it."
haskell,36jeiu,bss03,5,Tue May 19 23:45:28 2015 UTC,cough purescript cough
haskell,36jeiu,eriksensei,1 point,Wed May 20 10:28:39 2015 UTC,"I plan on looking at that next. I haven't gotten the time to do so up until now, unfortunately."
haskell,36jeiu,eriksensei,2,Wed May 20 11:10:53 2015 UTC,"You should, it's excellent! A bower.json file and pulp as your build tool are all you need to get started."
haskell,36jeiu,Whoopska,5,Wed May 20 11:13:45 2015 UTC,"Also I keep typing "":quit"" into all kinds of REPLs (most notably, Python). My own little programming language and GHCI are both to blame. Very annoying."
haskell,36jeiu,bss03,10,Tue May 19 21:04:32 2015 UTC,How about ^d as EOF and then you shouldn't have to think about it?
haskell,36jeiu,gfixler,2,Tue May 19 22:55:30 2015 UTC,"Yeah, maybe I should make that a habit."
haskell,36jeiu,dmytrish,1 point,Tue May 19 22:59:47 2015 UTC,Doesn't work on MS Windows. :(
haskell,36jeiu,mine0,16,Tue May 19 23:42:13 2015 UTC,What does?
haskell,36jeiu,dmytrish,1 point,Wed May 20 07:30:25 2015 UTC,Ctrl-Z should work for Windows.
haskell,36jeiu,drb226,1 point,Wed May 20 17:36:45 2015 UTC,... and suspends the process nearly everywhere else.
haskell,36jeiu,Crandom,1 point,Fri May 22 08:01:25 2015 UTC,"Ok, it does not work :) (I don't know much about Windows)."
haskell,36jeiu,drb226,5,Fri May 22 15:09:34 2015 UTC,What's with all those calls to .get()? It sort of defeats the point of using Maybe when you just unwrap it like that.
haskell,36jeiu,ignorantone,2,Wed May 20 06:00:39 2015 UTC,"You're right. I was unsure about how best to go about this and it came out unsafe. I will try to go about this more cleanly today. Thanks for pointing it out, though, I was not sure how much of a code smell it was."
haskell,36jeiu,bss03,7,Wed May 20 06:24:04 2015 UTC,"You need monadic bind/do notation to make it nice. Pattern matching also helps, there are libraries for that"
haskell,36jeiu,kuribas,1 point,Wed May 20 09:10:06 2015 UTC,"Thanks for that! I did not know that lib, looks pretty!"
haskell,36jeiu,SelectricSimian,2,Wed May 20 09:51:36 2015 UTC,Update: I now removed these calls and settled for working with catamorphisms instead. It's much cleaner now.
haskell,36jeiu,tel,2,Thu May 21 13:00:08 2015 UTC,"Safer! I would have expected data.maybeto come with something like defaultMaybe. In Scala it's called aMaybe.getOrElse(default), and in Haskell fromMaybe default aMaybe."
haskell,36jeiu,sinelaw,5,Thu May 21 18:05:42 2015 UTC,"Check out http://ramdajs.com/0.14/index.html  Sadly, functions like ramda.head are not total, but at least they got currying right."
haskell,36jeiu,Oremorj,4,Wed May 20 00:13:02 2015 UTC,"functions like ramda.head are not total   Well, even Haskell didn't get that right. :P"
haskell,36jeiu,erikd,1 point,Wed May 20 00:31:17 2015 UTC,"I know ramda. For the purpose of that tiny little thing, using a library seemed overkill (also it would take all the joy out of writing it!), but I very much like it and am looking forward to using it for real for the first time."
haskell,36jeiu,Oremorj,4,Wed May 20 06:19:07 2015 UTC,"Implementing tail by splicing an array is dangerous, because unlike the haskell tail, it is O(n), instead of O(1).  That can turn O(n) algorithms into O(n2), leading to great loss in performance."
haskell,36jeiu,Oremorj,2,Wed May 20 10:47:18 2015 UTC,Thanks for pointing that out. I haven't even thought about that.
haskell,36jeiu,tejon,1 point,Wed May 20 11:09:13 2015 UTC,"Do you know of any better way to implement this, though? Ramdas version seems to do the same, except that it's heavily optimized."
haskell,36jeiu,bss03,1 point,Wed May 20 13:51:18 2015 UTC,"Just a note that in some languages, like D, taking a slice of an array just creates a new ""view"" into the same memory, which is O(1) time.  You don't always need linked list to be able to make efficient head/tail based array handling algorithms (although linked lists still make the most sense for dealing with laziness)"
haskell,36jeiu,i_am_broccoli,4,Thu May 21 22:15:55 2015 UTC,I'll just leave this here.
haskell,36i6tv,tailbalance,25,Tue May 19 15:57:42 2015 UTC,Cool. After pressing >>>: http://haskell-exists.com/cc27.png
haskell,36i6tv,Yuras,8,Tue May 19 16:27:23 2015 UTC,Its a feature.
haskell,36i6tv,Vektorweg,10,Tue May 19 17:59:31 2015 UTC,It should wait indefinitely to lazily load a next strip.
haskell,36i6tv,IsTom,12,Tue May 19 20:18:59 2015 UTC,It should force Roman to upload a new one :P
haskell,36i6tv,chrisdoner,6,Tue May 19 21:04:32 2015 UTC,Authored by the denizens of /r/programming.
haskell,36i6tv,hagda,3,Tue May 19 18:35:14 2015 UTC,...and how does reality look?
haskell,36i6tv,qZeta,9,Tue May 19 17:16:24 2015 UTC,Different. Most Haskellers don't sparkle.
haskell,36i6tv,tsahyt,15,Tue May 19 18:35:00 2015 UTC,Speak for yourself. I sparkle like a type safe unicorn.
haskell,36i6tv,Oremorj,4,Tue May 19 19:07:31 2015 UTC,Do you also poop rainbows? If so then you may actually be a unicorn! Something to consider...
haskell,36i6tv,dimsuz,3,Tue May 19 22:02:38 2015 UTC,And that stays in the monad of course!
haskell,36i6tv,tejon,7,Tue May 19 19:30:14 2015 UTC,instance Monad Vegas where...
haskell,36i6tv,theonlycosmonaut,2,Tue May 19 20:21:05 2015 UTC,"...I don't get it. Is there a joke or a message? All I get from this is 'Haskellers want to write secure software', or maybe 'Haskellers want people to attribute the security of their software to language features'."
haskell,36i6tv,rpglover64,5,Wed May 20 12:43:15 2015 UTC,"My interpretation is that it's a light jab at Haskeller's self-perception. The implication is that this scenario is unrealistic for many reasons, of which two possible ones are that Haskell code still has security flaws and that no auditor would actually recommend Haskell."
haskell,36i6tv,autowikibot,2,Wed May 20 13:09:12 2015 UTC,"Timing attack:       In cryptography, a timing attack is a side channel attack in which the attacker attempts to compromise a cryptosystem by analyzing the time taken to execute cryptographic algorithms. Every logical operation in a computer takes time to execute, and the time can differ based on the input; with precise measurements of the time for each operation, an attacker can work backwards to the input.  Information can leak from a system through measurement of the time it takes to respond to certain queries. How much such information can help an attacker depends on many variables: crypto system design, the CPU running the system, the algorithms used, assorted implementation details, timing attack countermeasures, the accuracy of the timing measurements, etc.  Timing attacks are often overlooked in the design phase because they are so dependent on the implementation. [citation needed]     Interesting: Lucky Thirteen attack | Time attack | Clock drift | Rotational cryptanalysis   Parent commenter can toggle NSFW or delete. Will also delete on comment score of -1 or less. | FAQs | Mods | Magic Words"
haskell,36i6tv,PM_ME_UR_OBSIDIAN,-3,Tue May 19 16:33:03 2015 UTC,meh
haskell,36i6tv,jeandem,-2,Tue May 19 16:33:31 2015 UTC,moo
haskell,36irsi,jaspervdj,14,Tue May 19 18:16:42 2015 UTC,"After researching this for a while, it seems that <*> = ap is not a verbatim rule   The docs of Monad literally say that ""(<*>) = ap"" should hold, which is as strong as laws in Haskell get. The Report itself mentions all laws in that ""should"" style, and I expect that the next Report iteration will mention the Applicative/Monad relation in the same spirit.  There are good reasons for the ""should"", of course. The programmer is free to choose instances that only satisfy them observationally, and then there's our good friend ⊥ who breaks e.g. Reader:  ⊥ >>= return = \r -> return (⊥ r) r = \r -> const (⊥ r) r = const ⊥ ≠ ⊥"
haskell,36irsi,quchen,8,Tue May 19 20:11:56 2015 UTC,"It's getting more important now, with the advent of ApplicativeDo notation."
haskell,36irsi,yitz,4,Tue May 19 20:23:47 2015 UTC,Making  a <- foo b <- bar return $ baz foo bar   have a different result than  baz <$> foo <*> bar   is just plain evil anyway.
haskell,36irsi,mjmrotek,4,Wed May 20 10:32:01 2015 UTC,"For some reason I managed to overlook this – I will update my blogpost. It is worth noting though that this was added together with AMP, so reasonably recent."
haskell,36irsi,quchen,8,Tue May 19 20:15:53 2015 UTC,"Before the AMP (GHC 7.10/Base < 4.8) the note was in Applicative's docs, at least since Base 4.0.0.0.  (And sorry to be that guy) ;-)"
haskell,36irsi,mstksg,3,Tue May 19 20:32:17 2015 UTC,"Ok, but that's great, it's good to know that there can be no doubt about this."
haskell,36irsi,pi3r,14,Tue May 19 21:06:01 2015 UTC,"By the way, this is actually the fairly well established ""Validation"" Applicative instance :) I think a few libraries offer it... I consider it somewhat analogous to ZipList's Applicative instance and List's monad instances being different. Definitely a bad idea to have them on the same type, because of equational reasoning, monad laws, optimizations, and ado :)"
haskell,36irsi,dcoutts,4,Tue May 19 20:33:37 2015 UTC,"Yes, I mention Validation near the conclusion of the blogpost. It is indeed similar to ZipList, although perhaps a bit trickier because the difference is more subtle."
haskell,36irsi,jkozlowski,8,Tue May 19 22:52:49 2015 UTC,"I find rather reassuring that there are valid/good applicatives that should not be ""extended"" to monad. This might be because I have spent too much time using languages with subtypes ?"
haskell,36irsi,jkozlowski,4,Tue May 19 19:01:10 2015 UTC,"Ah this is a blast from the past. I wrote about this topic as an undergrad some years ago. This was back before the applicative functors paper identified this as a common pattern (so the paper talks about it as probably being some special case of arrows and goes on at some length about things we all now take for granted with Applicative).  Yes, I wanted to do the same thing to gather independent errors from multiple independent branches in an AST, and so I also wanted an applicative style combinator with ""parallel"" behaviour, different from the monad bind."
haskell,36irsi,bss03,3,Wed May 20 13:48:39 2015 UTC,Does that mean ludwig compiler is written in Haskell?
haskell,36irsi,autowikibot,4,Wed May 20 11:02:42 2015 UTC,"Yes, it is."
haskell,36hm94,jleitgeb,12,Tue May 19 13:25:19 2015 UTC,"This is one of the best habits I've picked up from working on GHC, and we try to be very judicious about it. Of course, it helps more with Haskell (and especially a compiler) in my experience where the information density per LOC is fairly high. :)  There's lots of great stuff to learn from them though, if you look. One I pointed out on Twitter a while ago - Why does GHC eta-expand the RHS of an INLINE thing?"
haskell,36hm94,aseipp,2,Tue May 19 14:01:50 2015 UTC,"so how do the ""notes"" work? they don't look like named comments in haddock."
haskell,36hm94,sambocyn,2,Tue May 19 23:17:09 2015 UTC,"There's nothing special about the notes, they're just plain text, simply add them to your code. Since it's about implementation comments, Haddock wouldn't display them, but you could look at them in the source via Haddock."
haskell,36hm94,jpvillaisaza,1 point,Tue May 19 23:58:18 2015 UTC,"Thanks for the link. I haven't used this convention that much, but I do think it's something very useful and something I think I'll keep using."
haskell,36hm94,jpvillaisaza,12,Tue May 19 18:11:47 2015 UTC,"This is something I'm trying to incorporate in my code via org-mode in emacs. I'm surprised that the notion of hyperlinked notes isn't a mainstay of programming yet. I think, perhaps, that literate programming rode that wave, but went in a slightly different direction that ended up losing the interest of the wider community."
haskell,36hm94,acow,5,Tue May 19 15:19:06 2015 UTC,"Literate programming seems to focus on the wrong thing (in practice, in theory I'm all for it!). I'm sure we'd all like all our programs to read like prose, but writing comprehensible prose is a lot more difficult for us programmers than writing comprehensible programs.  I think the ""Notes"" idea is exactly right[1]. Write prose about the things that are actually interesting and/or difficult to understand... but don't ask the programmer to also describe the mundane parts in prose.  [1] Can't speak to how well it works in practice, I haven't had the pleasure of being asked to write one. Regardless, it seems to work for the GHC team and I'm inclined to believe them."
haskell,36hm94,Oremorj,5,Tue May 19 22:22:08 2015 UTC,"Literate programming seems to focus on the wrong thing (in practice, in theory I'm all for it!).   Most ""literate programming"" implementations (including .lhs files) are mere shadows of the original cweb, which would not only let you rearrange prose and provide hyperlinks, but would also rearrange your source code to match the requirements of the C compiler for you so that you wouldn't have to move your prose around as much."
haskell,36hm94,bss03,3,Tue May 19 23:54:47 2015 UTC,"That's what I was referring to when I said literate programming went off in a direction programmers don't seem to have wanted. The fragmentation and rearranging of code is not what I want, and is similar to the problem mentioned in the OP that Notes solve by moving long comments somewhat out of the way to keep the code readable."
haskell,36hm94,acow,3,Wed May 20 02:12:15 2015 UTC,"CWEB would let you chose what to rearrange.  Sometimes it's better to move the code to match the prose.  Sometimes it's better to move the prose to match the code.  Either way, CTANGLE and CWEAVE would give you the output you needed for that type of consumption."
haskell,36hm94,bss03,3,Wed May 20 02:22:37 2015 UTC,"Yeah, I’m familiar with it. I just don’t think that flexibility hit the mark for helping most programmers.  Edit: I shouldn’t speak for “most programmers.” For me, the time spent introducing those features of cweb always seemed a waste of time when what I would have rather seen is an easy way to connect good, clean code with pretty documentation. I do some cweb-type things with org every now and again, but usually find that it doesn’t lead to very nice source code."
haskell,36hm94,acow,3,Wed May 20 02:53:26 2015 UTC,"Exactly! This is why org-mode links work so nicely: they don’t break up the code. Org also buys you some nice formatting, navigation, and organization."
haskell,36hm94,acow,5,Tue May 19 22:30:24 2015 UTC,Could you elaborate? Can you have org-mode links in Haskell code? (I'm an org-mode novice)
haskell,36hm94,rpglover64,3,Wed May 20 04:01:17 2015 UTC,"Given that this is emacs, you can do basically anything you want. I'll try to put together a short presentation/demo/article on using it for notes. I did record a complicated and boring screencast showing off outorg a while ago. That's one way to use org facilities from within Haskell code."
haskell,36hm94,acow,1 point,Wed May 20 23:42:26 2015 UTC,"This is absolutely brilliant! If you could write it up, I'd be very grateful.  One problem I've found getting into org-mode is that most tutorials either fail to motivate (leaving it up to the reader to figure out when to use the features) or fail to explain (leaving the reader with a bunch of disjoint tricks). I look forward hopefully to yours if/when you write it.  EDIT: I found your write-up here and intend to take a look at it when I get the chance."
haskell,36hm94,rpglover64,2,Thu May 21 01:03:34 2015 UTC,"I've heard so much about the magic of org-mode, but I've been very skeptical... and I'm an Emacs user! I guess I should look into it one of these days... maybe I'll achieve another level of Zen or something. :D"
haskell,36hm94,Oremorj,3,Tue May 19 22:37:29 2015 UTC,"I really didn't get org-mode at all for a very long time. The trick is, I still don't get it, because there is no spoon org-mode.  It's really just a bunch of useful tools for working with text. Once you decide to write notes on anything, you, as a programmer, will independently invent some fraction of org-mode. Once you internalize that, it's much like the welcoming embrace of emacs itself."
haskell,36hm94,acow,2,Wed May 20 02:09:53 2015 UTC,"But it makes a lot of sense (in both practice and theory) for articles and tutorials and things like that in which the prose is very important, as well as keeping the code with the text. However, perhaps writing that prose (even if it's harder for programmers) can help in writing better programs, which is also an idea from literate programming."
haskell,36hm94,jpvillaisaza,3,Tue May 19 22:42:01 2015 UTC,"Certainly, for tutorials and articles &c! However, I don't think this is the typical situation.  I'm just kind of questioning the assumption that ""writing that prose"" results in ""writing better programs"". (And I do think it is a completely unproven assumption(*).) Anecdotally, I personally think much better symbolically/algebraically than in terms of prose.  (*) It may have worked for e.g. Knuth, but extrapolating from Knuth to all programmers is unbelievably naïve."
haskell,36hm94,Oremorj,2,Tue May 19 22:48:45 2015 UTC,"then you could annotate your code with properties and laws and stuff :)  it's distinct from ""the code itself"" because it's more concise and readable"
haskell,36hm94,sambocyn,2,Tue May 19 23:16:02 2015 UTC,I'm not sure what your point is... because I usually do. (As far as is practical in a non-dependently-typed language.)
haskell,36hm94,Oremorj,3,Tue May 19 23:21:57 2015 UTC,"I can have LaTeX typeset equations in my notes that are rendered right in emacs. I can put notes about alternative approaches that didn't work out (haven't you ever encountered some of your own code and thought, ""Oh, I have an idea to make this better!"" only to realize that you'd already tried that and it didn't work?). I can link to benchmark histories, sample data sets, annotated references.  These are all useful notes for you, not just tutorials for others."
haskell,36hm94,acow,1 point,Wed May 20 02:07:18 2015 UTC,"yeah I keep some history. in the comments, not Haddock's. but it helps remind me why this is a newtype not an alias (avoid impredicative types) or a data over a newtype (existential quantification) etc. one line is all it takes to trigger all those memories."
haskell,36hm94,sambocyn,1 point,Wed May 20 23:57:54 2015 UTC,"Yes, it's not the typical situation.  Some of these (notes and comments, literate programming) are ways to help you think about your program, which matters more than how you get to think about it. Of course, Haskell is great for reasoning about programs with or without things like literate programming."
haskell,36hm94,jpvillaisaza,2,Tue May 19 23:55:30 2015 UTC,"Cool, it would be much better to have some support for hyperlinked notes even though it works just fine with plain text. And I guess it does have some similarities with literate programming, the notes are kind of similar to what they'd look with LaTeX."
haskell,36hm94,jpvillaisaza,2,Tue May 19 18:09:27 2015 UTC,"The ipython Notebook (or the Haskell version) focus heavily on commenting. It's more the other way around, text with interspersed code samples."
haskell,36hm94,quiteamess,2,Tue May 19 21:59:36 2015 UTC,"I haven't tried IHaskell. The idea seems interesting and similar to literate programming at least based on what you say. I like it in some cases, but it may be overkill in other cases in which a simple plain note would do. There's no special syntax for these notes, which could be better at least in some cases. But I'm not sure if I'm getting the idea of IHaskell wrong because of not trying it yet..."
haskell,36hm94,jpvillaisaza,2,Tue May 19 22:37:23 2015 UTC,"Notebook interfaces like IHaskell are fantastic for things like plots. If you treat it more like reading text, then it has the huge benefit that you can see exactly how the plot was generated. If you are just reading, it's no big whoop, but if you want to play with parameters like axis scaling, or you're suspicious of a quantitative result, you don't need to recapitulate all of the author's technical work to check it out."
haskell,36hm94,acow,7,Wed May 20 02:15:13 2015 UTC,"Ah, commenting discovers the concept of binding a variable."
haskell,36hm94,tomejaguar,3,Tue May 19 23:00:20 2015 UTC,"Yes, and the same idea of ""go to declaration"" applies. It would be nice to have convenient tool support."
haskell,36hm94,mallai,1 point,Wed May 20 13:28:14 2015 UTC,Or footnotes.
haskell,36hm94,maltem,6,Thu May 21 18:45:46 2015 UTC,"""GHC Haskell compiler"" Glasgow Haskell compiler Haskell compiler"
haskell,36hm94,Frosticus,6,Tue May 19 17:16:27 2015 UTC,the Glasgow GHC Haskell Compiler ;)
haskell,36hm94,sambocyn,5,Tue May 19 20:25:31 2015 UTC,"RIP in peace, concision.  Brought to you by the Department of Redundancy Department."
haskell,36hm94,bss03,2,Tue May 19 19:19:41 2015 UTC,Ah yes the good old DRD dept
haskell,36hm94,beerdude26,3,Wed May 20 07:11:23 2015 UTC,"To be fair, quite a few abbreviations in the programming world are recursive, GHC just happens to be one of the non-recursive ones. Otherwise this would have been a perfectly valid thing to write. :)"
haskell,36hm94,Pseudoradius,1 point,Wed May 20 08:47:49 2015 UTC,Recursive abbreviations are just cop outs for not having to think up a real word for one of the letters :P
haskell,36hm94,Fylwind,2,Wed May 20 17:40:53 2015 UTC,Actually they are a defense mechanism against AIs which don't have a termination checker included in their language subsystem. Gets them every time. ;)
haskell,36hm94,Pseudoradius,2,Wed May 20 19:09:49 2015 UTC,Thanks! I just fixed that typo.
haskell,36ikhd,zinfan,3,Tue May 19 17:29:03 2015 UTC,"This is cool! Thank you for mentioning that this was borrowed from Blunt. I actually considered running Blunt in the browser but ultimately rejected it. To paraphrase myself from that issue: I'm not excited about the 6.5 MB JavaScript file, especially considering that Blunt typically responds with about 100 bytes of text.   Pointfree.js sends about 1 MB of JavaScript over the wire, which decompresses into almost 10 MB. Also it freezes up my browser (Firefox 38) if I enter a complex expression like (a, b) +|+ (c, d) = (a + b, c + d)."
haskell,36ikhd,taylorfausak,4,Tue May 19 19:06:05 2015 UTC,"The pointfree computation is best done in an asynchronous background thread, so it can be interleaved with the browser doing other things. When the user types something, existing computations should be aborted. See the try-purescript example for how to do these things asynchronously:  https://github.com/ghcjs/ghcjs-examples/blob/master/try-purescript/Main.hs  When the computation has been moved to a background thread, browser responsiveness can probably be improved by tuning the RTS options by passing -D preprocessor flags to GHCJS when linking:  See: https://github.com/ghcjs/shims/blob/master/src/thread.js#L8-L21  In particular the GHCJS_BUSY_YIELD field is probably too high as a default: the GHCJS RTS keeps computing for 500ms if it has work to do, during this time the browser has no chance to process events."
haskell,36ikhd,luite2,1 point,Wed May 20 00:37:16 2015 UTC,"Ohh. I've only noticed this message today.  Thanks, that's helpful I'll try to add this soon."
haskell,36ikhd,taylorfausak,3,Tue May 26 06:03:17 2015 UTC,"Thanks. The linked issue describes all the problems pretty extensively.  haskell-src-exts is the biggest source of output blowing.  The main purpose of this app was to see myself and demonstrate the state of GHCJS with a simple example. I am glad that it's possible to just add pointfree and pointful in build-depends and use it right-away. It's also possible to have a normal haskell tooling and workflow. Compiling GHCJS project is no different from compiling a normal haskell project. All you need to do is to put --ghcjs parameter and that's it.  Of course it's far from being perfect and there are problems with performance and output size, but they seem to arise only when you include some huge library from hackage which was never intended to be compiled into javascript."
haskell,36ikhd,luite2,3,Tue May 19 19:30:07 2015 UTC,"problems [...] arise only when you include some huge library from hackage which was never intended to be compiled into javascript   That is true, but that is also part of the appeal of GHCJS. Their readme says: ""Most packages from hackage should work out of the box."""
haskell,36ikhd,Oremorj,2,Tue May 19 19:40:50 2015 UTC,True. It would be great to see improvements in this area.
haskell,36ikhd,bss03,2,Tue May 19 20:01:41 2015 UTC,"haskell-src-exts is a pathological example, it's notorious for long compile times and large output, which makes it an interesting starting point for exploring optimization (it uncovered some memory leaks in earlier GHCJS). The haskell-src-exts dylib for OS X 64 bit is almost 22MB.  The JavaScript code size will improve once the Tyr code generator lands: http://www.reddit.com/r/haskell/comments/31ui2h/whats_the_current_status_of_ghcjs_vs_haste/cq6070o but for the haskell-src-exts package in particular, I think more needs to be done for actually good results. Perhaps it's just a matter of tuning the GHC options.  Now that hackage has been updated to Cabal 1.22, it should accept the ghcjs-options field for libraries and executables (the options get added to the ghc-options on the GHCJS command line). So if anyone wants to try and find a better optimum when compiling to JS, maybe it can be merged upstream."
haskell,36ikhd,codygman,2,Wed May 20 00:24:49 2015 UTC,"Just as a point of interest, IIRC (from a presentation by Sébastien Doeraene), scala.js achieved huge reductions in size (roughly 10x or so) when they were able to use the Closure Compiler's ADVANCED mode (or whatever it's called). One can only hope that ghcjs will be able to fix the remaining problems preventing the use of ADVANCED mode."
haskell,36ikhd,beerdude26,3,Tue May 19 22:16:28 2015 UTC,Some things are just better written pointful.  Try:  \w x y z -> ((x `y` x) `z` (x `y` x)) w w   and watch v8 beg for mercy.
haskell,36i8fi,letrec,4,Tue May 19 16:08:36 2015 UTC,The literate haskell file that generates this pdf can be found here (in the AlgorithmW package).
haskell,36i8fi,Crandom,4,Tue May 19 17:18:05 2015 UTC,"Example is section 2.3 would be clearer if they were in Haskell syntax instead of AST literals.  Let's presume a parse function that converts a limited subset of Haskell (as a String) to the AST and the examples become:  e0 = parse ""let id = \x -> x in id"" e1 = parse ""let id = \x -> x in id id"" e2 = parse ""let id = \x -> let y = x in y in id id"" e3 = parse ""let id = \x -> let y = x in y in id id 2"" e4 = parse ""let id = \x -> x x in id"" e5 = parse ""\m -> let y = m in let x = y True in x""   GHCi gives the following types to them (if you want to check your own Algorithm W implementation against it):   t -> t t -> t t -> t Num t => t (Int would also be acceptable, I believe.) Occurs check: cannot construct the infinite type: t3 ~ t3 -> t2 (Bool -> t) -> t"
haskell,36i8fi,bss03,3,Tue May 19 19:38:35 2015 UTC,"Not bad, although hasn't GHC itself moved on to using OutsideIn instead of Algorithm W?"
haskell,36i8fi,bss03,5,Tue May 19 19:23:06 2015 UTC,"GHC never used W. W never handled type classes, for example."
haskell,36i8fi,kamatsu,3,Wed May 20 23:00:43 2015 UTC,"Wikipedia's image of the algorithm's rules is actually helpful (which differs from the pure version in Damas, Milner (1982), ""Principal type-schemes for functional programs"")."
haskell,36i8fi,bss03,1 point,Tue May 19 21:15:25 2015 UTC,"It's not so great on a non-white background, and especially unreadable on my RES night mode. :/"
haskell,36i8fi,steshaw,1 point,Tue May 19 23:49:00 2015 UTC,Folks will also be interested in this awesome resource on HM by Ian Grant.  http://steshaw.org/hm/
haskell,36jjdu,jpvillaisaza,4,Tue May 19 21:15:31 2015 UTC,Personally I like this reverse function because it does not use any auxiliary functions:  sloverse [] = [] sloverse (x:xs) =     case sloverse xs of     [] -> [x]     y:ys -> y : sloverse (x : sloverse ys)
haskell,36gvv9,n-simplex,7,Tue May 19 08:15:18 2015 UTC,If you want to create a list I would assume toList being the best way since it can have specialized version that produce lists in a good way.
haskell,36gvv9,augustss,4,Tue May 19 16:03:54 2015 UTC,The Foldable instance for [] has the default definition of foldMap:  foldMap f = foldr (mappend . f) mempty
haskell,36gvv9,prophile,6,Tue May 19 09:13:12 2015 UTC,"Yes, but my concern is with List being used as the target Monoid, not the source Foldable.  foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m   Here t would stand for an arbitrary Foldable instance and m would stand for [b] for some b."
haskell,36gvv9,ninereeds314,14,Tue May 19 09:36:29 2015 UTC,"foldMap isn't a separate function - it's a method in the Foldable instance. Therefore when instancing Foldable, it's the implementers responsibility to ensure reasonable performance properties. But of course there are constraints on that.  I think you're right that the laws aren't sufficient to ensure good performance - the rule is that typeclass laws specify what's correct.  The foldable may fold in an inconvenient order for any particular monoid. Of course a lot of monoids (Sum, Product...) don't have cost penalties for changing bracketing order, but some (like list) do.  If this is a problem, one workaround is probably to switch to a difference-list monoid - difference lists in Haskell (IIRC - I haven't looked at them for a while) are functions of the form \t -> ... :t - lists with a ""hole"" where the tail should be. They support efficient concatenation by function composition, and to get the final list at the end you just provide the empty list to fill the hole.  More generally, if the folding order is wrong for your monoid, you can use another monoid that implements the same concept with different cost trade-offs."
haskell,36gvv9,ninereeds314,2,Tue May 19 10:38:14 2015 UTC,"I'm aware foldMap is a method of the Foldable typeclass, and as such how well it will perform for this particular scenario would depend on the particularities of its implementation per instance.  However, as you mentioned in another reply here, unless the Foldable instance in question is isomorphic to [], its natural folding associativity is unlikely to match the optimal list concatenation order, so if it implements foldMap as its Foldable primitive we're likely to suffer from a performance penalty (again, in this particular scenario).  I get your point that for many other monoids this performance penalty wouldn't exist, however for all a the type [a] is the free monoid over the alphabet a ('the' since free objects are unique up to isomorphism). Maybe I'm being too purist about my categories, but if a function is meant to be used over monoids, I'd expect it to be a natural and efficient choice for usage over free monoids. And since this can't be expected to directly happen over any Foldable instance, since how foldMap associates operations very much relies on its internal structure*, a compiler backed optimization would be desirable in order to preserve code level abstraction without sacrificing efficiency. But, well, concatMap does exactly what I'm talking about, and does so efficiently, so it may be regarded as the go-to specialization of foldMap for the case where the monoid is a list; again, I'm just somewhat annoyed by free monoids having to be treated as an exception if efficiency is a concern.  * Unless the monoid operation performed in foldMap is delayed by a lazyness trick, such as instead of performing the operations over the monoid itself, doing so over its monoid of endomorphisms** (which is precisely what both DList and the standard derivation of foldMap from foldr do).  ** Endomorphisms in the Hask category, not necessarily in the category of monoids.  Anyway, I did some benchmarks using Criterion, adopting Data.Map.Lazy Int as the Foldable instance (to have some tree structure). The benchmarking code as well as the results (bench.out being the output for unoptimized compilation and benchO2.out being the output for -O2 optimized compilation) is here: https://gist.github.com/anonymous/7623f7234b7ec2a215ef  As expected, foldMap runs a lot slower than the other approaches, which are otherwise fairly comparable.  EDIT: grammar"
haskell,36gvv9,decimalplaces,2,Wed May 20 00:00:39 2015 UTC,"I'm just somewhat annoyed by free monoids having to be treated as an exception if efficiency is a concern.   My objection there would be that the free monoid isn't a list, it's a sequence. A list is a specific implementation of a sequence - a specific data structure that makes specific cost trade-offs. Lists are cheap and cheerful, but don't scale well if overused - irrespective of foldMap.   a compiler backed optimization would be desirable in order to preserve code level abstraction without sacrificing efficiency   In this case, you're basically asking for the compiler to replace the foldMap algorithm specified in the library source code with a completely different one depending on the monoid. This is considered cheating - benchmark fraud, even. Also impractical - the compiler doesn't know all possible foldable and monoid combinations and, except where sufficient inlining occurs, it doesn't know which monoid applies in any particular case. Finally, since performance issues aren't referentially transparent it could backfire depending on the context where foldMap is used.  You seem to want the compiler to be ""sufficiently devious"" rather than ""sufficiently smart"", but where the compiler isn't sufficiently smart to make all your performance issues go away non-strict evaluation makes reasoning about performance hard enough - having the compiler deviously replacing algorithms without telling you would make it impossible.  If you don't want to switch types just to use foldMap, you can switch to Seq, which makes different usually-more-scalable performance trade-offs but isn't so specialized as a difference list. That is, since the free monoid is a sequence, you can use Data.Sequence.  That said, while O(log(min(n1,n2))) for concatenation of Seq is good, difference lists are optimized for the case where there's lots of concatenation and little else - for the foldMap you might still do better using those.  And incidentally, difference lists are as much the free monoid as normal lists - the ADT is still a sequence.  Or of course someone else already mentioned toList. I'm not sure they understood, but intentionally or accidentally it was a good point - the following (untested) should give useful order-of-bracketing guidance to the compiler...  foldMapAsList :: Monoid m => (a -> m) -> t a -> m foldMapAsList f t = foldMap f $ toList t   Maybe that should be in the library alongside foldMap with notes about performance trade-offs - if you think so, I'm not the person you need to persuade."
haskell,36gvv9,ninereeds314,0,Wed May 20 05:43:04 2015 UTC,"As prophile said, foldMap is defined in terms of foldr, so it ""keeps the accumulating parameter on the right"""
haskell,36gvv9,decimalplaces,6,Tue May 19 10:31:25 2015 UTC,"As n-simplex says, this isn't really about folding a list, it's about folding to create a list. There used to be a list-specific foldMap in the prelude but these days the Foldable class is exported by the prelude so foldMap is generic in the kind of structure you're folding.  The Foldable instance might e.g. be some kind of tree structure with a list value at each leaf. The bracketing order for a foldMap over that tree is likely to depend on the structure of the tree, and so in general it won't ""keep the accumulating parameter on the right""."
haskell,36gvv9,ninereeds314,1 point,Tue May 19 12:21:03 2015 UTC,"Data.Foldable.foldMap is defined in terms of foldr. That is the default implementation, granted there is no guarantee the method is not overriden in the instance. foldr is really the default way of folding in lazy langauges, lazy foldl is suboptimal, so I would bet my money that whatever the instance implementation is it is still going to be accumulating on the right."
haskell,36gvv9,decimalplaces,2,Wed May 20 09:16:12 2015 UTC,"The reason foldMap is a method in the Foldable class is precisely so that instance can override the default. The normal reason to do that is because the structure you have can be efficiently folded in a different order. The obvious case where you'd want to use foldl rather than foldr is a snoc list, but there's more than two data structures in the world and more than two possible fold orderings.  For example the Seq instance foldMap delegates most of the job to the FingerTree foldMap.  instance Foldable (FingerTree v) where     foldMap _ Empty = mempty     foldMap f (Single x) = f x     foldMap f (Deep _ pr m sf) =         foldMap f pr `mappend` foldMap (foldMap f) m `mappend` foldMap f sf   Notice the Deep case, which uses mappend to concatenate three recursively-generated monoid-values. The accumulating parameter not only isn't on the right - there is no single accumulating parameter. This isn't a linear fold."
haskell,36gvv9,ninereeds314,1 point,Wed May 20 10:26:06 2015 UTC,"I was wrrong, so it would be better to use foldr in general then"
haskell,36duul,edsko,10,Mon May 18 16:37:44 2015 UTC,Thanks again to everyone who's contributed recently.
haskell,36duul,dcoutts,10,Mon May 18 16:43:46 2015 UTC,"Great work, all :)  Really amazing stuff."
haskell,36duul,mstksg,5,Mon May 18 18:25:25 2015 UTC,"Exciting stuff, thanks for all the hard work!"
haskell,36duul,akurilin,4,Tue May 19 04:24:32 2015 UTC,"Thanks!   I was always missing the link to the README badly. However, I'd say that displaying them inline is too much. READMEs can be quite large and they could cause problems with formatting."
haskell,36duul,mallai,5,Tue May 19 13:22:23 2015 UTC,"The current suggestions are:   display it at the end, like github does display the first N lines, with a link or expander (like the stackage website does)   and either   display the readme in place of the description, if there is no description always display the reamde and description, with description (usually short) at the top and reamde (usually long) at the bottom   Indeed this last option has some merit, we could encourage people to keep a description but really limit it to a paragraph or two, just for people to quickly scan and get an idea of what a package is for (useful for the search), while moving the longer stuff and examples / mini-tutorial into the readme. Currently we have some rather long and perhaps over-deailed descriptions which could be moved into the readme if we display the readme properly on the hackage page."
haskell,36duul,dcoutts,5,Tue May 19 14:22:21 2015 UTC,"So awesome! I've noticed a number of these with little delight bubbles.  I think replacing the description with the README when no description is set makes the most sense. And while you're at it, I suggest solving two problems by putting the properties and modules sections above the description. For every time I read a new package's description there's 2.7 years I've spent scrolling down to look at module structure, dependencies, and whether I'm actually looking at the latest version of the package because Google randomly sent me here (oh, can we do the incantation with the google sauce where we make Google search results go to the newest version of the package, plz?)"
haskell,36duul,jberryman,2,Tue May 19 15:02:18 2015 UTC,"oh, can we do the incantation with the google sauce where we make Google search results go to the newest version of the package, plz?   If you know what the incantation is, that'd be great. The most recent thing we've tried is putting in <link rel=""canonical"" href=...> into each page to link to the unversioned page, but it's not clear if this will help. The issue is that we want to make sure that links to documentation doesn't go stale, so our unversioned links to docs do a temp redirect to the specific latest version. The problem then is that the search engines point to the specific latest version (which gets out of date) rather than to the unversioned url that redirects. Clearly we could have a concrete resource for the unversioned version but then we'd get the oppostie problem of stale links as docs change. Solutions welcome."
haskell,36duul,dcoutts,1 point,Tue May 19 17:45:39 2015 UTC,"Oh, rel=""canonical"" is what I was thinking of. Sorry for the unhelpful comment!"
haskell,36d12v,tailcalled,9,Mon May 18 12:17:16 2015 UTC,Someone smart please make a morte decoder for javascript.
haskell,36d12v,latermuse,3,Mon May 18 14:44:10 2015 UTC,I'll need some time. I will PM you if I decide to do it and progress is made.
haskell,36d12v,pythonista_barista,9,Tue May 19 21:19:32 2015 UTC,"Awesome. I'm so excited for this!  I think the section on Linking is especially interesting because they motivate us putting more proofs in our code. For example, the definition of #False may change (and point towards #True) but if we include proofs of boolean laws, then we lessen the anxiety that a changed property would break current program behaviour (aside from an inability to compile - in which case you use your cached copy while the issue is resolved)."
haskell,36d12v,aaronlevin,5,Mon May 18 15:31:24 2015 UTC,That's right!  The trade off is that you must either statically link the type of the proof or import it from a trusted source.
haskell,36d12v,Tekmo,5,Mon May 18 15:34:51 2015 UTC,Could javascript/asm.js be targeted as a backend for this? Would that be a sensible alternative to ghcjs?
haskell,36d12v,leperLlama,3,Mon May 18 14:54:49 2015 UTC,"Yes.  Although, my original plan was to first target LLVM (since you can compile that to asm.js) and only then later provide a more idiomatic Javascript binding.  This wouldn't really replace GHCJS since it will never support the full Haskell language.  The restricted subset of Haskell you would be programming in would be very limited."
haskell,36d12v,Tekmo,3,Mon May 18 20:52:59 2015 UTC,"If we restrict to a fully statically typed subset of JavaScript, then we could also have JavaScript as a source"
haskell,36d12v,sinelaw,5,Mon May 18 21:53:41 2015 UTC,One thing about Morte that seems somewhat unclear to me is how to do dependent pattern matching (assuming it is intended as a fully functional dependently type language core).
haskell,36d12v,Tekmo,6,Mon May 18 12:21:22 2015 UTC,"You can do it in a restricted way, but it's not very powerful due to the lack of universe polymorphism.  For example, suppose you were to try encoding length-indexed vectors.  One approach might be to encode it as this eliminator:      forall (a : *) -> forall (n : Nat) ->  forall (Vector : Nat -> *) ->  forall (Cons : a -> Vector n -> Vector (Succ n)) ->  forall (Nil : n -> Vector Zero) -> Vector n a   However, using that eliminator you can't even write a type-safe head function of type:  head : Vector (Succ n) a -> a   The part where it breaks down is coming up with a proper eliminator for the Zero branch.  This is because the eliminator for Nat doesn't let you return a type.  For reference, here is the definition of Nat that I'm assuming:  forall (Nat : *) -> forall (Succ : Nat -> Nat) -> forall (Zero : Nat) -> Nat   You can fix this by either (A) using universe polymorphism or (B) using a different core calculus (Jon Sterling suggested Martin Lof type theory, for example).  So why even keep dependent types at all, then?  The main reason I still have them is because they allow you to model coherent instances.  For example, you can define a safe union function of type:  union : forall (o : Ord) -> forall (a : *) -> Set o a -> Set o a -> Set o a   In other words, you parametrize the Set type on an additional type parameter representing its Ord instance so that you can enforce that sets you union use the same instances.  However, even with that I'm still not convinced that this restricted form of dependent types are worth it and I may eventually use System Fw instead.  I'm postponing that decision until annah is complete because part of the scope of annah is come up with a shared set of terms/types/function/data-structures/side-effects that all interoperating lanuages must support and then by then I'll know better if the dependent types are worth it or not."
haskell,36d12v,Tekmo,4,Mon May 18 13:51:55 2015 UTC,"I'm thinking about rules like:  Gamma |- b: Boolean, T: Boolean -> * Gamma |- ifTrue: T(True), ifFalse: T(False) ---------------------------------------- Gamma |- if b then ifTrue else ifFalse : T(b)"
haskell,36d12v,Tekmo,4,Mon May 18 13:54:07 2015 UTC,That would not work (for the same reasons as the Vector example).  The part where it breaks down is actually defining a useful T function to supply to the eliminator.  If you expand out the type of T you get:  T : (forall (Bool : *) -> forall (True : Bool) -> forall (False : Bool) -> Bool) -> *   ... and the problem there is that you can't (usefully) use the eliminator for Bool to produce a type since the Bool type variable cannot itself be *.  The only T functions you'd be able to define are those that ignore the Bool that they are supplied.
haskell,36d12v,imz,3,Mon May 18 14:29:40 2015 UTC,"Exactly. However, it would be possible if you had a 'true' boolean type, with dependent eliminators and all."
haskell,36d12v,Tekmo,4,Mon May 18 14:36:51 2015 UTC,I know that Morte's dependent types are pretty neutered.  At some point I decided to just release what I had because I figure the idea (of a distributed Internet of typed expression fragments) was more important than the specific core calculus used as the carrier language.
haskell,36d12v,seriousreddit,2,Mon May 18 14:49:06 2015 UTC,Of course. I just wanted to double-check that I wasn't missing something in my knowledge about Morte.
haskell,36d12v,Tekmo,4,Mon May 18 14:50:34 2015 UTC,"Can this code be used from a Haskell program? (At least, theoretically.)  And what about other languages?  Where are the limits: which kind of programming languages can use this code and which can't?"
haskell,36d12v,sacundim,4,Mon May 18 13:54:28 2015 UTC,"The goal is to convert to and from restricted subsets of existing programming languages.  That means that you would be programming with a lowest-common-denominator of several languages, but with a bias towards functional languages and functional idioms.  This is analogous to how thrift is a lowest-common-denominator for language agnostic data structures and types, except that this will also include useful functions and side effects that every language must support.  So the issue is not what languages can use this, but rather what language features will be supported by this restricted format.  Things that you can encode are:   Side effects (by encoding it as a free monad) Recursion and mutual recursion Algebraic data types and pattern matching   Things that will probably be difficult to encode or not be shared as a lowest-common-denominator feature are:   Type classes Object-oriented programming Laziness (not because it's hard, but rather because few languages support laziness)"
haskell,36d12v,Tekmo,3,Mon May 18 14:39:10 2015 UTC,"Laziness (not because it's hard, but rather because few languages support laziness)   You could add call-by-push-value to CoC to get a clean encoding of laziness. This would make it possible to specify the evaluation model on a very fine grained scale as well."
haskell,36d12v,sacundim,2,Mon May 18 15:22:39 2015 UTC,"Actually, the issue there is not the implementation but rather the fact that so few target languages support laziness natively.  However, for communicating code between services all written in Haskell then you can assume more features in the encoder/decoder."
haskell,36d12v,latermuse,3,Mon May 18 15:32:11 2015 UTC,"Things that will probably be difficult to encode or not be shared as a lowest-common-denominator feature are: [...] Laziness (not because it's hard, but rather because few languages support laziness)   What exactly do you mean, then, when you say you're not going to support ""laziness""?  I do see in the morte tutorial in Hackage that you can encode corecursive types as streams with existentially-quantified seeds—which certainly covers many use cases of ""laziness.""  So does for that matter the free-monad encoding of effectful computations illustrated in the tutorial.  And if the language is total, well, evaluation order doesn't matter anyway, right?"
haskell,36d12v,drb226,3,Tue May 19 00:33:42 2015 UTC,"i meant that not all target languages that Morte would convert between would support laziness, but after reading your comment I realized that many languages support lazy generators, so I retract that statement.  Encoding laziness via corecursive types is easy, as you already pointed out."
haskell,36d12v,Tekmo,3,Tue May 19 00:52:12 2015 UTC,"I think we can go even lower-denominator than lazy generators.  There's no shortage of languages today that have objects with callable methods.  So a colist could be represented in a host language as an object with four methods:   isEmpty() and isPair() head() and tail() (which return a Maybe/Option result)   Since you're invoking code that can return objects, this can support a graph where no chain of tail() invocations ever reaches a object with isEmpty() == True.  Another alternative in some languages could be the Visitor Pattern.  For example, in Java:  interface Colist<A> {     <R> R accept(Visitor<A, R> visitor);      interface Visitor<A, R> {         R empty();         R pair(A head, CoList<A> tail);     } }   EDIT: Well, thinking about this again, I clearly only had the consumer case in mind.  Encoding values is another story..."
haskell,36d12v,imz,3,Tue May 19 01:26:31 2015 UTC,Morte can be used as a standard format between functional languages. You can use it to convert code from one functional language to another as long as both languages have implemented a morte encoder/decoder.
haskell,36d12v,imz,4,Mon May 18 14:40:06 2015 UTC,I'm curious if there are any specific motivating cases for this.
haskell,36d12v,imz,9,Tue May 19 01:09:30 2015 UTC,"Yes!  This is heavily inspired by my work at Twitter.  I'll give a couple of specific examples of problems that I was interested in applying this to:  Example 1: You're building a web API to filter and retrieve some data, so you end up defining your own bespoke query language using URL/form parameters or JSON.  Wouldn't be nice if you could just directly transmit the function (in a standard format) that you want to use to filter the data?  Example 2: You are writing a domain-specific tool that some sort of configuration file.  Under the hood you have some logging logic that you wish to let users customize, so every time somebody requests a new way to log things you add a new field to your configuration file that only one person/team cares about, which leads to configuration file bloat.  You could consolidate all these disposable fields into a single field where the user supplies their own logging logic.  Example 3: You want an easy way to distribute a tool, but you don't want to ask your users to curl into sh.  You need a solution that is typed (so you can restrict the set of permissible effects the installer can invoke, effectively sandboxing it) and normalizable (so any user can audit the normalized program with all indirection removed in order to view the exact sequence of steps it will perform).  Example 4: You want to estimate the performance of analytics jobs so that you can reserve machine resources in advance and fail jobs that are too expensive at compile time.  Wouldn't it be nice if you encode your analytics transformations in a language that was minimal, total, and normalizable so that it's highly amenable to static analysis to estimate computational cost?  Example 5: In many distributed analytics pipelines that horizontally scale you need a way to transmit code across machines.  For example, at Twitter we love using commutative monoids to parallelize and reorder analytics computations (see the algebird/scalding libraries), but for these monoids to be maximally effective the data structures and code must be transparently propagated across the entire pipeline (from the hadoop job, to the data storage format, to the query server, to the client).  Anywhere that we can't propagate the code and data structures invariably becomes a performance or API bottleneck.  It would be nice if the functions, types, and values derived from them could be seamlessly transmitted and distributed.  Note that I have not proposed any of these internally just yet since morte does not yet interop with any languages.  So far, the full extent of my internal communications has just been to keep saying ""Wouldn't it be nice if we had X?"" where X is one of Morte's features, mainly to mentally prime people for the idea.  Some people at Twitter read my blog (and /r/haskell) so they know about my side projects, but I'm waiting until the full language interop is working before I start pressing for morte's use internally."
haskell,36d12v,radomaj,3,Tue May 19 02:47:13 2015 UTC,"I have had very similar problems in my mind recently, namely similar to Example 1, 2, 5. And also another thing not covered by this list.  First, I formulated it for myself like something like: can I transfer a ""thunk"" between Haskell programs? My explorations left a trace of comments under How do I serialize or save to a file a Thunk?, Can Haskell functions be serialized?.  Having learnt a lot of limitations (not to say that it was merely impossible), I thought that everything is not so bad, actually. Because, say, in Example 2 or 1 we know that the program that would receive the configuration (or filter) expression is the one... I mean it is not an arbitrary program, it is a program with a more-or-less fixed set of named functions and data. (Perhaps, a different revision.)  And unlike Example 1, as I said, I had also a different situation in mind: the answer (response) of my program is a function. (Not the request, as in your Example 1.) (The domain of my tasks were things where the values are functions. Namely, the domain is natural language grammar, and the meanings of words and complex natural language expressions are usually formalized as functions--in the theories of formal semantics and sysntax--semantics interface.)  But here I also realized that having strong limitations on where this function from a response can go is not a big problem for me. The side that would receive the functional responses might not be interested in universal manipulations with these functions. Imagine I have a ""grammar agent"" which does all kind of grammatical combinations (constructs complex natural language expressions). The results (the natural language expressions) are functions. But they have two uses:   to build another complex natural language expression -- then they are sent back to the ""grammar agent"" for this operation; to give some interesting information to the outside world concerning their properties. But for this, the ""grammar agent"" would simply have a limited set of queries in its interface.   Of course, here we can count on the ""grammar agent"" being more or less the same program: perhaps, a different process or a different revision, but the main named functions and data would remain the same.  As for my Example 5, I thought that for parallellized computations, I would have the code shared between processes beforehand, and the computations would be composed from the basic building blocks (the named functions and data that are the same across processes) and transferred between the computation processes/""nodes"".  So, HdpH seemed to suggest something which could be a solution by allowing to build closures by function compositions and applications (not something present in the simpler system known under the name ""Cloud Haskell"") and transferring them.  P.S.  Unfortunately, I haven't had a chance to implement such a system, because the leaders of our project seem not to value having a tool for linguistic analysis (and research of formal linguistic theories) that could be plugged in for any specific task of building a precise formal grammar of a language or of using the built grammar for practical linguistic queries. They are more for: code an algorithm fast that would somehow approximate the missing bits in the grammar, get the bits, and throw the algorithm away."
haskell,36d12v,Tekmo,3,Tue May 19 08:25:00 2015 UTC,"I'll give a couple of specific examples of problems that I was interested in applying this to:   As I've told in my story above/below this comment, for the cases like your Examples 1 and 2 (and also for my case of responding with a function), I set out to implement this in my program by means of static_ptrs and HdpH and its closures.  That's a rigid and clean approach, but I also had a ""prankish"" thought suitable for Examples 1 and 2, at least; something that shouldn't be used in production, probably -- look below   Example 1: You're building a web API to filter and retrieve some data, so you end up defining your own bespoke query language using URL/form parameters or JSON. Wouldn't be nice if you could just directly transmit the function (in a standard format) that you want to use to filter the data?  Example 2: You are writing a domain-specific tool that some sort of configuration file. Under the hood you have some logging logic that you wish to let users customize, so every time somebody requests a new way to log things you add a new field to your configuration file that only one person/team cares about, which leads to configuration file bloat. You could consolidate all these disposable fields into a single field where the user supplies their own logging logic.   what if the program is run in GHCi? Then we can write the filtering expressions and the configuration stuff in GHCi while the program is already running, can't we? Then we skip over the use/need of static_ptrs from GHC.  I haven't thought this over well. It seems that GHCi (at least, for testing) gives the flexibility static_ptrs would give for production work. Perhaps someone has some comments.  Not very suitable though for one of my other goals: responding with functions. Unless there is a way to make sense of the output from :sprint which prints the thunks."
haskell,36d12v,kamatsu,3,Tue May 19 11:52:08 2015 UTC,"Another example would be of the kind (which I've mentioned in my story here aside):  a server sending a function to the user, which--when sent back--would cause a specific computation on the server.  Here the response is also a function. Not only the request.  This approach is taken in the HTML library in Curry (for forms, actions, etc.), but is implementable only in the Prolog-based implementation of Curry because it has the primitive to serialize and deserialize Curry code."
haskell,36d12v,Tekmo,3,Tue May 19 12:34:28 2015 UTC,Am I slow? Shouldn't doubleEven handle Zero?  EDIT: Fixed now. Good job on a quick response!
haskell,36d12v,kamatsu,2,Mon May 18 17:10:03 2015 UTC,"I forgot to include that case in the Haskell code example, but the implementation at http://sigil.place/post/0/doubleEven does handle the zero case (it has to, since Morte is total and forbids cheating).  I'll fix the post as soon as I can.  Edit: Fixed"
haskell,36d12v,Tekmo,1 point,Mon May 18 17:34:16 2015 UTC,I think you're correct. Paging /u/tekmo.
haskell,36d12v,kamatsu,3,Mon May 18 17:24:50 2015 UTC,Sounds very cool. Did you manage to figure out how to translate from morte-encodings of datatypes back into the Haskell style datatypes? That seems nontrivial to me.
haskell,36d12v,Tekmo,3,Tue May 19 11:39:15 2015 UTC,"It is nontrivial.  Part of what makes this an interesting problem is that you could accidentally transform code that was not generated using data types back into a data type!  For example, the polymorphic identity function:  \(a : *) -> \(x : a) -> x   ... could be resugared to this data type definition:  type a data x in x   ... which might not be what the user wanted!  However, there is a simple way to resugar them if you don't care about that problem.  The rough sketch (for data types without type parameters) is:   A data type definition must begin with a lambda that binds a type.   Like this one:  \(T0 : *) -> ...    For each lambda that binds a type in a row, you have one type declaration.   For example, this:  \(T0 : *) -> \(T1 : *) -> ...   ... translates to this:  type T0 ...  type T1 ...  in ...    Then for each argument after that you try to make it a constructor depending on what type it ends with.   For example, if you see:  \(T1 : *) -> \(T2 : *) -> \(C1 : forall (x : T3) -> T1) -> \(C2 : forall (y : T2) -> T2) -> ...   ... then it translates to:  type T1 data C1 (x : T3)  type T2 data C2 (x : T2)  in ...   ... and you're mostly done!  That covers the common cases and works for recursive types.  For example, if you resugared:  \(Nat : *) -> \(Succ : forall (pred : Nat) -> Nat) -> \(Zero : Nat) -> Succ (Succ (Succ Zero)))   ... you would get:  type Nat data Succ (pred : Nat) data Zero in Succ (Succ (Succ Zero))   ... which is the correct high-level version.  The part where it gets tricky is that eta-reduction interferes with this resugaring.  For example, suppose you have:  \(Nat : *) -> \(Succ : Nat -> Nat) -> \(Zero : Nat) -> Succ Zero   ... that will eta-reduce to:  \(Nat : *) -> \(Succ : Nat -> Nat) -> Succ   ... and then it will not resugar correctly.  I mean, technically the resugaring would still work, but it wouldn't be what the human expected:  type Nat data Succ Nat in Succ   The other part where it gets tricky is working with type variables, which slightly complicate the resugaring since it's not immediately clear which bound types are type variables and which ones are type constructors, so you have to do a little backtracking search to try out different possible solutions, but there will only be at most one unique solution."
haskell,36d12v,rdfox,3,Tue May 19 14:00:37 2015 UTC,How do you deal with this eta-reduction problem?
haskell,36d12v,Peaker,5,Tue May 19 14:14:17 2015 UTC,"I have no idea.  I'm still figuring it out.  I'm also not 100% sure that what I'm doing is sound or complete, yet.  This is still basically a research problem."
haskell,36d12v,Tekmo,1 point,Tue May 19 14:31:46 2015 UTC,"Could you not simply encode the regular tree types directly, with constructors and eliminators and reduction rules, rather than encode them using Böhm-Berarducci? This would at least give you an accounting of what things are types and what things are values."
haskell,36d12v,mooglefrooglian,2,Wed May 20 13:04:31 2015 UTC,"I want to keep the core language as small as possible so that if any target language lacks any higher-level feature (such as pattern matching), it could always fall back to a literal translation of the calculus of constructions (using lambdas) as a last resort, even if it generates non-idiomatic code.  I want this to be as portable as possible."
haskell,36d12v,Crandom,2,Wed May 20 14:36:16 2015 UTC,I guess today is as good a day as any to find out what's this lambda calculus thing everyone keeps going on about.
haskell,36dfcx,pigworker,10,Mon May 18 14:36:14 2015 UTC,"The link gives you videos and slides from a lovely meeting in Dundee, spoiled only by my participation.   Tom Schrijvers GADTs Meet Their Match: Pattern-matching Warnings that Account for GADTs, Guards, and Laziness Conor McBride Type Inference needs Revolution J. Garrett Morris Substructural Types with Class Bob Atkey An Algebraic Approach to Typechecking and Elaboration Katya Komendantskaya Structural Resolution and Universal Productivity Checker Peng Fu Nontermination Analysis for Evidence Construction in Type Class Inference Edwin Brady Implementing a Dependently Typed Programming Language Adam Gundry A Typechecker Plugin for Units of Measure: Domain-specific Constraint Solving in GHC Haskell"
haskell,36dfcx,gasche,2,Mon May 18 14:39:14 2015 UTC,"This is very cool, thanks. Next time, please encourage Edwin Brady to keep a written form (eg. preparation notes) of his presentation!  Edit: it looks like slides were just added. Or at least I hadn't seen them before. Sorry fo the noise."
haskell,36dfcx,gasche,2,Thu May 21 09:33:21 2015 UTC,"Peng Fu: Nontermination Analysis for Evidence Construction in Type Class Inference (slides)   I am not convinced that rewriting is the right way to look at type-class elaboration. I find it more natural as a proof search process, or even a code search process (because unlike the common perception of proof terms, the identity of elaboration witnesses matters as they influence the dynamic semantics; it is by observing this identity that we should talk about coherence). Rewriting might be a good framework in which to consider termination problems, but proof search also has had a fair share of work on detecting cycles and ensuring search termination."
haskell,36euau,dstcruz,4,Mon May 18 20:58:54 2015 UTC,"https://registry.hub.docker.com/u/library/haskell provides ghc and cabal, at least."
haskell,36euau,ReinH,1 point,Mon May 18 23:25:24 2015 UTC,"The source repo has the Dockerfiles as well. There has been some interest in a ""slim"" image, but so far there hasn't been a good description of what we'd drop from the current image."
haskell,36euau,biscarch,1 point,Tue May 19 16:47:50 2015 UTC,"Well, just by using debian instead of ubuntu it already saves a few hundred megabytes..."
haskell,36euau,ReinH,1 point,Tue May 19 19:52:11 2015 UTC,"They are using debian:jessie as a base, which is 125.2mb"
haskell,36euau,biscarch,1 point,Wed May 20 02:14:29 2015 UTC,"Yeah, that's what I said. By using debian jessie they are already saving a few hundred megabytes over ubuntu."
haskell,36euau,ReinH,1 point,Wed May 20 05:35:30 2015 UTC,ah. sorry. I misinterpreted.
haskell,36euau,biscarch,3,Wed May 20 07:10:27 2015 UTC,What's the motivation/benefit of using a Docker environment for Haskell development? Doesn't it complicate everything compared to Docker-less Haskell dev-env?
haskell,36euau,RedLambda,2,Tue May 19 08:00:10 2015 UTC,"I develop on Linux (on a Mac in an Ubuntu VM) and it simplifies my life. I always assumed it adds some complications for those that primarily develop on a Mac.  The benefits are isolation and environmental parity with production. Before docker I always saw issues that did not show up on developer's machines that showed up during a production build or while running in production. These issues are a lot fewer now and easier to figure out. I use some of the same install scripts that are used for building or running in production. These installs are isolated from the rest of my system. That way I can work on 2 projects at once without any worries about system conflicts. Additionally, if my computer turns into a brick, or if I switch to a new computer I can quickly bring up a project environment again because docker requires you to describe your environment."
haskell,36euau,eegreg,1 point,Tue May 19 12:26:53 2015 UTC,"I have mac on desktop and linux on server. Docker allows me to build stuff on desktop which can be handy. Also, the mac in question is so old that it can't support latest os:s which makes installing the haskell tool chain a bit of a challenge.."
haskell,36euau,aleator,1 point,Tue May 19 09:04:49 2015 UTC,"Use any GHC version you want, easily."
haskell,36euau,theonlycosmonaut,1 point,Tue May 19 11:45:30 2015 UTC,"With hvr's Ubuntu PPA, I have that already at least in Linux. I just flip my PATH between /opt/ghc/7.10.1, 7.8.4, etc."
haskell,36euau,Mob_Of_One,1 point,Tue May 19 16:09:27 2015 UTC,On OSX you can use https://ghcformacosx.github.io/ to achieve the same thing (which is what I did before Docker and the Docker library/haskell images use hvr's ppa anyway)
haskell,36euau,biscarch,1 point,Tue May 19 16:41:30 2015 UTC,I use GHC For Mac OS X on my Macbooks.  I've only had bad experiences with Docker tho.
haskell,36euau,Mob_Of_One,1 point,Tue May 19 19:40:28 2015 UTC,What were your bad experiences with Docker?
haskell,36euau,codygman,1 point,Wed May 20 05:32:25 2015 UTC,"Mostly centered around production use. Not very stable, hard to do anything non-trivial with their provisioning stuff. This is partly why people end up provisioning Docker instances from Puppet. Intra-docker-instance networking (like...talking to PostgreSQL from a web app) made us pull our hair out.  Problem is, if I've gone to the trouble of making a reliable Puppet config for my stuff, I don't need Docker anymore. Most AWS machines are so sad and overloaded that I have zero desire to slice and dice that EC2 instance any further."
haskell,36euau,Mob_Of_One,2,Wed May 20 06:07:38 2015 UTC,"I tend to simply boot up the stock Haskell container and run bash in it, treating it as a regular VM with my source dir mounted."
haskell,36euau,theonlycosmonaut,1 point,Tue May 19 11:46:54 2015 UTC,I have one for ghc hacking: https://github.com/gregwebs/ghc-docker-dev  For normal Haskell development I now just throw a few things on top of the standard Haskell image along the lines of   RUN apt-get install git libgmp-dev xz-utils RUN apt-get install -y libssl-dev ca-certificates libtinfo-dev authbind RUN cabal update && cabal install stackage-update stackage-install && stackage-update   So a Haskell dev environment image is definitely useful. It is just a question as to whether there are enough common interest installations or if everyone will want to just customize off the base haskell image instead.
haskell,36euau,eegreg,1 point,Tue May 19 01:09:12 2015 UTC,I hadn't thought of having a Haskell image with stackage installed. I shall have to give this a try!
haskell,36euau,theonlycosmonaut,2,Tue May 19 11:47:56 2015 UTC,I added an Dockerfilewith more stackage stuff pre-installed here: https://github.com/yesodweb/yesod/blob/master/Dockerfile
haskell,36euau,eegreg,1 point,Thu May 28 03:48:02 2015 UTC,Thanks! I'll be sure to give it a go sometime.
haskell,36euau,theonlycosmonaut,1 point,Thu May 28 06:17:33 2015 UTC,Will this one do? https://registry.hub.docker.com/u/tfcross/hoh-chennaihaskell/dockerfile/
haskell,36e0bv,ababkin,2,Mon May 18 17:18:30 2015 UTC,"I'm very interested in this as well. Could just compile to javascript via ghcjs in the meantime. Could you post your exact code here? I'd like to repro, seeing that I'm going to use lambda at work too."
haskell,36e0bv,dmjio,1 point,Mon May 18 18:01:32 2015 UTC,"sure, the haskell program is trivial - just outputs ""hello"" string to stdio here is the javascript code (commented out is just another version that was suggested on the net, tried both of them without luck)  process.env['PATH'] = process.env['PATH'] + ':' + process.env['LAMBDA_TASK_ROOT']  // var child_process = require('child_process'); // exports.handler = function(event, context) {     // var proc = child_process.spawn('./lambda-test', [ JSON.stringify(event) ], { stdio: 'inherit' });      // proc.on('close', function(code) {         // if(code !== 0) {             // return context.done(new Error(""Process exited with non-zero status code""));         // }          // context.done(null);     // }); // }  var exec = require('child_process').execFile;  exports.handler = function(event, context) {     exec('./lambda-test', function(err, data) {         console.log(err)         console.log(data.toString());         context.done(null, data.toString());     }); }"
haskell,36e0bv,crb002,1 point,Mon May 18 18:47:35 2015 UTC,"Easy mode is to compile your Haskell application to a binary then exec it on the shell with node.js.  Otherwise, you will have to use node's FFI."
haskell,36e0bv,crb002,2,Mon May 18 18:20:15 2015 UTC,"unless i am missing something, this is exactly what i was trying to do - execute a binary executable file from node.js"
haskell,36az3n,davidchristiansen,22,Sun May 17 22:13:06 2015 UTC,"I love hacking around in this language so much. Even without understanding all the esoteric academics behind dependent type theory, I've found using them surprisingly easy and intuitive, and I'm constantly finding cases in my day job where I wish I had them available.  Possibly my favorite thing about Idris compared to Haskell is the interface of the repl/IDE. Programming in Haskell mostly feels like the type checker prevents me from making mistakes, but it doesn't actually help me find the right answer. It just tells me ""No, that's wrong. No, that's wrong, too. Ok, that type checks."" And sometimes it takes me a long time to actually figure out how to make the type checker happy. In contrast, Idris actually offers suggestions -- instead of ""No, that's wrong"", Idris can tell you ""How about this? It type checks, is it what you're looking for?"" It's fantastic.  Oh, and the output is nice and color-coded, like in Rust, which allows me to parse compiler messages much more quickly than monochromatic text. Small thing, but it's a big usability improvement for me."
haskell,36az3n,dnkndnts,12,Mon May 18 07:14:05 2015 UTC,I completey agree. Despite being so young (or maybe it's even because of that?) the tooling is way ahead of haskell. And because everything is already built into the compiler it doesn't break as easily with new versions.
haskell,36az3n,cocreature,13,Mon May 18 08:09:12 2015 UTC,"Thanks! I think that compilers these days should take editor and IDE support just as seriously as they took REPL support in the 90s and 2000s. With Idris, we're fortunate to have a small enough and hackable enough compiler to make that happen with the spare time of a couple of grad students."
haskell,36az3n,pjmlp,4,Mon May 18 08:39:29 2015 UTC,"Fully agree.  As personal anecdote, Borland IDE's spoiled me as minimal set of IDE features I have came to expect from any language.  Then afterwards came the Smalltalk, Oberon, Caml Light experiences.  All workflows that I look for in any modern IDE."
haskell,36az3n,pjmlp,2,Mon May 18 11:07:21 2015 UTC,"I'd love to hear what rubs you the wrong way in Idris and idris-mode, should you attempt to use them - I really want Idris to support turning dumb text editors into featureful IDEs with a minimum of effort!"
haskell,36az3n,bss03,3,Mon May 18 14:45:20 2015 UTC,"I would like to explore Idris, but so far I only managed to watch a few recoded presentation and the available papers.  My job is related to consulting on the JVM/.NET eco-systems, so there is zero chances I could make use of Idris.  However as language geek, I like to learn about programming language research, as it was one of my strong focus in my degree.  Regarding IDEs, some of the features I love when they are available are:   integration of build tools as the project format some kind of REPL, workspace code navigation (go to definition, find usages with semantic info, ...) code completion tooltips with documentation and type information graphical debugging, including visual representation of data structures integration with ALM tools easy navigation between error messages, failed tests and source code semantic refactoring integration with profiling tools"
haskell,36az3n,againstmethod,3,Mon May 18 22:16:40 2015 UTC,Thanks for the list! It's good food for thought.
haskell,36az3n,againstmethod,11,Wed May 20 14:43:19 2015 UTC,"One thing to note with tooling, though, is that there are things that can be done with Haskell tools that we can't yet do. A limitation of Idris's internals is that all type checking is happening on a lossy translation to a core language. We maintain enough source information to point errors at the right spot in the file, but not enough to reconstruct the original tree - there's just a heuristic translation that attempts to reconstruct a source tree that fits the core term involved. This means we don't have a reasonable way to implement nice features like ghc-mod's ""type of expression at point"", structured-haskell-mode's tree-aware editing, or even simple refactoring tools like renaming an identifier across a module or alpha-converting a local binding.  I wish I had time to make those things happen."
haskell,36az3n,lw9k,3,Mon May 18 08:46:15 2015 UTC,"We maintain enough source information to point errors at the right spot in the file   Mostly.  I've definitely had some ""called with too-many / too-few arguments"" errors that end up just pointing to filename:0.0 or <interactive>:0.0."
haskell,36az3n,lw9k,7,Mon May 18 14:41:49 2015 UTC,Agh! Would you please report these at the issue tracker when they arise? I thought I had squished them all.  Thanks!
haskell,36az3n,spirosboosalis,2,Mon May 18 14:42:41 2015 UTC,"Are there any benchmarks for it?  A great IDE is wonderful, but if i have to drop a few editing features to get reasonable performance, i normally will make that trade."
haskell,36az3n,roche,3,Mon May 18 12:01:55 2015 UTC,"We don't have any benchmarks for idris-mode. It's still nothing as nice as what you can get with structured-haskell-mode or ghc-mod with regards to editing. What I've worked hardest on has instead been introspective features, for doing things like getting documentation, searching the library, and understanding error messages."
haskell,36az3n,roche,3,Mon May 18 12:30:47 2015 UTC,"I meant for the idris language itself, application performance.  Those all sound like cool features."
haskell,36az3n,ponchedeburro,6,Mon May 18 13:35:14 2015 UTC,"Ah, I see what you mean. We haven't yet thrown together a comprehensive set of benchmarks, and you should expect Idris to be fast enough for many reasonable things, but slow in various ugly ways. For example, there's still no unboxed values, which will hurt in performance-sensitive areas. Also, it's a research language, and regressions may happen - I wouldn't recommend using Idris in your business at this time, unless you plan on employing some compiler hackers!"
